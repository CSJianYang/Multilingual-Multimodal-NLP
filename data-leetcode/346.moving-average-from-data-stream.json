[
    {
        "title": "Permutations",
        "question_content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n&nbsp;\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 6\n\t-10 <= nums[i] <= 10\n\tAll the integers of nums are unique.",
        "solutions": [
            {
                "id": 18239,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 18247,
                "title": "my-elegant-recursive-c-solution-with-inline-explanation",
                "content": "This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations [here][1]. All comments are welcome.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n    \\t    vector<vector<int> > result;\\n    \\t    \\n    \\t    permuteRecursive(num, 0, result);\\n    \\t    return result;\\n        }\\n        \\n        // permute num[begin..end]\\n        // invariant: num[0..begin-1] have been fixed/permuted\\n    \\tvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\\t{\\n    \\t\\tif (begin >= num.size()) {\\n    \\t\\t    // one permutation instance\\n    \\t\\t    result.push_back(num);\\n    \\t\\t    return;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = begin; i < num.size(); i++) {\\n    \\t\\t    swap(num[begin], num[i]);\\n    \\t\\t    permuteRecursive(num, begin + 1, result);\\n    \\t\\t    // reset\\n    \\t\\t    swap(num[begin], num[i]);\\n    \\t\\t}\\n        }\\n    };\\n\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2014/12/permutations.html",
                "solutionTags": [
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n    \\t    vector<vector<int> > result;\\n    \\t    \\n    \\t    permuteRecursive(num, 0, result);\\n    \\t    return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18296,
                "title": "simple-python-solution-dfs",
                "content": "        \\n    # DFS\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n        \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            # return # backtracking\\n        for i in xrange(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    # DFS\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n        \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            # return # backtracking\\n        for i in xrange(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "codeTag": "Python3"
            },
            {
                "id": 993970,
                "title": "python-4-approaches-visuals-time-complexity-analysis",
                "content": "--------------------------\\n**Approach 1: Recursive with backtracking (implicit stack)**\\n--------------------------\\n--------------------------\\n\\n**Big-O:**\\n- **Time:** `O(N*N!)` \\n\\t- **Why O(N*N!) and not just O(N!) ?**\\n\\tMany people are debating in the solution tab whether time-complexity should be `O(N!)` or `O(N * N!)`. Below are two intuitive arguments as to why it should be `O(N*N!)`. Let\\'s forget for a while about the recursive nature of the algorithm and examine  the **N-ary, recursive, space-tree** that is generated by the recursive algorithm. \\n\\t\\t\\n\\t\\t![image](https://assets.leetcode.com/users/images/ac9c35dc-89b8-4860-b08c-d2f60859e43e_1609289801.6830964.png)\\n\\t\\t\\n\\t1) In order to reaverse the tree, will visit each node once, we know very well that would cost us `O(N)` in a binary tree and `O(E+V)` in an N-ary tree where V = vertices and E = edges (or number of children). Now for the [1,2,3] example shown in the sketch, we can see there is a total of 16 nodes/verticies and that |E| varies from level to level with an upper limit of N and a lower limit of 1.\\n\\t\\t* So, we can say roughly O(E+V) = a little more than 16\\t\\n\\t\\t* O(N!) on the other hand = 6\\n\\t\\t* whereas, O(N*N!) = 3*6 = 18\\n\\n\\t2) Another way of looking at is we know from set theory that there are N! permutations of a list of size N. We also know that the permutations are going to be the leaves of the tree, which means we will have N! leaves. In order to get to each one of those leaves, we had to go through N calls. That\\'s O(N*N!). Again a little more than the total number of nodes because some nodes are shared among more than one path.\\n\\n\\n- **Space:** `O(N!)` \\n\\t- Because you still need to store the permutations and there are N! of them even if the depth of the stack is maxed out at N+1 (depth of the recursion space-tree is also N+1). See figure below.\\n\\n\\n**Code:**\\n```\\ndef permute(self, nums):\\n\\t# helper\\n\\tdef recursive(nums, perm=[], res=[]):\\n\\t\\tif not nums: # -- NOTE [1] \\n\\t\\t\\tres.append(perm[::]) #  -- NOTE [2] - append a copy of the perm at the leaf before we start popping/backtracking\\n\\n\\t\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tperm.append(nums[i])\\n\\t\\t\\trecursive(newNums, perm, res) # - recursive call will make sure I reach the leaf\\n\\t\\t\\tperm.pop() # -- NOTE [3] \\n\\t\\treturn res\\n\\nreturn recursive(nums)\\n\\n# NOTE [1]:\\n# --------\\n# nums is empty at the leaf of the recursive tree\\n\\n# NOTE [2]:\\n# --------\\n# at the leaf -> we know we have exaushted one path/permutation (each path is a permutation in a recursive tree)\\n# reason why we are copying here is because at lists are passed by reference and since we are maintaining only one path/perm variable throughput, we are gonna be modifiying that path variable (popping it to be precise) in order to revert the path to a previous state (aka parent node) in preperation to make a lateral/horizontal move to a sibling node. See explanation below for further understanding.\\n\\n# NOTE [3]:\\n# ---------\\n# See below\\n```\\n\\n**NOTE [3] Explained further : Why do we need to backtrack?** \\n\\n* Notice how in the code above, there is only one variable path (or perm) throughout the problem. This variable is passed to one recursive call after another recursive call as we move from the input (the root of the tree) to the leaf (the permutation) and obvioulsy it gets modified multiple times along the way. As we keep building the path (or perm). It goes from `[ ] -> [1,2] -> [1,2,3]` as you can see in the left-most branch. However, what actually happens is that everytime we append a number to the path, **we are actively changing the path from previous recursive states as well**, since all of these point to the same path list and are not independent states/copies. Since effectively all these aliases are pointing to the same memory location, any change to the variable are echoed to all of its aliases. This can be problematic because it alters the the previous states. See below for visual illustration of the problem.\\n\\t\\n![image](https://assets.leetcode.com/users/images/2dad4626-ba5b-4d8f-adcb-90249a1eddb4_1609299083.319523.png)\\n\\n\\n\\n* To overcome this problem, we need to backtrack. It\\'s tempting to think backtracking is needed only in situations where we encounter an obstacle while building/searching for the solution (such as hitting a wall while traversing a maze), however, backtracking as a technique has broader scope than just that. Any situation where we might need to access a previous state of a variable that keeps changing during the execution of the program requires backtracking. As mentioned earlier an coming across an obstacle in a maze (or anything that renders the path being explored invalid) is NOT the only incident backtracking is called upon. Backtracking would still be required even if the current path being explored is valid, in order to explore the next path. Think of a parent node from which two child nodes diverge. After exploring the first child, we need to backtrack to parent to investigate the sibling node (other child). This situation takes place in our space-tree. See sketch below.\\n\\n![image](https://assets.leetcode.com/users/images/ea5e3934-308b-486b-bd9d-ba5d84972c93_1609311308.955607.png)\\n\\n\\n- As you can see in the sketch above, by the time we reach node B, the path = [1,2,3]. These changes are echoed up to the parent node and even all the way up to the root if we don\\'t backtrack which will ruin subsequent paths (ex: ParentNode -> node C) is missed up. This can be alleviated by popping the path after each recursive call as we did in our code.\\n\\n\\t```\\n\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\tperm.append(nums[i])\\n\\t\\trecursive(newNums, perm, res) \\n\\t\\tperm.pop() # -- BACKTRACK\\n\\t```\\n\\n- It\\'s also worth-mentioning that backtracking was needed here because of the branching nature of the space-tree. Backtracking won\\'t be required if the recursive algorithm produces a linked-list rather than a space-tree. An example of such algorithm is recursively summing up numbers from 0 -> N\\n\\n\\t```\\n\\tdef sumPosNumLessThanN(N, res=0):\\n\\t\\tif N == 0:\\n\\t\\t\\treturn res\\n\\t\\telse:\\n\\t\\t\\tres = 1 + sumPosNumLessThanN(N-1)\\n\\t\\treturn res\\n\\t```\\n\\t\\n\\tThe recursive algorithm above produces a chain of nodes (no branching):\\n![image](https://assets.leetcode.com/users/images/65a431a3-c09d-4926-b431-8df5eb2a4cf3_1609312872.9623408.png)\\n\\n**NOTE [2] Explained further : Why do we need to copy?** \\n- You probably have guessed it by now. As shown above, due to the constantly changing state of our data/variables, we need to append a copy of the path `res.append(path[::])` at the leaf, instead of appending the path itself. The reason being that lists are mutable and are passed by reference, so even after appending a path to our result list, that path will still be affected by any changes to its aliases (will be afftected by all the poppping and backtracking taking place) and by the time our recursion calls make their way to the top/root, the path will be empty `path = [ ]`\\n\\n**Backtracking seems like a pain in the a$$. Is there a way around it?**\\n* Glad you asked, yes, there is! We can avoid backtracking all together with a little bit of book-keeping. Instead of having to backtrack to revert to a previous state of the data/variables, we could save snapshots of the data/variables at each step along the way so that we never have to manually backtrack. This can be done either recursively or iteratively by passing a copy of our data. See Approach 2 for recursive without backtracking, and Approach 3 for an itertaive solution without backtracking below.\\n.\\n.\\n--------------------------\\n**Appraoch 2: Recursive without backtracking (implicit stack)**\\n--------------------------\\n--------------------------\\n**Big-O:**\\n- Time: `O(N*N!)`\\n- Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef recursive(nums, perm=[], res=[]):\\n        \\n            if not nums: \\n                res.append(perm) # --- no need to copy as we are not popping/backtracking. Instead we\\'re passing a new variable each time \\n\\n            for i in range(len(nums)): \\n                newNums = nums[:i] + nums[i+1:]\\n                # perm.append(nums[i]) # --- instead of appending to the same variable\\n                newPerm = perm + [nums[i]] # --- new copy of the data/variable\\n                recursive(newNums, newPerm, res) \\n                # perm.pop()  # --- no need to backtrack\\n            return res\\n        \\n        return recursive(nums)\\n```\\n\\n**How backtracking was avoided?  Approach 2 vs. Approach 3**\\n* Below is a comparison between the two approaches. Notice how on the left side, only one `perm/path` variable is maintained throughout as opposed to multiple `perm/path` snapshots at each step on the right hand side.\\n\\n![image](https://assets.leetcode.com/users/images/0a74e098-5a23-4859-8518-2ffe513ea965_1609340194.1382449.png)\\n\\n\\n* Illustartions above are generated using this [Python Tutor tool](http://www.pythontutor.com/visualize.html#mode=edit)\\n\\t* Approach 2 : Recursive w backtracking : [here](        http://www.pythontutor.com/visualize.html#code=def%20recursivePermute%28nums,%20perm%3D%5B%5D,%20res%3D%5B%5D%29%3A%0A%20%20%20%20if%20not%20nums%3A%20%0A%20%20%20%20%20%20%20%20res.append%28perm%29%20%0A%20%20%20%20%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20for%20i%20in%20range%28len%28nums%29%29%3A%20%23%20%5B1,2,3%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20newNums%20%3D%20nums%5B%3Ai%5D%20%2B%20nums%5Bi%2B1%3A%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20perm.append%28nums%5Bi%5D%29%0A%20%20%20%20%20%20%20%20%20%20%20%20recursivePermute%28newNums,%20perm,%20res%29%20%23%20-%20recursive%20call%20will%20make%20sure%20I%20reach%20the%20leaf%0A%20%20%20%20%20%20%20%20%20%20%20%20perm.pop%28%29%20%0A%0A%20%20%20%20return%20res%0A%0Aprint%28recursivePermute%28%5B1,2,3%5D%29%29&cumulative=false&curInstr=25&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\\n)\\n\\t* Approach 3: Recursive w/o backtracking : [here](http://www.pythontutor.com/visualize.html#code=def%20recursivePermute%28nums,%20perm%3D%5B%5D,%20res%3D%5B%5D%29%3A%0A%20%20%20%20if%20not%20nums%3A%20%0A%20%20%20%20%20%20%20%20res.append%28perm%5B%3A%3A%5D%29%20%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20for%20i%20in%20range%28len%28nums%29%29%3A%20%23%20%5B1,2,3%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20newNums%20%3D%20nums%5B%3Ai%5D%20%2B%20nums%5Bi%2B1%3A%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20newPerm%20%3D%20perm%20%2B%20%5Bnums%5Bi%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20recursivePermute%28newNums,%20newPerm,%20res%29%20%23%20-%20recursive%20call%20will%20make%20sure%20I%20reach%20the%20leaf%0A%0A%20%20%20%20return%20res%0A%0Aprint%28recursivePermute%28%5B1,2,3%5D%29%29&cumulative=false&curInstr=23&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)\\n.\\n.\\n--------------------------\\n**Approach 3 : DFS Iterative with Explicit Stack**\\n--------------------------\\n--------------------------\\n**Big-O:**\\n- Time: `O(E+V)` which is the same as => `O(N*N!)`\\n- Space: `O(N!)`\\n\\n**Code:**\\n```       \\ndef recursive(nums):\\n\\t stack = [(nums, [])]   # -- nums, path (or perms)\\n\\t res = []\\n\\t while stack:\\n\\t\\t nums, path = stack.pop()\\n\\t\\t if not nums:\\n\\t\\t\\t res.append(path)\\n\\t\\t for i in range(len(nums)):   # -- NOTE [4]\\n\\t\\t\\t newNums = nums[:i] + nums[i+1:]\\n\\t\\t\\t stack.append((newNums, path+[nums[i]]))  # --  just like we used to do (path + [node.val]) in tree traversal\\n\\t return res\\n\\n# NOTE [4]\\n# The difference between itertaive tree/graph traversal we did before and this one is that\\n# in most tree/graph traversals we are given the DS (tree/graph/edges) whereas here we have to build the nodes before we # traverse them\\n# Generating the nodes is very simple, we Each node will be (nums, pathSofar)\\n```\\n\\n.\\n.\\n--------------------------\\n**Approach 4 : BFS Iterative with a queue**\\n--------------------------\\n--------------------------\\n**Big-O:**\\n- Time: `O(E+V)` which is the same as => `O(N*N!)`\\n- Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef recursive(nums):\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((nums, []))  # -- nums, path (or perms)\\n\\tres = []\\n\\twhile q:\\n\\t\\tnums, path = q.popleft()\\n\\t\\tif not nums:\\n\\t\\t\\tres.append(path)\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tq.append((newNums, path+[nums[i]]))\\n\\treturn res\\n        \\n```\\n\\n- **For JAVA implementation of all 4 approaches : checkout this post** => https://leetcode.com/problems/permutations/discuss/996115/Java-4-Approaches-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef permute(self, nums):\\n\\t# helper\\n\\tdef recursive(nums, perm=[], res=[]):\\n\\t\\tif not nums: # -- NOTE [1] \\n\\t\\t\\tres.append(perm[::]) #  -- NOTE [2] - append a copy of the perm at the leaf before we start popping/backtracking\\n\\n\\t\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tperm.append(nums[i])\\n\\t\\t\\trecursive(newNums, perm, res) # - recursive call will make sure I reach the leaf\\n\\t\\t\\tperm.pop() # -- NOTE [3] \\n\\t\\treturn res\\n\\nreturn recursive(nums)\\n\\n# NOTE [1]:\\n# --------\\n# nums is empty at the leaf of the recursive tree\\n\\n# NOTE [2]:\\n# --------\\n# at the leaf -> we know we have exaushted one path/permutation (each path is a permutation in a recursive tree)\\n# reason why we are copying here is because at lists are passed by reference and since we are maintaining only one path/perm variable throughput, we are gonna be modifiying that path variable (popping it to be precise) in order to revert the path to a previous state (aka parent node) in preperation to make a lateral/horizontal move to a sibling node. See explanation below for further understanding.\\n\\n# NOTE [3]:\\n# ---------\\n# See below\\n```\n```\\n\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\tperm.append(nums[i])\\n\\t\\trecursive(newNums, perm, res) \\n\\t\\tperm.pop() # -- BACKTRACK\\n\\t```\n```\\n\\tdef sumPosNumLessThanN(N, res=0):\\n\\t\\tif N == 0:\\n\\t\\t\\treturn res\\n\\t\\telse:\\n\\t\\t\\tres = 1 + sumPosNumLessThanN(N-1)\\n\\t\\treturn res\\n\\t```\n```\\ndef recursive(nums, perm=[], res=[]):\\n        \\n            if not nums: \\n                res.append(perm) # --- no need to copy as we are not popping/backtracking. Instead we\\'re passing a new variable each time \\n\\n            for i in range(len(nums)): \\n                newNums = nums[:i] + nums[i+1:]\\n                # perm.append(nums[i]) # --- instead of appending to the same variable\\n                newPerm = perm + [nums[i]] # --- new copy of the data/variable\\n                recursive(newNums, newPerm, res) \\n                # perm.pop()  # --- no need to backtrack\\n            return res\\n        \\n        return recursive(nums)\\n```\n```       \\ndef recursive(nums):\\n\\t stack = [(nums, [])]   # -- nums, path (or perms)\\n\\t res = []\\n\\t while stack:\\n\\t\\t nums, path = stack.pop()\\n\\t\\t if not nums:\\n\\t\\t\\t res.append(path)\\n\\t\\t for i in range(len(nums)):   # -- NOTE [4]\\n\\t\\t\\t newNums = nums[:i] + nums[i+1:]\\n\\t\\t\\t stack.append((newNums, path+[nums[i]]))  # --  just like we used to do (path + [node.val]) in tree traversal\\n\\t return res\\n\\n# NOTE [4]\\n# The difference between itertaive tree/graph traversal we did before and this one is that\\n# in most tree/graph traversals we are given the DS (tree/graph/edges) whereas here we have to build the nodes before we # traverse them\\n# Generating the nodes is very simple, we Each node will be (nums, pathSofar)\\n```\n```\\ndef recursive(nums):\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((nums, []))  # -- nums, path (or perms)\\n\\tres = []\\n\\twhile q:\\n\\t\\tnums, path = q.popleft()\\n\\t\\tif not nums:\\n\\t\\t\\tres.append(path)\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tq.append((newNums, path+[nums[i]]))\\n\\treturn res\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18284,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18237,
                "title": "my-ac-simple-iterative-java-python-solution",
                "content": "the basic idea is, to permute n numbers, we can add the nth number into the resulting `List<List<Integer>>` from the n-1 numbers, in every possible position. \\n\\nFor example, if the input num[] is {1,2,3}: First, add 1 into the initial `List<List<Integer>>` (let's call it \"answer\"). \\n\\nThen, 2 can be added in front or after 1. So we have to copy the List<Integer> in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.\\n\\nThen we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.\\n\\n    public List<List<Integer>> permute(int[] num) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if (num.length ==0) return ans;\\n        List<Integer> l0 = new ArrayList<Integer>();\\n        l0.add(num[0]);\\n        ans.add(l0);\\n        for (int i = 1; i< num.length; ++i){\\n            List<List<Integer>> new_ans = new ArrayList<List<Integer>>(); \\n            for (int j = 0; j<=i; ++j){            \\n               for (List<Integer> l : ans){\\n            \\t   List<Integer> new_l = new ArrayList<Integer>(l);\\n            \\t   new_l.add(j,num[i]);\\n            \\t   new_ans.add(new_l);\\n               }\\n            }\\n            ans = new_ans;\\n        }\\n        return ans;\\n    }\\n\\n-------------------------------------------------------------------------\\npython version is more concise:\\n\\n    def permute(self, nums):\\n        perms = [[]]   \\n        for n in nums:\\n            new_perms = []\\n            for perm in perms:\\n                for i in xrange(len(perm)+1):   \\n                    new_perms.append(perm[:i] + [n] + perm[i:])   ###insert n\\n            perms = new_perms\\n        return perms",
                "solutionTags": [],
                "code": "the basic idea is, to permute n numbers, we can add the nth number into the resulting `List<List<Integer>>` from the n-1 numbers, in every possible position. \\n\\nFor example, if the input num[] is {1,2,3}: First, add 1 into the initial `List<List<Integer>>` (let's call it \"answer\"). \\n\\nThen, 2 can be added in front or after 1. So we have to copy the List<Integer> in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.\\n\\nThen we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.\\n\\n    public List<List<Integer>> permute(int[] num) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if (num.length ==0) return ans;\\n        List<Integer> l0 = new ArrayList<Integer>();\\n        l0.add(num[0]);\\n        ans.add(l0);\\n        for (int i = 1; i< num.length; ++i){\\n            List<List<Integer>> new_ans = new ArrayList<List<Integer>>(); \\n            for (int j = 0; j<=i; ++j){            \\n               for (List<Integer> l : ans){\\n            \\t   List<Integer> new_l = new ArrayList<Integer>(l);\\n            \\t   new_l.add(j,num[i]);\\n            \\t   new_ans.add(new_l);\\n               }\\n            }\\n            ans = new_ans;\\n        }\\n        return ans;\\n    }\\n\\n-------------------------------------------------------------------------\\npython version is more concise:\\n\\n    def permute(self, nums):\\n        perms = [[]]   \\n        for n in nums:\\n            new_perms = []\\n            for perm in perms:\\n                for i in xrange(len(perm)+1):   \\n                    new_perms.append(perm[:i] + [n] + perm[i:])   ###insert n\\n            perms = new_perms\\n        return perms",
                "codeTag": "Python3"
            },
            {
                "id": 18241,
                "title": "one-liners-in-python",
                "content": "**Solution 1: *Recursive, take any number as first***\\n\\nTake any number as the first number and append any permutation of the other numbers.\\n\\n    def permute(self, nums):\\n        return [[n] + p\\n                for i, n in enumerate(nums)\\n                for p in self.permute(nums[:i] + nums[i+1:])] or [[]]\\n\\n---\\n\\n**Solution 2: *Recursive, insert first number anywhere***\\n\\nInsert the first number anywhere in any permutation of the remaining numbers.\\n\\n    def permute(self, nums):\\n        return nums and [p[:i] + [nums[0]] + p[i:]\\n                         for p in self.permute(nums[1:])\\n                         for i in range(len(nums))] or [[]]\\n\\n---\\n\\n**Solution 3: *Reduce, insert next number anywhere***\\n\\nUse `reduce` to insert the next number anywhere in the already built permutations.\\n\\n    def permute(self, nums):\\n        return reduce(lambda P, n: [p[:i] + [n] + p[i:]\\n                                    for p in P for i in range(len(p)+1)],\\n                      nums, [[]])\\n\\n---\\n\\n**Solution 4: *Using the library***\\n\\n    def permute(self, nums):\\n        return list(itertools.permutations(nums))\\n\\nThat returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists:\\n\\n    def permute(self, nums):\\n        return map(list, itertools.permutations(nums))",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1: *Recursive, take any number as first***\\n\\nTake any number as the first number and append any permutation of the other numbers.\\n\\n    def permute(self, nums):\\n        return [[n] + p\\n                for i, n in enumerate(nums)\\n                for p in self.permute(nums[:i] + nums[i+1:])] or [[]]\\n\\n---\\n\\n**Solution 2: *Recursive, insert first number anywhere***\\n\\nInsert the first number anywhere in any permutation of the remaining numbers.\\n\\n    def permute(self, nums):\\n        return nums and [p[:i] + [nums[0]] + p[i:]\\n                         for p in self.permute(nums[1:])\\n                         for i in range(len(nums))] or [[]]\\n\\n---\\n\\n**Solution 3: *Reduce, insert next number anywhere***\\n\\nUse `reduce` to insert the next number anywhere in the already built permutations.\\n\\n    def permute(self, nums):\\n        return reduce(lambda P, n: [p[:i] + [n] + p[i:]\\n                                    for p in P for i in range(len(p)+1)],\\n                      nums, [[]])\\n\\n---\\n\\n**Solution 4: *Using the library***\\n\\n    def permute(self, nums):\\n        return list(itertools.permutations(nums))\\n\\nThat returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists:\\n\\n    def permute(self, nums):\\n        return map(list, itertools.permutations(nums))",
                "codeTag": "Python3"
            },
            {
                "id": 179932,
                "title": "beats-100-java-with-explanations",
                "content": "**Thought**\\nWe think about a searching tree when we apply Backtracking.\\n```\\ne.g.[1, 2, 3]\\n    1 -2 -3\\n      -3 -2\\n\\n    2 -1 -3\\n      -3 -1\\n\\n    3 -1 -2\\n      -2 -1\\n```\\nIf we exhausted the current branch, `currResult.size() == nums.length`, we will backtrack.\\nTo make sure each element is used once, we establish `boolean[] used`.\\n**Code**\\n```\\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i])\\n                continue;\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\ne.g.[1, 2, 3]\\n    1 -2 -3\\n      -3 -2\\n\\n    2 -1 -3\\n      -3 -1\\n\\n    3 -1 -2\\n      -2 -1\\n```\n```\\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i])\\n                continue;\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685868,
                "title": "dfs-backtracking-python-java-javascript-picture",
                "content": "Classic combinatorial search problem, we can solve it using 3-step system \\n\\n1. Identify states\\nWhat state do we need to know whether we have reached a solution (and using it to construct a solution if the problem asks for it).\\nWe need a state to keep track of the list of letters we have chosen for the current permutation\\n\\nWhat state do we need to decide which child nodes should be visited next and which ones should be pruned?\\nWe have to know what are the letters left that we can still use (since each letter can only be used once).\\n\\n2. Draw the State-space Tree\\n![](https://algomonster.s3.us-east-2.amazonaws.com/dfs_intro/arrangement.png)\\n\\n3. DFS on the State-space tree\\nUsing the [backtracking template](https://algo.monster/problems/backtracking) as basis, we add the two states we identified in step 1:\\n\\nA list to represent permutation constructed so far, path\\nA list to record which letters are already used, used, used[i] == true means ith letter in the origin list has been used.\\n\\nImplementation in 3 languages:\\n\\nPython\\n```\\nclass Solution:\\n    def permute(self, l: List[int]) -> List[List[int]]:\\n        def dfs(path, used, res):\\n            if len(path) == len(l):\\n                res.append(path[:]) # note [:] make a deep copy since otherwise we\\'d be append the same list over and over\\n                return\\n\\n            for i, letter in enumerate(l):\\n                # skip used letters\\n                if used[i]:\\n                    continue\\n                # add letter to permutation, mark letter as used\\n                path.append(letter)\\n                used[i] = True\\n                dfs(path, used, res)\\n                # remove letter from permutation, mark letter as unused\\n                path.pop()\\n                used[i] = False\\n            \\n        res = []\\n        dfs([], [False] * len(l), res)\\n        return res\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] letters) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        dfs(new ArrayList<>(), new boolean[letters.length], res, letters);\\n        return res;\\n    }\\n\\n    private static void dfs(List<Integer> path, boolean[] used, List<List<Integer>> res, int[] letters) {\\n        if (path.size() == used.length) {\\n            // make a deep copy since otherwise we\\'d be append the same list over and over\\n            res.add(new ArrayList<Integer>(path));\\n            return;\\n        }\\n\\n        for (int i = 0; i < used.length; i++) {\\n            // skip used letters\\n            if (used[i]) continue;\\n            // add letter to permutation, mark letter as used\\n            path.add(letters[i]);\\n            used[i] = true;\\n            dfs(path, used, res, letters);\\n            // remove letter from permutation, mark letter as unused\\n            path.remove(path.size() - 1);\\n            used[i] = false;\\n        }\\n    }    \\n}\\n```\\n\\nJavascript\\n```\\nvar permute = function(letters) {\\n    let res = [];\\n    dfs(letters, [], Array(letters.length).fill(false), res);\\n    return res;\\n}\\n\\nfunction dfs(letters, path, used, res) {\\n    if (path.length == letters.length) {\\n        // make a deep copy since otherwise we\\'d be append the same list over and over\\n        res.push(Array.from(path));\\n        return;\\n    }\\n    for (let i = 0; i < letters.length; i++) {\\n        // skip used letters\\n        if (used[i]) continue;\\n        // add letter to permutation, mark letter as used\\n        path.push(letters[i]);\\n        used[i] = true;\\n        dfs(letters, path, used, res);\\n        // remove letter from permutation, mark letter as unused\\n        path.pop();\\n        used[i] = false;\\n    }\\n}\\n```\\n\\nPlease upvote if you find it useful. And learn more about backtracking/dfs here https://algo.monster/problems/backtracking",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, l: List[int]) -> List[List[int]]:\\n        def dfs(path, used, res):\\n            if len(path) == len(l):\\n                res.append(path[:]) # note [:] make a deep copy since otherwise we\\'d be append the same list over and over\\n                return\\n\\n            for i, letter in enumerate(l):\\n                # skip used letters\\n                if used[i]:\\n                    continue\\n                # add letter to permutation, mark letter as used\\n                path.append(letter)\\n                used[i] = True\\n                dfs(path, used, res)\\n                # remove letter from permutation, mark letter as unused\\n                path.pop()\\n                used[i] = False\\n            \\n        res = []\\n        dfs([], [False] * len(l), res)\\n        return res\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] letters) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        dfs(new ArrayList<>(), new boolean[letters.length], res, letters);\\n        return res;\\n    }\\n\\n    private static void dfs(List<Integer> path, boolean[] used, List<List<Integer>> res, int[] letters) {\\n        if (path.size() == used.length) {\\n            // make a deep copy since otherwise we\\'d be append the same list over and over\\n            res.add(new ArrayList<Integer>(path));\\n            return;\\n        }\\n\\n        for (int i = 0; i < used.length; i++) {\\n            // skip used letters\\n            if (used[i]) continue;\\n            // add letter to permutation, mark letter as used\\n            path.add(letters[i]);\\n            used[i] = true;\\n            dfs(path, used, res, letters);\\n            // remove letter from permutation, mark letter as unused\\n            path.remove(path.size() - 1);\\n            used[i] = false;\\n        }\\n    }    \\n}\\n```\n```\\nvar permute = function(letters) {\\n    let res = [];\\n    dfs(letters, [], Array(letters.length).fill(false), res);\\n    return res;\\n}\\n\\nfunction dfs(letters, path, used, res) {\\n    if (path.length == letters.length) {\\n        // make a deep copy since otherwise we\\'d be append the same list over and over\\n        res.push(Array.from(path));\\n        return;\\n    }\\n    for (let i = 0; i < letters.length; i++) {\\n        // skip used letters\\n        if (used[i]) continue;\\n        // add letter to permutation, mark letter as used\\n        path.push(letters[i]);\\n        used[i] = true;\\n        dfs(letters, path, used, res);\\n        // remove letter from permutation, mark letter as unused\\n        path.pop();\\n        used[i] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360280,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Level0: []\\n    level1: [1]                  [2]              [3]\\n    level2: [1,2]    [1,3]       [2,1] [2,3]      [3,1] [3,2]\\n    level3: [1,2,3]  [1,3,2]     [2,1,3][2,3,1]   [3,1,2][3,2,1]          \\n    \\n    \"\"\"\\n    \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        visited = set()\\n        res = []\\n        self.backtracking(res,visited,[],nums)\\n        return res\\n    def backtracking(self,res,visited,subset,nums):\\n        if len(subset) == len(nums):\\n            res.append(subset)\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                visited.add(i)\\n                self.backtracking(res,visited,subset+[nums[i]],nums)\\n                visited.remove(i)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Level0: []\\n    level1: [1]                  [2]              [3]\\n    level2: [1,2]    [1,3]       [2,1] [2,3]      [3,1] [3,2]\\n    level3: [1,2,3]  [1,3,2]     [2,1,3][2,3,1]   [3,1,2][3,2,1]          \\n    \\n    \"\"\"\\n    \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        visited = set()\\n        res = []\\n        self.backtracking(res,visited,[],nums)\\n        return res\\n    def backtracking(self,res,visited,subset,nums):\\n        if len(subset) == len(nums):\\n            res.append(subset)\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                visited.add(i)\\n                self.backtracking(res,visited,subset+[nums[i]],nums)\\n                visited.remove(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18436,
                "title": "java-clean-code-two-recursive-solutions",
                "content": "**Bottom up? approach - 280ms**\\n\\n    public class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.length == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\n    \\t\\tcollectPermutations(nums, 0, new ArrayList<>(), permutations);\\n    \\t\\treturn permutations;\\n        }\\n    \\n    \\tprivate void collectPermutations(int[] nums, int start, List<Integer> permutation,\\n     \\t\\t\\tList<List<Integer>>  permutations) {\\n    \\t\\t\\n    \\t\\tif (permutation.size() == nums.length) {\\n    \\t\\t\\tpermutations.add(permutation);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\n    \\t\\tfor (int i = 0; i <= permutation.size(); i++) {\\n    \\t\\t\\tList<Integer> newPermutation = new ArrayList<>(permutation);\\n    \\t\\t\\tnewPermutation.add(i, nums[start]);\\n    \\t\\t\\tcollectPermutations(nums, start + 1, newPermutation, permutations);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n***Code flow***\\n\\n    nums = 1,2,3\\n\\n    start = 0, permutation = []\\n    i = 0, newPermutation = [1]\\n    \\tstart = 1, permutation = [1]\\n    \\ti = 0, newPermutation = [2, 1]\\n    \\t\\tstart = 2, permutation = [2, 1]\\n    \\t\\ti = 0, newPermutation = [3, 2, 1]\\n    \\t\\ti = 1, newPermutation = [2, 3, 1]\\n    \\t\\ti = 2, newPermutation = [2, 1, 3]\\n    \\ti = 1, newPermutation = [1, 2]\\n    \\t\\tstart = 2, permutation = [1, 2]\\n    \\t\\ti = 0, newPermutation = [3, 1, 2]\\n    \\t\\ti = 1, newPermutation = [1, 3, 2]\\n    \\t\\ti = 2, newPermutation = [1, 2, 3]\\n\\n**Base case and build approach - 524ms**\\n\\n    public class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\treturn permute(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n       }\\n    \\n    \\tprivate List<List<Integer>> permute(List<Integer> nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.size() == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\t\\tif (nums.size() == 1) {\\n    \\t\\t\\tList<Integer> permutation = new ArrayList<>();\\n    \\t\\t\\tpermutation.add(nums.get(0));\\n    \\t\\t\\tpermutations.add(permutation);\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tList<List<Integer>> smallPermutations = permute(nums.subList(1, nums.size()));\\n    \\t\\tint first = nums.get(0);\\n    \\t\\tfor(List<Integer> permutation : smallPermutations) {\\n    \\t\\t\\tfor (int i = 0; i <= permutation.size(); i++) {\\n    \\t\\t\\t\\tList<Integer> newPermutation = new ArrayList<>(permutation);\\n    \\t\\t\\t\\tnewPermutation.add(i, first);\\n    \\t\\t\\t\\tpermutations.add(newPermutation);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn permutations;\\n    \\t}\\n    }\\n\\n***Code flow***\\n\\n    nums = 1,2,3\\n    \\n    smallPermutations(2, 3)\\n    \\tsmallPermutations(3)\\n    \\t\\treturn [[3]]\\n    \\tfirst = 2\\n     \\t\\tpermutation = [3]\\n    \\t\\t\\ti = 0, newPermutation = [2, 3]\\n    \\t\\t\\ti = 1, newPermutation = [3, 2]\\n    \\treturn [[2, 3], [3, 2]]\\n    first = 1\\n     \\tpermutation = [2, 3]\\n    \\t\\ti = 0, newPermutation = [1, 2, 3]\\n    \\t\\ti = 1, newPermutation = [2, 1, 3]\\n    \\t\\ti = 2, newPermutation = [2, 3, 1]\\n     \\tpermutation = [3, 2]\\n    \\t\\ti = 0, newPermutation = [1, 3, 2]\\n    \\t\\ti = 1, newPermutation = [3, 1, 2]\\n    \\t\\ti = 2, newPermutation = [3, 2, 1]",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.length == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1257633,
                "title": "backtracking-solution-c-easy-to-understand-with-explanation",
                "content": "\\nSuppose if give string is ABC then recursive tree like this\\n![image](https://assets.leetcode.com/users/images/0865f0cf-1f8a-4164-9543-4bf13aebcb59_1623088635.478572.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    // Backtracking\\n    void permutation(vector<int> &nums,int i,int n){\\n        if(i==n){\\n            result.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j=i;j<=n;j++){\\n            swap( nums[i],nums[j]);\\n            permutation(nums,i+1,n);\\n            swap( nums[i],nums[j]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        permutation(nums,0,nums.size()-1);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    // Backtracking\\n    void permutation(vector<int> &nums,int i,int n){\\n        if(i==n){\\n            result.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j=i;j<=n;j++){\\n            swap( nums[i],nums[j]);\\n            permutation(nums,i+1,n);\\n            swap( nums[i],nums[j]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        permutation(nums,0,nums.size()-1);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18360,
                "title": "c-backtracking-and-nextpermutation",
                "content": "**Backtracking**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                swap(nums[i], nums[j]);\\n                permute(nums, i + 1, perms);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Next Permutation**\\n\\nBesides backtracking, you may also solve this problem using [Next Permutation](https://leetcode.com/problems/next-permutation/): computing the next permutation and add it to the result until the permutation becomes the original array (`n!` times since all digits are distinct).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        for (int i = 0, n = factorial(nums.size()); i < n; i++) {\\n            perms.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        return perms;\\n    }\\nprivate:\\n    int factorial(int n) {\\n        int f = 1;\\n        while (n > 1) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n    \\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\nThe above code can also be applied to [Permutations II](https://leetcode.com/problems/permutations-ii/) since the `nextPermutation` is able to handle duplicates.",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                swap(nums[i], nums[j]);\\n                permute(nums, i + 1, perms);\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        for (int i = 0, n = factorial(nums.size()); i < n; i++) {\\n            perms.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        return perms;\\n    }\\nprivate:\\n    int factorial(int n) {\\n        int f = 1;\\n        while (n > 1) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n    \\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18255,
                "title": "share-my-short-iterative-java-solution",
                "content": "    public List<List<Integer>> permute(int[] num) {\\n        LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        for (int n : num) {\\n            int size = res.size();\\n            for (; size > 0; size--) {\\n                List<Integer> r = res.pollFirst();\\n                for (int i = 0; i <= r.size(); i++) {\\n                    List<Integer> t = new ArrayList<Integer>(r);\\n                    t.add(i, n);\\n                    res.add(t);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<List<Integer>> permute(int[] num) {\\n        LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        for (int n : num) {\\n            int size = res.size();\\n            for (; size > 0; size--) {\\n                List<Integer> r = res.pollFirst();\\n                for (int i = 0; i <= r.size(); i++) {\\n                    List<Integer> t = new ArrayList<Integer>(r);\\n                    t.add(i, n);\\n                    res.add(t);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 551252,
                "title": "short-recursive-python-solution",
                "content": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        if len(nums) == 1:\\n            return [nums]\\n        result = []\\n        for i in range(len(nums)):\\n            others = nums[:i] + nums[i+1:]\\n            other_permutations = self.permute(others)\\n            for permutation in other_permutations:\\n                result.append([nums[i]] + permutation)\\n        return result\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        if len(nums) == 1:\\n            return [nums]\\n        result = []\\n        for i in range(len(nums)):\\n            others = nums[:i] + nums[i+1:]\\n            other_permutations = self.permute(others)\\n            for permutation in other_permutations:\\n                result.append([nums[i]] + permutation)\\n        return result\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3378574,
                "title": "beats-100-simple-swapping-and-backtracking",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n# Approach\\n**Not need of an extra array, just use swap on every element.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N!)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    void solve(vector<int>&a,int idx)\\n    {\\n        if(idx >= a.size())\\n        {\\n            v.push_back(a);\\n            return;\\n        }\\n        for(int i = idx; i < a.size(); i++)\\n        {\\n            swap(a[i],a[idx]);\\n            solve(a,idx+1);\\n            swap(a[i],a[idx]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& a) {\\n        vector<int>p;\\n        solve(a,0);\\n        return v;\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/169ef9be-319d-4bd7-8cc2-52bb58c7ef9f_1680602007.8632011.png)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    void solve(vector<int>&a,int idx)\\n    {\\n        if(idx >= a.size())\\n        {\\n            v.push_back(a);\\n            return;\\n        }\\n        for(int i = idx; i < a.size(); i++)\\n        {\\n            swap(a[i],a[idx]);\\n            solve(a,idx+1);\\n            swap(a[i],a[idx]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& a) {\\n        vector<int>p;\\n        solve(a,0);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293217,
                "title": "javascript-backtracking-with-explanation-beats-99",
                "content": "Here is my simple recursive solution. I\\'ve provided many details to why certain things are done which may be more obvious to others. Credits to user [isaac3](https://leetcode.com/issac3/), as this is inspired by this [post](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)) outlining a general approach to backtracking.\\n\\n## Thought Process\\nFirst, it helps to recognize that this is problem can be solved with recursion. The key buzzwords that should set off *recursion* in your head as viable approaches include: combinations, permutations, subsets, and all possible X\\'s.\\nBecause I think visually, it helps me to draw a diagram of a tree and walk through the different recursive calls to get an intuition for what tools I will need. With our intitial input, we break down the different way we split (each branch) at each recursive level (rows). The array to our left represents what we have *taken* as `temp` , and the right array represents what is *left* to be taken as `nums`\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tinitial input\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n## Visualize\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[],[1,2,3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/         |             \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t[1],[2,3]        [2],[1,3]       [3],[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\t/    \\\\                /    \\\\               /  \\\\\\n\\t\\t\\t\\t\\t[1,2],[3]   [1,3],[2]   [2,1],[3]  [2,3],[1]  [3,1],[2]   [3,2],[1]\\n\\t\\t\\t\\t/                  /           /             \\\\         \\\\           \\\\\\n\\t\\t\\t[1,2,3],[]    [1,3,2],[]        [2,1,3],[]    [2,3,1],[]    [3,1,2],[]  [3,2,1],[]\\nSee in the chart above, the bottom row actually depicts the result that we want:\\n```\\n[ [ 1, 2, 3 ],\\n  [ 1, 3, 2 ],\\n  [ 2, 1, 3 ],\\n  [ 2, 3, 1 ],\\n  [ 3, 1, 2 ],\\n  [ 3, 2, 1 ] ]\\n  ```\\n\\t\\t\\t\\nAs you see at each recursive level, we need to *iterate* over the nums to select different nums to pick out. It\\'s also important that we leave in the rest of the nums so we can pick them later. This **iteration** is a key component we will use to build our algorithm.\\n```\\nfor (var i = 0; i < nums.length; i++) {\\n// pick a different number\\n// do some recursive call\\n}\\n```\\n\\nCan you find the **base case** here? Notice that all the `nums` (right arrays) are all empty. We\\'ll use that as an indicator that we are done.\\n```\\nif (!nums.length) {\\n// we found a solution!\\n// return\\n}\\n```\\n\\n## Putting the Algorithm Together\\n\\n```\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = function(nums) {\\n  const result = [];\\n  const temp = [];\\n  // we are using a common strategy to initialize an \\'answer\\' object, and pass it into\\n  // a recursion helper to modify the values. Sometimes it helps to separate this because\\n  // there are times you will want to have conditionals or a for loop in the top level code\\n  // before you call a recursive function.\\n  findPermutations(temp, nums, result);\\n  return result;\\n};\\n\\nconst findPermutations = (temp, nums, result) => {\\n  if (!nums.length) {\\n   // Here it is important to call concat(), just a fancy way of copying the original array.\\n   // See what happens when you remove concat, things will go crazy because you are \\n   // modifying an object that is referenced elsewhere!\\n    result.push(temp.concat());\\n    return;\\n  }\\n\\n  for (var i = 0; i < nums.length; i++) {\\n\\tconst newNum = nums[i];\\n\\t// we\\'ve picked our new number to add, so add it to our \"picked\" array called temp\\n    temp.push(newNum);\\n\\t// remember, in the first iteration, after picking 1, we need to pass in [2, 3] as the numbers left.\\n    nums.splice(i, 1);\\n    findPermutations(temp, nums, result);\\n\\t// Remember to \"reset\" our temp and nums array before our next iteration, where we pick the 2, and leave [1,3] \\n    temp.pop();\\n    nums.splice(i, 0, newNum);\\n  }\\n};\\n```\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\n[ [ 1, 2, 3 ],\\n  [ 1, 3, 2 ],\\n  [ 2, 1, 3 ],\\n  [ 2, 3, 1 ],\\n  [ 3, 1, 2 ],\\n  [ 3, 2, 1 ] ]\\n  ```\n```\\nfor (var i = 0; i < nums.length; i++) {\\n// pick a different number\\n// do some recursive call\\n}\\n```\n```\\nif (!nums.length) {\\n// we found a solution!\\n// return\\n}\\n```\n```\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = function(nums) {\\n  const result = [];\\n  const temp = [];\\n  // we are using a common strategy to initialize an \\'answer\\' object, and pass it into\\n  // a recursion helper to modify the values. Sometimes it helps to separate this because\\n  // there are times you will want to have conditionals or a for loop in the top level code\\n  // before you call a recursive function.\\n  findPermutations(temp, nums, result);\\n  return result;\\n};\\n\\nconst findPermutations = (temp, nums, result) => {\\n  if (!nums.length) {\\n   // Here it is important to call concat(), just a fancy way of copying the original array.\\n   // See what happens when you remove concat, things will go crazy because you are \\n   // modifying an object that is referenced elsewhere!\\n    result.push(temp.concat());\\n    return;\\n  }\\n\\n  for (var i = 0; i < nums.length; i++) {\\n\\tconst newNum = nums[i];\\n\\t// we\\'ve picked our new number to add, so add it to our \"picked\" array called temp\\n    temp.push(newNum);\\n\\t// remember, in the first iteration, after picking 1, we need to pass in [2, 3] as the numbers left.\\n    nums.splice(i, 1);\\n    findPermutations(temp, nums, result);\\n\\t// Remember to \"reset\" our temp and nums array before our next iteration, where we pick the 2, and leave [1,3] \\n    temp.pop();\\n    nums.splice(i, 0, newNum);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18282,
                "title": "backtracking-clean-c-recursion-with-detailed-explanation",
                "content": "The idea is much like the insertion sort. We start with only the first number, and pick next number from the rest of array, insert it to the front or back position of the first number, and pick the third number, insert it to front or mid or back position of the `[first, second]` array, and so on, until no element left.\\nFor example, given array `[1,2,3]`.\\nFirst, we have `[1]` as array to be inserted, and `[2,3]` remain;\\nnext number is `2`, we insert it to the front or back of `[1]`, which become `[1,2]` and `[2,1]`, with `[3]` remain.\\nThen we pick number `3`, insert it to `[1,2]` and `[2,1]`,\\nInsert to front position, we get\\n  `[3,1,2]`,\\n  `[3,2,1]`\\nInsert to mid position, we get\\n  `[1,3,2]`,\\n  `[2,3,1]`,\\nInsert to back, we get\\n  `[1,2,3]`,\\n  `[2,1,3]`,\\nand no element left in remain array, finish.\\nHere is my code,\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>vec;\\n        DFS(nums, 0, vec, res);\\n        return res;\\n    }\\n    \\n    void DFS(vector<int>& nums, int pos, vector<int>& vec, vector<vector<int>>& res){\\n        if(pos == nums.size()){\\n            res.push_back(vec);\\n            return;\\n        }\\n        for(int i = 0; i <= vec.size(); i++){\\n            vec.insert(vec.begin() + i, nums[pos]);\\n            DFS(nums, pos + 1, vec, res);\\n            vec.erase(vec.begin() + i);\\n        }\\n        return;\\n    }\\n};\\n```\\n***\\n*Update(9/2/2017):* No more `insert` and `erase`, my updated solution with `swap`.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        DFS(res, nums, 0);\\n        return res;        \\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(pos == nums.size() - 1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            swap(nums[pos], nums[i]);\\n            DFS(res, nums, pos + 1);\\n            swap(nums[pos], nums[i]);\\n        }\\n    }\\n};\\n```\\n***\\nSimilar swap [solution](https://discuss.leetcode.com/topic/101970/13-lines-c-backtracking) for [Permutations II](https://leetcode.com/problems/permutations-ii/description/).",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>vec;\\n        DFS(nums, 0, vec, res);\\n        return res;\\n    }\\n    \\n    void DFS(vector<int>& nums, int pos, vector<int>& vec, vector<vector<int>>& res){\\n        if(pos == nums.size()){\\n            res.push_back(vec);\\n            return;\\n        }\\n        for(int i = 0; i <= vec.size(); i++){\\n            vec.insert(vec.begin() + i, nums[pos]);\\n            DFS(nums, pos + 1, vec, res);\\n            vec.erase(vec.begin() + i);\\n        }\\n        return;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        DFS(res, nums, 0);\\n        return res;        \\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(pos == nums.size() - 1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            swap(nums[pos], nums[i]);\\n            DFS(res, nums, pos + 1);\\n            swap(nums[pos], nums[i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18462,
                "title": "share-my-three-different-solutions",
                "content": "    // method 1: standard backtracing solution\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        permutation(num, 0, ans);\\n        return ans;\\n    }\\n    \\n    void permutation(vector<int> &num, int begin, vector<vector<int> > &ans) {\\n        if (begin >= num.size()) {\\n            ans.push_back(num);\\n            return;\\n        }\\n        \\n        // every number chosen to be the begin once\\n        for (int i = begin; i < num.size(); ++i) {\\n            swap(num[begin], num[i]);\\n            permutation(num, begin+1, ans);\\n            swap(num[begin], num[i]);\\n        }\\n    }\\n    \\n    // method 2: using next_permutation to iterate all the permutaions\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        sort(num.begin(), num.end());\\n        ans.push_back(num);\\n        \\n        while(next_permutation(num.begin(), num.end()))\\n            ans.push_back(num);\\n        return ans;\\n    }\\n    \\n    // method 3: recursive dfs\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        dfs(num, ans);\\n        return ans;\\n    }\\n    \\n    void dfs(vector<int> &num, vector<vector<int>> &ans) {\\n        if (num.size() == 1) {\\n            vector<int> tmp(num.begin(), num.end());\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        vector<vector<int> > ans1;\\n        vector<int> num1(num.begin()+1, num.end());\\n        dfs(num1, ans);\\n        \\n        for(int i = 0; i < ans.size(); ++i) {\\n            for(int j = 0; j <= ans[i].size(); ++j) {\\n                vector<int> tmp = ans[i];\\n                tmp.insert(tmp.begin()+j, num[0]);\\n                ans1.push_back(tmp);\\n            }\\n        }\\n        \\n        ans = ans1;\\n    }",
                "solutionTags": [],
                "code": "    // method 1: standard backtracing solution\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        permutation(num, 0, ans);\\n        return ans;\\n    }\\n    \\n    void permutation(vector<int> &num, int begin, vector<vector<int> > &ans) {\\n        if (begin >= num.size()) {\\n            ans.push_back(num);\\n            return;\\n        }\\n        \\n        // every number chosen to be the begin once\\n        for (int i = begin; i < num.size(); ++i) {\\n            swap(num[begin], num[i]);\\n            permutation(num, begin+1, ans);\\n            swap(num[begin], num[i]);\\n        }\\n    }\\n    \\n    // method 2: using next_permutation to iterate all the permutaions\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        sort(num.begin(), num.end());\\n        ans.push_back(num);\\n        \\n        while(next_permutation(num.begin(), num.end()))\\n            ans.push_back(num);\\n        return ans;\\n    }\\n    \\n    // method 3: recursive dfs\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        dfs(num, ans);\\n        return ans;\\n    }\\n    \\n    void dfs(vector<int> &num, vector<vector<int>> &ans) {\\n        if (num.size() == 1) {\\n            vector<int> tmp(num.begin(), num.end());\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        vector<vector<int> > ans1;\\n        vector<int> num1(num.begin()+1, num.end());\\n        dfs(num1, ans);\\n        \\n        for(int i = 0; i < ans.size(); ++i) {\\n            for(int j = 0; j <= ans[i].size(); ++j) {\\n                vector<int> tmp = ans[i];\\n                tmp.insert(tmp.begin()+j, num[0]);\\n                ans1.push_back(tmp);\\n            }\\n        }\\n        \\n        ans = ans1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 301437,
                "title": "a-more-general-approach-to-backtracking-questions-in-python",
                "content": "Inspired by @issac3 , I write a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum,Generate Parentheses, Partition Equal Subset Sum,Letter Tile Possibilities)\\n  Thansks for [A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)\\n](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))\\n\\nI use hashmap(collections.Counter)  to make  code more easy and general.\\n\\nPermutations : https://leetcode.com/problems/permutations/\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\nsame code to pass two problems:\\n  ```python\\n    def DFS(self,end_len,path,recoder):\\n        if len(path) == end_len:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0:\\n                    recoder[key] -= 1\\n                    self.DFS(end_len,path+[key],recoder)\\n                    recoder[key] += 1\\n\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n    # def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        recoder = collections.Counter(nums)\\n        self.res = []\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\\n\\nSubsets : https://leetcode.com/problems/subsets/\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\nsame code to pass two problems:\\n\\n ```python\\n    def DFS(self,end_len,path,recoder):\\n        self.res.append(path)\\n        for key in recoder: \\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                self.DFS(end_len,path+[key],recoder_copy)\\n    \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t#def subsets(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        import copy\\n        recoder = collections.Counter(nums)\\n        self.res =[]\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\\n\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target-key >= 0 :\\n                    recoder_copy = copy.copy(recoder)\\n                    self.DFS(target-key,path+[key],recoder_copy)\\n                    recoder[key] =0\\n            \\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\\n\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target - key >= 0:   \\n                    recoder_copy = copy.copy(recoder)\\n                    recoder[key] = 0\\n                    recoder_copy[key] -= 1\\n                    self.DFS(target - key,path+[key],recoder_copy)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\\nGenerate Parentheses : https://leetcode.com/problems/generate-parentheses/\\n```python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        import copy\\n        cnt = {\\'l\\':n,\\'r\\':n}\\n        res = []\\n        def DFS(record,open,path):\\n            if len(path) == 2*n:\\n                res.append(path)\\n                return\\n            if record[\\'l\\']>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'l\\'] -= 1\\n                DFS(new_record,open+1,path+\\'(\\')\\n                \\n            if record[\\'r\\']>0 and open>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'r\\'] -= 1\\n                DFS(new_record,open-1,path+\\')\\')\\n        DFS(cnt,0,\\'\\')\\n        return res\\n```\\nPartition Equal Subset Sum:https://leetcode.com/problems/partition-equal-subset-sum/\\n```python\\n   def DFS(self,target,recoder):\\n        if target == 0:\\n            return True\\n        if target < 0:\\n            return False\\n        \\n        for key in recoder:\\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                if self.DFS(target-key,recoder_copy):\\n                    return True\\n        return False\\n    \\n    def canPartition(self, nums: List[int]) -> bool:\\n        import collections\\n        import copy\\n        if not nums:\\n            return True\\n        sumNum = sum(nums)\\n        if sumNum&1:\\n            return False\\n\\n        halfSum = sumNum//2\\n        recoder = collections.Counter(nums)\\n        return self.DFS(halfSum,recoder)\\n```\\n\\nLetter Tile Possibilities:\\n```python\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 1\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)-1\\n    \\n    # same idea\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 0\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    total+=1\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)\\n```\\n\\nI think this post deserves some upvotes!  : ) hope you enjoy it!",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\n    def DFS(self,end_len,path,recoder):\\n        if len(path) == end_len:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0:\\n                    recoder[key] -= 1\\n                    self.DFS(end_len,path+[key],recoder)\\n                    recoder[key] += 1\\n\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n    # def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        recoder = collections.Counter(nums)\\n        self.res = []\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\n```python\\n    def DFS(self,end_len,path,recoder):\\n        self.res.append(path)\\n        for key in recoder: \\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                self.DFS(end_len,path+[key],recoder_copy)\\n    \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t#def subsets(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        import copy\\n        recoder = collections.Counter(nums)\\n        self.res =[]\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target-key >= 0 :\\n                    recoder_copy = copy.copy(recoder)\\n                    self.DFS(target-key,path+[key],recoder_copy)\\n                    recoder[key] =0\\n            \\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target - key >= 0:   \\n                    recoder_copy = copy.copy(recoder)\\n                    recoder[key] = 0\\n                    recoder_copy[key] -= 1\\n                    self.DFS(target - key,path+[key],recoder_copy)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\n```python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        import copy\\n        cnt = {\\'l\\':n,\\'r\\':n}\\n        res = []\\n        def DFS(record,open,path):\\n            if len(path) == 2*n:\\n                res.append(path)\\n                return\\n            if record[\\'l\\']>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'l\\'] -= 1\\n                DFS(new_record,open+1,path+\\'(\\')\\n                \\n            if record[\\'r\\']>0 and open>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'r\\'] -= 1\\n                DFS(new_record,open-1,path+\\')\\')\\n        DFS(cnt,0,\\'\\')\\n        return res\\n```\n```python\\n   def DFS(self,target,recoder):\\n        if target == 0:\\n            return True\\n        if target < 0:\\n            return False\\n        \\n        for key in recoder:\\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                if self.DFS(target-key,recoder_copy):\\n                    return True\\n        return False\\n    \\n    def canPartition(self, nums: List[int]) -> bool:\\n        import collections\\n        import copy\\n        if not nums:\\n            return True\\n        sumNum = sum(nums)\\n        if sumNum&1:\\n            return False\\n\\n        halfSum = sumNum//2\\n        recoder = collections.Counter(nums)\\n        return self.DFS(halfSum,recoder)\\n```\n```python\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 1\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)-1\\n    \\n    # same idea\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 0\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    total+=1\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3850714,
                "title": "100-fast-image-video-explanation-backtracking-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor every number all the positions are available if it is not filled so we can put anywhere and recursively call and generate.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/XUQ0iZ94CGg\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1. Define a recursive function `solve` that generates permutations using backtracking. This function takes three parameters: `nums` (the original array of integers), `per` (the current permutation being constructed), and `c` (the current index indicating which element of `nums` is being considered).\\n\\n2. In the `solve` function, if the current index `c` reaches the length of `nums`, it means we have completed constructing one permutation. Therefore, we add the current permutation `per` to the `ans` vector.\\n\\n3. If the current index `c` is not equal to the length of `nums`, we continue generating permutations. For each position `i` in the current permutation `per`, if `per[i]` is equal to 11 (a marker used to indicate that the position is available), we set `per[i]` to the element at index `c` in the `nums` array, call the `solve` function recursively with `c+1` to consider the next element in `nums`, and then reset `per[i]` back to 11 after the recursive call (backtracking step).\\n\\n4. In the `permute` function, initialize a vector `per` with 11 as a placeholder value of the same length as `nums`. This vector will be used to construct the permutations.\\n\\n5. Call the `solve` function with the original `nums` array, the initial permutation `per`, and the starting index `0` to generate all possible permutations.\\n\\n6. Return the resulting `ans` vector, which contains all unique permutations of the input array `nums`.\\n\\n# Complexity\\n- Time complexity:$$O(n*n!)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n!)$$ for ans vector otherwise without taking that space only $$(n)$$ per array size. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void solve(vector<int>& nums,vector<int>&per,int c){\\n        if(c==nums.size()){\\n            ans.push_back(per);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(per[i]==11){\\n                per[i]=nums[c];\\n                solve(nums,per,c+1);\\n                per[i]=11;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>per(n,11);\\n       solve(nums,per,0);\\n       return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    void solve(int[] nums, int[] per, int c) {\\n        if (c == nums.length) {\\n            List<Integer> permutation = new ArrayList<>();\\n            for (int num : per) {\\n                permutation.add(num);\\n            }\\n            ans.add(permutation);\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (per[i] == 11) {\\n                per[i] = nums[c];\\n                solve(nums, per, c + 1);\\n                per[i] = 11;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        int n = nums.length;\\n        int[] per = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            per[i] = 11;\\n        }\\n        solve(nums, per, 0);\\n        return ans;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def permute(self, nums):\\n        def solve(nums, per, c):\\n            if c == len(nums):\\n                ans.append(list(per))\\n                return\\n            for i in range(len(nums)):\\n                if per[i] == 11:\\n                    per[i] = nums[c]\\n                    solve(nums, per, c + 1)\\n                    per[i] = 11\\n\\n        ans = []\\n        per = [11] * len(nums)\\n        solve(nums, per, 0)\\n        return ans\\n\\n```\\n# Recursive tree for same\\n![Screenshot (306).png](https://assets.leetcode.com/users/images/fc2ba42b-7291-4c76-92de-753b423bbd03_1690949987.7946765.png)\\n\\n# upvote if you understood the solution .",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void solve(vector<int>& nums,vector<int>&per,int c){\\n        if(c==nums.size()){\\n            ans.push_back(per);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(per[i]==11){\\n                per[i]=nums[c];\\n                solve(nums,per,c+1);\\n                per[i]=11;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>per(n,11);\\n       solve(nums,per,0);\\n       return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    void solve(int[] nums, int[] per, int c) {\\n        if (c == nums.length) {\\n            List<Integer> permutation = new ArrayList<>();\\n            for (int num : per) {\\n                permutation.add(num);\\n            }\\n            ans.add(permutation);\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (per[i] == 11) {\\n                per[i] = nums[c];\\n                solve(nums, per, c + 1);\\n                per[i] = 11;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        int n = nums.length;\\n        int[] per = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            per[i] = 11;\\n        }\\n        solve(nums, per, 0);\\n        return ans;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def permute(self, nums):\\n        def solve(nums, per, c):\\n            if c == len(nums):\\n                ans.append(list(per))\\n                return\\n            for i in range(len(nums)):\\n                if per[i] == 11:\\n                    per[i] = nums[c]\\n                    solve(nums, per, c + 1)\\n                    per[i] = 11\\n\\n        ans = []\\n        per = [11] * len(nums)\\n        solve(nums, per, 0)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850526,
                "title": "video-100-unlocking-recursive-backtracking-for-permutations",
                "content": "# Intuition\\nWhen I first looked at this problem, I realized it was a classic case of generating all possible permutations of a given list of numbers. My initial thought was to use a recursive approach to solve it. Recursive algorithms, especially backtracking, often provide a clean and efficient solution for generating permutations. I implemented two different versions of the solution in Python, both capitalizing on recursion and backtracking.\\n\\nBoth versions achieve the same result, but v2 provides more granular control over the recursive process. Version 1 has also been implemented in other programming languages including C++, JavaScript, C#, Java, Rust, Swift, and Go, demonstrating the versatility and applicability of the recursive backtracking approach across different coding environments.\\n\\nhttps://youtu.be/Jlw0sIGdS_4\\n\\n# Approach\\nThe main approach here is to use recursion (a form of backtracking) to generate all permutations of the input list. Here\\'s a detailed step-by-step guide:\\n\\n1. **Initialize Result**: Create an empty list, `result`, to store the final permutations.\\n\\n2. **Define Backtracking Function**: Define a recursive helper function `backtrack`, which takes the remaining numbers to be permuted (`nums`) and the current permutation (`path`) as parameters.\\n   \\n   a. **Base Case**: If there are no numbers left to permute (`nums` is empty), we have a complete permutation, and we add the current `path` to the `result`.\\n   \\n   b. **Recursive Case**: For each number in `nums`, we perform the following steps:\\n      i. Add the current number to `path`.\\n      ii. Remove the current number from `nums`.\\n      iii. Recursively call `backtrack` with the updated `nums` and `path`.\\n      iv. Since we are using slicing to create new lists, there is no need to revert the changes to `nums` and `path` after the recursive call.\\n\\n3. **Start Recursion**: Call the `backtrack` function with the original `nums` and an empty `path` to start the process.\\n\\n4. **Return Result**: Return the `result` list, which will contain all the permutations.\\n\\nBy iteratively choosing one element and recursively calling the function on the remaining elements, this approach ensures that all permutations are explored.\\n\\n# Complexity\\n- Time complexity: O(n*n!) \\n  This is because for generating permutations, we perform n! operations (since there are n! permutations for n numbers) and for each operation, we spend O(n) time for slicing the list in our recursive call.\\n\\n- Space complexity: O(n*n!) \\n  This is due to the number of solutions. In the worst case, if we have \\'n\\' distinct numbers, there would be n! permutations. Since each permutation is a list of \\'n\\' numbers, the space complexity is O(n*n!).\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```\\n\\n# Video for Python v2\\nhttps://youtu.be/jTCdBWNaLe8\\n\\n# Code v2\\n``` Python \\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(path, used): \\n            if len(path) == len(nums): \\n                result.append(path[:]) \\n                return \\n            for i in range(len(nums)): \\n                if not used[i]: \\n                    path.append(nums[i]) \\n                    used[i] = True \\n                    dfs(path, used) \\n                    path.pop() \\n                    used[i] = False \\n        result = [] \\n        dfs([], [False] * len(nums)) \\n        return result \\n```\\n\\n## Performance \\n| Language   | Runtime | Beats   | Memory  |\\n|------------|---------|---------|---------|\\n| C++        | 0 ms    | 100%    | 7.5 MB  |\\n| Java       | 1 ms    | 98.58%  | 44.1 MB |\\n| Rust       | 1 ms    | 87.70%  | 2.3 MB  |\\n| Go         | 2 ms    | 61.28%  | 3.1 MB  |\\n| Swift      | 8 ms    | 91.96%  | 14.4 MB |\\n| Python3 v2 | 36 ms   | 99.39%  | 16.5 MB |\\n| Python3    | 39 ms   | 98.74%  | 16.7 MB |\\n| JavaScript | 72 ms   | 55%     | 44.1 MB |\\n| C#         | 131 ms  | 94.50%  | 43.4 MB |\\n\\nThis sorted table provides a quick comparison of the runtime performance across different programming languages for the given problem.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```\n``` Python \\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(path, used): \\n            if len(path) == len(nums): \\n                result.append(path[:]) \\n                return \\n            for i in range(len(nums)): \\n                if not used[i]: \\n                    path.append(nums[i]) \\n                    used[i] = True \\n                    dfs(path, used) \\n                    path.pop() \\n                    used[i] = False \\n        result = [] \\n        dfs([], [False] * len(nums)) \\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938018,
                "title": "simple-java-sol",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean [] visited = new boolean[nums.length];\\n        FindAllPermutation(res,nums, new ArrayList(),visited);\\n        return res;\\n    }\\n    void FindAllPermutation(List<List<Integer>> res, int[] nums, List<Integer> curr, boolean [] visited){\\n        if(curr.size()==nums.length){\\n            res.add(new ArrayList(curr));\\n            return;\\n        }\\n\\n        for(int i =0;i<nums.length;i++){\\n            if(visited[i]==true)\\n            continue;\\n            curr.add(nums[i]);\\n            visited[i]= true;\\n            FindAllPermutation(res,nums,curr,visited);\\n            curr.remove(curr.size()-1);\\n            visited[i]=false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean [] visited = new boolean[nums.length];\\n        FindAllPermutation(res,nums, new ArrayList(),visited);\\n        return res;\\n    }\\n    void FindAllPermutation(List<List<Integer>> res, int[] nums, List<Integer> curr, boolean [] visited){\\n        if(curr.size()==nums.length){\\n            res.add(new ArrayList(curr));\\n            return;\\n        }\\n\\n        for(int i =0;i<nums.length;i++){\\n            if(visited[i]==true)\\n            continue;\\n            curr.add(nums[i]);\\n            visited[i]= true;\\n            FindAllPermutation(res,nums,curr,visited);\\n            curr.remove(curr.size()-1);\\n            visited[i]=false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992590,
                "title": "easiest-faang-method-ever",
                "content": "---\\n# ***PLEASE UPVOTE IF IT HELPS \\u2764\\uFE0F***\\n---\\n\\n# 1) Most Optimal Iterative Approach \\uD83D\\uDD25\\n\\n- Time complexity: O(n!+nlogn) ~ O(n!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            ans.emplace_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```\\n# 2) Recursive Approach but uses more space \\u26A0\\uFE0F\\n![image.png](https://assets.leetcode.com/users/images/e83c9988-b6e5-4112-a6ea-99ee252e0b71_1672753262.4502509.png)\\nhttps://www.youtube.com/watch?v=YK78FU5Ffjw&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=13\\n\\n- Time complexity: O(n!*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    void Permutations(vector<int> &nums, vector<vector<int>> &ans, vector<int> &ds, int freq[]){\\n        if(ds.size() == nums.size()){\\n            ans.emplace_back(ds);\\n            return;\\n        }\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(!freq[i]){\\n                ds.emplace_back(nums[i]);\\n                freq[i]++;\\n                Permutations(nums, ans, ds, freq);\\n                freq[i]--;\\n                ds.pop_back();\\n            }\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        int freq[nums.size()];\\n        for(int i=0 ; i<nums.size() ; i++) \\n            freq[i]=0;\\n        Permutations(nums, ans, ds, freq);\\n        return ans;\\n    }\\n};\\n```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 3) Most Optimal Recursive Approach \\uD83D\\uDD25\\nhttps://www.youtube.com/watch?v=f2ic2Rsc9pU&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=13\\n- Time complexity: O(n!*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    void Permutations(int ind, vector<int> &nums, vector<vector<int>> &ans){\\n        if(ind == nums.size()){\\n            ans.emplace_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        Permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# ***PLEASE UPVOTE IF IT HELPS \\u2764\\uFE0F***\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            ans.emplace_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void Permutations(vector<int> &nums, vector<vector<int>> &ans, vector<int> &ds, int freq[]){\\n        if(ds.size() == nums.size()){\\n            ans.emplace_back(ds);\\n            return;\\n        }\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(!freq[i]){\\n                ds.emplace_back(nums[i]);\\n                freq[i]++;\\n                Permutations(nums, ans, ds, freq);\\n                freq[i]--;\\n                ds.pop_back();\\n            }\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        int freq[nums.size()];\\n        for(int i=0 ; i<nums.size() ; i++) \\n            freq[i]=0;\\n        Permutations(nums, ans, ds, freq);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void Permutations(int ind, vector<int> &nums, vector<vector<int>> &ans){\\n        if(ind == nums.size()){\\n            ans.emplace_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        Permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816693,
                "title": "python-solution-93-utilized-the-same-logic-for-problem-39-and-40-with-illustration",
                "content": "It uses the same backtracking algorithm to solve problem 39 and 40. It will be very helpful if you look these 3 question all together. My post on those two questions also linked below. The chart to illustrate the process is in the bottom.\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process)\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration)\\n\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\'\\'\\'\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        self.helper(nums, [], ans)\\n        return ans\\n    \\n    def helper(self, nums, temp, ans):\\n        if len(nums)==0:\\n            ans.append(temp)\\n            return\\n\\n        for i in range(len(nums)):\\n            self.helper(nums[:i]+nums[i+1:],temp+[nums[i]],ans )\\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/f0af1aef-249f-4e08-8504-91f18c18a56e_1598625210.4955542.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "It uses the same backtracking algorithm to solve problem 39 and 40. It will be very helpful if you look these 3 question all together. My post on those two questions also linked below. The chart to illustrate the process is in the bottom.\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process)\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration)\\n\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\'\\'\\'\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        self.helper(nums, [], ans)\\n        return ans\\n    \\n    def helper(self, nums, temp, ans):\\n        if len(nums)==0:\\n            ans.append(temp)\\n            return\\n\\n        for i in range(len(nums)):\\n            self.helper(nums[:i]+nums[i+1:],temp+[nums[i]],ans )\\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/f0af1aef-249f-4e08-8504-91f18c18a56e_1598625210.4955542.png)\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3214018,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {   \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> &temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n            swap(temp[index] , temp[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {    \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {   \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> &temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n            swap(temp[index] , temp[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {    \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429530,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610172,
                "title": "intuitive-javascript-solution-with-dfs",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n  const output = [];\\n  /**\\n   * The goal is break down the problem by finding permutations in subarrays.\\n   * So we will maintain a subarray of fixed elements and a subarray for \\n   * exploring permutations.\\n   *\\n   *                  [1], [2, 3]    [1, 2], [3]    [1, 2, 3]\\n   * [], [1, 2, 3] -> [2], [1, 3] -> [1, 3], [2] -> [1, 3, 2]\\n   *                  [3], [1, 2]    [2, 1], [1]    [2, 1, 3]\\n   *                                 [2, 3], [1]    [2, 3, 1]\\n   *                                 [3, 1], [2]    [3, 1, 2]\\n   *                                 [3, 2], [1]    [3, 2, 1]                                 \\n   */\\n  const dfs = (curr, rest) => {\\n    // base case. Found a permutation because there\\'s nothing else to explore.\\n    if (rest.length === 0) {\\n      output.push(curr);\\n      return;\\n    }\\n    for (let i = 0; i < rest.length; i++) {\\n      dfs([...curr, rest[i]], [...rest.slice(0, i), ...rest.slice(i + 1)]);\\n    }\\n  }\\n  dfs([], nums);\\n  \\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n  const output = [];\\n  /**\\n   * The goal is break down the problem by finding permutations in subarrays.\\n   * So we will maintain a subarray of fixed elements and a subarray for \\n   * exploring permutations.\\n   *\\n   *                  [1], [2, 3]    [1, 2], [3]    [1, 2, 3]\\n   * [], [1, 2, 3] -> [2], [1, 3] -> [1, 3], [2] -> [1, 3, 2]\\n   *                  [3], [1, 2]    [2, 1], [1]    [2, 1, 3]\\n   *                                 [2, 3], [1]    [2, 3, 1]\\n   *                                 [3, 1], [2]    [3, 1, 2]\\n   *                                 [3, 2], [1]    [3, 2, 1]                                 \\n   */\\n  const dfs = (curr, rest) => {\\n    // base case. Found a permutation because there\\'s nothing else to explore.\\n    if (rest.length === 0) {\\n      output.push(curr);\\n      return;\\n    }\\n    for (let i = 0; i < rest.length; i++) {\\n      dfs([...curr, rest[i]], [...rest.slice(0, i), ...rest.slice(i + 1)]);\\n    }\\n  }\\n  dfs([], nums);\\n  \\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252489,
                "title": "python-backtracking-clean-concise",
                "content": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        self.ans = []\\n        \\n        def bt(i):\\n            if i == n:\\n                self.ans.append(deepcopy(nums))\\n                return\\n            \\n            for j in range(i, n):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                bt(i+1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n                \\n        bt(0)\\n        return self.ans\\n```\\n**Complexity**\\n- Time: `O(N!)`\\n- Space: `O(N!)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        self.ans = []\\n        \\n        def bt(i):\\n            if i == n:\\n                self.ans.append(deepcopy(nums))\\n                return\\n            \\n            for j in range(i, n):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                bt(i+1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n                \\n        bt(0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474624,
                "title": "c-beginner-explained-backtracking-clean",
                "content": "# ***Approach***\\n```\\nThis problem is very similar to finding combinations of a range but here we have to find permutations , and as we know in permutations we ordering matters\\n\\nmeans [1,2,3] != [2,1,3] != [3,2,1]\\n\\nwe will use visited vector to keep track of already present values in path\\nBenifit of using visited vector : it helps us to find whether a given value is present or not in a path in O(1) time!!!\\n\\nPath : holds single permutation at a time\\nvisited : stores true for all those indexes which are present in path\\nres : stores all permutations!!!!\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<vector<int>> permute(vector<int> &nums) {\\n        \\n        vector<int> path;\\n        vector<bool> visited(nums.size() , false);\\n        dfs(nums , path , visited);\\n        \\n        return res;\\n    }\\n    void dfs(vector<int> &nums , vector<int> &path , vector<bool> &visited)\\n    {\\n        if(path.size() == nums.size())\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i)\\n        {\\n            if(visited[i] == false)\\n            {\\n                visited[i] = true;\\n                path.push_back(nums[i]);\\n                \\n                dfs(nums , path , visited);\\n                \\n                path.pop_back();   // backtrack\\n                visited[i] = false;// backtrack\\n            }\\n        }\\n    }\\n};\\n```\\n# ***If you liked the solution , Please Upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nThis problem is very similar to finding combinations of a range but here we have to find permutations , and as we know in permutations we ordering matters\\n\\nmeans [1,2,3] != [2,1,3] != [3,2,1]\\n\\nwe will use visited vector to keep track of already present values in path\\nBenifit of using visited vector : it helps us to find whether a given value is present or not in a path in O(1) time!!!\\n\\nPath : holds single permutation at a time\\nvisited : stores true for all those indexes which are present in path\\nres : stores all permutations!!!!\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<vector<int>> permute(vector<int> &nums) {\\n        \\n        vector<int> path;\\n        vector<bool> visited(nums.size() , false);\\n        dfs(nums , path , visited);\\n        \\n        return res;\\n    }\\n    void dfs(vector<int> &nums , vector<int> &path , vector<bool> &visited)\\n    {\\n        if(path.size() == nums.size())\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i)\\n        {\\n            if(visited[i] == false)\\n            {\\n                visited[i] = true;\\n                path.push_back(nums[i]);\\n                \\n                dfs(nums , path , visited);\\n                \\n                path.pop_back();   // backtrack\\n                visited[i] = false;// backtrack\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18308,
                "title": "javascript-using-dp",
                "content": "Here's the common backtracking solution for comparison:\\n```\\nvar permute = function(nums) {\\n    const res = [];\\n    backtrack(nums, res);\\n    return res;\\n};\\n\\nfunction backtrack(nums, res, n = 0) {\\n    if (n === nums.length - 1) {\\n        res.push(nums.slice(0));\\n        return;\\n    }\\n    for (let i = n; i < nums.length; i++) {\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n        backtrack(nums, res, n + 1);\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n    }\\n}\\n```\\nThe DP solution came more naturally to my brain and OJ seems to like it for speed:\\n```\\nvar permute = function(nums, n = 0) {\\n    if (n >= nums.length) return [[]];\\n    const res = [];\\n    const prevs = permute(nums, n + 1);  // permutations of elements after n\\n    for (let prev of prevs) {\\n        for (let i = 0; i <= prev.length; i++) {\\n            let p = prev.slice(0);\\n            p.splice(i, 0, nums[n]);  // successively insert element n\\n            res.push(p);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar permute = function(nums) {\\n    const res = [];\\n    backtrack(nums, res);\\n    return res;\\n};\\n\\nfunction backtrack(nums, res, n = 0) {\\n    if (n === nums.length - 1) {\\n        res.push(nums.slice(0));\\n        return;\\n    }\\n    for (let i = n; i < nums.length; i++) {\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n        backtrack(nums, res, n + 1);\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n    }\\n}\\n```\n```\\nvar permute = function(nums, n = 0) {\\n    if (n >= nums.length) return [[]];\\n    const res = [];\\n    const prevs = permute(nums, n + 1);  // permutations of elements after n\\n    for (let prev of prevs) {\\n        for (let i = 0; i <= prev.length; i++) {\\n            let p = prev.slice(0);\\n            p.splice(i, 0, nums[n]);  // successively insert element n\\n            res.push(p);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527929,
                "title": "java-tc-o-n-n-sc-o-n-recursive-backtracking-iterative-solutions",
                "content": "**Recursive Backtracking**\\n\\n```java\\n/**\\n * Recursive Backtracking. In this solution passing the index of the nums that\\n * needs to be set in the current recursion.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n-1)\\n * ...\\n * T(2) = (2)*T(1) + O(2)\\n * T(1) = O(N) -> To convert the nums array to ArrayList.\\n *\\n * Above equations can be added together to get:\\n * T(n) = n + n*(n-1) + n*(n-1)*(n-2) + ... + (n....2) + (n....1) * n\\n *      = P(n,1) + P(n,2) + P(n,3) + ... + P(n,n-1) + n*P(n,n)\\n *      = (P(n,1) + ... + P(n,n)) + (n-1)*P(n,n)\\n *      = Floor(e*n! - 1) + (n-1)*n!\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        permutationsHelper(result, nums, 0);\\n        return result;\\n    }\\n\\n    private void permutationsHelper(List<List<Integer>> result, int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int n : nums) {\\n                list.add(n);\\n            }\\n            result.add(list);\\n            return;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            permutationsHelper(result, nums, start + 1);\\n            swap(nums, start, i);\\n        }\\n    }\\n\\n    private void swap(int[] nums, int x, int y) {\\n        int t = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = t;\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each\\n * permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Recursive Backtracking using visited array**\\n\\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        helper(result, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void helper(List<List<Integer>> result, List<Integer> temp, int[] nums, boolean[] visited) {\\n        if (temp.size() == nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            temp.add(nums[i]);\\n            visited[i] = true;\\n            helper(result, temp, nums, visited);\\n            visited[i] = false;\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Permutations questions on LeetCode:\\n- [47. Permutations II](https://leetcode.com/problems/permutations-ii/discuss/1527937/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Recursive-Backtracking-and-Iterative-Solutions)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Recursive Backtracking. In this solution passing the index of the nums that\\n * needs to be set in the current recursion.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n-1)\\n * ...\\n * T(2) = (2)*T(1) + O(2)\\n * T(1) = O(N) -> To convert the nums array to ArrayList.\\n *\\n * Above equations can be added together to get:\\n * T(n) = n + n*(n-1) + n*(n-1)*(n-2) + ... + (n....2) + (n....1) * n\\n *      = P(n,1) + P(n,2) + P(n,3) + ... + P(n,n-1) + n*P(n,n)\\n *      = (P(n,1) + ... + P(n,n)) + (n-1)*P(n,n)\\n *      = Floor(e*n! - 1) + (n-1)*n!\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        permutationsHelper(result, nums, 0);\\n        return result;\\n    }\\n\\n    private void permutationsHelper(List<List<Integer>> result, int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int n : nums) {\\n                list.add(n);\\n            }\\n            result.add(list);\\n            return;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            permutationsHelper(result, nums, start + 1);\\n            swap(nums, start, i);\\n        }\\n    }\\n\\n    private void swap(int[] nums, int x, int y) {\\n        int t = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = t;\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each\\n * permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        helper(result, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void helper(List<List<Integer>> result, List<Integer> temp, int[] nums, boolean[] visited) {\\n        if (temp.size() == nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            temp.add(nums[i]);\\n            visited[i] = true;\\n            helper(result, temp, nums, visited);\\n            visited[i] = false;\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18470,
                "title": "my-java-accepted-solution-without-additional-space",
                "content": "    public class Solution {\\n        public List<List<Integer>> permute(int[] num) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            permute(result, num, 0);\\n            return result;\\n        }\\n        \\n        private void permute(List<List<Integer>> result, int[] array, int start) {\\n    \\t\\tif (start >= array.length) {\\n    \\t\\t\\tList<Integer> current = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int a : array) {\\n    \\t\\t\\t    current.add(a);\\n    \\t\\t\\t}\\n    \\t\\t\\tresult.add(current);\\n    \\t\\t} else {\\n    \\t\\t\\tfor (int i=start; i<array.length; i++) {\\n    \\t\\t\\t\\tswap(array, start, i);\\n    \\t\\t\\t\\tpermute(result, array, start+1);\\n    \\t\\t\\t\\tswap(array, start, i);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tprivate void swap(int[] array, int i, int j) {\\n    \\t\\tint temp = array[i];\\n    \\t\\tarray[i] = array[j];\\n    \\t\\tarray[j] = temp;\\n    \\t}\\n    }\\n\\nI enumerate all the permutations in a generative way, the idea is that, at each position, I specify the element by swapping with values with a larger index. The value at the first position can swap with position 1,2,...,n-1, after each swap, I will do a recursion for the rest of the array. \\n\\nThe problem is that with this approach, the permutations may be out of order.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permute(int[] num) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            permute(result, num, 0);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18377,
                "title": "my-simple-javascript-recursive-solution",
                "content": "    var permute = function(nums) {\\n      let results = [];\\n    \\n      let permutations = (current, remaining) => {\\n        if(remaining.length <= 0) results.push(current.slice());\\n        else {\\n          for(let i = 0; i < remaining.length; i++) { // Loop through remaining elements\\n            current.push(remaining[i]); // Insert the iTH element onto the end of current\\n            permutations(current.slice(), remaining.slice(0, i).concat(remaining.slice(i+1))); // Recurse with inserted element removed\\n            current.pop(); // Remove last inserted element for next iteration\\n          }\\n        }\\n      };\\n    \\n      permutations([], nums);\\n      return results;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var permute = function(nums) {\\n      let results = [];\\n    \\n      let permutations = (current, remaining) => {\\n        if(remaining.length <= 0) results.push(current.slice());\\n        else {\\n          for(let i = 0; i < remaining.length; i++) { // Loop through remaining elements\\n            current.push(remaining[i]); // Insert the iTH element onto the end of current\\n            permutations(current.slice(), remaining.slice(0, i).concat(remaining.slice(i+1))); // Recurse with inserted element removed\\n            current.pop(); // Remove last inserted element for next iteration\\n          }\\n        }\\n      };\\n    \\n      permutations([], nums);\\n      return results;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 780823,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> result;\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        helper(nums, 0, (int)nums.size() - 1);\\n        \\n        return result;\\n    }\\n    \\n    void helper(vector<int> num_arr, int l, int r) {\\n        if (l == r){\\n            result.push_back(num_arr);\\n        } \\n        else {  \\n            for (int i = l; i <= r; i++) {\\n                swap(num_arr[l], num_arr[i]);\\n\\n                helper(num_arr, l + 1, r); \\n\\n                swap(num_arr[l], num_arr[i]);  \\n            }  \\n        }\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> result;\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        helper(nums, 0, (int)nums.size() - 1);\\n        \\n        return result;\\n    }\\n    \\n    void helper(vector<int> num_arr, int l, int r) {\\n        if (l == r){\\n            result.push_back(num_arr);\\n        } \\n        else {  \\n            for (int i = l; i <= r; i++) {\\n                swap(num_arr[l], num_arr[i]);\\n\\n                helper(num_arr, l + 1, r); \\n\\n                swap(num_arr[l], num_arr[i]);  \\n            }  \\n        }\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139642,
                "title": "clean-javascript-backtracking-solution",
                "content": "```js\\nconst permute = (nums) => {\\n  const res = [];\\n\\n  const go = (cur, rest) => {\\n    if (rest.length === 0) {\\n      res.push(cur);\\n      return;\\n    }\\n\\n    for (let i = 0; i < rest.length; i++) {\\n      // note if using array push and splice here, it will cause mutation\\n      go(\\n        [...cur, rest[i]],\\n        [...rest.slice(0, i), ...rest.slice(i + 1)],\\n      );\\n    }\\n  };\\n\\n  go([], nums);\\n  return res;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nconst permute = (nums) => {\\n  const res = [];\\n\\n  const go = (cur, rest) => {\\n    if (rest.length === 0) {\\n      res.push(cur);\\n      return;\\n    }\\n\\n    for (let i = 0; i < rest.length; i++) {\\n      // note if using array push and splice here, it will cause mutation\\n      go(\\n        [...cur, rest[i]],\\n        [...rest.slice(0, i), ...rest.slice(i + 1)],\\n      );\\n    }\\n  };\\n\\n  go([], nums);\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851480,
                "title": "c-python-c-0ms-backtrack-with-graph-explained-beginner-friendly",
                "content": "# Approach\\nUse a recursive function `backtrack`, in the function, we pass in a index.\\nIn the function, we use a for loop swap `nums[index]` with different numbers in `nums`.\\nAfter each swap, call `backtrack` again with `index+1`.\\nThen swap back the values, so that we can get every permutations as the graph shown below.\\n\\nIf `index` reach `n-1`, we kwon that we get one of the premutations.\\nSo just add `nums` into `arr`.\\nAfter all the recursion, we get our answer.\\n \\n![image.png](https://assets.leetcode.com/users/images/bde05504-fcb3-4ab0-98a5-98e24a83daed_1690955270.7047431.png)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> arr;\\n    void backtrack(vector<int>& nums, int n, int index){\\n        if(index == n - 1){\\n            arr.push_back(nums);\\n            return;\\n        }\\n        for(int i=index; i<n; i++){\\n            swap(nums[index], nums[i]);\\n            backtrack(nums, n, index+1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n = nums.size();\\n        backtrack(nums, n, 0);\\n        return arr;\\n    }\\n};\\n```\\n```c []\\n void swap(int* a, int* b){\\n     int temp = *a;\\n     *a = *b;\\n     *b = temp;\\n }\\n\\n void backtrack(int* nums, int numsSize, int*** arr, int* returnSize, int** returnColumnSizes, int index){\\n     if(index == numsSize - 1){\\n         (*returnSize)++;\\n         *arr = (int**)realloc(*arr, sizeof(int*) * (*returnSize));\\n         (*returnColumnSizes)[*returnSize - 1] = numsSize;\\n         (*arr)[*returnSize - 1] = (int*)malloc(sizeof(int) * numsSize);\\n         for(int i=0; i<numsSize; i++){\\n             (*arr)[*returnSize - 1][i] = nums[i];\\n         }\\n         return;\\n     }\\n     for(int i=index; i<numsSize; i++){\\n         swap(nums+index, nums+i);\\n         backtrack(nums, numsSize, arr, returnSize, returnColumnSizes, index + 1);\\n         swap(nums+index, nums+i);\\n     }\\n }\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = 1;\\n    for(int i=1; i<=numsSize; i++) (*returnSize) *= i;\\n    *returnColumnSizes = (int*)malloc(*returnSize * sizeof(int)); \\n    *returnSize = 0;\\n    int **arr = (int**)malloc(sizeof(int*));\\n    backtrack(nums, numsSize, &arr, returnSize, returnColumnSizes, 0);\\n    return arr;\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        arr = []\\n\\n        def backtrack(index):\\n            if(index == n):\\n                arr.append(nums[:])\\n                return\\n            for i in range(index, n):\\n                nums[index], nums[i] = nums[i], nums[index] # swap\\n                backtrack(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index] # swap back\\n        \\n        backtrack(0)\\n        return arr\\n```\\n# Please UPVOTE if this helps\\n![image.png](https://assets.leetcode.com/users/images/0edc260d-5815-41d8-af72-7a42927e99c8_1690956153.464619.png)\\n![image.png](https://assets.leetcode.com/users/images/85e39eaf-a380-450f-b311-0b2f67778c8c_1690953992.3802822.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> arr;\\n    void backtrack(vector<int>& nums, int n, int index){\\n        if(index == n - 1){\\n            arr.push_back(nums);\\n            return;\\n        }\\n        for(int i=index; i<n; i++){\\n            swap(nums[index], nums[i]);\\n            backtrack(nums, n, index+1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n = nums.size();\\n        backtrack(nums, n, 0);\\n        return arr;\\n    }\\n};\\n```\n```c []\\n void swap(int* a, int* b){\\n     int temp = *a;\\n     *a = *b;\\n     *b = temp;\\n }\\n\\n void backtrack(int* nums, int numsSize, int*** arr, int* returnSize, int** returnColumnSizes, int index){\\n     if(index == numsSize - 1){\\n         (*returnSize)++;\\n         *arr = (int**)realloc(*arr, sizeof(int*) * (*returnSize));\\n         (*returnColumnSizes)[*returnSize - 1] = numsSize;\\n         (*arr)[*returnSize - 1] = (int*)malloc(sizeof(int) * numsSize);\\n         for(int i=0; i<numsSize; i++){\\n             (*arr)[*returnSize - 1][i] = nums[i];\\n         }\\n         return;\\n     }\\n     for(int i=index; i<numsSize; i++){\\n         swap(nums+index, nums+i);\\n         backtrack(nums, numsSize, arr, returnSize, returnColumnSizes, index + 1);\\n         swap(nums+index, nums+i);\\n     }\\n }\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = 1;\\n    for(int i=1; i<=numsSize; i++) (*returnSize) *= i;\\n    *returnColumnSizes = (int*)malloc(*returnSize * sizeof(int)); \\n    *returnSize = 0;\\n    int **arr = (int**)malloc(sizeof(int*));\\n    backtrack(nums, numsSize, &arr, returnSize, returnColumnSizes, 0);\\n    return arr;\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        arr = []\\n\\n        def backtrack(index):\\n            if(index == n):\\n                arr.append(nums[:])\\n                return\\n            for i in range(index, n):\\n                nums[index], nums[i] = nums[i], nums[index] # swap\\n                backtrack(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index] # swap back\\n        \\n        backtrack(0)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310924,
                "title": "easy-to-understand-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n        {\\n            ans.push_back(nums);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n        {\\n            ans.push_back(nums);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790702,
                "title": "easy-to-understand-recursion-beats-97-38",
                "content": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n\\t\\t\\n\\t\\t# Base conditions\\n\\t\\t# If length is 0 or 1, there is only 1 permutation\\n        if n in [0, 1]:\\n            return [nums]\\n\\t\\t\\n\\t\\t# If length is 2, then there are only two permutations\\n\\t\\t# Example: [1,2] and [2,1]\\n        if n == 2:\\n            return [nums, nums[::-1]]\\n\\t\\t\\t\\n        res = []\\n\\t\\t# For every number in array, choose 1 number and permute the remaining\\n\\t\\t# by calling permute recursively\\n        for i in range(n):\\n            permutations = self.permute(nums[:i] + nums[i+1:])\\n            for p in permutations:\\n                res.append([nums[i]] + p)\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n\\t\\t\\n\\t\\t# Base conditions\\n\\t\\t# If length is 0 or 1, there is only 1 permutation\\n        if n in [0, 1]:\\n            return [nums]\\n\\t\\t\\n\\t\\t# If length is 2, then there are only two permutations\\n\\t\\t# Example: [1,2] and [2,1]\\n        if n == 2:\\n            return [nums, nums[::-1]]\\n\\t\\t\\t\\n        res = []\\n\\t\\t# For every number in array, choose 1 number and permute the remaining\\n\\t\\t# by calling permute recursively\\n        for i in range(n):\\n            permutations = self.permute(nums[:i] + nums[i+1:])\\n            for p in permutations:\\n                res.append([nums[i]] + p)\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18444,
                "title": "new-approach-directly-find-the-kth-permutation-k-1-n-with-a-simple-loop",
                "content": "# Explanation\\n\\nThe general idea is the following (same as other solutions):\\n\\n 1. We know there are `n!` possible permutations for `n` elements.\\n 2. Enumerate them one by one\\n\\nMost solutions use the previous permutation to generate the next permutation or build it recursively.\\nI had the idea to calculate the `k`<sup>th</sup> permutation directly from the input. Steps are as follows:\\n\\n 1. Build a list of all elements in ascending order.  \\nThe length of this list is `n` (i.e. not the original input size).\\n 2. Given `k` we know what the first element will be in the `k`<sup>th</sup> permutation of the current list.  \\nThere are `n` groups in the lexicographical order of all permutations of the list. Inside a group each permutation's first element is the same. Each group has `(n-1)!` elements, so an easy `k / (n-1)!` will give us the index.\\n 3. Append the selected element to the result, i.e. the next element in the `k`<sup>th</sup> permutation.\\n 4. Remove the selected element from the list.  \\n 5. Now the list has one less elements and we can **repeat from Step 2** with `k' = k % n!`,  \\nthat is the `k'`<sup>th</sup> permutation of the reduced list.\\n\\nNotice that it doesn't matter what the elements are because the indices are calculated.\\n\\n# Examples for `n = 1...4`\\n\\n    elements  k    indices\\n    []        -    -       =----- trivial\\n\\n    [1]       0    0       =----- reduces to [] after selecting 1\\n\\n    [1,2]     0    0 0     =----- reduces to [2] after selecting 1\\n    [2,1]     1    1 0     =----- reduces to [1] after selecting 2\\n    \\n    [1,2,3]   0    0 0 0   =\\\\____ reduces to [2,3] after selecting 1\\n    [1,3,2]   1    0 1 0   =/\\n    [2,1,3]   2    1 0 0   =\\\\____ reduces to [1,3] after selecting 2\\n    [2,3,1]   3    1 1 0   =/\\n    [3,1,2]   4    2 0 0   =\\\\____ reduces to [1,2] after selecting 3\\n    [3,2,1]   5    2 1 0   =/\\n    \\n    [1,2,3,4] 0    0 0 0 0 =\\\\\\n    [1,2,4,3] 1    0 0 1 0   \\\\\\n    [1,3,2,4] 2    0 1 0 0    \\\\__ reduces to [2,3,4] after selecting 1\\n    [1,3,4,2] 3    0 1 1 0    /\\n    [1,4,2,3] 4    0 2 0 0   /\\n    [1,4,3,2] 5    0 2 1 0 =/\\n    [2,1,3,4] 6    1 0 0 0 =\\\\\\n    [2,1,4,3] 7    1 0 1 0   \\\\\\n    [2,3,1,4] 8    1 1 0 0    \\\\__ reduces to [1,3,4] after selecting 2\\n    [2,3,4,1] 9    1 1 1 0    /\\n    [2,4,1,3] 10   1 2 0 0   /\\n    [2,4,3,1] 11   1 1 1 0 =/\\n    [3,1,2,4] 12   2 0 0 0 =\\\\\\n    [3,1,4,2] 13   2 0 1 0   \\\\\\n    [3,2,1,4] 14   2 1 0 0    \\\\__ reduces to [1,2,4] after selecting 3\\n    [3,2,4,1] 15   2 1 1 0    /\\n    [3,4,1,2] 16   2 2 0 0   /\\n    [3,4,2,1] 17   2 2 1 0 =/\\n    [4,1,2,3] 18   3 0 0 0 =\\\\\\n    [4,1,3,2] 19   3 0 1 0   \\\\\\n    [4,2,1,3] 20   3 1 0 0    \\\\__ reduces to [1,2,3] after selecting 4\\n    [4,2,3,1] 21   3 1 1 0    /\\n    [4,3,1,2] 22   3 2 0 0   /\\n    [4,3,2,1] 23   3 2 1 0 =/\\n\\n# Code\\n\\n**The fact of `FACT`**: since the problem asks for **all** permutations we can be sure it won't ask for more than `12` elements, because `13!` is out of range for `int` and all lists are indexed by `int`s. Also `12!` permutations of `12` elements in `List<List>` is good `7GiB` worth of memory.\\n\\n    public class Solution {\\n        private static final int[] FACT = { // 479001600 < 2147483647 < 6227020800\\n            1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600\\n        };\\n        public List<List<Integer>> permute(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result = new ArrayList<>(nums.length);\\n            for (int k = 0; k < FACT[nums.length]; ++k) {\\n                result.add(permutation(nums, k));\\n            }\\n            return result;\\n        }\\n        List<Integer> permutation(int[] nums, int k) {\\n            // k %= FACT[nums.length]; // in case you want to use it elsewhere\\n            List<Integer> source = toList(nums);\\n            List<Integer> result = new ArrayList(nums.length);\\n            while (!source.isEmpty()) {\\n                int f = FACT[source.size() - 1];\\n                result.add(source.remove(k / f));\\n                k %= f;\\n            }\\n            return result;\\n        }\\n        List<Integer> toList(int[] nums) {\\n            List<Integer> result = new LinkedList<>();\\n            for (int num : nums) {\\n                result.add(num);\\n            }\\n            return result;\\n        }\\n    }\\n\\n# Analysis\\n\\nIt's clear that we need to iterate `n!` times, because we're generating `n!` elements.\\nThe `permutation` method looks like `O(n)`, but sadly it's `O(n^2)` because `remove` takes `O(n)`:\\n\\n * `LinkedList`  \\n`i` steps to find the `i`<sup>th</sup> element and `O(1)` to remove it\\n * `ArrayList`  \\n`O(1)` to find the `i`<sup>th</sup> element and `n-i` steps to remove the `i`<sup>th</sup> element\\n * keep `int[] nums` and `boolean[] removed`  \\nwe have to iterate over each removed item, so `O(n)`\\n * `Map<Integer, Integer>`  \\nmay be better, but we have to re-index all remaining elements\\n * **Is there a better data structure for this?**\\n\\n# Code variations\\n\\nIn case you don't like the hardcoded `FACT`:\\n\\n    /* 12! = 479001600 < Integer.MAX_VALUE = 2147483647 < 13! = 6227020800 */\\n    private static final int[] FACT = factorials(12);\\n    static int[] factorials(int n) {\\n        int[] f = new int[n+1];\\n        f[0] = f[1] = 1;\\n        for (int i = 2; i <= n; ++i) {\\n            f[i] = f[i-1] * i;\\n        }\\n        return f;\\n    }\\n\\nor it's even possible to calculate `n!` only once and keep reducing it, but then we have to pass an extra unrelated argument.\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>(nums.length);\\n        int fact = factorial(nums.length);\\n        for (int k = 0; k < fact; ++k) {\\n            result.add(permutation(nums, fact, k));\\n        }\\n        return result;\\n    }\\n    List<Integer> permutation(int[] nums, int f, int k) {\\n        if (nums.length == 0) return Collections.emptyList();\\n        List<Integer> source = toList(nums);\\n        List<Integer> result = new ArrayList(nums.length);\\n        do {\\n            k %= f;\\n            f /= source.size();\\n            result.add(source.remove(k / f));\\n        } while (!source.isEmpty());\\n        return result;\\n    }\\n    static int factorial(int n) {\\n        if (n <= 1) return 1;\\n        int result = n;\\n        while (--n > 1) {\\n            result *= n;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        private static final int[] FACT = { // 479001600 < 2147483647 < 6227020800\\n            1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3851346,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing backtracking to create all possible combinations\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/J7m7W7P6e3s\\n\\n# Subscribe to my channel from here. I have 238 videos as of August 2nd\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python solution. Other might be different a bit.\\n\\n1. The function `permute` takes a list of integers `nums` as input and aims to generate all possible permutations of the elements in the input list.\\n\\n2. The base case is checked: if the length of the `nums` list is 1, then it means there\\'s only one element left to permute, and at this point, a list containing that single element is returned as a permutation.\\n\\n3. If the `nums` list has more than one element, the algorithm proceeds with permutation generation.\\n\\n4. Initialize an empty list `res` to store the permutations.\\n\\n5. Iterate over each element in the `nums` list (using `_` as a placeholder for the loop variable). In each iteration, pop the first element `n` from the `nums` list.\\n\\n6. Recursively call the `permute` function on the remaining elements in `nums` after removing the first element. This generates all possible permutations of the remaining elements.\\n\\n7. For each permutation `p` generated in the recursive call, append the previously removed element `n` to it.\\n\\n8. Extend the `res` list with the permutations generated in the recursive calls, each with the element `n` appended.\\n\\n9. After the loop completes, add the removed element `n` back to the end of the `nums` list, restoring the original state for the next iteration.\\n\\n10. Finally, return the list `res` containing all the generated permutations.\\n\\nIn summary, this code uses a recursive approach to generate all possible permutations of the input list `nums`. It removes one element at a time, generates permutations for the remaining elements, appends the removed element to those permutations, and collects all permutations in the `res` list. The recursion continues until only one element is left in the list, at which point a permutation containing that single element is returned. \\n\\n# Complexity\\n- Time complexity: O(n * n!)\\n\\n    - Recursive Calls: The permute function is called recursively, and each time it generates permutations for a smaller list by removing one element. In the worst case, the recursion depth is equal to the length of the input list nums, which is n.\\n\\n    - Permutation Generation: For each index, we are generating permutations for the remaining elements and appending the removed element at the end. This involves recursive calls and list manipulations. In general time complexity of permutation should be O(n!)\\n\\n- Space complexity: O(n)\\n    - Recursion Depth: The depth of recursion goes up to the number of elements in the input list. So, the maximum recursion depth is O(n).\\n    - Additional Memory: The additional memory usage includes the res list, the n variable, and the space used in each recursive call.\\n\\n        Considering these factors, the space complexity is O(n)\\n\\n\\n```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums[:]]\\n        \\n        res = []\\n\\n        for _ in range(len(nums)):\\n            n = nums.pop(0)\\n            perms = self.permute(nums)\\n\\n            for p in perms:\\n                p.append(n)\\n            \\n            res.extend(perms)\\n            nums.append(n)\\n        \\n        return res\\n            \\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    if (nums.length === 1) {\\n        return [nums.slice()];\\n    }\\n    \\n    var res = [];\\n\\n    for (var i = 0; i < nums.length; i++) {\\n        var n = nums.shift();\\n        var perms = permute(nums.slice());\\n\\n        for (var p of perms) {\\n            p.push(n);\\n        }\\n        \\n        res.push(...perms);\\n        nums.push(n);\\n    }\\n    \\n    return res;  \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums.length == 1) {\\n            List<Integer> singleList = new ArrayList<>();\\n            singleList.add(nums[0]);\\n            res.add(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int[] remainingNums = new int[nums.length - 1];\\n            int index = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (j != i) {\\n                    remainingNums[index] = nums[j];\\n                    index++;\\n                }\\n            }\\n            \\n            List<List<Integer>> perms = permute(remainingNums);\\n            for (List<Integer> p : perms) {\\n                p.add(n);\\n            }\\n            \\n            res.addAll(perms);\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        if (nums.size() == 1) {\\n            vector<int> singleList;\\n            singleList.push_back(nums[0]);\\n            res.push_back(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int n = nums[i];\\n            vector<int> remainingNums;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (j != i) {\\n                    remainingNums.push_back(nums[j]);\\n                }\\n            }\\n            \\n            vector<vector<int>> perms = permute(remainingNums);\\n            for (vector<int> p : perms) {\\n                p.insert(p.begin(), n);  // Insert n at the beginning of the permutation\\n                res.push_back(p);  // Append the modified permutation to the result\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```\\n\\n- This is bonus codes I don\\'t explain in the article.\\n\\n```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n\\n        def backtrack(start):\\n            if start == len(nums):\\n                res.append(nums[:])\\n                return\\n            \\n            for i in range(start, len(nums)):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start + 1)\\n                nums[start], nums[i] = nums[i], nums[start]\\n\\n        res = []\\n        backtrack(0)\\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const backtrack = (start) => {\\n        if (start === nums.length) {\\n            res.push([...nums]);\\n            return;\\n        }\\n        \\n        for (let i = start; i < nums.length; i++) {\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n            backtrack(start + 1);\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n        }\\n    };\\n\\n    const res = [];\\n    backtrack(0);\\n    return res;  \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, res);\\n        return res;    \\n    }\\n\\n    private void backtrack(int[] nums, int start, List<List<Integer>> res) {\\n        if (start == nums.length) {\\n            res.add(arrayToList(nums));\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            backtrack(nums, start + 1, res);\\n            swap(nums, start, i);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : arr) {\\n            list.add(num);\\n        }\\n        return list;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }    \\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(nums, 0, res);\\n        return res;\\n    }\\n\\n    void backtrack(vector<int>& nums, int start, vector<vector<int>>& res) {\\n        if (start == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            swap(nums[start], nums[i]);\\n            backtrack(nums, start + 1, res);\\n            swap(nums[start], nums[i]);\\n        }\\n    }\\n    \\n    void swap(int& a, int& b) {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n    }    \\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums[:]]\\n        \\n        res = []\\n\\n        for _ in range(len(nums)):\\n            n = nums.pop(0)\\n            perms = self.permute(nums)\\n\\n            for p in perms:\\n                p.append(n)\\n            \\n            res.extend(perms)\\n            nums.append(n)\\n        \\n        return res\\n            \\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    if (nums.length === 1) {\\n        return [nums.slice()];\\n    }\\n    \\n    var res = [];\\n\\n    for (var i = 0; i < nums.length; i++) {\\n        var n = nums.shift();\\n        var perms = permute(nums.slice());\\n\\n        for (var p of perms) {\\n            p.push(n);\\n        }\\n        \\n        res.push(...perms);\\n        nums.push(n);\\n    }\\n    \\n    return res;  \\n};\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums.length == 1) {\\n            List<Integer> singleList = new ArrayList<>();\\n            singleList.add(nums[0]);\\n            res.add(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int[] remainingNums = new int[nums.length - 1];\\n            int index = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (j != i) {\\n                    remainingNums[index] = nums[j];\\n                    index++;\\n                }\\n            }\\n            \\n            List<List<Integer>> perms = permute(remainingNums);\\n            for (List<Integer> p : perms) {\\n                p.add(n);\\n            }\\n            \\n            res.addAll(perms);\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        if (nums.size() == 1) {\\n            vector<int> singleList;\\n            singleList.push_back(nums[0]);\\n            res.push_back(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int n = nums[i];\\n            vector<int> remainingNums;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (j != i) {\\n                    remainingNums.push_back(nums[j]);\\n                }\\n            }\\n            \\n            vector<vector<int>> perms = permute(remainingNums);\\n            for (vector<int> p : perms) {\\n                p.insert(p.begin(), n);  // Insert n at the beginning of the permutation\\n                res.push_back(p);  // Append the modified permutation to the result\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n\\n        def backtrack(start):\\n            if start == len(nums):\\n                res.append(nums[:])\\n                return\\n            \\n            for i in range(start, len(nums)):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start + 1)\\n                nums[start], nums[i] = nums[i], nums[start]\\n\\n        res = []\\n        backtrack(0)\\n        return res\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const backtrack = (start) => {\\n        if (start === nums.length) {\\n            res.push([...nums]);\\n            return;\\n        }\\n        \\n        for (let i = start; i < nums.length; i++) {\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n            backtrack(start + 1);\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n        }\\n    };\\n\\n    const res = [];\\n    backtrack(0);\\n    return res;  \\n};\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, res);\\n        return res;    \\n    }\\n\\n    private void backtrack(int[] nums, int start, List<List<Integer>> res) {\\n        if (start == nums.length) {\\n            res.add(arrayToList(nums));\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            backtrack(nums, start + 1, res);\\n            swap(nums, start, i);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : arr) {\\n            list.add(num);\\n        }\\n        return list;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }    \\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(nums, 0, res);\\n        return res;\\n    }\\n\\n    void backtrack(vector<int>& nums, int start, vector<vector<int>>& res) {\\n        if (start == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            swap(nums[start], nums[i]);\\n            backtrack(nums, start + 1, res);\\n            swap(nums[start], nums[i]);\\n        }\\n    }\\n    \\n    void swap(int& a, int& b) {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681162,
                "title": "100-faster-c-solution-simple-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums, vector<vector<int>>& ans, int index){\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j=index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            solve(nums, ans, index+1); //recursive call\\n            swap(nums[index], nums[j]); //backtracking\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums,ans,index);\\n        return ans;\\n    }\\n};\\n```\\nPlease Upvote If You Find the Solution Helpful..\\nHappy Coding !",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums, vector<vector<int>>& ans, int index){\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j=index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            solve(nums, ans, index+1); //recursive call\\n            swap(nums[index], nums[j]); //backtracking\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums,ans,index);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898253,
                "title": "easyway-explanation-every-step",
                "content": "```\\n\\ndfs(nums = [1, 2, 3] , path = [] , result = [] )\\n|____ dfs(nums = [2, 3] , path = [1] , result = [] )\\n|      |___dfs(nums = [3] , path = [1, 2] , result = [] )\\n|      |    |___dfs(nums = [] , path = [1, 2, 3] , result = [[1, 2, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [2] , path = [1, 3] , result = [[1, 2, 3]] )\\n|           |___dfs(nums = [] , path = [1, 3, 2] , result = [[1, 2, 3], [1, 3, 2]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 3] , path = [2] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |___dfs(nums = [3] , path = [2, 1] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |    |___dfs(nums = [] , path = [2, 1, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [1] , path = [2, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] )\\n|           |___dfs(nums = [] , path = [2, 3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 2] , path = [3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |___dfs(nums = [2] , path = [3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |    |___dfs(nums = [] , path = [3, 1, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] ) # added a new permutation to the result\\n       |___dfs(nums = [1] , path = [3, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] )\\n            |___dfs(nums = [] , path = [3, 2, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ) # added a new permutation to the results\\n\\n\\n```\\n\\n```\\ndef permute(self, nums):\\n    res = []\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n        # return # backtracking\\n    for i in range(len(nums)):\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n\\ndfs(nums = [1, 2, 3] , path = [] , result = [] )\\n|____ dfs(nums = [2, 3] , path = [1] , result = [] )\\n|      |___dfs(nums = [3] , path = [1, 2] , result = [] )\\n|      |    |___dfs(nums = [] , path = [1, 2, 3] , result = [[1, 2, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [2] , path = [1, 3] , result = [[1, 2, 3]] )\\n|           |___dfs(nums = [] , path = [1, 3, 2] , result = [[1, 2, 3], [1, 3, 2]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 3] , path = [2] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |___dfs(nums = [3] , path = [2, 1] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |    |___dfs(nums = [] , path = [2, 1, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [1] , path = [2, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] )\\n|           |___dfs(nums = [] , path = [2, 3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 2] , path = [3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |___dfs(nums = [2] , path = [3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |    |___dfs(nums = [] , path = [3, 1, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] ) # added a new permutation to the result\\n       |___dfs(nums = [1] , path = [3, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] )\\n            |___dfs(nums = [] , path = [3, 2, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ) # added a new permutation to the results\\n\\n\\n```\n```\\ndef permute(self, nums):\\n    res = []\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n        # return # backtracking\\n    for i in range(len(nums)):\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1861293,
                "title": "simple-java-solution-with-full-explanation-simple-recursion-1-ms-faster-than-93-44",
                "content": "![image](https://assets.leetcode.com/users/images/2c97ed56-e3b7-47bf-8a01-7e9bcc9d7e47_1647625201.5840182.jpeg)\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        return permutation(new ArrayList<>(),nums);\\n    }\\n    public List<List<Integer>> permutation(List<Integer> p,int[] up){\\n        \\n        if(up.length==0){\\n            List<List<Integer>> sublist=new ArrayList<>();\\n            sublist.add(p);\\n            return sublist;\\n        }\\n        int num=up[0];\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<=p.size();i++){\\n            List<Integer> new1=new ArrayList<>();\\n            new1.addAll(p.subList(0,i));\\n            new1.add(num);\\n            new1.addAll(p.subList(i,p.size()));\\n            ans.addAll(permutation(new1,Arrays.copyOfRange(up, 1, up.length)));\\n        }\\n        return ans;\\n    }\\n}\\n\\n// If it seems to easy to understand, give a upvote(reputation)\\uD83D\\uDC4Dto motivate me\\uD83D\\uDE09\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        return permutation(new ArrayList<>(),nums);\\n    }\\n    public List<List<Integer>> permutation(List<Integer> p,int[] up){\\n        \\n        if(up.length==0){\\n            List<List<Integer>> sublist=new ArrayList<>();\\n            sublist.add(p);\\n            return sublist;\\n        }\\n        int num=up[0];\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<=p.size();i++){\\n            List<Integer> new1=new ArrayList<>();\\n            new1.addAll(p.subList(0,i));\\n            new1.add(num);\\n            new1.addAll(p.subList(i,p.size()));\\n            ans.addAll(permutation(new1,Arrays.copyOfRange(up, 1, up.length)));\\n        }\\n        return ans;\\n    }\\n}\\n\\n// If it seems to easy to understand, give a upvote(reputation)\\uD83D\\uDC4Dto motivate me\\uD83D\\uDE09\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090060,
                "title": "simple-c-using-backtracking-and-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply do swaping recusrively for every index and bactrack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo approaches \\n- Using Backtracking\\n- Using STL function\\n# Complexity\\n- Time complexity:$$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n!)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Using Backtracking**\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void permutation(vector<int>&arr,int start){\\n        if(start==arr.size())\\n        ans.push_back(arr);\\n\\n        for(int i=start;i<arr.size();i++){\\n              swap(arr[i],arr[start]);\\n              permutation(arr,start+1);\\n              swap(arr[i],arr[start]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        \\n        vector<int>temp;\\n        permutation(arr,0);\\n        return ans;\\n    }\\n};\\n```\\n**USING STL Function**\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> permute(vector<int>& arr) {\\n       vector<vector<int>>ans;\\n         sort(arr.begin(),arr.end());\\n         do{\\n            ans.push_back(arr);\\n         }while(next_permutation(arr.begin(),arr.end()));\\n        return ans;\\n    }\\n};\\n```\\n# UpVote If HELPFULL \\uD83D\\uDD3C\\uD83D\\uDD3C",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void permutation(vector<int>&arr,int start){\\n        if(start==arr.size())\\n        ans.push_back(arr);\\n\\n        for(int i=start;i<arr.size();i++){\\n              swap(arr[i],arr[start]);\\n              permutation(arr,start+1);\\n              swap(arr[i],arr[start]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        \\n        vector<int>temp;\\n        permutation(arr,0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> permute(vector<int>& arr) {\\n       vector<vector<int>>ans;\\n         sort(arr.begin(),arr.end());\\n         do{\\n            ans.push_back(arr);\\n         }while(next_permutation(arr.begin(),arr.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036237,
                "title": "clean-short-approach-in-python-with-intution-explained",
                "content": "In recursion you want to think of an obvious solution, a solution which you\\'re sure of, which is obvious. For ex: what will be the list of permutations of [1]? obviously it\\'ll be [1] only. This makes our base case.\\n\\nNext you need to think about how a normal typical person would go about solving it. Taking another example:\\nfor [1, 2, 3] I would go about it like this:\\n1) fix 1 at 1st position and get all permutation for [2, 3], which would give me [1, 2, 3], and [1, 3, 2].\\n2) fix 2 at 1st position and get all permutation for [1, 3], which would give me [2, 1, 3], and [2, 3, 1].\\n3) fix 3 at 1st position and get all permutation for [2, 3], which would give me [3, 2, 1], and [3, 1, 2].\\n\\nBelow is my code based on just the above approach\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef permute(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn [nums]\\n\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\t\\t\\t\\tsub_prob = self.permute(nums[1:])\\n\\t\\t\\t\\tfor sub_ans in sub_prob:\\n\\t\\t\\t\\t\\tans.append([nums[0]] + sub_ans)\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\n\\t\\t\\treturn ans\\n\\n\\'\\'\\'\\n\\nHope it helps. Thanks.",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "In recursion you want to think of an obvious solution, a solution which you\\'re sure of, which is obvious. For ex: what will be the list of permutations of [1]? obviously it\\'ll be [1] only. This makes our base case.\\n\\nNext you need to think about how a normal typical person would go about solving it. Taking another example:\\nfor [1, 2, 3] I would go about it like this:\\n1) fix 1 at 1st position and get all permutation for [2, 3], which would give me [1, 2, 3], and [1, 3, 2].\\n2) fix 2 at 1st position and get all permutation for [1, 3], which would give me [2, 1, 3], and [2, 3, 1].\\n3) fix 3 at 1st position and get all permutation for [2, 3], which would give me [3, 2, 1], and [3, 1, 2].\\n\\nBelow is my code based on just the above approach\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef permute(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn [nums]\\n\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\t\\t\\t\\tsub_prob = self.permute(nums[1:])\\n\\t\\t\\t\\tfor sub_ans in sub_prob:\\n\\t\\t\\t\\t\\tans.append([nums[0]] + sub_ans)\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\n\\t\\t\\treturn ans\\n\\n\\'\\'\\'\\n\\nHope it helps. Thanks.",
                "codeTag": "Java"
            },
            {
                "id": 586822,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/newbiecoder1/image_1587275499.png)\\n\\n**Solution 1**\\n```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Backtracking(nums, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(list.Contains(nums[i]))\\n                    continue;\\n                list.Add(nums[i]);\\n                Backtracking(nums, list, res);\\n                list.RemoveAt(list.Count -1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Solution 2**\\n```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Backtracking(nums, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(list.Contains(nums[i]))\\n                    continue;\\n                list.Add(nums[i]);\\n                Backtracking(nums, list, res);\\n                list.RemoveAt(list.Count -1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168050,
                "title": "python-iterative-solution-beat-99",
                "content": "The idea is to insert new num in the existing permutation to form new permutations.\\n\\nFor example, suppose we need to get all permutation of `[1, 2, 3]`. Assume that we have got the permutation of `[1, 2]`, so `result = [[1, 2], [2, 1]]`. Then we could add 3 to each position of each element of result to get all permutations with number 3. The idea is kind of like BFS. \\n\\nAs a time optimization, we do not actually insert 3 in existing permutation because it takes O(N) for each insertation. We could simply append 3 to the end of [1, 2] and then swap each element with 3 to get new permutation. \\n\\n```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            new_res = []\\n            for i in range(len(res)):\\n                prev = res[i]\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    new_res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n            res = new_res\\n        return res\\n```\\n\\nThe space could be further optimized by using one array. \\n\\n```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            size = len(res)\\n            for i in range(size):\\n                prev = res.pop(0)\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n        return res\\n```\\n\\nA little bit slower, since pop(0) also takes O(N), can be avoid by using `deque`  though. \\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            new_res = []\\n            for i in range(len(res)):\\n                prev = res[i]\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    new_res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n            res = new_res\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            size = len(res)\\n            for i in range(size):\\n                prev = res.pop(0)\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850847,
                "title": "easy-explanation-short-code-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to generate all possible permutations of a given set of numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a recursive backtracking approach to generate all the permutations. It starts by fixing the first element of the permutation and then recursively generates the permutations for the remaining elements by swapping the first element with each of the subsequent elements. This process continues until all elements have been considered as the first element.\\n\\n> Inside the \\'solve\\' function:\\n-  It checks if \\'ind\\' is equal to the size of \\'nums\\'. If it is, that means we have formed one permutation, so it adds \\'nums\\' to the \\'res\\' vector and returns from the function.\\n-  Otherwise, it enters a loop starting from the current \\'ind\\' up to the end of the \\'nums\\' vector\\n- Inside the loop, it swaps the elements at \\'ind\\' and \\'i\\' indices to try different possibilities for the first element.\\n-  After swapping, it makes a recursive call to \\'solve\\' with \\'ind+1\\' (moving to the next index) to generate permutations for the remaining elements.\\n\\n`Let\\'s analyze the time complexity of the code. For each element at index \\'ind\\', there are \\'n - ind\\' choices to be made for swapping (where \\'n\\' is the total number of elements). Then, for each choice, we make a recursive call to generate permutations for the remaining elements. Therefore, the time complexity of this algorithm can be expressed as O(n * n!), where \\'n\\' is the number of elements in the input vector \\'nums\\'.`\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n*n!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void solve(int ind ,vector<int>&nums,vector<vector<int>>&res){\\n        if(ind == nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,res);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(0,nums,res);\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void solve(int ind ,vector<int>&nums,vector<vector<int>>&res){\\n        if(ind == nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,res);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(0,nums,res);\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909417,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n\\tfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\t\\tvar res: [[Int]] = []\\n        \\n\\n\\t\\tfunc recursion(_ list: [Int], _ rest: [Int]) -> Void {\\n            for (i, item) in rest.enumerated() {\\n\\t\\t\\t\\tvar list = list\\n\\t\\t\\t\\tvar rest = rest\\n\\n\\t\\t\\t\\tlist.append(item)\\n\\t\\t\\t\\trest.remove(at: i)\\n\\t\\t\\t\\tif (list.count == nums.count) { res.append(list) }\\n                recursion(list, rest)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trecursion([], nums)\\n\\t\\treturn res\\n\\t}\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\t\\tvar res: [[Int]] = []\\n        \\n\\n\\t\\tfunc recursion(_ list: [Int], _ rest: [Int]) -> Void {\\n            for (i, item) in rest.enumerated() {\\n\\t\\t\\t\\tvar list = list\\n\\t\\t\\t\\tvar rest = rest\\n\\n\\t\\t\\t\\tlist.append(item)\\n\\t\\t\\t\\trest.remove(at: i)\\n\\t\\t\\t\\tif (list.count == nums.count) { res.append(list) }\\n                recursion(list, rest)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trecursion([], nums)\\n\\t\\treturn res\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700569,
                "title": "solution-swift-permutations",
                "content": "```swift\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 1 && len <= 6 else { return [] }\\n        \\n        var permutes = [[Int]](repeating: [], count: 1)\\n        \\n        for n in nums where n >= -10 && n <= 10 {\\n            var values: [[Int]] = []\\n            for var arr in permutes {\\n                for i in 0..<arr.count {\\n                    var temp = arr\\n                    temp.insert(n, at: i)\\n                    values.append(temp)\\n                }\\n                arr.append(n)\\n                values.append(arr)\\n            }\\n            permutes = values\\n        }\\n        \\n        return permutes\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 1 && len <= 6 else { return [] }\\n        \\n        var permutes = [[Int]](repeating: [], count: 1)\\n        \\n        for n in nums where n >= -10 && n <= 10 {\\n            var values: [[Int]] = []\\n            for var arr in permutes {\\n                for i in 0..<arr.count {\\n                    var temp = arr\\n                    temp.insert(n, at: i)\\n                    values.append(temp)\\n                }\\n                arr.append(n)\\n                values.append(arr)\\n            }\\n            permutes = values\\n        }\\n        \\n        return permutes\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541908,
                "title": "python-bfs-solution",
                "content": "Python BFS solution\\n\\n```python\\nfrom collections import deque\\ndef permute(self, nums: List[int]) -> List[List[int]]:        \\n\\tif len(nums) <= 1:\\n\\t\\treturn [nums]\\n\\n\\tans = []\\n\\tqueue = deque([([], nums)])\\n\\n\\twhile queue:\\n\\t\\tarr, options = queue.popleft()\\n\\n\\t\\tfor i in range(len(options)):\\n\\t\\t\\tnext_options = options[:i] + options[i+1:]\\n\\t\\t\\tnew_arr = arr + [options[i]]\\n\\n\\t\\t\\tif next_options:\\n\\t\\t\\t\\tqueue.append((new_arr, next_options))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(new_arr)\\n\\n\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "Python BFS solution\\n\\n```python\\nfrom collections import deque\\ndef permute(self, nums: List[int]) -> List[List[int]]:        \\n\\tif len(nums) <= 1:\\n\\t\\treturn [nums]\\n\\n\\tans = []\\n\\tqueue = deque([([], nums)])\\n\\n\\twhile queue:\\n\\t\\tarr, options = queue.popleft()\\n\\n\\t\\tfor i in range(len(options)):\\n\\t\\t\\tnext_options = options[:i] + options[i+1:]\\n\\t\\t\\tnew_arr = arr + [options[i]]\\n\\n\\t\\t\\tif next_options:\\n\\t\\t\\t\\tqueue.append((new_arr, next_options))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(new_arr)\\n\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 18486,
                "title": "simple-python-solution-68ms",
                "content": "    def permute(self, nums):\\n        ans = [nums]\\n        for i in xrange(1, len(nums)):\\n            m = len(ans)\\n            for k in xrange(m):\\n                for j in xrange(i):\\n                    ans.append(ans[k][:])\\n                    ans[-1][j], ans[-1][i] = ans[-1][i], ans[-1][j]\\n        return ans\\n\\n\\n    # 25 / 25 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 68 ms\\n    # 99.02%\\n\\nswap unique pairs of numbers for all the answers in pocket to generate new answers.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def permute(self, nums):\\n        ans = [nums]\\n        for i in xrange(1, len(nums)):\\n            m = len(ans)\\n            for k in xrange(m):\\n                for j in xrange(i):\\n                    ans.append(ans[k][:])\\n                    ans[-1][j], ans[-1][i] = ans[-1][i], ans[-1][j]\\n        return ans\\n\\n\\n    # 25 / 25 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 68 ms\\n    # 99.02%\\n\\nswap unique pairs of numbers for all the answers in pocket to generate new answers.",
                "codeTag": "Python3"
            },
            {
                "id": 18459,
                "title": "java-solution-easy-to-understand-backtracking",
                "content": "public class Solution {\\n    \\n    List<List<Integer>> list;\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        list = new ArrayList<>();\\n        ArrayList<Integer> perm = new ArrayList<Integer>();\\n        backTrack(perm,0,nums);\\n        return list;\\n    }\\n    \\n    void backTrack (ArrayList<Integer> perm,int i,int[] nums){\\n        \\n        //Permutation completes\\n        if(i==nums.length){\\n            list.add(new ArrayList(perm));\\n            return;\\n        }\\n        \\n        ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);\\n        \\n       //Insert elements in the array by increasing index\\n        for(int j=0;j<=i;j++){\\n            newPerm.add(j,nums[i]);\\n            backTrack(newPerm,i+1,nums);\\n            newPerm.remove(j);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    List<List<Integer>> list;\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        list = new ArrayList<>();\\n        ArrayList<Integer> perm = new ArrayList<Integer>();\\n        backTrack(perm,0,nums);\\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3850900,
                "title": "c-python3-java-easy-explanation-with-image-backtracking-solution",
                "content": "# Intuition\\nSince the n is very small we could try all the permutations. \\n\\n# Approach\\nTo solve this problem, we will use a recursive backtracking algorithm. The main idea behind backtracking is to explore all possible combinations by trying out different choices and then undoing those choices if they lead to invalid solutions. We will start with the main array `nums` and swap and permutate it untill we reach our base case.\\n\\n1. Base Case:\\nWe need to identify the base case of the recursion, i.e., when to stop generating permutations. In our case, the base case will be when the i which is the index of the array reaches the end of the array which is `nums.size()`.\\n\\n2. Recursive Function:\\nWe will define a recursive function, let\\'s call it `recur`, which will be responsible for generating the permutations. This function will take the following parameters:\\n   - `nums`: The original array which we will use to generate all the permutations.\\n   - `i`: index of the element at which it is currently present.\\n\\n3. Initialization:\\nWe will start by calling the recursive `recur` function with `nums` and `i` the 0th index at which we are starting.\\n\\n4. Backtracking Algorithm:\\nInside the `recur` function, we will do the following steps:\\n   a. Check the base case: If the length of `i` equals the length of `nums`, add it to the array of valid permutations.\\n   b. Iterate through the `nums` array:\\n      i. Swap the i<sup>th</sup> element with the j<sup>th</sup> element.\\n      ii. Call for the function recursively for the next index which is i + 1.\\n      iii. Backtrack by undoing what we did with swaping back that i<sup>th</sup> element with the j<sup>th</sup> \\n\\nConclusion:\\nBy implementing the above approach, we can efficiently generate all possible permutations of the given array `nums`. The backtracking algorithm ensures that we explore all possible combinations while efficiently avoiding invalid solutions.\\n\\n![Screenshot (462).png](https://assets.leetcode.com/users/images/c6653b56-827d-441a-b4e8-14d5610db238_1690945456.6858256.png)\\n\\n# Complexity\\n- Time complexity: O(n*n!) Note that there are n! permutations and it requires O(n) time to print a permutation.\\n\\n- Space complexity: O(n * n!) in worst case.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void recur(vector<int> nums , int i){\\n        if(i == nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int j = i ; j < nums.size() ; j++){\\n            swap(nums[i] , nums[j]);\\n            recur(nums , i + 1);\\n            swap(nums[i] , nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        recur(nums , 0);\\n        return ans;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        \\n        def recur(nums, i):\\n            if i == len(nums):\\n                ans.append(nums[:])\\n                return\\n            \\n            for j in range(i, len(nums)):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                recur(nums, i + 1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n        \\n        recur(nums, 0)\\n        return ans\\n```\\n```Java []\\nclass Solution {\\n    private List<List<Integer>> ans = new ArrayList<>();\\n\\n    private void recur(int[] nums, int i) {\\n        if (i == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            ans.add(temp);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++) {\\n            swap(nums, i, j);\\n            recur(nums, i + 1);\\n            swap(nums, i, j);\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        recur(nums, 0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void recur(vector<int> nums , int i){\\n        if(i == nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int j = i ; j < nums.size() ; j++){\\n            swap(nums[i] , nums[j]);\\n            recur(nums , i + 1);\\n            swap(nums[i] , nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        recur(nums , 0);\\n        return ans;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        \\n        def recur(nums, i):\\n            if i == len(nums):\\n                ans.append(nums[:])\\n                return\\n            \\n            for j in range(i, len(nums)):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                recur(nums, i + 1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n        \\n        recur(nums, 0)\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    private List<List<Integer>> ans = new ArrayList<>();\\n\\n    private void recur(int[] nums, int i) {\\n        if (i == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            ans.add(temp);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++) {\\n            swap(nums, i, j);\\n            recur(nums, i + 1);\\n            swap(nums, i, j);\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        recur(nums, 0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773139,
                "title": "permutations-java-solution-2-approaches",
                "content": "```\\n1. First Approach :- Generating all permutations\\n\\nTwo Extra Data Structure Required To generate permutation\\n1. ArrayList<> subset //to store subset\\n2. boolean map[]   //this map will tell us which element is pick or not picked at that time\\n\\n//Let\\'s Understand\\nExample :- [1,2,3]\\n\\nfor make permutation we can pick one element from given three element\\n1. if we pick 1 mark in map true ,map[T,F,F] & subset[1]\\n2. if we pick 2 mark in map true , map[F,T,F] & subset[2]\\n3. if we pick 3 mark in map true , map[F,F,T] & subset[3]\\n\\nnow suppose we picked 1 so that our map is map[T,F,F] & subset[1], again for make permutation we can pick one element from \\ngiven three element but this time we already picked 1 so we have only 2 elements remaining\\n1.if we pick 2 mark in map true, map[T,T,F] & subset[1,2]\\n2.if we pick 3 mark in map true, map[T,F,T] & subset[1,3]\\n\\nnow suppose we picked 2 so that our map is map[T,T,F] & subset[1,2], again for make permutation we can pick one element from \\ngiven three element but this time we already picked1 & 2 so we have only 3 remaining\\n1.we picked 3 mark in map true, map[T,T,T] & subset[1,2,3]\\n\\nWhen subset size equal to arra size store the subset into our final ans \\nand same for remaining cases\\n```\\n![image](https://assets.leetcode.com/users/images/9a46ac0c-e3c8-4c42-9567-2c5d1ec73157_1667463248.6818707.jpeg)\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList();\\n        List<Integer> subset = new ArrayList();\\n        boolean map[] = new boolean[nums.length];\\n        helper(nums,subset,ans,map);\\n        return ans;\\n    }\\n    public static void helper(int nums[],List<Integer> subset,List<List<Integer>> ans,boolean map[]){\\n        if(subset.size()==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(!map[i]){\\n                subset.add(nums[i]);\\n                map[i]=true;\\n                helper(nums,subset,ans,map);\\n                subset.remove(subset.size()-1);\\n                map[i]=false;\\n            }\\n        }\\n    }\\n}\\nT.C :- n!(for generating all permutation) * n(for running loop i=0 to nums.length)\\nS.C :- EXTRA SPACE :- n(for subset data structure) + n(for map data structure)\\n      :- Auxillary Space :- recursion stack i.e. O(n)\\n```\\n```\\n2. Second Approach :- Backtracking & Swapping \\n```\\n![image](https://assets.leetcode.com/users/images/e8bfec02-f92d-42ef-a686-1b67ffe210d5_1667464348.8291073.jpeg)\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n          List<List<Integer>> ans = new ArrayList<>();\\n\\t        helper(nums,0,ans);\\n\\t        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans)\\n\\t    {\\n\\t\\t//BASE CASE\\n\\t    \\tif(index==nums.length){\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t        for(int i = index; i<nums.length; i++){\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\nT.C :- n! * n\\nS.C :- Auxillary Space - O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach :- Generating all permutations\\n\\nTwo Extra Data Structure Required To generate permutation\\n1. ArrayList<> subset //to store subset\\n2. boolean map[]   //this map will tell us which element is pick or not picked at that time\\n\\n//Let\\'s Understand\\nExample :- [1,2,3]\\n\\nfor make permutation we can pick one element from given three element\\n1. if we pick 1 mark in map true ,map[T,F,F] & subset[1]\\n2. if we pick 2 mark in map true , map[F,T,F] & subset[2]\\n3. if we pick 3 mark in map true , map[F,F,T] & subset[3]\\n\\nnow suppose we picked 1 so that our map is map[T,F,F] & subset[1], again for make permutation we can pick one element from \\ngiven three element but this time we already picked 1 so we have only 2 elements remaining\\n1.if we pick 2 mark in map true, map[T,T,F] & subset[1,2]\\n2.if we pick 3 mark in map true, map[T,F,T] & subset[1,3]\\n\\nnow suppose we picked 2 so that our map is map[T,T,F] & subset[1,2], again for make permutation we can pick one element from \\ngiven three element but this time we already picked1 & 2 so we have only 3 remaining\\n1.we picked 3 mark in map true, map[T,T,T] & subset[1,2,3]\\n\\nWhen subset size equal to arra size store the subset into our final ans \\nand same for remaining cases\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList();\\n        List<Integer> subset = new ArrayList();\\n        boolean map[] = new boolean[nums.length];\\n        helper(nums,subset,ans,map);\\n        return ans;\\n    }\\n    public static void helper(int nums[],List<Integer> subset,List<List<Integer>> ans,boolean map[]){\\n        if(subset.size()==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(!map[i]){\\n                subset.add(nums[i]);\\n                map[i]=true;\\n                helper(nums,subset,ans,map);\\n                subset.remove(subset.size()-1);\\n                map[i]=false;\\n            }\\n        }\\n    }\\n}\\nT.C :- n!(for generating all permutation) * n(for running loop i=0 to nums.length)\\nS.C :- EXTRA SPACE :- n(for subset data structure) + n(for map data structure)\\n      :- Auxillary Space :- recursion stack i.e. O(n)\\n```\n```\\n2. Second Approach :- Backtracking & Swapping \\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n          List<List<Integer>> ans = new ArrayList<>();\\n\\t        helper(nums,0,ans);\\n\\t        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans)\\n\\t    {\\n\\t\\t//BASE CASE\\n\\t    \\tif(index==nums.length){\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t        for(int i = index; i<nums.length; i++){\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\nT.C :- n! * n\\nS.C :- Auxillary Space - O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961596,
                "title": "c-easy-to-understand-with-diagram-0-ms-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/6d15c5f2-ac03-4b37-821e-9e8a04111124_1650304031.4591222.png)\\n**//image source gfg**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n\\t\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\t\\tres.push_back(nums);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\tfor(int j=i;j<nums.size();j++){\\n\\t\\t\\t   swap(nums[i],nums[j]);\\n\\t\\t\\t   helper(res,nums,i+1);\\n\\t\\t\\t   swap(nums[i],nums[j]);\\n\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t\\t\\tvector<vector<int>> res;\\n\\t\\t\\t\\thelper(res,nums,0);\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n\\t\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\t\\tres.push_back(nums);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18404,
                "title": "2ms-java-solution-beats-93-i-think-it-could-be-optimized",
                "content": "    public class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tperm(result,nums,0,nums.length-1);\\n\\t\\treturn result;\\n    }\\n    public static void perm(List<List<Integer>> result, int[] nums, int start, int end){\\n\\t\\tif(start==end){\\n\\t\\t\\tInteger[] ele = new Integer[nums.length];\\n\\t\\t\\tfor(int i=0; i<nums.length; i++){\\n\\t\\t\\t\\tele[i] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tresult.add(Arrays.asList(ele));\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tfor(int i=start; i<=end; i++){\\n\\t\\t\\t\\tint temp = nums[start];\\n\\t\\t\\t\\tnums[start] = nums[i];\\n\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tperm(result, nums,start+1,end);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ttemp = nums[start];\\n\\t\\t\\t\\tnums[start] = nums[i];\\n\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tperm(result,nums,0,nums.length-1);\\n\\t\\treturn result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 18540,
                "title": "my-c-solution-share",
                "content": "It is obvious that **N numbers has N! permutations** .\\n\\nHere I assume an empty vector also has one permutation. It seems OJ didn't check the empty input case. Well, it doesn't matter.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n            // Add an empty vector as the base case (empty input)\\n        \\tvector<vector<int> > permutations(1, vector<int>());\\n        \\t// Algrithm description:\\n        \\t//\\tInsert the current number in different spaces of previous permutations\\n        \\tfor (vector<int>::size_type index = 0; index != num.size(); ++index)\\n        \\t{\\n        \\t\\tvector<vector<int> > subPermutations(permutations);\\n        \\t\\tpermutations.clear();\\n        \\t\\tfor (vector<vector<int> >::size_type i = 0; i != subPermutations.size(); ++i)\\n        \\t\\t{\\n        \\t\\t\\tfor (int offset = 0; offset != subPermutations[i].size()+1; ++offset)\\n        \\t\\t\\t{\\n        \\t\\t\\t\\tvector<int> temp(subPermutations[i]);\\n        \\t\\t\\t\\ttemp.insert(temp.begin() + offset, num[index]);\\n        \\t\\t\\t\\tpermutations.push_back(temp);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn permutations;\\n        }\\n    };\\n\\nAll comments are welcome !",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n            // Add an empty vector as the base case (empty input)\\n        \\tvector<vector<int> > permutations(1, vector<int>());\\n        \\t// Algrithm description:\\n        \\t//\\tInsert the current number in different spaces of previous permutations\\n        \\tfor (vector<int>::size_type index = 0; index != num.size(); ++index)\\n        \\t{\\n        \\t\\tvector<vector<int> > subPermutations(permutations);\\n        \\t\\tpermutations.clear();\\n        \\t\\tfor (vector<vector<int> >::size_type i = 0; i != subPermutations.size(); ++i)\\n        \\t\\t{\\n        \\t\\t\\tfor (int offset = 0; offset != subPermutations[i].size()+1; ++offset)\\n        \\t\\t\\t{\\n        \\t\\t\\t\\tvector<int> temp(subPermutations[i]);\\n        \\t\\t\\t\\ttemp.insert(temp.begin() + offset, num[index]);\\n        \\t\\t\\t\\tpermutations.push_back(temp);\\n        \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2844437,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-only-4-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        do {\\n            ans.push_back(nums);\\n        } while (next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        do {\\n            ans.push_back(nums);\\n        } while (next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542099,
                "title": "javascript-dfs-backtracking-with-heavy-comments",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = (nums) => {\\n    // Backtracking\\n    const used = new Set(); // Keep track of what we have used\\n    const path = []; // Current potiential answer array\\n    const res = []; // Result array to be returned\\n    \\n    const dfs = () => {\\n        // If path is same length as nums, we know we have an answer. Push it to res array\\n        if(path.length === nums.length) {\\n            res.push([...path]); // We use spread operator to clone since arrays are pass by reference\\n        }\\n        \\n        // Every DFS we loop all numbers\\n        for(let i = 0; i < nums.length; i++) {\\n            // We can skip these numbers if they have been used\\n            if(used.has(nums[i])) continue;\\n            \\n            // Add to our potienial answer array and make it used by adding to used set\\n            path.push(nums[i]);\\n            used.add(nums[i]);\\n            \\n            // After adding, we call DFS again. DFS will continue till we hit the base case above\\n\\t\\t\\t// Think of this as just continuing down a path till we have an answer\\n            dfs();\\n            \\n            // Once we pop out of DFS, we need to remove from path array and remove from used Set\\n            // This will let it be used later in further paths\\n            path.pop();\\n            used.delete(nums[i])\\n        }\\n        \\n    }\\n    \\n    // Start DFS\\n    // All variables are global, no need to pass in anything\\n    dfs();\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = (nums) => {\\n    // Backtracking\\n    const used = new Set(); // Keep track of what we have used\\n    const path = []; // Current potiential answer array\\n    const res = []; // Result array to be returned\\n    \\n    const dfs = () => {\\n        // If path is same length as nums, we know we have an answer. Push it to res array\\n        if(path.length === nums.length) {\\n            res.push([...path]); // We use spread operator to clone since arrays are pass by reference\\n        }\\n        \\n        // Every DFS we loop all numbers\\n        for(let i = 0; i < nums.length; i++) {\\n            // We can skip these numbers if they have been used\\n            if(used.has(nums[i])) continue;\\n            \\n            // Add to our potienial answer array and make it used by adding to used set\\n            path.push(nums[i]);\\n            used.add(nums[i]);\\n            \\n            // After adding, we call DFS again. DFS will continue till we hit the base case above\\n\\t\\t\\t// Think of this as just continuing down a path till we have an answer\\n            dfs();\\n            \\n            // Once we pop out of DFS, we need to remove from path array and remove from used Set\\n            // This will let it be used later in further paths\\n            path.pop();\\n            used.delete(nums[i])\\n        }\\n        \\n    }\\n    \\n    // Start DFS\\n    // All variables are global, no need to pass in anything\\n    dfs();\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074177,
                "title": "mathematical-proof-that-time-complexity-is-o-e-n-not-o-n-n",
                "content": "I have seen a lot of answers here that simply state the time complexity is `O(n*n!)` but the justification isn\\'t too well explained. Here I show a better approximation for the time complexity is actually `O(e*n!)`.\\n\\nFirst we must visualise the recursion tree (see other answers for recursive solution), the tree below shows the recursion for `n=4`. On the first layer of the tree we have `n` possible options to choose from, so we make `n` function calls and have `n` nodes in our tree. Now we have n partial permutations built up so far and have `n-1` numbers to choose from, so the next layer in our tree will have `n*(n-1)` nodes. The layer after this will have `n*(n-1)*(n-2)` nodes and so on and so forth. Until we have `n!` leaf nodes at the bottom of our tree. At this point it is obvious to see `O(n*n!)` is an over estimate for the time complexity of this algorithm, as it implies each layer (there are `n` in total) has `n!` nodes.\\n\\nWe know the time complexity of a recursive algorithm is the number of nodes in its recursion tree multiplied by the cost of computation at each node. At each node in our tree we either call the dfs function recursively (non-leaf nodes) or add to the results array, both of these operations are `O(1)`, hence the time complexity is equal to the number of nodes in the recursion tree.\\n\\nNow for the magic, if we sum up the nodes in each layer of the recursion tree we get to the expression:\\n\\n`O(n) = 1 + n + n*(n-1) + n*(n-1)*(n-2) + ... + n!`\\n\\nIf we reverse the order of terms in this series and factor out `n!` we get:\\n\\n`O(n) = n!(1/1! + 1/2! + 1/3! + ... + 1/n!)`\\n\\nNotice the second term is the series representation of `e`, so we have:\\n\\n`O(n) = e * n!`\\n\\n![image](https://assets.leetcode.com/users/images/824a0380-cf67-4058-89c1-fb98ba79da68_1653524447.4704807.png)\\n\\nHere are some calculations for n = 1-10, of actual nodes in recursion tree (calculating the first summation expression in a while loop) vs `e*n!` vs `n*n!`:\\n\\n```\\nn    actual    e*n!      n*n!\\n1    1         2         1\\n2    4         5         4\\n3    15        16        18\\n4    64        65        96\\n5    325       326       600\\n6    1956      1957      4320\\n7    13699     13700     35280\\n8    109600    109601    322560\\n9    986409    986410    3265920\\n10   9864100   9864101   36288000\\n```\\n",
                "solutionTags": [],
                "code": "```\\nn    actual    e*n!      n*n!\\n1    1         2         1\\n2    4         5         4\\n3    15        16        18\\n4    64        65        96\\n5    325       326       600\\n6    1956      1957      4320\\n7    13699     13700     35280\\n8    109600    109601    322560\\n9    986409    986410    3265920\\n10   9864100   9864101   36288000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690075,
                "title": "golang-beats-100-recursion-explanation",
                "content": "```\\n// To solve this problem we can use recursion.\\n// If we think about it, a combination is valid when it has the same length of the input.\\n// So, all we need to do is, have a concept of current combination (left) and left items (right)\\n// that we need to analyse every time. We start with empty current combination and left will be equal to the input.\\n//\\n// E.G. current: []; left: [1, 2, 3]\\n// Then we would have current: [1]; left: [2, 3], current: [2]; left: [1, 3], current: [3]; left: [1, 2]\\n// \\n// The recursion tree looks like:\\n//\\n// - ([],[1, 2, 3])\\n// - ([1],[2,3]); ([2],[1, 3]); ([3],[2, 1])\\n// - ([1,2],[3]); ([1,3],[2]); ([2,1],[3]); ([2,3],[1]); ([3,2],[1]); ([3,1],[2])\\n// - ([1,2,3]); ([1,3,2]); ([2,1,3]); ([2,3,1]); ([3,2,1]); ([3,1,2])\\n//\\n// T: O(n!)\\n// S: O(n!)\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\tpermuteRec([]int{}, nums, &res)\\n\\treturn res\\n}\\n\\n// We use a pointer for the result so we don\\'t need to worry returning it.\\nfunc permuteRec(currComb, left []int, res *[][]int) {\\n\\t// We know that we found a new combination when we have no elements left.\\n\\tif 0 == len(left) {\\n\\t\\t*res = append(*res, currComb)\\n\\t\\treturn\\n\\t}\\n\\t// For the next iteration we consider all the left elements but the current one (idx).\\n\\tfor idx, l := range left {\\n\\t\\tpermuteRec(\\n\\t\\t\\tappend(currComb, l),\\n\\t\\t\\tappend(append([]int{}, left[:idx]...), left[idx+1:]...), // Make sure to allocate a new slice.\\n\\t\\t\\tres,\\n\\t\\t)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\n// To solve this problem we can use recursion.\\n// If we think about it, a combination is valid when it has the same length of the input.\\n// So, all we need to do is, have a concept of current combination (left) and left items (right)\\n// that we need to analyse every time. We start with empty current combination and left will be equal to the input.\\n//\\n// E.G. current: []; left: [1, 2, 3]\\n// Then we would have current: [1]; left: [2, 3], current: [2]; left: [1, 3], current: [3]; left: [1, 2]\\n// \\n// The recursion tree looks like:\\n//\\n// - ([],[1, 2, 3])\\n// - ([1],[2,3]); ([2],[1, 3]); ([3],[2, 1])\\n// - ([1,2],[3]); ([1,3],[2]); ([2,1],[3]); ([2,3],[1]); ([3,2],[1]); ([3,1],[2])\\n// - ([1,2,3]); ([1,3,2]); ([2,1,3]); ([2,3,1]); ([3,2,1]); ([3,1,2])\\n//\\n// T: O(n!)\\n// S: O(n!)\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\tpermuteRec([]int{}, nums, &res)\\n\\treturn res\\n}\\n\\n// We use a pointer for the result so we don\\'t need to worry returning it.\\nfunc permuteRec(currComb, left []int, res *[][]int) {\\n\\t// We know that we found a new combination when we have no elements left.\\n\\tif 0 == len(left) {\\n\\t\\t*res = append(*res, currComb)\\n\\t\\treturn\\n\\t}\\n\\t// For the next iteration we consider all the left elements but the current one (idx).\\n\\tfor idx, l := range left {\\n\\t\\tpermuteRec(\\n\\t\\t\\tappend(currComb, l),\\n\\t\\t\\tappend(append([]int{}, left[:idx]...), left[idx+1:]...), // Make sure to allocate a new slice.\\n\\t\\t\\tres,\\n\\t\\t)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18378,
                "title": "simple-python-code-without-recursion",
                "content": "    class Solution(object):\\n        def permute(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            def swap(i, j, nums):\\n                new_nums = list(nums)\\n                new_nums[i], new_nums[j] = new_nums[j], new_nums[i]\\n                return new_nums\\n    \\n            result = [nums,]\\n    \\n            for i in range(len(nums)-1):\\n                for one in result[:]:\\n                    for j in range(i+1, len(nums)):\\n                        result.append(swap(i, j, one))\\n    \\n            return result",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def permute(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            def swap(i, j, nums):\\n                new_nums = list(nums)\\n                new_nums[i], new_nums[j] = new_nums[j], new_nums[i]\\n                return new_nums\\n    \\n            result = [nums,]\\n    \\n            for i in range(len(nums)-1):\\n                for one in result[:]:\\n                    for j in range(i+1, len(nums)):\\n                        result.append(swap(i, j, one))\\n    \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 3851730,
                "title": "c-bits-approach-recursion-day-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int mask,vector<int>&v,vector<int>&temp){\\n        if(mask==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(mask & (1<<i)){\\n                temp.push_back(v[i]);\\n                help(mask ^ (1<<i), v,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& v) {\\n        vector<int>temp;\\n        help((1<<v.size())-1,v,temp);\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/531dcc09-5c89-4f76-855e-433d650af579_1690959144.8366618.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int mask,vector<int>&v,vector<int>&temp){\\n        if(mask==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(mask & (1<<i)){\\n                temp.push_back(v[i]);\\n                help(mask ^ (1<<i), v,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& v) {\\n        vector<int>temp;\\n        help((1<<v.size())-1,v,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851090,
                "title": "very-simple-c-c-java-python3-codes-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to generate all possible permutations of a given array of distinct integers. A permutation is an arrangement of elements in a specific order. For example, given the array [1, 2, 3], the permutations are [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]].\\n\\nTo solve this problem, we can use a recursive approach known as backtracking. The intuition behind the backtracking approach is to try out all possible combinations by swapping elements to find the different arrangements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a helper function that takes the current index as a parameter and generates permutations for the remaining elements.\\n- The base case for recursion is when the current index reaches the end of the array. At this point, we have a valid permutation, so we add it to the result list.\\n- For each index from the current position, swap the element at the current index with the element at the current position, and then recursively generate permutations for the rest of the array.\\n- After the recursive call, swap the elements back to their original positions to restore the original array for further exploration.\\n\\n# Complexity\\n- Time complexity: **O(n!)** We have to generate all possible permutations, and there are n! permutations for an array of size n.\\n\\n- Space complexity:**O(n)** The space required for recursion depth and the result list\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void generatePermutations(vector<int>& nums, int index, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); ++i) {\\n            swap(nums[index], nums[i]);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums[index], nums[i]); // Backtrack\\n        }\\n    }\\n};\\n```\\n## Java\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\n    private void generatePermutations(int[] nums, int index, List<List<Integer>> result) {\\n        if (index == nums.length) {\\n            List<Integer> currentPerm = new ArrayList<>();\\n            for (int num : nums) {\\n                currentPerm.add(num);\\n            }\\n            result.add(currentPerm);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.length; i++) {\\n            swap(nums, index, i);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums, index, i); // Backtrack\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\\n## Python3\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def generate_permutations(index):\\n            if index == len(nums):\\n                result.append(nums.copy())\\n                return\\n            \\n            for i in range(index, len(nums)):\\n                nums[index], nums[i] = nums[i], nums[index]\\n                generate_permutations(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index]  # Backtrack\\n        \\n        result = []\\n        generate_permutations(0)\\n        return result\\n```\\n## C\\n```\\nvoid swap(int* nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\nvoid generatePermutations(int* nums, int numsSize, int index, int** result, int* returnSize, int** returnColumnSizes) {\\n    if (index == numsSize) {\\n        result[*returnSize] = malloc(numsSize * sizeof(int));\\n        memcpy(result[*returnSize], nums, numsSize * sizeof(int));\\n        (*returnColumnSizes)[*returnSize] = numsSize;\\n        (*returnSize)++;\\n        return;\\n    }\\n\\n    for (int i = index; i < numsSize; i++) {\\n        swap(nums, index, i);\\n        generatePermutations(nums, numsSize, index + 1, result, returnSize, returnColumnSizes);\\n        swap(nums, index, i); // Backtrack\\n    }\\n}\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }\\n\\n    int** result = (int**)malloc(totalPermutations * sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(totalPermutations * sizeof(int));\\n    *returnSize = 0;\\n\\n    generatePermutations(nums, numsSize, 0, result, returnSize, returnColumnSizes);\\n    return result;\\n}\\n```\\n\\n![upvote img.jpg](https://assets.leetcode.com/users/images/98fa308e-0a58-4b30-a602-c745ada9c64c_1690950320.6229887.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void generatePermutations(vector<int>& nums, int index, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); ++i) {\\n            swap(nums[index], nums[i]);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums[index], nums[i]); // Backtrack\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\n    private void generatePermutations(int[] nums, int index, List<List<Integer>> result) {\\n        if (index == nums.length) {\\n            List<Integer> currentPerm = new ArrayList<>();\\n            for (int num : nums) {\\n                currentPerm.add(num);\\n            }\\n            result.add(currentPerm);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.length; i++) {\\n            swap(nums, index, i);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums, index, i); // Backtrack\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def generate_permutations(index):\\n            if index == len(nums):\\n                result.append(nums.copy())\\n                return\\n            \\n            for i in range(index, len(nums)):\\n                nums[index], nums[i] = nums[i], nums[index]\\n                generate_permutations(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index]  # Backtrack\\n        \\n        result = []\\n        generate_permutations(0)\\n        return result\\n```\n```\\nvoid swap(int* nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\nvoid generatePermutations(int* nums, int numsSize, int index, int** result, int* returnSize, int** returnColumnSizes) {\\n    if (index == numsSize) {\\n        result[*returnSize] = malloc(numsSize * sizeof(int));\\n        memcpy(result[*returnSize], nums, numsSize * sizeof(int));\\n        (*returnColumnSizes)[*returnSize] = numsSize;\\n        (*returnSize)++;\\n        return;\\n    }\\n\\n    for (int i = index; i < numsSize; i++) {\\n        swap(nums, index, i);\\n        generatePermutations(nums, numsSize, index + 1, result, returnSize, returnColumnSizes);\\n        swap(nums, index, i); // Backtrack\\n    }\\n}\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }\\n\\n    int** result = (int**)malloc(totalPermutations * sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(totalPermutations * sizeof(int));\\n    *returnSize = 0;\\n\\n    generatePermutations(nums, numsSize, 0, result, returnSize, returnColumnSizes);\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850454,
                "title": "100-backtracking-recursive-approach-unlocking-permutations",
                "content": "# Intuition\\nThe problem requires generating all possible permutations of a given array of distinct integers. A clear and intuitive understanding of the recursive approach can be achieved by watching vanAmsen\\'s video explanation, where the permutations are constructed by choosing one element at a time and recursively calling the function on the remaining elements. The video thoroughly explains the underlying logic and how to implement it in code. Special thanks to vanAmsen for the insightful explanation! [Watch the video here](https://youtu.be/Jlw0sIGdS_4).\\n\\n\\n# Approach\\n1. We define a recursive function `backtrack` that takes the current numbers and the path of the permutation being constructed.\\n2. In the base case, if there are no numbers left, we append the current path to the result list.\\n3. We iterate through the numbers, and for each number, we add it to the current path and recursively call `backtrack` with the remaining numbers (excluding the current number).\\n4. We initialize an empty result list and call the `backtrack` function with the original numbers and an empty path to start the process.\\n5. The result list will contain all the permutations, and we return it.\\n\\n# Complexity\\n- Time complexity: \\\\(O(n!)\\\\)\\n  - We generate \\\\(n!\\\\) permutations, where \\\\(n\\\\) is the length of the input list.\\n\\n- Space complexity: \\\\(O(n)\\\\)\\n  - The maximum depth of the recursion is \\\\(n\\\\), and we use additional space for the current path and slicing operations.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\\n``` JavaScript []\\nvar permute = function(nums) {\\n    let result = []; \\n    permuteRec(nums, 0, result); \\n    return result; \\n             \\n};\\n\\nfunction permuteRec(nums, begin, result) {  \\n    if (begin === nums.length) { \\n            result.push(nums.slice()); \\n        return; \\n    } \\n    for (let i = begin; i < nums.length; i++) { \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n        permuteRec(nums, begin + 1, result); \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n    } \\n} \\n```\\n``` C# []\\npublic class Solution {\\n    public void PermuteRec(int[] nums, int begin, IList<IList<int>> result) {\\n        if (begin == nums.Length) {\\n            var temp = new List<int>(nums);\\n            result.Add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.Length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            PermuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        PermuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\n``` JavaScript []\\nvar permute = function(nums) {\\n    let result = []; \\n    permuteRec(nums, 0, result); \\n    return result; \\n             \\n};\\n\\nfunction permuteRec(nums, begin, result) {  \\n    if (begin === nums.length) { \\n            result.push(nums.slice()); \\n        return; \\n    } \\n    for (let i = begin; i < nums.length; i++) { \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n        permuteRec(nums, begin + 1, result); \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n    } \\n} \\n```\n``` C# []\\npublic class Solution {\\n    public void PermuteRec(int[] nums, int begin, IList<IList<int>> result) {\\n        if (begin == nums.Length) {\\n            var temp = new List<int>(nums);\\n            result.Add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.Length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            PermuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        PermuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297287,
                "title": "simple-python-solution-beats-99-with-comments",
                "content": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \\n        res = []\\n        def dfs(path, num): # record the path and remaining numbers\\n            if not num:\\n                res.append(path)    # When finished iterating, append path to result\\n                return\\n            for i in range(len(num)):\\n                dfs(path + [num[i]], num[:i] + num[i + 1:]) \\n                # append the current number to path and iterate with the unused numbers\\n        \\n        dfs([], nums)\\n        return res  # return results\\n    \\n    #If you find this solution helpful, please upvote :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \\n        res = []\\n        def dfs(path, num): # record the path and remaining numbers\\n            if not num:\\n                res.append(path)    # When finished iterating, append path to result\\n                return\\n            for i in range(len(num)):\\n                dfs(path + [num[i]], num[:i] + num[i + 1:]) \\n                # append the current number to path and iterate with the unused numbers\\n        \\n        dfs([], nums)\\n        return res  # return results\\n    \\n    #If you find this solution helpful, please upvote :)",
                "codeTag": "Java"
            },
            {
                "id": 1564505,
                "title": "java-easy-solution-recursion-and-backtracking",
                "content": "**Code**\\n\\n```java\\npublic List<List<Integer>> permute(int[] nums) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tpermuteUtil(list, new ArrayList<>(), nums);\\n\\treturn list;\\n}\\n\\npublic void permuteUtil(List<List<Integer>> list, List<Integer> temp, int[] nums) {\\n\\t//base case\\n\\tif(temp.size() == nums.length) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t//recursive case\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif(temp.contains(nums[i])) continue;\\n\\t\\ttemp.add(nums[i]);\\n\\t\\tpermuteUtil(list, temp, nums);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\\n\\n**Explanation**\\nThis is a standard problem and this approach is used in a variety of problems, I\\'ve explained the approach there, do check them out, the problems are as follows:-\\n- [Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1560722/java-easy-solution-100-faster-recursion-and-backtracking)\\n- [Combination Sum 2](https://leetcode.com/problems/combination-sum-ii/discuss/1560743/java-easy-solution-with-explanation-recursion-and-backtracking)\\n- [Subsets](https://leetcode.com/problems/subsets/)\\n- [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/discuss/1561260/java-easy-solution-recursion-and-backtracking)\\n\\nThanks",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\npublic List<List<Integer>> permute(int[] nums) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tpermuteUtil(list, new ArrayList<>(), nums);\\n\\treturn list;\\n}\\n\\npublic void permuteUtil(List<List<Integer>> list, List<Integer> temp, int[] nums) {\\n\\t//base case\\n\\tif(temp.size() == nums.length) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t//recursive case\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif(temp.contains(nums[i])) continue;\\n\\t\\ttemp.add(nums[i]);\\n\\t\\tpermuteUtil(list, temp, nums);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463162,
                "title": "c-clean-code-two-approaches-with-proper-comments",
                "content": "Approach 1\\n\\nusing a freq array to store the number visited because it should not be included again in the answer\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,vector<int>&v,vector<vector<int>>&ans,int freq[])\\n    {\\n        if(v.size()==nums.size()){\\n            ans.push_back(v);\\n            return;\\n        }  \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!freq[i])\\n            {\\n               freq[i]=1;  //marking that number as visited\\n                v.push_back(nums[i]); //pushing the number in vector\\n                solve(nums,v,ans,freq); \\n                freq[i]=0; //after recursive call is finished mark it as unvisited so that it can be considered for other permutation\\n                v.pop_back(); // pop it otherwise it will remain a part of other permutations too\\n            }   \\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n     vector<int>v;\\n        vector<vector<int>>ans;\\n        int n=nums.size();\\n        int freq[n];\\n        for(int i=0;i<n;i++)freq[i]=0; //initialisation of freq array\\n        solve(nums,v,ans,freq);\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2\\n\\nWithout freq array, by swapping two numbers \\n\\n```\\nclass Solution {\\npublic:\\n    void solve(int ind,vector<int>& nums,vector<vector<int>>&ans)\\n    {\\n        if(ind==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n       for(int i=ind;i<nums.size();i++)\\n       {\\n           swap(nums[i],nums[ind]);  \\n           solve(ind+1,nums,ans); //ind is increased by one so that swapping is done with next index element in further calls\\n            swap(nums[i],nums[ind]); // swapping it back to original order after recursion call is over\\n       }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>ans;\\n\\t   solve(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like my solution",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,vector<int>&v,vector<vector<int>>&ans,int freq[])\\n    {\\n        if(v.size()==nums.size()){\\n            ans.push_back(v);\\n            return;\\n        }  \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!freq[i])\\n            {\\n               freq[i]=1;  //marking that number as visited\\n                v.push_back(nums[i]); //pushing the number in vector\\n                solve(nums,v,ans,freq); \\n                freq[i]=0; //after recursive call is finished mark it as unvisited so that it can be considered for other permutation\\n                v.pop_back(); // pop it otherwise it will remain a part of other permutations too\\n            }   \\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n     vector<int>v;\\n        vector<vector<int>>ans;\\n        int n=nums.size();\\n        int freq[n];\\n        for(int i=0;i<n;i++)freq[i]=0; //initialisation of freq array\\n        solve(nums,v,ans,freq);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(int ind,vector<int>& nums,vector<vector<int>>&ans)\\n    {\\n        if(ind==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n       for(int i=ind;i<nums.size();i++)\\n       {\\n           swap(nums[i],nums[ind]);  \\n           solve(ind+1,nums,ans); //ind is increased by one so that swapping is done with next index element in further calls\\n            swap(nums[i],nums[ind]); // swapping it back to original order after recursion call is over\\n       }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>ans;\\n\\t   solve(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172632,
                "title": "python-dfs-bfs",
                "content": "### 46. Permutations\n[此题收录在Github](https://github.com/yuzhoujr/leetcode/issues/33)\n#### DFS\n\n```python\nclass Solution:\n    def permute(self, nums):\n        self.res = []\n        self.dfs(nums, [])\n        return self.res\n    \n    def dfs(self, nums, temp):\n        if len(nums) == len(temp):\n            self.res.append(temp[:])\n            return\n        \n        for i in range(len(nums)):\n            if nums[i] in temp: continue\n            temp.append(nums[i])\n            self.dfs(nums, temp)\n            temp.pop()\n```\n\n#### BFS (Using Deque)\n\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/permu.jpg)\n\n先把起始状态的`queue`存好: `[[1],[2],[3]]`\n\n`while`这一层检查我们`queue`里面是否有比input `nums`长度小的单位，如果有的话，咱还有针对这个`queue`里面的元素进行增值。\n\n`for`这一层把pop()出来的数组`temp`，进行去重比对，如果发现`nums`里面的元素没有出现在`temp`，代表着这是unique的，我们这个数组的的copy `temp[:]`加上当前的值，放回`queue`中。\n\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = deque()\n        for num in nums:\n            q.append([num])\n\n        while len(min(q,key=len)) < len(nums):\n            temp = q.popleft()\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return list(q)\n```\n\n#### BFS (Acting like using Deque)\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = [[num] for num in nums]\n        while len(min(q,key=len)) < len(nums):\n            temp = q.pop(0)\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return q\n```",
                "solutionTags": [],
                "code": "```python\nclass Solution:\n    def permute(self, nums):\n        self.res = []\n        self.dfs(nums, [])\n        return self.res\n    \n    def dfs(self, nums, temp):\n        if len(nums) == len(temp):\n            self.res.append(temp[:])\n            return\n        \n        for i in range(len(nums)):\n            if nums[i] in temp: continue\n            temp.append(nums[i])\n            self.dfs(nums, temp)\n            temp.pop()\n```\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = deque()\n        for num in nums:\n            q.append([num])\n\n        while len(min(q,key=len)) < len(nums):\n            temp = q.popleft()\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return list(q)\n```\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = [[num] for num in nums]\n        while len(min(q,key=len)) < len(nums):\n            temp = q.pop(0)\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return q\n```",
                "codeTag": "Java"
            },
            {
                "id": 18414,
                "title": "accepted-as-best-in-c",
                "content": "    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void search(int* nums, int size, int*** arr, int* returnSize, int begin, int end)\\n    {\\n        if(begin == end)\\n        {\\n            (*returnSize)++;\\n            *arr = (int**)realloc(*arr, sizeof(int*)*(*returnSize));\\n            (*arr)[*returnSize-1] = (int*)malloc(sizeof(int)*size);\\n            for(int i = 0; i < size; i++)\\n                (*arr)[*returnSize-1][i] = nums[i];\\n            return;\\n        }\\n        for(int i = begin; i <= end; i++)\\n        {\\n            swap(nums+begin, nums+i); //try to use each element as the head;\\n            search(nums, size, arr, returnSize, begin+1, end);\\n            swap(nums+begin, nums+i);\\n        }\\n    }\\n    \\n    //AC - 4ms;\\n    int** permute(int* nums, int size, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        int** arr = (int**)malloc(sizeof(int*));\\n        search(nums, size, &arr, returnSize, 0, size-1);\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void search(int* nums, int size, int*** arr, int* returnSize, int begin, int end)\\n    {\\n        if(begin == end)\\n        {\\n            (*returnSize)++;\\n            *arr = (int**)realloc(*arr, sizeof(int*)*(*returnSize));\\n            (*arr)[*returnSize-1] = (int*)malloc(sizeof(int)*size);\\n            for(int i = 0; i < size; i++)\\n                (*arr)[*returnSize-1][i] = nums[i];\\n            return;\\n        }\\n        for(int i = begin; i <= end; i++)\\n        {\\n            swap(nums+begin, nums+i); //try to use each element as the head;\\n            search(nums, size, arr, returnSize, begin+1, end);\\n            swap(nums+begin, nums+i);\\n        }\\n    }\\n    \\n    //AC - 4ms;\\n    int** permute(int* nums, int size, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        int** arr = (int**)malloc(sizeof(int*));\\n        search(nums, size, &arr, returnSize, 0, size-1);\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18546,
                "title": "accepted-recursive-solution-in-java",
                "content": "    int len;\\n    boolean[] used;\\n    List<List<Integer>> result;\\n    List<Integer> temp;\\n    public List<List<Integer>> permute(int[] num) {\\n        len = num.length;\\n        used = new boolean[len];\\n        result = new ArrayList<List<Integer>>();\\n        temp = new ArrayList<>();\\n        doPermute(num, 0);\\n\\n        return result;\\n    }\\n\\n    public void doPermute(int[] in, int level) {\\n        if (level == len) {\\n            result.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (used[i]) {\\n                continue;\\n            }\\n\\n            temp.add(in[i]);\\n            used[i] = true;\\n            doPermute(in, level + 1);\\n            used[i] = false;\\n            temp.remove(level);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "    int len;\\n    boolean[] used;\\n    List<List<Integer>> result;\\n    List<Integer> temp;\\n    public List<List<Integer>> permute(int[] num) {\\n        len = num.length;\\n        used = new boolean[len];\\n        result = new ArrayList<List<Integer>>();\\n        temp = new ArrayList<>();\\n        doPermute(num, 0);\\n\\n        return result;\\n    }\\n\\n    public void doPermute(int[] in, int level) {\\n        if (level == len) {\\n            result.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (used[i]) {\\n                continue;\\n            }\\n\\n            temp.add(in[i]);\\n            used[i] = true;\\n            doPermute(in, level + 1);\\n            used[i] = false;\\n            temp.remove(level);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 996115,
                "title": "java-4-approaches-visuals-time-complexity-analysis",
                "content": "- **For Python implementation (AND/OR) a more detailed explanation and visuals -> checkout this post:**\\nhttps://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis\\n\\n- **For JAVA implementation => scroll down**\\n------------------------\\n\\n**Recursive with backtracking**\\n--------------\\n-------------\\n\\n```\\n/*\\n    Recursive with backtracking\\n*/\\n\\nclass Solution {\\n\\n    // helper\\n    public List<List<Integer>> recursive(List<Integer> numsLst, List<List<Integer>> res, List<Integer> path) {\\n        \\n        if (numsLst.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        }\\n        else {\\n            for (int i=0; i<numsLst.size(); i++) {\\n                List<Integer> newNumsLst = new ArrayList(numsLst);\\n                newNumsLst.remove(i);\\n                path.add(numsLst.get(i));\\n                recursive(newNumsLst, res, path);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        // a turn around is to instantiate vars here - equivalent to Pythonic optional vars \\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> path = new ArrayList();\\n        \\n        // convert array to list\\n        List<Integer> numsLst = new ArrayList<Integer>();\\n        for (int num: nums) {\\n            numsLst.add(num);\\n        }\\n        \\n        // call helper\\n        return recursive(numsLst, res, path);\\n        \\n    }\\n}\\n```\\n------------------------\\n\\n**Recursive without backtracking**\\n--------------\\n----------\\n\\n```\\n/*\\n    Recursive without backtracking\\n*/\\nclass Solution {\\n    \\n    // helper to convert array to arrayList\\n    public List<Integer> toArrayList(int[] arr) {\\n        List<Integer> l = new ArrayList();\\n        for (int num : arr) {\\n            l.add(num);\\n        }\\n        return l;\\n    }\\n    \\n    public List<List<Integer>> recursive(List<Integer> nums, List<List<Integer>> res, List<Integer> path) {\\n        if (nums.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        } else {\\n            for (int i=0; i<nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(nums); // copy\\n                newNums.remove(i); // remove takes an index\\n                \\n                List<Integer> newPath = new ArrayList(path);\\n                path.add(nums.get(i)); \\n                recursive(newNums, res, newPath);\\n                // no backtracking needed\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        List<List<Integer>> res = new ArrayList();\\n        return recursive(numsLst, res, path);\\n    }\\n}\\n```\\n------------------------\\n\\n**Iterative DFS**\\n--------------\\n----------\\n\\n```\\n/*\\n    Iterative DFS\\n*/\\n\\nclass Node {\\n    List<Integer> nums;\\n    List<Integer> path;\\n    \\n    // Constructor\\n    Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n\\n    // helper\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        List<List<Integer>> res = new ArrayList();\\n        Stack<Node> stack = new Stack();\\n        List<Integer> path = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        Node node = new Node(numsLst, path);\\n        stack.push(node);\\n        \\n        while (!stack.isEmpty()) {\\n            node = stack.pop();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            \\n            for (int i=0; i<node.nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                stack.push(newNode);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\n------------------------\\n\\n**Iterative DFS**\\n--------------\\n----------\\n\\n```\\n/*\\n    Iterative BFS\\n*/\\n\\nclass Node {\\n    List<Integer> path;\\n    List<Integer> nums;\\n    \\n    // Constructor\\n    public Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        Deque<Node> q = new ArrayDeque<>();\\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        Node node = new Node(numsLst, path);\\n        q.add(node);\\n        while (!q.isEmpty()) {\\n            node = q.pollFirst();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            for (int i=0; i< node.nums.size(); i++) {\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                q.add(newNode);\\n            }\\n        }\\n        return res;\\n  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/*\\n    Recursive with backtracking\\n*/\\n\\nclass Solution {\\n\\n    // helper\\n    public List<List<Integer>> recursive(List<Integer> numsLst, List<List<Integer>> res, List<Integer> path) {\\n        \\n        if (numsLst.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        }\\n        else {\\n            for (int i=0; i<numsLst.size(); i++) {\\n                List<Integer> newNumsLst = new ArrayList(numsLst);\\n                newNumsLst.remove(i);\\n                path.add(numsLst.get(i));\\n                recursive(newNumsLst, res, path);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        // a turn around is to instantiate vars here - equivalent to Pythonic optional vars \\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> path = new ArrayList();\\n        \\n        // convert array to list\\n        List<Integer> numsLst = new ArrayList<Integer>();\\n        for (int num: nums) {\\n            numsLst.add(num);\\n        }\\n        \\n        // call helper\\n        return recursive(numsLst, res, path);\\n        \\n    }\\n}\\n```\n```\\n/*\\n    Recursive without backtracking\\n*/\\nclass Solution {\\n    \\n    // helper to convert array to arrayList\\n    public List<Integer> toArrayList(int[] arr) {\\n        List<Integer> l = new ArrayList();\\n        for (int num : arr) {\\n            l.add(num);\\n        }\\n        return l;\\n    }\\n    \\n    public List<List<Integer>> recursive(List<Integer> nums, List<List<Integer>> res, List<Integer> path) {\\n        if (nums.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        } else {\\n            for (int i=0; i<nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(nums); // copy\\n                newNums.remove(i); // remove takes an index\\n                \\n                List<Integer> newPath = new ArrayList(path);\\n                path.add(nums.get(i)); \\n                recursive(newNums, res, newPath);\\n                // no backtracking needed\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        List<List<Integer>> res = new ArrayList();\\n        return recursive(numsLst, res, path);\\n    }\\n}\\n```\n```\\n/*\\n    Iterative DFS\\n*/\\n\\nclass Node {\\n    List<Integer> nums;\\n    List<Integer> path;\\n    \\n    // Constructor\\n    Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n\\n    // helper\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        List<List<Integer>> res = new ArrayList();\\n        Stack<Node> stack = new Stack();\\n        List<Integer> path = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        Node node = new Node(numsLst, path);\\n        stack.push(node);\\n        \\n        while (!stack.isEmpty()) {\\n            node = stack.pop();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            \\n            for (int i=0; i<node.nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                stack.push(newNode);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```\\n/*\\n    Iterative BFS\\n*/\\n\\nclass Node {\\n    List<Integer> path;\\n    List<Integer> nums;\\n    \\n    // Constructor\\n    public Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        Deque<Node> q = new ArrayDeque<>();\\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        Node node = new Node(numsLst, path);\\n        q.add(node);\\n        while (!q.isEmpty()) {\\n            node = q.pollFirst();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            for (int i=0; i< node.nums.size(); i++) {\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                q.add(newNode);\\n            }\\n        }\\n        return res;\\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854583,
                "title": "python-simple-solution-explained-video-code-beginner",
                "content": "[](https://www.youtube.com/watch?v=DBLUa6ErLKw)\\nhttps://www.youtube.com/watch?v=DBLUa6ErLKw\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.backtrack(nums, [])\\n        return self.res\\n    \\n    def backtrack(self, nums, path):\\n        if not nums:\\n            self.res.append(path)\\n        for x in range(len(nums)):\\n            self.backtrack(nums[:x]+nums[x+1:], path+[nums[x]])\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.backtrack(nums, [])\\n        return self.res\\n    \\n    def backtrack(self, nums, path):\\n        if not nums:\\n            self.res.append(path)\\n        for x in range(len(nums)):\\n            self.backtrack(nums[:x]+nums[x+1:], path+[nums[x]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276363,
                "title": "javascript-solution",
                "content": "```\\nvar permute = function(nums) {\\n    let sol = [];\\n    if(nums.length < 1) {\\n        return [[]];\\n    } else if(nums.length == 1) {\\n        return [[nums[0]]];\\n    } \\n    for(let i = 0; i < nums.length; i++) {\\n        let numsCopy = [...nums]; \\n        numsCopy.splice(i, 1); \\n        let rtnVal = permute(numsCopy);\\n        for(let j = 0; j < rtnVal.length; j++) {\\n            sol.push([nums[i], ...rtnVal[j]])\\n        }  \\n    }\\n    return sol;\\n};\\n```\\n\\n# Approach:\\nThe approach to this problem is quite similar to that of the [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/). Since we\\'re dealing with combinations in arrays, my intuition told me that this likely had a recursive solution. \\n\\nLet\\'s deal with the base case first:\\nIf the given array is empty (array = `[]`), then the function should return `[[]]`.\\nIf the given array only had one element, then it should return `[[array[0]]`.\\n\\nNow, that we have our base cases, let\\'s go into our recursion. We know that when the array has more than one element, each element has a number of permutations in which that element is the first element.\\n\\nSo that\\'s why we have the outer for loop:\\n```\\nfor(let i = 0; i < nums.length; i++) {\\n.\\n.\\n.\\n\\tsol.push(nums[i], ....);\\n}\\n```\\n\\nTo visualize:\\n```\\npermute([1, 2, 3]):\\ni = 0: nums[0] == 1 --> [[1, ...[2,3]], [1, ...[3,2]]] --> [[1,2,3], [1,3,2]]\\ni = 1: nums[1] == 2 --> [[2, ...[1,3]], [2, ...[3,1]]] --> [[2,1,3], [2,3,1]]\\ni = 1: nums[2] == 3 --> [[3, ...[1,2]], [3, ...[2,1]]] --> [[3,1,2], [3,2,1]]\\n```\\n\\nNow, in order to get the other combinations such as `[1,3], [2,3]`, I used the `splice()`. **However**, `splice()` changes the array reference and object, so you must make a copy. Which is why I did `let numsCopy = [...nums]`. \\n\\nNow, we simply recurse on `numsCopy` after we remove the `i-th` element and it will return an array with the permutations of `numsCopy`. Then we just add `[nums[i], ...rtnVal[j]]` to the `sol` and return the value.\\n\\nRuntime: `O(n!)`\\nSpace Complexity: `O(n)`",
                "solutionTags": [],
                "code": "```\\nvar permute = function(nums) {\\n    let sol = [];\\n    if(nums.length < 1) {\\n        return [[]];\\n    } else if(nums.length == 1) {\\n        return [[nums[0]]];\\n    } \\n    for(let i = 0; i < nums.length; i++) {\\n        let numsCopy = [...nums]; \\n        numsCopy.splice(i, 1); \\n        let rtnVal = permute(numsCopy);\\n        for(let j = 0; j < rtnVal.length; j++) {\\n            sol.push([nums[i], ...rtnVal[j]])\\n        }  \\n    }\\n    return sol;\\n};\\n```\n```\\nfor(let i = 0; i < nums.length; i++) {\\n.\\n.\\n.\\n\\tsol.push(nums[i], ....);\\n}\\n```\n```\\npermute([1, 2, 3]):\\ni = 0: nums[0] == 1 --> [[1, ...[2,3]], [1, ...[3,2]]] --> [[1,2,3], [1,3,2]]\\ni = 1: nums[1] == 2 --> [[2, ...[1,3]], [2, ...[3,1]]] --> [[2,1,3], [2,3,1]]\\ni = 1: nums[2] == 3 --> [[3, ...[1,2]], [3, ...[2,1]]] --> [[3,1,2], [3,2,1]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18442,
                "title": "java-backtracking-solution",
                "content": "    public class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> lists = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return lists;\\n        }\\n\\n        dfs(nums, lists, new ArrayList<Integer>());\\n        return lists;\\n    }\\n\\n    private void dfs(int[] nums, List<List<Integer>> lists, List<Integer> cur) {\\n        if (cur.size() == nums.length) {\\n            List<Integer> list = new ArrayList<>(cur);\\n            lists.add(list);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (cur.contains(nums[i])) {\\n                continue;\\n            }\\n            cur.add(nums[i]);\\n            dfs(nums, lists, cur);\\n            cur.remove(cur.size() - 1);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> lists = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return lists;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3797989,
                "title": "video-backtracking-100-unlocking-permutations",
                "content": "# Intuition\\nUpon encountering this problem, I was immediately struck by its resemblance to a well-known puzzle: generating all possible permutations of a given sequence. It\\'s like holding a Rubik\\'s Cube of numbers and twisting it to discover every conceivable arrangement. With the challenge laid out, my mind gravitated towards the elegant world of recursion, an approach that often weaves simplicity with efficiency. In particular, the concept of backtracking emerged as a promising path. Imagine walking through a maze of numbers, exploring every turn and alley, but with the magical ability to step back and try a different route whenever needed. That\\'s the beauty of backtracking in recursion. It\\'s not just about finding a solution; it\\'s about crafting an adventure through the mathematical landscape, one permutation at a time.\\n\\nhttps://youtu.be/Jlw0sIGdS_4\\n\\n# Approach\\nThe solution to this problem is elegantly found through recursion, a form of backtracking. The approach begins by initializing an empty list, `result`, to store the final permutations. Then, a recursive helper function `backtrack` is defined, which takes the remaining numbers (`nums`) and the current permutation (`path`) as parameters. The base case is reached when there are no numbers left to permute; at this point, the current `path` is added to the `result`. In the recursive case, for each number in `nums`, the following steps are performed: (i) add the current number to `path`, (ii) remove the current number from `nums`, (iii) recursively call `backtrack` with the updated `nums` and `path`, and (iv) proceed without needing to revert the changes to `nums` and `path` due to the use of list slicing. Finally, the `backtrack` function is called with the original `nums` and an empty `path` to start the process, and the `result` list containing all the permutations is returned. This method ensures that all permutations are explored by iteratively choosing one element and recursively calling the function on the remaining elements.\\n\\n# Complexity\\n- Time complexity: O(n*n!) \\n  This is because for generating permutations, we perform n! operations (since there are n! permutations for n numbers) and for each operation, we spend O(n) time for slicing the list in our recursive call.\\n\\n- Space complexity: O(n*n!) \\n  This is due to the number of solutions. In the worst case, if we have \\'n\\' distinct numbers, there would be n! permutations. Since each permutation is a list of \\'n\\' numbers, the space complexity is O(n*n!).\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```\\n## Performance \\n| Language   | Runtime | Beats   | Memory  |\\n|------------|---------|---------|---------|\\n| C++        | 0 ms    | 100%    | 7.5 MB  |\\n| Java       | 1 ms    | 98.58%  | 44.1 MB |\\n| Rust       | 1 ms    | 87.70%  | 2.3 MB  |\\n| Go         | 2 ms    | 61.28%  | 3.1 MB  |\\n| Swift      | 8 ms    | 91.96%  | 14.4 MB |\\n| Python3    | 39 ms   | 98.74%  | 16.7 MB |\\n| JavaScript | 72 ms   | 55%     | 44.1 MB |\\n| C#         | 131 ms  | 94.50%  | 43.4 MB |\\n\\n\\nThis sorted table provides a quick comparison of the runtime performance across different programming languages for the given problem.",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Swift",
                    "Go",
                    "Rust"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475963,
                "title": "backtracking-o-n-time-and-o-n-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n![image.png](https://assets.leetcode.com/users/images/14fe9f74-0ba3-42db-ab6c-74e0554f21d2_1683001886.1161199.png)\\n\\n*The problem of generating all permutations of a given array can be solved using a recursive backtracking algorithm. The basic idea is to swap each element of the array with every other element in the array, and then recursively generate all permutations of the remaining elements. Once we have generated all permutations of the remaining elements, we swap the original elements back to restore the original order of the array.*\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    // Recursive helper function to generate permutations\\n    void helper(int l, int r, vector<int>& nums, vector<vector<int>>& ans) {\\n        // Base case: when left and right pointers are equal,\\n        // we have generated a permutation and add it to the answer.\\n        if (l == r) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        // Recursive case: for each index i in the range [l, r],\\n        // swap nums[l] with nums[i], generate permutations of the rest\\n        // of the array, and then swap back to restore original order.\\n        else {\\n            for (int i = l; i <= r; i++) {\\n                swap(nums[l], nums[i]); // Swap nums[l] with nums[i]\\n                helper(l+1, r, nums, ans); // Recursively generate permutations for remaining indices\\n                swap(nums[l], nums[i]); // Swap back to restore original order\\n            }\\n        }\\n    }\\n    // Main function to generate permutations\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, nums.size()-1, nums, ans); // Generate permutations starting from index 0 to n-1\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n * n!)**, where n! is the number of permutations of an n-element array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(n * n!)**, In the recursive helper function, we are using the call stack to store the state of each recursive call. The maximum depth of the call stack is n, which corresponds to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    // Recursive helper function to generate permutations\\n    void helper(int l, int r, vector<int>& nums, vector<vector<int>>& ans) {\\n        // Base case: when left and right pointers are equal,\\n        // we have generated a permutation and add it to the answer.\\n        if (l == r) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        // Recursive case: for each index i in the range [l, r],\\n        // swap nums[l] with nums[i], generate permutations of the rest\\n        // of the array, and then swap back to restore original order.\\n        else {\\n            for (int i = l; i <= r; i++) {\\n                swap(nums[l], nums[i]); // Swap nums[l] with nums[i]\\n                helper(l+1, r, nums, ans); // Recursively generate permutations for remaining indices\\n                swap(nums[l], nums[i]); // Swap back to restore original order\\n            }\\n        }\\n    }\\n    // Main function to generate permutations\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, nums.size()-1, nums, ans); // Generate permutations starting from index 0 to n-1\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990689,
                "title": "java-explained-multiple-approaches",
                "content": "**1. Using extra space**\\n\\nCreate two containers \\n\\t- First is for candidates for next permutations\\n\\t- Second is for storing current permutation\\n\\nNow let\\'s consider we\\'ve to generate all the permutations for [1,2,3]\\n\\nInitially we\\'ll have - \\nCandidates     = [1,2,3] \\nPermutation   = []\\n\\nNow we\\'ll call a recursive method for each number in the candidates, remove it from candidates, put it into the permutation and recurse for remaining candidates.\\n\\n// Method call 1\\nLoop for **i=0 to 2**, remove first candidate and put into permutation\\nCandidates     = [2,3] \\nPermutation   = [1]\\n\\n// Method call 2\\nNow 1 is fixed and we need to find possible permutations for [2,3] so we recurse for i=1 from here\\nAgain loop from **i=0 to 1** as there are only two elements left, remove first candidate and put into permutation\\nCandidates     = [3] \\nPermutation   = [1,2]\\n\\n// Method call 3\\nNow 1,2 is fixed and we need to find possible permutations for [3] so we recurse for i=2 from here\\nLoop from **i=0 to 0** as there is only one element left, remove first candidate and put into permutation\\nCandidates     = [] \\nPermutation   = [1,2,3]\\n\\n// Method call 4\\nSince first permutation is generated, put into the result and **back track to Method call 3.**\\n\\n// Method call 3\\nRemove the last element from permutation and put it back into candidates and **back track to Method call 2.**\\nCandidates     = [3] \\nPermutation   = [1,2]\\n\\n// Method call 2\\nRemove the last element from permutation and put it back into candidates and **continue the loop for index 1**\\nCandidates     = [2,3] \\nPermutation   = [1]\\n\\nremove second candidate and put into permutation\\nCandidates     = [2] \\nPermutation   = [1,3]\\n\\n// Method call 3\\nNow 1,3 is fixed and we need to find possible permutations for [2] so we recurse for i=2 from here.\\nLoop from **i=0 to 0** as there is only one element left, remove first candidate and put into permutation\\nCandidates     = [] \\nPermutation   = [1,3,2]\\n\\n// Method call 4\\nSecond permutation is generated, put into the result and **back track to Method call 3.**\\n\\n// Method call 3\\nRemove the last element from permutation and put it back into candidates and **back track to Method call 2.**\\nCandidates     = [2] \\nPermutation   = [1,3]\\n\\n// Method call 2\\nRemove the last element from permutation and put it back into candidates and **back track to Method call 1 and loop finished.**\\nCandidates     = [2,3] \\nPermutation   = [1]\\n\\nNow method 1 will again repeat the same steps for index 1 and 2 as well. and will generate all the possible permutations.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        List<Integer> candidates = new ArrayList<>();\\n        \\n        for(int num : nums) {\\n            candidates.add( num );\\n        }\\n        \\n        permute(candidates, new ArrayList<>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(List<Integer> candidates, List<Integer> permutation, List<List<Integer>> result) {\\n        \\n        // Since no number is left for permutation, a permutation is generated\\n        if( candidates.isEmpty() ) {\\n            result.add( new ArrayList<>( permutation ) );\\n            return;\\n        }\\n        \\n        int n = candidates.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = candidates.get(i);\\n            \\n            // Fix the current number\\n            permutation.add( num );\\n            \\n            // Remove the current number from candidates\\n            candidates.remove( i );\\n            \\n            // And permute for remaining numbers\\n            permute(candidates, permutation, result);\\n            \\n            // Add the number back to it\\'s original index\\n            candidates.add(i, num );\\n            \\n            // Remove the number from the permutation\\n            permutation.remove( permutation.size() - 1 );\\n        }\\n    }\\n}\\n```\\n\\n**2. Using Swapping**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        permute(nums, 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(int[] nums, int start, List<List<Integer>> result) {\\n        int n = nums.length;\\n        \\n        // All the permutations in the current path has been generated.\\n        if( start == n ) {\\n            result.add( new ArrayList<>( arrayToList( nums ) ));\\n            return;\\n        }\\n        \\n        for(int i=start; i<n; i++) {\\n            \\n            /* Swap the current number with the number at start to \\n            generate next permutation */\\n            swap(nums, i, start);\\n            \\n            /* Fix the start, permute the number after start */\\n            permute(nums, start+1, result);\\n            \\n            /* Re-swap the current number with the number at start */\\n            swap(nums, i, start);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> lst = new ArrayList<>();\\n        for(int item : arr) {\\n            lst.add( item );\\n        }\\n        return lst;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        if( i == j ) return;\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        List<Integer> candidates = new ArrayList<>();\\n        \\n        for(int num : nums) {\\n            candidates.add( num );\\n        }\\n        \\n        permute(candidates, new ArrayList<>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(List<Integer> candidates, List<Integer> permutation, List<List<Integer>> result) {\\n        \\n        // Since no number is left for permutation, a permutation is generated\\n        if( candidates.isEmpty() ) {\\n            result.add( new ArrayList<>( permutation ) );\\n            return;\\n        }\\n        \\n        int n = candidates.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = candidates.get(i);\\n            \\n            // Fix the current number\\n            permutation.add( num );\\n            \\n            // Remove the current number from candidates\\n            candidates.remove( i );\\n            \\n            // And permute for remaining numbers\\n            permute(candidates, permutation, result);\\n            \\n            // Add the number back to it\\'s original index\\n            candidates.add(i, num );\\n            \\n            // Remove the number from the permutation\\n            permutation.remove( permutation.size() - 1 );\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        permute(nums, 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(int[] nums, int start, List<List<Integer>> result) {\\n        int n = nums.length;\\n        \\n        // All the permutations in the current path has been generated.\\n        if( start == n ) {\\n            result.add( new ArrayList<>( arrayToList( nums ) ));\\n            return;\\n        }\\n        \\n        for(int i=start; i<n; i++) {\\n            \\n            /* Swap the current number with the number at start to \\n            generate next permutation */\\n            swap(nums, i, start);\\n            \\n            /* Fix the start, permute the number after start */\\n            permute(nums, start+1, result);\\n            \\n            /* Re-swap the current number with the number at start */\\n            swap(nums, i, start);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> lst = new ArrayList<>();\\n        for(int item : arr) {\\n            lst.add( item );\\n        }\\n        return lst;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        if( i == j ) return;\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492456,
                "title": "javascript-bfs",
                "content": "Javascript Breath First Search. \\n\\nEach queue element will have two array: \\n* The first array is the current sequence we have constructed so far. \\n* The second array is the remaning numbers from nums. \\n\\nFor every element of the queue we add a new element for every remaning number. For example: \\nif our nums = [1,2,3] and we dequed the following element: [ [1], [2, 3] ], then: \\n\\tWe iterate through the second array and add  [ [1 ,2] , [3] ] and [ [1, 3] , [2] ] to the queue. \\n\\n\\n```\\nvar permute = function(nums) {\\n    \\n    const result = [];\\n    const queue = [];\\n    \\n    queue.push([[], nums]);\\n    \\n    while(queue.length){\\n        const [currentSequence, availableNumbers] = queue.shift();\\n        \\n        if(availableNumbers.length === 0)\\n        {\\n            result.push(currentSequence);\\n            continue;\\n        }\\n            \\n        \\n        for(let i =0; i < availableNumbers.length; i++)\\n        {\\n            const number = availableNumbers[i];\\n            queue.push([\\n                [...currentSequence, number], \\n                [...availableNumbers.slice(0, i), ...availableNumbers.slice(i + 1)]\\n            ]);    \\n        }   \\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar permute = function(nums) {\\n    \\n    const result = [];\\n    const queue = [];\\n    \\n    queue.push([[], nums]);\\n    \\n    while(queue.length){\\n        const [currentSequence, availableNumbers] = queue.shift();\\n        \\n        if(availableNumbers.length === 0)\\n        {\\n            result.push(currentSequence);\\n            continue;\\n        }\\n            \\n        \\n        for(let i =0; i < availableNumbers.length; i++)\\n        {\\n            const number = availableNumbers[i];\\n            queue.push([\\n                [...currentSequence, number], \\n                [...availableNumbers.slice(0, i), ...availableNumbers.slice(i + 1)]\\n            ]);    \\n        }   \\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525691,
                "title": "simple-and-easy-to-understand-c-using-recursion-98-faster-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> results;\\n        generatePermutations(0, &nums, &results);\\n        return results;\\n    }\\nprivate:\\n    void generatePermutations(int i, vector<int>* nums_ptr, vector<vector<int>>* results) {\\n        auto& nums = *nums_ptr;\\n        if (i == nums.size() - 1) {\\n            results->emplace_back(nums);\\n            return;\\n        }\\n        \\n        for (int j = i; j < nums.size(); ++j) {\\n            std::swap(nums[i], nums[j]);\\n            generatePermutations(i + 1, nums_ptr, results);\\n            std::swap(nums[i], nums[j]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> results;\\n        generatePermutations(0, &nums, &results);\\n        return results;\\n    }\\nprivate:\\n    void generatePermutations(int i, vector<int>* nums_ptr, vector<vector<int>>* results) {\\n        auto& nums = *nums_ptr;\\n        if (i == nums.size() - 1) {\\n            results->emplace_back(nums);\\n            return;\\n        }\\n        \\n        for (int j = i; j < nums.size(); ++j) {\\n            std::swap(nums[i], nums[j]);\\n            generatePermutations(i + 1, nums_ptr, results);\\n            std::swap(nums[i], nums[j]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389065,
                "title": "javascript-solution-98",
                "content": "```\\nvar permute = function(nums) {\\n\\n    let permutations = []\\n    \\n    let findPermutations = function(visited = new Set(), currPerm = []) {\\n        if (currPerm.length === nums.length) {\\n            permutations.push(currPerm)\\n            return\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            if(!visited.has(i)) {\\n                findPermutations(new Set([...visited, i]), [...currPerm, nums[i]])\\n            }\\n        }\\n    }\\n    \\n    findPermutations()\\n    \\n    return permutations;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar permute = function(nums) {\\n\\n    let permutations = []\\n    \\n    let findPermutations = function(visited = new Set(), currPerm = []) {\\n        if (currPerm.length === nums.length) {\\n            permutations.push(currPerm)\\n            return\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            if(!visited.has(i)) {\\n                findPermutations(new Set([...visited, i]), [...currPerm, nums[i]])\\n            }\\n        }\\n    }\\n    \\n    findPermutations()\\n    \\n    return permutations;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247779,
                "title": "easy-solution-for-kotlin",
                "content": "```\\nclass Solution {\\n    private val result: MutableList<List<Int>> = mutableListOf()\\n\\n    fun permute(nums: IntArray): List<List<Int>> {\\n        permuteAux(mutableListOf(), nums.toList())\\n        return result\\n    }\\n\\n    private fun permuteAux(added: List<Int>, left: List<Int>) {\\n        if (left.isEmpty()) {\\n            result.add(added)\\n        } else {\\n            left.forEach { candidate ->\\n                permuteAux(added + candidate, left - candidate)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private val result: MutableList<List<Int>> = mutableListOf()\\n\\n    fun permute(nums: IntArray): List<List<Int>> {\\n        permuteAux(mutableListOf(), nums.toList())\\n        return result\\n    }\\n\\n    private fun permuteAux(added: List<Int>, left: List<Int>) {\\n        if (left.isEmpty()) {\\n            result.add(added)\\n        } else {\\n            left.forEach { candidate ->\\n                permuteAux(added + candidate, left - candidate)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18563,
                "title": "share-my-c-backtracksolution",
                "content": "\\n    class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n        \\tvector<vector<int> > res;   // result\\n        \\tvector<bool> flags( num.size(), false);    // bool, whether num[i] is choosed\\n        \\tvector<int> path;     // num have been choosed\\n        \\tbacktrack(num, res, path, flags);   //backtrack\\n        \\treturn res;\\t\\n        }\\n    \\n        void backtrack(vector<int> &num, vector<vector<int> > &res, \\n    \\tvector<int> path,vector<bool> flags)\\n    {\\n    \\tif( num.size() == path.size() )\\n    \\t{\\n    \\t\\tres.push_back(path);\\n    \\t}\\n    \\telse\\n    \\t{\\n    \\t\\tfor( int i = 0; i < num.size(); i++ )\\n    \\t\\t{\\n    \\t\\t\\tif( flags[i] == true )\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tpath.push_back(num[i]);\\n    \\t\\t\\t\\tflags[i] = true;\\n    \\t\\t\\t\\tbacktrack( num, res, path, flags );\\n    \\t\\t\\t\\tflags[i] = false;\\n    \\t\\t\\t\\tpath.pop_back();\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t}\\n    \\t}\\n    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n        \\tvector<vector<int> > res;   // result\\n        \\tvector<bool> flags( num.size(), false);    // bool, whether num[i] is choosed\\n        \\tvector<int> path;     // num have been choosed\\n        \\tbacktrack(num, res, path, flags);   //backtrack\\n        \\treturn res;\\t\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3851219,
                "title": "c-easy-recursive-and-backtracking-solution-heavy-commented",
                "content": "## **\\u2705\\u2705C++ Easy Recursive and Backtracking Solution**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    void rec(int idx,vector<int>&nums,vector<vector<int>>&ans){\\n        //if our index reached nums.size() then we will and the nums in ans and return\\n        if(idx==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        //we are traversing from idx to nums.size() and swapping the nums[i] and nums[idx]\\n        for(int i=idx;i<nums.size();i++){\\n            swap(nums[idx],nums[i]);\\n            rec(idx+1,nums,ans);\\n            //backtracking \\n            swap(nums[idx],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //we have created the ans vector for storing all the permutation in it\\n        vector<vector<int>>ans;\\n        //we are calling recursive function for the 0th index\\n        rec(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/a7291557-8a27-49e5-88f9-9565acd4c438_1690952446.59402.png)\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(int idx,vector<int>&nums,vector<vector<int>>&ans){\\n        //if our index reached nums.size() then we will and the nums in ans and return\\n        if(idx==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        //we are traversing from idx to nums.size() and swapping the nums[i] and nums[idx]\\n        for(int i=idx;i<nums.size();i++){\\n            swap(nums[idx],nums[i]);\\n            rec(idx+1,nums,ans);\\n            //backtracking \\n            swap(nums[idx],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //we have created the ans vector for storing all the permutation in it\\n        vector<vector<int>>ans;\\n        //we are calling recursive function for the 0th index\\n        rec(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538037,
                "title": "python-seriously-1-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(itertools.permutations(nums,len(nums)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(itertools.permutations(nums,len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480880,
                "title": "c-recurive-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findpermutation(vector<int>& nums, vector<vector<int>>&ans, vector<int>&ds,int freq[]){\\n        if(ds.size()==nums.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=0;i<nums.size(); i++){\\n            if(!freq[i]){\\n                ds.push_back(nums[i]);\\n                freq[i]=1;\\n                findpermutation(nums,ans,ds,freq);\\n                freq[i]=0;\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        int freq[nums.size()];\\n        for(int i=0;i<nums.size();i++){\\n            freq[i]=0;\\n        }\\n\\n        findpermutation(nums,ans,ds,freq);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findpermutation(vector<int>& nums, vector<vector<int>>&ans, vector<int>&ds,int freq[]){\\n        if(ds.size()==nums.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=0;i<nums.size(); i++){\\n            if(!freq[i]){\\n                ds.push_back(nums[i]);\\n                freq[i]=1;\\n                findpermutation(nums,ans,ds,freq);\\n                freq[i]=0;\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        int freq[nums.size()];\\n        for(int i=0;i<nums.size();i++){\\n            freq[i]=0;\\n        }\\n\\n        findpermutation(nums,ans,ds,freq);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099923,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/nXQUC0gpvck\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 0){\\n            res.push(temp)\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 0){\\n            res.push(temp)\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557947,
                "title": "easiest-cpp-solution-without-swapping-array-elements-using-recursion-and-backtracking",
                "content": "```\\n/*\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   o\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t / | \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   /   |   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /     |     \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /       |       \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /         |         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t   /           |           \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t /             |             \\\\ \\n\\t\\t\\t\\t\\t\\t\\t\\t1              2              3\\n\\t\\t\\t\\t\\t\\t\\t   / \\\\            / \\\\            / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2   3          3   1          2   1\\n\\t\\t\\t\\t\\t\\t\\t /     \\\\        /     \\\\        /     \\\\\\n\\t\\t\\t\\t\\t\\t\\t3       2      1       3      1       2\\n\\t\\t\\t\\t\\t\\t\\t|       |      |       |      |       |\\n\\t\\t\\t\\t\\t\\t   123     132    231     213    321     312\\n*/\\nclass Solution {\\npublic:\\n    void permutation(vector<int> &vec, int k, vector<int> &a, vector<int> &res, vector<vector<int>> &ans){\\n        if(k==vec.size()){\\n            ans.push_back(res);//pushing res vector to ans vector\\n        }\\n        else{\\n            for(int i=0;i<vec.size();i++){\\n\\t\\t\\t//checking if that element is already taken or not, if it is 0 then we will add it\\n\\t\\t\\t//in resultant vector else we will move forward\\n                if(a[i]==0){\\n                    res[k] = vec[i];  //adding element to resultant vector\\n                    a[i] = 1;  //Assign 1 such that next time it will not get counted\\n                    permutation(vec, k+1, a, res, ans);  //calling function by increasing k\\n                    a[i] = 0;  //backtracking(moving back to previous position)\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans; \\n        vector<int> a(nums.size(), 0);  //for storing 0 & 1(vector for checking)\\n        vector<int> res(nums.size());  //for storing vector elemets\\n        permutation(nums, 0, a, res, ans);  //calling recursive function\\n        return ans;  //returning answer\\n    }\\n};\\n```\\n**I hope you find this solution helpful. If so, then please upvote it...\\u270C\\uD83C\\uDFFB\\uD83E\\uDD17**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/*\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   o\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t / | \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   /   |   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /     |     \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /       |       \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /         |         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t   /           |           \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t /             |             \\\\ \\n\\t\\t\\t\\t\\t\\t\\t\\t1              2              3\\n\\t\\t\\t\\t\\t\\t\\t   / \\\\            / \\\\            / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2   3          3   1          2   1\\n\\t\\t\\t\\t\\t\\t\\t /     \\\\        /     \\\\        /     \\\\\\n\\t\\t\\t\\t\\t\\t\\t3       2      1       3      1       2\\n\\t\\t\\t\\t\\t\\t\\t|       |      |       |      |       |\\n\\t\\t\\t\\t\\t\\t   123     132    231     213    321     312\\n*/\\nclass Solution {\\npublic:\\n    void permutation(vector<int> &vec, int k, vector<int> &a, vector<int> &res, vector<vector<int>> &ans){\\n        if(k==vec.size()){\\n            ans.push_back(res);//pushing res vector to ans vector\\n        }\\n        else{\\n            for(int i=0;i<vec.size();i++){\\n\\t\\t\\t//checking if that element is already taken or not, if it is 0 then we will add it\\n\\t\\t\\t//in resultant vector else we will move forward\\n                if(a[i]==0){\\n                    res[k] = vec[i];  //adding element to resultant vector\\n                    a[i] = 1;  //Assign 1 such that next time it will not get counted\\n                    permutation(vec, k+1, a, res, ans);  //calling function by increasing k\\n                    a[i] = 0;  //backtracking(moving back to previous position)\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans; \\n        vector<int> a(nums.size(), 0);  //for storing 0 & 1(vector for checking)\\n        vector<int> res(nums.size());  //for storing vector elemets\\n        permutation(nums, 0, a, res, ans);  //calling recursive function\\n        return ans;  //returning answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308076,
                "title": "detailed-explanation-about-why-the-time-complexity-of-two-methods-are-o-n-n-and-o-n",
                "content": "I will demonstrate two methods here. \\n* The complexity of the basic DFS is `O(n*n!)`\\n* The complexity of the DFS with swap is `O(n!)`\\n\\n### **Method 1**\\nThe first method is the basic DFS (not using swap). Its time complexity is `O(n*n!)`. I paste the code first.\\n\\n```java\\n/*\\n * Method1: DFS - use an extra boolean array for visited-checking\\n * 1ms, 92.55%\\n * For each position pos in nums, i.e., pos is [0, len-1], we try each number that has not been\\n * used yet.\\n * For example, nums=[1,2,3,4], at index 0, we can try 1, 2, 3, 4, say this time we try\\n * 2, then at index 1, we can try 1, 3, 4, and so on.\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> cur = new ArrayList<>();\\n    // The last parameter, a boolean array, is to record which elements has been used\\n    dfs(nums, 0, ans, cur, new boolean[nums.length]);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans, List<Integer> cur, boolean[] visited) {\\n    if (pos == nums.length) {\\n      ans.add(new ArrayList<>(cur));\\n      return;\\n    }\\n    // Try all the elements that are not used yet in this position\\n    for (int i = 0; i < nums.length; ++i) {\\n      if (!visited[i]) {\\n        visited[i] = true;\\n        cur.add(nums[i]);\\n        dfs(nums, pos + 1, ans, cur, visited);\\n        cur.remove(cur.size() - 1);\\n        visited[i] = false;\\n      }\\n    }\\n  }\\n}\\n```\\n\\nThe time complexity is determined by the total number of nodes in the recursion tree. Take nums=[1, 2, 3] as an example. \\n\\n![image](https://assets.leetcode.com/users/images/51a9e886-04b0-453f-966e-9f36a52751a8_1625103952.2332764.jpeg)\\n\\nThe number of nodes is `1 + 3 + 3*2 + 3*2*1`. Now let\\'s extend this to a general case. Let nums has n numbers. The total number of nodes the recursion tree has will be:\\n```plain\\n1 + n + n*(n-1) + n*(n-1)*(n-2) + ... + n*(n-1)*(n-2)*...*2 + n*(n-1)*(n-2)*...*2*1\\n```\\n\\nNow we reverse the order of the terms:\\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n```\\n\\nNext, let\\'s simplify it\\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n= n! + n!/1! + n!/2! + ... + n!/(n-1)! + n!/n!\\n= n! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!)           ---------------------------------- formula (1)\\n```\\n\\nBased on Taylor Formula, \\n```plain\\ne^x = 1 + x + x^2/2! + x^3/3! + x^4/4! + ... +x^n/n!\\n```\\n\\nLet `x = 1`, we got\\n```plain\\ne = 1 + 1 + 1/2! + 1/3! + 1/4! + ... + 1/n!\\n```\\n\\nNext, combine this with formula (1) above, we get\\n```plain\\nn! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!) \\n= n! * e\\n```\\n\\nNow, we know that the total number of nodes in the recursion tree is `n! * e`. \\n\\nIn each non-leaf node, we have a for-loop which iterate over all the n numbers. Its time is `O(n)`. In each leaf node, we add the current result to the final answer by `ans.add(new ArrayList<>(cur));` whose time is `O(n)` as well. So in each node, it take `O(n)`. \\n\\nSo the time complexity is `O(n * n! * e)`, i.e., `O(n * n!)`. \\n\\n### **Method 2**\\nThe second method is DFS with swap. The time complexity is `O(n!)`. \\n\\n```java\\n * Method2: DFS - use swap to avoid visited-checking\\n * 0ms, 100%\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    dfs(nums, 0, ans);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans) {\\n    if (pos == nums.length) {\\n      ans.add(arrayToList(nums));\\n      return;\\n    }\\n    // For each position pos in nums, i.e., pos is [0, len-1], we swap nums[pos] with each\\n    // number after it.\\n    for (int i = pos; i < nums.length; ++i) {\\n      swap(nums, pos, i);\\n      dfs(nums, pos + 1, ans);\\n      swap(nums, i, pos);\\n    }\\n  }\\n\\n  private List<Integer> arrayToList(int[] array) {\\n    List<Integer> l = new ArrayList<>();\\n    for (int i : array) {\\n      l.add(i);\\n    }\\n    return l;\\n  }\\n\\n  private void swap(int[] nums, int i, int j) {\\n    if (i == j) {\\n      return;\\n    }\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n  }\\n}\\n```\\n\\nTake a look at the for-loop, on each node, it is not from 0 to n, and instead it is from pos to n. So the number of execution is not constant n for each node, but decreasing level by level. For example, in the root node, for-loop has n executions (pos is from 0 to n); in a node of the second level, for-loop has n-1 executions (pos is from 1 to n); and so on so forth. \\n\\nIn the figure below, I use `[1, 2, 3]` as an example, and I list \\n1. the number of nodes each level has\\n2. the number of executions in the for-loop for each node in a level\\n3. the number of executions for all nodes in a level (equals to the multiplication of the two numbers above)\\n\\n![image](https://assets.leetcode.com/users/images/44ad5d75-bb8c-4e1a-a42f-9c660006e1d6_1626470559.319824.jpeg)\\n\\nNow let\\'s generalize it to an array with n numbers. The total number of executions for all nodes in the recursion tree is:\\n```plain\\n1*n + n*(n-1) + n*(n-2)*(n-3) + ... + n(n-1)(n-2)...1\\n= n!/(n-1)! + n!/(n-2)! + ... + n!\\n= n! * (1/(n-1)! + 1/(n-2)! + ... + 1)\\n= n! * (e - 1/n!)\\n= n! * e - 1\\n= O(n!)\\n```\\n\\nSo the time complexity of this method is `O(n!)`.\\n\\n\\nHope this is helpful. Thank you very much. \\n\\n",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\n/*\\n * Method1: DFS - use an extra boolean array for visited-checking\\n * 1ms, 92.55%\\n * For each position pos in nums, i.e., pos is [0, len-1], we try each number that has not been\\n * used yet.\\n * For example, nums=[1,2,3,4], at index 0, we can try 1, 2, 3, 4, say this time we try\\n * 2, then at index 1, we can try 1, 3, 4, and so on.\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> cur = new ArrayList<>();\\n    // The last parameter, a boolean array, is to record which elements has been used\\n    dfs(nums, 0, ans, cur, new boolean[nums.length]);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans, List<Integer> cur, boolean[] visited) {\\n    if (pos == nums.length) {\\n      ans.add(new ArrayList<>(cur));\\n      return;\\n    }\\n    // Try all the elements that are not used yet in this position\\n    for (int i = 0; i < nums.length; ++i) {\\n      if (!visited[i]) {\\n        visited[i] = true;\\n        cur.add(nums[i]);\\n        dfs(nums, pos + 1, ans, cur, visited);\\n        cur.remove(cur.size() - 1);\\n        visited[i] = false;\\n      }\\n    }\\n  }\\n}\\n```\n```plain\\n1 + n + n*(n-1) + n*(n-1)*(n-2) + ... + n*(n-1)*(n-2)*...*2 + n*(n-1)*(n-2)*...*2*1\\n```\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n```\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n= n! + n!/1! + n!/2! + ... + n!/(n-1)! + n!/n!\\n= n! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!)           ---------------------------------- formula (1)\\n```\n```plain\\ne^x = 1 + x + x^2/2! + x^3/3! + x^4/4! + ... +x^n/n!\\n```\n```plain\\ne = 1 + 1 + 1/2! + 1/3! + 1/4! + ... + 1/n!\\n```\n```plain\\nn! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!) \\n= n! * e\\n```\n```java\\n * Method2: DFS - use swap to avoid visited-checking\\n * 0ms, 100%\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    dfs(nums, 0, ans);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans) {\\n    if (pos == nums.length) {\\n      ans.add(arrayToList(nums));\\n      return;\\n    }\\n    // For each position pos in nums, i.e., pos is [0, len-1], we swap nums[pos] with each\\n    // number after it.\\n    for (int i = pos; i < nums.length; ++i) {\\n      swap(nums, pos, i);\\n      dfs(nums, pos + 1, ans);\\n      swap(nums, i, pos);\\n    }\\n  }\\n\\n  private List<Integer> arrayToList(int[] array) {\\n    List<Integer> l = new ArrayList<>();\\n    for (int i : array) {\\n      l.add(i);\\n    }\\n    return l;\\n  }\\n\\n  private void swap(int[] nums, int i, int j) {\\n    if (i == j) {\\n      return;\\n    }\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n  }\\n}\\n```\n```plain\\n1*n + n*(n-1) + n*(n-2)*(n-3) + ... + n(n-1)(n-2)...1\\n= n!/(n-1)! + n!/(n-2)! + ... + n!\\n= n! * (1/(n-1)! + 1/(n-2)! + ... + 1)\\n= n! * (e - 1/n!)\\n= n! * e - 1\\n= O(n!)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822916,
                "title": "simple-java-solution-recursive-0ms-100-faster",
                "content": "It is similar to subset question.\\n\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        permutations(nums,0,list);\\n        return list;\\n    }\\n    \\n    public void permutations(int[] nums,int i,List<List<Integer>> list) {\\n        if(i==nums.length) {\\n            List<Integer> sublist = new ArrayList<>();\\n            for(int j=0;j<nums.length;j++){\\n                sublist.add(nums[j]);\\n            }\\n            list.add(sublist);\\n            return;\\n        }\\n        for(int start=i;start<nums.length;start++) {\\n            swap(nums,i,start);\\n            permutations(nums,i+1,list);  \\n            swap(nums,i,start);            \\n        }\\n\\n    }\\n    \\n    private void swap(int[] nums,int i,int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        permutations(nums,0,list);\\n        return list;\\n    }\\n    \\n    public void permutations(int[] nums,int i,List<List<Integer>> list) {\\n        if(i==nums.length) {\\n            List<Integer> sublist = new ArrayList<>();\\n            for(int j=0;j<nums.length;j++){\\n                sublist.add(nums[j]);\\n            }\\n            list.add(sublist);\\n            return;\\n        }\\n        for(int start=i;start<nums.length;start++) {\\n            swap(nums,i,start);\\n            permutations(nums,i+1,list);  \\n            swap(nums,i,start);            \\n        }\\n\\n    }\\n    \\n    private void swap(int[] nums,int i,int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790275,
                "title": "java-solution-backtrack-remove-the-last-element",
                "content": "* **Please upvote if helpFul!!**\\n```\\nclass Solution {\\n    //[1,2,3]\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> resultList, ArrayList<Integer> tempSet, int[] nums) {\\n\\n        if (tempSet.size() == nums.length) {\\n            resultList.add(new ArrayList<>(tempSet));\\n            return;\\n        }\\n\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (tempSet.contains(nums[i])) continue;\\n            tempSet.add(nums[i]);\\n            backtrack(resultList, tempSet, nums);\\n            tempSet.remove(tempSet.size() - 1);  // v v v IMP step....this is where backtrack magic happens...\\n\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    //[1,2,3]\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> resultList, ArrayList<Integer> tempSet, int[] nums) {\\n\\n        if (tempSet.size() == nums.length) {\\n            resultList.add(new ArrayList<>(tempSet));\\n            return;\\n        }\\n\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (tempSet.contains(nums[i])) continue;\\n            tempSet.add(nums[i]);\\n            backtrack(resultList, tempSet, nums);\\n            tempSet.remove(tempSet.size() - 1);  // v v v IMP step....this is where backtrack magic happens...\\n\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359476,
                "title": "c-clear-general-backtracking-beats-98-38-in-time-100-00-in-memory",
                "content": "```\\n\\tvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        backtrack(res, nums, current);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count(current.begin(), current.end(), nums[i]) == 0){\\n                current.push_back(nums[i]);\\n                backtrack(res, nums, current);\\n                current.pop_back();\\n            }\\n        }\\n    }\\n```\\n\\nRuntime: 8 ms, faster than 98.38% of C++ online submissions.\\n\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions.\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n\\tvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        backtrack(res, nums, current);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count(current.begin(), current.end(), nums[i]) == 0){\\n                current.push_back(nums[i]);\\n                backtrack(res, nums, current);\\n                current.pop_back();\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18539,
                "title": "my-ac-solution-in-c-i-think-this-is-not-dfs-is-it",
                "content": "    class Solution {\\n    public:\\n    \\tvector<vector<int> > permute(vector<int> &num) {\\n    \\t\\tvector<vector<int>> result;\\n    \\t\\tif (num.size() == 0)\\n    \\t\\t\\treturn result;\\n    \\t\\tsort(num.begin(), num.end());\\n    \\t\\tpermute(num, 0, result);\\n    \\t\\treturn result;\\n    \\t}\\n    private:\\n    \\tvoid permute(vector<int> &num, size_t start, vector<vector<int>> &result){\\n    \\t\\tif (start == num.size()-1){\\n    \\t\\t\\tresult.push_back(num);\\n    \\t\\t}\\n    \\t\\telse{\\n    \\t\\t\\tfor (size_t i = start; i < num.size(); i++){\\n    \\t\\t\\t\\tswap(num[start], num[i]);\\n    \\t\\t\\t\\tpermute(num, start + 1, result);\\n    \\t\\t\\t\\tswap(num[start], num[i]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > permute(vector<int> &num) {\\n    \\t\\tvector<vector<int>> result;\\n    \\t\\tif (num.size() == 0)\\n    \\t\\t\\treturn result;\\n    \\t\\tsort(num.begin(), num.end());\\n    \\t\\tpermute(num, 0, result);\\n    \\t\\treturn result;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3854776,
                "title": "beats-100-simple-recursion-with-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> ans;\\n    int n;\\n    void solve(vector<int> &nums, int mask, vector<int> &temp)\\n    {\\n        if(mask==((1<<n)-1))\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!(mask&(1<<i)))\\n            {\\n                temp.push_back(nums[i]);\\n                solve(nums, mask|(1<<i), temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        n=nums.size();\\n        int mask=0;\\n        vector<int> temp;\\n        solve(nums, mask, temp);      \\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n    int n;\\n    void solve(vector<int> &nums, int mask, vector<int> &temp)\\n    {\\n        if(mask==((1<<n)-1))\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!(mask&(1<<i)))\\n            {\\n                temp.push_back(nums[i]);\\n                solve(nums, mask|(1<<i), temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        n=nums.size();\\n        int mask=0;\\n        vector<int> temp;\\n        solve(nums, mask, temp);      \\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850769,
                "title": "beats-100-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/c1bh0cRLrIU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> permute(int[] nums) {\\n        result = new ArrayList<>();\\n        helper(new ArrayList<>(), nums);\\n        return result;\\n    }\\n    \\n    public void helper(List<Integer> curr, int[] nums) {\\n        if (curr.size() == nums.length) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        for (int num: nums) {\\n            if (!curr.contains(num)) {\\n                curr.add(num);\\n                helper(curr, nums);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> curr;\\n        helper(curr, nums);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& curr, vector<int>& nums) {\\n        if (curr.size() == nums.size()) {\\n            result.push_back(curr);\\n            return;\\n        }\\n        \\n        for (int num : nums) {\\n            if (find(curr.begin(), curr.end(), num) == curr.end()) {\\n                curr.push_back(num);\\n                helper(curr, nums);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.helper([], nums, result)\\n        return result\\n    \\n    def helper(self, curr, nums, result):\\n        if len(curr) == len(nums):\\n            result.append(curr.copy())\\n            return\\n        \\n        for num in nums:\\n            if num not in curr:\\n                curr.append(num)\\n                self.helper(curr, nums, result)\\n                curr.pop()\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> permute(int[] nums) {\\n        result = new ArrayList<>();\\n        helper(new ArrayList<>(), nums);\\n        return result;\\n    }\\n    \\n    public void helper(List<Integer> curr, int[] nums) {\\n        if (curr.size() == nums.length) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        for (int num: nums) {\\n            if (!curr.contains(num)) {\\n                curr.add(num);\\n                helper(curr, nums);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> curr;\\n        helper(curr, nums);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& curr, vector<int>& nums) {\\n        if (curr.size() == nums.size()) {\\n            result.push_back(curr);\\n            return;\\n        }\\n        \\n        for (int num : nums) {\\n            if (find(curr.begin(), curr.end(), num) == curr.end()) {\\n                curr.push_back(num);\\n                helper(curr, nums);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.helper([], nums, result)\\n        return result\\n    \\n    def helper(self, curr, nums, result):\\n        if len(curr) == len(nums):\\n            result.append(curr.copy())\\n            return\\n        \\n        for num in nums:\\n            if num not in curr:\\n                curr.append(num)\\n                self.helper(curr, nums, result)\\n                curr.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792941,
                "title": "python3-easy-to-understand-simple-recursive-approach-beats-85",
                "content": "# Approach\\nRecursive call tries to add a number that was not used earlier (not in the list). If the list gains the right length it goes to the result. The process repeats with each num as a first element.\\n# Code\\n```re\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def solve(s=[], nums=[]):\\n            if len(s) == len(nums):\\n                res.append(s)\\n                return\\n            for i in range(len(nums)):\\n                if nums[i] not in s:\\n                    solve(s + [nums[i]], nums)\\n        solve([], nums)\\n        return res\\n\\n```\\n\\n\\n## UPVOTE makes me happy --> (o\\u02D8\\u25E1\\u02D8o)",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```re\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def solve(s=[], nums=[]):\\n            if len(s) == len(nums):\\n                res.append(s)\\n                return\\n            for i in range(len(nums)):\\n                if nums[i] not in s:\\n                    solve(s + [nums[i]], nums)\\n        solve([], nums)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776165,
                "title": "c-simple-and-concise-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<vector<int>> &ans, vector<int> v){\\n        if(idx == v.size()){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = idx;i < v.size();i++){\\n            swap(v[i], v[idx]);\\n            helper(idx+1, ans, v);\\n            swap(v[i], v[idx]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, ans, nums);\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<vector<int>> &ans, vector<int> v){\\n        if(idx == v.size()){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = idx;i < v.size();i++){\\n            swap(v[i], v[idx]);\\n            helper(idx+1, ans, v);\\n            swap(v[i], v[idx]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, ans, nums);\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630991,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<vector<int>> &ans){\\n        if(i>=n-1){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int j = i; j < n; j++){\\n            swap(v[i],v[j]);\\n            solve(i+1,n,v,ans);\\n            swap(v[i],v[j]);\\n        }\\n\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        solve(0,n,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<vector<int>> &ans){\\n        if(i>=n-1){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int j = i; j < n; j++){\\n            swap(v[i],v[j]);\\n            solve(i+1,n,v,ans);\\n            swap(v[i],v[j]);\\n        }\\n\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        solve(0,n,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561075,
                "title": "easy-to-understand-with-hand-written-example-well-commented",
                "content": "# Code\\n![Adobe Scan May 25, 2023_1.jpg](https://assets.leetcode.com/users/images/6e4c7c07-d522-4649-9503-0f4e6c69296d_1684998844.7881637.jpeg)\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums,int i,vector<vector<int>> &res){\\n        //If index reaches to the last push the nums to result\\n        if(i==nums.size()-1){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n            //Swap the values and then recursively call the function again.\\n            swap(nums[i],nums[j]);\\n            solve(nums,i+1,res);\\n            //Backtracking\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(nums,0,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums,int i,vector<vector<int>> &res){\\n        //If index reaches to the last push the nums to result\\n        if(i==nums.size()-1){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n            //Swap the values and then recursively call the function again.\\n            swap(nums[i],nums[j]);\\n            solve(nums,i+1,res);\\n            //Backtracking\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(nums,0,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454676,
                "title": "beates-everyone-java-recursive-solution-2-approaches-explained",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N!)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Without Using Extra Space\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // call the helper function to generate all permutations\\n        helper(0,nums,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int index, int nums[], List<List<Integer>> ans){\\n        // if we have processed all elements up to the last one in the array,\\n        // add the current permutation to the list of permutations and return\\n        if(index == nums.length){\\n            // create a list to store the current permutation\\n            List<Integer> ds = new ArrayList<>();\\n\\n            // copy the current array into the list\\n            for(int i = 0; i < nums.length;i++){\\n                ds.add(nums[i]);\\n            }\\n\\n            // add the current permutation to the list of permutations\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through the remaining elements in the array starting from the current index\\n        for(int i = index; i < nums.length;i++){\\n            // swap the current element with the element at the current index\\n            swap(i,index,nums);\\n\\n            // call the helper function recursively to generate all permutations using the remaining elements\\n            helper(index+1, nums, ans);\\n\\n            // swap the current element back to its original position\\n            swap(i,index,nums);\\n        }\\n    }\\n\\n    // helper method to swap two elements in the array\\n    private void swap(int i, int j, int nums[]){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/e1511521-29cf-4935-9a96-12802ce94e9d_1682443584.171484.png)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N!)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N * N!)\\n\\n\\n# Using Extra Boolean Array\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // create a list to store the current permutation being built\\n        ArrayList<Integer> ds = new ArrayList<>();\\n\\n        // create an array to keep track of whether each element has been used in the current permutation\\n        boolean freq[] = new boolean[nums.length];\\n\\n        // call the helper function to generate all permutations\\n        helper(nums,freq,ds,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int nums[], boolean freq[], ArrayList<Integer> ds, List<List<Integer>> ans){\\n        // if the current permutation is the same length as the original array,\\n        // add it to the list of permutations and return\\n        if(ds.size() == nums.length){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through each element in the original array\\n        for(int i = 0; i < nums.length;i++){\\n            // if the current element has not already been used in the current permutation\\n            if(!freq[i]){\\n                // mark the current element as used\\n                freq[i] = true;\\n                // add the current element to the current permutation\\n                ds.add(nums[i]);\\n\\n                // call the helper function recursively to generate all permutations using the current element\\n                helper(nums,freq,ds,ans);\\n\\n                // remove the current element from the current permutation and mark it as unused\\n                ds.remove(ds.size() - 1);\\n                freq[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // call the helper function to generate all permutations\\n        helper(0,nums,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int index, int nums[], List<List<Integer>> ans){\\n        // if we have processed all elements up to the last one in the array,\\n        // add the current permutation to the list of permutations and return\\n        if(index == nums.length){\\n            // create a list to store the current permutation\\n            List<Integer> ds = new ArrayList<>();\\n\\n            // copy the current array into the list\\n            for(int i = 0; i < nums.length;i++){\\n                ds.add(nums[i]);\\n            }\\n\\n            // add the current permutation to the list of permutations\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through the remaining elements in the array starting from the current index\\n        for(int i = index; i < nums.length;i++){\\n            // swap the current element with the element at the current index\\n            swap(i,index,nums);\\n\\n            // call the helper function recursively to generate all permutations using the remaining elements\\n            helper(index+1, nums, ans);\\n\\n            // swap the current element back to its original position\\n            swap(i,index,nums);\\n        }\\n    }\\n\\n    // helper method to swap two elements in the array\\n    private void swap(int i, int j, int nums[]){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // create a list to store the current permutation being built\\n        ArrayList<Integer> ds = new ArrayList<>();\\n\\n        // create an array to keep track of whether each element has been used in the current permutation\\n        boolean freq[] = new boolean[nums.length];\\n\\n        // call the helper function to generate all permutations\\n        helper(nums,freq,ds,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int nums[], boolean freq[], ArrayList<Integer> ds, List<List<Integer>> ans){\\n        // if the current permutation is the same length as the original array,\\n        // add it to the list of permutations and return\\n        if(ds.size() == nums.length){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through each element in the original array\\n        for(int i = 0; i < nums.length;i++){\\n            // if the current element has not already been used in the current permutation\\n            if(!freq[i]){\\n                // mark the current element as used\\n                freq[i] = true;\\n                // add the current element to the current permutation\\n                ds.add(nums[i]);\\n\\n                // call the helper function recursively to generate all permutations using the current element\\n                helper(nums,freq,ds,ans);\\n\\n                // remove the current element from the current permutation and mark it as unused\\n                ds.remove(ds.size() - 1);\\n                freq[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458885,
                "title": "c-solution-100-fast-0-ms-space-optimised",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(vector<int>&nums,int ind,vector<vector<int>>&ans,int max)\\n{\\n\\tif(ind >= max)\\n\\t{\\n\\t\\tans.push_back(nums);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(int i=ind;i<max;i++)\\n\\t{\\n\\t\\tswap(nums[ind],nums[i]);\\n\\t\\tsolve(nums,ind+1,ans,max);\\n\\t\\tswap(nums[i],nums[ind]);\\n\\t}\\n\\t\\n}\\n\\n vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\n\\tvector<vector<int>> ans;        \\n\\t\\n\\tint max = nums.size();\\n\\t\\n\\tsolve(nums,0,ans,max);\\n\\t\\n\\treturn ans;\\n\\n}\\n\\n};\\n```\\n\\nupvote if it helps you :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(vector<int>&nums,int ind,vector<vector<int>>&ans,int max)\\n{\\n\\tif(ind >= max)\\n\\t{\\n\\t\\tans.push_back(nums);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(int i=ind;i<max;i++)\\n\\t{\\n\\t\\tswap(nums[ind],nums[i]);\\n\\t\\tsolve(nums,ind+1,ans,max);\\n\\t\\tswap(nums[i],nums[ind]);\\n\\t}\\n\\t\\n}\\n\\n vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\n\\tvector<vector<int>> ans;        \\n\\t\\n\\tint max = nums.size();\\n\\t\\n\\tsolve(nums,0,ans,max);\\n\\t\\n\\treturn ans;\\n\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450393,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=25alMWqAOLo",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=25alMWqAOLo",
                "codeTag": "Unknown"
            },
            {
                "id": 1807685,
                "title": "easy-solution-with-image-explanation-swap-100-c",
                "content": "**Time Complexity : O(N!) * O(N)**\\n**Space Complexity : O(N)**\\n\\n\\n![image](https://assets.leetcode.com/users/images/4dff7997-f962-4adc-8082-c52ffa8fa09b_1646079113.775907.jpeg)\\n\\n```\\nclass Solution\\n{\\n    void solve(int ind, vector<int> &nums,vector<vector<int>>&ans)\\n    {\\n        if (ind == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = ind; i < nums.size(); i++)\\n        {\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }\\n\\n    public:\\n        vector<vector < int>> permute(vector<int> &nums)\\n        {\\n            vector<vector<int>>ans;\\n            solve(0,nums,ans);\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    void solve(int ind, vector<int> &nums,vector<vector<int>>&ans)\\n    {\\n        if (ind == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = ind; i < nums.size(); i++)\\n        {\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }\\n\\n    public:\\n        vector<vector < int>> permute(vector<int> &nums)\\n        {\\n            vector<vector<int>>ans;\\n            solve(0,nums,ans);\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791024,
                "title": "python-3-50ms-dfs-solution",
                "content": "```\\nclass Solution:\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470228,
                "title": "my-python-solutions-with-time-space-analysis",
                "content": "attempt 1, recursion\\n```\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.6 MB, less than 14.31%\\n    #\\n    # note:\\n    #     * return list of permutations\\n    #     * fix 1 position and use recursion to permute the others\\n    #\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def helper(nums, path):\\n            if not nums:\\n                res.append(path)\\n            else:\\n                for i in range(len(nums)):\\n                    helper(nums[:i] + nums[i + 1:], path + [nums[i]])\\n        res = []\\n        helper(nums, [])\\n        return res\\n```\\nattempt 2, backtrack\\n```\\n    # peeked https://leetcode.com/problems/permutations/discuss/360280/Python3-backtracking\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.3 MB, less than 70.36%\\n    #\\n    # note:\\n    #     * used an additional set @visited to tracke the index of elements\\n    #       visited, so that we won\\'t visit them again[]\\n    #     * this is DFS, so we keep adding @visited until @path contains all the\\n    #       elements and the record the result in @res\\n    #     * when an index is added to @visited, it means the corresponding\\n    #       element is fixed at a certain position in @path, if later we want to\\n    #       change it, it is removed from @visited\\n    #\\n    # example:\\n    #     nums = [1,2,3]\\n    #                           __ initial path\\n    #                          /\\n    #                         v\\n    #          ______________[]_________________          -> level0, P(3,0) nodes\\n    #         /               \\\\                 \\\\\\n    #        [1]              [2]               [3]       -> level1, P(3,1) nodes\\n    #       /   \\\\            /   \\\\             /   \\\\\\n    #    [1,2]  [1,3]      [2,1]  [2,3]      [3,1]  [3,2] -> level2, P(3,2) nodes\\n    #     /       \\\\        /       \\\\         /       \\\\\\n    # [1,2,3]  [1,3,2] [2,1,3]  [2,3,2]  [3,1,2]  [3,2,1] -> level3, P(3,3) nodes\\n    #\\n    # time: O(n!) < time complexity <= O(n*n!)\\n    #     * backtrack() is called with each node in the tree shown above as its\\n    #       @path parameter, so the time would be O(# of nodes in the tree)\\n    #     * (# of nodes in the tree) = P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) <= n! + n! + ... + n! = (n * n!)\\n    #       because P(n, k) = n!/(n-k)! <= n!\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) > n!\\n    #       because P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #               = n!/n! + n!/(n-1)! + ... + n!/(n-n)!\\n    #               = n!(1/n! + 1/(n-1)! + ... + 1/(n-n)!)\\n    #               < n!*1\\n    #\\n    # space: O(n), regardless the space for the solutions\\n    #     * to keep the solutions: O(n*n!)\\n    #       we have n! solutions, each has length n\\n    #     * @visited: O(n)\\n    #     * stack: O(n), considering the longest path\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(path):\\n            if len(path) == n:\\n                res.append(path)\\n            else:\\n                for i in range(n):\\n                    if i not in visited:\\n                        visited.add(i)\\n                        backtrack(path + [nums[i]])\\n                        visited.remove(i)\\n        res, visited, n = [], set(), len(nums)\\n        backtrack([])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.6 MB, less than 14.31%\\n    #\\n    # note:\\n    #     * return list of permutations\\n    #     * fix 1 position and use recursion to permute the others\\n    #\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def helper(nums, path):\\n            if not nums:\\n                res.append(path)\\n            else:\\n                for i in range(len(nums)):\\n                    helper(nums[:i] + nums[i + 1:], path + [nums[i]])\\n        res = []\\n        helper(nums, [])\\n        return res\\n```\n```\\n    # peeked https://leetcode.com/problems/permutations/discuss/360280/Python3-backtracking\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.3 MB, less than 70.36%\\n    #\\n    # note:\\n    #     * used an additional set @visited to tracke the index of elements\\n    #       visited, so that we won\\'t visit them again[]\\n    #     * this is DFS, so we keep adding @visited until @path contains all the\\n    #       elements and the record the result in @res\\n    #     * when an index is added to @visited, it means the corresponding\\n    #       element is fixed at a certain position in @path, if later we want to\\n    #       change it, it is removed from @visited\\n    #\\n    # example:\\n    #     nums = [1,2,3]\\n    #                           __ initial path\\n    #                          /\\n    #                         v\\n    #          ______________[]_________________          -> level0, P(3,0) nodes\\n    #         /               \\\\                 \\\\\\n    #        [1]              [2]               [3]       -> level1, P(3,1) nodes\\n    #       /   \\\\            /   \\\\             /   \\\\\\n    #    [1,2]  [1,3]      [2,1]  [2,3]      [3,1]  [3,2] -> level2, P(3,2) nodes\\n    #     /       \\\\        /       \\\\         /       \\\\\\n    # [1,2,3]  [1,3,2] [2,1,3]  [2,3,2]  [3,1,2]  [3,2,1] -> level3, P(3,3) nodes\\n    #\\n    # time: O(n!) < time complexity <= O(n*n!)\\n    #     * backtrack() is called with each node in the tree shown above as its\\n    #       @path parameter, so the time would be O(# of nodes in the tree)\\n    #     * (# of nodes in the tree) = P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) <= n! + n! + ... + n! = (n * n!)\\n    #       because P(n, k) = n!/(n-k)! <= n!\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) > n!\\n    #       because P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #               = n!/n! + n!/(n-1)! + ... + n!/(n-n)!\\n    #               = n!(1/n! + 1/(n-1)! + ... + 1/(n-n)!)\\n    #               < n!*1\\n    #\\n    # space: O(n), regardless the space for the solutions\\n    #     * to keep the solutions: O(n*n!)\\n    #       we have n! solutions, each has length n\\n    #     * @visited: O(n)\\n    #     * stack: O(n), considering the longest path\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(path):\\n            if len(path) == n:\\n                res.append(path)\\n            else:\\n                for i in range(n):\\n                    if i not in visited:\\n                        visited.add(i)\\n                        backtrack(path + [nums[i]])\\n                        visited.remove(i)\\n        res, visited, n = [], set(), len(nums)\\n        backtrack([])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1435474,
                "title": "c-faster-than-100-both-methods",
                "content": "The difference between both the solutions is just the space complexity . The approach is also kinda similar , in the latter instead of visited array we are swapping to save the space consumed by visited array.\\n\\n```\\nclass Solution {\\npublic:\\n\\t//TIme complexity = O(n! * n)\\n\\t//Space complexity = O(n) + O(n) ( Extra space consumed by visited array)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums , vector<int> &vec,int visited[])\\n    {\\n        if(vec.size()==nums.size())\\n        {\\n            ans.push_back(vec);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                vec.push_back(nums[i]);\\n                visited[i]=1;\\n                solve(ans,nums,vec,visited);\\n                visited[i]=0;\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> vec;\\n        int n = nums.size();\\n        int visited[n];\\n        for(int i=0;i<nums.size();i++) visited[i]=0;\\n        solve(ans,nums,vec,visited);\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Time complexity = O(n! * n)\\n\\t//Space complexity = O(n)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums ,int index)\\n    {\\n        if(index==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[index]);\\n            solve(ans,nums,index+1);\\n            swap(nums[i],nums[index]);\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solve(ans,nums,index);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Happy Coding\\nIf you like it , Do upvote**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//TIme complexity = O(n! * n)\\n\\t//Space complexity = O(n) + O(n) ( Extra space consumed by visited array)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums , vector<int> &vec,int visited[])\\n    {\\n        if(vec.size()==nums.size())\\n        {\\n            ans.push_back(vec);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                vec.push_back(nums[i]);\\n                visited[i]=1;\\n                solve(ans,nums,vec,visited);\\n                visited[i]=0;\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> vec;\\n        int n = nums.size();\\n        int visited[n];\\n        for(int i=0;i<nums.size();i++) visited[i]=0;\\n        solve(ans,nums,vec,visited);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\t// Time complexity = O(n! * n)\\n\\t//Space complexity = O(n)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums ,int index)\\n    {\\n        if(index==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[index]);\\n            solve(ans,nums,index+1);\\n            swap(nums[i],nums[index]);\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solve(ans,nums,index);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301912,
                "title": "general-recursive-approach-c-with-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> store;\\n        \\n        helper(nums, 0, store);\\n        \\n        return store;\\n    }\\n    \\n    void helper(vector<int> current, int pos, vector<vector<int>> &store)\\n    {\\n        if(pos == current.size())\\n        {\\n            store.push_back(current);       //Push the number when the permute is formed\\n            return;\\n        }\\n        else\\n            for(int idx = pos; idx < current.size(); idx++)\\n            {\\n                swap(current[pos], current[idx]);       //Swap each index recursively\\n                helper(current, pos + 1, store);        //Perform for next each Permutation\\n            }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> store;\\n        \\n        helper(nums, 0, store);\\n        \\n        return store;\\n    }\\n    \\n    void helper(vector<int> current, int pos, vector<vector<int>> &store)\\n    {\\n        if(pos == current.size())\\n        {\\n            store.push_back(current);       //Push the number when the permute is formed\\n            return;\\n        }\\n        else\\n            for(int idx = pos; idx < current.size(); idx++)\\n            {\\n                swap(current[pos], current[idx]);       //Swap each index recursively\\n                helper(current, pos + 1, store);        //Perform for next each Permutation\\n            }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925113,
                "title": "fast-1-ms-easy-java-backtracking-explained",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> listOfPermutations = new ArrayList<>(); //list to hold the permutations\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        generatePermutations(new ArrayList<Integer>(), nums);\\n        return listOfPermutations;\\n    }\\n    \\n    private void generatePermutations(List<Integer> permutation, int[] nums){\\n        if(permutation.size() == nums.length){ \\n            List<Integer> validPermutation = new ArrayList<Integer>(permutation);\\n            listOfPermutations.add(validPermutation);\\n            return;\\n        }\\n        \\n        /*Start a for loop for every number in the nums[] array and recursively call\\n        the backtracking function until a valid permutation is obtained. Since we do not want\\n        permutations with repeated numbers, we will skip a number if it has already been added\\n        to the permutation.*/\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(permutation.contains(nums[i])){  //skip if already added\\n                continue;\\n            }\\n            permutation.add(nums[i]);\\n            generatePermutations(permutation, nums);\\n            permutation.remove(permutation.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> listOfPermutations = new ArrayList<>(); //list to hold the permutations\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        generatePermutations(new ArrayList<Integer>(), nums);\\n        return listOfPermutations;\\n    }\\n    \\n    private void generatePermutations(List<Integer> permutation, int[] nums){\\n        if(permutation.size() == nums.length){ \\n            List<Integer> validPermutation = new ArrayList<Integer>(permutation);\\n            listOfPermutations.add(validPermutation);\\n            return;\\n        }\\n        \\n        /*Start a for loop for every number in the nums[] array and recursively call\\n        the backtracking function until a valid permutation is obtained. Since we do not want\\n        permutations with repeated numbers, we will skip a number if it has already been added\\n        to the permutation.*/\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(permutation.contains(nums[i])){  //skip if already added\\n                continue;\\n            }\\n            permutation.add(nums[i]);\\n            generatePermutations(permutation, nums);\\n            permutation.remove(permutation.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776226,
                "title": "golang-javascript-solution",
                "content": "# GOLANG\\n> Runtime: 0 ms, faster than 100.00% of Go online submissions for Permutations.\\nMemory Usage: 2.7 MB, less than 60.71% of Go online submissions for Permutations.\\n```GOLANG\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\thelper(nums, []int{}, &res)\\n\\treturn res\\n}\\n\\nfunc helper(source []int, ans []int, ansList *[][]int) {\\n\\tif len(source) == 0 {\\n\\t\\t*ansList = append(*ansList, ans)\\n\\t\\treturn\\n\\t}\\n\\tfor i, e := range source {\\n\\t\\tnewSource := append(append([]int{}, source[:i]...), source[i+1:]...)\\n\\t\\thelper(newSource, append(ans, e), ansList)\\n\\t}\\n}\\n```\\n\\n# JAVASCRIPT\\n> Runtime: 144 ms, faster than 9.43% of JavaScript online submissions for Permutations.\\nMemory Usage: 39.5 MB, less than 67.24% of JavaScript online submissions for Permutations.\\n\\n```JS\\nvar permute = function(nums) {\\n    let res = []\\n    function help(arr2){\\n        if (arr2.length==nums.length)\\n            return res.push(arr2)\\n        for(let e of nums)\\n            if (!arr2.includes(e))\\n                help([...arr2, e])\\n    }\\n    help([])\\n    return res\\n};\\n```",
                "solutionTags": [],
                "code": "```GOLANG\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\thelper(nums, []int{}, &res)\\n\\treturn res\\n}\\n\\nfunc helper(source []int, ans []int, ansList *[][]int) {\\n\\tif len(source) == 0 {\\n\\t\\t*ansList = append(*ansList, ans)\\n\\t\\treturn\\n\\t}\\n\\tfor i, e := range source {\\n\\t\\tnewSource := append(append([]int{}, source[:i]...), source[i+1:]...)\\n\\t\\thelper(newSource, append(ans, e), ansList)\\n\\t}\\n}\\n```\n```JS\\nvar permute = function(nums) {\\n    let res = []\\n    function help(arr2){\\n        if (arr2.length==nums.length)\\n            return res.push(arr2)\\n        for(let e of nums)\\n            if (!arr2.includes(e))\\n                help([...arr2, e])\\n    }\\n    help([])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751309,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def backtrack(self, nums, vis = set(), r = []):\\n        if len(r) == len(nums):\\n            self.res.append([*r])\\n            return\\n        \\n        for n in nums:\\n            if n not in vis:\\n                # Place\\n                vis.add(n)\\n                r.append(n)\\n                # Explore\\n                self.backtrack(nums, vis, r)\\n                # Backtrack\\n                vis.remove(n)\\n                r.pop()\\n                \\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.res = []\\n        self.backtrack(nums)\\n        return self.res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def backtrack(self, nums, vis = set(), r = []):\\n        if len(r) == len(nums):\\n            self.res.append([*r])\\n            return\\n        \\n        for n in nums:\\n            if n not in vis:\\n                # Place\\n                vis.add(n)\\n                r.append(n)\\n                # Explore\\n                self.backtrack(nums, vis, r)\\n                # Backtrack\\n                vis.remove(n)\\n                r.pop()\\n                \\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.res = []\\n        self.backtrack(nums)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558360,
                "title": "general-iterative-approach-with-queue-in-swift",
                "content": "**General Approach**\\nI prefer solving backtracking problems iteratively with a simple queue. The general approach I take:\\n1. Add element to queue\\n2. Loop over input\\n3. Loop over current queue size\\n4. Remove first element from queue\\n5. Use the removed element\\n\\n**Permutations**\\nhttps://leetcode.com/problems/permutations/\\n\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\\n\\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Permutations II**\\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\\n\\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Subset**\\nhttps://leetcode.com/problems/subsets/\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\\n\\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\\n\\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Letter Combinations of a Phone Number**\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\\n\\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking",
                    "Queue"
                ],
                "code": "```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485894,
                "title": "c-no-recursion-8-lines-stl-no-explanation-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> ourResult;\\n        vector<int> singleIter = nums;\\n\\t\\tourResult.push_back(singleIter);\\n        next_permutation(singleIter.begin(), singleIter.end());\\n        while (singleIter != nums)\\n        {\\n            ourResult.push_back(singleIter);\\n            next_permutation(singleIter.begin(), singleIter.end());\\n        }\\n        return ourResult;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> ourResult;\\n        vector<int> singleIter = nums;\\n\\t\\tourResult.push_back(singleIter);\\n        next_permutation(singleIter.begin(), singleIter.end());\\n        while (singleIter != nums)\\n        {\\n            ourResult.push_back(singleIter);\\n            next_permutation(singleIter.begin(), singleIter.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 428429,
                "title": "simple-and-easy-c-backtracking-solution-98-fast",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    \\n    void permute(vector<int> nums, int i, vector<vector<int>> &ans) {\\n        if(i == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j = i; j < nums.size(); j++) {\\n            swap(nums[i],nums[j]);\\n            permute(nums,i+1,ans);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permute(nums,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    void permute(vector<int> nums, int i, vector<vector<int>> &ans) {\\n        if(i == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j = i; j < nums.size(); j++) {\\n            swap(nums[i],nums[j]);\\n            permute(nums,i+1,ans);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permute(nums,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309478,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 291565,
                "title": "easiest-golang-solution-99-4ms",
                "content": "```\\nfunc permute(nums []int) [][]int {\\n    answer := make([][]int, 0)\\n    aux(&answer, 0, nums)\\n\\treturn answer\\n}\\n\\nfunc aux(answer *[][]int, idx int, nums []int) {\\n    if idx == len(nums) {\\n        c := make([]int, len(nums))\\n        copy(c, nums)\\n        *answer = append(*answer, c)\\n        return\\n    }\\n    for i := idx; i < len(nums); i++ {\\n        nums[idx], nums[i] = nums[i], nums[idx]\\n        aux(answer, idx + 1, nums)\\n        nums[i], nums[idx] = nums[idx], nums[i]\\n    }\\n    return\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc permute(nums []int) [][]int {\\n    answer := make([][]int, 0)\\n    aux(&answer, 0, nums)\\n\\treturn answer\\n}\\n\\nfunc aux(answer *[][]int, idx int, nums []int) {\\n    if idx == len(nums) {\\n        c := make([]int, len(nums))\\n        copy(c, nums)\\n        *answer = append(*answer, c)\\n        return\\n    }\\n    for i := idx; i < len(nums); i++ {\\n        nums[idx], nums[i] = nums[i], nums[idx]\\n        aux(answer, idx + 1, nums)\\n        nums[i], nums[idx] = nums[idx], nums[i]\\n    }\\n    return\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176521,
                "title": "clear-python-beats-99",
                "content": "```\\nclass Solution:\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        n = len(nums)\\n        if n < 1: return [[]]\\n        \\n        def DFS(nums, level, current, res):\\n            if level == n: res.append(current)\\n            else:\\n                for num in nums:\\n                    if num not in current: # I wonder if this will be even faster with a set\\n                        DFS(nums, level+1, current + [num], res)\\n        \\n        res = []\\n        DFS(nums,0,[],res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        n = len(nums)\\n        if n < 1: return [[]]\\n        \\n        def DFS(nums, level, current, res):\\n            if level == n: res.append(current)\\n            else:\\n                for num in nums:\\n                    if num not in current: # I wonder if this will be even faster with a set\\n                        DFS(nums, level+1, current + [num], res)\\n        \\n        res = []\\n        DFS(nums,0,[],res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160656,
                "title": "cpp-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> orig = nums;\\n        vector<vector<int> > result;\\n        do{\\n            result.push_back(nums);\\n            next_permutation(nums.begin(),nums.end());\\n        }while(orig!=nums);\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nOnce youre done with this problem do check out\\n\\nhttps://leetcode.com/problems/palindrome-permutation-ii/description/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> orig = nums;\\n        vector<vector<int> > result;\\n        do{\\n            result.push_back(nums);\\n            next_permutation(nums.begin(),nums.end());\\n        }while(orig!=nums);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153304,
                "title": "ruby-recursive-solution-with-comments",
                "content": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer[][]}\\ndef permute(nums)\\n  res = []\\n  add_number(res, nums, [])\\n  res\\nend\\n\\ndef add_number(res, nums, curr)\\n  # set numbers left based on current\\n  left = nums - curr\\n  \\n  # stop when there is nothing left to add\\n  if left.empty?\\n    res << curr\\n  end\\n  \\n  # for each number left\\n  left.each do |l|\\n    # add number to current solution\\n    add_number(res, nums, curr + [l])\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer[][]}\\ndef permute(nums)\\n  res = []\\n  add_number(res, nums, [])\\n  res\\nend\\n\\ndef add_number(res, nums, curr)\\n  # set numbers left based on current\\n  left = nums - curr\\n  \\n  # stop when there is nothing left to add\\n  if left.empty?\\n    res << curr\\n  end\\n  \\n  # for each number left\\n  left.each do |l|\\n    # add number to current solution\\n    add_number(res, nums, curr + [l])\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18236,
                "title": "c-easy-understand-solution-recursion",
                "content": "```\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            vector<int> temp;    \\n            help(ans, temp, nums, i);\\n        }\\n        return ans;\\n    }\\n    void help(vector<vector<int>>& ans, vector<int> cur, vector<int> nums, int cur_idx){\\n        cur.push_back(nums[cur_idx]);\\n        nums.erase(nums.begin() + cur_idx);\\n        if(nums.empty()){\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++)\\n            help(ans, cur, nums, i);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            vector<int> temp;    \\n            help(ans, temp, nums, i);\\n        }\\n        return ans;\\n    }\\n    void help(vector<vector<int>>& ans, vector<int> cur, vector<int> nums, int cur_idx){\\n        cur.push_back(nums[cur_idx]);\\n        nums.erase(nums.begin() + cur_idx);\\n        if(nums.empty()){\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++)\\n            help(ans, cur, nums, i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18328,
                "title": "backtracking-python",
                "content": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        answer = []\\n        rec = [0 for i in xrange(len(nums))]\\n        def dfs(ans):\\n            if len(ans) == len(nums):\\n                answer.append(ans[:])\\n                return\\n            for i in xrange(len(nums)):\\n                if rec[i] != 1:\\n                    rec[i] = 1\\n                    dfs(ans + [nums[i]])\\n                    rec[i] = 0\\n        dfs([])\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        answer = []\\n        rec = [0 for i in xrange(len(nums))]\\n        def dfs(ans):\\n            if len(ans) == len(nums):\\n                answer.append(ans[:])\\n                return\\n            for i in xrange(len(nums)):\\n                if rec[i] != 1:\\n                    rec[i] = 1\\n                    dfs(ans + [nums[i]])\\n                    rec[i] = 0\\n        dfs([])\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18428,
                "title": "my-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> permute(vector<int>& nums) {\\n            vector<vector<int>> res;\\n            create(nums,res,0);\\n            return res;\\n        }\\n        \\n        void create(vector<int>& nums,vector<vector<int>> &res,int n)\\n        {\\n            if(n==nums.size()-1)\\n                res.push_back(nums);\\n            else\\n            {\\n                for(int i=n;i<nums.size();i++)\\n                {\\n                    swap(nums[i],nums[n]);\\n                    create(nums,res,n+1);\\n                    swap(nums[i],nums[n]);\\n                }\\n            }\\n        }\\n        \\n        void swap(int &a,int &b)\\n        {\\n            int tmp=a;\\n            a=b;\\n            b=tmp;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> permute(vector<int>& nums) {\\n            vector<vector<int>> res;\\n            create(nums,res,0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18494,
                "title": "my-iterative-solution-in-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        \\n        if(n == 0)\\n            return res;\\n\\n        stack <vector<int>> perm;\\n        perm.push(nums);\\n        \\n        for(int fix_pos = 0;fix_pos < n - 1;fix_pos++)  \\n        /*For fix_pos => 0 -> n times, 1-> n-1 times ..... n -1-> 2times */\\n        {\\n            stack <vector<int>> temp;\\n            vector<int> vec;\\n            while(!perm.empty())\\n            {\\n                vec = perm.top();\\n                perm.pop();\\n                for(int i = fix_pos;i < n;i++) /* swap around this fix_pos and generate new perms */\\n                {\\n                    std::swap(vec[i],vec[fix_pos]);\\n                    temp.push(vec);\\n                    std::swap(vec[i],vec[fix_pos]); /*swap back to retain original vec */\\n                }\\n            }\\n            std::swap(perm,temp); /* swap stack as we want result in perm */\\n        }\\n        \\n        while(!perm.empty())\\n        {\\n            res.push_back(perm.top());\\n            perm.pop();\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        \\n        if(n == 0)\\n            return res;\\n\\n        stack <vector<int>> perm;\\n        perm.push(nums);\\n        \\n        for(int fix_pos = 0;fix_pos < n - 1;fix_pos++)  \\n        /*For fix_pos => 0 -> n times, 1-> n-1 times ..... n -1-> 2times */\\n        {\\n            stack <vector<int>> temp;\\n            vector<int> vec;\\n            while(!perm.empty())\\n            {\\n                vec = perm.top();\\n                perm.pop();\\n                for(int i = fix_pos;i < n;i++) /* swap around this fix_pos and generate new perms */\\n                {\\n                    std::swap(vec[i],vec[fix_pos]);\\n                    temp.push(vec);\\n                    std::swap(vec[i],vec[fix_pos]); /*swap back to retain original vec */\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18521,
                "title": "iterative-c-11-solution",
                "content": "The move semantic is sometimes helpful.\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> v(1,vector<int>());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            vector<vector<int>> tv(move(v));\\n            for (int j = 0; j < tv.size(); ++j) {\\n                for (int k = 0; k <= tv[0].size(); ++k) {\\n                    vector<int> tmp(tv[j]);\\n                    tmp.insert(tmp.begin()+k,nums[i]);\\n                    v.push_back(move(tmp));\\n                }\\n            }\\n        }\\n        return v;\\n    }",
                "solutionTags": [],
                "code": "The move semantic is sometimes helpful.\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> v(1,vector<int>());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            vector<vector<int>> tv(move(v));\\n            for (int j = 0; j < tv.size(); ++j) {\\n                for (int k = 0; k <= tv[0].size(); ++k) {\\n                    vector<int> tmp(tv[j]);\\n                    tmp.insert(tmp.begin()+k,nums[i]);\\n                    v.push_back(move(tmp));\\n                }\\n            }\\n        }\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4072449,
                "title": "c-beats-100-recursion-explained",
                "content": "# *PLEASE UPVOTE IF IT HELPED*\\n\\n# Approach\\n***(Also explained in the code)***\\n1. The `permute` function takes a vector of integers `nums` and returns a vector of vectors containing all possible permutations of `nums`.\\n\\n1. We use a recursive function `solve` to generate permutations. It takes the current state of `nums`, the result vector `ans`, and the current index as parameters.\\n\\n1. In the `solve` function, we start with a base case: If we have processed all elements (i.e., **index >= nums.size()**), we add the current permutation to the result vector `ans`.\\n\\n1. In the recursive part, we iterate through the remaining elements (starting from `index`) and swap the current element with each of them. This generates different permutations.\\n\\n1. After swapping, we recursively call `solve` with the updated `nums` and `index + 1` to generate permutations for the remaining elements.\\n\\n1. Finally, we backtrack by swapping back to the original state to explore other possibilities.\\n\\n\\n***(\\'a\\', \\'b\\', and \\'c\\' here represents numbers.)***\\n\\n\\n![Screenshot 2023-09-21 175006.png](https://assets.leetcode.com/users/images/7eda35cc-7e3c-4239-adb1-82b9774c2cf6_1695304514.7908428.png)\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n$$O(n)$$\\n\\n\\n- **Space complexity:**\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // Recursive function to generate permutations\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index) {\\n        // Base case: If we have processed all elements, add the permutation to the result\\n        if (index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        // Recursion: Try all possible swaps for the current index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Swap the elements at index and i\\n            swap(nums[index], nums[i]);\\n            // Recursively generate permutations for the remaining elements\\n            solve(nums, ans, index + 1);\\n            // Backtrack by swapping back to the original state\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, ans, index); // Start generating permutations from index 0\\n        return ans;\\n    }\\n};\\n\\n```\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Recursive function to generate permutations\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index) {\\n        // Base case: If we have processed all elements, add the permutation to the result\\n        if (index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        // Recursion: Try all possible swaps for the current index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Swap the elements at index and i\\n            swap(nums[index], nums[i]);\\n            // Recursively generate permutations for the remaining elements\\n            solve(nums, ans, index + 1);\\n            // Backtrack by swapping back to the original state\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, ans, index); // Start generating permutations from index 0\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957700,
                "title": "best-solution",
                "content": "# Approach\\nBacktracking\\n\\n# Complexity\\n- Time complexity:\\n$$O(n!*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void permutations(int idx, vector<int>& nums, vector<vector<int>>& ans) {\\n        if (idx == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            swap(nums[idx], nums[i]);\\n            permutations(idx+1, nums, ans);\\n            swap(nums[idx], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void permutations(int idx, vector<int>& nums, vector<vector<int>>& ans) {\\n        if (idx == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            swap(nums[idx], nums[i]);\\n            permutations(idx+1, nums, ans);\\n            swap(nums[idx], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874190,
                "title": "simple-1-liner-by-using-builtin-function-and-with-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(permutations(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(permutations(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711565,
                "title": "c-easy-recursion-solution-for-beginers",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe will swap the current element and next element.for example take [1,2,3] we can choose any element so choose 1 and swap it with 1 and swap it with 2 so the array becomes [1,2,3] and [2,1,3] resepctively. continue with other elements\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n!*n)\\nn!-->for generating  permutations\\nn--->for inserting the permutation to answer\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)-->no extra space is used\\nauxilary space-O(n)(depth of the recursion)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<int>& n,vector<vector<int>>& ans)\\n    {\\n        if(i==n.size())\\n        {\\n            ans.push_back(n);\\n            return;\\n        }\\n        for(int j=i;j<n.size();j++)\\n        {\\n            \\n            swap(n[i],n[j]);\\n            solve(i+1,n,ans);\\n            swap(n[i],n[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& n) {\\n        vector<vector<int>> ans;\\n         solve(0,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<int>& n,vector<vector<int>>& ans)\\n    {\\n        if(i==n.size())\\n        {\\n            ans.push_back(n);\\n            return;\\n        }\\n        for(int j=i;j<n.size();j++)\\n        {\\n            \\n            swap(n[i],n[j]);\\n            solve(i+1,n,ans);\\n            swap(n[i],n[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& n) {\\n        vector<vector<int>> ans;\\n         solve(0,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328876,
                "title": "set-recursion-backtracking",
                "content": "we make a initial call and iterate over whole list , if element we are picking is not in set then \\nwe add to our perm list and add it in set and  recursively call again and once we reach the base case where len(arr) == len(permGenerated) then we add perm to res list and now call goes back to the for loop , and upon the return we remove the element we had added to perm and also remove it from the set.\\nGo Through Code and let me know if you need a decisive tree for it .\\n```\\nclass Solution:\\n    def permute(self, arr: List[int]) -> List[List[int]]:\\n        \\n        ans  = []\\n        def bt(res,check) :\\n            if len(res) == len(arr) :\\n                ans.append(res[:])\\n                return\\n            \\n            for i in arr :\\n                if i not in check :\\n                    check.add(i)\\n                    res.append(i)\\n                    bt(res,check)\\n                    res.remove(i)\\n                    check.remove(i)\\n        bt([],set())\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "we make a initial call and iterate over whole list , if element we are picking is not in set then \\nwe add to our perm list and add it in set and  recursively call again and once we reach the base case where len(arr) == len(permGenerated) then we add perm to res list and now call goes back to the for loop , and upon the return we remove the element we had added to perm and also remove it from the set.\\nGo Through Code and let me know if you need a decisive tree for it .\\n```\\nclass Solution:\\n    def permute(self, arr: List[int]) -> List[List[int]]:\\n        \\n        ans  = []\\n        def bt(res,check) :\\n            if len(res) == len(arr) :\\n                ans.append(res[:])\\n                return\\n            \\n            for i in arr :\\n                if i not in check :\\n                    check.add(i)\\n                    res.append(i)\\n                    bt(res,check)\\n                    res.remove(i)\\n                    check.remove(i)\\n        bt([],set())\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3059260,
                "title": "recursion-c-easy-approach",
                "content": "\\n```\\nclass Solution {\\n    int n;\\n     vector<vector<int>> ans;\\n     void solve(vector<int> nums, vector<int> v){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(int i=0; i<nums.size(); i++){\\n             int x=nums[i];\\n             v.push_back(x);\\n             nums.erase(nums.begin()+i);\\n             solve(nums,v);\\n             v.pop_back();\\n            nums.insert(nums.begin()+i, x);\\n         }\\n     }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> v; n=nums.size();\\n        solve(nums,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n     vector<vector<int>> ans;\\n     void solve(vector<int> nums, vector<int> v){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(int i=0; i<nums.size(); i++){\\n             int x=nums[i];\\n             v.push_back(x);\\n             nums.erase(nums.begin()+i);\\n             solve(nums,v);\\n             v.pop_back();\\n            nums.insert(nums.begin()+i, x);\\n         }\\n     }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> v; n=nums.size();\\n        solve(nums,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053533,
                "title": "c-backtracking-explained-with-comments",
                "content": "# Intuition\\nSince we need to find all the possible permutations, backtracking is needed.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid print(int i, vector<int> &nums, vector<vector<int>> &ans){\\n    if(i==nums.size()){\\n        ans.push_back(nums);//one permutation instance\\n        return;\\n    }\\n    for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);//modifying nums\\n        print(i+1,nums,ans);recursively calling the print function\\n        swap(nums[i],nums[j]);//backtracking step\\n    }\\n}\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        print(0,nums,ans);\\n        return  ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid print(int i, vector<int> &nums, vector<vector<int>> &ans){\\n    if(i==nums.size()){\\n        ans.push_back(nums);//one permutation instance\\n        return;\\n    }\\n    for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);//modifying nums\\n        print(i+1,nums,ans);recursively calling the print function\\n        swap(nums[i],nums[j]);//backtracking step\\n    }\\n}\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        print(0,nums,ans);\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025444,
                "title": "python3-1-line-code-using-function-for-fun",
                "content": "- # Code\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:        \\n        return permutations(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:        \\n        return permutations(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689366,
                "title": "c-recursion-100-faster",
                "content": "```\\nvoid solve(vector<int>& nums,vector<vector<int>>&v,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            v.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            swap(nums[i],nums[j]);\\n            solve(nums,v,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n          \\n    }\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>>v;\\n        int i=0;\\n        solve(nums,v,i);\\n        return v;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nvoid solve(vector<int>& nums,vector<vector<int>>&v,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            v.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            swap(nums[i],nums[j]);\\n            solve(nums,v,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n          \\n    }\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>>v;\\n        int i=0;\\n        solve(nums,v,i);\\n        return v;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2428738,
                "title": "js-clear-explanation-faster-than-99-90",
                "content": "**How to solve this problem?**\\n\\nSo, according to LeetCode, this problem is supposed to be solved with recursion/backtracking. If the problem is solved with recursion, then we have to figure out what is the base case for recursive calls and what is the recursive case. In order for the algorithm to work, we need our recursive case to get to the base case eventually by decreasing the problem size. \\n\\n**Solution explained**\\n\\nIn this problem all we have is a `nums` array, so probably we need to shrink the array size, until we hit the base case, and then work our way up, while keeping in mind the fact that we shrinked the array size, we do not want to lose any data. This is where the backtracking part fits in. \\n\\nNow, the base case is probably an array of size 1. Permutations of the `[3]` array is just `[[3]]`. How do we reduce our initial problem to the base case? We could simply go through each element of the array, removing the first element of the array. If we do that, the recursive case should work it\\'s way to the base case. Then we need to handle the results returned by the base case in the recursive case and return the new result.\\n\\nFor example, let us take the array of size 2: `nums = [1, 2]`. If we remove the first element, we get just `[2]`, this is our base case. In order to complete the permutations array, we should add the missing `1` to the permutations returned by the base case, which will get us `[[2, 1]]`. Then we add the missing `1` back to the `nums` array, we get `nums = [2, 1]`. We remove `2`, since this is our first element now and get just `[1]`. This is, again, the base case. Then we add the `2` to the end and get `[1, 2]`. We add up the results to make `result = [[2, 1], [1, 2]]` and we can return this value. If it works for the array of size 2, it should work for an array of any size.\\n\\nHere is the resulting code:\\n```js\\nvar permute = function(nums) {\\n    const result = [];\\n\\t// - Base case\\n    if(nums.length === 1) {\\n\\t    // If there\\'s just 1 element, we simply return a copy\\n\\t\\t// of that array\\n        return [[...nums]];\\n    }\\n\\t// - Recursive case\\n\\t// We move through each number in `nums`\\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\t// Remove the first element of `nums`\\n        const n = nums.shift();\\n\\t\\t// Now we have reduced the `nums` size to \\n\\t\\t// `nums.length - 1`, this will get us to the\\n\\t\\t// base case eventually\\n        const perms = permute(nums);\\n\\t\\t// Traverse through each of the permutations\\n\\t\\t// returned by a recursive call\\n        for(let perm of perms) {\\n\\t\\t    // We add the number that we shifted earlier\\n\\t\\t\\t// to reduce the problem size to the back of\\n\\t\\t\\t// the permutation array\\n            perm.push(n);\\n\\t\\t\\t// We add this permutation to the result array\\n            result.push(perm);\\n        }\\n\\t\\t// Finally, we add the number we shifted back\\n\\t\\t// to the array\\n        nums.push(n);\\n    }\\n\\t// Return the result\\n    return result;\\n};\\n```\\n\\n**Further runtime improvement**\\n\\nWhat if we make our base case an array of size 2? Figuring out what the permutations of a 2-sized array is pretty straightforward. For example, permutations of `[1, 2]` are `[[1, 2], [2, 1]]`. So if we change our base case to an array of size 2, we could get rid of a few extra recursive calls, and save some time.\\n\\n```js\\n\\t// - Base case\\n    if(nums.length === 2) {\\n        return [[nums[0], nums[1]], [nums[1], nums[0]]];\\n    }\\n```\\n\\nThis should get your solution to the top 99.90% of JS solutions.",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```js\\nvar permute = function(nums) {\\n    const result = [];\\n\\t// - Base case\\n    if(nums.length === 1) {\\n\\t    // If there\\'s just 1 element, we simply return a copy\\n\\t\\t// of that array\\n        return [[...nums]];\\n    }\\n\\t// - Recursive case\\n\\t// We move through each number in `nums`\\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\t// Remove the first element of `nums`\\n        const n = nums.shift();\\n\\t\\t// Now we have reduced the `nums` size to \\n\\t\\t// `nums.length - 1`, this will get us to the\\n\\t\\t// base case eventually\\n        const perms = permute(nums);\\n\\t\\t// Traverse through each of the permutations\\n\\t\\t// returned by a recursive call\\n        for(let perm of perms) {\\n\\t\\t    // We add the number that we shifted earlier\\n\\t\\t\\t// to reduce the problem size to the back of\\n\\t\\t\\t// the permutation array\\n            perm.push(n);\\n\\t\\t\\t// We add this permutation to the result array\\n            result.push(perm);\\n        }\\n\\t\\t// Finally, we add the number we shifted back\\n\\t\\t// to the array\\n        nums.push(n);\\n    }\\n\\t// Return the result\\n    return result;\\n};\\n```\n```js\\n\\t// - Base case\\n    if(nums.length === 2) {\\n        return [[nums[0], nums[1]], [nums[1], nums[0]]];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278089,
                "title": "c-easy-simple-solution-permutations",
                "content": "class Solution {\\npublic:\\nvector<vector<int>> ans;\\nvoid permutation(vector<int>&a, int ind, int n)\\n{\\n    if(ind==n)\\n    {\\n        ans.push_back(a);\\n        return;\\n    }\\n    for(int i=ind;i<n;i++)\\n    {\\n        swap(a[ind],a[i]);\\n        permutation(a,ind+1,n);\\n        swap(a[ind],a[i]);\\n    }\\n}\\nvector<vector<int>> permute(vector<int>& nums) {\\n    permutation(nums,0,nums.size());\\n    return ans;\\n}\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\nvector<vector<int>> ans;\\nvoid permutation(vector<int>&a, int ind, int n)\\n{\\n    if(ind==n)\\n    {\\n        ans.push_back(a);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2133771,
                "title": "simple-recursive-solution-c",
                "content": "```\\n//recursive solution \\n    void perm(int pos,vector<int>& v,vector<vector<int>>& ans)\\n    {\\n        if(pos>=v.size())\\n        {\\n            ans.push_back(v);\\n        }\\n        for(int i=pos;i<v.size();i++)\\n        {\\n            swap(v[i],v[pos]); //first swap to get the ith element on desired position\\n            perm(pos+1,v,ans); // recursive call for remaining elements\\n            swap(v[i],v[pos]); //back tracking or cleaning\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        perm(0,nums,ans);\\n        return ans;\\n    }\\n\\t```\\n**\\tIF YOU FIND IT HELPFUL PLEASE UPVOTE IT**\\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//recursive solution \\n    void perm(int pos,vector<int>& v,vector<vector<int>>& ans)\\n    {\\n        if(pos>=v.size())\\n        {\\n            ans.push_back(v);\\n        }\\n        for(int i=pos;i<v.size();i++)\\n        {\\n            swap(v[i],v[pos]); //first swap to get the ith element on desired position\\n            perm(pos+1,v,ans); // recursive call for remaining elements\\n            swap(v[i],v[pos]); //back tracking or cleaning\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        perm(0,nums,ans);\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703219,
                "title": "c-easy-to-understand-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/12d39195-f555-42ab-b69c-23ae3a954661_1642698221.311954.jpeg)\\n\\n\\n```\\nvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n        if(i==nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);\\n        helper(res,nums,i+1);\\n        swap(nums[i],nums[j]);\\n    }\\n        return;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res,nums,0);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n        if(i==nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);\\n        helper(res,nums,i+1);\\n        swap(nums[i],nums[j]);\\n    }\\n        return;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res,nums,0);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1684545,
                "title": "permutations-java-backtracking-inline-explanation",
                "content": "### bactracking Approach\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list; \\n        \\n    }\\n    \\n    public void backtrack(List<List<Integer>> list, List<Integer> temp, int [] nums){\\n        if (temp.size()==nums.length){\\n            list.add(new ArrayList(temp));//if the the temp list equals nums length then add to resultant list\\n            }else{\\n            for(int i=0;i<nums.length;i++){\\n                if(temp.contains(nums[i]))\\n                    continue;\\n                temp.add(nums[i]);//Add the current traversing element from nums\\n                backtrack(list, temp, nums);//Backtrack to its previous node by calling backtrack function recursively\\n                temp.remove(temp.size()-1);//remove the last element of the temp to find another way from the prev node which we got ofter backtracking \\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list; \\n        \\n    }\\n    \\n    public void backtrack(List<List<Integer>> list, List<Integer> temp, int [] nums){\\n        if (temp.size()==nums.length){\\n            list.add(new ArrayList(temp));//if the the temp list equals nums length then add to resultant list\\n            }else{\\n            for(int i=0;i<nums.length;i++){\\n                if(temp.contains(nums[i]))\\n                    continue;\\n                temp.add(nums[i]);//Add the current traversing element from nums\\n                backtrack(list, temp, nums);//Backtrack to its previous node by calling backtrack function recursively\\n                temp.remove(temp.size()-1);//remove the last element of the temp to find another way from the prev node which we got ofter backtracking \\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661636,
                "title": "how-to-approach-the-problem-both-recursive-and-iterative-way",
                "content": "\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        This can be solved using iterative way too\\n        we need queue for this\\n        Idea is to push empty list into queue\\n        then we will graze over each no in array\\n            for each no we will graze over all lists into queue\\n                for each list we will graze over each idx including last\\n                    if it make upto the length of nums\\n                        then add to ans\\n                    else\\n                        add to queue\\n        for eg.[1,2,3]\\n                                    [ ]\\n                                     | for 1\\n                                    [1]\\n                                /          \\\\ for 2\\n                            [2,1]           [1,2]\\n                        /   |   \\\\          /    |   \\\\ for 3\\n                      321   231 213       312   132  123  now add it to answer\\n        tc = O(n * n!)\\n        sc = O(n!) for queue\\n                                     \\n        \"\"\"\\n        q = deque()\\n        q.append([])\\n        n = len(nums)\\n        ans = []\\n        for currIdx in range(n):\\n            currEle = nums[currIdx]\\n            queueLen = len(q)\\n            for currListIdx in range(queueLen):\\n                innerPermute = q.popleft()\\n                for idxInCurrList in range(len(innerPermute) + 1):\\n                    newPermute = innerPermute.copy()\\n                    newPermute.insert(idxInCurrList,currEle)\\n                    if len(newPermute) == n:\\n                        ans.append(newPermute)\\n                    else:\\n                        q.append(newPermute)\\n        return ans\\n    \\n    def recursive(self,nums):\\n        \"\"\"\\n        we can do it recursively\\n        Idea is to graze over numbers array\\n        means for each curr idx\\n            graze over curr path for each position\\n                insert ele at curr idx in curr path\\n                and recur\\n        for eg. [1,2,3]\\n                                    [ ]\\n                                     |\\n                                    [1]\\n                            /                       \\\\\\n                         [2,1]                      [1,2]\\n                    /      |    \\\\          /           |       \\\\\\n              [3,2,1]   [2,3,1] [2,1,3]   [3,1,2]   [1,3,2]    [1,2,3]\\n              \\n        base case is if curr idx is reached end\\n            then attach curr path copy to answer\\n            \\n        tc = O(n * n!) for any n length array or string there are n! permutations\\n        sc = O(n!) to store all recursive calls of permutation\\n        \"\"\"\\n        def backtrack(nums,currIdx,n,ans,currPath):\\n            if currIdx == n:\\n                ans.append(currPath)\\n                return\\n            for i in range(len(currPath) + 1):\\n                newList = currPath.copy()\\n                newList.insert(i,nums[currIdx])\\n                backtrack(nums,currIdx + 1,n,ans,newList)\\n                \\n        currPath = []\\n        ans = []\\n        n = len(nums)\\n        backtrack(nums,0,n,ans,currPath)\\n        return ans\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Stack",
                    "Queue"
                ],
                "code": "\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        This can be solved using iterative way too\\n        we need queue for this\\n        Idea is to push empty list into queue\\n        then we will graze over each no in array\\n            for each no we will graze over all lists into queue\\n                for each list we will graze over each idx including last\\n                    if it make upto the length of nums\\n                        then add to ans\\n                    else\\n                        add to queue\\n        for eg.[1,2,3]\\n                                    [ ]\\n                                     | for 1\\n                                    [1]\\n                                /          \\\\ for 2\\n                            [2,1]           [1,2]\\n                        /   |   \\\\          /    |   \\\\ for 3\\n                      321   231 213       312   132  123  now add it to answer\\n        tc = O(n * n!)\\n        sc = O(n!) for queue\\n                                     \\n        \"\"\"\\n        q = deque()\\n        q.append([])\\n        n = len(nums)\\n        ans = []\\n        for currIdx in range(n):\\n            currEle = nums[currIdx]\\n            queueLen = len(q)\\n            for currListIdx in range(queueLen):\\n                innerPermute = q.popleft()\\n                for idxInCurrList in range(len(innerPermute) + 1):\\n                    newPermute = innerPermute.copy()\\n                    newPermute.insert(idxInCurrList,currEle)\\n                    if len(newPermute) == n:\\n                        ans.append(newPermute)\\n                    else:\\n                        q.append(newPermute)\\n        return ans\\n    \\n    def recursive(self,nums):\\n        \"\"\"\\n        we can do it recursively\\n        Idea is to graze over numbers array\\n        means for each curr idx\\n            graze over curr path for each position\\n                insert ele at curr idx in curr path\\n                and recur\\n        for eg. [1,2,3]\\n                                    [ ]\\n                                     |\\n                                    [1]\\n                            /                       \\\\\\n                         [2,1]                      [1,2]\\n                    /      |    \\\\          /           |       \\\\\\n              [3,2,1]   [2,3,1] [2,1,3]   [3,1,2]   [1,3,2]    [1,2,3]\\n              \\n        base case is if curr idx is reached end\\n            then attach curr path copy to answer\\n            \\n        tc = O(n * n!) for any n length array or string there are n! permutations\\n        sc = O(n!) to store all recursive calls of permutation\\n        \"\"\"\\n        def backtrack(nums,currIdx,n,ans,currPath):\\n            if currIdx == n:\\n                ans.append(currPath)\\n                return\\n            for i in range(len(currPath) + 1):\\n                newList = currPath.copy()\\n                newList.insert(i,nums[currIdx])\\n                backtrack(nums,currIdx + 1,n,ans,newList)\\n                \\n        currPath = []\\n        ans = []\\n        n = len(nums)\\n        backtrack(nums,0,n,ans,currPath)\\n        return ans\\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1564385,
                "title": "python-3-recursion-faster-than-99-97",
                "content": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]):\\n        if len(nums) == 1: return [nums]\\n        if len(nums) == 2: return [list(nums), list(nums)[::-1]]\\n        \\n        if type(nums) is not deque: nums = deque(nums)\\n\\n        result = deque()\\n        for _ in range(len(nums)):\\n            num = nums.popleft()  # fix first number\\n\\n            perm_results = self.permute(nums)\\n            for perm in perm_results:\\n                perm.append(num) # add the fixed number to all sub permutations\\n            result += perm_results\\n\\n            nums.append(num) # return the fixed number into the end\\n\\n        return result\\n\\n```\\n![image](https://assets.leetcode.com/users/images/c22bb704-ba60-4baf-8966-c4608a111588_1636278377.334533.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]):\\n        if len(nums) == 1: return [nums]\\n        if len(nums) == 2: return [list(nums), list(nums)[::-1]]\\n        \\n        if type(nums) is not deque: nums = deque(nums)\\n\\n        result = deque()\\n        for _ in range(len(nums)):\\n            num = nums.popleft()  # fix first number\\n\\n            perm_results = self.permute(nums)\\n            for perm in perm_results:\\n                perm.append(num) # add the fixed number to all sub permutations\\n            result += perm_results\\n\\n            nums.append(num) # return the fixed number into the end\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451507,
                "title": "c-0ms-backtracking-solution-with-explanation",
                "content": "The idea is to generate all possible permutations, by repeatedly swapping the first(left-most) element with every other element in the array. Then swapping the second element(hence `leftIdx + 1`) with every element towards its right, and so on. This is achieved via backtracking.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, int leftIdx, int rightIdx){\\n        if(leftIdx == rightIdx){  // all the numbers in the current permutation have been considered\\n            res.push_back(nums);  // hence, push them into result\\n        } else {\\n            for(int i = leftIdx; i<=rightIdx; i++){\\n                swap(nums[i], nums[leftIdx]);    // swap and call it again\\n                backtrack(res, nums, leftIdx + 1, rightIdx);\\n                swap(nums[i], nums[leftIdx]);    // revert the change (backtrack)\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(res, nums, 0, nums.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, int leftIdx, int rightIdx){\\n        if(leftIdx == rightIdx){  // all the numbers in the current permutation have been considered\\n            res.push_back(nums);  // hence, push them into result\\n        } else {\\n            for(int i = leftIdx; i<=rightIdx; i++){\\n                swap(nums[i], nums[leftIdx]);    // swap and call it again\\n                backtrack(res, nums, leftIdx + 1, rightIdx);\\n                swap(nums[i], nums[leftIdx]);    // revert the change (backtrack)\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(res, nums, 0, nums.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421884,
                "title": "js-backtracking-dfs",
                "content": "```\\n\\n//approach: backtracking (DFS)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (nth -1 value), so then you can now start with other value add to that 0th value\\nvar permute = function(nums) {\\n    let resultArray = new Array();\\n    \\n    function helper(nums, permutedValueArr){\\n        \\n        if(nums.length == 0){ \\n            resultArray.push([...permutedValueArr]);  //push the copy of the permuted array \\n            return;\\n        }\\n        \\n        for(let i = 0; i < nums.length; i++){\\n            //choose\\n            permutedValueArr.push(nums[i]); //0th value\\n            \\n            let decreasedNums = nums.filter((n, index) => index != i);\\n            \\n            //explore\\n            helper(decreasedNums, permutedValueArr);   //passing in the new decreased nums array\\n            \\n            //unchoose\\n            permutedValueArr.pop();  //start removing the elements from the last so you can make possible combinations of values with that 0th value \\n        }\\n        \\n    }\\n    \\n    helper(nums, new Array());\\n    \\n    return resultArray;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n//approach: backtracking (DFS)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (nth -1 value), so then you can now start with other value add to that 0th value\\nvar permute = function(nums) {\\n    let resultArray = new Array();\\n    \\n    function helper(nums, permutedValueArr){\\n        \\n        if(nums.length == 0){ \\n            resultArray.push([...permutedValueArr]);  //push the copy of the permuted array \\n            return;\\n        }\\n        \\n        for(let i = 0; i < nums.length; i++){\\n            //choose\\n            permutedValueArr.push(nums[i]); //0th value\\n            \\n            let decreasedNums = nums.filter((n, index) => index != i);\\n            \\n            //explore\\n            helper(decreasedNums, permutedValueArr);   //passing in the new decreased nums array\\n            \\n            //unchoose\\n            permutedValueArr.pop();  //start removing the elements from the last so you can make possible combinations of values with that 0th value \\n        }\\n        \\n    }\\n    \\n    helper(nums, new Array());\\n    \\n    return resultArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378285,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var permute = function(nums) {\\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(temp, nums) {\\n          if(nums.length == 0) {\\n              result.push([...temp])\\n              return\\n           }\\n        \\n          for(let i=0; i<nums.length; i++) {\\n              temp.push(nums[i])\\n              nums.splice(i, 1)\\n              backtracking(temp, nums)\\n              nums.splice(i, 0, temp.pop())\\n           }\\n        }\\n        backtracking(temp, nums)\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "\\n\\n    var permute = function(nums) {\\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(temp, nums) {\\n          if(nums.length == 0) {\\n              result.push([...temp])\\n              return\\n           }\\n        \\n          for(let i=0; i<nums.length; i++) {\\n              temp.push(nums[i])\\n              nums.splice(i, 1)\\n              backtracking(temp, nums)\\n              nums.splice(i, 0, temp.pop())\\n           }\\n        }\\n        backtracking(temp, nums)\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1203474,
                "title": "simplest-java-solution-no-backtracking-simple-iteration-recursion",
                "content": "```\\n    // To create all permutations of integers contained in nums array,\\n    // we realize that for each num, there needs to be a list of integers with this num as the first member in that list.\\n    // Once we have that, we realize that for each remaining num, there needs to be a list of integers that has this num as the next member in that list.\\n    // Once we have that, we realize that for each remaining num, we need to do the same as above.\\n    // The key realization is that we need to have a new copy of the list at each step when we add a num to it.\\n    //\\n    // So, we start with an empty list of integers called sublist, and iterate over the given nums,\\n    // creating a new copy from the sublist and adding the current num to that copy, but only if the current num is not already in the sublist.\\n    // We keep doing this until the size of the sublist becomes equal to the number of given nums,\\n    // which means that one permutation is complete, so we add this sublist to the result.\\n    // When we are done iterating over all the nums, our result will have all the permutations.\\n    // \\n    // You can visualize this with a tree/branching approach, e.g., for nums = [1, 2, 3]\\n    //                                 start with empty sublist\\n    //                                        [ ]\\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //              /                          |                             \\\\  \\n    //            1                            2                              3\\n    //   new copy of sublist           new copy of sublist             new copy of sublist\\n    //   add 1 to this copy            add 2 to this copy              add 3 to this copy\\n    //           [1]                           [2]                             [3]\\n    // \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //    /     |        \\\\              /        |      \\\\                 /      |       \\\\\\n    //   1      2         3            1         2       3              1        2        3\\n    //   x     new copy  new copy     new copy   x     new copy      new copy  new copy   x          \\n    //         add 2     add 3        add 1            add 3         add 1     add 2              \\n    //         [1,2]     [1,3]        [2,1]            [2,3]         [3,1]     [3,2]                  \\n    //                                                                                   \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //         |           |            |               |             |           |              \\n    //         3           2            3               1             2           1                \\n    //       new copy    new copy     new copy        new copy      new copy    new copy                \\n    //       add 3       add 2        add 3           add 1         add 2       add 1                 \\n    //      [1,2,3]     [1,3,2]      [2,1,3]         [2,3,1]       [3,1,2]     [3,2,1]\\n    //\\n    //  if (size of sublist == nums.length), add this sublist to result\\n    // [    [1,2,3]    [1,3,2]       [2,1,3]         [2,3,1]      [3,1,2]      [3,2,1] ] = result\\n    // done\\n    //  \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        // start with an empty sublist\\n        List<Integer> sublist = new ArrayList<Integer>();\\n        helper(nums, result, sublist);\\n        return result;\\n    }\\n    \\n    private void helper(int[]nums, List<List<Integer>> result, List<Integer> sublist) {\\n        // if all nums are in the sublist, add this sublist to the result\\n        if (sublist.size() == nums.length) {\\n            result.add(sublist);\\n\\t\\t\\treturn;\\n        }\\n\\n        // for each num, if that num is not in the sublist, create a new copy of sublist and add the num to it\\n        for (int num : nums) {\\n            if (!sublist.contains(num)) {\\n                List<Integer> copy = new ArrayList<>(sublist);\\n                copy.add(num);\\n                // pass the new copy of sublist for the next recursion\\n                helper(nums, result, copy);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    // To create all permutations of integers contained in nums array,\\n    // we realize that for each num, there needs to be a list of integers with this num as the first member in that list.\\n    // Once we have that, we realize that for each remaining num, there needs to be a list of integers that has this num as the next member in that list.\\n    // Once we have that, we realize that for each remaining num, we need to do the same as above.\\n    // The key realization is that we need to have a new copy of the list at each step when we add a num to it.\\n    //\\n    // So, we start with an empty list of integers called sublist, and iterate over the given nums,\\n    // creating a new copy from the sublist and adding the current num to that copy, but only if the current num is not already in the sublist.\\n    // We keep doing this until the size of the sublist becomes equal to the number of given nums,\\n    // which means that one permutation is complete, so we add this sublist to the result.\\n    // When we are done iterating over all the nums, our result will have all the permutations.\\n    // \\n    // You can visualize this with a tree/branching approach, e.g., for nums = [1, 2, 3]\\n    //                                 start with empty sublist\\n    //                                        [ ]\\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //              /                          |                             \\\\  \\n    //            1                            2                              3\\n    //   new copy of sublist           new copy of sublist             new copy of sublist\\n    //   add 1 to this copy            add 2 to this copy              add 3 to this copy\\n    //           [1]                           [2]                             [3]\\n    // \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //    /     |        \\\\              /        |      \\\\                 /      |       \\\\\\n    //   1      2         3            1         2       3              1        2        3\\n    //   x     new copy  new copy     new copy   x     new copy      new copy  new copy   x          \\n    //         add 2     add 3        add 1            add 3         add 1     add 2              \\n    //         [1,2]     [1,3]        [2,1]            [2,3]         [3,1]     [3,2]                  \\n    //                                                                                   \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //         |           |            |               |             |           |              \\n    //         3           2            3               1             2           1                \\n    //       new copy    new copy     new copy        new copy      new copy    new copy                \\n    //       add 3       add 2        add 3           add 1         add 2       add 1                 \\n    //      [1,2,3]     [1,3,2]      [2,1,3]         [2,3,1]       [3,1,2]     [3,2,1]\\n    //\\n    //  if (size of sublist == nums.length), add this sublist to result\\n    // [    [1,2,3]    [1,3,2]       [2,1,3]         [2,3,1]      [3,1,2]      [3,2,1] ] = result\\n    // done\\n    //  \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        // start with an empty sublist\\n        List<Integer> sublist = new ArrayList<Integer>();\\n        helper(nums, result, sublist);\\n        return result;\\n    }\\n    \\n    private void helper(int[]nums, List<List<Integer>> result, List<Integer> sublist) {\\n        // if all nums are in the sublist, add this sublist to the result\\n        if (sublist.size() == nums.length) {\\n            result.add(sublist);\\n\\t\\t\\treturn;\\n        }\\n\\n        // for each num, if that num is not in the sublist, create a new copy of sublist and add the num to it\\n        for (int num : nums) {\\n            if (!sublist.contains(num)) {\\n                List<Integer> copy = new ArrayList<>(sublist);\\n                copy.add(num);\\n                // pass the new copy of sublist for the next recursion\\n                helper(nums, result, copy);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076700,
                "title": "elegant-kotlin-solution",
                "content": "```\\nfun permute(nums: IntArray): List<List<Int>> {\\n\\tval result = mutableListOf<List<Int>>()\\n\\tbacktrack(result, ArrayList(), nums.toMutableList())\\n\\treturn result\\n}\\n\\nprivate fun backtrack(result: MutableList<List<Int>>, tmpList: List<Int>, nums: MutableList<Int>) {\\n\\tif (nums.isEmpty()) {\\n\\t\\tresult.add(tmpList)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor (i in nums.indices) {\\n\\t\\tval numsNew = ArrayList<Int>(nums).also {\\n\\t\\t\\tit.removeAt(i)\\n\\t\\t}\\n\\n\\t\\tbacktrack(result, tmpList + nums[i], numsNew) // \"+\" creates copy of tmpList with appended nums[i] \\n\\t}\\n}\\n ```",
                "solutionTags": [
                    "Kotlin",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nfun permute(nums: IntArray): List<List<Int>> {\\n\\tval result = mutableListOf<List<Int>>()\\n\\tbacktrack(result, ArrayList(), nums.toMutableList())\\n\\treturn result\\n}\\n\\nprivate fun backtrack(result: MutableList<List<Int>>, tmpList: List<Int>, nums: MutableList<Int>) {\\n\\tif (nums.isEmpty()) {\\n\\t\\tresult.add(tmpList)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor (i in nums.indices) {\\n\\t\\tval numsNew = ArrayList<Int>(nums).also {\\n\\t\\t\\tit.removeAt(i)\\n\\t\\t}\\n\\n\\t\\tbacktrack(result, tmpList + nums[i], numsNew) // \"+\" creates copy of tmpList with appended nums[i] \\n\\t}\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 986577,
                "title": "easiest-to-understand-beats-93-java",
                "content": "Enjoy.\\n\\n```\\nclass Solution {\\n    \\n    // Add permutations for the numbers one by one \\n    // A new number can go between all the numbers in an existing list\\n    // See this\\n    // Existing list [] add 1\\n    // Existing list [[1]] add 2 - see that 2 can go as 0th item and 1th item\\n    // Existing list [[2, 1], [1, 2]] add 3 - see that for each list, 3 can go as 0th, 1th and 2nd item\\n    // Existing list [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] add 4  - ....\\n    \\n    public List<List<Integer>> permute(int[] nums) {   \\n          List<List<Integer>> result = new ArrayList<>();\\n          for(int num : nums) {\\n              result = addNumToLists( result,  num) ;\\n          }\\n          return result;\\n    }\\n    \\n    public List<List<Integer>> addNumToLists(List<List<Integer>> lists, int num) { \\n        List<List<Integer>> result = new ArrayList<>();   \\n        if(lists.isEmpty()) {\\n            List<Integer> newlist = new ArrayList<>();\\n            newlist.add(num);\\n            result.add(newlist);\\n        } else {\\n            for(List<Integer> list : lists) {\\n                int size = list.size();\\n                for(int i = 0 ; i <= size ; i++ ) {\\n                    List<Integer> newList = new ArrayList<>(list);\\n                    newList.add(i,num);\\n                    result.add(newList);\\n                }\\n            } \\n        }        \\n        //Turn on output to see how it works\\n        //System.out.println(result);\\n        return result;    \\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Add permutations for the numbers one by one \\n    // A new number can go between all the numbers in an existing list\\n    // See this\\n    // Existing list [] add 1\\n    // Existing list [[1]] add 2 - see that 2 can go as 0th item and 1th item\\n    // Existing list [[2, 1], [1, 2]] add 3 - see that for each list, 3 can go as 0th, 1th and 2nd item\\n    // Existing list [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] add 4  - ....\\n    \\n    public List<List<Integer>> permute(int[] nums) {   \\n          List<List<Integer>> result = new ArrayList<>();\\n          for(int num : nums) {\\n              result = addNumToLists( result,  num) ;\\n          }\\n          return result;\\n    }\\n    \\n    public List<List<Integer>> addNumToLists(List<List<Integer>> lists, int num) { \\n        List<List<Integer>> result = new ArrayList<>();   \\n        if(lists.isEmpty()) {\\n            List<Integer> newlist = new ArrayList<>();\\n            newlist.add(num);\\n            result.add(newlist);\\n        } else {\\n            for(List<Integer> list : lists) {\\n                int size = list.size();\\n                for(int i = 0 ; i <= size ; i++ ) {\\n                    List<Integer> newList = new ArrayList<>(list);\\n                    newList.add(i,num);\\n                    result.add(newList);\\n                }\\n            } \\n        }        \\n        //Turn on output to see how it works\\n        //System.out.println(result);\\n        return result;    \\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904215,
                "title": "simple-diagram-python-code-beating-97-in-speed-and-100-in-space",
                "content": "The concept is that for **N** elements we pick one by one and swap it with itself and the rest of the element consisting that element and then we move to next element and do the same.\\n![image](https://assets.leetcode.com/users/images/4dbd465d-f79a-43e0-9cba-fe81ab71b1e4_1603277897.2668254.png)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        p=[]\\n        def rec(nums,i):\\n            if i==len(nums)-1:\\n                p.append(nums[:])\\n                return\\n            for j in range(i,len(nums)):\\n                nums[i],nums[j]=nums[j],nums[i] #swap\\n                rec(nums,i+1)\\n                nums[i],nums[j]=nums[j],nums[i]  #reswap so that we get the prev array\\n        rec(nums,0)\\n        return p\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        p=[]\\n        def rec(nums,i):\\n            if i==len(nums)-1:\\n                p.append(nums[:])\\n                return\\n            for j in range(i,len(nums)):\\n                nums[i],nums[j]=nums[j],nums[i] #swap\\n                rec(nums,i+1)\\n                nums[i],nums[j]=nums[j],nums[i]  #reswap so that we get the prev array\\n        rec(nums,0)\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842210,
                "title": "ruby-backtracking",
                "content": "```\\ndef permute(nums)\\n  results = []\\n  backtrack(nums, [], results)\\n  results\\nend\\n\\ndef backtrack(list, temp, results)\\n  if temp.length == list.length\\n    results << temp.dup\\n  end\\n  \\n  list.each do |n|\\n    next if temp.include? n\\n    temp << n\\n    backtrack(list, temp, results)\\n    temp.pop\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\ndef permute(nums)\\n  results = []\\n  backtrack(nums, [], results)\\n  results\\nend\\n\\ndef backtrack(list, temp, results)\\n  if temp.length == list.length\\n    results << temp.dup\\n  end\\n  \\n  list.each do |n|\\n    next if temp.include? n\\n    temp << n\\n    backtrack(list, temp, results)\\n    temp.pop\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 705100,
                "title": "c-simple-recursive-solution-with-explanation",
                "content": "Purmutations recursive function.\\nEach time takes the permutations of the numbers excluding the last one.\\nThen for each permutation takes the last number and pushes it between the numbers in all available positions.\\n\\n```\\n#include <stdlib.h>\\n\\n/*\\nEach time takes the permutations of the numbers excluding the last one.\\nThen for each permutation takes the last number and pushes it between the numbers in all available positions.\\nFor example:\\n\\n    for the permutations of [1, 2, 3] first we get the permutations of [1, 2].\\n        that [[1, 2], [2, 1]]\\n    then for each of them pushes 3 between the numbers in all available positions.\\n        for [1, 2] we get [1, 2, 3], [3, 1, 2], [1, 3, 2].\\n        for [2, 1] we get [2, 1, 3], [3, 2, 1], [2, 3, 1]. \\n        \\n*note - Assumes the table is in the right size.\\n*/\\nint fill_permutations(int nums[], int nums_size, int *permutations_table[])\\n{\\n    int permutations_amount = 0;\\n    int i = 0;\\n    // Holds the line we are currently writing the permutations to.\\n    int line_index = 0;\\n    // The column we are pushing the last number to.\\n    int column_index = 0;\\n    // Used for pushing the last number between the other numbers.\\n    int temp = 0;\\n    \\n    // Exit rule.\\n    if (0 == nums_size)\\n    {\\n        return 0;\\n    }\\n    if (1 == nums_size)\\n    {\\n        permutations_table[0][0] = nums[0];\\n        return 1;\\n    }\\n    \\n    // Fills the permutations of the numbers excluding the last one.\\n    permutations_amount = fill_permutations(nums, nums_size - 1, permutations_table);\\n    line_index = permutations_amount;\\n    \\n    for (i = 0; i < permutations_amount; ++i)\\n    {\\n        // First we push the last number to the permutation at the end. Thats one of the permutations.\\n        permutations_table[i][nums_size - 1] = nums[nums_size - 1];\\n        \\n        // Then we create all the other permutations of that line.\\n        for (column_index = 0; column_index < nums_size - 1; ++column_index)\\n        {\\n            // We copy that permutation to a new line at the end.\\n            memcpy(permutations_table[line_index], permutations_table[i], nums_size * sizeof(nums[0]));\\n            // Then we switch the last number with each of the other numbers.\\n            temp = permutations_table[line_index][column_index];\\n            permutations_table[line_index][column_index] = permutations_table[line_index][nums_size - 1];\\n            permutations_table[line_index][nums_size - 1] = temp;\\n            line_index++;\\n        }\\n    }\\n    \\n    return line_index;\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int **permutations = NULL;\\n    int *columns_sizes = NULL;\\n    int permutations_amount = 1;\\n    int i = 0;\\n    \\n    // Determine the amount of permutations.\\n    for (i = 1; i <= numsSize; i++)\\n    {\\n        permutations_amount *= i;\\n    }\\n    permutations = (int**)malloc(sizeof(int*) * permutations_amount);\\n    columns_sizes = (int*)malloc(sizeof(int) * permutations_amount);\\n    \\n    for (i = 0; i < permutations_amount; i++)\\n    {\\n        // Assign the column sizes.\\n        columns_sizes[i] = numsSize;    \\n        // Allocates the permutations rows.\\n        permutations[i] = (int*)malloc(sizeof(int) * numsSize); \\n    }\\n    \\n    // Fills the permutations.\\n    (void)fill_permutations(nums, numsSize, permutations);\\n    \\n    *returnSize = permutations_amount;\\n    *returnColumnSizes = columns_sizes;\\n    \\n    return permutations;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <stdlib.h>\\n\\n/*\\nEach time takes the permutations of the numbers excluding the last one.\\nThen for each permutation takes the last number and pushes it between the numbers in all available positions.\\nFor example:\\n\\n    for the permutations of [1, 2, 3] first we get the permutations of [1, 2].\\n        that [[1, 2], [2, 1]]\\n    then for each of them pushes 3 between the numbers in all available positions.\\n        for [1, 2] we get [1, 2, 3], [3, 1, 2], [1, 3, 2].\\n        for [2, 1] we get [2, 1, 3], [3, 2, 1], [2, 3, 1]. \\n        \\n*note - Assumes the table is in the right size.\\n*/\\nint fill_permutations(int nums[], int nums_size, int *permutations_table[])\\n{\\n    int permutations_amount = 0;\\n    int i = 0;\\n    // Holds the line we are currently writing the permutations to.\\n    int line_index = 0;\\n    // The column we are pushing the last number to.\\n    int column_index = 0;\\n    // Used for pushing the last number between the other numbers.\\n    int temp = 0;\\n    \\n    // Exit rule.\\n    if (0 == nums_size)\\n    {\\n        return 0;\\n    }\\n    if (1 == nums_size)\\n    {\\n        permutations_table[0][0] = nums[0];\\n        return 1;\\n    }\\n    \\n    // Fills the permutations of the numbers excluding the last one.\\n    permutations_amount = fill_permutations(nums, nums_size - 1, permutations_table);\\n    line_index = permutations_amount;\\n    \\n    for (i = 0; i < permutations_amount; ++i)\\n    {\\n        // First we push the last number to the permutation at the end. Thats one of the permutations.\\n        permutations_table[i][nums_size - 1] = nums[nums_size - 1];\\n        \\n        // Then we create all the other permutations of that line.\\n        for (column_index = 0; column_index < nums_size - 1; ++column_index)\\n        {\\n            // We copy that permutation to a new line at the end.\\n            memcpy(permutations_table[line_index], permutations_table[i], nums_size * sizeof(nums[0]));\\n            // Then we switch the last number with each of the other numbers.\\n            temp = permutations_table[line_index][column_index];\\n            permutations_table[line_index][column_index] = permutations_table[line_index][nums_size - 1];\\n            permutations_table[line_index][nums_size - 1] = temp;\\n            line_index++;\\n        }\\n    }\\n    \\n    return line_index;\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int **permutations = NULL;\\n    int *columns_sizes = NULL;\\n    int permutations_amount = 1;\\n    int i = 0;\\n    \\n    // Determine the amount of permutations.\\n    for (i = 1; i <= numsSize; i++)\\n    {\\n        permutations_amount *= i;\\n    }\\n    permutations = (int**)malloc(sizeof(int*) * permutations_amount);\\n    columns_sizes = (int*)malloc(sizeof(int) * permutations_amount);\\n    \\n    for (i = 0; i < permutations_amount; i++)\\n    {\\n        // Assign the column sizes.\\n        columns_sizes[i] = numsSize;    \\n        // Allocates the permutations rows.\\n        permutations[i] = (int*)malloc(sizeof(int) * numsSize); \\n    }\\n    \\n    // Fills the permutations.\\n    (void)fill_permutations(nums, numsSize, permutations);\\n    \\n    *returnSize = permutations_amount;\\n    *returnColumnSizes = columns_sizes;\\n    \\n    return permutations;\\n}\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1996537,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1576744,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568476,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1565738,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1572686,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1569264,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996589,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996522,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996529,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568871,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996537,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1576744,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568476,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1565738,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1572686,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1569264,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996589,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996522,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996529,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568871,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1997422,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1996984,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1996843,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1854475,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1574574,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1567719,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1997262,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1996543,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1571114,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 2046549,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 2037614,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2026872,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2010218,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2008108,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2001048,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1999060,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1998169,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997657,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997485,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997454,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997358,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1997353,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1997079,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1997032,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996894,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996834,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996798,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996719,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996709,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996696,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996613,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1996527,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1996519,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1992957,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1991558,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1971626,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1947870,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1935616,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1912947,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1911137,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1872896,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1809209,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1802701,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1787336,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1785105,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1784368,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1774225,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752626,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1737361,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724555,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1722175,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1721780,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1715050,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1714572,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1709502,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1707559,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1696029,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1694585,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1693441,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1689573,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            }
        ]
    },
    {
        "title": "LRU Cache",
        "question_content": "<p>Design a data structure that follows the constraints of a <strong><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\">Least Recently Used (LRU) cache</a></strong>.</p>\n\n<p>Implement the <code>LRUCache</code> class:</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>\n\t<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>\n\t<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>\n</ul>\n\n<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>Output</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>Explanation</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 45911,
                "title": "java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes",
                "content": "The problem can be solved with a hashtable that keeps track of the keys and its values in the double linked list. One interesting property about double linked list is that the node can remove itself without other reference. In addition, it takes constant time to add and remove nodes from the head or tail.\\n\\nOne particularity about the double linked list that I implemented is that I create a pseudo head and tail to mark the boundary, so that we don\\'t need to check the NULL node during the update. This makes the code more concise and clean, and also it is good for the performance. \\n\\nVoila, here is the code. \\n\\n```java\\nimport java.util.Hashtable;\\n\\n\\npublic class LRUCache {\\n\\nclass DLinkedNode {\\n  int key;\\n  int value;\\n  DLinkedNode pre;\\n  DLinkedNode post;\\n}\\n\\n/**\\n * Always add the new node right after head;\\n */\\nprivate void addNode(DLinkedNode node) {\\n    \\n  node.pre = head;\\n  node.post = head.post;\\n\\n  head.post.pre = node;\\n  head.post = node;\\n}\\n\\n/**\\n * Remove an existing node from the linked list.\\n */\\nprivate void removeNode(DLinkedNode node){\\n  DLinkedNode pre = node.pre;\\n  DLinkedNode post = node.post;\\n\\n  pre.post = post;\\n  post.pre = pre;\\n}\\n\\n/**\\n * Move certain node in between to the head.\\n */\\nprivate void moveToHead(DLinkedNode node){\\n  this.removeNode(node);\\n  this.addNode(node);\\n}\\n\\n// pop the current tail. \\nprivate DLinkedNode popTail(){\\n  DLinkedNode res = tail.pre;\\n  this.removeNode(res);\\n  return res;\\n}\\n\\nprivate Hashtable<Integer, DLinkedNode> \\n  cache = new Hashtable<Integer, DLinkedNode>();\\nprivate int count;\\nprivate int capacity;\\nprivate DLinkedNode head, tail;\\n\\npublic LRUCache(int capacity) {\\n  this.count = 0;\\n  this.capacity = capacity;\\n\\n  head = new DLinkedNode();\\n  head.pre = null;\\n\\n  tail = new DLinkedNode();\\n  tail.post = null;\\n\\n  head.post = tail;\\n  tail.pre = head;\\n}\\n\\npublic int get(int key) {\\n\\n  DLinkedNode node = cache.get(key);\\n  if(node == null){\\n    return -1; // should raise exception here.\\n  }\\n\\n  // move the accessed node to the head;\\n  this.moveToHead(node);\\n\\n  return node.value;\\n}\\n\\n\\npublic void put(int key, int value) {\\n  DLinkedNode node = cache.get(key);\\n\\n  if(node == null){\\n\\n    DLinkedNode newNode = new DLinkedNode();\\n    newNode.key = key;\\n    newNode.value = value;\\n\\n    this.cache.put(key, newNode);\\n    this.addNode(newNode);\\n\\n    ++count;\\n\\n    if(count > capacity){\\n      // pop the tail\\n      DLinkedNode tail = this.popTail();\\n      this.cache.remove(tail.key);\\n      --count;\\n    }\\n  }else{\\n    // update the value.\\n    node.value = value;\\n    this.moveToHead(node);\\n  }\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```java\\nimport java.util.Hashtable;\\n\\n\\npublic class LRUCache {\\n\\nclass DLinkedNode {\\n  int key;\\n  int value;\\n  DLinkedNode pre;\\n  DLinkedNode post;\\n}\\n\\n/**\\n * Always add the new node right after head;\\n */\\nprivate void addNode(DLinkedNode node) {\\n    \\n  node.pre = head;\\n  node.post = head.post;\\n\\n  head.post.pre = node;\\n  head.post = node;\\n}\\n\\n/**\\n * Remove an existing node from the linked list.\\n */\\nprivate void removeNode(DLinkedNode node){\\n  DLinkedNode pre = node.pre;\\n  DLinkedNode post = node.post;\\n\\n  pre.post = post;\\n  post.pre = pre;\\n}\\n\\n/**\\n * Move certain node in between to the head.\\n */\\nprivate void moveToHead(DLinkedNode node){\\n  this.removeNode(node);\\n  this.addNode(node);\\n}\\n\\n// pop the current tail. \\nprivate DLinkedNode popTail(){\\n  DLinkedNode res = tail.pre;\\n  this.removeNode(res);\\n  return res;\\n}\\n\\nprivate Hashtable<Integer, DLinkedNode> \\n  cache = new Hashtable<Integer, DLinkedNode>();\\nprivate int count;\\nprivate int capacity;\\nprivate DLinkedNode head, tail;\\n\\npublic LRUCache(int capacity) {\\n  this.count = 0;\\n  this.capacity = capacity;\\n\\n  head = new DLinkedNode();\\n  head.pre = null;\\n\\n  tail = new DLinkedNode();\\n  tail.post = null;\\n\\n  head.post = tail;\\n  tail.pre = head;\\n}\\n\\npublic int get(int key) {\\n\\n  DLinkedNode node = cache.get(key);\\n  if(node == null){\\n    return -1; // should raise exception here.\\n  }\\n\\n  // move the accessed node to the head;\\n  this.moveToHead(node);\\n\\n  return node.value;\\n}\\n\\n\\npublic void put(int key, int value) {\\n  DLinkedNode node = cache.get(key);\\n\\n  if(node == null){\\n\\n    DLinkedNode newNode = new DLinkedNode();\\n    newNode.key = key;\\n    newNode.value = value;\\n\\n    this.cache.put(key, newNode);\\n    this.addNode(newNode);\\n\\n    ++count;\\n\\n    if(count > capacity){\\n      // pop the tail\\n      DLinkedNode tail = this.popTail();\\n      this.cache.remove(tail.key);\\n      --count;\\n    }\\n  }else{\\n    // update the value.\\n    node.value = value;\\n    this.moveToHead(node);\\n  }\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45926,
                "title": "python-dict-double-linkedlist",
                "content": "    class Node:\\n    def __init__(self, k, v):\\n        self.key = k\\n        self.val = v\\n        self.prev = None\\n        self.next = None\\n\\n    class LRUCache:\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.dic = dict()\\n        self.head = Node(0, 0)\\n        self.tail = Node(0, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key):\\n        if key in self.dic:\\n            n = self.dic[key]\\n            self._remove(n)\\n            self._add(n)\\n            return n.val\\n        return -1\\n\\n    def set(self, key, value):\\n        if key in self.dic:\\n            self._remove(self.dic[key])\\n        n = Node(key, value)\\n        self._add(n)\\n        self.dic[key] = n\\n        if len(self.dic) > self.capacity:\\n            n = self.head.next\\n            self._remove(n)\\n            del self.dic[n.key]\\n\\n    def _remove(self, node):\\n        p = node.prev\\n        n = node.next\\n        p.next = n\\n        n.prev = p\\n\\n    def _add(self, node):\\n        p = self.tail.prev\\n        p.next = node\\n        self.tail.prev = node\\n        node.prev = p\\n        node.next = self.tail",
                "solutionTags": [],
                "code": "    class Node:\\n    def __init__(self, k, v):\\n        self.key = k\\n        self.val = v\\n        self.prev = None\\n        self.next = None\\n\\n    class LRUCache:\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.dic = dict()\\n        self.head = Node(0, 0)\\n        self.tail = Node(0, 0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key):\\n        if key in self.dic:\\n            n = self.dic[key]\\n            self._remove(n)\\n            self._add(n)\\n            return n.val\\n        return -1\\n\\n    def set(self, key, value):\\n        if key in self.dic:\\n            self._remove(self.dic[key])\\n        n = Node(key, value)\\n        self._add(n)\\n        self.dic[key] = n\\n        if len(self.dic) > self.capacity:\\n            n = self.head.next\\n            self._remove(n)\\n            del self.dic[n.key]\\n\\n    def _remove(self, node):\\n        p = node.prev\\n        n = node.next\\n        p.next = n\\n        n.prev = p\\n\\n    def _add(self, node):\\n        p = self.tail.prev\\n        p.next = node\\n        self.tail.prev = node\\n        node.prev = p\\n        node.next = self.tail",
                "codeTag": "Java"
            },
            {
                "id": 45912,
                "title": "clean-short-standard-c-solution-not-writing-c-in-c-like-all-other-lengthy-ones",
                "content": "I saw so many (or all) \"C++\" solutions posted here were not written in C++ at all. For those 200-line solutions, I don't see the point in implementing a double-linked-list by themselves. \\n\\n**If you are writing C++, please use STL!** \\n\\nThe code below is way cleaner, shorter and easier to read than most other C++ solutions posted here.\\nAnd above all, it was written in a standard C++ way.\\n\\n    class LRUCache{\\n        size_t m_capacity;\\n        unordered_map<int,  list<pair<int, int>>::iterator> m_map; //m_map_iter->first: key, m_map_iter->second: list iterator;\\n        list<pair<int, int>> m_list;                               //m_list_iter->first: key, m_list_iter->second: value;\\n    public:\\n        LRUCache(size_t capacity):m_capacity(capacity) {\\n        }\\n        int get(int key) {\\n            auto found_iter = m_map.find(key);\\n            if (found_iter == m_map.end()) //key doesn't exist\\n                return -1;\\n            m_list.splice(m_list.begin(), m_list, found_iter->second); //move the node corresponding to key to front\\n            return found_iter->second->second;                         //return value of the node\\n        }\\n        void set(int key, int value) {\\n            auto found_iter = m_map.find(key);\\n            if (found_iter != m_map.end()) //key exists\\n            {\\n                m_list.splice(m_list.begin(), m_list, found_iter->second); //move the node corresponding to key to front\\n                found_iter->second->second = value;                        //update value of the node\\n                return;\\n            }\\n            if (m_map.size() == m_capacity) //reached capacity\\n            {\\n               int key_to_del = m_list.back().first; \\n               m_list.pop_back();            //remove node in list;\\n               m_map.erase(key_to_del);      //remove key in map\\n            }\\n            m_list.emplace_front(key, value);  //create new node in list\\n            m_map[key] = m_list.begin();       //create correspondence between key and node\\n        }\\n    };",
                "solutionTags": [],
                "code": "I saw so many (or all) \"C++\" solutions posted here were not written in C++ at all. For those 200-line solutions, I don't see the point in implementing a double-linked-list by themselves. \\n\\n**If you are writing C++, please use STL!** \\n\\nThe code below is way cleaner, shorter and easier to read than most other C++ solutions posted here.\\nAnd above all, it was written in a standard C++ way.\\n\\n    class LRUCache{\\n        size_t m_capacity;\\n        unordered_map<int,  list<pair<int, int>>::iterator> m_map; //m_map_iter->first: key, m_map_iter->second: list iterator;\\n        list<pair<int, int>> m_list;                               //m_list_iter->first: key, m_list_iter->second: value;\\n    public:\\n        LRUCache(size_t capacity):m_capacity(capacity) {\\n        }\\n        int get(int key) {\\n            auto found_iter = m_map.find(key);\\n            if (found_iter == m_map.end()) //key doesn't exist\\n                return -1;\\n            m_list.splice(m_list.begin(), m_list, found_iter->second); //move the node corresponding to key to front\\n            return found_iter->second->second;                         //return value of the node\\n        }\\n        void set(int key, int value) {\\n            auto found_iter = m_map.find(key);\\n            if (found_iter != m_map.end()) //key exists\\n            {\\n                m_list.splice(m_list.begin(), m_list, found_iter->second); //move the node corresponding to key to front\\n                found_iter->second->second = value;                        //update value of the node\\n                return;\\n            }\\n            if (m_map.size() == m_capacity) //reached capacity\\n            {\\n               int key_to_del = m_list.back().first; \\n               m_list.pop_back();            //remove node in list;\\n               m_map.erase(key_to_del);      //remove key in map\\n            }\\n            m_list.emplace_front(key, value);  //create new node in list\\n            m_map[key] = m_list.begin();       //create correspondence between key and node\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 45939,
                "title": "laziest-implementation-java-s-linkedhashmap-takes-care-of-everything",
                "content": "This is the laziest implementation using Java's LinkedHashMap. In the real interview, however, it is definitely not what interviewer expected.\\n```\\n    import java.util.LinkedHashMap;\\n    public class LRUCache {\\n        private LinkedHashMap<Integer, Integer> map;\\n        private final int CAPACITY;\\n        public LRUCache(int capacity) {\\n            CAPACITY = capacity;\\n            map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true){\\n                protected boolean removeEldestEntry(Map.Entry eldest) {\\n                    return size() > CAPACITY;\\n                }\\n            };\\n        }\\n        public int get(int key) {\\n            return map.getOrDefault(key, -1);\\n        }\\n        public void set(int key, int value) {\\n            map.put(key, value);\\n        }\\n    }\\n```\\nSeveral points to mention:<br>\\n1. In the constructor, the third boolean parameter specifies the ordering mode. If we set it to true, it will be in access order. (https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#LinkedHashMap-int-float-boolean-)<br>\\n2. By overriding removeEldestEntry in this way, we do not need to take care of it ourselves. It will automatically remove the least recent one when the size of map exceeds the specified capacity.(https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#removeEldestEntry-java.util.Map.Entry-)\\n\\nBelow is a \"normal\" HashMap + doubly-linked list implementation:\\n```\\npublic class LRUCache {\\n    private class Node{\\n        int key, value;\\n        Node prev, next;\\n        Node(int k, int v){\\n            this.key = k;\\n            this.value = v;\\n        }\\n        Node(){\\n            this(0, 0);\\n        }\\n    }\\n    private int capacity, count;\\n    private Map<Integer, Node> map;\\n    private Node head, tail;\\n    \\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.count = 0;\\n        map = new HashMap<>();\\n        head = new Node();\\n        tail = new Node();\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        Node n = map.get(key);\\n        if(null==n){\\n            return -1;\\n        }\\n        update(n);\\n        return n.value;\\n    }\\n    \\n    public void set(int key, int value) {\\n        Node n = map.get(key);\\n        if(null==n){\\n            n = new Node(key, value);\\n            map.put(key, n);\\n            add(n);\\n            ++count;\\n        }\\n        else{\\n            n.value = value;\\n            update(n);\\n        }\\n        if(count>capacity){\\n            Node toDel = tail.prev;\\n            remove(toDel);\\n            map.remove(toDel.key);\\n            --count;\\n        }\\n    }\\n    \\n    private void update(Node node){\\n        remove(node);\\n        add(node);\\n    }\\n    private void add(Node node){\\n        Node after = head.next;\\n        head.next = node;\\n        node.prev = head;\\n        node.next = after;\\n        after.prev = node;\\n    }\\n    \\n    private void remove(Node node){\\n        Node before = node.prev, after = node.next;\\n        before.next = after;\\n        after.prev = before;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    import java.util.LinkedHashMap;\\n    public class LRUCache {\\n        private LinkedHashMap<Integer, Integer> map;\\n        private final int CAPACITY;\\n        public LRUCache(int capacity) {\\n            CAPACITY = capacity;\\n            map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true){\\n                protected boolean removeEldestEntry(Map.Entry eldest) {\\n                    return size() > CAPACITY;\\n                }\\n            };\\n        }\\n        public int get(int key) {\\n            return map.getOrDefault(key, -1);\\n        }\\n        public void set(int key, int value) {\\n            map.put(key, value);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171305,
                "title": "solution",
                "content": "```C++ []\\nclass LRUCache {\\npublic:\\n    inline static int M[10001];\\n    inline static int16_t L[10002][2];\\n    int cap, size = 0;\\n    const int NONE = 10001;\\n    int head = NONE, tail = NONE;\\n    \\n    LRUCache(int capacity) : cap(capacity) {\\n        memset(M, 0xff, sizeof M);\\n    }\\n    \\n    inline void erase(int key) {\\n        const int pre = L[key][0];\\n        const int nxt = L[key][1];\\n        L[pre][1] = nxt;\\n        L[nxt][0] = pre;\\n        if (head == key) head = nxt;\\n        if (tail == key) tail = pre;\\n    }\\n    \\n    inline void push_front(int key) {\\n        L[key][0] = NONE;\\n        L[key][1] = head;\\n        L[head][0] = key;\\n        head = key;\\n        if (tail == NONE)\\n            tail = key;\\n    }\\n    \\n    inline int pop_back() {\\n        int ret = tail;\\n        tail = L[tail][0];\\n        L[tail][1] = NONE;\\n        if (tail == NONE)\\n            head = NONE;\\n        return ret;\\n    }\\n    \\n    int get(int key) {\\n        if (M[key] == -1) return -1;\\n        erase(key);\\n        push_front(key);\\n        return M[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if (M[key] != -1) {\\n            erase(key);\\n        } else {\\n            if (size == cap) {\\n                int poped = pop_back();\\n                M[poped] = -1;\\n                size -= 1;\\n            }\\n            size += 1;\\n        }\\n        push_front(key);\\n        M[key] = value;\\n    }\\n};\\n\\n#include <unistd.h>\\nstatic char buf[20000000];\\n\\nint mgetchar() {\\n    static int pos = 0;\\n    pos++;\\n    return buf[pos-1] == \\'\\\\0\\' ? EOF : buf[pos-1];\\n}\\n\\nint getmethod() {\\n    int c = mgetchar();\\n    while (mgetchar() != \\'\"\\');\\n    return c;\\n}\\n\\nint getinput(vector<int>& ret) {\\n    int c;\\n    while((c = mgetchar()) != EOF && c != \\'[\\');\\n    while ((c = mgetchar()) != EOF) {\\n        if (c == \\'\"\\')\\n            ret.push_back(getmethod());\\n        else if (c == \\']\\')\\n            return 1;\\n    }\\n    return 0;\\n}\\n\\nint getone() {\\n    while(mgetchar() != \\'[\\');\\n    int ans = 0, c;\\n    while((c = mgetchar()) != \\']\\') {\\n        if (isdigit(c))\\n            ans = ans * 10 + c - \\'0\\';\\n    }\\n    return ans;\\n}\\n\\npair<int,int> gettwo() {\\n    while(mgetchar() != \\'[\\');\\n    pair<int,int> ans;\\n    int c;\\n    while((c = mgetchar()) != \\',\\') {\\n        if (isdigit(c))\\n            ans.first = ans.first * 10 + c - \\'0\\';\\n    }\\n    while((c = mgetchar()) != \\']\\') {\\n        if (isdigit(c))\\n            ans.second = ans.second * 10 + c - \\'0\\';\\n    }\\n    return ans;\\n}\\n\\nvoid getpara(FILE *fp, vector<int>& funcs) {\\n    while(mgetchar() != \\'[\\');\\n    fprintf(fp, \"[\");\\n    LRUCache lru(getone());\\n    for (int i = 0; i < funcs.size(); i++) {\\n        auto f = funcs[i];\\n        if (f == \\'L\\') {\\n            fprintf(fp, \"null\");\\n        } else if (f == \\'g\\') {\\n            int v = lru.get(getone());\\n            fprintf(fp, \"%d\", v);\\n        } else {\\n            pair<int,int> v = gettwo();\\n            lru.put(v.first, v.second);\\n            fprintf(fp, \"null\");\\n        }\\n        if (i + 1 < funcs.size())\\n            fprintf(fp, \",\");\\n    }\\n    while(mgetchar() != \\']\\');\\n    fprintf(fp, \"]\\\\n\");\\n}\\n\\nint main() {\\n    int n = read(0, buf, 20000000);\\n    buf[n] = \\'\\\\0\\';\\n\\n    FILE *fp = fopen(\"user.out\", \"w\");\\n    vector<int> funcs;\\n    while (getinput(funcs)) {\\n        getpara(fp, funcs);\\n        funcs.clear();\\n    }\\n    fclose(fp);\\n}\\n```\\n\\n```Python3 []\\nfrom collections import OrderedDict\\n\\nclass LRUCache:\\n    __slots__ = (\\'data\\', \\'capacity\\')\\n\\n    def __init__(self, capacity: int):\\n        self.data: Dict[int, int] = OrderedDict()\\n        self.capacity: int = capacity\\n\\n    def get(self, key: int) -> int:\\n        return -1 if key not in self.data else self.data.setdefault(key, self.data.pop(key))\\n\\n    def put(self, key: int, value: int) -> None:\\n        try:\\n            self.data.move_to_end(key)\\n            self.data[key] = value\\n        except KeyError:\\n            self.data[key] = value\\n            if len(self.data) > self.capacity:\\n                self.data.popitem(last=False)\\n```\\n\\n```Java []\\nclass LRUCache {\\n    class Node{\\n        int key;\\n        int value;\\n\\n        Node prev;\\n        Node next;\\n\\n        Node(int key, int value){\\n            this.key= key;\\n            this.value= value;\\n        }\\n    }\\n\\n    public Node[] map;\\n    public int count, capacity;\\n    public Node head, tail;\\n    \\n    public LRUCache(int capacity) {\\n        \\n        this.capacity= capacity;\\n        count= 0;\\n        \\n        map= new Node[10_000+1];\\n        \\n        head= new Node(0,0);\\n        tail= new Node(0,0);\\n        \\n        head.next= tail;\\n        tail.prev= head;\\n        \\n        head.prev= null;\\n        tail.next= null;\\n    }\\n    \\n    public void deleteNode(Node node){\\n        node.prev.next= node.next;\\n        node.next.prev= node.prev;       \\n        \\n        return;\\n    }\\n    \\n    public void addToHead(Node node){\\n        node.next= head.next;\\n        node.next.prev= node;\\n        node.prev= head;\\n        \\n        head.next= node;      \\n        \\n        return;\\n    }\\n    \\n    public int get(int key) {\\n        \\n        if( map[key] != null ){\\n            \\n            Node node= map[key];\\n            \\n            int nodeVal= node.value;\\n            \\n            deleteNode(node);\\n            \\n            addToHead(node);\\n            \\n            return nodeVal;\\n        }\\n        else\\n            return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if(map[key] != null){\\n            \\n            Node node= map[key];\\n            \\n            node.value= value;\\n            \\n            deleteNode(node);\\n            \\n            addToHead(node);\\n            \\n        } else {\\n            \\n            Node node= new Node(key,value);\\n            \\n            map[key]= node;\\n            \\n            if(count < capacity){\\n                count++;\\n                addToHead(node);\\n            } \\n            else {\\n                \\n                map[tail.prev.key]= null;\\n                deleteNode(tail.prev);\\n                \\n                addToHead(node);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass LRUCache {\\npublic:\\n    inline static int M[10001];\\n    inline static int16_t L[10002][2];\\n    int cap, size = 0;\\n    const int NONE = 10001;\\n    int head = NONE, tail = NONE;\\n    \\n    LRUCache(int capacity) : cap(capacity) {\\n        memset(M, 0xff, sizeof M);\\n    }\\n    \\n    inline void erase(int key) {\\n        const int pre = L[key][0];\\n        const int nxt = L[key][1];\\n        L[pre][1] = nxt;\\n        L[nxt][0] = pre;\\n        if (head == key) head = nxt;\\n        if (tail == key) tail = pre;\\n    }\\n    \\n    inline void push_front(int key) {\\n        L[key][0] = NONE;\\n        L[key][1] = head;\\n        L[head][0] = key;\\n        head = key;\\n        if (tail == NONE)\\n            tail = key;\\n    }\\n    \\n    inline int pop_back() {\\n        int ret = tail;\\n        tail = L[tail][0];\\n        L[tail][1] = NONE;\\n        if (tail == NONE)\\n            head = NONE;\\n        return ret;\\n    }\\n    \\n    int get(int key) {\\n        if (M[key] == -1) return -1;\\n        erase(key);\\n        push_front(key);\\n        return M[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if (M[key] != -1) {\\n            erase(key);\\n        } else {\\n            if (size == cap) {\\n                int poped = pop_back();\\n                M[poped] = -1;\\n                size -= 1;\\n            }\\n            size += 1;\\n        }\\n        push_front(key);\\n        M[key] = value;\\n    }\\n};\\n\\n#include <unistd.h>\\nstatic char buf[20000000];\\n\\nint mgetchar() {\\n    static int pos = 0;\\n    pos++;\\n    return buf[pos-1] == \\'\\\\0\\' ? EOF : buf[pos-1];\\n}\\n\\nint getmethod() {\\n    int c = mgetchar();\\n    while (mgetchar() != \\'\"\\');\\n    return c;\\n}\\n\\nint getinput(vector<int>& ret) {\\n    int c;\\n    while((c = mgetchar()) != EOF && c != \\'[\\');\\n    while ((c = mgetchar()) != EOF) {\\n        if (c == \\'\"\\')\\n            ret.push_back(getmethod());\\n        else if (c == \\']\\')\\n            return 1;\\n    }\\n    return 0;\\n}\\n\\nint getone() {\\n    while(mgetchar() != \\'[\\');\\n    int ans = 0, c;\\n    while((c = mgetchar()) != \\']\\') {\\n        if (isdigit(c))\\n            ans = ans * 10 + c - \\'0\\';\\n    }\\n    return ans;\\n}\\n\\npair<int,int> gettwo() {\\n    while(mgetchar() != \\'[\\');\\n    pair<int,int> ans;\\n    int c;\\n    while((c = mgetchar()) != \\',\\') {\\n        if (isdigit(c))\\n            ans.first = ans.first * 10 + c - \\'0\\';\\n    }\\n    while((c = mgetchar()) != \\']\\') {\\n        if (isdigit(c))\\n            ans.second = ans.second * 10 + c - \\'0\\';\\n    }\\n    return ans;\\n}\\n\\nvoid getpara(FILE *fp, vector<int>& funcs) {\\n    while(mgetchar() != \\'[\\');\\n    fprintf(fp, \"[\");\\n    LRUCache lru(getone());\\n    for (int i = 0; i < funcs.size(); i++) {\\n        auto f = funcs[i];\\n        if (f == \\'L\\') {\\n            fprintf(fp, \"null\");\\n        } else if (f == \\'g\\') {\\n            int v = lru.get(getone());\\n            fprintf(fp, \"%d\", v);\\n        } else {\\n            pair<int,int> v = gettwo();\\n            lru.put(v.first, v.second);\\n            fprintf(fp, \"null\");\\n        }\\n        if (i + 1 < funcs.size())\\n            fprintf(fp, \",\");\\n    }\\n    while(mgetchar() != \\']\\');\\n    fprintf(fp, \"]\\\\n\");\\n}\\n\\nint main() {\\n    int n = read(0, buf, 20000000);\\n    buf[n] = \\'\\\\0\\';\\n\\n    FILE *fp = fopen(\"user.out\", \"w\");\\n    vector<int> funcs;\\n    while (getinput(funcs)) {\\n        getpara(fp, funcs);\\n        funcs.clear();\\n    }\\n    fclose(fp);\\n}\\n```\n```Python3 []\\nfrom collections import OrderedDict\\n\\nclass LRUCache:\\n    __slots__ = (\\'data\\', \\'capacity\\')\\n\\n    def __init__(self, capacity: int):\\n        self.data: Dict[int, int] = OrderedDict()\\n        self.capacity: int = capacity\\n\\n    def get(self, key: int) -> int:\\n        return -1 if key not in self.data else self.data.setdefault(key, self.data.pop(key))\\n\\n    def put(self, key: int, value: int) -> None:\\n        try:\\n            self.data.move_to_end(key)\\n            self.data[key] = value\\n        except KeyError:\\n            self.data[key] = value\\n            if len(self.data) > self.capacity:\\n                self.data.popitem(last=False)\\n```\n```Java []\\nclass LRUCache {\\n    class Node{\\n        int key;\\n        int value;\\n\\n        Node prev;\\n        Node next;\\n\\n        Node(int key, int value){\\n            this.key= key;\\n            this.value= value;\\n        }\\n    }\\n\\n    public Node[] map;\\n    public int count, capacity;\\n    public Node head, tail;\\n    \\n    public LRUCache(int capacity) {\\n        \\n        this.capacity= capacity;\\n        count= 0;\\n        \\n        map= new Node[10_000+1];\\n        \\n        head= new Node(0,0);\\n        tail= new Node(0,0);\\n        \\n        head.next= tail;\\n        tail.prev= head;\\n        \\n        head.prev= null;\\n        tail.next= null;\\n    }\\n    \\n    public void deleteNode(Node node){\\n        node.prev.next= node.next;\\n        node.next.prev= node.prev;       \\n        \\n        return;\\n    }\\n    \\n    public void addToHead(Node node){\\n        node.next= head.next;\\n        node.next.prev= node;\\n        node.prev= head;\\n        \\n        head.next= node;      \\n        \\n        return;\\n    }\\n    \\n    public int get(int key) {\\n        \\n        if( map[key] != null ){\\n            \\n            Node node= map[key];\\n            \\n            int nodeVal= node.value;\\n            \\n            deleteNode(node);\\n            \\n            addToHead(node);\\n            \\n            return nodeVal;\\n        }\\n        else\\n            return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        \\n        if(map[key] != null){\\n            \\n            Node node= map[key];\\n            \\n            node.value= value;\\n            \\n            deleteNode(node);\\n            \\n            addToHead(node);\\n            \\n        } else {\\n            \\n            Node node= new Node(key,value);\\n            \\n            map[key]= node;\\n            \\n            if(count < capacity){\\n                count++;\\n                addToHead(node);\\n            } \\n            else {\\n                \\n                map[tail.prev.key]= null;\\n                deleteNode(tail.prev);\\n                \\n                addToHead(node);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 792449,
                "title": "simple-c-solution-with-detailed-explanation",
                "content": "In this question we have to keep track of the most least recently used item in the cache. I have designed the cache using list and map in C++.\\nWe do it by following the steps below :-\\n* When we access an item in the cache it moves to the front of the list as it is the most recently used item.\\n* When we want to remove an item we remove it from the last of the list as it is the least recently used item in the cache.\\n* When we insert an item we insert it into the front of the list as it is the most recently used item.\\nThe idea is to store the keys in the map and its corrosponding values into the list...\\n**Note : splice() function here takes the element at the m[key] and places it at the beginning of the list...**\\n\\n```\\nclass LRUCache\\n{\\n    public:\\n        list<pair<int,int>> l;\\n        unordered_map<int,list<pair<int, int>>::iterator> m;\\n        int size;\\n        LRUCache(int capacity)\\n        {\\n            size=capacity;\\n        }\\n        int get(int key)\\n        {\\n            if(m.find(key)==m.end())\\n                return -1;\\n            l.splice(l.begin(),l,m[key]);\\n            return m[key]->second;\\n        }\\n        void put(int key, int value)\\n        {\\n            if(m.find(key)!=m.end())\\n            {\\n                l.splice(l.begin(),l,m[key]);\\n                m[key]->second=value;\\n                return;\\n            }\\n            if(l.size()==size)\\n            {\\n                auto d_key=l.back().first;\\n                l.pop_back();\\n                m.erase(d_key);\\n            }\\n            l.push_front({key,value});\\n            m[key]=l.begin();\\n        }\\n};\\n```\\n\\nPlease upvote if u liked it.....**Happy Coding...**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LRUCache\\n{\\n    public:\\n        list<pair<int,int>> l;\\n        unordered_map<int,list<pair<int, int>>::iterator> m;\\n        int size;\\n        LRUCache(int capacity)\\n        {\\n            size=capacity;\\n        }\\n        int get(int key)\\n        {\\n            if(m.find(key)==m.end())\\n                return -1;\\n            l.splice(l.begin(),l,m[key]);\\n            return m[key]->second;\\n        }\\n        void put(int key, int value)\\n        {\\n            if(m.find(key)!=m.end())\\n            {\\n                l.splice(l.begin(),l,m[key]);\\n                m[key]->second=value;\\n                return;\\n            }\\n            if(l.size()==size)\\n            {\\n                auto d_key=l.back().first;\\n                l.pop_back();\\n                m.erase(d_key);\\n            }\\n            l.push_front({key,value});\\n            m[key]=l.begin();\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45976,
                "title": "c-11-code-74ms-hash-table-list",
                "content": "There is a similar example in Java, but I wanted to share my solution using the new C++11 unordered\\\\_map and a list. The good thing about lists is that iterators are never invalidated by modifiers (unless erasing the element itself). This way, we can store the iterator to the corresponding LRU queue in the values of the hash map. Since using erase on a list with an iterator takes constant time, all operations of the LRU cache run in constant time.\\n\\n    class LRUCache {\\n    public:\\n        LRUCache(int capacity) : _capacity(capacity) {}\\n        \\n        int get(int key) {\\n            auto it = cache.find(key);\\n            if (it == cache.end()) return -1;\\n            touch(it);\\n            return it->second.first;\\n        }\\n        \\n        void set(int key, int value) {\\n            auto it = cache.find(key);\\n            if (it != cache.end()) touch(it);\\n            else {\\n    \\t\\t\\tif (cache.size() == _capacity) {\\n    \\t\\t\\t\\tcache.erase(used.back());\\n    \\t\\t\\t\\tused.pop_back();\\n    \\t\\t\\t}\\n                used.push_front(key);\\n            }\\n            cache[key] = { value, used.begin() };\\n        }\\n        \\n    private:\\n        typedef list<int> LI;\\n        typedef pair<int, LI::iterator> PII;\\n        typedef unordered_map<int, PII> HIPII;\\n        \\n        void touch(HIPII::iterator it) {\\n            int key = it->first;\\n            used.erase(it->second.second);\\n            used.push_front(key);\\n            it->second.second = used.begin();\\n        }\\n        \\n        HIPII cache;\\n        LI used;\\n        int _capacity;\\n    };",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "There is a similar example in Java, but I wanted to share my solution using the new C++11 unordered\\\\_map and a list. The good thing about lists is that iterators are never invalidated by modifiers (unless erasing the element itself). This way, we can store the iterator to the corresponding LRU queue in the values of the hash map. Since using erase on a list with an iterator takes constant time, all operations of the LRU cache run in constant time.\\n\\n    class LRUCache {\\n    public:\\n        LRUCache(int capacity) : _capacity(capacity) {}\\n        \\n        int get(int key) {\\n            auto it = cache.find(key);\\n            if (it == cache.end()) return -1;\\n            touch(it);\\n            return it->second.first;\\n        }\\n        \\n        void set(int key, int value) {\\n            auto it = cache.find(key);\\n            if (it != cache.end()) touch(it);\\n            else {\\n    \\t\\t\\tif (cache.size() == _capacity) {\\n    \\t\\t\\t\\tcache.erase(used.back());\\n    \\t\\t\\t\\tused.pop_back();\\n    \\t\\t\\t}\\n                used.push_front(key);\\n            }\\n            cache[key] = { value, used.begin() };\\n        }\\n        \\n    private:\\n        typedef list<int> LI;\\n        typedef pair<int, LI::iterator> PII;\\n        typedef unordered_map<int, PII> HIPII;\\n        \\n        void touch(HIPII::iterator it) {\\n            int key = it->first;\\n            used.erase(it->second.second);\\n            used.push_front(key);\\n            it->second.second = used.begin();\\n        }\\n        \\n        HIPII cache;\\n        LI used;\\n        int _capacity;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 45922,
                "title": "java-easy-version-to-understand",
                "content": "1.The key to solve this problem is using a double linked list which enables us to quickly move nodes.\\n2.The LRU cache is a hash table of keys and double linked nodes. The hash table makes the time of get() to be O(1). The list of double linked nodes make the nodes adding/removal operations O(1).\\n\\nclass Node {\\n\\tint key;\\n\\tint value;\\n\\tNode pre;\\n\\tNode next;\\n\\n\\tpublic Node(int key, int value) {\\n\\t\\tthis.key = key;\\n\\t\\tthis.value = value;\\n\\t}\\n}\\npublic class LRUCache {\\n    \\n HashMap<Integer, Node> map;\\n\\tint capicity, count;\\n\\tNode head, tail;\\n\\n\\tpublic LRUCache(int capacity) {\\n\\t\\tthis.capicity = capacity;\\n\\t\\tmap = new HashMap<>();\\n\\t\\thead = new Node(0, 0);\\n\\t\\ttail = new Node(0, 0);\\n\\t\\thead.next = tail;\\n\\t\\ttail.pre = head;\\n\\t\\thead.pre = null;\\n\\t\\ttail.next = null;\\n\\t\\tcount = 0;\\n\\t}\\n\\n\\tpublic void deleteNode(Node node) {\\n\\t\\tnode.pre.next = node.next;\\n\\t\\tnode.next.pre = node.pre;\\n\\t}\\n\\n\\tpublic void addToHead(Node node) {\\n\\t\\tnode.next = head.next;\\n\\t\\tnode.next.pre = node;\\n\\t\\tnode.pre = head;\\n\\t\\thead.next = node;\\n\\t}\\n\\n\\tpublic int get(int key) {\\n\\t\\tif (map.get(key) != null) {\\n\\t\\t\\tNode node = map.get(key);\\n\\t\\t\\tint result = node.value;\\n\\t\\t\\tdeleteNode(node);\\n\\t\\t\\taddToHead(node);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic void set(int key, int value) {\\n\\t\\tif (map.get(key) != null) {\\n\\t\\t\\tNode node = map.get(key);\\n\\t\\t\\tnode.value = value;\\n\\t\\t\\tdeleteNode(node);\\n\\t\\t\\taddToHead(node);\\n\\t\\t} else {\\n\\t\\t\\tNode node = new Node(key, value);\\n\\t\\t\\tmap.put(key, node);\\n\\t\\t\\tif (count < capicity) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\taddToHead(node);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.remove(tail.pre.key);\\n\\t\\t\\t\\tdeleteNode(tail.pre);\\n\\t\\t\\t\\taddToHead(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n}",
                "solutionTags": [],
                "code": "1.The key to solve this problem is using a double linked list which enables us to quickly move nodes.\\n2.The LRU cache is a hash table of keys and double linked nodes. The hash table makes the time of get() to be O(1). The list of double linked nodes make the nodes adding/removal operations O(1).\\n\\nclass Node {\\n\\tint key;\\n\\tint value;\\n\\tNode pre;\\n\\tNode next;\\n\\n\\tpublic Node(int key, int value) {\\n\\t\\tthis.key = key;\\n\\t\\tthis.value = value;\\n\\t}\\n}\\npublic class LRUCache {\\n    \\n HashMap<Integer, Node> map;\\n\\tint capicity, count;\\n\\tNode head, tail;\\n\\n\\tpublic LRUCache(int capacity) {\\n\\t\\tthis.capicity = capacity;\\n\\t\\tmap = new HashMap<>();\\n\\t\\thead = new Node(0, 0);\\n\\t\\ttail = new Node(0, 0);\\n\\t\\thead.next = tail;\\n\\t\\ttail.pre = head;\\n\\t\\thead.pre = null;\\n\\t\\ttail.next = null;\\n\\t\\tcount = 0;\\n\\t}\\n\\n\\tpublic void deleteNode(Node node) {\\n\\t\\tnode.pre.next = node.next;\\n\\t\\tnode.next.pre = node.pre;\\n\\t}\\n\\n\\tpublic void addToHead(Node node) {\\n\\t\\tnode.next = head.next;\\n\\t\\tnode.next.pre = node;\\n\\t\\tnode.pre = head;\\n\\t\\thead.next = node;\\n\\t}\\n\\n\\tpublic int get(int key) {\\n\\t\\tif (map.get(key) != null) {\\n\\t\\t\\tNode node = map.get(key);\\n\\t\\t\\tint result = node.value;\\n\\t\\t\\tdeleteNode(node);\\n\\t\\t\\taddToHead(node);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic void set(int key, int value) {\\n\\t\\tif (map.get(key) != null) {\\n\\t\\t\\tNode node = map.get(key);\\n\\t\\t\\tnode.value = value;\\n\\t\\t\\tdeleteNode(node);\\n\\t\\t\\taddToHead(node);\\n\\t\\t} else {\\n\\t\\t\\tNode node = new Node(key, value);\\n\\t\\t\\tmap.put(key, node);\\n\\t\\t\\tif (count < capicity) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\taddToHead(node);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.remove(tail.pre.key);\\n\\t\\t\\t\\tdeleteNode(tail.pre);\\n\\t\\t\\t\\taddToHead(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 45952,
                "title": "python-concise-solution-with-comments-using-ordereddict",
                "content": "    \\n    def __init__(self, capacity):\\n        self.dic = collections.OrderedDict()\\n        self.remain = capacity\\n\\n    def get(self, key):\\n        if key not in self.dic:\\n            return -1\\n        v = self.dic.pop(key) \\n        self.dic[key] = v   # set key as the newest one\\n        return v\\n\\n    def set(self, key, value):\\n        if key in self.dic:    \\n            self.dic.pop(key)\\n        else:\\n            if self.remain > 0:\\n                self.remain -= 1  \\n            else:  # self.dic is full\\n                self.dic.popitem(last=False) \\n        self.dic[key] = value",
                "solutionTags": [
                    "Python"
                ],
                "code": "    \\n    def __init__(self, capacity):\\n        self.dic = collections.OrderedDict()\\n        self.remain = capacity\\n\\n    def get(self, key):\\n        if key not in self.dic:\\n            return -1\\n        v = self.dic.pop(key) \\n        self.dic[key] = v   # set key as the newest one\\n        return v\\n\\n    def set(self, key, value):\\n        if key in self.dic:    \\n            self.dic.pop(key)\\n        else:\\n            if self.remain > 0:\\n                self.remain -= 1  \\n            else:  # self.dic is full\\n                self.dic.popitem(last=False) \\n        self.dic[key] = value",
                "codeTag": "Python3"
            },
            {
                "id": 352295,
                "title": "python3-doubly-linked-list-and-dictionary",
                "content": "*  The most frequent operation of the problem is changing the node position in the list. \\n     Change position of the node means two operations, delete and insert.\\n     Double linked list data structure takes constant time O(1) to insert or delete nodes a linked list by repointing the  previous and next pointer of the node.\\n     [Array data structure takes O(n) to insert or delete ](https://www.tutorialspoint.com/data_structures_algorithms/array_insertion_algorithm.htm) an element in the list by shifting all the element behind the position (backward for insertion, forward for deletion) by one.\\n   \\n * put : \\n\\tif the key is already in the cache, we update the value, remove the key node and insert the key node after the head;\\n\\tif the key is not in cache, if the cache is not full,we insert the new key node after the head. If the cache is full, we delete the node before the tail to make room for the new key node, and insert the new key node after the head.\\n* get:\\n\\treturn the value of the key.\\n\\tremove the key node.\\n\\tinsert the key node after the head.\\n\\t \\n\\n\\n```\\nclass ListNode:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.value = value\\n        self.prev = None\\n        self.next = None\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.dic = dict() # key to node\\n        self.capacity = capacity\\n        self.head = ListNode(0, 0)\\n        self.tail = ListNode(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key: int) -> int:\\n        if key in self.dic:\\n            node = self.dic[key]\\n            self.removeFromList(node)\\n            self.insertIntoHead(node)\\n            return node.value\\n        else:\\n            return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.dic:             # similar to get()        \\n            node = self.dic[key]\\n            self.removeFromList(node)\\n            self.insertIntoHead(node)\\n            node.value = value         # replace the value len(dic)\\n        else: \\n            if len(self.dic) >= self.capacity:\\n                self.removeFromTail()\\n            node = ListNode(key,value)\\n            self.dic[key] = node\\n            self.insertIntoHead(node)\\n\\t\\t\\t\\n    def removeFromList(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n    \\n    def insertIntoHead(self, node):\\n        headNext = self.head.next \\n        self.head.next = node \\n        node.prev = self.head \\n        node.next = headNext \\n        headNext.prev = node\\n    \\n    def removeFromTail(self):\\n        if len(self.dic) == 0: return\\n        tail_node = self.tail.prev\\n        del self.dic[tail_node.key]\\n        self.removeFromList(tail_node)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.value = value\\n        self.prev = None\\n        self.next = None\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.dic = dict() # key to node\\n        self.capacity = capacity\\n        self.head = ListNode(0, 0)\\n        self.tail = ListNode(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key: int) -> int:\\n        if key in self.dic:\\n            node = self.dic[key]\\n            self.removeFromList(node)\\n            self.insertIntoHead(node)\\n            return node.value\\n        else:\\n            return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.dic:             # similar to get()        \\n            node = self.dic[key]\\n            self.removeFromList(node)\\n            self.insertIntoHead(node)\\n            node.value = value         # replace the value len(dic)\\n        else: \\n            if len(self.dic) >= self.capacity:\\n                self.removeFromTail()\\n            node = ListNode(key,value)\\n            self.dic[key] = node\\n            self.insertIntoHead(node)\\n\\t\\t\\t\\n    def removeFromList(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n    \\n    def insertIntoHead(self, node):\\n        headNext = self.head.next \\n        self.head.next = node \\n        node.prev = self.head \\n        node.next = headNext \\n        headNext.prev = node\\n    \\n    def removeFromTail(self):\\n        if len(self.dic) == 0: return\\n        tail_node = self.tail.prev\\n        del self.dic[tail_node.key]\\n        self.removeFromList(tail_node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399146,
                "title": "clean-javascript-solution",
                "content": "```\\nclass LRUCache {\\n  constructor(capacity) {\\n    this.cache = new Map();\\n    this.capacity = capacity;\\n  }\\n\\n  get(key) {\\n    if (!this.cache.has(key)) return -1;\\n\\n    const v = this.cache.get(key);\\n    this.cache.delete(key);\\n    this.cache.set(key, v);\\n    return this.cache.get(key);\\n  };\\n\\n  put(key, value) {\\n    if (this.cache.has(key)) {\\n      this.cache.delete(key);\\n    }\\n    this.cache.set(key, value);\\n    if (this.cache.size > this.capacity) {\\n      this.cache.delete(this.cache.keys().next().value);  // keys().next().value returns first item\\'s key\\n    }\\n  };\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass LRUCache {\\n  constructor(capacity) {\\n    this.cache = new Map();\\n    this.capacity = capacity;\\n  }\\n\\n  get(key) {\\n    if (!this.cache.has(key)) return -1;\\n\\n    const v = this.cache.get(key);\\n    this.cache.delete(key);\\n    this.cache.set(key, v);\\n    return this.cache.get(key);\\n  };\\n\\n  put(key, value) {\\n    if (this.cache.has(key)) {\\n      this.cache.delete(key);\\n    }\\n    this.cache.set(key, value);\\n    if (this.cache.size > this.capacity) {\\n      this.cache.delete(this.cache.keys().next().value);  // keys().next().value returns first item\\'s key\\n    }\\n  };\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45960,
                "title": "an-elegant-c-solution",
                "content": "    class LRUCache {\\n    private:\\n        int capacity;\\n        list<int> recent;\\n        unordered_map<int, int> cache;\\n        unordered_map<int, list<int>::iterator> pos;\\n        void use(int key) {\\n            if (pos.find(key) != pos.end()) {\\n                recent.erase(pos[key]);\\n            } else if (recent.size() >= capacity) {\\n                int old = recent.back();\\n                recent.pop_back();\\n                cache.erase(old);\\n                pos.erase(old);\\n            }\\n            recent.push_front(key);\\n            pos[key] = recent.begin();\\n        }\\n    public:\\n        LRUCache(int capacity): capacity(capacity) {}\\n        int get(int key) {\\n            if (cache.find(key) != cache.end()) {\\n                use(key);\\n                return cache[key];\\n            }\\n            return -1;\\n        }\\n        void set(int key, int value) {\\n            use(key);\\n            cache[key] = value;\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class LRUCache {\\n    private:\\n        int capacity;\\n        list<int> recent;\\n        unordered_map<int, int> cache;\\n        unordered_map<int, list<int>::iterator> pos;\\n        void use(int key) {\\n            if (pos.find(key) != pos.end()) {\\n                recent.erase(pos[key]);\\n            } else if (recent.size() >= capacity) {\\n                int old = recent.back();\\n                recent.pop_back();\\n                cache.erase(old);\\n                pos.erase(old);\\n            }\\n            recent.push_front(key);\\n            pos[key] = recent.begin();\\n        }\\n    public:\\n        LRUCache(int capacity): capacity(capacity) {}\\n        int get(int key) {\\n            if (cache.find(key) != cache.end()) {\\n                use(key);\\n                return cache[key];\\n            }\\n            return -1;\\n        }\\n        void set(int key, int value) {\\n            use(key);\\n            cache[key] = value;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1461942,
                "title": "c-detailed-solution-with-dry-run",
                "content": "Least Recently Used \\n\\n---\\n\\n__________________________________________________________________________________________________________\\n\\n**first of all figure out which Data Structues will help us :**\\n\\nas we have to perform these functions\\n\\n1:GET:\\n\\n       if key is  PRESENT:\\n\\n               then give the value associate with this this key \\n\\n               and this key-value pair updated to  currently used pair\\n\\n       if key is Absent :\\n\\t           return -1\\n\\n3: PUT:\\n\\n              \\n\\n       if key is  PRESENT :\\n\\n               update the key value pair \\n\\n       if key is Absent :\\n\\n              if the cache size full\\n\\n                    then remove the least recently pair and  put current pair \\n\\n                else\\n\\n                    put the current pair\\n\\n**NOW ,**  we can see that \\n\\n1:   we have to keep track of our keys so for this **unordered_map** will help us \\n\\n2: as we have to do **ADD, REMOVE , and Update operations .**\\n\\n   if we take ans **ARRAY**\\n\\n\\t  we can do add in o(1) , update in o(1) , but for remove we have to shift all the values after the removed index\\n\\t  \\n\\t  \\n\\n   if we take **SINGLY LINKED LIST:**\\n\\n         we can do add o(1), but for update and remove we need the previous pointer it will take o(N) \\n\\n   so we came to an end that ,\\n\\n         Doubly linked list   with the help of  Maps  are sufficient to achieve an efficient solution.\\n\\n__________________________________________________________________________________________________________\\n\\nAdditional functions :\\n\\n1. **insert_helper :** helps to insert a node in the front of list \\n2. **remove_helper:** helps to remove a node from the list;\\n\\n__________________________________________________________________________________________________________\\n\\n  **Now move to algorithm:**\\n\\n1. we create a Doubly linked list with the help of given **key , value.** with two **dummy nodes** as head , tail to keep track starting and ending node of list\\n2. we create a  unordered map with the key as integer and value as a node of our list \\n3. for **PUT** function.\\n\\n        1:  check in the map if the key is present or not .\\n\\n               \\u2014 if the key is present :\\n\\n                    a: first we remove the node with the help of \\n\\n                         remove_helper\\n\\n                     b: add this removed node in front of list with the help        \\n\\n                          of insert_helper (insert at front)\\n\\n                     c: update the the map accordingy.\\n\\n                \\u2014 key is  not present :\\n\\n                       Now check the size of our cache\\n\\n                        \\u2014 if the size is FULL:\\n\\n                                 then we remove the least recently node [which is the previous node of tail as as per our approach]\\n\\n                                 and add the new node which store the given information.\\n\\n                        \\u2014else \\n                                    simply add the new node with the given information.\\n\\n1. for **GET** function. \\n\\n                \\u2014 check in our map if the required key is present or not .\\n\\n                          if the required key is present \\n\\n                                     a: give the value of required key with the help of map.\\n\\n                                     b: we also update this node as the recently used for this we simple first remove this node and again add in front with the help of our additionals  funcitons.\\n\\n                           \\u2014 if not present\\n\\n                                     return -1;\\n\\n__________________________________________________________________________________________________________\\n\\n```\\n\\nclass LRUCache {\\npublic:\\n    \\n    class node{\\n        public:\\n        int key;\\n        int val;\\n        node* next;\\n        node* prev;\\n        \\n        node( int key , int val)\\n        {\\n            this->key = key;\\n            this->val=val;\\n            this->next=NULL;\\n            this->prev=NULL;\\n            \\n        }\\n    };\\n\\n    unordered_map<int,node*>mp;\\n    int capacity;\\n   \\n//two dummy nodes to keep track starting and ending point of list  \\n    node * head = new node(0,0);\\n    node * tail = new node(0,0);\\n    \\n\\n    \\n    LRUCache(int capacity)\\n    {\\n        this->capacity = capacity;\\n        head->next=tail;\\n        tail->prev= head;\\n        \\n    }\\n    \\n// function to help a node in the next to head [can say front of our list]\\n    void insert ( node* currnode)\\n    {\\n        currnode->next = head->next;                      // adding node in next of head (front of our cache)\\n        head->next->prev = currnode;\\n        head->next= currnode;\\n        currnode->prev= head;\\n        mp[currnode->key]=currnode;                       //update map accordingly\\n    }\\n    \\n   \\n// function to remove a node \\n    void remove(node* currnode)\\n    {\\n        mp.erase(currnode->key);\\n        currnode->next->prev =currnode->prev;\\n        currnode->prev->next=currnode->next;\\n       \\n    }\\n  \\n  \\n    int get(int key) \\n    {\\n       // if key is not present than return -1;\\n        if(mp.find(key)==mp.end())\\n        {\\n            return -1;\\n        }\\n        //if key is present , than update the node and return the value associated with the key\\n        // for update first we remove the node and then add at start of list with the help of insert function\\n        node *currnode = mp[key];\\n        remove(currnode);\\n        insert(currnode);\\n        return currnode->val;\\n        \\n    }\\n    \\n    void put(int key, int value)\\n    {\\n       //if key is already present than we have to update it \\n       // similiary we first remove and then add node in front with the help of insert helper \\n        if(mp.find(key)!=mp.end())\\n        {\\n            remove(mp[key]);\\n        }\\n        \\n        // if size is full then we have to remove the least recently used node\\n        if(mp.size()==capacity)\\n        {\\n            remove(tail->prev);\\n        }\\n        insert(new node(key,value));\\n        \\n    }\\n};\\n```\\n\\n\\nlet\\'s do a dry run with the help of given test case:\\n\\ngo to this ppt for  a dry run :\\n\\n[https://docs.google.com/presentation/d/1pXQ50S65Fnmyo93HqA503m3uwxwDspFPlLZRoto_7t4/edit?usp=sharing](https://docs.google.com/presentation/d/1pXQ50S65Fnmyo93HqA503m3uwxwDspFPlLZRoto_7t4/edit?usp=sharing)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass LRUCache {\\npublic:\\n    \\n    class node{\\n        public:\\n        int key;\\n        int val;\\n        node* next;\\n        node* prev;\\n        \\n        node( int key , int val)\\n        {\\n            this->key = key;\\n            this->val=val;\\n            this->next=NULL;\\n            this->prev=NULL;\\n            \\n        }\\n    };\\n\\n    unordered_map<int,node*>mp;\\n    int capacity;\\n   \\n//two dummy nodes to keep track starting and ending point of list  \\n    node * head = new node(0,0);\\n    node * tail = new node(0,0);\\n    \\n\\n    \\n    LRUCache(int capacity)\\n    {\\n        this->capacity = capacity;\\n        head->next=tail;\\n        tail->prev= head;\\n        \\n    }\\n    \\n// function to help a node in the next to head [can say front of our list]\\n    void insert ( node* currnode)\\n    {\\n        currnode->next = head->next;                      // adding node in next of head (front of our cache)\\n        head->next->prev = currnode;\\n        head->next= currnode;\\n        currnode->prev= head;\\n        mp[currnode->key]=currnode;                       //update map accordingly\\n    }\\n    \\n   \\n// function to remove a node \\n    void remove(node* currnode)\\n    {\\n        mp.erase(currnode->key);\\n        currnode->next->prev =currnode->prev;\\n        currnode->prev->next=currnode->next;\\n       \\n    }\\n  \\n  \\n    int get(int key) \\n    {\\n       // if key is not present than return -1;\\n        if(mp.find(key)==mp.end())\\n        {\\n            return -1;\\n        }\\n        //if key is present , than update the node and return the value associated with the key\\n        // for update first we remove the node and then add at start of list with the help of insert function\\n        node *currnode = mp[key];\\n        remove(currnode);\\n        insert(currnode);\\n        return currnode->val;\\n        \\n    }\\n    \\n    void put(int key, int value)\\n    {\\n       //if key is already present than we have to update it \\n       // similiary we first remove and then add node in front with the help of insert helper \\n        if(mp.find(key)!=mp.end())\\n        {\\n            remove(mp[key]);\\n        }\\n        \\n        // if size is full then we have to remove the least recently used node\\n        if(mp.size()==capacity)\\n        {\\n            remove(tail->prev);\\n        }\\n        insert(new node(key,value));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780815,
                "title": "dll-map-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe intuition is to maintain a fixed-size cache of key-value pairs using a doubly linked list and an unordered map. When accessing or adding a key-value pair, it moves the corresponding node to the front of the linked list, making it the most recently used item. This way, the least recently used item is always at the end of the list. When the cache is full and a new item is added, it removes the item at the end of the list (least recently used) to make space for the new item, ensuring the LRU property is maintained.\\n\\n# Explanation:\\n\\n1. `Node` Class:\\n- This is a nested class representing a doubly linked list node.\\n- Each node contains an integer key, an integer value, and pointers to the previous and next nodes in the linked list.\\n\\n2. `LRUCache` Class:\\n- This is the main LRU Cache class.\\n- It has a fixed capacity (`cap`) that is specified during its instantiation.\\n- It uses an `unordered_map<int, Node*>` named `m` to store key-value pairs, where the key is the integer key, and the value is a pointer to the corresponding `Node`.\\n\\n3. `head` and `tail` Nodes:\\n- The `LRUCache` class has two dummy nodes: `head` and `tail`.\\n- These nodes act as sentinels in the doubly linked list, helping to simplify the edge cases and avoid dealing with null pointers.\\n- `head` is the first node in the linked list, and `tail` is the last node.\\n\\n4. `addNode` Function:\\n- This function is used to add a new node to the front of the doubly linked list (right after `head`).\\n- It takes a `Node* newnode` as input, representing the node to be added.\\n- The function updates the pointers of the new node, the previous first node, and `head` to include the new node as the new first node.\\n\\n5. `deleteNode` Function:\\n- This function is used to delete a node from the doubly linked list.\\n- It takes a `Node* delnode` as input, representing the node to be deleted.\\n- The function updates the pointers of the previous and next nodes to exclude the node to be deleted, effectively removing it from the linked list.\\n\\n6. `get` Function:\\n- This function is used to retrieve a value from the cache based on the given key.\\n- If the key exists in the cache (`m.find(key) != m.end()`), it retrieves the corresponding node (`resNode`), extracts its value (`ans`), and performs the following steps:\\n  - Erase the key-value pair from the `m` unordered map.\\n  - Delete the node from its current position in the linked list using `deleteNode`.\\n  - Add the node to the front of the linked list using `addNode`, making it the most recently used node.\\n  - Update the `m` map to store the key with the most recently used node.\\n- If the key doesn\\'t exist in the cache, it returns `-1`.\\n\\n7. `put` Function:\\n- This function is used to insert or update a key-value pair in the cache.\\n- If the key already exists in the cache, it updates the value by performing the following steps:\\n  - Erase the existing key-value pair from the `m` unordered map.\\n  - Delete the corresponding node from its current position in the linked list using `deleteNode`.\\n- If the cache is full (i.e., `m.size() == cap`), it removes the least recently used node from the cache by erasing the key-value pair from the `m` map and deleting the node from the end of the linked list using `deleteNode`.\\n- After handling the eviction (if needed), it creates a new node using `new Node(key, value)` and adds it to the front of the linked list using `addNode`.\\n- Finally, it updates the `m` map to store the key with the newly added node.\\n\\n# Code\\n```C++ []\\nclass LRUCache {\\npublic:\\n    class Node{\\n        public: \\n            int key;\\n            int val;\\n            Node* prev;\\n            Node* next;\\n\\n            Node(int key, int val){\\n                this->key = key;\\n                this->val = val;\\n            }\\n    };\\n\\n    Node* head = new Node(-1, -1);\\n    Node* tail = new Node(-1, -1);\\n\\n    int cap;\\n    unordered_map<int, Node*> m;\\n\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n        head -> next = tail;\\n        tail -> prev = head;\\n    }\\n\\n    void addNode(Node* newnode){\\n        Node* temp = head -> next;\\n\\n        newnode -> next = temp;\\n        newnode -> prev = head;\\n\\n        head -> next = newnode;\\n        temp -> prev = newnode;\\n    }\\n\\n    void deleteNode(Node* delnode){\\n        Node* prevv = delnode -> prev;\\n        Node* nextt = delnode -> next;\\n\\n        prevv -> next = nextt;\\n        nextt -> prev = prevv;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key) != m.end()){\\n            Node* resNode = m[key];\\n            int ans = resNode -> val;\\n\\n            m.erase(key);\\n            deleteNode(resNode);\\n            addNode(resNode);\\n\\n            m[key] = head -> next;\\n            return ans;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.find(key) != m.end()){\\n            Node* curr = m[key];\\n            m.erase(key);\\n            deleteNode(curr);\\n        }\\n\\n        if(m.size() == cap){\\n            m.erase(tail -> prev -> key);\\n            deleteNode(tail -> prev);\\n        }\\n\\n        addNode(new Node(key, value));\\n        m[key] = head -> next;\\n    }\\n};\\n```\\n```Java []\\nclass LRUCache {\\n    class Node {\\n        int key;\\n        int val;\\n        Node prev;\\n        Node next;\\n\\n        Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }\\n\\n    Node head = new Node(-1, -1);\\n    Node tail = new Node(-1, -1);\\n    int cap;\\n    HashMap<Integer, Node> m = new HashMap<>();\\n\\n    public LRUCache(int capacity) {\\n        cap = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    private void addNode(Node newnode) {\\n        Node temp = head.next;\\n\\n        newnode.next = temp;\\n        newnode.prev = head;\\n\\n        head.next = newnode;\\n        temp.prev = newnode;\\n    }\\n\\n    private void deleteNode(Node delnode) {\\n        Node prevv = delnode.prev;\\n        Node nextt = delnode.next;\\n\\n        prevv.next = nextt;\\n        nextt.prev = prevv;\\n    }\\n\\n    public int get(int key) {\\n        if (m.containsKey(key)) {\\n            Node resNode = m.get(key);\\n            int ans = resNode.val;\\n\\n            m.remove(key);\\n            deleteNode(resNode);\\n            addNode(resNode);\\n\\n            m.put(key, head.next);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n\\n    public void put(int key, int value) {\\n        if (m.containsKey(key)) {\\n            Node curr = m.get(key);\\n            m.remove(key);\\n            deleteNode(curr);\\n        }\\n\\n        if (m.size() == cap) {\\n            m.remove(tail.prev.key);\\n            deleteNode(tail.prev);\\n        }\\n\\n        addNode(new Node(key, value));\\n        m.put(key, head.next);\\n    }\\n}\\n```\\n```Python3 []\\nclass LRUCache:\\n    class Node:\\n        def __init__(self, key, val):\\n            self.key = key\\n            self.val = val\\n            self.prev = None\\n            self.next = None\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.head = self.Node(-1, -1)\\n        self.tail = self.Node(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.m = {}\\n\\n    def addNode(self, newnode):\\n        temp = self.head.next\\n        newnode.next = temp\\n        newnode.prev = self.head\\n        self.head.next = newnode\\n        temp.prev = newnode\\n\\n    def deleteNode(self, delnode):\\n        prevv = delnode.prev\\n        nextt = delnode.next\\n        prevv.next = nextt\\n        nextt.prev = prevv\\n\\n    def get(self, key: int) -> int:\\n        if key in self.m:\\n            resNode = self.m[key]\\n            ans = resNode.val\\n            del self.m[key]\\n            self.deleteNode(resNode)\\n            self.addNode(resNode)\\n            self.m[key] = self.head.next\\n            return ans\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.m:\\n            curr = self.m[key]\\n            del self.m[key]\\n            self.deleteNode(curr)\\n\\n        if len(self.m) == self.cap:\\n            del self.m[self.tail.prev.key]\\n            self.deleteNode(self.tail.prev)\\n\\n        self.addNode(self.Node(key, value))\\n        self.m[key] = self.head.next\\n```\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Doubly-Linked List"
                ],
                "code": "```C++ []\\nclass LRUCache {\\npublic:\\n    class Node{\\n        public: \\n            int key;\\n            int val;\\n            Node* prev;\\n            Node* next;\\n\\n            Node(int key, int val){\\n                this->key = key;\\n                this->val = val;\\n            }\\n    };\\n\\n    Node* head = new Node(-1, -1);\\n    Node* tail = new Node(-1, -1);\\n\\n    int cap;\\n    unordered_map<int, Node*> m;\\n\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n        head -> next = tail;\\n        tail -> prev = head;\\n    }\\n\\n    void addNode(Node* newnode){\\n        Node* temp = head -> next;\\n\\n        newnode -> next = temp;\\n        newnode -> prev = head;\\n\\n        head -> next = newnode;\\n        temp -> prev = newnode;\\n    }\\n\\n    void deleteNode(Node* delnode){\\n        Node* prevv = delnode -> prev;\\n        Node* nextt = delnode -> next;\\n\\n        prevv -> next = nextt;\\n        nextt -> prev = prevv;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key) != m.end()){\\n            Node* resNode = m[key];\\n            int ans = resNode -> val;\\n\\n            m.erase(key);\\n            deleteNode(resNode);\\n            addNode(resNode);\\n\\n            m[key] = head -> next;\\n            return ans;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.find(key) != m.end()){\\n            Node* curr = m[key];\\n            m.erase(key);\\n            deleteNode(curr);\\n        }\\n\\n        if(m.size() == cap){\\n            m.erase(tail -> prev -> key);\\n            deleteNode(tail -> prev);\\n        }\\n\\n        addNode(new Node(key, value));\\n        m[key] = head -> next;\\n    }\\n};\\n```\n```Java []\\nclass LRUCache {\\n    class Node {\\n        int key;\\n        int val;\\n        Node prev;\\n        Node next;\\n\\n        Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }\\n\\n    Node head = new Node(-1, -1);\\n    Node tail = new Node(-1, -1);\\n    int cap;\\n    HashMap<Integer, Node> m = new HashMap<>();\\n\\n    public LRUCache(int capacity) {\\n        cap = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    private void addNode(Node newnode) {\\n        Node temp = head.next;\\n\\n        newnode.next = temp;\\n        newnode.prev = head;\\n\\n        head.next = newnode;\\n        temp.prev = newnode;\\n    }\\n\\n    private void deleteNode(Node delnode) {\\n        Node prevv = delnode.prev;\\n        Node nextt = delnode.next;\\n\\n        prevv.next = nextt;\\n        nextt.prev = prevv;\\n    }\\n\\n    public int get(int key) {\\n        if (m.containsKey(key)) {\\n            Node resNode = m.get(key);\\n            int ans = resNode.val;\\n\\n            m.remove(key);\\n            deleteNode(resNode);\\n            addNode(resNode);\\n\\n            m.put(key, head.next);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n\\n    public void put(int key, int value) {\\n        if (m.containsKey(key)) {\\n            Node curr = m.get(key);\\n            m.remove(key);\\n            deleteNode(curr);\\n        }\\n\\n        if (m.size() == cap) {\\n            m.remove(tail.prev.key);\\n            deleteNode(tail.prev);\\n        }\\n\\n        addNode(new Node(key, value));\\n        m.put(key, head.next);\\n    }\\n}\\n```\n```Python3 []\\nclass LRUCache:\\n    class Node:\\n        def __init__(self, key, val):\\n            self.key = key\\n            self.val = val\\n            self.prev = None\\n            self.next = None\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.head = self.Node(-1, -1)\\n        self.tail = self.Node(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.m = {}\\n\\n    def addNode(self, newnode):\\n        temp = self.head.next\\n        newnode.next = temp\\n        newnode.prev = self.head\\n        self.head.next = newnode\\n        temp.prev = newnode\\n\\n    def deleteNode(self, delnode):\\n        prevv = delnode.prev\\n        nextt = delnode.next\\n        prevv.next = nextt\\n        nextt.prev = prevv\\n\\n    def get(self, key: int) -> int:\\n        if key in self.m:\\n            resNode = self.m[key]\\n            ans = resNode.val\\n            del self.m[key]\\n            self.deleteNode(resNode)\\n            self.addNode(resNode)\\n            self.m[key] = self.head.next\\n            return ans\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.m:\\n            curr = self.m[key]\\n            del self.m[key]\\n            self.deleteNode(curr)\\n\\n        if len(self.m) == self.cap:\\n            del self.m[self.tail.prev.key]\\n            self.deleteNode(self.tail.prev)\\n\\n        self.addNode(self.Node(key, value))\\n        self.m[key] = self.head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860350,
                "title": "super-simple-c-lru-cache-solution",
                "content": "```\\nclass LRUCache {\\npublic:\\n    unordered_map<int, pair<list<int>::iterator, int>> ht;\\n    list<int> dll;\\n    int cap;\\n    LRUCache(int capacity) {\\n        cap=capacity;\\n    }\\n    \\n    void moveToFirst(int key){\\n        dll.erase(ht[key].first);\\n        dll.push_front(key);\\n        ht[key].first=dll.begin();\\n    }\\n    \\n    int get(int key) {\\n        if(ht.find(key)==ht.end()) return -1;\\n        \\n        moveToFirst(key);\\n        return ht[key].second;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(ht.find(key)!=ht.end()){\\n            ht[key].second=value;\\n            moveToFirst(key);\\n        }\\n        else{\\n            dll.push_front(key);\\n            ht[key]={dll.begin(), value};\\n            cap--;\\n        }\\n        \\n        if(cap<0){\\n            ht.erase(dll.back());\\n            dll.pop_back();\\n            cap++;\\n        }\\n        \\n    }\\n};\\n\\n/*\\nAlgorithm Outline:\\n\\nLRUCache()\\n1. key -> (addr, value)\\n2. List, will contain keys\\n3. cap=capacity\\n\\nGet\\n1. if found, movetofirst for key, return. Else -1\\n\\nPut\\n1. if exist, update.\\n2. else add\\n3. move to first\\n4. if >capacity, remove last in list i.e. LRU\\n\\nMove to first\\n1. erase element\\n2. add to first\\n3. store first addr in ht\\n */\\n ```\\n I appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    unordered_map<int, pair<list<int>::iterator, int>> ht;\\n    list<int> dll;\\n    int cap;\\n    LRUCache(int capacity) {\\n        cap=capacity;\\n    }\\n    \\n    void moveToFirst(int key){\\n        dll.erase(ht[key].first);\\n        dll.push_front(key);\\n        ht[key].first=dll.begin();\\n    }\\n    \\n    int get(int key) {\\n        if(ht.find(key)==ht.end()) return -1;\\n        \\n        moveToFirst(key);\\n        return ht[key].second;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(ht.find(key)!=ht.end()){\\n            ht[key].second=value;\\n            moveToFirst(key);\\n        }\\n        else{\\n            dll.push_front(key);\\n            ht[key]={dll.begin(), value};\\n            cap--;\\n        }\\n        \\n        if(cap<0){\\n            ht.erase(dll.back());\\n            dll.pop_back();\\n            cap++;\\n        }\\n        \\n    }\\n};\\n\\n/*\\nAlgorithm Outline:\\n\\nLRUCache()\\n1. key -> (addr, value)\\n2. List, will contain keys\\n3. cap=capacity\\n\\nGet\\n1. if found, movetofirst for key, return. Else -1\\n\\nPut\\n1. if exist, update.\\n2. else add\\n3. move to first\\n4. if >capacity, remove last in list i.e. LRU\\n\\nMove to first\\n1. erase element\\n2. add to first\\n3. store first addr in ht\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2606056,
                "title": "python-explained-steps-clean-code-best-method",
                "content": "To solve this problem efficiently we have to use **OrderedDict**.\\n\\nIn **get** method we have to return **-1** if key is not in our **dict**. If it does, then we have to move our key, value pair to the end of our dict. Now it is our **most recent** key, value pair.\\n\\nIn **put** method if key is not in our **dict** and we would go above **capacity**, then we remove first item in our dict by **.popitem(last=False)** method. \\n\\nIf we only update value of the existed key, then we have to pop the value from the **dict** and then assign the value, to put the key, value pair at the end of our **dict** (so we make the key, value pair **most recent one**).\\n\\nCode:\\n```\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.values = OrderedDict()\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.values:\\n            return -1\\n        else:\\n            self.values[key] = self.values.pop(key)\\n            return self.values[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.values:\\n            if len(self.values) == self.capacity:\\n                self.values.popitem(last=False)\\n        else:\\n            self.values.pop(key)\\n        self.values[key] = value\\n```\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.values = OrderedDict()\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.values:\\n            return -1\\n        else:\\n            self.values[key] = self.values.pop(key)\\n            return self.values[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.values:\\n            if len(self.values) == self.capacity:\\n                self.values.popitem(last=False)\\n        else:\\n            self.values.pop(key)\\n        self.values[key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617415,
                "title": "javascript-2-solutions-es6-map-vs-doubly-linked-list",
                "content": "## Solution 1 - Using ES6 Map\\n```javascript\\nclass LRUCache {\\n    constructor(capacity) {\\n        this.map = new Map();\\n        this.capacity = capacity;\\n    }\\n\\n    get(key) {\\n        if (!this.map.has(key)) return -1;\\n        const val = this.map.get(key);\\n        this.map.delete(key);\\n        this.map.set(key, val);\\n        return val;\\n    }\\n\\n    put(key, value) {\\n        this.map.delete(key);\\n        this.map.set(key, value);\\n        if (this.map.size > this.capacity) {\\n          const firstItem = this.map.keys().next().value;\\n          this.map.delete(firstItem);\\n        }\\n    }\\n}\\n```\\n\\n## Solution 2 - Using Object and Doubly linked list\\n```javascript\\nclass Node {\\n  constructor(key, val) {\\n      this.key = key;\\n      this.val = val;\\n      this.next = null;\\n      this.prev = null;\\n  }\\n}\\n\\nclass DoublyLinkedList {\\n  constructor() {\\n      this.head = null;\\n      this.tail = null;\\n      this.length = 0;\\n  }\\n  \\n  push(key, val) {\\n      const newNode = new Node(key, val);\\n      if(!this.head) {\\n          this.head = newNode;\\n          this.tail = newNode;\\n      } else {\\n          this.tail.next = newNode;\\n          newNode.prev = this.tail;\\n          this.tail = newNode;\\n      }\\n      this.length++;\\n      return newNode;\\n  }\\n  \\n  remove(node) {\\n      if(!node.next && !node.prev) { // if there\\'s only 1 node\\n          this.head = null;\\n          this.tail = null;\\n      } else if(!node.next) { // if the node is tail node\\n          this.tail = node.prev;\\n          this.tail.next = null;\\n      } else if(!node.prev) { // if the node is head node\\n          this.head = node.next;\\n          this.head.prev = null;\\n      } else { // if the node is in between\\n          const prev = node.prev;\\n          const next = node.next;\\n          prev.next = next;\\n          next.prev = prev;\\n      }\\n      this.length--;\\n  }\\n}\\n\\nclass LRUCache {\\n  constructor(capacity) {\\n      this.DLL = new DoublyLinkedList();\\n      this.map = {};\\n      this.capacity = capacity;\\n  }\\n\\n  get(key) {\\n      if(!this.map[key]) return -1;\\n      const value = this.map[key].val;\\n      this.DLL.remove(this.map[key]);\\n      this.map[key] = this.DLL.push(key, value);\\n      return value;\\n  }\\n\\n  put(key, value) {\\n      if(this.map[key]) this.DLL.remove(this.map[key]);\\n      this.map[key] = this.DLL.push(key, value);\\n      if(this.DLL.length > this.capacity) {\\n          const currKey = this.DLL.head.key;\\n          delete this.map[currKey];\\n          this.DLL.remove(this.DLL.head);\\n      }\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```javascript\\nclass LRUCache {\\n    constructor(capacity) {\\n        this.map = new Map();\\n        this.capacity = capacity;\\n    }\\n\\n    get(key) {\\n        if (!this.map.has(key)) return -1;\\n        const val = this.map.get(key);\\n        this.map.delete(key);\\n        this.map.set(key, val);\\n        return val;\\n    }\\n\\n    put(key, value) {\\n        this.map.delete(key);\\n        this.map.set(key, value);\\n        if (this.map.size > this.capacity) {\\n          const firstItem = this.map.keys().next().value;\\n          this.map.delete(firstItem);\\n        }\\n    }\\n}\\n```\n```javascript\\nclass Node {\\n  constructor(key, val) {\\n      this.key = key;\\n      this.val = val;\\n      this.next = null;\\n      this.prev = null;\\n  }\\n}\\n\\nclass DoublyLinkedList {\\n  constructor() {\\n      this.head = null;\\n      this.tail = null;\\n      this.length = 0;\\n  }\\n  \\n  push(key, val) {\\n      const newNode = new Node(key, val);\\n      if(!this.head) {\\n          this.head = newNode;\\n          this.tail = newNode;\\n      } else {\\n          this.tail.next = newNode;\\n          newNode.prev = this.tail;\\n          this.tail = newNode;\\n      }\\n      this.length++;\\n      return newNode;\\n  }\\n  \\n  remove(node) {\\n      if(!node.next && !node.prev) { // if there\\'s only 1 node\\n          this.head = null;\\n          this.tail = null;\\n      } else if(!node.next) { // if the node is tail node\\n          this.tail = node.prev;\\n          this.tail.next = null;\\n      } else if(!node.prev) { // if the node is head node\\n          this.head = node.next;\\n          this.head.prev = null;\\n      } else { // if the node is in between\\n          const prev = node.prev;\\n          const next = node.next;\\n          prev.next = next;\\n          next.prev = prev;\\n      }\\n      this.length--;\\n  }\\n}\\n\\nclass LRUCache {\\n  constructor(capacity) {\\n      this.DLL = new DoublyLinkedList();\\n      this.map = {};\\n      this.capacity = capacity;\\n  }\\n\\n  get(key) {\\n      if(!this.map[key]) return -1;\\n      const value = this.map[key].val;\\n      this.DLL.remove(this.map[key]);\\n      this.map[key] = this.DLL.push(key, value);\\n      return value;\\n  }\\n\\n  put(key, value) {\\n      if(this.map[key]) this.DLL.remove(this.map[key]);\\n      this.map[key] = this.DLL.push(key, value);\\n      if(this.DLL.length > this.capacity) {\\n          const currKey = this.DLL.head.key;\\n          delete this.map[currKey];\\n          this.DLL.remove(this.DLL.head);\\n      }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46117,
                "title": "least-recently-used-let-s-pay-attention-to-the-word-recently-don-t-be-confused",
                "content": "Just want to emphasize the word \"Recently\". It is not the most visited. So thinking using priority queue or double linked list can be helpful. Don't waste time implementing codes based on wrong understanding... like me...\\nFor example,\\n\\n    capacity = 2\\n    set(2,1)\\n    set(2,2)\\n    get(2)\\n    set(1,1)\\n    set(4,1)\\n    get(2)\\n\\nSo what happened when set(4,1) is executed?\\n2 is deleted, 1 is still there, because 1 is more \"Recently\" than 2.\\n\\nHope this can help someone has misunderstanding on this problem.",
                "solutionTags": [],
                "code": "Just want to emphasize the word \"Recently\". It is not the most visited. So thinking using priority queue or double linked list can be helpful. Don't waste time implementing codes based on wrong understanding... like me...\\nFor example,\\n\\n    capacity = 2\\n    set(2,1)\\n    set(2,2)\\n    get(2)\\n    set(1,1)\\n    set(4,1)\\n    get(2)\\n\\nSo what happened when set(4,1) is executed?\\n2 is deleted, 1 is still there, because 1 is more \"Recently\" than 2.\\n\\nHope this can help someone has misunderstanding on this problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 3780778,
                "title": "100-fast-very-easily-line-by-line-explained-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere to get s key value we can think of map and to get prev and next in O(1) time we can think of doubly linked list. arrays or vector cant be used because delete operation is costier here.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtube.com/@LetsCodeTogether72?sub_confirmation=1\\n or link in the comment section.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n or \\nsearch `Lru cache by Lets Code Together` on youtube\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are storing element in doubly linked list and we are maintaining the order like last recently used will at first ,after that second last recently used so the least recently used will be stored at last and we are taking map which will store the location of the key .it will help in deleting the key and getting the value of the key.\\n\\n\\n\\n1. when we get the key it will become last used.if the key is not present directly return -1.if key is present so we have to insert at first just after head.so now we need hashmap to store location of the node.so we can acces and dlete from that location and store just after head and update location of key to m[key]=head->next.\\n\\n2. if size of lru catche data structure is less than capacity then there can be two possibilities.\\n\\n   1. may be key is present so we insert it just next to head and delete from the previous location and update the location of key in map i.e m[key]=head->next.\\n   \\n   2. may be key is not present then we will directly insert just after head i.e at first and store the location in map m[key]=head->next.\\n   \\n     here we are always inserting in the order of \\n        ->last used ->second last used ->third last used->least used \\n\\n3. if the size is equal to capacity so we have to maintain it so here can be two option \\n    1.  Element we are inserting is present so we delete   the  node from double linked list and with help of map and insert just after head saying that it is last used  and also update the location of the key.\\n    2.  Element is not present in the cache so to maintain capacity we will delete the least used which will be stored at last i.e before tail .so we will delete that node from there and the new node should be inserted at first i.e just after head and also delete that key from map.\\n\\n\\nstarting configuration of doubly linked list.\\n\\nDoubly linked list\\nhead<-->tail\\n\\n# Complexity\\n- Time complexity:$$O(1)$$ Average get and put\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Node{\\n    public:\\n    int key;\\n    int val;\\n    Node*next;\\n    Node*prev;\\n    Node(int key,int val){\\n        this->key=key;\\n        this->val=val;\\n        next=NULL;\\n        prev=NULL;\\n    }\\n};\\nclass LRUCache {\\npublic:\\n    unordered_map<int,Node*>m;\\n    Node*head=new Node(-1,-1);\\n    Node*tail=new Node(-1,-1);\\n    int size;\\n    LRUCache(int capacity) {\\n           size=capacity;\\n            head->next=tail;\\n             tail->prev=head;\\n    }\\n    void deleteNode(Node*p){\\n       Node*pre=p->prev;\\n       Node*nex=p->next;\\n       pre->next=nex;\\n       nex->prev=pre;\\n    }\\n    void addNode(Node*newnode){\\n        Node*temp=head->next;\\n        head->next=newnode;\\n        newnode->prev=head;\\n        newnode->next=temp;\\n        temp->prev=newnode;\\n    }\\n    int get(int key) {\\n        if(m.find(key)==m.end())\\n        return -1;\\n        Node*p=m[key];\\n        deleteNode(p);\\n        addNode(p);\\n        m[key]=head->next;\\n        return head->next->val;\\n    }\\n    \\n    void put(int key, int value) {\\n       if(m.find(key)!=m.end()){\\n            Node*c=m[key];\\n            deleteNode(c);\\n            c->val=value;\\n            addNode(c);\\n            m[key]=head->next;\\n        }\\n        else{\\n            if(m.size()==size){\\n                Node* prev=tail->prev;\\n                deleteNode(prev);\\n                Node*l=new Node(key,value);\\n                addNode(l);\\n                m.erase(prev->key);\\n                m[key]=head->next;\\n            }\\n            else{\\n                 Node*l=new Node(key,value);\\n                addNode(l);\\n                m[key]=head->next; \\n            }\\n        }\\n    }\\n};\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n```Java []\\nclass Node {\\n    public int key;\\n    public int val;\\n    public Node next;\\n    public Node prev;\\n\\n    public Node(int key, int val) {\\n        this.key = key;\\n        this.val = val;\\n        next = null;\\n        prev = null;\\n    }\\n}\\n\\nclass LRUCache {\\n    private Map<Integer, Node> m;\\n    private Node head;\\n    private Node tail;\\n    private int size;\\n\\n    public LRUCache(int capacity) {\\n        size = capacity;\\n        m = new HashMap<>();\\n        head = new Node(-1, -1);\\n        tail = new Node(-1, -1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    private void deleteNode(Node p) {\\n        Node pre = p.prev;\\n        Node nex = p.next;\\n        pre.next = nex;\\n        nex.prev = pre;\\n    }\\n\\n    private void addNode(Node newnode) {\\n        Node temp = head.next;\\n        head.next = newnode;\\n        newnode.prev = head;\\n        newnode.next = temp;\\n        temp.prev = newnode;\\n    }\\n\\n    public int get(int key) {\\n        if (!m.containsKey(key))\\n            return -1;\\n\\n        Node p = m.get(key);\\n        deleteNode(p);\\n        addNode(p);\\n        m.put(key, head.next);\\n        return head.next.val;\\n    }\\n\\n    public void put(int key, int value) {\\n        if (m.containsKey(key)) {\\n            Node c = m.get(key);\\n            deleteNode(c);\\n            c.val = value;\\n            addNode(c);\\n            m.put(key, head.next);\\n        } else {\\n            if (m.size() == size) {\\n                Node prev = tail.prev;\\n                deleteNode(prev);\\n                Node l = new Node(key, value);\\n                addNode(l);\\n                m.remove(prev.key);\\n                m.put(key, head.next);\\n            } else {\\n                Node l = new Node(key, value);\\n                addNode(l);\\n                m.put(key, head.next);\\n            }\\n        }\\n    }\\n}\\n\\n// Example usage:\\n// LRUCache cache = new LRUCache(capacity);\\n// int value = cache.get(key);\\n// cache.put(key, value);\\n\\n```\\n```Python []\\nclass Node:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n\\nclass LRUCache:\\n    def __init__(self, capacity):\\n        self.size = capacity\\n        self.m = {}\\n        self.head = Node(-1, -1)\\n        self.tail = Node(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def deleteNode(self, p):\\n        p.prev.next = p.next\\n        p.next.prev = p.prev\\n\\n    def addNode(self, newnode):\\n        temp = self.head.next\\n        self.head.next = newnode\\n        newnode.prev = self.head\\n        newnode.next = temp\\n        temp.prev = newnode\\n\\n    def get(self, key):\\n        if key not in self.m:\\n            return -1\\n\\n        p = self.m[key]\\n        self.deleteNode(p)\\n        self.addNode(p)\\n        self.m[key] = self.head.next\\n        return self.head.next.val\\n\\n    def put(self, key, value):\\n        if key in self.m:\\n            c = self.m[key]\\n            self.deleteNode(c)\\n            c.val = value\\n            self.addNode(c)\\n            self.m[key] = self.head.next\\n        else:\\n            if len(self.m) == self.size:\\n                prev = self.tail.prev\\n                self.deleteNode(prev)\\n                l = Node(key, value)\\n                self.addNode(l)\\n                del self.m[prev.key]\\n                self.m[key] = self.head.next\\n            else:\\n                l = Node(key, value)\\n                self.addNode(l)\\n                self.m[key] = self.head.next\\n\\n# Example usage:\\n# cache = LRUCache(capacity)\\n# value = cache.get(key)\\n# cache.put(key, value)\\n\\n```\\n\\n\\n\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/119d585b-554d-45cf-819c-38627aa55ead_1689643196.6033697.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```C++ []\\nclass Node{\\n    public:\\n    int key;\\n    int val;\\n    Node*next;\\n    Node*prev;\\n    Node(int key,int val){\\n        this->key=key;\\n        this->val=val;\\n        next=NULL;\\n        prev=NULL;\\n    }\\n};\\nclass LRUCache {\\npublic:\\n    unordered_map<int,Node*>m;\\n    Node*head=new Node(-1,-1);\\n    Node*tail=new Node(-1,-1);\\n    int size;\\n    LRUCache(int capacity) {\\n           size=capacity;\\n            head->next=tail;\\n             tail->prev=head;\\n    }\\n    void deleteNode(Node*p){\\n       Node*pre=p->prev;\\n       Node*nex=p->next;\\n       pre->next=nex;\\n       nex->prev=pre;\\n    }\\n    void addNode(Node*newnode){\\n        Node*temp=head->next;\\n        head->next=newnode;\\n        newnode->prev=head;\\n        newnode->next=temp;\\n        temp->prev=newnode;\\n    }\\n    int get(int key) {\\n        if(m.find(key)==m.end())\\n        return -1;\\n        Node*p=m[key];\\n        deleteNode(p);\\n        addNode(p);\\n        m[key]=head->next;\\n        return head->next->val;\\n    }\\n    \\n    void put(int key, int value) {\\n       if(m.find(key)!=m.end()){\\n            Node*c=m[key];\\n            deleteNode(c);\\n            c->val=value;\\n            addNode(c);\\n            m[key]=head->next;\\n        }\\n        else{\\n            if(m.size()==size){\\n                Node* prev=tail->prev;\\n                deleteNode(prev);\\n                Node*l=new Node(key,value);\\n                addNode(l);\\n                m.erase(prev->key);\\n                m[key]=head->next;\\n            }\\n            else{\\n                 Node*l=new Node(key,value);\\n                addNode(l);\\n                m[key]=head->next; \\n            }\\n        }\\n    }\\n};\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\n```Java []\\nclass Node {\\n    public int key;\\n    public int val;\\n    public Node next;\\n    public Node prev;\\n\\n    public Node(int key, int val) {\\n        this.key = key;\\n        this.val = val;\\n        next = null;\\n        prev = null;\\n    }\\n}\\n\\nclass LRUCache {\\n    private Map<Integer, Node> m;\\n    private Node head;\\n    private Node tail;\\n    private int size;\\n\\n    public LRUCache(int capacity) {\\n        size = capacity;\\n        m = new HashMap<>();\\n        head = new Node(-1, -1);\\n        tail = new Node(-1, -1);\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n\\n    private void deleteNode(Node p) {\\n        Node pre = p.prev;\\n        Node nex = p.next;\\n        pre.next = nex;\\n        nex.prev = pre;\\n    }\\n\\n    private void addNode(Node newnode) {\\n        Node temp = head.next;\\n        head.next = newnode;\\n        newnode.prev = head;\\n        newnode.next = temp;\\n        temp.prev = newnode;\\n    }\\n\\n    public int get(int key) {\\n        if (!m.containsKey(key))\\n            return -1;\\n\\n        Node p = m.get(key);\\n        deleteNode(p);\\n        addNode(p);\\n        m.put(key, head.next);\\n        return head.next.val;\\n    }\\n\\n    public void put(int key, int value) {\\n        if (m.containsKey(key)) {\\n            Node c = m.get(key);\\n            deleteNode(c);\\n            c.val = value;\\n            addNode(c);\\n            m.put(key, head.next);\\n        } else {\\n            if (m.size() == size) {\\n                Node prev = tail.prev;\\n                deleteNode(prev);\\n                Node l = new Node(key, value);\\n                addNode(l);\\n                m.remove(prev.key);\\n                m.put(key, head.next);\\n            } else {\\n                Node l = new Node(key, value);\\n                addNode(l);\\n                m.put(key, head.next);\\n            }\\n        }\\n    }\\n}\\n\\n// Example usage:\\n// LRUCache cache = new LRUCache(capacity);\\n// int value = cache.get(key);\\n// cache.put(key, value);\\n\\n```\n```Python []\\nclass Node:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n\\nclass LRUCache:\\n    def __init__(self, capacity):\\n        self.size = capacity\\n        self.m = {}\\n        self.head = Node(-1, -1)\\n        self.tail = Node(-1, -1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def deleteNode(self, p):\\n        p.prev.next = p.next\\n        p.next.prev = p.prev\\n\\n    def addNode(self, newnode):\\n        temp = self.head.next\\n        self.head.next = newnode\\n        newnode.prev = self.head\\n        newnode.next = temp\\n        temp.prev = newnode\\n\\n    def get(self, key):\\n        if key not in self.m:\\n            return -1\\n\\n        p = self.m[key]\\n        self.deleteNode(p)\\n        self.addNode(p)\\n        self.m[key] = self.head.next\\n        return self.head.next.val\\n\\n    def put(self, key, value):\\n        if key in self.m:\\n            c = self.m[key]\\n            self.deleteNode(c)\\n            c.val = value\\n            self.addNode(c)\\n            self.m[key] = self.head.next\\n        else:\\n            if len(self.m) == self.size:\\n                prev = self.tail.prev\\n                self.deleteNode(prev)\\n                l = Node(key, value)\\n                self.addNode(l)\\n                del self.m[prev.key]\\n                self.m[key] = self.head.next\\n            else:\\n                l = Node(key, value)\\n                self.addNode(l)\\n                self.m[key] = self.head.next\\n\\n# Example usage:\\n# cache = LRUCache(capacity)\\n# value = cache.get(key)\\n# cache.put(key, value)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594885,
                "title": "python-simple-implementation-with-deque-slow-and-ordereddict-fast",
                "content": "The slow approach implementation is just simple but it is not efficient at all (and it is ugly).\\nThe fast approach implementation is much better using OrderedDict (so that you have O(1) access time).\\nOrderedDict has `.move_to_end()` and `.popitem(last=False) #last=True if you want to pop the last element, last=False if you want to pop the first element` which make things way too easy.\\n\\nWhy do I do this? Well, if I were interviewed, I would tell the interviewer the first approach too and then introduce the second approach for faster time. By doing so, the interviewer knows my thinking process, my knowledge on Python data structures and my communication skills.\\n\\nThings to keep in mind:\\n\\n**Putting**\\n* Whenever you are putting a key-value pair in, you have to check whether the key already exists.\\n\\t* If it exists, you get that key-value pair, update the value and put that pair at the the end of the cache.\\n\\t* If the key does not exist, you check whether the cache size is already at limit. \\n\\t\\t* If the cache size is at limit, pop the key-value pair at the beginning of the cache and push the new key-value pair at the end of the cache.\\n\\t\\t* If the cache is still under size limit, simply push the new key-value pair at the end of the cache.\\n\\n**Getting**\\n* Whenever you are getting the value of the key, check whether the key exists in the cache.\\n\\t* If it exists, put that key-value pair at the end of the cache and return the value. \\n\\t* If it does not exist, return -1.\\n\\n**Slow Approach**\\n\\n``` python\\nfrom collections import deque\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.size = capacity\\n        self.deque = deque()\\n    \\n    def _find(self, key: int) -> int:\\n\\t\\t\"\"\" Linearly scans the deque for a specified key. Returns -1 if it does not exist, returns the index of the deque if it exists\"\"\"\\n        for i in range(len(self.deque)):\\n            n = self.deque[i]\\n            if n[0] == key:\\n                return i \\n        return -1\\n    \\n    def get(self, key: int) -> int:\\n        idx = self._find(key)\\n        if idx == -1:\\n            return -1\\n        else:\\n            k, v = self.deque[idx]\\n            del self.deque[idx] # We have to put this pair at the end of the queue so, we have to delete it first\\n            self.deque.append((k, v)) # And now, we put it at the end of the queue. So, the most viewed ones will be always at the end and be saved from popping when new capacity got hit.\\n            return v\\n                \\n\\n    def put(self, key: int, value: int) -> None:\\n        idx = self._find(key)\\n        if idx == -1:\\n            if len(self.deque) >= self.size:\\n                self.deque.popleft()\\n            self.deque.append((key,value))\\n        else:\\n            del self.deque[idx]\\n            self.deque.append((key, value))\\n```\\n``` bash\\nRuntime: 4716 ms, faster than 5.01% of Python3 online submissions for LRU Cache.\\nMemory Usage: 22.9 MB, less than 6.06% of Python3 online submissions for LRU Cache.\\n```\\nThis is just sad.\\n\\n**Fast Approach**\\n\\n``` python\\nfrom collections import OrderedDict\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.size = capacity\\n        self.cache = OrderedDict()\\n    \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        else:\\n            self.cache.move_to_end(key)  # Gotta keep this pair fresh, move to end of OrderedDict\\n            return self.cache[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.cache:\\n            if len(self.cache) >= self.size:\\n                self.cache.popitem(last=False) # last=True, LIFO; last=False, FIFO. We want to remove in FIFO fashion. \\n        else:\\n            self.cache.move_to_end(key) # Gotta keep this pair fresh, move to end of OrderedDict\\n            \\n\\t\\tself.cache[key] = value\\n```\\n\\n``` bash\\nRuntime: 172 ms, faster than 98.25% of Python3 online submissions for LRU Cache.\\nMemory Usage: 23.1 MB, less than 6.06% of Python3 online submissions for LRU Cache.\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "``` python\\nfrom collections import deque\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.size = capacity\\n        self.deque = deque()\\n    \\n    def _find(self, key: int) -> int:\\n\\t\\t\"\"\" Linearly scans the deque for a specified key. Returns -1 if it does not exist, returns the index of the deque if it exists\"\"\"\\n        for i in range(len(self.deque)):\\n            n = self.deque[i]\\n            if n[0] == key:\\n                return i \\n        return -1\\n    \\n    def get(self, key: int) -> int:\\n        idx = self._find(key)\\n        if idx == -1:\\n            return -1\\n        else:\\n            k, v = self.deque[idx]\\n            del self.deque[idx] # We have to put this pair at the end of the queue so, we have to delete it first\\n            self.deque.append((k, v)) # And now, we put it at the end of the queue. So, the most viewed ones will be always at the end and be saved from popping when new capacity got hit.\\n            return v\\n                \\n\\n    def put(self, key: int, value: int) -> None:\\n        idx = self._find(key)\\n        if idx == -1:\\n            if len(self.deque) >= self.size:\\n                self.deque.popleft()\\n            self.deque.append((key,value))\\n        else:\\n            del self.deque[idx]\\n            self.deque.append((key, value))\\n```\n``` bash\\nRuntime: 4716 ms, faster than 5.01% of Python3 online submissions for LRU Cache.\\nMemory Usage: 22.9 MB, less than 6.06% of Python3 online submissions for LRU Cache.\\n```\n``` python\\nfrom collections import OrderedDict\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.size = capacity\\n        self.cache = OrderedDict()\\n    \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        else:\\n            self.cache.move_to_end(key)  # Gotta keep this pair fresh, move to end of OrderedDict\\n            return self.cache[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.cache:\\n            if len(self.cache) >= self.size:\\n                self.cache.popitem(last=False) # last=True, LIFO; last=False, FIFO. We want to remove in FIFO fashion. \\n        else:\\n            self.cache.move_to_end(key) # Gotta keep this pair fresh, move to end of OrderedDict\\n            \\n\\t\\tself.cache[key] = value\\n```\n``` bash\\nRuntime: 172 ms, faster than 98.25% of Python3 online submissions for LRU Cache.\\nMemory Usage: 23.1 MB, less than 6.06% of Python3 online submissions for LRU Cache.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305346,
                "title": "java-hashmap-queue-linked-list-easy-approach-with-explanation",
                "content": "```\\nApproach 1: Brute Force\\n```\\n```\\nclass LRUCache\\n{\\n    int capacity;\\n    Queue<Integer> q=new ArrayDeque<>();//faster than LinkedList//to store the key according to  LRU principal\\n    Map<Integer,Integer> map=new LinkedHashMap<>();//To store key and value pair \\n    \\n    public LRUCache(int capacity) \\n    {\\n        this.capacity = capacity;//cache size \\n    }\\n    \\n    public int get(int key)\\n    {\\n        if (map.containsKey(key)) \\n        {//cache updating \\n            q.remove(key);//O(n)\\n            q.offer(key);//O(1)\\n            return map.get(key);//O(1)\\n        } \\n        else \\n            return -1;//key is npt found \\n    }\\n    \\n    public void put(int key, int value) \\n    {\\n        if(map.containsKey(key)) //if key is present in the map, key has to be searched and deleted and then enqueue the key into the queue, according to LRU principal\\n        {\\n            q.remove(key);//O(n)//remove the key from the queue \\n            q.offer(key);//O(1)//apeend at the end of the queue(enqueue)\\n            map.put(key,value);//O(1)//overwriding the key value (key is always unique)\\n        }\\n        else \\n        {\\n            if(q.size() < capacity)\\n                q.offer(key);//inserting the new key into the queue \\n            else \\n            {//q.size() == capacity\\n                map.remove(q.poll());//removing the least recently used key \\n                q.offer(key);//qppending the new key to the queue\\n            }\\n            map.put(key,value);//putting the key value pair \\n        }\\n    }\\n}\\n```\\n```\\nApproach 2: Optimal \\n```\\n```\\nclass LRUCache {\\n    class Node{//DLL \\n        int key;\\n        int value;\\n\\n        Node prev;\\n        Node next;\\n\\n        Node(int key, int value){\\n            this.key= key;\\n            this.value= value;\\n        }\\n    }\\n\\n    public Node[] map;//stores each node metatdata reff w.r.t to key\\n    public int count, capacity;\\n    public Node head, tail;\\n    \\n    public LRUCache(int capacity) { //all nodes are inserded b/w head and tail node \\n        \\n        this.capacity= capacity;\\n        count= 0;\\n        \\n        map= new Node[10_000+1];//no of nodes //metadata w.r.t. to key \\n        \\n        head= new Node(0,0);\\n        tail= new Node(0,0);\\n        \\n        head.next= tail;\\n        tail.prev= head;\\n        \\n        head.prev= null;\\n        tail.next= null;\\n    }\\n    \\n    public void deleteNode(Node node){ // deleting the node in LRU cache \\n        node.prev.next= node.next;\\n        node.next.prev= node.prev;       \\n        \\n        return;\\n    }\\n    \\n    public void addToHead(Node node){// adding the node in front of head i.e;in LRU cache \\n        node.next= head.next;\\n        node.next.prev= node;\\n        node.prev= head;\\n        \\n        head.next= node;      \\n        \\n        return;\\n    }\\n    \\n    public int get(int key) { // O(1)\\n        \\n        if( map[key] != null ){ //if node is present in LRU cache \\n            \\n            Node node= map[key];//getting the node metadata \\n            \\n            int nodeVal= node.value;\\n            \\n            deleteNode(node);//deleting the node from dll //O(1)\\n            \\n            addToHead(node);//adding to the front of head //now visited //O(1)\\n            \\n            return nodeVal;//returning the value of the node w.r.t to key \\n        }\\n        else\\n            return -1;//node not present \\n    }\\n    \\n    public void put(int key, int value) { // O(1)\\n        \\n        if(map[key] != null){//node already exists in LRU cache \\n            \\n            Node node= map[key]; //getting the node metadata\\n            \\n            node.value= value;//changing the node value to the current value \\n            \\n            deleteNode(node);//deleting the node  //O(1)\\n            \\n            addToHead(node);//adding node in front of head  //O(1)\\n            \\n        } else {//node dosent  exists in LRU cache \\n            \\n            Node node= new Node(key,value);\\n            \\n            map[key]= node;\\n            \\n            if(count < capacity){ //Case 1 //space availabe \\n                count++;\\n                addToHead(node);\\n            } \\n            else {//case 2 //space not availabe (capacity full)\\n                \\n                //deleting the least recently used node, making 1 sapce availabele\\n                map[tail.prev.key]= null;\\n                deleteNode(tail.prev);\\n                \\n                //adding the node in front of head\\n                addToHead(node);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n}\\n```\\n```\\nPlease do upvote, It helps a lot :)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Queue"
                ],
                "code": "```\\nApproach 1: Brute Force\\n```\n```\\nclass LRUCache\\n{\\n    int capacity;\\n    Queue<Integer> q=new ArrayDeque<>();//faster than LinkedList//to store the key according to  LRU principal\\n    Map<Integer,Integer> map=new LinkedHashMap<>();//To store key and value pair \\n    \\n    public LRUCache(int capacity) \\n    {\\n        this.capacity = capacity;//cache size \\n    }\\n    \\n    public int get(int key)\\n    {\\n        if (map.containsKey(key)) \\n        {//cache updating \\n            q.remove(key);//O(n)\\n            q.offer(key);//O(1)\\n            return map.get(key);//O(1)\\n        } \\n        else \\n            return -1;//key is npt found \\n    }\\n    \\n    public void put(int key, int value) \\n    {\\n        if(map.containsKey(key)) //if key is present in the map, key has to be searched and deleted and then enqueue the key into the queue, according to LRU principal\\n        {\\n            q.remove(key);//O(n)//remove the key from the queue \\n            q.offer(key);//O(1)//apeend at the end of the queue(enqueue)\\n            map.put(key,value);//O(1)//overwriding the key value (key is always unique)\\n        }\\n        else \\n        {\\n            if(q.size() < capacity)\\n                q.offer(key);//inserting the new key into the queue \\n            else \\n            {//q.size() == capacity\\n                map.remove(q.poll());//removing the least recently used key \\n                q.offer(key);//qppending the new key to the queue\\n            }\\n            map.put(key,value);//putting the key value pair \\n        }\\n    }\\n}\\n```\n```\\nApproach 2: Optimal \\n```\n```\\nclass LRUCache {\\n    class Node{//DLL \\n        int key;\\n        int value;\\n\\n        Node prev;\\n        Node next;\\n\\n        Node(int key, int value){\\n            this.key= key;\\n            this.value= value;\\n        }\\n    }\\n\\n    public Node[] map;//stores each node metatdata reff w.r.t to key\\n    public int count, capacity;\\n    public Node head, tail;\\n    \\n    public LRUCache(int capacity) { //all nodes are inserded b/w head and tail node \\n        \\n        this.capacity= capacity;\\n        count= 0;\\n        \\n        map= new Node[10_000+1];//no of nodes //metadata w.r.t. to key \\n        \\n        head= new Node(0,0);\\n        tail= new Node(0,0);\\n        \\n        head.next= tail;\\n        tail.prev= head;\\n        \\n        head.prev= null;\\n        tail.next= null;\\n    }\\n    \\n    public void deleteNode(Node node){ // deleting the node in LRU cache \\n        node.prev.next= node.next;\\n        node.next.prev= node.prev;       \\n        \\n        return;\\n    }\\n    \\n    public void addToHead(Node node){// adding the node in front of head i.e;in LRU cache \\n        node.next= head.next;\\n        node.next.prev= node;\\n        node.prev= head;\\n        \\n        head.next= node;      \\n        \\n        return;\\n    }\\n    \\n    public int get(int key) { // O(1)\\n        \\n        if( map[key] != null ){ //if node is present in LRU cache \\n            \\n            Node node= map[key];//getting the node metadata \\n            \\n            int nodeVal= node.value;\\n            \\n            deleteNode(node);//deleting the node from dll //O(1)\\n            \\n            addToHead(node);//adding to the front of head //now visited //O(1)\\n            \\n            return nodeVal;//returning the value of the node w.r.t to key \\n        }\\n        else\\n            return -1;//node not present \\n    }\\n    \\n    public void put(int key, int value) { // O(1)\\n        \\n        if(map[key] != null){//node already exists in LRU cache \\n            \\n            Node node= map[key]; //getting the node metadata\\n            \\n            node.value= value;//changing the node value to the current value \\n            \\n            deleteNode(node);//deleting the node  //O(1)\\n            \\n            addToHead(node);//adding node in front of head  //O(1)\\n            \\n        } else {//node dosent  exists in LRU cache \\n            \\n            Node node= new Node(key,value);\\n            \\n            map[key]= node;\\n            \\n            if(count < capacity){ //Case 1 //space availabe \\n                count++;\\n                addToHead(node);\\n            } \\n            else {//case 2 //space not availabe (capacity full)\\n                \\n                //deleting the least recently used node, making 1 sapce availabele\\n                map[tail.prev.key]= null;\\n                deleteNode(tail.prev);\\n                \\n                //adding the node in front of head\\n                addToHead(node);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n}\\n```\n```\\nPlease do upvote, It helps a lot :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46055,
                "title": "probably-the-best-java-solution-extend-linkedhashmap",
                "content": "I didn't check all 9 pages that are in this forum already, so it's likely someone already posted a solution like this. The easiest solution and maybe most elegant is to just use the LinkedHashMap with the access-order flag set to true. The official documentation on it even mentions LRU caches and offers a method to overwrite specifically for a purpose like this. \\n\\n\\n    import java.util.LinkedHashMap;\\n    \\n    public class LRUCache {\\n        \\n        private Map<Integer, Integer> map;\\n        \\n        public LRUCache(int capacity) {\\n            map = new LinkedCappedHashMap<>(capacity);\\n        }\\n        \\n        public int get(int key) {\\n            if(!map.containsKey(key)) { return -1; }\\n            return map.get(key);\\n        }\\n        \\n        public void set(int key, int value) {\\n            map.put(key,value);\\n        }\\n    \\n        private static class LinkedCappedHashMap<K,V> extends LinkedHashMap<K,V> {\\n            \\n            int maximumCapacity;\\n            \\n            LinkedCappedHashMap(int maximumCapacity) {\\n                super(16, 0.75f, true);\\n                this.maximumCapacity = maximumCapacity;\\n            }\\n            \\n            protected boolean removeEldestEntry(Map.Entry eldest) {\\n                return size() > maximumCapacity;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I didn't check all 9 pages that are in this forum already, so it's likely someone already posted a solution like this. The easiest solution and maybe most elegant is to just use the LinkedHashMap with the access-order flag set to true. The official documentation on it even mentions LRU caches and offers a method to overwrite specifically for a purpose like this. \\n\\n\\n    import java.util.LinkedHashMap;\\n    \\n    public class LRUCache {\\n        \\n        private Map<Integer, Integer> map;\\n        \\n        public LRUCache(int capacity) {\\n            map = new LinkedCappedHashMap<>(capacity);\\n        }\\n        \\n        public int get(int key) {\\n            if(!map.containsKey(key)) { return -1; }\\n            return map.get(key);\\n        }\\n        \\n        public void set(int key, int value) {\\n            map.put(key,value);\\n        }\\n    \\n        private static class LinkedCappedHashMap<K,V> extends LinkedHashMap<K,V> {\\n            \\n            int maximumCapacity;\\n            \\n            LinkedCappedHashMap(int maximumCapacity) {\\n                super(16, 0.75f, true);\\n                this.maximumCapacity = maximumCapacity;\\n            }\\n            \\n            protected boolean removeEldestEntry(Map.Entry eldest) {\\n                return size() > maximumCapacity;\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 46223,
                "title": "o-1-unordered-map-list-splice",
                "content": "    class LRUCache {\\n    private:\\n        // A list of (key, value) pairs\\n        list<pair<int, int>> items;\\n        // Map items to iterators (pointers) to list nodes\\n        unordered_map<int, list<pair<int, int>>::iterator> cache;\\n        // The capacity of the list\\n        int capacity;\\n\\n    public:\\n        LRUCache(int capacity) : capacity(capacity) {}\\n\\n        int get(int key) {\\n            // If key is not found in hash map, return -1\\n            if (cache.find(key) == cache.end())\\n                return -1;\\n            // Move the (key, value) pair to the beginning of the list\\n            items.splice(items.begin(), items, cache[key]);\\n            return cache[key]->second;\\n        }\\n\\n        void set(int key, int value) {\\n            // The key is not in the hash table\\n            if (cache.find(key) == cache.end()) {\\n                // If the cache is full then delete the least recently\\n                // used item, which is at the end of the list\\n                if (items.size() == capacity) {\\n                    cache.erase(items.back().first);\\n                    items.pop_back();\\n                }\\n                items.push_front(make_pair(key, value));\\n                cache[key] = items.begin();\\n            } else {\\n                // Update the value associated with the key\\n                cache[key]->second = value;\\n                // Move the (key, value) pair to the beginning of the list\\n                items.splice(items.begin(), items, cache[key]);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class LRUCache {\\n    private:\\n        // A list of (key, value) pairs\\n        list<pair<int, int>> items;\\n        // Map items to iterators (pointers) to list nodes\\n        unordered_map<int, list<pair<int, int>>::iterator> cache;\\n        // The capacity of the list\\n        int capacity;\\n\\n    public:\\n        LRUCache(int capacity) : capacity(capacity) {}\\n\\n        int get(int key) {\\n            // If key is not found in hash map, return -1\\n            if (cache.find(key) == cache.end())\\n                return -1;\\n            // Move the (key, value) pair to the beginning of the list\\n            items.splice(items.begin(), items, cache[key]);\\n            return cache[key]->second;\\n        }\\n\\n        void set(int key, int value) {\\n            // The key is not in the hash table\\n            if (cache.find(key) == cache.end()) {\\n                // If the cache is full then delete the least recently\\n                // used item, which is at the end of the list\\n                if (items.size() == capacity) {\\n                    cache.erase(items.back().first);\\n                    items.pop_back();\\n                }\\n                items.push_front(make_pair(key, value));\\n                cache[key] = items.begin();\\n            } else {\\n                // Update the value associated with the key\\n                cache[key]->second = value;\\n                // Move the (key, value) pair to the beginning of the list\\n                items.splice(items.begin(), items, cache[key]);\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 850110,
                "title": "python-3-7-no-need-to-use-ordereddict-simply-use-the-regular-dict",
                "content": "In Python 3.7 and above, there\\'s no need to use OrderedDict anymore, because the regular dict is already ordered.\\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.dict = {}\\n        self.capacity = capacity   \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.dict:\\n            return -1\\n        val = self.dict.pop(key)  #Remove it first before inserting it at the end again\\n        self.dict[key] = val   \\n        return val        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.dict:    \\n            self.dict.pop(key)\\n        else:\\n            if len(self.dict) == self.capacity:\\n                del self.dict[next(iter(self.dict))]         \\n        self.dict[key] = value\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.dict = {}\\n        self.capacity = capacity   \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.dict:\\n            return -1\\n        val = self.dict.pop(key)  #Remove it first before inserting it at the end again\\n        self.dict[key] = val   \\n        return val        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.dict:    \\n            self.dict.pop(key)\\n        else:\\n            if len(self.dict) == self.capacity:\\n                del self.dict[next(iter(self.dict))]         \\n        self.dict[key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178988,
                "title": "hashmap-doublelinkedlist-in-javascript",
                "content": "- Don\\'t use native API, for example `Object.keys(hashMap)` to count keys\\n- Don\\'t mass up HEAD and TAIL of the list\\n- Adopt DoubleLinkedList to get O(1)\\n- Store the key just for deleting the object :)\\n\\n```js\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this._capacity = capacity;\\n    this._count = 0;\\n    this._head = null;\\n    this._tail = null;\\n    this._hashTable = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if (this._hashTable[key]) {\\n        const { value } = this._hashTable[key];\\n        const { prev, next } = this._hashTable[key];\\n        if (prev) { prev.next = next; }\\n        if (next) { next.prev = prev || next.prev; }\\n        \\n        if (this._tail === this._hashTable[key]) {\\n            this._tail = prev || this._hashTable[key];\\n        }\\n        \\n        this._hashTable[key].prev = null;\\n        if (this._head !== this._hashTable[key]) {\\n            this._hashTable[key].next = this._head;\\n            this._head.prev = this._hashTable[key];\\n        }\\n        \\n        this._head = this._hashTable[key];\\n    \\n        return value;\\n    }\\n    \\n    return -1;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if (this._hashTable[key]) {\\n        this._hashTable[key].value = value;\\n        this.get(key);\\n    } else {\\n        this._hashTable[key] = { key, value, prev: null, next: null };\\n        if (this._head) {\\n            this._head.prev = this._hashTable[key];\\n            this._hashTable[key].next = this._head;\\n        }\\n\\n        this._head = this._hashTable[key];\\n\\n        if (!this._tail) {\\n            this._tail = this._hashTable[key];\\n        }\\n\\n        this._count += 1;\\n    }\\n    \\n    if (this._count > this._capacity) {\\n        let removedKey = this._tail.key;\\n\\n        if (this._tail.prev) {\\n            this._tail.prev.next = null;\\n            this._tail = this._tail.prev;\\n            this._hashTable[removedKey].prev = null;\\n        }\\n\\n        delete this._hashTable[removedKey];\\n        \\n        this._count -= 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this._capacity = capacity;\\n    this._count = 0;\\n    this._head = null;\\n    this._tail = null;\\n    this._hashTable = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if (this._hashTable[key]) {\\n        const { value } = this._hashTable[key];\\n        const { prev, next } = this._hashTable[key];\\n        if (prev) { prev.next = next; }\\n        if (next) { next.prev = prev || next.prev; }\\n        \\n        if (this._tail === this._hashTable[key]) {\\n            this._tail = prev || this._hashTable[key];\\n        }\\n        \\n        this._hashTable[key].prev = null;\\n        if (this._head !== this._hashTable[key]) {\\n            this._hashTable[key].next = this._head;\\n            this._head.prev = this._hashTable[key];\\n        }\\n        \\n        this._head = this._hashTable[key];\\n    \\n        return value;\\n    }\\n    \\n    return -1;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if (this._hashTable[key]) {\\n        this._hashTable[key].value = value;\\n        this.get(key);\\n    } else {\\n        this._hashTable[key] = { key, value, prev: null, next: null };\\n        if (this._head) {\\n            this._head.prev = this._hashTable[key];\\n            this._hashTable[key].next = this._head;\\n        }\\n\\n        this._head = this._hashTable[key];\\n\\n        if (!this._tail) {\\n            this._tail = this._hashTable[key];\\n        }\\n\\n        this._count += 1;\\n    }\\n    \\n    if (this._count > this._capacity) {\\n        let removedKey = this._tail.key;\\n\\n        if (this._tail.prev) {\\n            this._tail.prev.next = null;\\n            this._tail = this._tail.prev;\\n            this._hashTable[removedKey].prev = null;\\n        }\\n\\n        delete this._hashTable[removedKey];\\n        \\n        this._count -= 1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249435,
                "title": "c-implementation-using-map-and-doubly-linked-lists",
                "content": "```\\nclass Node{\\n    public:\\n    int key,value;\\n    Node *right,*left;\\n    \\n    Node(int key,int value){\\n        this->key=key;\\n        this->value=value;\\n        this->left=NULL;\\n        this->right=NULL;\\n    }\\n};\\nclass LRUCache {\\npublic:\\n    Node *head,*tail;\\n    int capacity,size;\\n    unordered_map<int,Node *> m;\\n    LRUCache(int capacity) {\\n        this->capacity=capacity;\\n        this->size=0;\\n        this->head=NULL;\\n        this->tail=NULL;\\n        \\n    }\\n    void delete_node(Node *p){\\n        if(p->left!=NULL){\\n            p->left->right=p->right;\\n        }\\n        else{\\n            head=p->right;\\n        }\\n        if(p->right!=NULL){\\n            p->right->left=p->left;\\n            \\n        }\\n        else{\\n            tail=p->left;\\n        }\\n        p->left=NULL;\\n        p->right=NULL;\\n    }\\n    \\n    void insert(Node *q){\\n       if (head == NULL)\\n        {\\n            head = tail = q;\\n        }\\n        else{\\n        tail->right = q;\\n        q->left = tail;\\n        tail = q;\\n        }\\n\\n    }\\n    /*\\n    Logic for get function:\\n    -> if key not found return -1\\n    ->if found then return val\\n    */\\n    int get(int key) {\\n        if (m.find(key)==m.end())\\n            return -1;\\n        Node *x=m[key];\\n        delete_node(x);\\n        insert(x);\\n        //insert the node at last\\n        \\n        return x->value;\\n    }\\n    /*Logic for Put function:\\n    ->if key already present thenchange the value of the key insert it at last\\n    ->if key not present\\n        Case1:if size== capacity then first value removed in LRU Cache\\n        Case2:if size!=capacity value inserted at last  \\n    */\\n    void put(int key, int value) {\\n        Node *y=new Node(key,value);\\n        if(m.find(key)!=m.end()){\\n            m[key]->value=value;\\n            delete_node(m[key]);\\n            insert(m[key]);\\n        }else{\\n            m[key]=y;\\n            if(size==capacity){\\n                m.erase(head->key);//remove the least recently used value from map\\n                delete_node(head);\\n                insert(y);\\n            }else{\\n                size+=1;//size of window increase\\n                insert(y);\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n ```\\n#####  Time Complexity:O(Q) where Q is number of queries\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Node{\\n    public:\\n    int key,value;\\n    Node *right,*left;\\n    \\n    Node(int key,int value){\\n        this->key=key;\\n        this->value=value;\\n        this->left=NULL;\\n        this->right=NULL;\\n    }\\n};\\nclass LRUCache {\\npublic:\\n    Node *head,*tail;\\n    int capacity,size;\\n    unordered_map<int,Node *> m;\\n    LRUCache(int capacity) {\\n        this->capacity=capacity;\\n        this->size=0;\\n        this->head=NULL;\\n        this->tail=NULL;\\n        \\n    }\\n    void delete_node(Node *p){\\n        if(p->left!=NULL){\\n            p->left->right=p->right;\\n        }\\n        else{\\n            head=p->right;\\n        }\\n        if(p->right!=NULL){\\n            p->right->left=p->left;\\n            \\n        }\\n        else{\\n            tail=p->left;\\n        }\\n        p->left=NULL;\\n        p->right=NULL;\\n    }\\n    \\n    void insert(Node *q){\\n       if (head == NULL)\\n        {\\n            head = tail = q;\\n        }\\n        else{\\n        tail->right = q;\\n        q->left = tail;\\n        tail = q;\\n        }\\n\\n    }\\n    /*\\n    Logic for get function:\\n    -> if key not found return -1\\n    ->if found then return val\\n    */\\n    int get(int key) {\\n        if (m.find(key)==m.end())\\n            return -1;\\n        Node *x=m[key];\\n        delete_node(x);\\n        insert(x);\\n        //insert the node at last\\n        \\n        return x->value;\\n    }\\n    /*Logic for Put function:\\n    ->if key already present thenchange the value of the key insert it at last\\n    ->if key not present\\n        Case1:if size== capacity then first value removed in LRU Cache\\n        Case2:if size!=capacity value inserted at last  \\n    */\\n    void put(int key, int value) {\\n        Node *y=new Node(key,value);\\n        if(m.find(key)!=m.end()){\\n            m[key]->value=value;\\n            delete_node(m[key]);\\n            insert(m[key]);\\n        }else{\\n            m[key]=y;\\n            if(size==capacity){\\n                m.erase(head->key);//remove the least recently used value from map\\n                delete_node(head);\\n                insert(y);\\n            }else{\\n                size+=1;//size of window increase\\n                insert(y);\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 46148,
                "title": "accepted-c-solution-296-ms",
                "content": "Solution is unusual - combination of 2 data structures - hash map and linked list.\\nAlgorithm:\\n\\n 1. hash map holds iterators to linked list\\n 2. linked list holds key and value, key to access hash map items\\n 3. when item is accessed, it's promoted - moved to the tail of the list - O(1) operation\\n 4. when item should be removed, we remove head of the list - O(1) operation\\n 5. when item is not promoted long time, it's moved to the head of the list automatically\\n 6. get() - O(1) performance, set() - O(1) performance\\n\\n       {\\n    \\n        class LRUCache{\\n        private:\\n        \\tstruct item_t{\\n        \\t\\tint key, val;\\n        \\t\\titem_t(int k, int v) :key(k), val(v){}\\n        \\t};\\n        \\ttypedef list<item_t> list_t;\\n        \\ttypedef unordered_map<int, list_t::iterator> map_t;\\n        \\n        \\tmap_t   m_map;\\n        \\tlist_t  m_list;\\n        \\tint     m_capacity;\\n        public:\\n        \\tLRUCache(int capacity) : m_capacity(capacity) {\\n        \\t}\\n        \\tint get(int key) {\\n        \\t\\tmap_t::iterator i = m_map.find(key);\\n        \\t\\tif (i == m_map.end()) return -1;\\n        \\t\\tm_map[key] = promote(i->second);\\n        \\t\\treturn m_map[key]->val;\\n        \\t}\\n        \\tvoid set(int key, int value) {\\n        \\t\\tmap_t::iterator i = m_map.find(key);\\n        \\t\\tif (i != m_map.end()){\\n        \\t\\t\\tm_map[key] = promote(i->second);\\n        \\t\\t\\tm_map[key]->val = value;\\n        \\t\\t}\\n        \\t\\telse {\\n        \\t\\t\\tif (m_map.size() < m_capacity){\\n        \\t\\t\\t\\tm_map[key] = m_list.insert(m_list.end(), item_t(key, value));\\n        \\t\\t\\t}\\n        \\t\\t\\telse {\\n        \\t\\t\\t\\tm_map.erase(m_list.front().key);\\n        \\t\\t\\t\\tm_list.pop_front();\\n        \\t\\t\\t\\tm_map[key] = m_list.insert(m_list.end(), item_t(key, value));\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tlist_t::iterator promote(list_t::iterator i){\\n        \\t\\tlist_t::iterator inew = m_list.insert(m_list.end(), *i);\\n        \\t\\tm_list.erase(i);\\n        \\t\\treturn inew;\\n        \\t}\\n        };\\n    }\\n\\n\\nbtw LeetCode, it was really hard to insert this code, after pressing {} button, class was improperly formatted. I inserted additional braces around class.",
                "solutionTags": [],
                "code": "Solution is unusual - combination of 2 data structures - hash map and linked list.\\nAlgorithm:\\n\\n 1. hash map holds iterators to linked list\\n 2. linked list holds key and value, key to access hash map items\\n 3. when item is accessed, it's promoted - moved to the tail of the list - O(1) operation\\n 4. when item should be removed, we remove head of the list - O(1) operation\\n 5. when item is not promoted long time, it's moved to the head of the list automatically\\n 6. get() - O(1) performance, set() - O(1) performance\\n\\n       {\\n    \\n        class LRUCache{\\n        private:\\n        \\tstruct item_t{\\n        \\t\\tint key, val;\\n        \\t\\titem_t(int k, int v) :key(k), val(v){}\\n        \\t};\\n        \\ttypedef list<item_t> list_t;\\n        \\ttypedef unordered_map<int, list_t::iterator> map_t;\\n        \\n        \\tmap_t   m_map;\\n        \\tlist_t  m_list;\\n        \\tint     m_capacity;\\n        public:\\n        \\tLRUCache(int capacity) : m_capacity(capacity) {\\n        \\t}\\n        \\tint get(int key) {\\n        \\t\\tmap_t::iterator i = m_map.find(key);\\n        \\t\\tif (i == m_map.end()) return -1;\\n        \\t\\tm_map[key] = promote(i->second);\\n        \\t\\treturn m_map[key]->val;\\n        \\t}\\n        \\tvoid set(int key, int value) {\\n        \\t\\tmap_t::iterator i = m_map.find(key);\\n        \\t\\tif (i != m_map.end()){\\n        \\t\\t\\tm_map[key] = promote(i->second);\\n        \\t\\t\\tm_map[key]->val = value;\\n        \\t\\t}\\n        \\t\\telse {\\n        \\t\\t\\tif (m_map.size() < m_capacity){\\n        \\t\\t\\t\\tm_map[key] = m_list.insert(m_list.end(), item_t(key, value));\\n        \\t\\t\\t}\\n        \\t\\t\\telse {\\n        \\t\\t\\t\\tm_map.erase(m_list.front().key);\\n        \\t\\t\\t\\tm_list.pop_front();\\n        \\t\\t\\t\\tm_map[key] = m_list.insert(m_list.end(), item_t(key, value));\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tlist_t::iterator promote(list_t::iterator i){\\n        \\t\\tlist_t::iterator inew = m_list.insert(m_list.end(), *i);\\n        \\t\\tm_list.erase(i);\\n        \\t\\treturn inew;\\n        \\t}\\n        };\\n    }\\n\\n\\nbtw LeetCode, it was really hard to insert this code, after pressing {} button, class was improperly formatted. I inserted additional braces around class.",
                "codeTag": "Java"
            },
            {
                "id": 801375,
                "title": "java-o-1-solution-clean-and-detailed-explanation",
                "content": "```\\n/**\\n * Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\\n *\\n * get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\\n * put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n *\\n * The cache is initialized with a positive capacity.\\n *\\n * Follow up:\\n * Could you do both operations in O(1) time complexity?\\n *\\n * Example:\\n *\\n * LRUCache cache = new LRUCache( 2 capacity );\\n        *\\n        *cache.put(1,1);\\n        *cache.put(2,2);\\n        *cache.get(1);       // returns 1\\n        *cache.put(3,3);    // evicts key 2\\n        *cache.get(2);       // returns -1 (not found)\\n        *cache.put(4,4);    // evicts key 1\\n        *cache.get(1);       // returns -1 (not found)\\n        *cache.get(3);       // returns 3\\n        *cache.get(4);       // returns 4\\n */\\n\\nclass Node {\\n    int key;\\n    int val;\\n    Node prev;\\n    Node next;\\n\\n    public Node(int key, int val) {\\n        this.key = key;\\n        this.val = val;\\n    }\\n}\\n\\n// only need addToFront and Delete\\nclass LRUCache {\\n\\n    Map<Integer, Node> map;\\n    Node head;\\n    Node tail;\\n    int capacity;\\n\\n    // initializ a <capacity> size data sctructure with two empty nodes pointing to each other (head and tail)\\n    public LRUCache(int capacity) {\\n        map = new HashMap<>();\\n        head = new Node(-1, -1);\\n        tail = new Node(-1, -1);\\n        head.next = tail;\\n        tail.prev = head;\\n        this.capacity = capacity;\\n    }\\n\\n    // move the current node to head, O(1)\\n    public void moveToHead(Node curr) {\\n        curr.next = head.next;\\n        curr.prev = head;\\n        head.next = curr;\\n        curr.next.prev = curr;\\n    }\\n\\n    // delete the current node, O(1)\\n    public void delete(Node curr) {\\n        curr.prev.next = curr.next;\\n        curr.next.prev = curr.prev;\\n    }\\n\\n    // when getting this node, delete it and move it to head because it is recently used, O(1)\\n    public int get(int key) {\\n        if(map.containsKey(key)) {\\n            Node curr = map.get(key);\\n            delete(curr);\\n            moveToHead(curr);\\n            return curr.val;\\n        }\\n        return -1;\\n    }\\n\\n    // puts a new node if it doesn\\'t already exist. Regardless of if it already exists, this node is brough to head\\n    // because it is recently used. If capacity exceeds, remove the tail because it is the least used, O(1)\\n    public void put(int key, int value) {\\n        if(map.containsKey(key)) {\\n            Node curr = map.get(key);\\n            curr.val = value;\\n            delete(curr);\\n            moveToHead(curr);\\n        }\\n        else if(map.size()<capacity) {\\n            map.put(key, new Node(key, value));\\n            moveToHead(map.get(key));\\n        }\\n        else {\\n            map.put(key, new Node(key, value));\\n            map.remove(tail.prev.key);\\n            delete(tail.prev);\\n            moveToHead(map.get(key));\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n\\n/**\\n * Time: O(1) for everything\\n * Space: O(capacity)\\n *\\n * Intuition:\\n * 1. to ensure get operation is O(1), hashmap is used\\n * 2. put at worst case involves, inserting new and deleting least recently used.\\n *   - For inserting new, hashmap is also O(1)\\n *   - For deleteing least recently used, the least recently used has to be tracked, so this involves keeping and\\n *     modifying the ordering of the cached values. This is where doubly linked list can be used, where moving places,\\n *     swapping or deletion are all O(1) when I can access each node through a hashmap\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\n/**\\n * Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\\n *\\n * get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\\n * put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n *\\n * The cache is initialized with a positive capacity.\\n *\\n * Follow up:\\n * Could you do both operations in O(1) time complexity?\\n *\\n * Example:\\n *\\n * LRUCache cache = new LRUCache( 2 capacity );\\n        *\\n        *cache.put(1,1);\\n        *cache.put(2,2);\\n        *cache.get(1);       // returns 1\\n        *cache.put(3,3);    // evicts key 2\\n        *cache.get(2);       // returns -1 (not found)\\n        *cache.put(4,4);    // evicts key 1\\n        *cache.get(1);       // returns -1 (not found)\\n        *cache.get(3);       // returns 3\\n        *cache.get(4);       // returns 4\\n */\\n\\nclass Node {\\n    int key;\\n    int val;\\n    Node prev;\\n    Node next;\\n\\n    public Node(int key, int val) {\\n        this.key = key;\\n        this.val = val;\\n    }\\n}\\n\\n// only need addToFront and Delete\\nclass LRUCache {\\n\\n    Map<Integer, Node> map;\\n    Node head;\\n    Node tail;\\n    int capacity;\\n\\n    // initializ a <capacity> size data sctructure with two empty nodes pointing to each other (head and tail)\\n    public LRUCache(int capacity) {\\n        map = new HashMap<>();\\n        head = new Node(-1, -1);\\n        tail = new Node(-1, -1);\\n        head.next = tail;\\n        tail.prev = head;\\n        this.capacity = capacity;\\n    }\\n\\n    // move the current node to head, O(1)\\n    public void moveToHead(Node curr) {\\n        curr.next = head.next;\\n        curr.prev = head;\\n        head.next = curr;\\n        curr.next.prev = curr;\\n    }\\n\\n    // delete the current node, O(1)\\n    public void delete(Node curr) {\\n        curr.prev.next = curr.next;\\n        curr.next.prev = curr.prev;\\n    }\\n\\n    // when getting this node, delete it and move it to head because it is recently used, O(1)\\n    public int get(int key) {\\n        if(map.containsKey(key)) {\\n            Node curr = map.get(key);\\n            delete(curr);\\n            moveToHead(curr);\\n            return curr.val;\\n        }\\n        return -1;\\n    }\\n\\n    // puts a new node if it doesn\\'t already exist. Regardless of if it already exists, this node is brough to head\\n    // because it is recently used. If capacity exceeds, remove the tail because it is the least used, O(1)\\n    public void put(int key, int value) {\\n        if(map.containsKey(key)) {\\n            Node curr = map.get(key);\\n            curr.val = value;\\n            delete(curr);\\n            moveToHead(curr);\\n        }\\n        else if(map.size()<capacity) {\\n            map.put(key, new Node(key, value));\\n            moveToHead(map.get(key));\\n        }\\n        else {\\n            map.put(key, new Node(key, value));\\n            map.remove(tail.prev.key);\\n            delete(tail.prev);\\n            moveToHead(map.get(key));\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n\\n/**\\n * Time: O(1) for everything\\n * Space: O(capacity)\\n *\\n * Intuition:\\n * 1. to ensure get operation is O(1), hashmap is used\\n * 2. put at worst case involves, inserting new and deleting least recently used.\\n *   - For inserting new, hashmap is also O(1)\\n *   - For deleteing least recently used, the least recently used has to be tracked, so this involves keeping and\\n *     modifying the ordering of the cached values. This is where doubly linked list can be used, where moving places,\\n *     swapping or deletion are all O(1) when I can access each node through a hashmap\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45964,
                "title": "very-short-solution-using-python-s-ordereddict",
                "content": "Here is a simple fast solution using Python's OrderedDict. Original credits to http://www.kunxi.org/blog/2014/05/lru-cache-in-python/ . It could be even shorter if python 3.2 was supported with `move_to_end`.\\n\\n    class LRUCache:\\n    \\n        # @param capacity, an integer\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            self.cache = collections.OrderedDict()\\n    \\n        # @return an integer\\n        def get(self, key):\\n            if not key in self.cache:\\n                return -1\\n            value = self.cache.pop(key)\\n            self.cache[key] = value\\n            return value\\n    \\n        # @param key, an integer\\n        # @param value, an integer\\n        # @return nothing\\n        def set(self, key, value):\\n            if key in self.cache:\\n                self.cache.pop(key)\\n            elif len(self.cache) == self.capacity:\\n                self.cache.popitem(last=False)\\n            self.cache[key] = value",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is a simple fast solution using Python's OrderedDict. Original credits to http://www.kunxi.org/blog/2014/05/lru-cache-in-python/ . It could be even shorter if python 3.2 was supported with `move_to_end`.\\n\\n    class LRUCache:\\n    \\n        # @param capacity, an integer\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            self.cache = collections.OrderedDict()\\n    \\n        # @return an integer\\n        def get(self, key):\\n            if not key in self.cache:\\n                return -1\\n            value = self.cache.pop(key)\\n            self.cache[key] = value\\n            return value\\n    \\n        # @param key, an integer\\n        # @param value, an integer\\n        # @return nothing\\n        def set(self, key, value):\\n            if key in self.cache:\\n                self.cache.pop(key)\\n            elif len(self.cache) == self.capacity:\\n                self.cache.popitem(last=False)\\n            self.cache[key] = value",
                "codeTag": "Java"
            },
            {
                "id": 1770891,
                "title": "typescript-simple-solution-with-o-1-get-and-put",
                "content": "The tricky thing is to have O(1) get and put time. We could create linked lists and hashmaps, but it\\'s very complex and easy to go wrong.\\n\\nFortunately JS/TS has a very convenient structure called Map, which behaves like an object, with the particularity of **respecting insertion order of keys**. So we know if we add a key, it will be at the end of the object, and the first inserted key will be at the beginning.\\n\\nThe \"key\" (haha) is to be sure to remove keys and re-add it at the end of the map when interacted with.\\n\\n```typescript\\nclass LRUCache {\\n  capacity: number;\\n  map: Map<number, number>;\\n\\n  constructor(capacity: number) {\\n      this.capacity = capacity;\\n      this.map = new Map();\\n  }\\n\\n  get(key: number): number {\\n    const value = this.map.get(key);\\n\\n    if (value === undefined) return -1;\\n          \\n    // Small hack to re-order keys: we remove the requested key and place it at the end\\n    this.map.delete(key);\\n    this.map.set(key, value);\\n    \\n    return value;\\n  }\\n\\n  put(key: number, value: number): void {\\n    // remove last element to avoid overflow, only if it does not have \\n    // the inserted key is a new key\\n    if (this.map.size >= this.capacity && !this.map.has(key)) {\\n        const firstKey = this.map.keys().next().value;\\n        this.map.delete(firstKey);\\n    }\\n    \\n    // Small hack to re-order keys: we remove the requested key and place it at the end\\n    this.map.delete(key);\\n    this.map.set(key, value);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nclass LRUCache {\\n  capacity: number;\\n  map: Map<number, number>;\\n\\n  constructor(capacity: number) {\\n      this.capacity = capacity;\\n      this.map = new Map();\\n  }\\n\\n  get(key: number): number {\\n    const value = this.map.get(key);\\n\\n    if (value === undefined) return -1;\\n          \\n    // Small hack to re-order keys: we remove the requested key and place it at the end\\n    this.map.delete(key);\\n    this.map.set(key, value);\\n    \\n    return value;\\n  }\\n\\n  put(key: number, value: number): void {\\n    // remove last element to avoid overflow, only if it does not have \\n    // the inserted key is a new key\\n    if (this.map.size >= this.capacity && !this.map.has(key)) {\\n        const firstKey = this.map.keys().next().value;\\n        this.map.delete(firstKey);\\n    }\\n    \\n    // Small hack to re-order keys: we remove the requested key and place it at the end\\n    this.map.delete(key);\\n    this.map.set(key, value);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46176,
                "title": "clean-java-solution",
                "content": "This problem is very common in interviews. Basically `HashMap` with `Entry<K, V>` being linked.\\n\\n    Map<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(-1, -1);\\n    Node tail = new Node(-1, -1);\\n    int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        join(head, tail);\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n        Node node = map.get(key);\\n        remove(node);\\n        moveToHead(node);\\n        return node.val;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            node.val = value;\\n            remove(node);\\n            moveToHead(node);\\n        } else {\\n            if (map.size() == capacity) {\\n                if (tail.prev != head) {\\n                    map.remove(tail.prev.key);\\n                    remove(tail.prev);\\n                }\\n            }\\n            Node node = new Node(key, value);\\n            moveToHead(node); \\n            map.put(key, node);\\n        }       \\n    }   \\n        \\n    public void join(Node n1, Node n2) {\\n        n1.next = n2;\\n        n2.prev = n1;\\n    }\\n\\n    public void remove(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public void moveToHead(Node node) {\\n        Node next = head.next; \\n        join(head, node);\\n        join(node, next);\\n    }\\n    \\n    class Node {\\n        Node prev;\\n        Node next;\\n        int key;\\n        int val;\\n        public Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This problem is very common in interviews. Basically `HashMap` with `Entry<K, V>` being linked.\\n\\n    Map<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(-1, -1);\\n    Node tail = new Node(-1, -1);\\n    int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        join(head, tail);\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n        Node node = map.get(key);\\n        remove(node);\\n        moveToHead(node);\\n        return node.val;\\n    }\\n    \\n    public void set(int key, int value) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            node.val = value;\\n            remove(node);\\n            moveToHead(node);\\n        } else {\\n            if (map.size() == capacity) {\\n                if (tail.prev != head) {\\n                    map.remove(tail.prev.key);\\n                    remove(tail.prev);\\n                }\\n            }\\n            Node node = new Node(key, value);\\n            moveToHead(node); \\n            map.put(key, node);\\n        }       \\n    }   \\n        \\n    public void join(Node n1, Node n2) {\\n        n1.next = n2;\\n        n2.prev = n1;\\n    }\\n\\n    public void remove(Node node) {\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    public void moveToHead(Node node) {\\n        Node next = head.next; \\n        join(head, node);\\n        join(node, next);\\n    }\\n    \\n    class Node {\\n        Node prev;\\n        Node next;\\n        int key;\\n        int val;\\n        public Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 446715,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Use `DoublyLinkedList` to maintin a least recently used cache\\n2. Use dummy head and tail for easier access and logic\\n3. Use hashtable `{key:node}` to access the nodes in the linked list in O(1)\\n*not so complicated but extremely long, very hard to write bug-free code\\n``` javascript\\nvar Node = function(key, value) {\\n    this.key = key;\\n    this.val = value;\\n    this.prev = this.next = null;\\n}\\n/**\\n * DoublyLinkedList Class\\n * @constructor initilize head & tail\\n * @action insertHead\\n * @action removeNode\\n * @action moveToHead\\n * @action removeTail\\n */\\nvar DoublyLinkedList = function() {\\n    this.head = new Node;\\n    this.tail = new Node;\\n    this.head.next = this.tail;\\n    this.tail.prev = this.head;\\n}\\n\\n/**\\n * Insert a new node right after head\\n * @param {Node} node\\n */\\nDoublyLinkedList.prototype.insertHead = function(node) {\\n    node.prev = this.head;\\n    node.next = this.head.next;\\n    this.head.next.prev = node;\\n    this.head.next = node;\\n}\\n\\n/**\\n * Remove a node from the linked list\\n * @param {Node} node\\n */\\nDoublyLinkedList.prototype.removeNode = function(node) {\\n    // console.log(\"trying to remove node:\", node.key)\\n    let prev = node.prev;\\n    let next = node.next;\\n    prev.next = next;\\n    next.prev = prev;\\n}\\n\\n/**\\n * Move a node to the head\\n * @param {Node} node\\n */\\nDoublyLinkedList.prototype.moveToHead = function(node){\\n    this.removeNode(node);\\n    this.insertHead(node);\\n}\\n\\n/**\\n * Remove the tail element and return its key\\n * @return {String}\\n */\\nDoublyLinkedList.prototype.removeTail = function() {\\n    let tail = this.tail.prev;\\n    this.removeNode(tail);\\n    return tail.key;\\n}\\n\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.capacity = capacity;\\n    this.currentSize = 0;\\n    this.hash = new Map();\\n    this.dll = new DoublyLinkedList();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    let node = this.hash.get(key);\\n    if (!node) return -1;\\n    this.dll.moveToHead(node);\\n    return node.val;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    let node = this.hash.get(key);\\n    if (node==null) { // new node\\n        let newNode = new Node(key, value);\\n        this.hash.set(key, newNode);\\n        this.dll.insertHead(newNode);\\n        this.currentSize++;\\n        if (this.currentSize > this.capacity) {\\n            let tailKey = this.dll.removeTail();\\n            this.hash.delete(tailKey);\\n            this.currentSize--;\\n        }\\n    } else { // existed node, update its value and move to head;\\n        node.val = value;\\n        this.dll.moveToHead(node);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar Node = function(key, value) {\\n    this.key = key;\\n    this.val = value;\\n    this.prev = this.next = null;\\n}\\n/**\\n * DoublyLinkedList Class\\n * @constructor initilize head & tail\\n * @action insertHead\\n * @action removeNode\\n * @action moveToHead\\n * @action removeTail\\n */\\nvar DoublyLinkedList = function() {\\n    this.head = new Node;\\n    this.tail = new Node;\\n    this.head.next = this.tail;\\n    this.tail.prev = this.head;\\n}\\n\\n/**\\n * Insert a new node right after head\\n * @param {Node} node\\n */\\nDoublyLinkedList.prototype.insertHead = function(node) {\\n    node.prev = this.head;\\n    node.next = this.head.next;\\n    this.head.next.prev = node;\\n    this.head.next = node;\\n}\\n\\n/**\\n * Remove a node from the linked list\\n * @param {Node} node\\n */\\nDoublyLinkedList.prototype.removeNode = function(node) {\\n    // console.log(\"trying to remove node:\", node.key)\\n    let prev = node.prev;\\n    let next = node.next;\\n    prev.next = next;\\n    next.prev = prev;\\n}\\n\\n/**\\n * Move a node to the head\\n * @param {Node} node\\n */\\nDoublyLinkedList.prototype.moveToHead = function(node){\\n    this.removeNode(node);\\n    this.insertHead(node);\\n}\\n\\n/**\\n * Remove the tail element and return its key\\n * @return {String}\\n */\\nDoublyLinkedList.prototype.removeTail = function() {\\n    let tail = this.tail.prev;\\n    this.removeNode(tail);\\n    return tail.key;\\n}\\n\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.capacity = capacity;\\n    this.currentSize = 0;\\n    this.hash = new Map();\\n    this.dll = new DoublyLinkedList();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    let node = this.hash.get(key);\\n    if (!node) return -1;\\n    this.dll.moveToHead(node);\\n    return node.val;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    let node = this.hash.get(key);\\n    if (node==null) { // new node\\n        let newNode = new Node(key, value);\\n        this.hash.set(key, newNode);\\n        this.dll.insertHead(newNode);\\n        this.currentSize++;\\n        if (this.currentSize > this.capacity) {\\n            let tailKey = this.dll.removeTail();\\n            this.hash.delete(tailKey);\\n            this.currentSize--;\\n        }\\n    } else { // existed node, update its value and move to head;\\n        node.val = value;\\n        this.dll.moveToHead(node);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138745,
                "title": "c-code-well-documented-with-comments",
                "content": "```\\nclass LRUCache {\\npublic:\\n    \\n    // this list will have (key, value) pairs that we need\\n    list<pair<int, int>> cache;\\n    // this unordered_map will have the key and address of list where that key is stored\\n    unordered_map<int, list<pair<int,int>> :: iterator> myMap;\\n    int maxSize; // max Capacity\\n    \\n    // this is the main logic and game changing function\\n    // this function will remove the (key, value) from the cache\\n    // insert the new (key,value) in front of cache\\n    // update/enter the address of (key,address) in map\\n    void refreshPosition(int key, int value) {\\n        \\n        // find the position of the key and remove it from the cache\\n        cache.erase(myMap[key]);\\n        // push in front the new (key,value) pair\\n        cache.push_front(make_pair(key, value));\\n        // make entry in map as cache.begin() because we added it in front\\n        myMap[key] = cache.begin();\\n        \\n    }\\n   \\n    LRUCache(int capacity) {\\n        maxSize = capacity;\\n    }\\n    \\n    // check if that value is already present in map\\n    // if yes, then refresh the position to make it the first element in cache\\n    // return the value from the pair (key, value)\\n    // return -1 if not found\\n    int get(int key) {\\n        // if found in map\\n        if(myMap.find(key) != myMap.end()) {\\n            // *myMap[key] -> second will give us the corresponding value of the key\\n            // because myMap[key] stores the address of the pair and not the pair itself\\n            int value = (*myMap[key]).second;\\n            refreshPosition(key, value);\\n            return value;\\n        }\\n        return -1; // if not found\\n    }\\n    \\n    // if a pair is already present then just refresh it\\n    // check if that key exists in map, if it does then just refresh the position\\n    void put(int key, int value) {\\n        if(myMap.find(key) != myMap.end())\\n            refreshPosition(key, value); \\n        // here we refresh (key, value) and not (key, (*myMap[key]).second) because if put [2,1] and put [2,2] is called\\n        // then get(2) should give ans 2 and not 1, so refresh with latest value and same key\\n        else {\\n            // push it in front of the cache\\n            cache.push_front(make_pair(key, value));\\n            myMap[key] = cache.begin();\\n            \\n            // if capacity is overflown after this insertion then remove the last element from cache\\n            if(myMap.size() > maxSize) {\\n                // erase the last element of the cache from map\\n                myMap.erase(cache.back().first);\\n                // pop that element from cache as well\\n                cache.pop_back();\\n            }\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    \\n    // this list will have (key, value) pairs that we need\\n    list<pair<int, int>> cache;\\n    // this unordered_map will have the key and address of list where that key is stored\\n    unordered_map<int, list<pair<int,int>> :: iterator> myMap;\\n    int maxSize; // max Capacity\\n    \\n    // this is the main logic and game changing function\\n    // this function will remove the (key, value) from the cache\\n    // insert the new (key,value) in front of cache\\n    // update/enter the address of (key,address) in map\\n    void refreshPosition(int key, int value) {\\n        \\n        // find the position of the key and remove it from the cache\\n        cache.erase(myMap[key]);\\n        // push in front the new (key,value) pair\\n        cache.push_front(make_pair(key, value));\\n        // make entry in map as cache.begin() because we added it in front\\n        myMap[key] = cache.begin();\\n        \\n    }\\n   \\n    LRUCache(int capacity) {\\n        maxSize = capacity;\\n    }\\n    \\n    // check if that value is already present in map\\n    // if yes, then refresh the position to make it the first element in cache\\n    // return the value from the pair (key, value)\\n    // return -1 if not found\\n    int get(int key) {\\n        // if found in map\\n        if(myMap.find(key) != myMap.end()) {\\n            // *myMap[key] -> second will give us the corresponding value of the key\\n            // because myMap[key] stores the address of the pair and not the pair itself\\n            int value = (*myMap[key]).second;\\n            refreshPosition(key, value);\\n            return value;\\n        }\\n        return -1; // if not found\\n    }\\n    \\n    // if a pair is already present then just refresh it\\n    // check if that key exists in map, if it does then just refresh the position\\n    void put(int key, int value) {\\n        if(myMap.find(key) != myMap.end())\\n            refreshPosition(key, value); \\n        // here we refresh (key, value) and not (key, (*myMap[key]).second) because if put [2,1] and put [2,2] is called\\n        // then get(2) should give ans 2 and not 1, so refresh with latest value and same key\\n        else {\\n            // push it in front of the cache\\n            cache.push_front(make_pair(key, value));\\n            myMap[key] = cache.begin();\\n            \\n            // if capacity is overflown after this insertion then remove the last element from cache\\n            if(myMap.size() > maxSize) {\\n                // erase the last element of the cache from map\\n                myMap.erase(cache.back().first);\\n                // pop that element from cache as well\\n                cache.pop_back();\\n            }\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 595743,
                "title": "c-o-1-solution-linkedlist-dictionary",
                "content": "Update on 4/8/2021 based on @glahaye\\'s suggestion.\\n\\n```\\npublic class LRUCache {\\n\\n    public class Cache\\n    {\\n        public int CacheKey;\\n        public int CacheVal;\\n        public Cache(int key, int val)\\n        {\\n            CacheKey = key;\\n            CacheVal = val;\\n        }\\n    }\\n    \\n    public int Capacity = 0;\\n    \\n    /* dic: maintain the key-value mapping for 2 purposes:\\n       1. Get cache value by cache key in O(1)\\n       2. Use LinkedListNode as the dictionry value, so that later we can use LinkedList.Remove(dic[key]) to remove an element in O(1).\\n    */\\n    public Dictionary<int, LinkedListNode<Cache>> dic = new Dictionary<int, LinkedListNode<Cache>>();\\n    \\n    /*\\n        lruList: \\n        1. Most recently used cache will be added to the head of the LinkedList.\\n        2. Use LinkedListNode to add/remove element to achieve O(1) time complexity.\\n        3. LinkedList<T>.Last returns the last LinkedListNode<T>.\\n\\t\\t\\t- LinkedList<T>.Last is a property which is an O(1) operation.\\n\\t\\t\\t- LinkedList<T>.Last() uses LINQ to get the last element which is an O(n) operation.\\n    */\\n    public LinkedList<Cache> lruList = new LinkedList<Cache>();\\n        \\n    public LRUCache(int capacity) {\\n        this.Capacity = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if(!dic.ContainsKey(key))\\n            return -1;\\n        \\n        var cache = dic[key];\\n        \\n        // move the cache to the head of lruList, indicating it is the most recent used cache.\\n        lruList.Remove(cache);\\n        lruList.AddFirst(cache);\\n        \\n        return cache.Value.CacheVal;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if(dic.ContainsKey(key))\\n        {\\n            // update the cache value\\n            dic[key].Value.CacheVal = value;\\n            \\n            // move the updated cache to the head of the lruList\\n            var cache = dic[key];\\n            lruList.Remove(cache);\\n            lruList.AddFirst(cache);\\n        }\\n        else\\n        {   \\n            // add a new cache to the dic and lru\\n            Cache cache = new Cache(key, value);\\n            dic.Add(key, new LinkedListNode<Cache>(cache));\\n            lruList.AddFirst(dic[key]);\\n            \\n            if(dic.Count > Capacity)\\n            {\\n                // remove the last cache from the dic and lruList if capacity execeeds the limit\\n                // use lruList.Last instead of lruList.Last() to get the LinkedListNode object\\n\\t\\t\\t\\t// this helps remove lastCache from lruList in O(1)\\n                LinkedListNode<Cache> lastCache = lruList.Last;\\n                dic.Remove(lastCache.Value.CacheKey);\\n                lruList.Remove(lastCache);\\n            }  \\n        } \\n    }\\n}\\n```\\n\\n**Original implementation**\\nIn C#, LinkedList is a double linked list data structure. Remove(LinkedListNode<T>) is O(1) operation.\\n```\\npublic class Cache\\n{\\n    public int key {set; get;}\\n    public int value {set; get;}\\n    public Cache(int key, int value)\\n    {\\n        this.key = key;\\n        this.value = value;\\n    }\\n}\\n\\npublic class LRUCache {\\n\\n    private int capacity;\\n    private Dictionary<int, Cache> dic;\\n    private LinkedList<Cache> cacheList;\\n          \\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        dic = new Dictionary<int, Cache>();\\n        cacheList = new LinkedList<Cache>();\\n    }\\n    \\n    public int Get(int key) {\\n        if(!dic.ContainsKey(key))\\n            return -1;\\n        \\n        Cache currCache = dic[key];\\n        cacheList.Remove(currCache);\\n        cacheList.AddFirst(currCache);\\n        return dic[key].value;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if(dic.ContainsKey(key))\\n        {\\n            // update the value of cache\\n            dic[key].value = value; \\n                     \\n            // re-arrange the order of cacheList\\n            cacheList.Remove(dic[key]);\\n            cacheList.AddFirst(dic[key]);\\n        }\\n        else\\n        {\\n            // add cache\\n            Cache newCache = new Cache(key, value);\\n            dic.Add(key, newCache);\\n            cacheList.AddFirst(newCache);\\n        }\\n        \\n        if(dic.Count > capacity)\\n        {\\n            dic.Remove(cacheList.Last.Value.key);\\n            cacheList.RemoveLast();         \\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.Get(key);\\n * obj.Put(key,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LRUCache {\\n\\n    public class Cache\\n    {\\n        public int CacheKey;\\n        public int CacheVal;\\n        public Cache(int key, int val)\\n        {\\n            CacheKey = key;\\n            CacheVal = val;\\n        }\\n    }\\n    \\n    public int Capacity = 0;\\n    \\n    /* dic: maintain the key-value mapping for 2 purposes:\\n       1. Get cache value by cache key in O(1)\\n       2. Use LinkedListNode as the dictionry value, so that later we can use LinkedList.Remove(dic[key]) to remove an element in O(1).\\n    */\\n    public Dictionary<int, LinkedListNode<Cache>> dic = new Dictionary<int, LinkedListNode<Cache>>();\\n    \\n    /*\\n        lruList: \\n        1. Most recently used cache will be added to the head of the LinkedList.\\n        2. Use LinkedListNode to add/remove element to achieve O(1) time complexity.\\n        3. LinkedList<T>.Last returns the last LinkedListNode<T>.\\n\\t\\t\\t- LinkedList<T>.Last is a property which is an O(1) operation.\\n\\t\\t\\t- LinkedList<T>.Last() uses LINQ to get the last element which is an O(n) operation.\\n    */\\n    public LinkedList<Cache> lruList = new LinkedList<Cache>();\\n        \\n    public LRUCache(int capacity) {\\n        this.Capacity = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if(!dic.ContainsKey(key))\\n            return -1;\\n        \\n        var cache = dic[key];\\n        \\n        // move the cache to the head of lruList, indicating it is the most recent used cache.\\n        lruList.Remove(cache);\\n        lruList.AddFirst(cache);\\n        \\n        return cache.Value.CacheVal;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if(dic.ContainsKey(key))\\n        {\\n            // update the cache value\\n            dic[key].Value.CacheVal = value;\\n            \\n            // move the updated cache to the head of the lruList\\n            var cache = dic[key];\\n            lruList.Remove(cache);\\n            lruList.AddFirst(cache);\\n        }\\n        else\\n        {   \\n            // add a new cache to the dic and lru\\n            Cache cache = new Cache(key, value);\\n            dic.Add(key, new LinkedListNode<Cache>(cache));\\n            lruList.AddFirst(dic[key]);\\n            \\n            if(dic.Count > Capacity)\\n            {\\n                // remove the last cache from the dic and lruList if capacity execeeds the limit\\n                // use lruList.Last instead of lruList.Last() to get the LinkedListNode object\\n\\t\\t\\t\\t// this helps remove lastCache from lruList in O(1)\\n                LinkedListNode<Cache> lastCache = lruList.Last;\\n                dic.Remove(lastCache.Value.CacheKey);\\n                lruList.Remove(lastCache);\\n            }  \\n        } \\n    }\\n}\\n```\n```\\npublic class Cache\\n{\\n    public int key {set; get;}\\n    public int value {set; get;}\\n    public Cache(int key, int value)\\n    {\\n        this.key = key;\\n        this.value = value;\\n    }\\n}\\n\\npublic class LRUCache {\\n\\n    private int capacity;\\n    private Dictionary<int, Cache> dic;\\n    private LinkedList<Cache> cacheList;\\n          \\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        dic = new Dictionary<int, Cache>();\\n        cacheList = new LinkedList<Cache>();\\n    }\\n    \\n    public int Get(int key) {\\n        if(!dic.ContainsKey(key))\\n            return -1;\\n        \\n        Cache currCache = dic[key];\\n        cacheList.Remove(currCache);\\n        cacheList.AddFirst(currCache);\\n        return dic[key].value;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if(dic.ContainsKey(key))\\n        {\\n            // update the value of cache\\n            dic[key].value = value; \\n                     \\n            // re-arrange the order of cacheList\\n            cacheList.Remove(dic[key]);\\n            cacheList.AddFirst(dic[key]);\\n        }\\n        else\\n        {\\n            // add cache\\n            Cache newCache = new Cache(key, value);\\n            dic.Add(key, newCache);\\n            cacheList.AddFirst(newCache);\\n        }\\n        \\n        if(dic.Count > capacity)\\n        {\\n            dic.Remove(cacheList.Last.Value.key);\\n            cacheList.RemoveLast();         \\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.Get(key);\\n * obj.Put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212952,
                "title": "python-solution",
                "content": "Doubly linked lists to store the `(key, val)` pair, and dictionary mapping `key` to the corresponding node. Time complexity for both `get` and `put` : `O(1)`. Space complexity: `O(capacity)`.\\n\\n```\\nclass ListNode(object):\\n    \\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\n\\nclass LRUCache(object):\\n\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.head = ListNode(-1, -1)\\n        self.tail = self.head\\n        self.key2node = {}\\n        self.capacity = capacity\\n        self.length = 0\\n        \\n        \\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.key2node:\\n            return -1\\n        node = self.key2node[key]\\n        val = node.val\\n        if node.next:\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            self.tail.next = node\\n            node.prev = self.tail\\n            node.next = None\\n            self.tail = node\\n        return val\\n        \\n        \\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if key in self.key2node:\\n            node = self.key2node[key]\\n            node.val = value\\n            if node.next:\\n                node.prev.next = node.next\\n                node.next.prev = node.prev\\n                self.tail.next = node\\n                node.prev = self.tail\\n                node.next = None\\n                self.tail = node   \\n        else:\\n            node = ListNode(key, value)\\n            self.key2node[key] = node\\n            self.tail.next = node\\n            node.prev = self.tail\\n            self.tail = node\\n            self.length += 1\\n            if self.length > self.capacity:\\n                remove = self.head.next\\n                self.head.next = self.head.next.next\\n                self.head.next.prev = self.head\\n                del self.key2node[remove.key]\\n                self.length -= 1\\n```\\n\\nAnother solution using OrderedDict:\\n\\n```\\nclass LRUCache:\\n\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity\\n        self.dic = collections.OrderedDict()\\n        \\n\\t\\t\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.dic:\\n            return -1\\n        val = self.dic[key]\\n        self.dic.move_to_end(key)\\n        return val\\n        \\n\\t\\t\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        self.dic[key] = value\\n        self.dic.move_to_end(key)\\n        if len(self.dic) > self.capacity:\\n            self.dic.popitem(last=False)\\n```",
                "solutionTags": [],
                "code": "```\\nclass ListNode(object):\\n    \\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\n\\nclass LRUCache(object):\\n\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.head = ListNode(-1, -1)\\n        self.tail = self.head\\n        self.key2node = {}\\n        self.capacity = capacity\\n        self.length = 0\\n        \\n        \\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.key2node:\\n            return -1\\n        node = self.key2node[key]\\n        val = node.val\\n        if node.next:\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            self.tail.next = node\\n            node.prev = self.tail\\n            node.next = None\\n            self.tail = node\\n        return val\\n        \\n        \\n        \\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        if key in self.key2node:\\n            node = self.key2node[key]\\n            node.val = value\\n            if node.next:\\n                node.prev.next = node.next\\n                node.next.prev = node.prev\\n                self.tail.next = node\\n                node.prev = self.tail\\n                node.next = None\\n                self.tail = node   \\n        else:\\n            node = ListNode(key, value)\\n            self.key2node[key] = node\\n            self.tail.next = node\\n            node.prev = self.tail\\n            self.tail = node\\n            self.length += 1\\n            if self.length > self.capacity:\\n                remove = self.head.next\\n                self.head.next = self.head.next.next\\n                self.head.next.prev = self.head\\n                del self.key2node[remove.key]\\n                self.length -= 1\\n```\n```\\nclass LRUCache:\\n\\n\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity\\n        self.dic = collections.OrderedDict()\\n        \\n\\t\\t\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key not in self.dic:\\n            return -1\\n        val = self.dic[key]\\n        self.dic.move_to_end(key)\\n        return val\\n        \\n\\t\\t\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: void\\n        \"\"\"\\n        self.dic[key] = value\\n        self.dic.move_to_end(key)\\n        if len(self.dic) > self.capacity:\\n            self.dic.popitem(last=False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46171,
                "title": "clean-python-code-with-doubly-linked-list-hashtable",
                "content": "    class LinkedListNode(object):\\n        def __init__(self, key=None, val=-1):\\n            self.key = key\\n            self.val = val\\n            self.pre = None\\n            self.next = None\\n    \\n    \\n    class LinkedList(object):\\n        def __init__(self):\\n            self.head = None\\n            self.tail = None\\n            self.size = 0\\n    \\n        def appendHead(self, node):\\n            node.next, node.pre = self.head, None\\n            if self.head:\\n                self.head.pre = node\\n            self.head = node\\n    \\n            if not self.tail:\\n                self.tail = self.head\\n    \\n            self.size += 1\\n    \\n        def remove(self, node):\\n            if not node:\\n                return\\n    \\n            pre, next = node.pre, node.next\\n            if pre:\\n                pre.next = next\\n            if next:\\n                next.pre = pre\\n    \\n            if self.head == node:\\n                self.head = next\\n    \\n            if self.tail == node:\\n                self.tail = pre\\n    \\n            self.size -= 1\\n            return node\\n    \\n        def removeTail(self):\\n            return self.remove(self.tail)\\n    \\n        def advance(self, node):\\n            self.remove(node)\\n            self.appendHead(node)\\n    \\n    \\n    class LRUCache(object):\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            self.record = {}\\n            self.linkedList = LinkedList()\\n    \\n        def get(self, key):\\n            if key not in self.record:\\n                return -1\\n    \\n            self.linkedList.advance(self.record[key])\\n            return self.record[key].val\\n    \\n        def set(self, key, value):\\n            if key not in self.record:\\n                node = LinkedListNode(key, value)\\n    \\n                self.linkedList.appendHead(node)\\n                self.record[key] = node\\n    \\n                if self.linkedList.size > self.capacity:\\n                    del self.record[self.linkedList.removeTail().key]\\n            else:\\n                self.record[key].val = value\\n                self.linkedList.advance(self.record[key])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class LinkedListNode(object):\\n        def __init__(self, key=None, val=-1):\\n            self.key = key\\n            self.val = val\\n            self.pre = None\\n            self.next = None\\n    \\n    \\n    class LinkedList(object):\\n        def __init__(self):\\n            self.head = None\\n            self.tail = None\\n            self.size = 0\\n    \\n        def appendHead(self, node):\\n            node.next, node.pre = self.head, None\\n            if self.head:\\n                self.head.pre = node\\n            self.head = node\\n    \\n            if not self.tail:\\n                self.tail = self.head\\n    \\n            self.size += 1\\n    \\n        def remove(self, node):\\n            if not node:\\n                return\\n    \\n            pre, next = node.pre, node.next\\n            if pre:\\n                pre.next = next\\n            if next:\\n                next.pre = pre\\n    \\n            if self.head == node:\\n                self.head = next\\n    \\n            if self.tail == node:\\n                self.tail = pre\\n    \\n            self.size -= 1\\n            return node\\n    \\n        def removeTail(self):\\n            return self.remove(self.tail)\\n    \\n        def advance(self, node):\\n            self.remove(node)\\n            self.appendHead(node)\\n    \\n    \\n    class LRUCache(object):\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            self.record = {}\\n            self.linkedList = LinkedList()\\n    \\n        def get(self, key):\\n            if key not in self.record:\\n                return -1\\n    \\n            self.linkedList.advance(self.record[key])\\n            return self.record[key].val\\n    \\n        def set(self, key, value):\\n            if key not in self.record:\\n                node = LinkedListNode(key, value)\\n    \\n                self.linkedList.appendHead(node)\\n                self.record[key] = node\\n    \\n                if self.linkedList.size > self.capacity:\\n                    del self.record[self.linkedList.removeTail().key]\\n            else:\\n                self.record[key].val = value\\n                self.linkedList.advance(self.record[key])",
                "codeTag": "Java"
            },
            {
                "id": 1284118,
                "title": "c-queue-o-n-m",
                "content": "Top discussion section is filled with Double Linked List \\nso I thought I\\'ll put another way to solve this problem up here.\\n\\nThe solution scales with O(N + M) amortized time and space \\nwhere N and M are  `get` and  `put` calls respectively. \\nIt is a fast solution as well. The idea is to push all calls into a queue \\nand count how many times same keys appear in the queue. \\nIf certain keys counts are zero then they are removed from the hashmap.\\n\\n```\\nunordered_map <int, int> m, cnt;\\nqueue <int> q;\\nint n;\\nLRUCache(int capacity) : n(capacity) {}\\nint get(int key) {\\n\\tif (cnt.find(key) == cnt.end()) \\n\\t\\treturn -1;\\n\\tq.push(key);\\n\\tcnt[key]++;\\n\\treturn m[key];\\n}\\nvoid put(int key, int value) {\\n\\tq.push(key);\\n\\tcnt[key]++;\\n\\tm[key] = value;\\n\\twhile (cnt.size() > n) {\\n\\t\\tint cur = q.front(); q.pop();\\n\\t\\tif (cnt[cur]-- == 1) \\n\\t\\t\\tcnt.erase(cur);\\n\\t}\\n}\\n```\\n\\nWith regards to the most popular solution of Double Linked List: \\nthat solution scales with O(C) for space, which is less than number of all calls. \\n`C = capacity = 3000 < N + M = 2*10^5 calls` so it is a much better \\nspacewise solution, but it is much harder to write I think.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nunordered_map <int, int> m, cnt;\\nqueue <int> q;\\nint n;\\nLRUCache(int capacity) : n(capacity) {}\\nint get(int key) {\\n\\tif (cnt.find(key) == cnt.end()) \\n\\t\\treturn -1;\\n\\tq.push(key);\\n\\tcnt[key]++;\\n\\treturn m[key];\\n}\\nvoid put(int key, int value) {\\n\\tq.push(key);\\n\\tcnt[key]++;\\n\\tm[key] = value;\\n\\twhile (cnt.size() > n) {\\n\\t\\tint cur = q.front(); q.pop();\\n\\t\\tif (cnt[cur]-- == 1) \\n\\t\\t\\tcnt.erase(cur);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594882,
                "title": "c-unordered-map-with-list-o-1-simple-code-with-comments",
                "content": "```\\nclass LRUCache {\\n    int capacity;\\n    list< pair<int,int> > lruList;     // key, value pair\\n    unordered_map< int, list<pair<int,int>>::iterator > hash;   // key to <key,val> iterator map\\n\\n    void moveToFront( int key, int value ) {\\n\\t    // erase and add a new entry to front\\n        lruList.erase( hash[key] ); // this is O(1) since we are using iterator\\n        lruList.push_front( make_pair(key, value) );\\n        hash[key] = lruList.begin();\\n    }\\npublic:\\n    LRUCache( int capacity ) {\\n        this->capacity = capacity;\\n    }\\n    \\n    int get( int key ) {\\n        if( hash.find(key) == hash.end() )\\n            return -1;\\n\\t\\t// move the key, value pair to front\\n        int value = (*hash[key]).second;\\n        moveToFront( key, value );\\n        return (*hash[key]).second;\\n    }\\n    \\n    void put( int key, int value ) {\\n        if( hash.find(key) != hash.end() ) {\\n            // when key is already in hash\\n            moveToFront( key, value );\\n        } else {\\n\\t\\t    // add to the cache\\n            lruList.push_front( make_pair( key, value ) );\\n            hash[key] = lruList.begin();\\n            if( hash.size() > capacity ) {\\n                // erase\\n                hash.erase( lruList.back().first );\\n                lruList.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\nOne important thing to note: I\\'m using an iterator to an entry in list (iterator is guaranteed to remain valid unless deleted).\\nWe can\\'t use deque instead of list as the iterator validity is not guaranteed. I learn this while coding this.\\n",
                "solutionTags": [],
                "code": "```\\nclass LRUCache {\\n    int capacity;\\n    list< pair<int,int> > lruList;     // key, value pair\\n    unordered_map< int, list<pair<int,int>>::iterator > hash;   // key to <key,val> iterator map\\n\\n    void moveToFront( int key, int value ) {\\n\\t    // erase and add a new entry to front\\n        lruList.erase( hash[key] ); // this is O(1) since we are using iterator\\n        lruList.push_front( make_pair(key, value) );\\n        hash[key] = lruList.begin();\\n    }\\npublic:\\n    LRUCache( int capacity ) {\\n        this->capacity = capacity;\\n    }\\n    \\n    int get( int key ) {\\n        if( hash.find(key) == hash.end() )\\n            return -1;\\n\\t\\t// move the key, value pair to front\\n        int value = (*hash[key]).second;\\n        moveToFront( key, value );\\n        return (*hash[key]).second;\\n    }\\n    \\n    void put( int key, int value ) {\\n        if( hash.find(key) != hash.end() ) {\\n            // when key is already in hash\\n            moveToFront( key, value );\\n        } else {\\n\\t\\t    // add to the cache\\n            lruList.push_front( make_pair( key, value ) );\\n            hash[key] = lruList.begin();\\n            if( hash.size() > capacity ) {\\n                // erase\\n                hash.erase( lruList.back().first );\\n                lruList.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165620,
                "title": "python-elegant-o-1-solution",
                "content": "Here we use in-built Python3 methods, which are most optimized. \\n\\n```python\\nclass LRUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.od = collections.OrderedDict()\\n        self.cap = capacity\\n\\n    def get(self, key):\\n        if key not in self.od: return -1\\n        self.od.move_to_end(key)\\n        return self.od[key]\\n\\n    def put(self, key, value):\\n        if key in self.od:\\n            del self.od[key]\\n            self.od[key] = value\\n        else:\\n            while len(self.od) >= self.cap:\\n                self.od.popitem(False)\\n            self.od[key] = value\\n```\\n\\n\\nHere is a more detailed solution without use of in-built methods\\n\\n```python\\nclass LRUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.od = collections.OrderedDict()\\n        self.cap = capacity\\n\\n    def get(self, key):\\n        if key not in self.od: return -1\\n        val = self.od[key]\\n        del self.od[key]\\n        self.od[key] = val\\n        return val\\n\\n    def put(self, key, value):\\n        if key in self.od:\\n            del self.od[key]\\n            self.od[key] = value\\n        else:\\n            while len(self.od) >= self.cap:\\n                toBeRemoved = next(iter(self.od))\\n                del self.od[toBeRemoved]\\n            self.od[key] = value\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass LRUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.od = collections.OrderedDict()\\n        self.cap = capacity\\n\\n    def get(self, key):\\n        if key not in self.od: return -1\\n        self.od.move_to_end(key)\\n        return self.od[key]\\n\\n    def put(self, key, value):\\n        if key in self.od:\\n            del self.od[key]\\n            self.od[key] = value\\n        else:\\n            while len(self.od) >= self.cap:\\n                self.od.popitem(False)\\n            self.od[key] = value\\n```\n```python\\nclass LRUCache(object):\\n\\n    def __init__(self, capacity):\\n        self.od = collections.OrderedDict()\\n        self.cap = capacity\\n\\n    def get(self, key):\\n        if key not in self.od: return -1\\n        val = self.od[key]\\n        del self.od[key]\\n        self.od[key] = val\\n        return val\\n\\n    def put(self, key, value):\\n        if key in self.od:\\n            del self.od[key]\\n            self.od[key] = value\\n        else:\\n            while len(self.od) >= self.cap:\\n                toBeRemoved = next(iter(self.od))\\n                del self.od[toBeRemoved]\\n            self.od[key] = value\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782410,
                "title": "fast-pythonic-solution",
                "content": "# Intuition\\nFor Python 3.7+ dictionary iteration order is guaranteed to be in order of insertion.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ for one operation.\\n\\n- Space complexity: $$O(1)$$ for one operation.\\n\\n# Code\\n```\\nclass LRUCache:\\n    def __init__(self, capacity):\\n        self.dict = {}\\n        self.freeSpace = capacity\\n\\n\\n    def get(self, key):\\n        if key not in self.dict:\\n            return -1\\n\\n        self.dict[key] = self.dict.pop(key)\\n\\n        return self.dict[key]\\n\\n\\n    def put(self, key, value):\\n        if key in self.dict:\\n            self.dict.pop(key)\\n        else:\\n            if self.freeSpace:\\n                self.freeSpace -= 1\\n            else:\\n                self.dict.pop(next(iter(self.dict)))\\n\\n        self.dict[key] = value\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Iterator"
                ],
                "code": "```\\nclass LRUCache:\\n    def __init__(self, capacity):\\n        self.dict = {}\\n        self.freeSpace = capacity\\n\\n\\n    def get(self, key):\\n        if key not in self.dict:\\n            return -1\\n\\n        self.dict[key] = self.dict.pop(key)\\n\\n        return self.dict[key]\\n\\n\\n    def put(self, key, value):\\n        if key in self.dict:\\n            self.dict.pop(key)\\n        else:\\n            if self.freeSpace:\\n                self.freeSpace -= 1\\n            else:\\n                self.dict.pop(next(iter(self.dict)))\\n\\n        self.dict[key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134851,
                "title": "es6-javascript-o-1-one-map-fewest-lines-of-code",
                "content": "```\\nclass LRUCache {\\n  constructor(capacity) {\\n    this.capacity = capacity;\\n    this.map = new Map();\\n  }\\n\\n  get(key) {\\n    let val = this.map.get(key);\\n    if (typeof val === \\'undefined\\') { return -1 }\\n    this.map.delete(key);\\n    this.map.set(key, val);\\n    return val;\\n  }\\n\\n  put(key, value) {\\n    if (this.map.has(key)) { this.map.delete(key) }\\n    this.map.set(key, value);\\n    let keys = this.map.keys();\\n    while (this.map.size > this.capacity) { this.map.delete(keys.next().value) }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LRUCache {\\n  constructor(capacity) {\\n    this.capacity = capacity;\\n    this.map = new Map();\\n  }\\n\\n  get(key) {\\n    let val = this.map.get(key);\\n    if (typeof val === \\'undefined\\') { return -1 }\\n    this.map.delete(key);\\n    this.map.set(key, val);\\n    return val;\\n  }\\n\\n  put(key, value) {\\n    if (this.map.has(key)) { this.map.delete(key) }\\n    this.map.set(key, value);\\n    let keys = this.map.keys();\\n    while (this.map.size > this.capacity) { this.map.delete(keys.next().value) }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221997,
                "title": "python-extremely-simple-soln-explained-beats-99",
                "content": "A hash-map, i.e. Python Dictionary solution. Time Complexity: O(1) for both `get` and `put`.\\n\\nBeginning with Python 3.7, Dictionary objects naturally store key-value pairs in the order of key insertion. So we can very easily identify the least recently used item with a single iteration of the dictionary keys, i.e. one can treat dictionary keys like a stack and the first key is the least-recently-used as long as we always replace accessed keys back to the top of the stack.\\n\\nImplementation detail of last line: To iterate the dictionary keys, I chose to use a generator object to simply generate a single key: `next(iter(self.cache))`, which is equivalent to `list(self.cache.keys())[0]` or `self.cache.items()[0][0]`. The reason behind doing this is because we can avoid a little bit of overhead required to generate a whole list of keys, which can be more time-consuming when capacity is large; i.e. generate one key O(1) versus a whole list of keys O(k).\\n\\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.capacity = capacity\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            self.put(key, self.cache[key])                 # Call to put to handle LRU placement\\n        return self.cache.get(key, -1)                     # Return a default of \\'-1\\' if key does not exist\\n        \\n\\n    def put(self, key: int, value: int) -> None:           # Method adds key-value to cache and pops the LRU item\\n        self.cache.pop(key, None)                          # Remove key-value if it exists\\n        self.cache[key] = value                            # Insert key-value at top of key stack\\n        if len(self.cache) > self.capacity:\\n            del self.cache[next(iter(self.cache))]         # Delete LRU (bottom of key stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.capacity = capacity\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            self.put(key, self.cache[key])                 # Call to put to handle LRU placement\\n        return self.cache.get(key, -1)                     # Return a default of \\'-1\\' if key does not exist\\n        \\n\\n    def put(self, key: int, value: int) -> None:           # Method adds key-value to cache and pops the LRU item\\n        self.cache.pop(key, None)                          # Remove key-value if it exists\\n        self.cache[key] = value                            # Insert key-value at top of key stack\\n        if len(self.cache) > self.capacity:\\n            del self.cache[next(iter(self.cache))]         # Delete LRU (bottom of key stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46188,
                "title": "my-easy-to-understand-java-solution-with-hashmap-and-doubly-linked-list",
                "content": "    class ListNode {\\n        int key;\\n        int val;\\n        ListNode prev;\\n        ListNode next;\\n        public ListNode(int k, int v) { key = k; val = v; }\\n    }\\n    \\n    class DoublyLinkedList {\\n        private ListNode head = null;\\n        private ListNode tail = null;\\n        \\n        public void addFirst(ListNode node) {\\n            if (head == null) {\\n                head = node;\\n                tail = node;\\n                return;\\n            }\\n    \\n            head.prev = node;\\n            node.next = head;\\n            node.prev = null;\\n            head = node;\\n        }\\n    \\n        public ListNode removeLast() {\\n            ListNode node = tail;\\n    \\n            if (tail.prev != null) {\\n                tail.prev.next = null;\\n                tail = tail.prev;\\n            } else {\\n                head = null;\\n                tail = null;\\n            }\\n    \\n            return node;\\n        }\\n        \\n        public void promote(ListNode node) {\\n            if (node.prev == null) {\\n                return;\\n            }\\n    \\n            node.prev.next = node.next;\\n            if (node.next == null) {\\n                tail = node.prev;\\n            } else {\\n                node.next.prev = node.prev;\\n            }\\n    \\n            head.prev = node;\\n            node.next = head;\\n            node.prev = null;\\n            head = node;\\n        }\\n    }\\n    \\n    public class LRUCache {\\n        private final Map<Integer, ListNode> cachedMap = new HashMap<>();\\n        private final DoublyLinkedList cachedList = new DoublyLinkedList();\\n        private final int capacity;\\n    \\n        public LRUCache(int capacity) {\\n            this.capacity = capacity;\\n        }\\n    \\n        public int get(int key) {\\n            if (!cachedMap.containsKey(key)) {\\n                return -1;\\n            }\\n    \\n            ListNode targetNode = cachedMap.get(key);\\n            cachedList.promote(targetNode);\\n    \\n            return targetNode.val;\\n        }\\n    \\n        public void set(int key, int value) {\\n            ListNode targetNode;\\n    \\n            if (cachedMap.containsKey(key)) {\\n                targetNode = cachedMap.get(key);\\n                targetNode.val = value;\\n                cachedList.promote(targetNode);\\n                return;\\n            }\\n    \\n            if (cachedMap.size() == capacity) {\\n                ListNode node = cachedList.removeLast();\\n                cachedMap.remove(node.key);\\n            }\\n    \\n            targetNode = new ListNode(key, value);\\n            cachedList.addFirst(targetNode);\\n            cachedMap.put(targetNode.key, targetNode);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class ListNode {\\n        int key;\\n        int val;\\n        ListNode prev;\\n        ListNode next;\\n        public ListNode(int k, int v) { key = k; val = v; }\\n    }\\n    \\n    class DoublyLinkedList {\\n        private ListNode head = null;\\n        private ListNode tail = null;\\n        \\n        public void addFirst(ListNode node) {\\n            if (head == null) {\\n                head = node;\\n                tail = node;\\n                return;\\n            }\\n    \\n            head.prev = node;\\n            node.next = head;\\n            node.prev = null;\\n            head = node;\\n        }\\n    \\n        public ListNode removeLast() {\\n            ListNode node = tail;\\n    \\n            if (tail.prev != null) {\\n                tail.prev.next = null;\\n                tail = tail.prev;\\n            } else {\\n                head = null;\\n                tail = null;\\n            }\\n    \\n            return node;\\n        }\\n        \\n        public void promote(ListNode node) {\\n            if (node.prev == null) {\\n                return;\\n            }\\n    \\n            node.prev.next = node.next;\\n            if (node.next == null) {\\n                tail = node.prev;\\n            } else {\\n                node.next.prev = node.prev;\\n            }\\n    \\n            head.prev = node;\\n            node.next = head;\\n            node.prev = null;\\n            head = node;\\n        }\\n    }\\n    \\n    public class LRUCache {\\n        private final Map<Integer, ListNode> cachedMap = new HashMap<>();\\n        private final DoublyLinkedList cachedList = new DoublyLinkedList();\\n        private final int capacity;\\n    \\n        public LRUCache(int capacity) {\\n            this.capacity = capacity;\\n        }\\n    \\n        public int get(int key) {\\n            if (!cachedMap.containsKey(key)) {\\n                return -1;\\n            }\\n    \\n            ListNode targetNode = cachedMap.get(key);\\n            cachedList.promote(targetNode);\\n    \\n            return targetNode.val;\\n        }\\n    \\n        public void set(int key, int value) {\\n            ListNode targetNode;\\n    \\n            if (cachedMap.containsKey(key)) {\\n                targetNode = cachedMap.get(key);\\n                targetNode.val = value;\\n                cachedList.promote(targetNode);\\n                return;\\n            }\\n    \\n            if (cachedMap.size() == capacity) {\\n                ListNode node = cachedList.removeLast();\\n                cachedMap.remove(node.key);\\n            }\\n    \\n            targetNode = new ListNode(key, value);\\n            cachedList.addFirst(targetNode);\\n            cachedMap.put(targetNode.key, targetNode);\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1157689,
                "title": "javascript-map",
                "content": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.map = new Map();\\n    this.capacity = capacity;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if(!this.map.has(key)) return -1;\\n    let value = this.map.get(key);\\n    this.map.delete(key);\\n    this.map.set(key, value)\\n    return value;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if(this.map.has(key)) this.map.delete(key);\\n    this.map.set(key, value);\\n    if (this.map.size > this.capacity) this.map.delete(this.map.keys().next().value);\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.map = new Map();\\n    this.capacity = capacity;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if(!this.map.has(key)) return -1;\\n    let value = this.map.get(key);\\n    this.map.delete(key);\\n    this.map.set(key, value)\\n    return value;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if(this.map.has(key)) this.map.delete(key);\\n    this.map.set(key, value);\\n    if (this.map.size > this.capacity) this.map.delete(this.map.keys().next().value);\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 3780810,
                "title": "c-faster-than-95-long-explanation-doubly-linked-list-hashing-clean-code",
                "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603579,
                "title": "tle-issue-solved",
                "content": "```\\nLRUCache(int capacity) {\\n        ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\\n    }\\n```\\nAdd this line to ur constructor function.\\n\\n\\n```\\nclass LRUCache {\\npublic:\\n    int cap, size;\\n    unordered_map<int, list<pair<int, int>>::iterator> mp;\\n    list<pair<int, int>> dq;\\n    LRUCache(int capacity) {\\n        ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\\n        cap = capacity;\\n        size = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key) == mp.end())\\n            return -1;\\n        int val = mp[key]->second;\\n        dq.erase(mp[key]);\\n        dq.push_front({key, val});\\n        mp[key] = dq.begin();\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key) != mp.end()) {\\n            dq.erase(mp[key]);\\n            size--;\\n        }\\n        dq.push_front({key, value});\\n        mp[key] = dq.begin();\\n        size++;\\n        \\n        if(size > cap) {\\n            int k = dq.back().first;\\n            mp.erase(k);\\n            dq.pop_back();\\n            size--;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLRUCache(int capacity) {\\n        ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\\n    }\\n```\n```\\nclass LRUCache {\\npublic:\\n    int cap, size;\\n    unordered_map<int, list<pair<int, int>>::iterator> mp;\\n    list<pair<int, int>> dq;\\n    LRUCache(int capacity) {\\n        ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\\n        cap = capacity;\\n        size = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key) == mp.end())\\n            return -1;\\n        int val = mp[key]->second;\\n        dq.erase(mp[key]);\\n        dq.push_front({key, val});\\n        mp[key] = dq.begin();\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key) != mp.end()) {\\n            dq.erase(mp[key]);\\n            size--;\\n        }\\n        dq.push_front({key, value});\\n        mp[key] = dq.begin();\\n        size++;\\n        \\n        if(size > cap) {\\n            int k = dq.back().first;\\n            mp.erase(k);\\n            dq.pop_back();\\n            size--;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1941828,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass LRUCache {\\n\\tvar cache: [Int: Node] = [:]\\n\\tvar count: Int = 0\\n\\tlet capacity: Int\\n\\tvar head: Node?\\n\\tvar tail: Node?\\n\\n\\n\\tinit(_ capacity: Int) {\\n\\t\\tself.capacity = capacity\\n\\t}\\n\\n    \\n\\tfunc get(_ key: Int) -> Int {\\n\\t\\tif let node = cache[key] {\\n\\t\\t\\tmoveToHead(node)\\n\\t\\t\\t\\n            return node.val\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tfunc put(_ key: Int, _ value: Int) {\\n\\t\\tif let node = cache[key] {\\n\\t\\t\\tnode.val = value\\n\\t\\t\\tmoveToHead(node)\\n\\n        } else {\\n\\t\\t\\tlet node = Node(key, value)\\n\\t\\t\\t\\n            node.next = head\\n\\t\\t\\thead?.prev = node\\n\\t\\t\\thead = node\\n\\t\\t\\tcache[key] = node\\n\\t\\t\\tcount += 1\\n            if tail == nil {\\n                tail = head\\n            }\\n\\t\\t}\\n        \\n\\t\\tif count > capacity {\\n\\t\\t\\tcache.removeValue(forKey: tail!.key)\\n\\t\\t\\ttail = tail?.prev\\n\\t\\t\\ttail?.next = nil\\n\\t\\t\\tcount -= 1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tfunc moveToHead(_ node: Node) {\\n\\t\\tif node === head {\\n\\t\\t\\treturn\\n\\t\\t} else {\\n\\t\\t\\tnode.prev?.next = node.next\\n\\t\\t\\tnode.next?.prev = node.prev\\n\\t\\t\\tnode.next = head\\n\\t\\t\\thead?.prev = node\\n\\t\\t\\thead = node\\n\\t\\t}\\n\\t\\tif node === tail {\\n\\t\\t\\ttail = tail?.prev\\n\\t\\t\\ttail?.next = nil\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nclass Node {\\n\\tvar key: Int\\n\\tvar val: Int\\n\\tvar prev: Node?\\n\\tvar next: Node?\\n\\t\\n    \\n    init(_ key: Int, _ val: Int) {\\n\\t\\tself.key = key\\n\\t\\tself.val = val\\n\\t}\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * let obj = LRUCache(capacity)\\n * let ret_1: Int = obj.get(key)\\n * obj.put(key, value)\\n */\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass LRUCache {\\n\\tvar cache: [Int: Node] = [:]\\n\\tvar count: Int = 0\\n\\tlet capacity: Int\\n\\tvar head: Node?\\n\\tvar tail: Node?\\n\\n\\n\\tinit(_ capacity: Int) {\\n\\t\\tself.capacity = capacity\\n\\t}\\n\\n    \\n\\tfunc get(_ key: Int) -> Int {\\n\\t\\tif let node = cache[key] {\\n\\t\\t\\tmoveToHead(node)\\n\\t\\t\\t\\n            return node.val\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tfunc put(_ key: Int, _ value: Int) {\\n\\t\\tif let node = cache[key] {\\n\\t\\t\\tnode.val = value\\n\\t\\t\\tmoveToHead(node)\\n\\n        } else {\\n\\t\\t\\tlet node = Node(key, value)\\n\\t\\t\\t\\n            node.next = head\\n\\t\\t\\thead?.prev = node\\n\\t\\t\\thead = node\\n\\t\\t\\tcache[key] = node\\n\\t\\t\\tcount += 1\\n            if tail == nil {\\n                tail = head\\n            }\\n\\t\\t}\\n        \\n\\t\\tif count > capacity {\\n\\t\\t\\tcache.removeValue(forKey: tail!.key)\\n\\t\\t\\ttail = tail?.prev\\n\\t\\t\\ttail?.next = nil\\n\\t\\t\\tcount -= 1\\n\\t\\t}\\n\\t}\\n\\n    \\n\\tfunc moveToHead(_ node: Node) {\\n\\t\\tif node === head {\\n\\t\\t\\treturn\\n\\t\\t} else {\\n\\t\\t\\tnode.prev?.next = node.next\\n\\t\\t\\tnode.next?.prev = node.prev\\n\\t\\t\\tnode.next = head\\n\\t\\t\\thead?.prev = node\\n\\t\\t\\thead = node\\n\\t\\t}\\n\\t\\tif node === tail {\\n\\t\\t\\ttail = tail?.prev\\n\\t\\t\\ttail?.next = nil\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nclass Node {\\n\\tvar key: Int\\n\\tvar val: Int\\n\\tvar prev: Node?\\n\\tvar next: Node?\\n\\t\\n    \\n    init(_ key: Int, _ val: Int) {\\n\\t\\tself.key = key\\n\\t\\tself.val = val\\n\\t}\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * let obj = LRUCache(capacity)\\n * let ret_1: Int = obj.get(key)\\n * obj.put(key, value)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565991,
                "title": "c-doubly-linkedlist-unordered-map",
                "content": "```\\nclass LRUCache {\\npublic:\\n    class node{\\n        public:\\n            int key;\\n            int val;\\n            node* prev;\\n            node* next;\\n            node(int key, int val){\\n                this->key = key;\\n                this->val = val;\\n            }\\n    };\\n    \\n    node* head = new node(-1,-1);\\n    node* tail = new node(-1,-1);\\n    int capacity;\\n    unordered_map<int,node*> map;\\n    \\n    LRUCache(int capacity) {\\n        this->capacity = capacity;\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    void deleteNode(node* curNode){\\n        node* prevNode = curNode->prev;\\n        node* nextNode = curNode->next;\\n        prevNode->next = nextNode;\\n        nextNode->prev = prevNode;\\n    }\\n    \\n    void addNode(node* curNode){\\n        curNode->next = head->next;\\n        curNode->prev = head;\\n        curNode->next->prev = curNode;\\n        head->next = curNode;\\n    }\\n    \\n    int get(int key) {\\n        if(map.find(key) == map.end()) return -1;\\n        node* curNode = map[key];\\n        int result = curNode->val;\\n        map.erase(key);\\n        deleteNode(curNode);\\n        addNode(curNode);\\n        map[key] = head->next;\\n        return result;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(map.find(key) != map.end()){\\n            node* curNode = map[key];\\n            map.erase(key);\\n            deleteNode(curNode);\\n        }\\n        if(map.size() == capacity){\\n            map.erase(tail->prev->key);\\n            deleteNode(tail->prev);\\n        }\\n        addNode(new node(key,value));\\n        map[key] = head->next;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    class node{\\n        public:\\n            int key;\\n            int val;\\n            node* prev;\\n            node* next;\\n            node(int key, int val){\\n                this->key = key;\\n                this->val = val;\\n            }\\n    };\\n    \\n    node* head = new node(-1,-1);\\n    node* tail = new node(-1,-1);\\n    int capacity;\\n    unordered_map<int,node*> map;\\n    \\n    LRUCache(int capacity) {\\n        this->capacity = capacity;\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    void deleteNode(node* curNode){\\n        node* prevNode = curNode->prev;\\n        node* nextNode = curNode->next;\\n        prevNode->next = nextNode;\\n        nextNode->prev = prevNode;\\n    }\\n    \\n    void addNode(node* curNode){\\n        curNode->next = head->next;\\n        curNode->prev = head;\\n        curNode->next->prev = curNode;\\n        head->next = curNode;\\n    }\\n    \\n    int get(int key) {\\n        if(map.find(key) == map.end()) return -1;\\n        node* curNode = map[key];\\n        int result = curNode->val;\\n        map.erase(key);\\n        deleteNode(curNode);\\n        addNode(curNode);\\n        map[key] = head->next;\\n        return result;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(map.find(key) != map.end()){\\n            node* curNode = map[key];\\n            map.erase(key);\\n            deleteNode(curNode);\\n        }\\n        if(map.size() == capacity){\\n            map.erase(tail->prev->key);\\n            deleteNode(tail->prev);\\n        }\\n        addNode(new node(key,value));\\n        map[key] = head->next;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391421,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Node {\\nint key;\\nint value;\\nNode pre;\\nNode next;\\n\\npublic Node(int key, int value) {\\n\\tthis.key = key;\\n\\tthis.value = value;\\n}\\n}\\npublic class LRUCache {\\n\\nHashMap<Integer, Node> map;\\nint capicity, count;\\nNode head, tail;\\n\\npublic LRUCache(int capacity) {\\n\\tthis.capicity = capacity;\\n\\tmap = new HashMap<>();\\n\\thead = new Node(0, 0);\\n\\ttail = new Node(0, 0);\\n\\thead.next = tail;\\n\\ttail.pre = head;\\n\\thead.pre = null;\\n\\ttail.next = null;\\n\\tcount = 0;\\n}\\n\\npublic void deleteNode(Node node) {\\n\\tnode.pre.next = node.next;\\n\\tnode.next.pre = node.pre;\\n}\\n\\npublic void addToHead(Node node) {\\n\\tnode.next = head.next;\\n\\tnode.next.pre = node;\\n\\tnode.pre = head;\\n\\thead.next = node;\\n}\\n\\npublic int get(int key) {\\n\\tif (map.get(key) != null) {\\n\\t\\tNode node = map.get(key);\\n\\t\\tint result = node.value;\\n\\t\\tdeleteNode(node);\\n\\t\\taddToHead(node);\\n\\t\\treturn result;\\n\\t}\\n\\treturn -1;\\n}\\n\\npublic void put(int key, int value) {\\n\\tif (map.get(key) != null) {\\n\\t\\tNode node = map.get(key);\\n\\t\\tnode.value = value;\\n\\t\\tdeleteNode(node);\\n\\t\\taddToHead(node);\\n\\t} else {\\n\\t\\tNode node = new Node(key, value);\\n\\t\\tmap.put(key, node);\\n\\t\\tif (count < capicity) {\\n\\t\\t\\tcount++;\\n\\t\\t\\taddToHead(node);\\n\\t\\t} else {\\n\\t\\t\\tmap.remove(tail.pre.key);\\n\\t\\t\\tdeleteNode(tail.pre);\\n\\t\\t\\taddToHead(node);\\n\\t\\t}\\n\\t}\\n}\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Node {\\nint key;\\nint value;\\nNode pre;\\nNode next;\\n\\npublic Node(int key, int value) {\\n\\tthis.key = key;\\n\\tthis.value = value;\\n}\\n}\\npublic class LRUCache {\\n\\nHashMap<Integer, Node> map;\\nint capicity, count;\\nNode head, tail;\\n\\npublic LRUCache(int capacity) {\\n\\tthis.capicity = capacity;\\n\\tmap = new HashMap<>();\\n\\thead = new Node(0, 0);\\n\\ttail = new Node(0, 0);\\n\\thead.next = tail;\\n\\ttail.pre = head;\\n\\thead.pre = null;\\n\\ttail.next = null;\\n\\tcount = 0;\\n}\\n\\npublic void deleteNode(Node node) {\\n\\tnode.pre.next = node.next;\\n\\tnode.next.pre = node.pre;\\n}\\n\\npublic void addToHead(Node node) {\\n\\tnode.next = head.next;\\n\\tnode.next.pre = node;\\n\\tnode.pre = head;\\n\\thead.next = node;\\n}\\n\\npublic int get(int key) {\\n\\tif (map.get(key) != null) {\\n\\t\\tNode node = map.get(key);\\n\\t\\tint result = node.value;\\n\\t\\tdeleteNode(node);\\n\\t\\taddToHead(node);\\n\\t\\treturn result;\\n\\t}\\n\\treturn -1;\\n}\\n\\npublic void put(int key, int value) {\\n\\tif (map.get(key) != null) {\\n\\t\\tNode node = map.get(key);\\n\\t\\tnode.value = value;\\n\\t\\tdeleteNode(node);\\n\\t\\taddToHead(node);\\n\\t} else {\\n\\t\\tNode node = new Node(key, value);\\n\\t\\tmap.put(key, node);\\n\\t\\tif (count < capicity) {\\n\\t\\t\\tcount++;\\n\\t\\t\\taddToHead(node);\\n\\t\\t} else {\\n\\t\\t\\tmap.remove(tail.pre.key);\\n\\t\\t\\tdeleteNode(tail.pre);\\n\\t\\t\\taddToHead(node);\\n\\t\\t}\\n\\t}\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259144,
                "title": "simplest-c-solution-using-map-and-list",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\nclass LRUCache {\\n    int cacheSize;\\n    list<pair<int,int>> cache;\\n    unordered_map<int, list<pair<int,int>>::iterator> map;\\npublic:\\n    LRUCache(int capacity) {\\n        cacheSize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(map.find(key) != map.end())\\n        {\\n            auto it = map[key];\\n            int value = it->second;\\n            cache.erase(it);\\n            cache.push_front({key,value});\\n            map[key] = cache.begin();\\n            return value;\\n        }\\n        else return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(map.find(key) == map.end())\\n        {\\n            if(cache.size() == cacheSize)\\n            {\\n                pair<int, int> lru = cache.back();\\n                cache.pop_back();\\n                map.erase(lru.first);\\n            }\\n        }\\n        else\\n        {\\n            cache.erase(map[key]);\\n        }\\n        cache.push_front({key,value});\\n        map[key] = cache.begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LRUCache {\\n    int cacheSize;\\n    list<pair<int,int>> cache;\\n    unordered_map<int, list<pair<int,int>>::iterator> map;\\npublic:\\n    LRUCache(int capacity) {\\n        cacheSize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(map.find(key) != map.end())\\n        {\\n            auto it = map[key];\\n            int value = it->second;\\n            cache.erase(it);\\n            cache.push_front({key,value});\\n            map[key] = cache.begin();\\n            return value;\\n        }\\n        else return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(map.find(key) == map.end())\\n        {\\n            if(cache.size() == cacheSize)\\n            {\\n                pair<int, int> lru = cache.back();\\n                cache.pop_back();\\n                map.erase(lru.first);\\n            }\\n        }\\n        else\\n        {\\n            cache.erase(map[key]);\\n        }\\n        cache.push_front({key,value});\\n        map[key] = cache.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680563,
                "title": "c-lru-cache-using-unordered-map-and-list-commented-and-faster-than-97-16",
                "content": "```\\nstatic const auto ___ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n// Runtime - 152 ms, Memory - 42.3 MB\\nclass LRUCache {\\n    int capacity;\\n    unordered_map<int, list<pair<int, int>>::iterator> dict;    // hash table to store key and iterator to node in list with that key\\n    list<pair<int, int>> cache;                                 // doubly linked list to store key-value pair starting from most freq used to least freq\\n    \\npublic:\\n    LRUCache(int capacity): capacity(capacity) {}\\n    \\n    int get(int key) {\\n        // return -1 if key not present in hash-table\\n        if(dict.find(key) == dict.end())    return -1;\\n        \\n        auto itr = dict[key];               // get iterator to pair with required key\\n        int val = (*itr).second;            // store value at required key\\n        cache.erase(itr);                   // delete pair\\n        cache.push_front({key, val});       // insert that pair again but at the front of cache\\n        dict[key] = cache.begin();          // store updated position of iterator for key\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        // if key already present in hash-table (also means, already in cache)\\n        if(dict.find(key) != dict.end()) {\\n            // remove pair from cache and insert pair with the same key but different value to front of cache and update iterator value in hash-table\\n            auto itr = dict[key];\\n            cache.erase(itr);\\n        }\\n        else {\\n            // if key not present already first check capacity of cache\\n            if(cache.size() == capacity) {\\n                // if capacity is full already pop out least recently used (last element from cache) key-value pair and corresponding entry from hash-table\\n                pair<int, int> lru = cache.back();\\n                cache.pop_back();\\n                dict.erase(lru.first);\\n            }\\n        }\\n\\n        // insert new pair in cache and its entry in hash-table\\n        cache.push_front({key, value});\\n        dict[key] = cache.begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic const auto ___ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n// Runtime - 152 ms, Memory - 42.3 MB\\nclass LRUCache {\\n    int capacity;\\n    unordered_map<int, list<pair<int, int>>::iterator> dict;    // hash table to store key and iterator to node in list with that key\\n    list<pair<int, int>> cache;                                 // doubly linked list to store key-value pair starting from most freq used to least freq\\n    \\npublic:\\n    LRUCache(int capacity): capacity(capacity) {}\\n    \\n    int get(int key) {\\n        // return -1 if key not present in hash-table\\n        if(dict.find(key) == dict.end())    return -1;\\n        \\n        auto itr = dict[key];               // get iterator to pair with required key\\n        int val = (*itr).second;            // store value at required key\\n        cache.erase(itr);                   // delete pair\\n        cache.push_front({key, val});       // insert that pair again but at the front of cache\\n        dict[key] = cache.begin();          // store updated position of iterator for key\\n        return val;\\n    }\\n    \\n    void put(int key, int value) {\\n        // if key already present in hash-table (also means, already in cache)\\n        if(dict.find(key) != dict.end()) {\\n            // remove pair from cache and insert pair with the same key but different value to front of cache and update iterator value in hash-table\\n            auto itr = dict[key];\\n            cache.erase(itr);\\n        }\\n        else {\\n            // if key not present already first check capacity of cache\\n            if(cache.size() == capacity) {\\n                // if capacity is full already pop out least recently used (last element from cache) key-value pair and corresponding entry from hash-table\\n                pair<int, int> lru = cache.back();\\n                cache.pop_back();\\n                dict.erase(lru.first);\\n            }\\n        }\\n\\n        // insert new pair in cache and its entry in hash-table\\n        cache.push_front({key, value});\\n        dict[key] = cache.begin();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 46149,
                "title": "clean-python-solution-with-unlink-node-and-insert-at-head-method-dictionary-doubly-linked-list",
                "content": "    class LRUCache(object):\\n        \\n        class ListNode(object):\\n            def __init__(self, k, v):\\n                self.k, self.v = k, v\\n                self.prev, self.next = None, None\\n    \\n        def __init__(self, capacity):\\n            \"\"\"\\n            :type capacity: int\\n            \"\"\"\\n            self.capacity, self.size, self.d = capacity, 0, {}\\n            self.head, self.tail = self.ListNode(0, 0), self.ListNode(0, 0)\\n            self.head.next, self.tail.prev = self.tail, self.head\\n        \\n        def __unlink_node(self, node):\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            node.prev, node.next = None, None\\n        \\n        def __insert_at_head(self, node):\\n            node.prev, node.next = self.head, self.head.next\\n            self.head.next.prev = node\\n            self.head.next = node\\n    \\n        def get(self, key):\\n            \"\"\"\\n            :rtype: int\\n            \"\"\"\\n            if key not in self.d:\\n                return -1\\n            node = self.d[key]\\n            self.__unlink_node(node)\\n            self.__insert_at_head(node)\\n            return node.v\\n            \\n        def set(self, key, value):\\n            \"\"\"\\n            :type key: int\\n            :type value: int\\n            :rtype: nothing\\n            \"\"\"\\n            if key in self.d:  # hit\\n                node = self.d[key]\\n                node.v = value\\n                self.__unlink_node(node)\\n                self.__insert_at_head(node)\\n            else:  # insert\\n                if self.size == self.capacity:\\n                    least_recently_used_node = self.tail.prev\\n                    self.__unlink_node(least_recently_used_node)\\n                    del self.d[least_recently_used_node.k]\\n                    self.size -= 1\\n                new_node = self.ListNode(key, value)\\n                self.__insert_at_head(new_node)\\n                self.d[key] = new_node\\n                self.size += 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class LRUCache(object):\\n        \\n        class ListNode(object):\\n            def __init__(self, k, v):\\n                self.k, self.v = k, v\\n                self.prev, self.next = None, None\\n    \\n        def __init__(self, capacity):\\n            \"\"\"\\n            :type capacity: int\\n            \"\"\"\\n            self.capacity, self.size, self.d = capacity, 0, {}\\n            self.head, self.tail = self.ListNode(0, 0), self.ListNode(0, 0)\\n            self.head.next, self.tail.prev = self.tail, self.head\\n        \\n        def __unlink_node(self, node):\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            node.prev, node.next = None, None\\n        \\n        def __insert_at_head(self, node):\\n            node.prev, node.next = self.head, self.head.next\\n            self.head.next.prev = node\\n            self.head.next = node\\n    \\n        def get(self, key):\\n            \"\"\"\\n            :rtype: int\\n            \"\"\"\\n            if key not in self.d:\\n                return -1\\n            node = self.d[key]\\n            self.__unlink_node(node)\\n            self.__insert_at_head(node)\\n            return node.v\\n            \\n        def set(self, key, value):\\n            \"\"\"\\n            :type key: int\\n            :type value: int\\n            :rtype: nothing\\n            \"\"\"\\n            if key in self.d:  # hit\\n                node = self.d[key]\\n                node.v = value\\n                self.__unlink_node(node)\\n                self.__insert_at_head(node)\\n            else:  # insert\\n                if self.size == self.capacity:\\n                    least_recently_used_node = self.tail.prev\\n                    self.__unlink_node(least_recently_used_node)\\n                    del self.d[least_recently_used_node.k]\\n                    self.size -= 1\\n                new_node = self.ListNode(key, value)\\n                self.__insert_at_head(new_node)\\n                self.d[key] = new_node\\n                self.size += 1",
                "codeTag": "Java"
            },
            {
                "id": 46200,
                "title": "java-solution-with-doubly-linked-list-hash-map",
                "content": "    /**\\n     * LRU cache. When cache is full, evict stalest entry.\\n     * \\n     * Phones - cache of files...a cache miss could mean an expensive network call. \\n     * \\n     * The cache itself is a doubly linked list where items at the tail get evicted first.\\n     * So new items are inserted into the head of the list.\\n     * \\n     * Need a hash table mapping keys to Nodes for quick lookup.\\n     * \\n     * Can't use java's LinkedList because for efficient removal we must update pointers\\n     * directly on Nodes returned from the map.\\n     * \\n     * If thread-safety is required and list scans can be tolerated, use Java's \\n     * ConcurrentLinkedQueue and HashTable.\\n     */\\n    public class LRUCache {\\n    \\tprivate Map<Integer, Node> map;\\n    \\tprivate Node head; // dummy \"fence\" head\\n    \\tprivate Node tail; // dummy \"fence\" tail\\n    \\tprivate int capacity;\\n    \\n    \\tpublic LRUCache(int capacity) {\\n    \\t\\tthis.capacity = capacity;\\n    \\t\\tmap = new HashMap<Integer, Node>();\\n    \\t\\thead = new Node(-1, -1);\\n    \\t\\ttail = new Node(-1, -1);\\n    \\t\\thead.next = tail; \\n    \\t\\ttail.prev = head; \\n    \\t}\\n    \\t\\n    \\tpublic int get(int key) {\\n    \\t\\tif( !map.containsKey(key) ) {\\n    \\t\\t\\treturn -1;\\n    \\t\\t}\\n    \\t\\tNode n = map.get(key);\\n    \\t\\tpromoteToHead(n);\\n    \\t\\treturn n.val;\\n    \\t}\\n    \\t\\n    \\tpublic void set(int key, int value) {\\n    \\t\\tNode n;\\n    \\t\\t// update existing Node; does not alter cache size\\n    \\t\\tif( map.containsKey(key) ) {\\n    \\t\\t\\tn = map.get(key);\\n    \\t\\t\\tn.val = value;   // map.get(n.key) will now return node with new val\\n    \\t\\t\\tpromoteToHead(n);\\n    \\t\\t\\t\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif( map.size() == capacity ) {\\n    \\t\\t\\tNode last = tail.prev;\\n    \\t\\t\\tmap.remove(last.key);\\n    \\t\\t\\tremove(last);\\n    \\t\\t}\\n    \\t\\tn = new Node(key, value);\\n    \\t\\taddFirst(n);\\n    \\t\\tmap.put(key, n);\\n    \\t}\\n    \\n    \\t/**\\n    \\t * Move given Node to head of queue.\\n    \\t */\\n    \\tprivate void promoteToHead(Node n) {\\n    \\t\\tif( head != n ) {\\n    \\t\\t\\tremove(n);\\n    \\t\\t\\taddFirst(n);\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t/**\\n    \\t * Remove given Node from queue.\\n    \\t */\\n    \\tprivate void remove(Node n) {\\n    \\t\\tn.prev.next = n.next;\\n    \\t\\tn.next.prev = n.prev;\\n    \\t}\\n    \\n    \\t/**\\n    \\t * Insert given Node to head of queue.\\n    \\t */\\n    \\tprivate void addFirst(Node n) {\\n    \\t\\t// first insert looks like:\\n    \\t\\t//  -1 <-> -1\\n    \\t\\t//  -1 <-> n <-> -1\\n    \\t\\tNode temp = head.next;\\n    \\t\\thead.next = n;\\n    \\t\\tn.prev = head;\\n    \\t\\tn.next = temp;\\n    \\t\\tn.next.prev = n;\\n    \\t}\\n    \\t\\n    \\tpublic void printCache() throws Exception {\\n    \\t\\tif( head.next == tail ) {\\n    \\t\\t\\tthrow new Exception(\"empty cache!\");\\n    \\t\\t}\\n    \\t\\tNode n = head.next;\\n    \\t\\tSystem.out.print(\"[ \");\\n    \\t\\twhile( n != tail ) {\\n    \\t\\t\\tSystem.out.print(n.val + \" \");\\n    \\t\\t\\tn = n.next;\\n    \\t\\t}\\n    \\t\\tSystem.out.println(\"]\");\\n    \\t}\\n    \\t\\n    \\tpublic class Node {\\n        \\tint key;\\n        \\tint val;\\n        \\tNode prev;\\n        \\tNode next;\\n        \\t\\t\\n        \\tpublic Node(int key, int val) {\\n        \\t\\tthis.key = key;\\n        \\t\\tthis.val = val;\\n        \\t}\\n        }\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * LRU cache. When cache is full, evict stalest entry.\\n     * \\n     * Phones - cache of files...a cache miss could mean an expensive network call. \\n     * \\n     * The cache itself is a doubly linked list where items at the tail get evicted first.\\n     * So new items are inserted into the head of the list.\\n     * \\n     * Need a hash table mapping keys to Nodes for quick lookup.\\n     * \\n     * Can't use java's LinkedList because for efficient removal we must update pointers\\n     * directly on Nodes returned from the map.\\n     * \\n     * If thread-safety is required and list scans can be tolerated, use Java's \\n     * ConcurrentLinkedQueue and HashTable.\\n     */\\n    public class LRUCache {\\n    \\tprivate Map<Integer, Node> map;\\n    \\tprivate Node head; // dummy \"fence\" head\\n    \\tprivate Node tail; // dummy \"fence\" tail\\n    \\tprivate int capacity;\\n    \\n    \\tpublic LRUCache(int capacity) {\\n    \\t\\tthis.capacity = capacity;\\n    \\t\\tmap = new HashMap<Integer, Node>();\\n    \\t\\thead = new Node(-1, -1);\\n    \\t\\ttail = new Node(-1, -1);\\n    \\t\\thead.next = tail; \\n    \\t\\ttail.prev = head; \\n    \\t}\\n    \\t\\n    \\tpublic int get(int key) {\\n    \\t\\tif( !map.containsKey(key) ) {\\n    \\t\\t\\treturn -1;\\n    \\t\\t}\\n    \\t\\tNode n = map.get(key);\\n    \\t\\tpromoteToHead(n);\\n    \\t\\treturn n.val;\\n    \\t}\\n    \\t\\n    \\tpublic void set(int key, int value) {\\n    \\t\\tNode n;\\n    \\t\\t// update existing Node; does not alter cache size\\n    \\t\\tif( map.containsKey(key) ) {\\n    \\t\\t\\tn = map.get(key);\\n    \\t\\t\\tn.val = value;   // map.get(n.key) will now return node with new val\\n    \\t\\t\\tpromoteToHead(n);\\n    \\t\\t\\t\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif( map.size() == capacity ) {\\n    \\t\\t\\tNode last = tail.prev;\\n    \\t\\t\\tmap.remove(last.key);\\n    \\t\\t\\tremove(last);\\n    \\t\\t}\\n    \\t\\tn = new Node(key, value);\\n    \\t\\taddFirst(n);\\n    \\t\\tmap.put(key, n);\\n    \\t}\\n    \\n    \\t/**\\n    \\t * Move given Node to head of queue.\\n    \\t */\\n    \\tprivate void promoteToHead(Node n) {\\n    \\t\\tif( head != n ) {\\n    \\t\\t\\tremove(n);\\n    \\t\\t\\taddFirst(n);\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t/**\\n    \\t * Remove given Node from queue.\\n    \\t */\\n    \\tprivate void remove(Node n) {\\n    \\t\\tn.prev.next = n.next;\\n    \\t\\tn.next.prev = n.prev;\\n    \\t}\\n    \\n    \\t/**\\n    \\t * Insert given Node to head of queue.\\n    \\t */\\n    \\tprivate void addFirst(Node n) {\\n    \\t\\t// first insert looks like:\\n    \\t\\t//  -1 <-> -1\\n    \\t\\t//  -1 <-> n <-> -1\\n    \\t\\tNode temp = head.next;\\n    \\t\\thead.next = n;\\n    \\t\\tn.prev = head;\\n    \\t\\tn.next = temp;\\n    \\t\\tn.next.prev = n;\\n    \\t}\\n    \\t\\n    \\tpublic void printCache() throws Exception {\\n    \\t\\tif( head.next == tail ) {\\n    \\t\\t\\tthrow new Exception(\"empty cache!\");\\n    \\t\\t}\\n    \\t\\tNode n = head.next;\\n    \\t\\tSystem.out.print(\"[ \");\\n    \\t\\twhile( n != tail ) {\\n    \\t\\t\\tSystem.out.print(n.val + \" \");\\n    \\t\\t\\tn = n.next;\\n    \\t\\t}\\n    \\t\\tSystem.out.println(\"]\");\\n    \\t}\\n    \\t\\n    \\tpublic class Node {\\n        \\tint key;\\n        \\tint val;\\n        \\tNode prev;\\n        \\tNode next;\\n        \\t\\t\\n        \\tpublic Node(int key, int val) {\\n        \\t\\tthis.key = key;\\n        \\t\\tthis.val = val;\\n        \\t}\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3781040,
                "title": "video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/0EPj92hqsDg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass LRUCache {\\n    \\n    class Node {\\n        int key;\\n        int val;\\n        Node next;\\n        Node prev;\\n\\n        public Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            next = null;\\n            prev = null;\\n        }\\n    }\\n    \\n    HashMap<Integer, Node> hashMap;\\n    Node MRU;\\n    Node LRU;\\n    int capacity;\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        hashMap = new HashMap<>();\\n        MRU = new Node(-1, -1);\\n        LRU = new Node(-1, -1);\\n        MRU.next = LRU;\\n        LRU.prev = MRU;\\n\\n    }\\n\\n    private void addNode(Node newNode) {\\n        Node temp = MRU.next;\\n        MRU.next = newNode;\\n        newNode.prev = MRU;\\n        newNode.next = temp;\\n        temp.prev = newNode;\\n    }\\n    \\n    private void deleteNode(Node node) {\\n        Node prev = node.prev;\\n        Node next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n\\n\\n    public int get(int key) {\\n        if (!hashMap.containsKey(key))\\n            return -1;\\n        put(key,hashMap.get(key).val);\\n        return hashMap.get(key).val;\\n        \\n    }\\n\\n    public void put(int key, int value) {\\n        if (hashMap.containsKey(key)) {\\n            Node node = hashMap.get(key);\\n            deleteNode(node);\\n            node.val = value;\\n            addNode(node);\\n            hashMap.put(key, MRU.next);\\n        } else {\\n            if (hashMap.size() == capacity) {\\n                Node prev = LRU.prev;\\n                deleteNode(prev);\\n                hashMap.remove(prev.key);       \\n            }\\n            Node newNode = new Node(key, value);\\n            addNode(newNode);\\n            hashMap.put(key, MRU.next);\\n        }\\n    }\\n}\\n```\\n\\n```\\nclass LRUCache {\\nprivate:\\n    struct Node {\\n        int key;\\n        int val;\\n        Node* next;\\n        Node* prev;\\n\\n        Node(int key, int val) : key(key), val(val), next(nullptr), prev(nullptr) {}\\n    };\\n\\n    unordered_map<int, Node*> hashMap;\\n    Node* MRU;\\n    Node* LRU;\\n    int capacity;\\n\\n    void addNode(Node* newNode) {\\n        Node* temp = MRU->next;\\n        MRU->next = newNode;\\n        newNode->prev = MRU;\\n        newNode->next = temp;\\n        temp->prev = newNode;\\n    }\\n\\n    void deleteNode(Node* node) {\\n        Node* prev = node->prev;\\n        Node* next = node->next;\\n        prev->next = next;\\n        next->prev = prev;\\n    }\\n\\npublic:\\n    LRUCache(int capacity) {\\n        this->capacity = capacity;\\n        hashMap = unordered_map<int, Node*>();\\n        MRU = new Node(-1, -1);\\n        LRU = new Node(-1, -1);\\n        MRU->next = LRU;\\n        LRU->prev = MRU;\\n    }\\n\\n    int get(int key) {\\n        if (hashMap.find(key) == hashMap.end())\\n            return -1;\\n        \\n        put(key, hashMap[key]->val);\\n        return hashMap[key]->val;\\n    }\\n\\n    void put(int key, int value) {\\n        if (hashMap.find(key) != hashMap.end()) {\\n            Node* node = hashMap[key];\\n            deleteNode(node);\\n            node->val = value;\\n            addNode(node);\\n            hashMap[key] = MRU->next;\\n        } else {\\n            if (hashMap.size() == capacity) {\\n                Node* prev = LRU->prev;\\n                deleteNode(prev);\\n                hashMap.erase(prev->key);\\n                delete prev;\\n            }\\n            Node* newNode = new Node(key, value);\\n            addNode(newNode);\\n            hashMap[key] = MRU->next;\\n        }\\n    }\\n};\\n```\\n```\\nclass LRUCache:\\n    class Node:\\n        def __init__(self, key, val):\\n            self.key = key\\n            self.val = val\\n            self.next = None\\n            self.prev = None\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.hashMap = {}\\n        self.MRU = self.Node(-1, -1)\\n        self.LRU = self.Node(-1, -1)\\n        self.MRU.next = self.LRU\\n        self.LRU.prev = self.MRU\\n\\n    def addNode(self, newNode):\\n        temp = self.MRU.next\\n        self.MRU.next = newNode\\n        newNode.prev = self.MRU\\n        newNode.next = temp\\n        temp.prev = newNode\\n\\n    def deleteNode(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hashMap:\\n            return -1\\n        self.put(key, self.hashMap[key].val)\\n        return self.hashMap[key].val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.hashMap:\\n            node = self.hashMap[key]\\n            self.deleteNode(node)\\n            node.val = value\\n            self.addNode(node)\\n            self.hashMap[key] = self.MRU.next\\n        else:\\n            if len(self.hashMap) == self.capacity:\\n                prev = self.LRU.prev\\n                self.deleteNode(prev)\\n                del self.hashMap[prev.key]\\n            newNode = self.Node(key, value)\\n            self.addNode(newNode)\\n            self.hashMap[key] = self.MRU.next\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass LRUCache {\\n    \\n    class Node {\\n        int key;\\n        int val;\\n        Node next;\\n        Node prev;\\n\\n        public Node(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            next = null;\\n            prev = null;\\n        }\\n    }\\n    \\n    HashMap<Integer, Node> hashMap;\\n    Node MRU;\\n    Node LRU;\\n    int capacity;\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        hashMap = new HashMap<>();\\n        MRU = new Node(-1, -1);\\n        LRU = new Node(-1, -1);\\n        MRU.next = LRU;\\n        LRU.prev = MRU;\\n\\n    }\\n\\n    private void addNode(Node newNode) {\\n        Node temp = MRU.next;\\n        MRU.next = newNode;\\n        newNode.prev = MRU;\\n        newNode.next = temp;\\n        temp.prev = newNode;\\n    }\\n    \\n    private void deleteNode(Node node) {\\n        Node prev = node.prev;\\n        Node next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n\\n\\n    public int get(int key) {\\n        if (!hashMap.containsKey(key))\\n            return -1;\\n        put(key,hashMap.get(key).val);\\n        return hashMap.get(key).val;\\n        \\n    }\\n\\n    public void put(int key, int value) {\\n        if (hashMap.containsKey(key)) {\\n            Node node = hashMap.get(key);\\n            deleteNode(node);\\n            node.val = value;\\n            addNode(node);\\n            hashMap.put(key, MRU.next);\\n        } else {\\n            if (hashMap.size() == capacity) {\\n                Node prev = LRU.prev;\\n                deleteNode(prev);\\n                hashMap.remove(prev.key);       \\n            }\\n            Node newNode = new Node(key, value);\\n            addNode(newNode);\\n            hashMap.put(key, MRU.next);\\n        }\\n    }\\n}\\n```\n```\\nclass LRUCache {\\nprivate:\\n    struct Node {\\n        int key;\\n        int val;\\n        Node* next;\\n        Node* prev;\\n\\n        Node(int key, int val) : key(key), val(val), next(nullptr), prev(nullptr) {}\\n    };\\n\\n    unordered_map<int, Node*> hashMap;\\n    Node* MRU;\\n    Node* LRU;\\n    int capacity;\\n\\n    void addNode(Node* newNode) {\\n        Node* temp = MRU->next;\\n        MRU->next = newNode;\\n        newNode->prev = MRU;\\n        newNode->next = temp;\\n        temp->prev = newNode;\\n    }\\n\\n    void deleteNode(Node* node) {\\n        Node* prev = node->prev;\\n        Node* next = node->next;\\n        prev->next = next;\\n        next->prev = prev;\\n    }\\n\\npublic:\\n    LRUCache(int capacity) {\\n        this->capacity = capacity;\\n        hashMap = unordered_map<int, Node*>();\\n        MRU = new Node(-1, -1);\\n        LRU = new Node(-1, -1);\\n        MRU->next = LRU;\\n        LRU->prev = MRU;\\n    }\\n\\n    int get(int key) {\\n        if (hashMap.find(key) == hashMap.end())\\n            return -1;\\n        \\n        put(key, hashMap[key]->val);\\n        return hashMap[key]->val;\\n    }\\n\\n    void put(int key, int value) {\\n        if (hashMap.find(key) != hashMap.end()) {\\n            Node* node = hashMap[key];\\n            deleteNode(node);\\n            node->val = value;\\n            addNode(node);\\n            hashMap[key] = MRU->next;\\n        } else {\\n            if (hashMap.size() == capacity) {\\n                Node* prev = LRU->prev;\\n                deleteNode(prev);\\n                hashMap.erase(prev->key);\\n                delete prev;\\n            }\\n            Node* newNode = new Node(key, value);\\n            addNode(newNode);\\n            hashMap[key] = MRU->next;\\n        }\\n    }\\n};\\n```\n```\\nclass LRUCache:\\n    class Node:\\n        def __init__(self, key, val):\\n            self.key = key\\n            self.val = val\\n            self.next = None\\n            self.prev = None\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.hashMap = {}\\n        self.MRU = self.Node(-1, -1)\\n        self.LRU = self.Node(-1, -1)\\n        self.MRU.next = self.LRU\\n        self.LRU.prev = self.MRU\\n\\n    def addNode(self, newNode):\\n        temp = self.MRU.next\\n        self.MRU.next = newNode\\n        newNode.prev = self.MRU\\n        newNode.next = temp\\n        temp.prev = newNode\\n\\n    def deleteNode(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hashMap:\\n            return -1\\n        self.put(key, self.hashMap[key].val)\\n        return self.hashMap[key].val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.hashMap:\\n            node = self.hashMap[key]\\n            self.deleteNode(node)\\n            node.val = value\\n            self.addNode(node)\\n            self.hashMap[key] = self.MRU.next\\n        else:\\n            if len(self.hashMap) == self.capacity:\\n                prev = self.LRU.prev\\n                self.deleteNode(prev)\\n                del self.hashMap[prev.key]\\n            newNode = self.Node(key, value)\\n            self.addNode(newNode)\\n            self.hashMap[key] = self.MRU.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931834,
                "title": "c-using-unordered-map-hash-and-list-doubly-linked-list-with-basic-inline-comments",
                "content": "Runtime: 76 ms, faster than 94.53% of C++ online submissions for LRU Cache.\\nMemory Usage: 42.1 MB, less than 25.12% of C++ online submissions for LRU Cache.\\n\\n```\\nusing key = int;\\n\\nstruct Entry {\\n    int value;\\n    list<key>::iterator itr;\\n};\\n\\nclass LRUCache {\\n    unordered_map<key, Entry> _cache;\\n    //old keys move to back, new ones enter at front\\n    list<key> _age;\\n    int _capacity;\\npublic:\\n    LRUCache(int capacity) {\\n        _capacity = capacity;\\n    }\\n\\n    int get(int key) {\\n        //if key is present, renew its age and return value\\n        if (_cache.count(key)) {\\n            _age.erase(_cache[key].itr);\\n            _age.push_front(key);\\n            _cache[key].itr = _age.begin();\\n            return _cache[key].value;\\n        }\\n        return -1;\\n    }\\n\\n    void put(int key, int value) {\\n        //if key is not present, check if the old entry need to be erased\\n        if (!_cache.count(key)) {\\n            if (_cache.size() == _capacity) {\\n                _cache.erase(_age.back());\\n                _age.pop_back();\\n            }\\n        }\\n        //key is present, just renew the age\\n        else {\\n            _age.erase(_cache[key].itr);\\n        }\\n        _age.push_front(key);\\n        _cache[key] = { value, _age.begin() };\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Doubly-Linked List"
                ],
                "code": "```\\nusing key = int;\\n\\nstruct Entry {\\n    int value;\\n    list<key>::iterator itr;\\n};\\n\\nclass LRUCache {\\n    unordered_map<key, Entry> _cache;\\n    //old keys move to back, new ones enter at front\\n    list<key> _age;\\n    int _capacity;\\npublic:\\n    LRUCache(int capacity) {\\n        _capacity = capacity;\\n    }\\n\\n    int get(int key) {\\n        //if key is present, renew its age and return value\\n        if (_cache.count(key)) {\\n            _age.erase(_cache[key].itr);\\n            _age.push_front(key);\\n            _cache[key].itr = _age.begin();\\n            return _cache[key].value;\\n        }\\n        return -1;\\n    }\\n\\n    void put(int key, int value) {\\n        //if key is not present, check if the old entry need to be erased\\n        if (!_cache.count(key)) {\\n            if (_cache.size() == _capacity) {\\n                _cache.erase(_age.back());\\n                _age.pop_back();\\n            }\\n        }\\n        //key is present, just renew the age\\n        else {\\n            _age.erase(_cache[key].itr);\\n        }\\n        _age.push_front(key);\\n        _cache[key] = { value, _age.begin() };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126734,
                "title": "c-linkedlist-dictionary",
                "content": "```\\n\\n    public class LRUCache\\n    {\\n        private const int NotFound = -1;\\n        private int _count;\\n        private readonly int _capacity;\\n        private readonly LinkedList<CacheItem> _items;\\n        private readonly Dictionary<int, LinkedListNode<CacheItem>> _keys;\\n\\n        public LRUCache(int capacity)\\n        {\\n            _items = new LinkedList<CacheItem>();\\n            _keys = new Dictionary<int, LinkedListNode<CacheItem>>(capacity);\\n            _count = 0;\\n            _capacity = capacity;\\n        }\\n\\n        public int Get(int key)\\n        {\\n            if (!_keys.ContainsKey(key))\\n            {\\n                return NotFound;\\n            }\\n\\n            var cacheItem = _keys[key];\\n\\n            if (cacheItem != _items.First)\\n            {\\n                // promote to most recently used\\n                _items.Remove(cacheItem);\\n                _items.AddFirst(cacheItem);\\n            }\\n\\n            return cacheItem.Value.Value;\\n        }\\n\\n        public void Put(int key, int value)\\n        {\\n            if (!_keys.ContainsKey(key))\\n            {\\n                // add\\n                _keys[key] = _items.AddFirst(new CacheItem(key, value));\\n\\n                if (_count == _capacity)\\n                {\\n                    // remove least recently used\\n                    var last = _items.Last;\\n                    _keys.Remove(last.Value.Key);\\n                    _items.RemoveLast();\\n                }\\n                else\\n                {\\n                    _count++;\\n                }\\n            }\\n            else\\n            {\\n                // update\\n                var cacheItem = _keys[key];\\n                cacheItem.Value.Value = value;\\n\\n                if (cacheItem != _items.First)\\n                {\\n                    // promote to most recently used\\n                    _items.Remove(cacheItem);\\n                    _items.AddFirst(cacheItem);\\n                }\\n            }\\n        }\\n\\n        private class CacheItem\\n        {\\n            public CacheItem(int key, int value)\\n            {\\n                Key = key;\\n                Value = value;\\n            }\\n\\n            public int Key { get; }\\n\\n            public int Value { get; set; }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public class LRUCache\\n    {\\n        private const int NotFound = -1;\\n        private int _count;\\n        private readonly int _capacity;\\n        private readonly LinkedList<CacheItem> _items;\\n        private readonly Dictionary<int, LinkedListNode<CacheItem>> _keys;\\n\\n        public LRUCache(int capacity)\\n        {\\n            _items = new LinkedList<CacheItem>();\\n            _keys = new Dictionary<int, LinkedListNode<CacheItem>>(capacity);\\n            _count = 0;\\n            _capacity = capacity;\\n        }\\n\\n        public int Get(int key)\\n        {\\n            if (!_keys.ContainsKey(key))\\n            {\\n                return NotFound;\\n            }\\n\\n            var cacheItem = _keys[key];\\n\\n            if (cacheItem != _items.First)\\n            {\\n                // promote to most recently used\\n                _items.Remove(cacheItem);\\n                _items.AddFirst(cacheItem);\\n            }\\n\\n            return cacheItem.Value.Value;\\n        }\\n\\n        public void Put(int key, int value)\\n        {\\n            if (!_keys.ContainsKey(key))\\n            {\\n                // add\\n                _keys[key] = _items.AddFirst(new CacheItem(key, value));\\n\\n                if (_count == _capacity)\\n                {\\n                    // remove least recently used\\n                    var last = _items.Last;\\n                    _keys.Remove(last.Value.Key);\\n                    _items.RemoveLast();\\n                }\\n                else\\n                {\\n                    _count++;\\n                }\\n            }\\n            else\\n            {\\n                // update\\n                var cacheItem = _keys[key];\\n                cacheItem.Value.Value = value;\\n\\n                if (cacheItem != _items.First)\\n                {\\n                    // promote to most recently used\\n                    _items.Remove(cacheItem);\\n                    _items.AddFirst(cacheItem);\\n                }\\n            }\\n        }\\n\\n        private class CacheItem\\n        {\\n            public CacheItem(int key, int value)\\n            {\\n                Key = key;\\n                Value = value;\\n            }\\n\\n            public int Key { get; }\\n\\n            public int Value { get; set; }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46153,
                "title": "easy-understanding-c-solution-using-unordered-map-and-list",
                "content": "Basically, the idea is to keep a cache using list, and keep a mapping between key and cache node's address (or you can say it's position). When a cache node is accessed, no matter whether it is an old node or newly inserted, update the mapped position of the accessed cache node to the first position in the list.\\n\\n    struct Cache {\\n        int _key;\\n        int _value;\\n        Cache(int key = 0, int value = 0) {\\n            _key = key;\\n            _value = value;\\n        }\\n    };\\n    \\n    class LRUCache{\\n        list<Cache> cache;\\n        unordered_map<int, list<Cache>::iterator> posMap;\\n        int _capacity;\\n    public:\\n        LRUCache(int capacity) {\\n            _capacity = capacity;\\n        }\\n        \\n        int get(int key) {\\n            if (posMap.find(key) == posMap.end()) return -1;\\n            //find the position of key\\n            auto it = posMap[key];\\n            //move the founded cache value to the front\\n            cache.push_front(*it);\\n            //delete the duplicate copy at the original position\\n            cache.erase(it);\\n            //update the posMap of key to new position: begin()\\n            posMap[key] = cache.begin();\\n            return posMap[key]->_value;\\n        }\\n        \\n        void set(int key, int value) {\\n            //if cannot find the new key in the cache, need to insert it\\n            //only in this case delete is needed, when cache size is larger than capacity\\n            //else just update the value and update the cache key position to the front\\n            if (posMap.find(key) == posMap.end()) {\\n                //insert the new cache value to the front\\n                cache.push_front(Cache(key, value));\\n                posMap[key] = cache.begin();\\n                //if size larger than capacity, delete the last value\\n                if (cache.size() > _capacity) {\\n                    //delete the last elements' iterator in map, and delete the last element\\n                    Cache lastNode = cache.back();\\n                    posMap.erase(lastNode._key);\\n                    cache.pop_back();\\n                }\\n            } else {\\n                //find the position of the key, update value and update pos to begin()\\n                auto it = posMap[key];\\n                it->_value = value;\\n                cache.push_front(*it);\\n                cache.erase(it);\\n                posMap[key] = cache.begin();\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "Basically, the idea is to keep a cache using list, and keep a mapping between key and cache node's address (or you can say it's position). When a cache node is accessed, no matter whether it is an old node or newly inserted, update the mapped position of the accessed cache node to the first position in the list.\\n\\n    struct Cache {\\n        int _key;\\n        int _value;\\n        Cache(int key = 0, int value = 0) {\\n            _key = key;\\n            _value = value;\\n        }\\n    };\\n    \\n    class LRUCache{\\n        list<Cache> cache;\\n        unordered_map<int, list<Cache>::iterator> posMap;\\n        int _capacity;\\n    public:\\n        LRUCache(int capacity) {\\n            _capacity = capacity;\\n        }\\n        \\n        int get(int key) {\\n            if (posMap.find(key) == posMap.end()) return -1;\\n            //find the position of key\\n            auto it = posMap[key];\\n            //move the founded cache value to the front\\n            cache.push_front(*it);\\n            //delete the duplicate copy at the original position\\n            cache.erase(it);\\n            //update the posMap of key to new position: begin()\\n            posMap[key] = cache.begin();\\n            return posMap[key]->_value;\\n        }\\n        \\n        void set(int key, int value) {\\n            //if cannot find the new key in the cache, need to insert it\\n            //only in this case delete is needed, when cache size is larger than capacity\\n            //else just update the value and update the cache key position to the front\\n            if (posMap.find(key) == posMap.end()) {\\n                //insert the new cache value to the front\\n                cache.push_front(Cache(key, value));\\n                posMap[key] = cache.begin();\\n                //if size larger than capacity, delete the last value\\n                if (cache.size() > _capacity) {\\n                    //delete the last elements' iterator in map, and delete the last element\\n                    Cache lastNode = cache.back();\\n                    posMap.erase(lastNode._key);\\n                    cache.pop_back();\\n                }\\n            } else {\\n                //find the position of the key, update value and update pos to begin()\\n                auto it = posMap[key];\\n                it->_value = value;\\n                cache.push_front(*it);\\n                cache.erase(it);\\n                posMap[key] = cache.begin();\\n            }\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3624964,
                "title": "best-o-1-solution",
                "content": "# Approach\\nUsing DLL & Hashmap\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass LRUCache {\\npublic:\\n    class Node {\\n    public:\\n        int key;\\n        int val;\\n        Node* prev;\\n        Node* next;\\n        Node (int _key, int _val) {\\n            key = _key;\\n            val = _val;\\n        }\\n    };\\n\\n    int cap;\\n    unordered_map<int, Node*> mp;\\n\\n    Node* head = new Node(-1, -1);\\n    Node* tail = new Node(-1, -1);\\n\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n\\n    void addNode(Node* newNode) {\\n        Node* temp = head->next;\\n        newNode->next = temp;\\n        newNode->prev = head;\\n        head->next = newNode;\\n        temp->prev = newNode;\\n    }\\n    \\n    void deleteNode(Node* delNode) {\\n        Node* delPrev = delNode->prev;\\n        Node* delNext = delNode->next;\\n        delPrev->next = delNext;\\n        delNext->prev = delPrev;\\n    }\\n\\n    int get(int key) {\\n        if (mp.find(key) != mp.end()) {\\n            Node* resNode = mp[key];\\n            int res = resNode->val;\\n            deleteNode(resNode);\\n            addNode(resNode);\\n            mp[key] = head->next;\\n            return res;\\n        } \\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (mp.find(key) != mp.end()) {\\n            Node* existingNode = mp[key];\\n            mp.erase(key);\\n            deleteNode(existingNode);\\n        }\\n        if (mp.size() == cap) {\\n            mp.erase(tail->prev->key);\\n            deleteNode(tail->prev);\\n        }\\n        addNode(new Node(key, value));\\n        mp[key] = head->next;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    class Node {\\n    public:\\n        int key;\\n        int val;\\n        Node* prev;\\n        Node* next;\\n        Node (int _key, int _val) {\\n            key = _key;\\n            val = _val;\\n        }\\n    };\\n\\n    int cap;\\n    unordered_map<int, Node*> mp;\\n\\n    Node* head = new Node(-1, -1);\\n    Node* tail = new Node(-1, -1);\\n\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n\\n    void addNode(Node* newNode) {\\n        Node* temp = head->next;\\n        newNode->next = temp;\\n        newNode->prev = head;\\n        head->next = newNode;\\n        temp->prev = newNode;\\n    }\\n    \\n    void deleteNode(Node* delNode) {\\n        Node* delPrev = delNode->prev;\\n        Node* delNext = delNode->next;\\n        delPrev->next = delNext;\\n        delNext->prev = delPrev;\\n    }\\n\\n    int get(int key) {\\n        if (mp.find(key) != mp.end()) {\\n            Node* resNode = mp[key];\\n            int res = resNode->val;\\n            deleteNode(resNode);\\n            addNode(resNode);\\n            mp[key] = head->next;\\n            return res;\\n        } \\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if (mp.find(key) != mp.end()) {\\n            Node* existingNode = mp[key];\\n            mp.erase(key);\\n            deleteNode(existingNode);\\n        }\\n        if (mp.size() == cap) {\\n            mp.erase(tail->prev->key);\\n            deleteNode(tail->prev);\\n        }\\n        addNode(new Node(key, value));\\n        mp[key] = head->next;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027314,
                "title": "easy-to-understand-hash-map-doubly-linked-list-intuition-and-approach-and-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo first we have to understand this problem we have to create LRU means least recent used for example:-you have three cars 1 farrari, 2 BMW, 3 Audi day 1 you go to office with farrari on day 2 with Audi and on day 3 with BMW so u have recently used BMW and Audi but u have used farrari long ago so u used it least recent. similarly we are given a key value pair we have to make least recent used cache in which we are given a container with certain and so if container is full we will remove least recent used element from container and insert new (key,value) capacity. I hope u are able to understand the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo we are going to use a container Doubly linked list having head and tail pointer |head|->|tail| & |head|<-|tail| and a unordered map to find key unordered_map<int,DoublyLinkedListNoderefrence> so if any key value pair came.\\n#### Put\\n1. I find it in my hashmap if it is not present and size of unorderd map is less than container then I create a newNode right to head node of doubly linked list and insert map[key]=newNode.\\n2. continer is full then I delete the Node from Linked List left to tail delete(tail->prev). and then do same insertion as point 1.\\n3. if it is availabe in map then we make it most recent used we delete it from its location and put it right to head(head->next=NewNode) and update key value with newNode.\\n#### Get\\n- For get we just find the key in hashmap and if it is not present then return -1.  elseif it is present then delete it from its location make it most recently used right to head and return its value\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(capacity)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LRUCache {\\n//Doubly linked List creation\\n  int cap;\\n  struct Node{\\n    int key;\\n    int data;\\n    struct Node*prev,*next;\\n   Node(int x,int y)\\n    {\\n      key=x;\\n      data =y;\\n      prev=NULL;\\n      next=NULL;\\n    }\\n  };\\n  unordered_map<int,Node*> mp;\\n     \\n        \\npublic:\\n          Node*head=new Node(0,0);\\n        Node*tail=new Node(0,0);\\n       \\n    LRUCache(int capacity) {\\n//assigning capcity and default doubly linked list\\n        cap=capacity;\\n        head->next=tail;\\n        tail->prev=head;\\n    }\\n\\n// function to create Node\\n    Node* createNode(int key,int val)\\n    {\\n      Node*newNode=new Node(key,val);\\n        newNode->next=head->next;\\n            head->next->prev=newNode;\\n            head->next=newNode;\\n            newNode->prev=head;\\n            return newNode;\\n    }\\n    int get(int key) {\\n      if(mp.find(key)!=mp.end())\\n      {\\n          auto it=mp.find(key);\\n          int ans=it->second->data;\\n          Node*newNode=createNode(it->second->key,it->second->data);\\n          deleteNode(it->second);\\n          mp.erase(key);\\n          mp[key]=newNode;\\n          return newNode->data;\\n\\n      }\\n      return -1;\\n    }\\n\\n//function to delete node\\n    void deleteNode(Node* x)\\n    {\\n      Node*temp=x;\\n      temp->prev->next=temp->next;\\n      temp->next->prev=temp->prev;\\n      temp->next=NULL;\\n      temp->prev=NULL;\\n      delete temp;\\n      \\n    }\\n    void put(int key, int value) {\\n//checking if key present in map or not\\n       if(mp.find(key)==mp.end())\\n       {\\n//checking if container has capacity or not\\n         if(mp.size()<cap)\\n         {\\n\\n            Node*newNode=createNode(key,value);\\n            mp[key]=newNode;\\n          }\\n          else\\n          {\\n              Node*x=tail->prev;\\n              int y=x->key;\\n              deleteNode(x);\\n              mp.erase(y);\\n             Node*newNode=createNode(key,value);\\n            mp[key]=newNode;\\n          }\\n       }\\n       else\\n       {\\n         auto it=mp.find(key);\\n         Node*x=it->second;\\n              int y=x->key;\\n              deleteNode(x);\\n              mp.erase(y);\\n               Node*newNode=new Node(key,value);\\n            newNode->next=head->next;\\n            head->next->prev=newNode;\\n            head->next=newNode;\\n            newNode->prev=head;\\n            mp[key]=newNode;\\n       } \\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n## If You find it helpful please UPVOTE\\u2B06\\uFE0F it .\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LRUCache {\\n//Doubly linked List creation\\n  int cap;\\n  struct Node{\\n    int key;\\n    int data;\\n    struct Node*prev,*next;\\n   Node(int x,int y)\\n    {\\n      key=x;\\n      data =y;\\n      prev=NULL;\\n      next=NULL;\\n    }\\n  };\\n  unordered_map<int,Node*> mp;\\n     \\n        \\npublic:\\n          Node*head=new Node(0,0);\\n        Node*tail=new Node(0,0);\\n       \\n    LRUCache(int capacity) {\\n//assigning capcity and default doubly linked list\\n        cap=capacity;\\n        head->next=tail;\\n        tail->prev=head;\\n    }\\n\\n// function to create Node\\n    Node* createNode(int key,int val)\\n    {\\n      Node*newNode=new Node(key,val);\\n        newNode->next=head->next;\\n            head->next->prev=newNode;\\n            head->next=newNode;\\n            newNode->prev=head;\\n            return newNode;\\n    }\\n    int get(int key) {\\n      if(mp.find(key)!=mp.end())\\n      {\\n          auto it=mp.find(key);\\n          int ans=it->second->data;\\n          Node*newNode=createNode(it->second->key,it->second->data);\\n          deleteNode(it->second);\\n          mp.erase(key);\\n          mp[key]=newNode;\\n          return newNode->data;\\n\\n      }\\n      return -1;\\n    }\\n\\n//function to delete node\\n    void deleteNode(Node* x)\\n    {\\n      Node*temp=x;\\n      temp->prev->next=temp->next;\\n      temp->next->prev=temp->prev;\\n      temp->next=NULL;\\n      temp->prev=NULL;\\n      delete temp;\\n      \\n    }\\n    void put(int key, int value) {\\n//checking if key present in map or not\\n       if(mp.find(key)==mp.end())\\n       {\\n//checking if container has capacity or not\\n         if(mp.size()<cap)\\n         {\\n\\n            Node*newNode=createNode(key,value);\\n            mp[key]=newNode;\\n          }\\n          else\\n          {\\n              Node*x=tail->prev;\\n              int y=x->key;\\n              deleteNode(x);\\n              mp.erase(y);\\n             Node*newNode=createNode(key,value);\\n            mp[key]=newNode;\\n          }\\n       }\\n       else\\n       {\\n         auto it=mp.find(key);\\n         Node*x=it->second;\\n              int y=x->key;\\n              deleteNode(x);\\n              mp.erase(y);\\n               Node*newNode=new Node(key,value);\\n            newNode->next=head->next;\\n            head->next->prev=newNode;\\n            head->next=newNode;\\n            newNode->prev=head;\\n            mp[key]=newNode;\\n       } \\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736254,
                "title": "python3-hashmap-doubly-linked-list-ordereddict-o-1-time-and-o-capacity-space-complexity",
                "content": "**HashMap + Doubly Linked List**\\n```Python\\nclass Node:\\n    def __init__(self, key=None, val=None):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        \\n        \\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.capacity = capacity\\n        self.size = 0\\n        self.ketToNode = dict()\\n    \\n    \\n    def addToTail(self, key, val):\\n        node = Node(key, val)\\n        node.prev = self.tail.prev\\n        node.next = self.tail\\n        self.tail.prev.next = node\\n        self.tail.prev = node\\n        self.ketToNode[key] = node\\n        self.size += 1\\n        \\n        \\n    def delete(self, key):\\n        node = self.ketToNode[key]\\n        del self.ketToNode[key]\\n        prevNode = node.prev\\n        nextNode = node.next\\n        prevNode.next = nextNode\\n        nextNode.prev = prevNode\\n        self.size -= 1\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.ketToNode:\\n            return -1\\n        \\n        value = self.ketToNode[key].val\\n        self.delete(key)\\n        self.addToTail(key, value)\\n        return value\\n            \\n        \\n    def put(self, key: int, value: int) -> None:\\n        if key in self.ketToNode:\\n            self.delete(key)\\n            self.addToTail(key, value)\\n            return\\n        \\n        if self.size == self.capacity:\\n            self.delete(self.head.next.key)\\n        \\n        self.addToTail(key, value)\\n```\\n\\n**OrderedDict**\\n```Python\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.linkedHashMap = collections.OrderedDict()\\n        self.capacity = capacity\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.linkedHashMap:\\n            return -1\\n        self.linkedHashMap.move_to_end(key)\\n        return self.linkedHashMap[key]\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.linkedHashMap:\\n            self.linkedHashMap.move_to_end(key)\\n            self.linkedHashMap[key] = value\\n            return\\n        \\n        if len(self.linkedHashMap) == self.capacity:\\n            self.linkedHashMap.popitem(last=False)\\n        self.linkedHashMap[key] = value\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```Python\\nclass Node:\\n    def __init__(self, key=None, val=None):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n        \\n        \\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.head = Node()\\n        self.tail = Node()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.capacity = capacity\\n        self.size = 0\\n        self.ketToNode = dict()\\n    \\n    \\n    def addToTail(self, key, val):\\n        node = Node(key, val)\\n        node.prev = self.tail.prev\\n        node.next = self.tail\\n        self.tail.prev.next = node\\n        self.tail.prev = node\\n        self.ketToNode[key] = node\\n        self.size += 1\\n        \\n        \\n    def delete(self, key):\\n        node = self.ketToNode[key]\\n        del self.ketToNode[key]\\n        prevNode = node.prev\\n        nextNode = node.next\\n        prevNode.next = nextNode\\n        nextNode.prev = prevNode\\n        self.size -= 1\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.ketToNode:\\n            return -1\\n        \\n        value = self.ketToNode[key].val\\n        self.delete(key)\\n        self.addToTail(key, value)\\n        return value\\n            \\n        \\n    def put(self, key: int, value: int) -> None:\\n        if key in self.ketToNode:\\n            self.delete(key)\\n            self.addToTail(key, value)\\n            return\\n        \\n        if self.size == self.capacity:\\n            self.delete(self.head.next.key)\\n        \\n        self.addToTail(key, value)\\n```\n```Python\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.linkedHashMap = collections.OrderedDict()\\n        self.capacity = capacity\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.linkedHashMap:\\n            return -1\\n        self.linkedHashMap.move_to_end(key)\\n        return self.linkedHashMap[key]\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.linkedHashMap:\\n            self.linkedHashMap.move_to_end(key)\\n            self.linkedHashMap[key] = value\\n            return\\n        \\n        if len(self.linkedHashMap) == self.capacity:\\n            self.linkedHashMap.popitem(last=False)\\n        self.linkedHashMap[key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733820,
                "title": "easiest-java-solution-using-only-1-map",
                "content": "**Please upvote \\uD83D\\uDE4F\\uD83D\\uDE2D\\uD83D\\uDE4F\\uD83D\\uDE2D**\\n```\\nclass LRUCache {\\n    LinkedHashMap<Integer, Integer> cache;\\n    int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        cache = new LinkedHashMap<Integer, Integer>();\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(cache.containsKey(key)){\\n            cache.remove(key);\\n            cache.put(key, value);\\n        }\\n        else{\\n            cache.put(key, value);\\n            int size = cache.size();\\n            if(size>capacity){\\n                int oldest = cache.keySet().iterator().next();\\n                cache.remove(oldest);\\n            }\\n        }\\n    }\\n    \\n    public int get(int key) {\\n        if(cache.containsKey(key)){\\n            int k = (int)cache.get(key);\\n            cache.remove(key);\\n            cache.put(key, k);\\n            return k;\\n        }\\n        return -1;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LRUCache {\\n    LinkedHashMap<Integer, Integer> cache;\\n    int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        cache = new LinkedHashMap<Integer, Integer>();\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(cache.containsKey(key)){\\n            cache.remove(key);\\n            cache.put(key, value);\\n        }\\n        else{\\n            cache.put(key, value);\\n            int size = cache.size();\\n            if(size>capacity){\\n                int oldest = cache.keySet().iterator().next();\\n                cache.remove(oldest);\\n            }\\n        }\\n    }\\n    \\n    public int get(int key) {\\n        if(cache.containsKey(key)){\\n            int k = (int)cache.get(key);\\n            cache.remove(key);\\n            cache.put(key, k);\\n            return k;\\n        }\\n        return -1;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343031,
                "title": "lru-cache-explanation",
                "content": "* An LRU cache is built by combining two data structures: a doubly linked list and a hash map.\\n\\n* We\\'ll set up our linked list with the most-recently used item at the head of the list and the least-recently used item at the tail:\\n\\n* This lets us access the LRU element in O(1)O(1) time by looking at the tail of the list.\\n\\n* What about accessing a specific item in the cache ?\\n\\n* In general, finding an item in a linked list is O(n) time, since we need to walk the whole list. But the whole point of a cache is to get quick lookups. How could we speed that up?\\n\\n* We\\'ll add in a hash map that maps items to linked list nodes i.e we;ll map each key with its corresponding iterator of the linked list\\n\\n**Note: If we have the iterator for a particular element then we can access that element in O(1) in any STL**\\n\\n![image](https://assets.leetcode.com/users/images/65ce5e4d-a566-4ff1-a993-e2da0403cf84_1626503210.16682.png)\\n\\n**That lets us find an element in our cache\\'s linked list in O(1) time, instead of O(n)**\\n\\n# Approach\\n* Putting things together, here are the steps we\\'d run through each time an item was accessed:\\n\\n* Look up the item in our hash map.\\n\\n* If the item is in the hash table, then it\\'s already in our cache\\u2014this is called a \"**cache hit**\"\\n\\n* Use the hash table to quickly find the corresponding linked list node.\\n\\n* Move the item\\'s linked list node to the head of the linked list, since it\\'s now the most recently used (so it shouldn\\'t get evicted any time soon).\\n\\n* If the item isn\\'t in the hash table, we have a **cache miss**. We need to load the item into the cache:\\n\\n* If the cache is not full then simply insert the new node at the head since its the most recently used and also at  the same time insert its key and iterator in the map so that next time we can access this node in O(1) time\\n\\n* Is our cache full? If so, we need to evict something to make room:\\n\\n* Grab the least-recently used cache item\\u2014it\\'ll be at the tail of the linked list.\\n\\n* Evict that item from the cache by removing it from the linked list and the hash map.\\n\\n* Create a new linked list node for the item. Insert it at the head of the linked list.\\n\\n* Add the item to our hash map, storing the newly-created linked list node as the value.\\n\\n### Remember: Whole point of using a map is to find the MRU and the LRU of the linked lists in O(1) time by mapping each with their corresponding iterators\\n\\n## Note:\\nIn the below code the value in the map is  a iterator so to access any STL using iterator we do *iterartor\\nEg\\n```\\n int value=(*mp[key]).second;  \\n```\\nlist has pair (key,value) and the iteratoro for each pair is stored in map as value\\nso we do *mp[key] to access the iterator and if we need value of the iterator then *mp[key].second and if we needed key then *mp[key].first\\n\\n\\n# Code\\n```\\nclass LRUCache {\\n    int Capacity;\\n    list<pair<int,int>> dq;  // {key,value}\\n    unordered_map<int,list<pair<int,int>> :: iterator> mp;  // {key,iterator}\\n    \\npublic:\\n    LRUCache(int capacity) {\\n        Capacity=capacity;\\n    }\\n    \\n    int get(int key) {\\n        \\n        if(mp.find(key)!=mp.end())\\n        {\\n            int value=(*mp[key]).second;              // updating it to make it MRU\\n            dq.erase(mp[key]);\\n            dq.push_front({key,value});   \\n            mp[key]=dq.begin();                    // since MRU is at head so iterator=dq.begin()\\n            return value;\\n        }\\n        else return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end())           // if present then update it to make it MRU\\n        {  \\n            dq.erase(mp[key]);\\n            dq.push_front({key,value});\\n            mp[key]=dq.begin();\\n        }\\n        else {\\n            if(dq.size()<Capacity)                   // just insert\\n            {\\n                dq.push_front({key,value});\\n                mp[key]=dq.begin();\\n            }\\n            else {                                             // erase the LRU and make new page as MRU\\n                int victimKey=dq.back().first;\\n                dq.pop_back();\\n                mp.erase(victimKey);\\n                dq.push_front({key,value});\\n                mp[key]=dq.begin();\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n int value=(*mp[key]).second;  \\n```\n```\\nclass LRUCache {\\n    int Capacity;\\n    list<pair<int,int>> dq;  // {key,value}\\n    unordered_map<int,list<pair<int,int>> :: iterator> mp;  // {key,iterator}\\n    \\npublic:\\n    LRUCache(int capacity) {\\n        Capacity=capacity;\\n    }\\n    \\n    int get(int key) {\\n        \\n        if(mp.find(key)!=mp.end())\\n        {\\n            int value=(*mp[key]).second;              // updating it to make it MRU\\n            dq.erase(mp[key]);\\n            dq.push_front({key,value});   \\n            mp[key]=dq.begin();                    // since MRU is at head so iterator=dq.begin()\\n            return value;\\n        }\\n        else return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end())           // if present then update it to make it MRU\\n        {  \\n            dq.erase(mp[key]);\\n            dq.push_front({key,value});\\n            mp[key]=dq.begin();\\n        }\\n        else {\\n            if(dq.size()<Capacity)                   // just insert\\n            {\\n                dq.push_front({key,value});\\n                mp[key]=dq.begin();\\n            }\\n            else {                                             // erase the LRU and make new page as MRU\\n                int victimKey=dq.back().first;\\n                dq.pop_back();\\n                mp.erase(victimKey);\\n                dq.push_front({key,value});\\n                mp[key]=dq.begin();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172804,
                "title": "clean-javascript-d",
                "content": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.capacity = capacity;\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if (!this.cache.has(key)) return -1;\\n    const value = this.cache.get(key);\\n    this.cache.delete(key);\\n    this.cache.set(key, value);\\n    return value;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    this.cache.delete(key);\\n    this.cache.set(key, value);\\n    if (this.cache.size > this.capacity) \\n        this.cache.delete(this.cache.keys().next().value);\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.capacity = capacity;\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if (!this.cache.has(key)) return -1;\\n    const value = this.cache.get(key);\\n    this.cache.delete(key);\\n    this.cache.set(key, value);\\n    return value;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    this.cache.delete(key);\\n    this.cache.set(key, value);\\n    if (this.cache.size > this.capacity) \\n        this.cache.delete(this.cache.keys().next().value);\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 811133,
                "title": "ordered-map-extension-o-1-and-easy-to-understand-linkedhashmap-queue",
                "content": "LRU cache is basically an ordered HashMap with a capacity limit.\\n\\nFor JavaScript, the Map datastructure keeps the insertion order, similar to Java\\'s LinkedHashMap. So, that\\'s all we need. We can handle it like a Queue, we insert to the end and remove from the begining of the list. Also, we need to move elements to the end of the list when they are read or overwritten. \\n\\nAlgorithm:\\n\\n- PUT: Every time we put a value, it will naturally go to the end of the list. \\n- PUT: If the value already exits we need to delete it from wherever it was and put it to the end.\\n- PUT: When doing a put, we check the capacity. If are over the limit, we delete the first element.\\n- GET: When we read a value, we have to move it from wherever it was an put it to the end.\\n- GET: If the value doesn\\'t exists, return `-1`;\\n\\nImplementation:\\n\\n```ts\\nclass LRUCache extends Map<number, any> {\\n  capacity: number;\\n  constructor(capacity: number) {\\n    super();\\n    this.capacity = capacity;\\n  }\\n\\n  get(key: number): number {\\n    if (super.has(key)) {\\n      const value = super.get(key);\\n      super.delete(key);\\n      super.set(key, value);\\n      return value;\\n    }\\n    return -1;\\n  }\\n\\n  put(key: number, value: number): void {\\n    if (super.has(key)) super.delete(key); // move it to the end if it exits\\n    super.set(key, value);\\n    if (super.size > this.capacity) super.delete(super.keys().next().value); // delete first\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Queue"
                ],
                "code": "```ts\\nclass LRUCache extends Map<number, any> {\\n  capacity: number;\\n  constructor(capacity: number) {\\n    super();\\n    this.capacity = capacity;\\n  }\\n\\n  get(key: number): number {\\n    if (super.has(key)) {\\n      const value = super.get(key);\\n      super.delete(key);\\n      super.set(key, value);\\n      return value;\\n    }\\n    return -1;\\n  }\\n\\n  put(key: number, value: number): void {\\n    if (super.has(key)) super.delete(key); // move it to the end if it exits\\n    super.set(key, value);\\n    if (super.size > this.capacity) super.delete(super.keys().next().value); // delete first\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320393,
                "title": "python-99-76-time-65-16-space-ordereddict-o-1-all",
                "content": "Python `OrderedDict` is a subclass of a `dict` with features of the Double Linked List. It stores original dict as well as mapping of keys to links in a doubly linked list\\n\\nEach link is stored as a list of length three:  [PREV, NEXT, KEY]. - from sources\\nSo all operations - `move_to_end`, `pop`, `popitem` kills it in `O(1)` time.\\n\\nSome may say that it is not what interviewers want to see. But remember that you have limited time on the real interview and in most cases, LRU cache is only start of the challenge and your interviewer will introduce more and more complex subissues  to solve on the fly\\n```\\nfrom collections import OrderedDict\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.dict = OrderedDict()\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.dict:\\n            return -1\\n        self.dict.move_to_end(key)\\n        return self.dict[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.dict:\\n            self.dict.pop(key)\\n            \\n        self.dict[key] = value\\n        if len(self.dict) > self.cap:\\n            self.dict.popitem(last=False) \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nfrom collections import OrderedDict\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.dict = OrderedDict()\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.dict:\\n            return -1\\n        self.dict.move_to_end(key)\\n        return self.dict[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.dict:\\n            self.dict.pop(key)\\n            \\n        self.dict[key] = value\\n        if len(self.dict) > self.cap:\\n            self.dict.popitem(last=False) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 225231,
                "title": "python3-solution-using-dict-beats-100-no-linked-list",
                "content": "We can implement a LRU cache using ```OrderedDict``` but we don\\'t need to -- the good old ```dict``` suffices since it is already **ordered**, i.e. it remembers the order of insertion of its keys. By using ```dict``` you can get better performance as it is implemented in C as opposed ```OrderedDict``` which is implemented in pure Python. It also enables us true O(n) space complexity as it won\\'t be storing a linked list or a hidden second ```dict``` to remember the order of insertion like ```OrderedDict```. Time complexity is O(1).\\n\\n```\\nclass LRUCache(dict):\\n\\tdef __init__(self, cap):\\n\\t\\tself.remaining = cap\\n\\t\\t\\n\\tdef get(self, key):\\n\\t\\tif key not in self:\\n\\t\\t\\treturn -1\\n\\t\\tval = self.pop(key) # pop and re-insert to keep the order\\n\\t\\tself[key] = val\\n\\t\\treturn val\\n\\t\\t\\n\\tdef put(self, key, value):\\n\\t\\tif key in self:\\n\\t\\t\\tself.pop(key)\\n\\t\\telse:\\n\\t\\t\\tif self.remaining > 0: self.remaining -= 1\\n\\t\\t\\telse: self.pop(next(iter(self))) # cache is full, remove least recently used key which is the first key \\n\\t\\tself[key] = value\\n```",
                "solutionTags": [],
                "code": "```OrderedDict```\n```dict```\n```dict```\n```OrderedDict```\n```dict```\n```OrderedDict```\n```\\nclass LRUCache(dict):\\n\\tdef __init__(self, cap):\\n\\t\\tself.remaining = cap\\n\\t\\t\\n\\tdef get(self, key):\\n\\t\\tif key not in self:\\n\\t\\t\\treturn -1\\n\\t\\tval = self.pop(key) # pop and re-insert to keep the order\\n\\t\\tself[key] = val\\n\\t\\treturn val\\n\\t\\t\\n\\tdef put(self, key, value):\\n\\t\\tif key in self:\\n\\t\\t\\tself.pop(key)\\n\\t\\telse:\\n\\t\\t\\tif self.remaining > 0: self.remaining -= 1\\n\\t\\t\\telse: self.pop(next(iter(self))) # cache is full, remove least recently used key which is the first key \\n\\t\\tself[key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46181,
                "title": "a-simple-ruby-solution-only-using-build-in-hash",
                "content": "Since ruby 1.9, build-in Hash records the order of insertion, so there is a simple solution. (running time: 148 ms )\\n\\n    class LRUCache\\n      # Initialize your data structure here\\n      # @param {Integer} capacity\\n      def initialize(capacity)\\n        @capacity = capacity\\n        @elems = {}\\n      end\\n    \\n      # @param {Integer} key\\n      # @return {Integer}\\n      def get(key)\\n        val = @elems.delete key\\n        if val\\n          @elems[key] = val\\n        else\\n          -1\\n        end\\n      end\\n    \\n      # @param {Integer} key\\n      # @param {Integer} value\\n      # @return {Void}\\n      def set(key, value)\\n        @elems.delete key\\n        @elems[key] = value\\n        @elems.delete @elems.first.first if @elems.size > @capacity \\n      end\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Since ruby 1.9, build-in Hash records the order of insertion, so there is a simple solution. (running time: 148 ms )\\n\\n    class LRUCache\\n      # Initialize your data structure here\\n      # @param {Integer} capacity\\n      def initialize(capacity)\\n        @capacity = capacity\\n        @elems = {}\\n      end\\n    \\n      # @param {Integer} key\\n      # @return {Integer}\\n      def get(key)\\n        val = @elems.delete key\\n        if val\\n          @elems[key] = val\\n        else\\n          -1\\n        end\\n      end\\n    \\n      # @param {Integer} key\\n      # @param {Integer} value\\n      # @return {Void}\\n      def set(key, value)\\n        @elems.delete key\\n        @elems[key] = value\\n        @elems.delete @elems.first.first if @elems.size > @capacity \\n      end\\n    end",
                "codeTag": "Java"
            },
            {
                "id": 46160,
                "title": "o-1-java-solution",
                "content": "    public class LRUCache {\\n        private HashMap <Integer,Node>map;\\n        private int cap;\\n        private int number;\\n        Node head;\\n        Node tail;\\n        public LRUCache(int capacity) {\\n            cap=capacity;\\n            number=0;\\n            head=new Node(-1,-1);\\n            head.pre=null;\\n            head.next=null;\\n            tail=head;\\n            map=new HashMap<Integer,Node>(capacity);\\n        }\\n        \\n        public int get(int key) {\\n            Node ret=map.get(new Integer(key));\\n            if(ret==null) return -1;\\n            refresh(ret);\\n            return ret.value;\\n           \\n        }\\n        public void refresh(Node node){\\n            if(node==head.next) return ;\\n            Node temp=head.next ; //head node in the map;\\n            Node nodePre=node.pre;\\n            Node nodeNext=node.next; //save\\n            head.next=node;\\n            node.pre=head;\\n            temp.pre=node;\\n            node.next=temp;\\n            nodePre.next=nodeNext;\\n            if(nodeNext!=null)   nodeNext.pre=nodePre;\\n                else tail=nodePre;\\n            \\n        }\\n        \\n        public void set(int key, int value) {\\n            Node ret=map.get(new Integer(key));\\n            if(ret!=null) {\\n                refresh(ret);\\n                ret.value=value;\\n            }\\n            else {\\n                //check and delete \\n                if(number==cap){\\n                    Node temp=tail;\\n                    tail=tail.pre;\\n                    tail.next=null;\\n                    map.remove(new Integer(temp.key));\\n                    number--;\\n                }\\n                number++;\\n                //add in the last and refresh\\n                Node node=new Node(key,value);\\n                node.pre=tail;\\n                node.next=null;\\n                tail.next=node;\\n                tail=node;\\n                map.put(key,node);\\n                refresh(node);\\n            }\\n            \\n        }\\n        class Node{\\n            int key;\\n            int value;\\n            Node pre;\\n            Node next;\\n            public Node(int k,int v){\\n                value=v;\\n                key=k;\\n            }\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class LRUCache {\\n        private HashMap <Integer,Node>map;\\n        private int cap;\\n        private int number;\\n        Node head;\\n        Node tail;\\n        public LRUCache(int capacity) {\\n            cap=capacity;\\n            number=0;\\n            head=new Node(-1,-1);\\n            head.pre=null;\\n            head.next=null;\\n            tail=head;\\n            map=new HashMap<Integer,Node>(capacity);\\n        }\\n        \\n        public int get(int key) {\\n            Node ret=map.get(new Integer(key));\\n            if(ret==null) return -1;\\n            refresh(ret);\\n            return ret.value;\\n           \\n        }\\n        public void refresh(Node node){\\n            if(node==head.next) return ;\\n            Node temp=head.next ; //head node in the map;\\n            Node nodePre=node.pre;\\n            Node nodeNext=node.next; //save\\n            head.next=node;\\n            node.pre=head;\\n            temp.pre=node;\\n            node.next=temp;\\n            nodePre.next=nodeNext;\\n            if(nodeNext!=null)   nodeNext.pre=nodePre;\\n                else tail=nodePre;\\n            \\n        }\\n        \\n        public void set(int key, int value) {\\n            Node ret=map.get(new Integer(key));\\n            if(ret!=null) {\\n                refresh(ret);\\n                ret.value=value;\\n            }\\n            else {\\n                //check and delete \\n                if(number==cap){\\n                    Node temp=tail;\\n                    tail=tail.pre;\\n                    tail.next=null;\\n                    map.remove(new Integer(temp.key));\\n                    number--;\\n                }\\n                number++;\\n                //add in the last and refresh\\n                Node node=new Node(key,value);\\n                node.pre=tail;\\n                node.next=null;\\n                tail.next=node;\\n                tail=node;\\n                map.put(key,node);\\n                refresh(node);\\n            }\\n            \\n        }\\n        class Node{\\n            int key;\\n            int value;\\n            Node pre;\\n            Node next;\\n            public Node(int k,int v){\\n                value=v;\\n                key=k;\\n            }\\n            \\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3601736,
                "title": "python-3-double-linked-list-with-moving-existing-node-after-using",
                "content": "```python3 []\\nclass LinkedNode:\\n    def __init__(self, key = -1, val = -1):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = dict()\\n        self.head = LinkedNode()\\n        self.tail = LinkedNode()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        \\n        return self.__moveToEnd(key).val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.cache:\\n            self.__delete(key)\\n        self.__create(key, value)\\n        \\n        if len(self.cache) > self.capacity:\\n            self.__delete(self.head.next.key)\\n\\n    def __create(self, key, val) -> LinkedNode: \\n        node = LinkedNode(key, val)\\n        self.__addToEnd(node)\\n        self.cache[key] = node\\n\\n        return node\\n    \\n    def __delete(self, key) -> None:\\n        deleteNode = self.__evict(key)\\n        del deleteNode\\n        del self.cache[key]\\n    \\n    def __moveToEnd(self, key) -> LinkedNode:\\n        node = self.__evict(key)\\n        self.__addToEnd(node)\\n        \\n        return node\\n\\n    def __addToEnd(self, node) -> None:\\n        node.prev = self.tail.prev\\n        node.next = self.tail\\n        self.tail.prev.next = node\\n        self.tail.prev = node\\n    \\n    def __evict(self, key) -> LinkedNode: \\n        node = self.cache[key]\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.next = None\\n        node.prev = None\\n        \\n        return node\\n```\\n![image.png](https://assets.leetcode.com/users/images/e55d0f49-768f-452e-bd1d-87b292f6201e_1689641575.6746032.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```python3 []\\nclass LinkedNode:\\n    def __init__(self, key = -1, val = -1):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = dict()\\n        self.head = LinkedNode()\\n        self.tail = LinkedNode()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        \\n        return self.__moveToEnd(key).val\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.cache:\\n            self.__delete(key)\\n        self.__create(key, value)\\n        \\n        if len(self.cache) > self.capacity:\\n            self.__delete(self.head.next.key)\\n\\n    def __create(self, key, val) -> LinkedNode: \\n        node = LinkedNode(key, val)\\n        self.__addToEnd(node)\\n        self.cache[key] = node\\n\\n        return node\\n    \\n    def __delete(self, key) -> None:\\n        deleteNode = self.__evict(key)\\n        del deleteNode\\n        del self.cache[key]\\n    \\n    def __moveToEnd(self, key) -> LinkedNode:\\n        node = self.__evict(key)\\n        self.__addToEnd(node)\\n        \\n        return node\\n\\n    def __addToEnd(self, node) -> None:\\n        node.prev = self.tail.prev\\n        node.next = self.tail\\n        self.tail.prev.next = node\\n        self.tail.prev = node\\n    \\n    def __evict(self, key) -> LinkedNode: \\n        node = self.cache[key]\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        node.next = None\\n        node.prev = None\\n        \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016427,
                "title": "c-highly-commented-2-maps-and-list-simple",
                "content": "Firstly, the Least Recently Used does not mean the most visited, but refers to to the cache which was just recently used and the list will be ordered in accordance in which cache was latest and recent in use.\\n\\nWe here use two maps to facilitate operation in O(1), one to store corresponding value of keys and other for corresponding position of the key in the list. The doubly linked list strucure (simply, list in C++ STL) is used as it can remove itself without any reference compared to singly linked list (forward_list in C++ STL, which use erase_after).\\n\\n\\n```\\nclass LRUCache {\\npublic:\\n    //One map to store the key and its corresponding value to facilitate O(1) time complexity\\n    map <int,int> keyval;\\n    \\n    //Similarly, one map to store the key and its corresponding positionn in the list\\n    map <int,list<int>::iterator> keypos;\\n    \\n    //A doubly linked list of keys\\n    list <int> keys;\\n    \\n    //Global variable siz and cap for other functions to know size and the total capacity of the cache\\n    int siz,cap;\\n    \\n\\t\\n    LRUCache(int capacity) {\\n        cap=capacity;//Initializing the LRU cache with the given positive size capacity.\\n        siz=0;//Keeping count of the total existing elements, which is initially 0       \\n    }\\n    \\n\\t\\n    int get(int key) {\\n        //If the key doesn\\'t exist in the LRU Cache, simply return -1\\n        if (keyval.find(key)==keyval.end())\\n            return -1;\\n        \\n        //\\uD83D\\uDCA1Since key exists we have to move key to front of the list (as it is now the least recently used cache) and return val\\n        \\n        //So, firstly erase key and its old position\\n        auto it= keypos[key];//Get the position of key in the list. This helps for searching list in O(1) throughout code.\\n        keys.erase(it);//Removing the key from our keys list\\n        keypos.erase(key);//And also erasing its position stored in the keypos map\\n        \\n        //Now push the key at front of the list and update its position in our map \\n        keys.push_front(key);\\n        keypos[key]=keys.begin();\\n        \\n        //didn\\'t update the value of list in get() so simply return it\\n        return keyval[key];\\n        \\n    }\\n    \\n\\t\\n    void put(int key, int value) {\\n        /*\\uD83D\\uDCA1We have to place the key at front as it is now the LRU .\\n        If it already exists in the cache so firstly delete it and put up front.\\n        Also we have to evict the last key from our list if the capacity is already full. \\n        Will write similar code like get () and simply mantain the data strucure we have created to facilitate O(1) average time complexity. */\\n        \\n        //So, firstly, if exist somewhere then delete so that it can be technically moved to front\\n        if (keyval.find(key)!=keyval.end())\\n        {\\n            auto it=keypos[key];\\n            keys.erase(it);\\n            keypos.erase(key);\\n            keyval.erase(key);\\n            siz--;\\n        }\\n        \\n        //Do check if capacity is reached then delete key from the last of the list\\n        if (siz==cap)\\n        {\\n            int lkey=keys.back();\\n            keys.pop_back();\\n            keypos.erase(lkey);\\n            keyval.erase(lkey);\\n            siz--;\\n        }\\n        \\n        //Now, simply place the new key at front of the list and mantain all the data structure we have created.\\n        keys.push_front(key);\\n        keypos[key]=keys.begin();\\n        keyval[key]=value;\\n        siz++;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n \\n ```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    //One map to store the key and its corresponding value to facilitate O(1) time complexity\\n    map <int,int> keyval;\\n    \\n    //Similarly, one map to store the key and its corresponding positionn in the list\\n    map <int,list<int>::iterator> keypos;\\n    \\n    //A doubly linked list of keys\\n    list <int> keys;\\n    \\n    //Global variable siz and cap for other functions to know size and the total capacity of the cache\\n    int siz,cap;\\n    \\n\\t\\n    LRUCache(int capacity) {\\n        cap=capacity;//Initializing the LRU cache with the given positive size capacity.\\n        siz=0;//Keeping count of the total existing elements, which is initially 0       \\n    }\\n    \\n\\t\\n    int get(int key) {\\n        //If the key doesn\\'t exist in the LRU Cache, simply return -1\\n        if (keyval.find(key)==keyval.end())\\n            return -1;\\n        \\n        //\\uD83D\\uDCA1Since key exists we have to move key to front of the list (as it is now the least recently used cache) and return val\\n        \\n        //So, firstly erase key and its old position\\n        auto it= keypos[key];//Get the position of key in the list. This helps for searching list in O(1) throughout code.\\n        keys.erase(it);//Removing the key from our keys list\\n        keypos.erase(key);//And also erasing its position stored in the keypos map\\n        \\n        //Now push the key at front of the list and update its position in our map \\n        keys.push_front(key);\\n        keypos[key]=keys.begin();\\n        \\n        //didn\\'t update the value of list in get() so simply return it\\n        return keyval[key];\\n        \\n    }\\n    \\n\\t\\n    void put(int key, int value) {\\n        /*\\uD83D\\uDCA1We have to place the key at front as it is now the LRU .\\n        If it already exists in the cache so firstly delete it and put up front.\\n        Also we have to evict the last key from our list if the capacity is already full. \\n        Will write similar code like get () and simply mantain the data strucure we have created to facilitate O(1) average time complexity. */\\n        \\n        //So, firstly, if exist somewhere then delete so that it can be technically moved to front\\n        if (keyval.find(key)!=keyval.end())\\n        {\\n            auto it=keypos[key];\\n            keys.erase(it);\\n            keypos.erase(key);\\n            keyval.erase(key);\\n            siz--;\\n        }\\n        \\n        //Do check if capacity is reached then delete key from the last of the list\\n        if (siz==cap)\\n        {\\n            int lkey=keys.back();\\n            keys.pop_back();\\n            keypos.erase(lkey);\\n            keyval.erase(lkey);\\n            siz--;\\n        }\\n        \\n        //Now, simply place the new key at front of the list and mantain all the data structure we have created.\\n        keys.push_front(key);\\n        keypos[key]=keys.begin();\\n        keyval[key]=value;\\n        siz++;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1116158,
                "title": "go-simple-elegant-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n```\\ntype LRUCache struct {\\n\\tHead, Tail *Node\\n\\tMp         map[int]*Node\\n\\tCapacity   int\\n}\\n\\nfunc newLRUCache(head, tail *Node, cap int) LRUCache {\\n\\treturn LRUCache{\\n\\t\\tHead:     head,\\n\\t\\tTail:     tail,\\n\\t\\tMp:       make(map[int]*Node),\\n\\t\\tCapacity: cap,\\n\\t}\\n}\\n\\ntype Node struct {\\n\\tPrev, Next *Node\\n\\tKey, Value int\\n}\\n\\nfunc newNode(key, val int) *Node {\\n\\treturn &Node{\\n\\t\\tKey:   key,\\n\\t\\tValue: val,\\n\\t}\\n}\\n\\nfunc Constructor(capacity int) LRUCache {\\n\\thead, tail := newNode(0, 0), newNode(0, 0)\\n\\n\\thead.Next = tail\\n\\ttail.Prev = head\\n\\treturn newLRUCache(head, tail, capacity)\\n}\\n\\nfunc (this *LRUCache) Get(key int) int {\\n\\tif n, ok := this.Mp[key]; ok {\\n\\t\\tthis.remove(n)\\n\\t\\tthis.insert(n)\\n\\t\\treturn n.Value\\n\\t}\\n\\n\\treturn -1\\n}\\n\\nfunc (this *LRUCache) Put(key int, value int) {\\n\\tif _, ok := this.Mp[key]; ok {\\n\\t\\tthis.remove(this.Mp[key])\\n\\t}\\n\\n\\tif len(this.Mp) == this.Capacity {\\n\\t\\tthis.remove(this.Tail.Prev)\\n\\t}\\n\\n\\tthis.insert(newNode(key, value))\\n}\\n\\nfunc (this *LRUCache) remove(node *Node) {\\n\\tdelete(this.Mp, node.Key)\\n\\tnode.Prev.Next = node.Next\\n\\tnode.Next.Prev = node.Prev\\n}\\n\\nfunc (this *LRUCache) insert(node *Node) {\\n\\tthis.Mp[node.Key] = node\\n\\tnext := this.Head.Next\\n\\tthis.Head.Next = node\\n\\tnode.Prev = this.Head\\n\\tnext.Prev = node\\n\\tnode.Next = next\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * obj := Constructor(capacity);\\n * param_1 := obj.Get(key);\\n * obj.Put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype LRUCache struct {\\n\\tHead, Tail *Node\\n\\tMp         map[int]*Node\\n\\tCapacity   int\\n}\\n\\nfunc newLRUCache(head, tail *Node, cap int) LRUCache {\\n\\treturn LRUCache{\\n\\t\\tHead:     head,\\n\\t\\tTail:     tail,\\n\\t\\tMp:       make(map[int]*Node),\\n\\t\\tCapacity: cap,\\n\\t}\\n}\\n\\ntype Node struct {\\n\\tPrev, Next *Node\\n\\tKey, Value int\\n}\\n\\nfunc newNode(key, val int) *Node {\\n\\treturn &Node{\\n\\t\\tKey:   key,\\n\\t\\tValue: val,\\n\\t}\\n}\\n\\nfunc Constructor(capacity int) LRUCache {\\n\\thead, tail := newNode(0, 0), newNode(0, 0)\\n\\n\\thead.Next = tail\\n\\ttail.Prev = head\\n\\treturn newLRUCache(head, tail, capacity)\\n}\\n\\nfunc (this *LRUCache) Get(key int) int {\\n\\tif n, ok := this.Mp[key]; ok {\\n\\t\\tthis.remove(n)\\n\\t\\tthis.insert(n)\\n\\t\\treturn n.Value\\n\\t}\\n\\n\\treturn -1\\n}\\n\\nfunc (this *LRUCache) Put(key int, value int) {\\n\\tif _, ok := this.Mp[key]; ok {\\n\\t\\tthis.remove(this.Mp[key])\\n\\t}\\n\\n\\tif len(this.Mp) == this.Capacity {\\n\\t\\tthis.remove(this.Tail.Prev)\\n\\t}\\n\\n\\tthis.insert(newNode(key, value))\\n}\\n\\nfunc (this *LRUCache) remove(node *Node) {\\n\\tdelete(this.Mp, node.Key)\\n\\tnode.Prev.Next = node.Next\\n\\tnode.Next.Prev = node.Prev\\n}\\n\\nfunc (this *LRUCache) insert(node *Node) {\\n\\tthis.Mp[node.Key] = node\\n\\tnext := this.Head.Next\\n\\tthis.Head.Next = node\\n\\tnode.Prev = this.Head\\n\\tnext.Prev = node\\n\\tnode.Next = next\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * obj := Constructor(capacity);\\n * param_1 := obj.Get(key);\\n * obj.Put(key,value);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 266148,
                "title": "javascript-map-only-1-data-structure",
                "content": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.m = new Map();\\n    this.capacity = capacity;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if(this.m.has(key))\\n    {\\n        // Remove and put key/value back into hash to move this key to the back (meaning recently used)\\n        var value = this.m.get(key);\\n        this.m.delete(key);\\n        this.m.set(key,value);\\n        return value;\\n    }else\\n    {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if(this.m.has(key)) //remove it and add it back with new value\\n    {\\n        this.m.delete(key);\\n        this.m.set(key,value);\\n    }else if(this.m.size == this.capacity) //remove the first key (Map adds new keys to the back)\\n    {\\n        var first_key = this.m.keys().next().value;\\n        this.m.delete(first_key);\\n        this.m.set(key,value);\\n    }else{  //Map has extra capacity\\n        this.m.set(key,value);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.m = new Map();\\n    this.capacity = capacity;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if(this.m.has(key))\\n    {\\n        // Remove and put key/value back into hash to move this key to the back (meaning recently used)\\n        var value = this.m.get(key);\\n        this.m.delete(key);\\n        this.m.set(key,value);\\n        return value;\\n    }else\\n    {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if(this.m.has(key)) //remove it and add it back with new value\\n    {\\n        this.m.delete(key);\\n        this.m.set(key,value);\\n    }else if(this.m.size == this.capacity) //remove the first key (Map adds new keys to the back)\\n    {\\n        var first_key = this.m.keys().next().value;\\n        this.m.delete(first_key);\\n        this.m.set(key,value);\\n    }else{  //Map has extra capacity\\n        this.m.set(key,value);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46073,
                "title": "java-solution-using-linkedhashmap",
                "content": "    import java.util.*;\\n    \\n    public class LRUCache {\\n        LinkedHashMap<Integer, Integer> cache;\\n        public LRUCache(int capacity) {\\n          cache = new LinkedHashMap<Integer, Integer>(){\\n          \\n          @Override\\n          protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\\n            if(cache.size() > capacity) {\\n              return true;\\n            }\\n            return false;\\n          }\\n        };\\n       }\\n        \\n        public int get(int key) {\\n          if(cache.containsKey(key)) {\\n            int value = cache.get(key);\\n            moveToFront(key);\\n            return value;\\n          }\\n          return -1;\\n        }\\n        \\n        void moveToFront(int key) {\\n     \\n          int val = cache.get(key);\\n          cache.remove(key);\\n          cache.put(key,val);\\n        }\\n        \\n        public void set(int key, int value) { \\n          cache.put(key, value);\\n          moveToFront(key);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    import java.util.*;\\n    \\n    public class LRUCache {\\n        LinkedHashMap<Integer, Integer> cache;\\n        public LRUCache(int capacity) {\\n          cache = new LinkedHashMap<Integer, Integer>(){\\n          \\n          @Override\\n          protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\\n            if(cache.size() > capacity) {\\n              return true;\\n            }\\n            return false;\\n          }\\n        };\\n       }\\n        \\n        public int get(int key) {\\n          if(cache.containsKey(key)) {\\n            int value = cache.get(key);\\n            moveToFront(key);\\n            return value;\\n          }\\n          return -1;\\n        }\\n        \\n        void moveToFront(int key) {\\n     \\n          int val = cache.get(key);\\n          cache.remove(key);\\n          cache.put(key,val);\\n        }\\n        \\n        public void set(int key, int value) { \\n          cache.put(key, value);\\n          moveToFront(key);\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 46231,
                "title": "a-short-c-solution-o-1-for-get-and-set-536ms",
                "content": "    public class LRUCache{\\n        private class LRUCacheItem{\\n            public int CacheKey { get; set; }\\n            public int CacheValue { get; set; }\\n        }\\n        // Caution here: in the Dictionary, LinkedListNode here is faster than LRUCacheItem\\n        private Dictionary<int, LinkedListNode<LRUCacheItem>> cacheMap = new Dictionary<int, LinkedListNode<LRUCacheItem>>();\\n        private LinkedList<LRUCacheItem> lruList = new LinkedList<LRUCacheItem>();\\n        private int capacity;\\n        public LRUCache(int capacity) { this.capacity = capacity;}\\n        public int Get(int key){\\n            if (!cacheMap.ContainsKey(key)) return -1;\\n            lruList.Remove(cacheMap[key]);\\n            lruList.AddLast(cacheMap[key]);\\n            return cacheMap[key].Value.CacheValue;\\n        }\\n        public void Set(int key, int val){\\n            if (cacheMap.ContainsKey(key)){\\n                cacheMap[key].Value.CacheValue = val;\\n                lruList.Remove(cacheMap[key]);\\n                lruList.AddLast(cacheMap[key]);\\n                return;\\n            }\\n            if (cacheMap.Count >= capacity){\\n                cacheMap.Remove(lruList.First.Value.CacheKey);\\n                lruList.RemoveFirst();\\n            }\\n            cacheMap.Add(key, new LinkedListNode<LRUCacheItem>(new LRUCacheItem { CacheKey = key, CacheValue = val }));\\n            lruList.AddLast(cacheMap[key]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class LRUCache{\\n        private class LRUCacheItem{\\n            public int CacheKey { get; set; }\\n            public int CacheValue { get; set; }\\n        }\\n        // Caution here: in the Dictionary, LinkedListNode here is faster than LRUCacheItem\\n        private Dictionary<int, LinkedListNode<LRUCacheItem>> cacheMap = new Dictionary<int, LinkedListNode<LRUCacheItem>>();\\n        private LinkedList<LRUCacheItem> lruList = new LinkedList<LRUCacheItem>();\\n        private int capacity;\\n        public LRUCache(int capacity) { this.capacity = capacity;}\\n        public int Get(int key){\\n            if (!cacheMap.ContainsKey(key)) return -1;\\n            lruList.Remove(cacheMap[key]);\\n            lruList.AddLast(cacheMap[key]);\\n            return cacheMap[key].Value.CacheValue;\\n        }\\n        public void Set(int key, int val){\\n            if (cacheMap.ContainsKey(key)){\\n                cacheMap[key].Value.CacheValue = val;\\n                lruList.Remove(cacheMap[key]);\\n                lruList.AddLast(cacheMap[key]);\\n                return;\\n            }\\n            if (cacheMap.Count >= capacity){\\n                cacheMap.Remove(lruList.First.Value.CacheKey);\\n                lruList.RemoveFirst();\\n            }\\n            cacheMap.Add(key, new LinkedListNode<LRUCacheItem>(new LRUCacheItem { CacheKey = key, CacheValue = val }));\\n            lruList.AddLast(cacheMap[key]);\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1323346,
                "title": "c-solution-using-doubly-linked-list-and-dictionary",
                "content": "```\\npublic class LRUCache {\\n    \\n    //Lesson learnt : Boxing-Unboxing is very costly operation. LinkedList.Remove(\"abc\") will cast abc in to LinkedListNode\\n    //so instead of taking a LinkedList of Int and Dictionary of <int, int>, using a Dictionary of <int, LinkedListNode> \\n    \\n    \\n    private class Node\\n    {\\n        public int Key {get; set;}\\n        public int Val { get; set; }\\n    }\\n\\n    //For initializing the constructor with capacity\\n    public int capacity {get; private set;}\\n    \\n    //DLL for maintaining LRU logic - Move/Add the most recently used item at front of the list\\n    private LinkedList<Node> circularList;\\n    \\n    //Dictionary for fetching the value for a key in O(1) time \\n    private Dictionary<int,LinkedListNode<Node>> map;\\n    \\n    //variable to keep track of DLL(Doubly linked list) size since list.Count is O(n) operation\\n    private int size;\\n    \\n    public LRUCache(int capacity) \\n    {\\n        this.capacity = capacity;\\n        circularList= new LinkedList<Node>();\\n        map = new Dictionary<int, LinkedListNode<Node>>();\\n        size =0;\\n    }\\n    \\n    public int Get(int key) {        \\n          if(!map.ContainsKey(key)) return -1;\\n          \\n          var node = map[key];\\n          circularList.Remove(node);\\n          circularList.AddFirst(node);        \\n          return node.Value.Val;        \\n    }\\n    \\n    public void Put(int key, int value) {        \\n        \\n        if(map.ContainsKey(key))\\n        {\\n              var node = map[key];\\n              circularList.Remove(node);\\n              circularList.AddFirst(node);\\n              node.Value.Val = value;\\n              \\n              return;\\n        }\\n\\n        if(size== capacity)\\n        {\\n            map.Remove(circularList.Last.Value.Key);\\n            circularList.RemoveLast();\\n            size--;\\n        }\\n        \\n        //Add the new key, value at the front of the list\\n        circularList.AddFirst(new Node {Key= key,Val = value});\\n        //The LinkedListNode will now be added in the dictionary for the given key\\n        map.Add(key, circularList.First);\\n        size++;\\n               \\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.Get(key);\\n * obj.Put(key,value);\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Doubly-Linked List"
                ],
                "code": "```\\npublic class LRUCache {\\n    \\n    //Lesson learnt : Boxing-Unboxing is very costly operation. LinkedList.Remove(\"abc\") will cast abc in to LinkedListNode\\n    //so instead of taking a LinkedList of Int and Dictionary of <int, int>, using a Dictionary of <int, LinkedListNode> \\n    \\n    \\n    private class Node\\n    {\\n        public int Key {get; set;}\\n        public int Val { get; set; }\\n    }\\n\\n    //For initializing the constructor with capacity\\n    public int capacity {get; private set;}\\n    \\n    //DLL for maintaining LRU logic - Move/Add the most recently used item at front of the list\\n    private LinkedList<Node> circularList;\\n    \\n    //Dictionary for fetching the value for a key in O(1) time \\n    private Dictionary<int,LinkedListNode<Node>> map;\\n    \\n    //variable to keep track of DLL(Doubly linked list) size since list.Count is O(n) operation\\n    private int size;\\n    \\n    public LRUCache(int capacity) \\n    {\\n        this.capacity = capacity;\\n        circularList= new LinkedList<Node>();\\n        map = new Dictionary<int, LinkedListNode<Node>>();\\n        size =0;\\n    }\\n    \\n    public int Get(int key) {        \\n          if(!map.ContainsKey(key)) return -1;\\n          \\n          var node = map[key];\\n          circularList.Remove(node);\\n          circularList.AddFirst(node);        \\n          return node.Value.Val;        \\n    }\\n    \\n    public void Put(int key, int value) {        \\n        \\n        if(map.ContainsKey(key))\\n        {\\n              var node = map[key];\\n              circularList.Remove(node);\\n              circularList.AddFirst(node);\\n              node.Value.Val = value;\\n              \\n              return;\\n        }\\n\\n        if(size== capacity)\\n        {\\n            map.Remove(circularList.Last.Value.Key);\\n            circularList.RemoveLast();\\n            size--;\\n        }\\n        \\n        //Add the new key, value at the front of the list\\n        circularList.AddFirst(new Node {Key= key,Val = value});\\n        //The LinkedListNode will now be added in the dictionary for the given key\\n        map.Add(key, circularList.First);\\n        size++;\\n               \\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.Get(key);\\n * obj.Put(key,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 933202,
                "title": "java-linkedhashmap-solution",
                "content": "\\n```\\nclass LRUCache {\\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\\n    int cap;\\n    public LRUCache(int capacity) {\\n        this.cap = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (!cache.containsKey(key)) {\\n            return -1;\\n        }\\n        moveRecently(key);\\n        return cache.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (cache.containsKey(key)) {\\n            cache.put(key, value);\\n            moveRecently(key);\\n            return;\\n        }\\n        if (cache.size() >= this.cap) {\\n            int oldKey = cache.keySet().iterator().next();\\n            cache.remove(oldKey);\\n        }\\n        cache.put(key, value);\\n    }\\n    public void moveRecently(int key) {\\n        int val = cache.get(key);\\n        cache.remove(key);\\n        cache.put(key, val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LRUCache {\\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\\n    int cap;\\n    public LRUCache(int capacity) {\\n        this.cap = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if (!cache.containsKey(key)) {\\n            return -1;\\n        }\\n        moveRecently(key);\\n        return cache.get(key);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (cache.containsKey(key)) {\\n            cache.put(key, value);\\n            moveRecently(key);\\n            return;\\n        }\\n        if (cache.size() >= this.cap) {\\n            int oldKey = cache.keySet().iterator().next();\\n            cache.remove(oldKey);\\n        }\\n        cache.put(key, value);\\n    }\\n    public void moveRecently(int key) {\\n        int val = cache.get(key);\\n        cache.remove(key);\\n        cache.put(key, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828818,
                "title": "c-94-46-unordered-map-and-dll-easy-to-understand",
                "content": "***Runtime: 172 ms, faster than 94.46% of C++ online submissions for LRU Cache.\\nMemory Usage: 42.3 MB, less than 28.83% of C++ online submissions for LRU Cache***\\n```\\nclass DLLNode{\\npublic:\\n    int key;\\n    int val;\\n    DLLNode *next, *prev;\\n    DLLNode(int k, int v){\\n        key = k;\\n        val = v;\\n        next = nullptr;\\n        prev = nullptr;\\n    }\\n};\\nclass DLL{\\n    public:\\n        // first : historical data\\n        // last  : most recent data\\n        DLLNode* first;\\n        DLLNode* last;\\n        DLL(){\\n            first = last = nullptr;\\n        }\\n        void addNodeAtTail(DLLNode* newNode){\\n            // insert a new node at the end of DLL\\n            if(!first){\\n                first = last = newNode;\\n            }else{\\n                last->next = newNode;\\n                newNode->prev = last;\\n                last = newNode;\\n                last->next = nullptr;\\n            }\\n        }\\n        void deleteFromHead(){\\n            // deletes the head ,if present\\n            if(first){\\n                DLLNode* temp = first;\\n                if(first == last){\\n                    first = last = nullptr;\\n                }else{\\n                    first = first->next;\\n                    first->prev = nullptr;\\n                }\\n                delete temp;\\n            }\\n        } \\n        DLLNode* deleteNode(DLLNode* node){\\n            // removes a node from DLL, return a node to the node to be deleted\\n            if(node == first && node == last){\\n                first = nullptr;\\n                last = nullptr;\\n            }else if(node->key == first->key){\\n                first = first->next;\\n                if(first)\\n                    first->prev = nullptr;\\n            }else if(node->key == last->key){\\n                last = last->prev;\\n                last->next = nullptr;\\n            }else{\\n                if(node->next)\\n                    node->next->prev = node->prev;\\n                if(node->prev)\\n                    node->prev->next = node->next;\\n            }\\n            return node;\\n        }\\n};\\nclass LRUCache {\\nprivate:\\n    unordered_map<int, DLLNode*> hashmap;\\n    DLL* list;\\n    int maxCapacity;\\npublic:\\n    LRUCache(int capacity) {\\n        maxCapacity = capacity;\\n        list = new DLL();\\n    }\\n    \\n    int get(int key) {\\n        /*\\n            Case 1: Key present\\n                    i). get access to the node in DLL from hashmap.\\n                    ii). move that node to tail of DLL.\\n                    iii). update entry in hashmap, as node got updated.\\n            Case 2: Key absent\\n                    i). return -1\\n        */\\n        int result;\\n        if(hashmap.count(key)){\\n            DLLNode* node = hashmap[key];\\n            result = node->val;\\n            if(node != list->last){\\n                node = list->deleteNode(node);\\n                list->addNodeAtTail(node);\\n                hashmap[key] = list->last;\\n            }\\n        }else{\\n            result = -1;\\n        }\\n        return result;\\n    }\\n    \\n    void put(int key, int value) {\\n        /*\\n            Case 1: Key present\\n                    In ths case, capacity cannot be overflow as only node is updated.\\n                    i). get access to the node in DLL from hashmap.\\n                    ii). delete that node of DLL.\\n                    iii). create a new node with given values\\n                    iv). add the newly created node at end\\n                    v). update hashmap\\n            Case 2: Key absent\\n                    Check whether capacity overflow occur or not\\n                    Case 2.1). If overflow occurs,\\n                               i). delete the most historical element from hashmap and DLL\\n                               ii). create a new node with given values\\n                               iii). add the newly created node at end\\n                               iv). update hashmap\\n                    Case 2.2). No Overflow,\\n                               i). create a new node with given values\\n                               ii). add the newly created node at end\\n                               iii). update hashmap \\n                    \\n        */\\n        if(hashmap.count(key)){\\n            DLLNode* node = hashmap[key];\\n            delete list->deleteNode(node);\\n            hashmap.erase(key);\\n        }else{\\n            if(hashmap.size() == maxCapacity){\\n                int delKey = list->first->key;\\n                hashmap.erase(delKey);\\n                list->deleteFromHead();\\n            }\\n        }\\n        DLLNode* node = new DLLNode(key, value);\\n        hashmap[key] = node;\\n        list->addNodeAtTail(node);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass DLLNode{\\npublic:\\n    int key;\\n    int val;\\n    DLLNode *next, *prev;\\n    DLLNode(int k, int v){\\n        key = k;\\n        val = v;\\n        next = nullptr;\\n        prev = nullptr;\\n    }\\n};\\nclass DLL{\\n    public:\\n        // first : historical data\\n        // last  : most recent data\\n        DLLNode* first;\\n        DLLNode* last;\\n        DLL(){\\n            first = last = nullptr;\\n        }\\n        void addNodeAtTail(DLLNode* newNode){\\n            // insert a new node at the end of DLL\\n            if(!first){\\n                first = last = newNode;\\n            }else{\\n                last->next = newNode;\\n                newNode->prev = last;\\n                last = newNode;\\n                last->next = nullptr;\\n            }\\n        }\\n        void deleteFromHead(){\\n            // deletes the head ,if present\\n            if(first){\\n                DLLNode* temp = first;\\n                if(first == last){\\n                    first = last = nullptr;\\n                }else{\\n                    first = first->next;\\n                    first->prev = nullptr;\\n                }\\n                delete temp;\\n            }\\n        } \\n        DLLNode* deleteNode(DLLNode* node){\\n            // removes a node from DLL, return a node to the node to be deleted\\n            if(node == first && node == last){\\n                first = nullptr;\\n                last = nullptr;\\n            }else if(node->key == first->key){\\n                first = first->next;\\n                if(first)\\n                    first->prev = nullptr;\\n            }else if(node->key == last->key){\\n                last = last->prev;\\n                last->next = nullptr;\\n            }else{\\n                if(node->next)\\n                    node->next->prev = node->prev;\\n                if(node->prev)\\n                    node->prev->next = node->next;\\n            }\\n            return node;\\n        }\\n};\\nclass LRUCache {\\nprivate:\\n    unordered_map<int, DLLNode*> hashmap;\\n    DLL* list;\\n    int maxCapacity;\\npublic:\\n    LRUCache(int capacity) {\\n        maxCapacity = capacity;\\n        list = new DLL();\\n    }\\n    \\n    int get(int key) {\\n        /*\\n            Case 1: Key present\\n                    i). get access to the node in DLL from hashmap.\\n                    ii). move that node to tail of DLL.\\n                    iii). update entry in hashmap, as node got updated.\\n            Case 2: Key absent\\n                    i). return -1\\n        */\\n        int result;\\n        if(hashmap.count(key)){\\n            DLLNode* node = hashmap[key];\\n            result = node->val;\\n            if(node != list->last){\\n                node = list->deleteNode(node);\\n                list->addNodeAtTail(node);\\n                hashmap[key] = list->last;\\n            }\\n        }else{\\n            result = -1;\\n        }\\n        return result;\\n    }\\n    \\n    void put(int key, int value) {\\n        /*\\n            Case 1: Key present\\n                    In ths case, capacity cannot be overflow as only node is updated.\\n                    i). get access to the node in DLL from hashmap.\\n                    ii). delete that node of DLL.\\n                    iii). create a new node with given values\\n                    iv). add the newly created node at end\\n                    v). update hashmap\\n            Case 2: Key absent\\n                    Check whether capacity overflow occur or not\\n                    Case 2.1). If overflow occurs,\\n                               i). delete the most historical element from hashmap and DLL\\n                               ii). create a new node with given values\\n                               iii). add the newly created node at end\\n                               iv). update hashmap\\n                    Case 2.2). No Overflow,\\n                               i). create a new node with given values\\n                               ii). add the newly created node at end\\n                               iii). update hashmap \\n                    \\n        */\\n        if(hashmap.count(key)){\\n            DLLNode* node = hashmap[key];\\n            delete list->deleteNode(node);\\n            hashmap.erase(key);\\n        }else{\\n            if(hashmap.size() == maxCapacity){\\n                int delKey = list->first->key;\\n                hashmap.erase(delKey);\\n                list->deleteFromHead();\\n            }\\n        }\\n        DLLNode* node = new DLLNode(key, value);\\n        hashmap[key] = node;\\n        list->addNodeAtTail(node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570315,
                "title": "golang-with-container-list",
                "content": "```\\nimport \"container/list\"\\n\\n\\ntype kv struct {\\n    // key is only needed to delete entry in data map\\n    // when removing LRU item\\n    k int\\n    v int\\n}\\n\\ntype LRUCache struct {\\n    capacity int\\n    data map[int]*list.Element\\n    hits *list.List\\n}\\n\\nfunc Constructor(capacity int) LRUCache {\\n    return LRUCache{\\n        capacity: capacity,\\n        data: make(map[int]*list.Element),\\n        hits: list.New(),\\n    }\\n}\\n\\nfunc (c *LRUCache) Get(key int) int {\\n    if el, ok := c.data[key]; ok {\\n        c.hits.MoveToFront(el)\\n        return el.Value.(kv).v\\n    } \\n    return -1\\n}\\n\\n\\nfunc (c *LRUCache) Put(key int, value int)  {\\n    // just an update?\\n    if el, ok := c.data[key]; ok {\\n        el.Value = kv{k: key, v: value}\\n        c.hits.MoveToFront(el)\\n        return\\n    }\\n    // full?\\n    if c.hits.Len() == c.capacity {\\n        last := c.hits.Back()\\n        delete(c.data, last.Value.(kv).k)\\n        c.hits.Remove(last)\\n    }\\n    // put\\n    c.data[key] := c.hits.PushFront(kv{k: key, v: value})\\n}\\n ```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"container/list\"\\n\\n\\ntype kv struct {\\n    // key is only needed to delete entry in data map\\n    // when removing LRU item\\n    k int\\n    v int\\n}\\n\\ntype LRUCache struct {\\n    capacity int\\n    data map[int]*list.Element\\n    hits *list.List\\n}\\n\\nfunc Constructor(capacity int) LRUCache {\\n    return LRUCache{\\n        capacity: capacity,\\n        data: make(map[int]*list.Element),\\n        hits: list.New(),\\n    }\\n}\\n\\nfunc (c *LRUCache) Get(key int) int {\\n    if el, ok := c.data[key]; ok {\\n        c.hits.MoveToFront(el)\\n        return el.Value.(kv).v\\n    } \\n    return -1\\n}\\n\\n\\nfunc (c *LRUCache) Put(key int, value int)  {\\n    // just an update?\\n    if el, ok := c.data[key]; ok {\\n        el.Value = kv{k: key, v: value}\\n        c.hits.MoveToFront(el)\\n        return\\n    }\\n    // full?\\n    if c.hits.Len() == c.capacity {\\n        last := c.hits.Back()\\n        delete(c.data, last.Value.(kv).k)\\n        c.hits.Remove(last)\\n    }\\n    // put\\n    c.data[key] := c.hits.PushFront(kv{k: key, v: value})\\n}\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 465255,
                "title": "go-golang-o-1-solution",
                "content": ">Runtime: 132 ms, faster than 95.87% of Go online submissions for LRU Cache.\\nMemory Usage: 15.4 MB, less than 100.00% of Go online submissions for LRU Cache.\\n\\n```go\\ntype LRUCache struct {\\n    Head *Node\\n    Tail *Node\\n    HT map[int]*Node\\n    Cap int\\n}\\n\\ntype Node struct {\\n    Key int\\n    Val int\\n    Prev *Node\\n    Next *Node\\n}\\n\\nfunc Constructor(capacity int) LRUCache {\\n    return LRUCache{HT: make(map[int]*Node), Cap: capacity}\\n}\\n\\nfunc (this *LRUCache) Get(key int) int {\\n    node, ok := this.HT[key]\\n    if ok {\\n        this.Remove(node)\\n        this.Add(node)\\n        return node.Val\\n    }\\n    return -1\\n}\\n\\nfunc (this *LRUCache) Put(key int, value int)  {\\n    node, ok := this.HT[key]\\n    if ok {\\n        node.Val = value\\n        this.Remove(node)\\n        this.Add(node)\\n        return\\n    } else {\\n        node = &Node{Key: key, Val: value}\\n        this.HT[key] = node\\n        this.Add(node)\\n    }\\n    if len(this.HT) > this.Cap {\\n        delete(this.HT, this.Tail.Key)\\n        this.Remove(this.Tail)\\n    }\\n}\\n\\nfunc (this *LRUCache) Add(node *Node) {\\n    node.Prev = nil\\n    node.Next = this.Head\\n    if this.Head != nil {\\n        this.Head.Prev = node\\n    }\\n    this.Head = node\\n    if this.Tail == nil {\\n        this.Tail = node\\n    }\\n}\\n\\nfunc (this *LRUCache) Remove(node *Node) {\\n    if node != this.Head {\\n        node.Prev.Next = node.Next\\n    } else {\\n        this.Head = node.Next\\n    }\\n    if node != this.Tail {\\n        node.Next.Prev = node.Prev\\n    } else {\\n        this.Tail = node.Prev\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```go\\ntype LRUCache struct {\\n    Head *Node\\n    Tail *Node\\n    HT map[int]*Node\\n    Cap int\\n}\\n\\ntype Node struct {\\n    Key int\\n    Val int\\n    Prev *Node\\n    Next *Node\\n}\\n\\nfunc Constructor(capacity int) LRUCache {\\n    return LRUCache{HT: make(map[int]*Node), Cap: capacity}\\n}\\n\\nfunc (this *LRUCache) Get(key int) int {\\n    node, ok := this.HT[key]\\n    if ok {\\n        this.Remove(node)\\n        this.Add(node)\\n        return node.Val\\n    }\\n    return -1\\n}\\n\\nfunc (this *LRUCache) Put(key int, value int)  {\\n    node, ok := this.HT[key]\\n    if ok {\\n        node.Val = value\\n        this.Remove(node)\\n        this.Add(node)\\n        return\\n    } else {\\n        node = &Node{Key: key, Val: value}\\n        this.HT[key] = node\\n        this.Add(node)\\n    }\\n    if len(this.HT) > this.Cap {\\n        delete(this.HT, this.Tail.Key)\\n        this.Remove(this.Tail)\\n    }\\n}\\n\\nfunc (this *LRUCache) Add(node *Node) {\\n    node.Prev = nil\\n    node.Next = this.Head\\n    if this.Head != nil {\\n        this.Head.Prev = node\\n    }\\n    this.Head = node\\n    if this.Tail == nil {\\n        this.Tail = node\\n    }\\n}\\n\\nfunc (this *LRUCache) Remove(node *Node) {\\n    if node != this.Head {\\n        node.Prev.Next = node.Next\\n    } else {\\n        this.Head = node.Next\\n    }\\n    if node != this.Tail {\\n        node.Next.Prev = node.Prev\\n    } else {\\n        this.Tail = node.Prev\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 263936,
                "title": "best-python-solution-explained-double-linked-list",
                "content": "```\\n\"\"\"\\nI learned this answer from @tusizi; rewrote it.\\n\\nLet\\'s analyze the problem\\nIf we need get() to be O(1),\\nwe must definitely use a hashmap(dictionary) to store the key value.\\n\\nput() is not a problem, since we are only setting value.\\nThe problem is when we excceed the capacity.\\nHow do we find the least-used key and remove it from the hashmap?\\nWe need something for us to sort from most-frequent-used to least-used.\\n\\nSo what else common data structure do we know?\\nArray? no, we will need to iterate to the whole array to find what we need. and it is not easy to add or remove.\\nTree? not likely.\\nMin-heap? even though we can get the least-used, but it need O(LogN) to set the most-frequent-used.\\nLink list? Bingo!\\n\\nWe also need it to be a double link list, so we can remove the tail.\\nWe also need the node to store the key when we remove the tail, we can also remove it in the hashmap\\nWe also need the node to store the val when we get().\\n\\nIt would be like:\\nhead<->node1<->node2<->node3 ... nodeN<->tail\\n(most-frequent-used to least-used)\\n\\nSo the main idea now is to use hashmap to store the key:Node pair [0]\\nIf we put or get any key-value pair, we move its node to the front of the line (I call this promote()) [1]\\nThe front of the line means we put it just after head.\\nIf we excced the capacity, we remove the node at the end of the line [2]\\nThe end of the line means the node just before tail.\\n\\nThe head and tail is just a dummy, [3]\\nfor us to keep track of the first and the last of the linklist\\nand don\\'t have worry about the edge case.\\n\"\"\"\\n```\\n```\\nclass Node(object):\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None \\n\\nclass LRUCache(object):\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.dic = {} #[0]\\n        self.head = Node(0, 0) #[3]\\n        self.tail = Node(0, 0) #[3]\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n    def remove(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n    \\n    def promote(self, node): #[1]\\n        #set the node next to head\\n        temp = self.head.next\\n        node.next = temp\\n        temp.prev = node\\n        self.head.next = node\\n        node.prev = self.head\\n\\n    def get(self, key):\\n        if key in self.dic:\\n            node = self.dic[key]\\n            self.remove(node)\\n            self.promote(node)\\n            return node.val\\n        return -1\\n            \\n    def put(self, key, value):\\n        if key in self.dic:\\n            self.remove(self.dic[key])\\n        node = Node(key, value)\\n        self.promote(node)\\n        self.dic[key] = node\\n        \\n        if len(self.dic)>self.capacity: #[2]\\n            del self.dic[self.tail.prev.key]\\n            self.remove(self.tail.prev)\\n\\n\"\"\"\\nI really take time to explain my solution, because I wanted to help people understand.\\nIf you like my answer, a star on GitHub I will really appreciated.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nI learned this answer from @tusizi; rewrote it.\\n\\nLet\\'s analyze the problem\\nIf we need get() to be O(1),\\nwe must definitely use a hashmap(dictionary) to store the key value.\\n\\nput() is not a problem, since we are only setting value.\\nThe problem is when we excceed the capacity.\\nHow do we find the least-used key and remove it from the hashmap?\\nWe need something for us to sort from most-frequent-used to least-used.\\n\\nSo what else common data structure do we know?\\nArray? no, we will need to iterate to the whole array to find what we need. and it is not easy to add or remove.\\nTree? not likely.\\nMin-heap? even though we can get the least-used, but it need O(LogN) to set the most-frequent-used.\\nLink list? Bingo!\\n\\nWe also need it to be a double link list, so we can remove the tail.\\nWe also need the node to store the key when we remove the tail, we can also remove it in the hashmap\\nWe also need the node to store the val when we get().\\n\\nIt would be like:\\nhead<->node1<->node2<->node3 ... nodeN<->tail\\n(most-frequent-used to least-used)\\n\\nSo the main idea now is to use hashmap to store the key:Node pair [0]\\nIf we put or get any key-value pair, we move its node to the front of the line (I call this promote()) [1]\\nThe front of the line means we put it just after head.\\nIf we excced the capacity, we remove the node at the end of the line [2]\\nThe end of the line means the node just before tail.\\n\\nThe head and tail is just a dummy, [3]\\nfor us to keep track of the first and the last of the linklist\\nand don\\'t have worry about the edge case.\\n\"\"\"\\n```\n```\\nclass Node(object):\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None \\n\\nclass LRUCache(object):\\n    def __init__(self, capacity):\\n        self.capacity = capacity\\n        self.dic = {} #[0]\\n        self.head = Node(0, 0) #[3]\\n        self.tail = Node(0, 0) #[3]\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n    def remove(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n    \\n    def promote(self, node): #[1]\\n        #set the node next to head\\n        temp = self.head.next\\n        node.next = temp\\n        temp.prev = node\\n        self.head.next = node\\n        node.prev = self.head\\n\\n    def get(self, key):\\n        if key in self.dic:\\n            node = self.dic[key]\\n            self.remove(node)\\n            self.promote(node)\\n            return node.val\\n        return -1\\n            \\n    def put(self, key, value):\\n        if key in self.dic:\\n            self.remove(self.dic[key])\\n        node = Node(key, value)\\n        self.promote(node)\\n        self.dic[key] = node\\n        \\n        if len(self.dic)>self.capacity: #[2]\\n            del self.dic[self.tail.prev.key]\\n            self.remove(self.tail.prev)\\n\\n\"\"\"\\nI really take time to explain my solution, because I wanted to help people understand.\\nIf you like my answer, a star on GitHub I will really appreciated.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164037,
                "title": "solution-python-using-doubly-linked-list-and-map-with-detailed-explanation",
                "content": "I wanted to implement my solution without using any special Python-only classes (such as OrderedDict), in hopes that the logic can be easily applied to other languages. ***This is in the perspective of next = left, prev = right.***\\n```\\nclass Node:\\n    def __init__(self, key, val):\\n        # keep track of key for later use;\\n        # given only a Node, we are able to\\n        # delete it from a node_map (see LRUCache)\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n\\nclass LRUCache:\\n    \"\"\"\\n    LRUCache utilizes an internal doubly linked list\\n    to maintain the least-recently-used structure:\\n    the head stores the Node with the most recently used key,\\n    and the tail stores the Node with the least recently used key.\\n\\n    Each time a key is used for put or get, the use_node function is called\\n    with the Node with the corresponding key (either an existing or new Node),\\n    and that Node is moved to the head (most recent) position.\\n\\n    If the cache is at full capacity, we first delete the Node at the tail\\n    (least recent) position, then call the use_node function with the new node as normal.\\n\\n    For O(1) put and get functions, the node_map lookup table is used to match a\\n    key to a corresponding Node.  This way, we can utilize O(1) head and tail operations\\n    of the internal doubly linked list, and at the same time, we can access a Node\\n    with a specific key  in O(1) time.\\n\\n    For simplicity in deleting the tail, I have each Node store its corresponding key.\\n    This way, we can access the Node at the tail position, extract its key,\\n    then delete the key from node_map.  The alternative would be to have a variable\\n    that specifically keeps track of the tail key, and update that value whenever we change\\n    the tail.\\n    \"\"\"\\n    def __init__(self, capacity):\\n        if capacity < 1:\\n            print(\\'LRUCache capacity must be > 0\\')\\n            return None\\n\\n        self.capacity = capacity\\n        self.size = 0\\n        self.node_map = {} # map a key to a Node (explained above)\\n        self.head = None # Node with the most recently used key\\n        self.tail = None # Node with the least recently used key\\n\\n    def use_node(self, node):\\n        \"\"\"\\n        put a Node in the head (most recent) position;\\n        can be a new node, or node that is already stored\\n        \"\"\"\\n\\n        # head Node is already in most recent position,\\n        # so no work to do when we use it\\n        if node is self.head: return\\n\\n        # connect nodes neighbors (one could be None);\\n        # if node is new, there are no neighbors to connect\\n        if node.next: node.next.prev = node.prev\\n        if node.prev: node.prev.next = node.next\\n\\n        # when using the tail, we must set a new tail\\n        if node is self.tail:\\n            # node still points to original tail, so we\\n            # are fine overwriting the tail pointer.\\n            # new tail\\'s next is be set to None in the above\\n            # condition, since the original tail\\'s next was None\\n            self.tail = self.tail.prev\\n\\n        # update head Node connections\\n        self.head.prev = node\\n        node.next = self.head\\n        node.prev = None\\n        self.head = node\\n\\n    def get(self, key):\\n        # if key exists, use the corresponding node and return its value\\n        if key in self.node_map:\\n            self.use_node(self.node_map[key])\\n            return self.node_map[key].val\\n        else:\\n            return -1\\n\\n    def put(self, key, value):\\n        # if key exists, use the corresponding node and update its value\\n        if key in self.node_map:\\n            self.use_node(self.node_map[key])\\n            self.node_map[key].val = value\\n        else:\\n            # insert new node\\n            node = Node(key, value)\\n            self.node_map[key] = node\\n\\n            # first node is special case: its the head and the tail\\n            if self.size == 0:\\n                self.head = node\\n                self.tail = node\\n\\n            if self.size < self.capacity:\\n                self.size += 1\\n\\n            # size at max capacity; must remove tail (least recent) node\\n            elif self.size == self.capacity:\\n                k = self.tail.key # preserve current tail key\\n\\n                if self.size == 1:\\n                    # special case; replace only node left,\\n                    # so it becomes the head and the tail\\n                    self.head = node\\n                    self.tail = node\\n                else:\\n                    # normal case, just adjust the tail position\\n                    self.tail = self.tail.prev\\n                    self.tail.next = None\\n\\n                # delete old tail\\n                del self.node_map[k]\\n\\n            self.use_node(node)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, key, val):\\n        # keep track of key for later use;\\n        # given only a Node, we are able to\\n        # delete it from a node_map (see LRUCache)\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n\\nclass LRUCache:\\n    \"\"\"\\n    LRUCache utilizes an internal doubly linked list\\n    to maintain the least-recently-used structure:\\n    the head stores the Node with the most recently used key,\\n    and the tail stores the Node with the least recently used key.\\n\\n    Each time a key is used for put or get, the use_node function is called\\n    with the Node with the corresponding key (either an existing or new Node),\\n    and that Node is moved to the head (most recent) position.\\n\\n    If the cache is at full capacity, we first delete the Node at the tail\\n    (least recent) position, then call the use_node function with the new node as normal.\\n\\n    For O(1) put and get functions, the node_map lookup table is used to match a\\n    key to a corresponding Node.  This way, we can utilize O(1) head and tail operations\\n    of the internal doubly linked list, and at the same time, we can access a Node\\n    with a specific key  in O(1) time.\\n\\n    For simplicity in deleting the tail, I have each Node store its corresponding key.\\n    This way, we can access the Node at the tail position, extract its key,\\n    then delete the key from node_map.  The alternative would be to have a variable\\n    that specifically keeps track of the tail key, and update that value whenever we change\\n    the tail.\\n    \"\"\"\\n    def __init__(self, capacity):\\n        if capacity < 1:\\n            print(\\'LRUCache capacity must be > 0\\')\\n            return None\\n\\n        self.capacity = capacity\\n        self.size = 0\\n        self.node_map = {} # map a key to a Node (explained above)\\n        self.head = None # Node with the most recently used key\\n        self.tail = None # Node with the least recently used key\\n\\n    def use_node(self, node):\\n        \"\"\"\\n        put a Node in the head (most recent) position;\\n        can be a new node, or node that is already stored\\n        \"\"\"\\n\\n        # head Node is already in most recent position,\\n        # so no work to do when we use it\\n        if node is self.head: return\\n\\n        # connect nodes neighbors (one could be None);\\n        # if node is new, there are no neighbors to connect\\n        if node.next: node.next.prev = node.prev\\n        if node.prev: node.prev.next = node.next\\n\\n        # when using the tail, we must set a new tail\\n        if node is self.tail:\\n            # node still points to original tail, so we\\n            # are fine overwriting the tail pointer.\\n            # new tail\\'s next is be set to None in the above\\n            # condition, since the original tail\\'s next was None\\n            self.tail = self.tail.prev\\n\\n        # update head Node connections\\n        self.head.prev = node\\n        node.next = self.head\\n        node.prev = None\\n        self.head = node\\n\\n    def get(self, key):\\n        # if key exists, use the corresponding node and return its value\\n        if key in self.node_map:\\n            self.use_node(self.node_map[key])\\n            return self.node_map[key].val\\n        else:\\n            return -1\\n\\n    def put(self, key, value):\\n        # if key exists, use the corresponding node and update its value\\n        if key in self.node_map:\\n            self.use_node(self.node_map[key])\\n            self.node_map[key].val = value\\n        else:\\n            # insert new node\\n            node = Node(key, value)\\n            self.node_map[key] = node\\n\\n            # first node is special case: its the head and the tail\\n            if self.size == 0:\\n                self.head = node\\n                self.tail = node\\n\\n            if self.size < self.capacity:\\n                self.size += 1\\n\\n            # size at max capacity; must remove tail (least recent) node\\n            elif self.size == self.capacity:\\n                k = self.tail.key # preserve current tail key\\n\\n                if self.size == 1:\\n                    # special case; replace only node left,\\n                    # so it becomes the head and the tail\\n                    self.head = node\\n                    self.tail = node\\n                else:\\n                    # normal case, just adjust the tail position\\n                    self.tail = self.tail.prev\\n                    self.tail.next = None\\n\\n                # delete old tail\\n                del self.node_map[k]\\n\\n            self.use_node(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115029,
                "title": "java-detailed-solution",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n#### We will use a Doubly linked list:\\n- The node right next to head is the *Most Recently Used* (The node on which we used `put()`, `get()` methods most recently, we will set it at the position next to the head of the linked-list).\\n- The node which has been idle for the longest, or the ***Least Recently Used***, will remain at the position right before the tail of the linked-list (Whenever we ***evict***, we will remove this particular node).\\n\\n#### We will also use a hashmap:\\nWe need some sort of data structure to let us know we have the key present with us, and it needs to store a value associated to the key as well.\\n\\n---\\n\\u2714\\uFE0F ***Video links to this solution are attached at the end of the post*** \\u2714\\uFE0F\\n\\n---\\n### Code:\\n``` java []\\nclass LRUCache {\\n    // Create doubly linkedlist\\n    private Node head = new Node(0, 0);     // head node\\n    private Node tail = new Node(0, 0);     // tail node\\n    // create map to store the key and its node\\n    private Map<Integer, Node> map = new HashMap<>();\\n    private int capacity;   // globally store the capacity\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.next = head;\\n    }\\n\\n    public int get(int key) {\\n        // if key is not present, return -1\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n\\n        // otherwise, fetch the node mapped to the key\\n        Node node = map.get(key);\\n        // we will set the node as the most recently used\\n        // by placing it right next to head\\n        remove(node);       // remove from wherever it is (also from map)\\n        insert(node);       // put it right after head  (also add it to map)\\n        return node.value;  // return value for the key\\n    }\\n\\n    public void put(int key, int value) {\\n        // if map contains the key, we will remove the node from the map\\n        if (map.containsKey(key)) {\\n            remove(map.get(key));\\n        }\\n        // if map size has reached max capacity, we will remove/evict the\\n        // LEAST RECENTLY USED node that will be right before the tail of linkedlist\\n        if (map.size() == capacity) {\\n            remove(tail.prev);\\n        }\\n        // we will insert the new node at head\\'s next and put it in the map\\n        insert(new Node(key, value));\\n    }\\n    \\n    // This method removes the node from its current position \\n    // as well as it removes the mapping from the hashmap\\n    private void remove(Node node) {\\n        // remove from map\\n        map.remove(node.key);       \\n        // delete the node\\n        node.prev.next = node.next; \\n        node.next.prev = node.prev;\\n    }\\n\\n    // This method adds the node right at the next of the head\\n    // as well as it puts a new mapping into the hashmap\\n    private void insert(Node node) {\\n        // add to hashmap\\n        map.put(node.key, node);    \\n        // Place at head\\'s next\\n        Node headNext = head.next;\\n        headNext.prev = node;\\n        node.next = headNext;\\n        head.next = node;\\n        headNext.prev = node;\\n        node.prev = head;\\n    }\\n    \\n    // The node class\\n    private class Node {\\n        Node next, prev;\\n        int key, value;\\n        Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass LRUCache {\\n    private Node head = new Node(0, 0);   \\n    private Node tail = new Node(0, 0);   \\n    private Map<Integer, Node> map = new HashMap<>();\\n    private int capacity;   \\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.next = head;\\n    }\\n\\n    public int get(int key) {\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n        Node node = map.get(key);\\n        remove(node);       \\n        insert(node);       \\n        return node.value; \\n    }\\n\\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            remove(map.get(key));\\n        }\\n        if (map.size() == capacity) {\\n            remove(tail.prev);\\n        }\\n        insert(new Node(key, value));\\n    }\\n\\n    private void remove(Node node) {\\n        map.remove(node.key);       \\n        node.prev.next = node.next; \\n        node.next.prev = node.prev;\\n    }\\n\\n    private void insert(Node node) {\\n        map.put(node.key, node);    \\n        Node headNext = head.next;\\n        headNext.prev = node;\\n        node.next = headNext;\\n        head.next = node;\\n        headNext.prev = node;\\n        node.prev = head;\\n    }\\n    \\n    private class Node {\\n        Node next, prev;\\n        int key, value;\\n        Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n}\\n```\\n---\\n### Time coplexity: $$O(1)$$\\n### Space complexity: $$O(capacity)$$\\n---\\n##### Watch these two videos serailly to understand the approach and the solution properly:\\n***[Link to first video](https://www.youtube.com/watch?v=xDEuM5qa0zg)***\\n***[Link to second video](https://www.youtube.com/watch?v=Xc4sICC8m4M)***",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "``` java []\\nclass LRUCache {\\n    // Create doubly linkedlist\\n    private Node head = new Node(0, 0);     // head node\\n    private Node tail = new Node(0, 0);     // tail node\\n    // create map to store the key and its node\\n    private Map<Integer, Node> map = new HashMap<>();\\n    private int capacity;   // globally store the capacity\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.next = head;\\n    }\\n\\n    public int get(int key) {\\n        // if key is not present, return -1\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n\\n        // otherwise, fetch the node mapped to the key\\n        Node node = map.get(key);\\n        // we will set the node as the most recently used\\n        // by placing it right next to head\\n        remove(node);       // remove from wherever it is (also from map)\\n        insert(node);       // put it right after head  (also add it to map)\\n        return node.value;  // return value for the key\\n    }\\n\\n    public void put(int key, int value) {\\n        // if map contains the key, we will remove the node from the map\\n        if (map.containsKey(key)) {\\n            remove(map.get(key));\\n        }\\n        // if map size has reached max capacity, we will remove/evict the\\n        // LEAST RECENTLY USED node that will be right before the tail of linkedlist\\n        if (map.size() == capacity) {\\n            remove(tail.prev);\\n        }\\n        // we will insert the new node at head\\'s next and put it in the map\\n        insert(new Node(key, value));\\n    }\\n    \\n    // This method removes the node from its current position \\n    // as well as it removes the mapping from the hashmap\\n    private void remove(Node node) {\\n        // remove from map\\n        map.remove(node.key);       \\n        // delete the node\\n        node.prev.next = node.next; \\n        node.next.prev = node.prev;\\n    }\\n\\n    // This method adds the node right at the next of the head\\n    // as well as it puts a new mapping into the hashmap\\n    private void insert(Node node) {\\n        // add to hashmap\\n        map.put(node.key, node);    \\n        // Place at head\\'s next\\n        Node headNext = head.next;\\n        headNext.prev = node;\\n        node.next = headNext;\\n        head.next = node;\\n        headNext.prev = node;\\n        node.prev = head;\\n    }\\n    \\n    // The node class\\n    private class Node {\\n        Node next, prev;\\n        int key, value;\\n        Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n}\\n```\n``` java []\\nclass LRUCache {\\n    private Node head = new Node(0, 0);   \\n    private Node tail = new Node(0, 0);   \\n    private Map<Integer, Node> map = new HashMap<>();\\n    private int capacity;   \\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.next = head;\\n    }\\n\\n    public int get(int key) {\\n        if (!map.containsKey(key)) {\\n            return -1;\\n        }\\n        Node node = map.get(key);\\n        remove(node);       \\n        insert(node);       \\n        return node.value; \\n    }\\n\\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            remove(map.get(key));\\n        }\\n        if (map.size() == capacity) {\\n            remove(tail.prev);\\n        }\\n        insert(new Node(key, value));\\n    }\\n\\n    private void remove(Node node) {\\n        map.remove(node.key);       \\n        node.prev.next = node.next; \\n        node.next.prev = node.prev;\\n    }\\n\\n    private void insert(Node node) {\\n        map.put(node.key, node);    \\n        Node headNext = head.next;\\n        headNext.prev = node;\\n        node.next = headNext;\\n        head.next = node;\\n        headNext.prev = node;\\n        node.prev = head;\\n    }\\n    \\n    private class Node {\\n        Node next, prev;\\n        int key, value;\\n        Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640761,
                "title": "c-faster-cpp-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF IT HELPS**\\nIn this question we have to keep track of the most least recently used item in the cache. I have designed the cache using list and map in C++.\\nWe do it by following the steps below :-\\n\\nWhen we access an item in the cache it moves to the front of the list as it is the most recently used item.\\nWhen we want to remove an item we remove it from the last of the list as it is the least recently used item in the cache.\\nWhen we insert an item we insert it into the front of the list as it is the most recently used item.\\nThe idea is to store the keys in the map and its corrosponding values into the list...\\nNote : splice() function here takes the element at the m[key] and places it at the beginning of the list...\\n```\\nclass LRUCache\\n{\\n    public:\\n        list<pair<int,int>> l;\\n        unordered_map<int,list<pair<int, int>>::iterator> m;\\n        int size;\\n        LRUCache(int capacity)\\n        {\\n            size=capacity;\\n        }\\n        int get(int key)\\n        {\\n            if(m.find(key)==m.end())\\n                return -1;\\n            l.splice(l.begin(),l,m[key]);\\n            return m[key]->second;\\n        }\\n        void put(int key, int value)\\n        {\\n            if(m.find(key)!=m.end())\\n            {\\n                l.splice(l.begin(),l,m[key]);\\n                m[key]->second=value;\\n                return;\\n            }\\n            if(l.size()==size)\\n            {\\n                auto d_key=l.back().first;\\n                l.pop_back();\\n                m.erase(d_key);\\n            }\\n            l.push_front({key,value});\\n            m[key]=l.begin();\\n        }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "**PLEASE UPVOTE IF IT HELPS**\\nIn this question we have to keep track of the most least recently used item in the cache. I have designed the cache using list and map in C++.\\nWe do it by following the steps below :-\\n\\nWhen we access an item in the cache it moves to the front of the list as it is the most recently used item.\\nWhen we want to remove an item we remove it from the last of the list as it is the least recently used item in the cache.\\nWhen we insert an item we insert it into the front of the list as it is the most recently used item.\\nThe idea is to store the keys in the map and its corrosponding values into the list...\\nNote : splice() function here takes the element at the m[key] and places it at the beginning of the list...\\n```\\nclass LRUCache\\n{\\n    public:\\n        list<pair<int,int>> l;\\n        unordered_map<int,list<pair<int, int>>::iterator> m;\\n        int size;\\n        LRUCache(int capacity)\\n        {\\n            size=capacity;\\n        }\\n        int get(int key)\\n        {\\n            if(m.find(key)==m.end())\\n                return -1;\\n            l.splice(l.begin(),l,m[key]);\\n            return m[key]->second;\\n        }\\n        void put(int key, int value)\\n        {\\n            if(m.find(key)!=m.end())\\n            {\\n                l.splice(l.begin(),l,m[key]);\\n                m[key]->second=value;\\n                return;\\n            }\\n            if(l.size()==size)\\n            {\\n                auto d_key=l.back().first;\\n                l.pop_back();\\n                m.erase(d_key);\\n            }\\n            l.push_front({key,value});\\n            m[key]=l.begin();\\n        }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1394842,
                "title": "curated-test-cases-sample-test-cases",
                "content": "# Curated Test Cases | Sample Test Cases\\n\\n```\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[2],[2,1],[1,1],[2],[4,1],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[2],[2,1],[1,1],[2],[4,1],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2,1],[1,1],[2,3],[4,1],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[3,3],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n```\\n\\na very large test case 21/21 is [available here](https://gist.github.com/Rishabh04-02/52f4487c70f674008f8edf4bab2e2ed7/raw/b28e13c1f36c6e35f6e426b67fbd05eab83b19b7/lru-cache-leetcode-very-large-test-case.txt)\\n\\nIf these test cases helped you, please consider upvoting.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[2],[2,1],[1,1],[2],[4,1],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[2],[2,1],[1,1],[2],[4,1],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2,1],[1,1],[2,3],[4,1],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[3,3],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 595578,
                "title": "python-3-simple-o-1-solution-using-ordereddict-that-beats-99-9-of-submissions",
                "content": "The `OrderedDict` keeps the order of elements added to the dictionary. This attribute can be used to keep track of the least recently used value order.\\n\\n```\\nfrom collections import OrderedDict\\n\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = OrderedDict()\\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n\\t\\t\\t# if we touch a key to return its value, we need to add it \\n\\t\\t\\t# to the end of the least recently used items in our cache\\n            self.cache.move_to_end(key)\\n            return self.cache[key]\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        # check if key already exists - if yes, move item to end and update the value\\n        if key in self.cache:\\n            self.cache.move_to_end(key)\\n        # if cache is full, remove least recent item (first value in OrderedDict)\\n        elif len(self.cache) == self.capacity:\\n            self.cache.popitem(last=False)\\n\\t\\t# update/add value\\n        self.cache[key] = value\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import OrderedDict\\n\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.cache = OrderedDict()\\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n\\t\\t\\t# if we touch a key to return its value, we need to add it \\n\\t\\t\\t# to the end of the least recently used items in our cache\\n            self.cache.move_to_end(key)\\n            return self.cache[key]\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        # check if key already exists - if yes, move item to end and update the value\\n        if key in self.cache:\\n            self.cache.move_to_end(key)\\n        # if cache is full, remove least recent item (first value in OrderedDict)\\n        elif len(self.cache) == self.capacity:\\n            self.cache.popitem(last=False)\\n\\t\\t# update/add value\\n        self.cache[key] = value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595264,
                "title": "c-o-1-time-solution-using-dictionary-and-linkedlist",
                "content": "```\\npublic class LRUCache {\\n    private Dictionary<int,LinkedListNode<int>> _hashes;\\n    private LinkedList<int> _list;\\n    private readonly int _capacity;\\n\\n    public LRUCache(int capacity) {\\n         _hashes = new Dictionary<int,LinkedListNode<int>>(capacity);\\n        _list = new LinkedList<int>();\\n        _capacity = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if (!_hashes.ContainsKey(key))\\n            return -1;\\n        var node = _hashes[key];\\n        if (node.List == null) {\\n            _hashes.Remove(key);\\n            return -1;\\n        }   \\n        _list.Remove(node);\\n        _list.AddFirst(node);\\n        return node.Value;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if (_hashes.ContainsKey(key)) {\\n            var node = _hashes[key];\\n            if (node.List != null) {\\n                node.Value = value;\\n                _list.Remove(node);\\n                _list.AddFirst(node);\\n                return;\\n            }\\n            else\\n                _hashes.Remove(key);\\n        }\\n        if (_list.Count == _capacity)\\n            _list.RemoveLast();\\n        var newNode = _list.AddFirst(value);\\n        _hashes.Add(key, newNode);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\npublic class LRUCache {\\n    private Dictionary<int,LinkedListNode<int>> _hashes;\\n    private LinkedList<int> _list;\\n    private readonly int _capacity;\\n\\n    public LRUCache(int capacity) {\\n         _hashes = new Dictionary<int,LinkedListNode<int>>(capacity);\\n        _list = new LinkedList<int>();\\n        _capacity = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if (!_hashes.ContainsKey(key))\\n            return -1;\\n        var node = _hashes[key];\\n        if (node.List == null) {\\n            _hashes.Remove(key);\\n            return -1;\\n        }   \\n        _list.Remove(node);\\n        _list.AddFirst(node);\\n        return node.Value;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if (_hashes.ContainsKey(key)) {\\n            var node = _hashes[key];\\n            if (node.List != null) {\\n                node.Value = value;\\n                _list.Remove(node);\\n                _list.AddFirst(node);\\n                return;\\n            }\\n            else\\n                _hashes.Remove(key);\\n        }\\n        if (_list.Count == _capacity)\\n            _list.RemoveLast();\\n        var newNode = _list.AddFirst(value);\\n        _hashes.Add(key, newNode);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167369,
                "title": "26-lines-java-linkedhashmap",
                "content": "Java already has a LinkedHashMap functionality. Why are so many people implementing their own?\\nEDIT: sligtly improved to be less code.\\n```\\nclass LRUCache { \\n    private LinkedHashMap<Integer, Integer> cache;\\n    private int capacity; \\n    \\n    public LRUCache(int capacity) {\\n        \\n        //create cache with initial capacity of 16 items, load factor of 75% and using access order (LRU style) retrieval\\n        this.cache = new LinkedHashMap<Integer, Integer>(16,0.75f,true){\\n            \\n            //anonymous inner class to override removeEldestEntry behaivor. \\n            @Override\\n            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\\n                return  cache.size() > capacity;\\n            }\\n        };\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        int value = cache.getOrDefault(key, -1);\\n        return value;\\n    } \\n    \\n    public void put(int key, int value) {  \\n        cache.put(key, value);  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LRUCache { \\n    private LinkedHashMap<Integer, Integer> cache;\\n    private int capacity; \\n    \\n    public LRUCache(int capacity) {\\n        \\n        //create cache with initial capacity of 16 items, load factor of 75% and using access order (LRU style) retrieval\\n        this.cache = new LinkedHashMap<Integer, Integer>(16,0.75f,true){\\n            \\n            //anonymous inner class to override removeEldestEntry behaivor. \\n            @Override\\n            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\\n                return  cache.size() > capacity;\\n            }\\n        };\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        int value = cache.getOrDefault(key, -1);\\n        return value;\\n    } \\n    \\n    public void put(int key, int value) {  \\n        cache.put(key, value);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780891,
                "title": "python-easy-solution-dictionary-701-ms-beats-91-59",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a dictionary to store the key value pairs and shift their position depending on their use.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor the get function, if the key exists in the dictionary we store the value in a variable val and delete the key. We again store the key value pair. This is done to shift the position of the key value pair so that the least recently used pair moves to the top of the dictionary. \\n\\nFor the put function, we check if the number of items in the dictionary is equal to the capacity. If yes, we delete the top item and insert the new key value pair.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for put() and get().\\n\\n\\n# Code\\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.capacity = capacity\\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            val = self.cache.pop(key) \\n            self.cache[key] = val\\n            return self.cache.get(key)\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.cache.keys():\\n            if len(self.cache.keys()) == self.capacity:\\n                del self.cache[next(iter(self.cache))]\\n        else:\\n            self.cache.pop(key)\\n        self.cache[key] = value\\n\\n\\n\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.capacity = capacity\\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            val = self.cache.pop(key) \\n            self.cache[key] = val\\n            return self.cache.get(key)\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.cache.keys():\\n            if len(self.cache.keys()) == self.capacity:\\n                del self.cache[next(iter(self.cache))]\\n        else:\\n            self.cache.pop(key)\\n        self.cache[key] = value\\n\\n\\n\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780802,
                "title": "c-faster-than-90-of-sol-n-no-linkedlist-only-map-and-set-imple-clean-and-concise",
                "content": "**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is straight forward and is as follows in some points :\\n\\n->Used a res variable and it will tell the rank of every key present\\n\\n->Use 2 Maps : One for storing key,value pairs and another for \\nstoring key rank pairs\\n\\n-> Whenever the get function is called if key is not present in map simply return -1;\\nelse delete the previous ranked key present in st and update it with a new rank which shows it is recently used.\\n\\n-> Whenever the put function is called there are 2 possibilities:\\n   \\nif key is already present in map just delete the previous ranked key present in st and update it with a new rank and valye which shows it is recently used.\\n\\nelse if size of map is equal to capacity delete the element which is present at top of set , ie st.begin and insert the element with a new rank and value in set and maps\\n\\nHappy Coding ! \\n\\n# Complexity\\n- Time complexity:O(LogN)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass LRUCache {\\npublic:\\n    int cnt;\\n    unordered_map<int,int> mp;\\n    deque<int> dq;\\n    set<pair<int,int>> st;\\n    unordered_map<int,int> val;\\n    int res=0;\\n    LRUCache(int capacity) {\\n        cnt=capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.count(key)){\\n            int v=val[key];\\n            st.erase({v,key});\\n            res++;\\n            st.insert({res,key});\\n            val[key]=res;\\n            return mp[key];\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!mp.count(key)){\\n            if(mp.size()==cnt){\\n                int r=st.begin()->second;\\n                st.erase(st.begin());\\n                mp.erase(r);\\n                val.erase(r);\\n            }\\n            res++;\\n            mp[key]=value;\\n            val[key]=res;\\n            st.insert({res,key});\\n        }\\n        else{\\n            int v=val[key];\\n            st.erase({v,key});\\n            res++;\\n            st.insert({res,key});\\n            mp[key]=value;\\n            val[key]=res;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    int cnt;\\n    unordered_map<int,int> mp;\\n    deque<int> dq;\\n    set<pair<int,int>> st;\\n    unordered_map<int,int> val;\\n    int res=0;\\n    LRUCache(int capacity) {\\n        cnt=capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.count(key)){\\n            int v=val[key];\\n            st.erase({v,key});\\n            res++;\\n            st.insert({res,key});\\n            val[key]=res;\\n            return mp[key];\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!mp.count(key)){\\n            if(mp.size()==cnt){\\n                int r=st.begin()->second;\\n                st.erase(st.begin());\\n                mp.erase(r);\\n                val.erase(r);\\n            }\\n            res++;\\n            mp[key]=value;\\n            val[key]=res;\\n            st.insert({res,key});\\n        }\\n        else{\\n            int v=val[key];\\n            st.erase({v,key});\\n            res++;\\n            st.insert({res,key});\\n            mp[key]=value;\\n            val[key]=res;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816473,
                "title": "c-fastest",
                "content": "**Complexities:**\\n```\\nTime: O(n)\\nSpace :O(1)\\n```\\n**Initial thoughts**: \\uD83D\\uDCAD\\nThe naive approach will be using arrays and removing and stuffs but those will be of linear complexities, i.e - TC - **O(n)**\\n\\nWe need to do this in **O(1)**\\n\\n**How can we achieve this?** \\uD83E\\uDD14\\n\\nWhile inserting the {key,val} pair into the DDL we need to make sure that we are inserting it from the back tail to the head.\\nThe cache will tell us when the {key, value} pair is used/inserted.\\n\\nSo, while inserting the {key,val}pair, we need to:\\n\\u27A1 Check if the {key,val} pair is already present in Cache or not.\\n\\u27A1 Check for the capacity, if the (Cache size == capacity) then while inserting the new pair we need to remove the LRU and insert the new pair right after the head & while removing the node we need to make sure that we remove the {value, node} pair from the cache.\\n\\u27A1Finally check, If the key is not present in the Cache then return -1;\\n\\n**C++** \\n```\\nclass LRUCache {\\npublic:\\n    class node {\\n        public:\\n            int key;\\n            int val;\\n            node* next;\\n            node* prev;\\n        node(int _key, int _val) {\\n            key = _key;\\n            val = _val; \\n        }\\n    };\\n    \\n    node* head = new node(-1,-1);\\n    node* tail = new node(-1,-1);\\n    \\n    int cap;\\n    unordered_map<int, node*>m;\\n    \\n    LRUCache(int capacity) {\\n        cap = capacity;    \\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    void addnode(node* newnode) {\\n        node* temp = head->next;\\n        newnode->next = temp;\\n        newnode->prev = head;\\n        head->next = newnode;\\n        temp->prev = newnode;\\n    }\\n    \\n    void deletenode(node* delnode) {\\n        node* delprev = delnode->prev;\\n        node* delnext = delnode->next;\\n        delprev->next = delnext;\\n        delnext->prev = delprev;\\n    }\\n    \\n    int get(int key_) {\\n        if (m.find(key_) != m.end()) {\\n            node* resnode = m[key_];\\n            int res = resnode->val;\\n            m.erase(key_);\\n            deletenode(resnode);\\n            addnode(resnode);\\n            m[key_] = head->next;\\n            return res; \\n        }\\n    \\n        return -1;\\n    }\\n    \\n    void put(int key_, int value) {\\n        if(m.find(key_) != m.end()) {\\n            node* existingnode = m[key_];\\n            m.erase(key_);\\n            deletenode(existingnode);\\n        }\\n        if(m.size() == cap) {\\n          m.erase(tail->prev->key);\\n          deletenode(tail->prev);\\n        }\\n        \\n        addnode(new node(key_, value));\\n        m[key_] = head->next; \\n    }\\n};\\n```\\n**`Please upvote, if you like it :)`**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nTime: O(n)\\nSpace :O(1)\\n```\n```\\nclass LRUCache {\\npublic:\\n    class node {\\n        public:\\n            int key;\\n            int val;\\n            node* next;\\n            node* prev;\\n        node(int _key, int _val) {\\n            key = _key;\\n            val = _val; \\n        }\\n    };\\n    \\n    node* head = new node(-1,-1);\\n    node* tail = new node(-1,-1);\\n    \\n    int cap;\\n    unordered_map<int, node*>m;\\n    \\n    LRUCache(int capacity) {\\n        cap = capacity;    \\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    void addnode(node* newnode) {\\n        node* temp = head->next;\\n        newnode->next = temp;\\n        newnode->prev = head;\\n        head->next = newnode;\\n        temp->prev = newnode;\\n    }\\n    \\n    void deletenode(node* delnode) {\\n        node* delprev = delnode->prev;\\n        node* delnext = delnode->next;\\n        delprev->next = delnext;\\n        delnext->prev = delprev;\\n    }\\n    \\n    int get(int key_) {\\n        if (m.find(key_) != m.end()) {\\n            node* resnode = m[key_];\\n            int res = resnode->val;\\n            m.erase(key_);\\n            deletenode(resnode);\\n            addnode(resnode);\\n            m[key_] = head->next;\\n            return res; \\n        }\\n    \\n        return -1;\\n    }\\n    \\n    void put(int key_, int value) {\\n        if(m.find(key_) != m.end()) {\\n            node* existingnode = m[key_];\\n            m.erase(key_);\\n            deletenode(existingnode);\\n        }\\n        if(m.size() == cap) {\\n          m.erase(tail->prev->key);\\n          deletenode(tail->prev);\\n        }\\n        \\n        addnode(new node(key_, value));\\n        m[key_] = head->next; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035482,
                "title": "python-dictionary-doubly-linked-list-implementation-not-so-efficient-but-very-easy-to-understand",
                "content": "\\n```\\nclass Node:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.value = value\\n        self.prev = None\\n        self.next = None\\n        \\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.hashmap = dict()\\n        self.head = Node(0,0)\\n        self.tail = Node(0,0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n\\n    def get(self, key: int) -> int:\\n        # if key does not exist in hashmap, return -1\\n        if key not in self.hashmap:\\n            return -1\\n        else:\\n            # if the key exists in hashmap, pull the value(node), perform put operation on the new key-value pair. Return the previously extracted value of the node\\n            node = self.hashmap[key]\\n            self.put(key,node.value)\\n            return node.value\\n            \\n\\n    def put(self, key: int, value: int) -> None:\\n        # if key exists in hashmap, pull the value(node), remove it from the linkedlist and pop it from hashmap. Perform re-creation of the node and re-insertion.\\n        if key in self.hashmap:\\n            node = self.hashmap[key]\\n            self.removeNodeFromList(node)\\n            self.hashmap.pop(node.key)\\n            \\n        # if the hashmap reaches capacity, remove the last node from the linked list and pop that record from the hashmap.    \\n        if len(self.hashmap)==self.capacity:\\n            node = self.tail.prev\\n            self.removeNodeFromList(node)\\n            self.hashmap.pop(node.key)   \\n        \\n        # create a node of (key,value), insert it as a value for the given key in the hashmap and also insert that node at the head of the linkedlist.\\n        node = Node(key,value)\\n        self.hashmap[key] = node\\n        self.insertAtHead(node)\\n        \\n    \\n    def insertAtHead(self,node):\\n        # insert always at the head\\n        node.next = self.head.next\\n        node.prev = self.head\\n        node.next.prev = node\\n        self.head.next = node\\n        \\n    def removeNodeFromList(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, key, value):\\n        self.key = key\\n        self.value = value\\n        self.prev = None\\n        self.next = None\\n        \\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.hashmap = dict()\\n        self.head = Node(0,0)\\n        self.tail = Node(0,0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n\\n    def get(self, key: int) -> int:\\n        # if key does not exist in hashmap, return -1\\n        if key not in self.hashmap:\\n            return -1\\n        else:\\n            # if the key exists in hashmap, pull the value(node), perform put operation on the new key-value pair. Return the previously extracted value of the node\\n            node = self.hashmap[key]\\n            self.put(key,node.value)\\n            return node.value\\n            \\n\\n    def put(self, key: int, value: int) -> None:\\n        # if key exists in hashmap, pull the value(node), remove it from the linkedlist and pop it from hashmap. Perform re-creation of the node and re-insertion.\\n        if key in self.hashmap:\\n            node = self.hashmap[key]\\n            self.removeNodeFromList(node)\\n            self.hashmap.pop(node.key)\\n            \\n        # if the hashmap reaches capacity, remove the last node from the linked list and pop that record from the hashmap.    \\n        if len(self.hashmap)==self.capacity:\\n            node = self.tail.prev\\n            self.removeNodeFromList(node)\\n            self.hashmap.pop(node.key)   \\n        \\n        # create a node of (key,value), insert it as a value for the given key in the hashmap and also insert that node at the head of the linkedlist.\\n        node = Node(key,value)\\n        self.hashmap[key] = node\\n        self.insertAtHead(node)\\n        \\n    \\n    def insertAtHead(self,node):\\n        # insert always at the head\\n        node.next = self.head.next\\n        node.prev = self.head\\n        node.next.prev = node\\n        self.head.next = node\\n        \\n    def removeNodeFromList(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011481,
                "title": "thread-safe-java-implementation-with-concurrenthashmap-and-reentrantlock",
                "content": "This is a thread-safe implementation of the LRU Cache. We use [ConcurrentHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html), [AtomicInteger](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html), and [ReentrantLock](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html) to achieve thread-safety. \\n```\\nclass LRUCache {\\n    class Node {\\n        int key;\\n        int value;\\n        Node next;\\n        Node prev;\\n        \\n        public Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n            next = null;\\n            prev = null;\\n        }\\n    }\\n    \\n    private ConcurrentHashMap<Integer, Node> map;\\n    private AtomicInteger size;\\n    private int capacity;\\n    private Node head, tail;\\n    private ReentrantLock lock;\\n    \\n    public LRUCache(int capacity) {\\n        map = new ConcurrentHashMap<>();\\n        size = new AtomicInteger();\\n        this.capacity = capacity;\\n        head = new Node(0, 0);\\n        tail = new Node(0, 0);\\n        head.prev = tail;\\n        tail.next = head;\\n        lock = new ReentrantLock();\\n    }\\n    \\n    public int get(int key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            removeNode(key);\\n            addNode(key, node.value);\\n            return node.value;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            removeNode(key);\\n            addNode(key, value);\\n        } else {\\n            addNode(key, value);\\n        }\\n    }\\n    \\n    // Remove the Node from DLL\\n    private void removeNode(int key) {\\n        lock.lock();\\n        try {\\n            Node node = map.get(key);\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n\\n            size.decrementAndGet(); \\n            map.remove(node.key);\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n    \\n    // Add the Node at the head of DLL\\n    private void addNode(int key, int value) {\\n        lock.lock();\\n        try {\\n            Node node = new Node(key, value);\\n\\n            node.prev = head.prev;\\n            head.prev = node;\\n            node.prev.next = node;\\n            node.next = head;\\n\\n            map.put(key, node);\\n            size.incrementAndGet(); \\n            if (size.get() > capacity) {\\n                removeNode(tail.next.key);\\n            }\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Design"
                ],
                "code": "```\\nclass LRUCache {\\n    class Node {\\n        int key;\\n        int value;\\n        Node next;\\n        Node prev;\\n        \\n        public Node(int key, int value) {\\n            this.key = key;\\n            this.value = value;\\n            next = null;\\n            prev = null;\\n        }\\n    }\\n    \\n    private ConcurrentHashMap<Integer, Node> map;\\n    private AtomicInteger size;\\n    private int capacity;\\n    private Node head, tail;\\n    private ReentrantLock lock;\\n    \\n    public LRUCache(int capacity) {\\n        map = new ConcurrentHashMap<>();\\n        size = new AtomicInteger();\\n        this.capacity = capacity;\\n        head = new Node(0, 0);\\n        tail = new Node(0, 0);\\n        head.prev = tail;\\n        tail.next = head;\\n        lock = new ReentrantLock();\\n    }\\n    \\n    public int get(int key) {\\n        if (map.containsKey(key)) {\\n            Node node = map.get(key);\\n            removeNode(key);\\n            addNode(key, node.value);\\n            return node.value;\\n        } else {\\n            return -1;\\n        }\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            removeNode(key);\\n            addNode(key, value);\\n        } else {\\n            addNode(key, value);\\n        }\\n    }\\n    \\n    // Remove the Node from DLL\\n    private void removeNode(int key) {\\n        lock.lock();\\n        try {\\n            Node node = map.get(key);\\n            node.prev.next = node.next;\\n            node.next.prev = node.prev;\\n\\n            size.decrementAndGet(); \\n            map.remove(node.key);\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n    \\n    // Add the Node at the head of DLL\\n    private void addNode(int key, int value) {\\n        lock.lock();\\n        try {\\n            Node node = new Node(key, value);\\n\\n            node.prev = head.prev;\\n            head.prev = node;\\n            node.prev.next = node;\\n            node.next = head;\\n\\n            map.put(key, node);\\n            size.incrementAndGet(); \\n            if (size.get() > capacity) {\\n                removeNode(tail.next.key);\\n            }\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 754241,
                "title": "c-doubly-linked-list-faster-than-80",
                "content": "```\\nclass LRUCache {\\npublic:\\n    class node {\\n        public:\\n            int key;\\n            int val;\\n            node* next;\\n            node* prev;\\n    };\\n    \\n    node* head = new node();\\n    node* tail = new node();\\n    \\n    int cap;\\n    unordered_map<int, node*>m;\\n    \\n    LRUCache(int capacity) {\\n        cap = capacity;    \\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    void addnode(node* newnode) {\\n        node* temp = head->next;\\n        newnode->next = temp;\\n        newnode->prev = head;\\n        head->next = newnode;\\n        temp->prev = newnode;\\n    }\\n    \\n    void deletenode(node* delnode) {\\n        node* delprev = delnode->prev;\\n        node* delnext = delnode->next;\\n        delprev->next = delnext;\\n        delnext->prev = delprev;\\n        //delete(delnode);\\n    }\\n    \\n    int get(int key_) {\\n        int res = -1;\\n        if (m.find(key_) != m.end()) {\\n            node* resnode = m[key_];\\n            res = resnode->val;\\n            deletenode(resnode);\\n            m.erase(key_);\\n            addnode(resnode);\\n            m[key_] = head->next;\\n        }\\n        return res;\\n    }\\n    \\n    void put(int key_, int value) {\\n        if (m.find(key_) != m.end()) {\\n            node* existingnode = m[key_];\\n            if (existingnode->val != value) {\\n                existingnode->val = value;\\n            }\\n            deletenode(existingnode);\\n            addnode(existingnode);\\n            m.erase(key_);\\n            m[key_] = head->next;\\n        }\\n        else {\\n            if (m.size() == cap) {\\n                node* delnode = tail->prev;\\n                int delkey = delnode->key;\\n                deletenode(delnode);\\n                node* newnode = new node();\\n                newnode->key = key_;\\n                newnode->val = value;\\n                addnode(newnode);\\n                m.erase(delkey);\\n                m[key_] = newnode;\\n            }\\n            else if (m.size() < cap) {\\n                node* newnode = new node();\\n                newnode->key = key_;\\n                newnode->val = value;\\n                addnode(newnode);\\n                m[key_] = newnode;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    class node {\\n        public:\\n            int key;\\n            int val;\\n            node* next;\\n            node* prev;\\n    };\\n    \\n    node* head = new node();\\n    node* tail = new node();\\n    \\n    int cap;\\n    unordered_map<int, node*>m;\\n    \\n    LRUCache(int capacity) {\\n        cap = capacity;    \\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    void addnode(node* newnode) {\\n        node* temp = head->next;\\n        newnode->next = temp;\\n        newnode->prev = head;\\n        head->next = newnode;\\n        temp->prev = newnode;\\n    }\\n    \\n    void deletenode(node* delnode) {\\n        node* delprev = delnode->prev;\\n        node* delnext = delnode->next;\\n        delprev->next = delnext;\\n        delnext->prev = delprev;\\n        //delete(delnode);\\n    }\\n    \\n    int get(int key_) {\\n        int res = -1;\\n        if (m.find(key_) != m.end()) {\\n            node* resnode = m[key_];\\n            res = resnode->val;\\n            deletenode(resnode);\\n            m.erase(key_);\\n            addnode(resnode);\\n            m[key_] = head->next;\\n        }\\n        return res;\\n    }\\n    \\n    void put(int key_, int value) {\\n        if (m.find(key_) != m.end()) {\\n            node* existingnode = m[key_];\\n            if (existingnode->val != value) {\\n                existingnode->val = value;\\n            }\\n            deletenode(existingnode);\\n            addnode(existingnode);\\n            m.erase(key_);\\n            m[key_] = head->next;\\n        }\\n        else {\\n            if (m.size() == cap) {\\n                node* delnode = tail->prev;\\n                int delkey = delnode->key;\\n                deletenode(delnode);\\n                node* newnode = new node();\\n                newnode->key = key_;\\n                newnode->val = value;\\n                addnode(newnode);\\n                m.erase(delkey);\\n                m[key_] = newnode;\\n            }\\n            else if (m.size() < cap) {\\n                node* newnode = new node();\\n                newnode->key = key_;\\n                newnode->val = value;\\n                addnode(newnode);\\n                m[key_] = newnode;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594954,
                "title": "cpp-c-lru-cache-using-map-and-list-easy-to-understand",
                "content": "1. Take one list to store <key> only.\\n2. one unordered hashmp to sore <key, value> pair\\n\\n**Explanation for funtions:**\\n\\nLRUCache(int capacity) {     //constructor\\n1. //added for fast I/O\\n2.  //added for fast I/O\\n3.  //added for fast I/O\\n//above three steps can be removed.\\n 4.initalising the capacity of the cache\\n}\\n\\n```\\nLRUCache(int capacity) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        cap = capacity;\\n    }\\n```\\n\\nint get(int key){\\n\\t1. if keynot found return -1\\n\\t2. if key is found\\n\\t\\ta. remove the key from list\\n\\t\\tb. push the key back of the list. (we are pushing back every recently used.. means least recent    one on front)\\n\\t\\tc. return value\\n}\\n\\n```\\n  int get(int key) {\\n         if(mp.find(key) == mp.end() ) return -1;\\n        \\n        else{\\n            key_list.remove(key);\\n            key_list.push_back(key);\\n            return mp[key];\\n        }\\n        \\n    }\\n```\\n\\n void put(int key, int value) {\\n  1. if key is found in the map ? // even though we found the entry we removing and inserting again.\\n\\t  a. erase that key from the map\\n\\t  b. remove that key from list as well.\\n 2. if list capacity reaches max // size of capacity \\n\\t a. remove the front key of the list \\n\\t b. <key, value> entry also erased from map\\n3. a. insert the <key, value> in the map \\n\\tb. push the key back of the list\\n }\\n \\n```\\nvoid put(int key, int value) {\\n        if(mp.find(key) != mp.end() ){\\n            mp.erase(key);\\n            key_list.remove(key);\\n        }\\n        if(key_list.size() == cap){\\n           int temp = key_list.front();\\n            key_list.pop_front();\\n            mp.erase(temp);\\n        }\\n        mp[key] = value;\\n        key_list.push_back(key);\\n    }\\n```\\n\\n**Complete Code for the reference:**\\n\\n\\n\\n\\n\\n\\n```\\nclass LRUCache {\\npublic:\\n    int cap;\\n    list<int>key_list; //stores only keys\\n    unordered_map<int,int>mp; // stores keys and corresponding values.\\n\\t\\n\\t\\n    LRUCache(int capacity) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n         if(mp.find(key) == mp.end() ) return -1;\\n        \\n        else{\\n            key_list.remove(key);\\n            key_list.push_back(key);\\n            return mp[key];\\n        }\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key) != mp.end() ){\\n            mp.erase(key);\\n            key_list.remove(key);\\n        }\\n        if(key_list.size() == cap){\\n           int temp = key_list.front();\\n            key_list.pop_front();\\n            mp.erase(temp);\\n        }\\n        mp[key] = value;\\n        key_list.push_back(key);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nLRUCache(int capacity) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        cap = capacity;\\n    }\\n```\n```\\n  int get(int key) {\\n         if(mp.find(key) == mp.end() ) return -1;\\n        \\n        else{\\n            key_list.remove(key);\\n            key_list.push_back(key);\\n            return mp[key];\\n        }\\n        \\n    }\\n```\n```\\nvoid put(int key, int value) {\\n        if(mp.find(key) != mp.end() ){\\n            mp.erase(key);\\n            key_list.remove(key);\\n        }\\n        if(key_list.size() == cap){\\n           int temp = key_list.front();\\n            key_list.pop_front();\\n            mp.erase(temp);\\n        }\\n        mp[key] = value;\\n        key_list.push_back(key);\\n    }\\n```\n```\\nclass LRUCache {\\npublic:\\n    int cap;\\n    list<int>key_list; //stores only keys\\n    unordered_map<int,int>mp; // stores keys and corresponding values.\\n\\t\\n\\t\\n    LRUCache(int capacity) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n         if(mp.find(key) == mp.end() ) return -1;\\n        \\n        else{\\n            key_list.remove(key);\\n            key_list.push_back(key);\\n            return mp[key];\\n        }\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key) != mp.end() ){\\n            mp.erase(key);\\n            key_list.remove(key);\\n        }\\n        if(key_list.size() == cap){\\n           int temp = key_list.front();\\n            key_list.pop_front();\\n            mp.erase(temp);\\n        }\\n        mp[key] = value;\\n        key_list.push_back(key);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 594789,
                "title": "java-15ms-and-12-ms-linkedhashmap-2-versions",
                "content": "```\\nclass LRUCache {\\n    private LinkedHashMap<Integer, Integer> cache;\\n    private int N;\\n    \\n    public LRUCache(int capacity) {\\n        this.N = capacity;\\n        this.cache = new LinkedHashMap<Integer, Integer>();\\n    }\\n    \\n    public int get(int key) {\\n        int result = -1;\\n        \\n        if(this.cache.containsKey(key)){\\n            result = this.cache.get(key);\\n            this.cache.remove(key);\\n            this.cache.put(key, result);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(this.cache.containsKey(key)){\\n            this.cache.remove(key);\\n        }else{\\n            if(this.cache.size() == N){\\n                Integer firstKey = this.cache.keySet().iterator().next();\\n                this.cache.remove(firstKey);\\n            }\\n        }\\n        \\n        this.cache.put(key, value);\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```\\n\\nSecond solution suggested by @kapy\\n\\n```\\nclass LRUCache {\\n    LinkedHashMap<Integer, Integer> map;\\n\\n    public LRUCache(int capacity) {\\n        this.map = new LinkedHashMap<Integer, Integer>(capacity, 0.75F, true) {\\n            @Override\\n            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\\n                return this.size() > capacity;\\n            }\\n        };\\n    }\\n    \\n    public int get(int key) {\\n        return this.map.getOrDefault(key, -1);\\n    }\\n    \\n    public void put(int key, int value) {\\n        this.map.put(key, value);\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LRUCache {\\n    private LinkedHashMap<Integer, Integer> cache;\\n    private int N;\\n    \\n    public LRUCache(int capacity) {\\n        this.N = capacity;\\n        this.cache = new LinkedHashMap<Integer, Integer>();\\n    }\\n    \\n    public int get(int key) {\\n        int result = -1;\\n        \\n        if(this.cache.containsKey(key)){\\n            result = this.cache.get(key);\\n            this.cache.remove(key);\\n            this.cache.put(key, result);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if(this.cache.containsKey(key)){\\n            this.cache.remove(key);\\n        }else{\\n            if(this.cache.size() == N){\\n                Integer firstKey = this.cache.keySet().iterator().next();\\n                this.cache.remove(firstKey);\\n            }\\n        }\\n        \\n        this.cache.put(key, value);\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```\n```\\nclass LRUCache {\\n    LinkedHashMap<Integer, Integer> map;\\n\\n    public LRUCache(int capacity) {\\n        this.map = new LinkedHashMap<Integer, Integer>(capacity, 0.75F, true) {\\n            @Override\\n            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\\n                return this.size() > capacity;\\n            }\\n        };\\n    }\\n    \\n    public int get(int key) {\\n        return this.map.getOrDefault(key, -1);\\n    }\\n    \\n    public void put(int key, int value) {\\n        this.map.put(key, value);\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505777,
                "title": "c-o-1-get-o-1-put-barebone-no-built-in-framework-etc",
                "content": "Below code is self-explanatory as it appears with needed inline comments. It is a barebone C code accomplishing O(1) get O(1) put - with no built-in framework used to store and retrieve the data or to maintain LRU cache. It took considerable attempts to get everything finally working with top speed and minimum space. But, I feel it\\'s totally worth it.\\n```\\n#define MAX_CITEMS 3192\\n\\ntypedef struct LRUCache {\\n    int val;\\n    bool valid;\\n    struct LRUCache *prev;\\n    struct LRUCache *next;\\n} LRUCache;\\n\\nstruct cdata {\\n    int capacity;\\n    int size;\\n    struct LRUCache *cache;\\n    struct LRUCache *head;\\n    struct LRUCache *tail;\\n};\\n\\ninline void *alloc_cache(size_t capacity){\\n    struct cdata *cdata = calloc(1, sizeof *cdata);\\n    cdata->cache = calloc(1, sizeof(struct LRUCache [MAX_CITEMS]));\\n    cdata->capacity = capacity;\\n    return cdata;\\n}\\n\\ninline void dealloc_cache(void *obj){\\n    free(((struct cdata *)obj)->cache);\\n    free(obj);\\n}\\n\\ninline void refresh_cache(struct LRUCache *item, struct cdata *cdata, bool front){\\n    struct LRUCache **prev = &item->prev, **next = &item->next;\\n    struct LRUCache **head = &cdata->head, **tail = &cdata->tail;\\n    if (item->valid) { // Remove node \\n        *prev ? (*prev)->next = *next : 0;\\n        *next ? (*next)->prev = *prev : 0;\\n    }\\n    item == *tail ? *tail = *prev : 0;// Fix tail\\n    item->valid = front;    \\n    if (front) { // Move front\\n        *prev = NULL;                       \\n        *next = cdata->head;\\n        *head ? (*head)->prev = item : 0;\\n        *head = item; // Fix head\\n        !*tail ? *tail = *head : 0; // First entry\\n    }\\n}\\n\\nLRUCache* lRUCacheCreate(int capacity){\\n    return alloc_cache(capacity);\\n}\\n\\nint lRUCacheGet(LRUCache* obj, int key){\\n    struct cdata *cdata = (void *)obj;\\n    struct LRUCache *item = &cdata->cache[key];    \\n    if (!cdata->size || !item->valid)\\n        return -1;\\n    if (item == cdata->head)\\n        return item->val; // Already at front \\n    refresh_cache(item, cdata, true); // Move front\\n    return item->val;\\n}\\n\\nvoid lRUCachePut(LRUCache* obj, int key, int value){\\n    struct cdata *cdata = (void *)obj;\\n    struct LRUCache *item = &cdata->cache[key];\\n    if (item == cdata->head)\\n        return item->val = value, (void)0; // Already at front\\n    if (!item->valid)\\n        if (cdata->size == cdata->capacity)\\n            refresh_cache(cdata->tail, cdata, false); // Evict\\n        else\\n            cdata->size++;\\n    refresh_cache(item, cdata, true); // Move/add front\\n    item->val = value;            \\n}\\n\\nvoid lRUCacheFree(LRUCache* obj){\\n    dealloc_cache(obj);\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_CITEMS 3192\\n\\ntypedef struct LRUCache {\\n    int val;\\n    bool valid;\\n    struct LRUCache *prev;\\n    struct LRUCache *next;\\n} LRUCache;\\n\\nstruct cdata {\\n    int capacity;\\n    int size;\\n    struct LRUCache *cache;\\n    struct LRUCache *head;\\n    struct LRUCache *tail;\\n};\\n\\ninline void *alloc_cache(size_t capacity){\\n    struct cdata *cdata = calloc(1, sizeof *cdata);\\n    cdata->cache = calloc(1, sizeof(struct LRUCache [MAX_CITEMS]));\\n    cdata->capacity = capacity;\\n    return cdata;\\n}\\n\\ninline void dealloc_cache(void *obj){\\n    free(((struct cdata *)obj)->cache);\\n    free(obj);\\n}\\n\\ninline void refresh_cache(struct LRUCache *item, struct cdata *cdata, bool front){\\n    struct LRUCache **prev = &item->prev, **next = &item->next;\\n    struct LRUCache **head = &cdata->head, **tail = &cdata->tail;\\n    if (item->valid) { // Remove node \\n        *prev ? (*prev)->next = *next : 0;\\n        *next ? (*next)->prev = *prev : 0;\\n    }\\n    item == *tail ? *tail = *prev : 0;// Fix tail\\n    item->valid = front;    \\n    if (front) { // Move front\\n        *prev = NULL;                       \\n        *next = cdata->head;\\n        *head ? (*head)->prev = item : 0;\\n        *head = item; // Fix head\\n        !*tail ? *tail = *head : 0; // First entry\\n    }\\n}\\n\\nLRUCache* lRUCacheCreate(int capacity){\\n    return alloc_cache(capacity);\\n}\\n\\nint lRUCacheGet(LRUCache* obj, int key){\\n    struct cdata *cdata = (void *)obj;\\n    struct LRUCache *item = &cdata->cache[key];    \\n    if (!cdata->size || !item->valid)\\n        return -1;\\n    if (item == cdata->head)\\n        return item->val; // Already at front \\n    refresh_cache(item, cdata, true); // Move front\\n    return item->val;\\n}\\n\\nvoid lRUCachePut(LRUCache* obj, int key, int value){\\n    struct cdata *cdata = (void *)obj;\\n    struct LRUCache *item = &cdata->cache[key];\\n    if (item == cdata->head)\\n        return item->val = value, (void)0; // Already at front\\n    if (!item->valid)\\n        if (cdata->size == cdata->capacity)\\n            refresh_cache(cdata->tail, cdata, false); // Evict\\n        else\\n            cdata->size++;\\n    refresh_cache(item, cdata, true); // Move/add front\\n    item->val = value;            \\n}\\n\\nvoid lRUCacheFree(LRUCache* obj){\\n    dealloc_cache(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 247060,
                "title": "javascript-doublell-hashtable",
                "content": "I updated the code. I used this working version and added explanations+ comments:\\nhttps://leetcode.com/problems/lru-cache/discuss/251656/JavaScript-Map-+-DoubleLinkedList\\n\\n```\\n/*******************\\n* LRU Cache = two data structures to manage the elements. \\n* Map: used to store elements in the list\\n* Double Linked List: used to keep track of the ordering when performing operations\\n* A doubly-linked list and a map gives us the following:\\n* Time complexity: O(1)\\n* Space complexity: O(n)\\n* This is achieved by having the doubly-linked list manage when we have to rearrange the elements while the map gives us direct \\n* access to the resource. Look-up in a map is O(1) by providing the key. \\n* We introduce the concept of \\n* - the \\u201Chead\\u201D, which is the least recently used entry, \\n* - the \\u201Ctail\\u201D, which is the most recently used entry, \\n* to keep track of the order when elements are retrieved or added. \\n* There are two pointers per node which is relatively low cost to manage the ordering.\\n*******************/\\nvar LRUCache = function(capacity) {\\n  this.capacity = capacity; \\n  this.map = new Map(); //this stores the whole array\\n\\n  //boundaries for double LL\\n  this.head = {}; \\n  this.tail = {};\\n  this.head.next = this.tail; //initialize double LL\\n  this.tail.prev = this.head;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n  if(this.map.has(key)){\\n    //remove elem from current position\\n    let c = this.map.get(key);\\n    c.prev.next = c.next;\\n    c.next.prev = c.prev;\\n\\n    \\n    this.tail.prev.next = c; //insert it after the last element (elem before tail) since we just used it\\n    c.prev = this.tail.prev; //update c.prev and next pointer\\n    c.next = this.tail;\\n    this.tail.prev = c; //update last element as tail\\n    return c.value;\\n  } else {\\n    return -1; //element does not exist\\n  }\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n  if(this.get(key) !== -1){ //key does not exist, update last element value \\n    this.tail.prev.value = value; \\n  } else {\\n    //need to check if map size is at capacity\\n    if(this.map.size === this.capacity) { \\n      //delete item both from map and DLL\\n      this.map.delete(this.head.next.key); //delete first element of list\\n      this.head.next = this.head.next.next; //update first element as next element\\n      this.head.next.prev = this.head; \\n    }\\n\\n    let newNode = {\\n      value, \\n      key\\n    }; //each node is a hashtable that stores key and value \\n    \\n    \\n    //When adding a new node, we need to update both map and DLL\\n    this.map.set(key, newNode); //add current node to map \\n    this.tail.prev.next = newNode; //add node to end of the list\\n    newNode.prev = this.tail.prev; //update prev and next pointers of newNode\\n    newNode.next = this.tail;\\n    this.tail.prev = newNode; //update last element\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*******************\\n* LRU Cache = two data structures to manage the elements. \\n* Map: used to store elements in the list\\n* Double Linked List: used to keep track of the ordering when performing operations\\n* A doubly-linked list and a map gives us the following:\\n* Time complexity: O(1)\\n* Space complexity: O(n)\\n* This is achieved by having the doubly-linked list manage when we have to rearrange the elements while the map gives us direct \\n* access to the resource. Look-up in a map is O(1) by providing the key. \\n* We introduce the concept of \\n* - the \\u201Chead\\u201D, which is the least recently used entry, \\n* - the \\u201Ctail\\u201D, which is the most recently used entry, \\n* to keep track of the order when elements are retrieved or added. \\n* There are two pointers per node which is relatively low cost to manage the ordering.\\n*******************/\\nvar LRUCache = function(capacity) {\\n  this.capacity = capacity; \\n  this.map = new Map(); //this stores the whole array\\n\\n  //boundaries for double LL\\n  this.head = {}; \\n  this.tail = {};\\n  this.head.next = this.tail; //initialize double LL\\n  this.tail.prev = this.head;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n  if(this.map.has(key)){\\n    //remove elem from current position\\n    let c = this.map.get(key);\\n    c.prev.next = c.next;\\n    c.next.prev = c.prev;\\n\\n    \\n    this.tail.prev.next = c; //insert it after the last element (elem before tail) since we just used it\\n    c.prev = this.tail.prev; //update c.prev and next pointer\\n    c.next = this.tail;\\n    this.tail.prev = c; //update last element as tail\\n    return c.value;\\n  } else {\\n    return -1; //element does not exist\\n  }\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n  if(this.get(key) !== -1){ //key does not exist, update last element value \\n    this.tail.prev.value = value; \\n  } else {\\n    //need to check if map size is at capacity\\n    if(this.map.size === this.capacity) { \\n      //delete item both from map and DLL\\n      this.map.delete(this.head.next.key); //delete first element of list\\n      this.head.next = this.head.next.next; //update first element as next element\\n      this.head.next.prev = this.head; \\n    }\\n\\n    let newNode = {\\n      value, \\n      key\\n    }; //each node is a hashtable that stores key and value \\n    \\n    \\n    //When adding a new node, we need to update both map and DLL\\n    this.map.set(key, newNode); //add current node to map \\n    this.tail.prev.next = newNode; //add node to end of the list\\n    newNode.prev = this.tail.prev; //update prev and next pointers of newNode\\n    newNode.next = this.tail;\\n    this.tail.prev = newNode; //update last element\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162452,
                "title": "javascript-es6-class-inherited-from-map-solution-o-1-complexity",
                "content": "```\\nclass LRUCache extends Map {\\n\\n    constructor(capacity) {\\n        super()\\n        this.capacity = capacity\\n    }\\n\\n    get(key) {\\n        if (!this.has(key)) { return -1 }\\n        let val = super.get(key)\\n        this.delete(key)\\n        this.set(key, val)\\n        return val\\n    }\\n\\n    put(key, value) {\\n        if (this.has(key) || this.size < this.capacity) {\\n            this.get(key)\\n            this.set(key, value)\\n        }\\n        else if (this.size > 0) {\\n            this.delete(this.keys().next().value)\\n            this.set(key, value)\\n        }\\n    }\\n}\\n```\\n\\nExplain:\\n* Keys in JavaScript Map are ordered.\\n* Override Map `get` method to move the key to the end (delete then set again, O(1) complexity)\\n* `Map.prototype.keys()` returns an `Iterator` instead of an array, so using `next()` to get the first key is O(1) complexity.\\n* `class` syntax is cleaner then `prototype` IMO :)",
                "solutionTags": [],
                "code": "```\\nclass LRUCache extends Map {\\n\\n    constructor(capacity) {\\n        super()\\n        this.capacity = capacity\\n    }\\n\\n    get(key) {\\n        if (!this.has(key)) { return -1 }\\n        let val = super.get(key)\\n        this.delete(key)\\n        this.set(key, val)\\n        return val\\n    }\\n\\n    put(key, value) {\\n        if (this.has(key) || this.size < this.capacity) {\\n            this.get(key)\\n            this.set(key, value)\\n        }\\n        else if (this.size > 0) {\\n            this.delete(this.keys().next().value)\\n            this.set(key, value)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46321,
                "title": "my-o-1-solution-in-java",
                "content": "    //Approach is to maintain a doubly link list  of key value pair (this will act as data structure for cache) and a Map which will store a reference to a node in the DLL corresponding to each key. \\n    //In get operation, we will check for the key in the Map. If it is there , get reference to the Node from the Map and extract its value  and place it at the start of the list.Otherwise, return -1\\n    // For put operation, we need to put the the new node at the start of the list. If the capacity of cache is already met, remove the last node from the list(and its corresponding entry from the map).\\n    //Take care of the edge cases where cache capacity is only 1.\\n    \\n    \\n    \\n    \\n    public class LRUCache {\\n        //Node to store the key-value pairs.\\n         class Node\\n            {\\n                int key;\\n                int value;\\n                Node next;\\n                Node prev;\\n                public Node(int x , int y, Node n , Node p)\\n                {\\n                    key=x;\\n                    value=y;\\n                    next=n;\\n                    prev=p;\\n                }\\n                \\n            }\\n            \\n        // Doubly link list of type Node.    \\n        class DoublyLL\\n        {\\n           \\n            Node first;\\n            Node last;\\n            int size;\\n            int count;\\n            public DoublyLL(int c)\\n            {\\n                size=c;\\n                count=0;\\n                first=null;\\n                last=null;\\n                \\n            }\\n        }\\n        HashMap<Integer,Node> map;      //The map will store a reference to the Node in DLL corresponding to each key.\\n        DoublyLL dll;\\n        public LRUCache(int capacity) {\\n            \\n           \\n          dll=new DoublyLL(capacity);\\n            \\n            map=new HashMap <Integer,Node> ();\\n            \\n           \\n            \\n        }\\n        \\n        public int get(int key) {\\n            \\n            if(map.containsKey(key))\\n            {\\n                Node n=map.get(key);\\n                if(n.prev!=null)\\n                {\\n                if(dll.last==n)\\n                dll.last=n.prev;\\n                n.prev.next=n.next;\\n                if(n.next!=null)\\n                n.next.prev=n.prev;\\n                n.prev=null;\\n                n.next=dll.first;\\n                \\n                dll.first.prev=n;\\n                dll.first=n;\\n                }\\n                \\n               \\n                \\n                return n.value;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n       \\n        \\n        public void set(int key, int value) {\\n             Node n;\\n          \\n             if(!map.containsKey(key))\\n            {\\n                n=new Node(key,value,null,null);\\n                if(dll.size!=dll.count)\\n                {\\n                         n.next=dll.first;\\n                        if(dll.count!=0)\\n                        {\\n                            dll.first.prev=n;\\n                        }\\n                        else\\n                        {\\n                            dll.last=n;\\n                            \\n                        }\\n                       \\n                        dll.first=n;\\n                        dll.count++; \\n                }\\n                else\\n                {\\n                \\n                    if(dll.count!=1)\\n                         {\\n                            map.remove(dll.last.key);\\n                            dll.last.prev.next=null;\\n                            dll.last=dll.last.prev;\\n                            dll.first.prev=n;\\n                            n.next=dll.first;\\n                            dll.first=n;\\n                             \\n                         }\\n                    else\\n                    {   map.remove(dll.first.key);\\n                        dll.first=n;\\n                        dll.last=n;\\n                    }\\n                \\n                }\\n                  map.put(key,n);\\n                 \\n            }\\n            else\\n            {\\n                n=map.get(key);\\n                n.value=value;\\n                if(n.prev!=null)\\n                {\\n                if(dll.last==n)\\n                dll.last=n.prev;\\n                n.prev.next=n.next;\\n                if(n.next!=null)\\n                n.next.prev=n.prev;\\n                n.prev=null;\\n                n.next=dll.first;\\n                \\n                dll.first.prev=n;\\n                dll.first=n;\\n                }\\n            }\\n                \\n             \\n        }\\n        \\n    }`",
                "solutionTags": [
                    "Java"
                ],
                "code": "    //Approach is to maintain a doubly link list  of key value pair (this will act as data structure for cache) and a Map which will store a reference to a node in the DLL corresponding to each key. \\n    //In get operation, we will check for the key in the Map. If it is there , get reference to the Node from the Map and extract its value  and place it at the start of the list.Otherwise, return -1\\n    // For put operation, we need to put the the new node at the start of the list. If the capacity of cache is already met, remove the last node from the list(and its corresponding entry from the map).\\n    //Take care of the edge cases where cache capacity is only 1.\\n    \\n    \\n    \\n    \\n    public class LRUCache {\\n        //Node to store the key-value pairs.\\n         class Node\\n            {\\n                int key;\\n                int value;\\n                Node next;\\n                Node prev;\\n                public Node(int x , int y, Node n , Node p)\\n                {\\n                    key=x;\\n                    value=y;\\n                    next=n;\\n                    prev=p;\\n                }\\n                \\n            }\\n            \\n        // Doubly link list of type Node.    \\n        class DoublyLL\\n        {\\n           \\n            Node first;\\n            Node last;\\n            int size;\\n            int count;\\n            public DoublyLL(int c)\\n            {\\n                size=c;\\n                count=0;\\n                first=null;\\n                last=null;\\n                \\n            }\\n        }\\n        HashMap<Integer,Node> map;      //The map will store a reference to the Node in DLL corresponding to each key.\\n        DoublyLL dll;\\n        public LRUCache(int capacity) {\\n            \\n           \\n          dll=new DoublyLL(capacity);\\n            \\n            map=new HashMap <Integer,Node> ();\\n            \\n           \\n            \\n        }\\n        \\n        public int get(int key) {\\n            \\n            if(map.containsKey(key))\\n            {\\n                Node n=map.get(key);\\n                if(n.prev!=null)\\n                {\\n                if(dll.last==n)\\n                dll.last=n.prev;\\n                n.prev.next=n.next;\\n                if(n.next!=null)\\n                n.next.prev=n.prev;\\n                n.prev=null;\\n                n.next=dll.first;\\n                \\n                dll.first.prev=n;\\n                dll.first=n;\\n                }\\n                \\n               \\n                \\n                return n.value;\\n            }\\n            else\\n            {\\n                return -1;\\n            }\\n        }\\n       \\n        \\n        public void set(int key, int value) {\\n             Node n;\\n          \\n             if(!map.containsKey(key))\\n            {\\n                n=new Node(key,value,null,null);\\n                if(dll.size!=dll.count)\\n                {\\n                         n.next=dll.first;\\n                        if(dll.count!=0)\\n                        {\\n                            dll.first.prev=n;\\n                        }\\n                        else\\n                        {\\n                            dll.last=n;\\n                            \\n                        }\\n                       \\n                        dll.first=n;\\n                        dll.count++; \\n                }\\n                else\\n                {\\n                \\n                    if(dll.count!=1)\\n                         {\\n                            map.remove(dll.last.key);\\n                            dll.last.prev.next=null;\\n                            dll.last=dll.last.prev;\\n                            dll.first.prev=n;\\n                            n.next=dll.first;\\n                            dll.first=n;\\n                             \\n                         }\\n                    else\\n                    {   map.remove(dll.first.key);\\n                        dll.first=n;\\n                        dll.last=n;\\n                    }\\n                \\n                }\\n                  map.put(key,n);\\n                 \\n            }\\n            else\\n            {\\n                n=map.get(key);\\n                n.value=value;\\n                if(n.prev!=null)\\n                {\\n                if(dll.last==n)\\n                dll.last=n.prev;\\n                n.prev.next=n.next;\\n                if(n.next!=null)\\n                n.next.prev=n.prev;\\n                n.prev=null;\\n                n.next=dll.first;\\n                \\n                dll.first.prev=n;\\n                dll.first=n;\\n                }\\n            }\\n                \\n             \\n        }\\n        \\n    }`",
                "codeTag": "Java"
            },
            {
                "id": 3785303,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Solution Video\\n\\nhttps://youtu.be/4Uh7nUGoeog\\n\\n# *** Please upvote and subscribe to my channel from here. I have 226 videos as of July 19th***\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other might be differnt a bit.\\n\\n1. Create a Node class with attributes key, val, prev, and next to represent individual nodes of a doubly linked list.\\n\\n2. Create the LRUCache class with a constructor that takes a capacity as input. Inside the constructor:\\n\\n   a. Initialize the capacity and an empty dictionary cache to store key-value pairs.\\n\\n   b. Create two sentinel nodes, oldest and latest, and set their key and value to 0. Connect the oldest node to the latest node and vice versa to form an empty doubly linked list.\\n\\n3. Implement the get method which takes a key as input and returns the corresponding value if the key exists in the cache:\\n\\n   a. Check if the key exists in the cache using the dictionary cache.\\n\\n   b. If the key is found, remove the corresponding node from the linked list using the remove method (to later move it to the front), and then insert it back at the front using the insert method (to indicate that it\\'s the most recently accessed node).\\n\\n   c. Finally, return the value associated with the key from the cache, or -1 if the key is not found.\\n\\n4. Implement the remove method which takes a node as input and removes it from the linked list:\\n\\n   a. Get the previous and next nodes of the input node.\\n\\n   b. Update the prev and next pointers of the previous and next nodes to exclude the input node.\\n\\n5. Implement the insert method which takes a node as input and inserts it at the front of the linked list:\\n\\n   a. Get the previous and next nodes of the latest node.\\n\\n   b. Connect the input node to the previous and next nodes appropriately.\\n\\n   c. Update the prev and next pointers of the previous and next nodes to include the input node.\\n\\n6. Implement the put method which takes a key and value as input and inserts or updates the key-value pair in the cache:\\n\\n   a. Check if the key exists in the cache using the dictionary cache.\\n\\n   b. If the key is found, remove the corresponding node from the linked list using the remove method.\\n\\n   c. Create a new node with the given key and value.\\n\\n   d. Add the new node to the cache.\\n\\n   e. Insert the new node at the front of the linked list using the insert method.\\n\\n   f. If the size of the cache exceeds the capacity, find the least recently used (LRU) node, which is the node next to the oldest node, and remove it from the linked list and cache.\\n\\n7. The LRUCache class is now implemented and can be used to store and access key-value pairs with a fixed capacity. When accessing a key-value pair, the most recently used pair is moved to the front, and if the cache exceeds its capacity, the least recently used pair is evicted.\\n\\n\\n```python []\\nclass Node:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.cache = {}\\n\\n        self.oldest = Node(0, 0)\\n        self.latest = Node(0, 0)\\n        self.oldest.next = self.latest\\n        self.latest.prev = self.oldest\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            self.remove(self.cache[key])\\n            self.insert(self.cache[key])\\n            return self.cache[key].val\\n        return -1\\n\\n    def remove(self, node):\\n        prev, next = node.prev, node.next\\n        prev.next = next\\n        next.prev = prev\\n    \\n    def insert(self, node):\\n        prev, next = self.latest.prev, self.latest\\n        prev.next = next.prev = node\\n        node.next = next\\n        node.prev = prev\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.cache:\\n            self.remove(self.cache[key])\\n        self.cache[key] = Node(key, value)\\n        self.insert(self.cache[key])\\n\\n        if len(self.cache) > self.cap:\\n            lru = self.oldest.next\\n            self.remove(lru)\\n            del self.cache[lru.key]\\n\\n```\\n```javascript []\\n/** \\n * https://leetcode.com/problems/lru-cache/\\n * Time O(1) | Space O(N)\\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n class LRUCache {\\n    constructor(capacity) {\\n        this.capacity = capacity;\\n        this.map = new Map();\\n\\n        this.head = {};\\n        this.tail = {};\\n\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n\\n    removeLastUsed () {\\n        const [ key, next, prev ]  = [ this.head.next.key, this.head.next.next, this.head ];\\n\\n        this.map.delete(key);\\n        this.head.next = next;\\n        this.head.next.prev = prev;\\n    }\\n\\n    put (key, value) {\\n        const hasKey = this.get(key) !== -1;\\n        const isAtCapacity = this.map.size === this.capacity;\\n        \\n        if (hasKey) return (this.tail.prev.value = value);\\n        if (isAtCapacity) this.removeLastUsed();\\n\\n        const node = { key, value };\\n        this.map.set(key, node);\\n        this.moveToFront(node);\\n    }\\n\\n    moveToFront (node) {\\n        const [ prev, next ] = [ this.tail.prev, this.tail ];\\n\\n        this.tail.prev.next = node;\\n        this.connectNode(node, { prev, next });\\n        this.tail.prev = node;\\n    }\\n\\n    connectNode (node, top) {\\n        node.prev = top.prev;\\n        node.next = top.next;\\n    }\\n\\n    get (key) {\\n        const hasKey = this.map.has(key);\\n        if (!hasKey) return -1;\\n\\n        const node = this.map.get(key);\\n        \\n        this.disconnectNode(node);\\n        this.moveToFront(node);\\n\\n        return node.value;\\n    }\\n\\n    disconnectNode (node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n}\\n```\\n```java []\\nclass Node {\\n    int key;\\n    int val;\\n    Node prev;\\n    Node next;\\n\\n    public Node(int key, int val) {\\n        this.key = key;\\n        this.val = val;\\n        this.prev = null;\\n        this.next = null;\\n    }\\n}\\n\\n\\nclass LRUCache {\\n\\n    private int cap;\\n    private Map<Integer, Node> cache;\\n    private Node oldest;\\n    private Node latest;\\n\\n    public LRUCache(int capacity) {\\n        this.cap = capacity;\\n        this.cache = new HashMap<>();\\n        this.oldest = new Node(0, 0);\\n        this.latest = new Node(0, 0);\\n        this.oldest.next = this.latest;\\n        this.latest.prev = this.oldest;\\n    }\\n\\n    public int get(int key) {\\n        if (cache.containsKey(key)) {\\n            Node node = cache.get(key);\\n            remove(node);\\n            insert(node);\\n            return node.val;\\n        }\\n        return -1;\\n    }\\n\\n    private void remove(Node node) {\\n        Node prev = node.prev;\\n        Node next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n\\n    private void insert(Node node) {\\n        Node prev = latest.prev;\\n        Node next = latest;\\n        prev.next = next.prev = node;\\n        node.next = next;\\n        node.prev = prev;\\n    }\\n\\n    public void put(int key, int value) {\\n        if (cache.containsKey(key)) {\\n            remove(cache.get(key));\\n        }\\n        Node newNode = new Node(key, value);\\n        cache.put(key, newNode);\\n        insert(newNode);\\n\\n        if (cache.size() > cap) {\\n            Node lru = oldest.next;\\n            remove(lru);\\n            cache.remove(lru.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```\\n```C++ []\\nclass Node {\\npublic:\\n    int key;\\n    int val;\\n    Node* prev;\\n    Node* next;\\n\\n    Node(int key, int val) : key(key), val(val), prev(nullptr), next(nullptr) {}\\n};\\n\\nclass LRUCache {\\npublic:\\nprivate:\\n    int cap;\\n    std::unordered_map<int, Node*> cache;\\n    Node* oldest;\\n    Node* latest;\\n\\npublic:\\n    LRUCache(int capacity) : cap(capacity) {\\n        oldest = new Node(0, 0);\\n        latest = new Node(0, 0);\\n        oldest->next = latest;\\n        latest->prev = oldest;\\n    }\\n\\n    int get(int key) {\\n        if (cache.find(key) != cache.end()) {\\n            Node* node = cache[key];\\n            remove(node);\\n            insert(node);\\n            return node->val;\\n        }\\n        return -1;\\n    }\\n\\nprivate:\\n    void remove(Node* node) {\\n        Node* prev = node->prev;\\n        Node* next = node->next;\\n        prev->next = next;\\n        next->prev = prev;\\n    }\\n\\n    void insert(Node* node) {\\n        Node* prev = latest->prev;\\n        Node* next = latest;\\n        prev->next = next->prev = node;\\n        node->next = next;\\n        node->prev = prev;\\n    }\\n\\npublic:\\n    void put(int key, int value) {\\n        if (cache.find(key) != cache.end()) {\\n            remove(cache[key]);\\n        }\\n        Node* newNode = new Node(key, value);\\n        cache[key] = newNode;\\n        insert(newNode);\\n\\n        if (cache.size() > cap) {\\n            Node* lru = oldest->next;\\n            remove(lru);\\n            cache.erase(lru->key);\\n            delete lru;\\n        }\\n    }\\n\\n    // Destructor to release memory used by the nodes\\n    ~LRUCache() {\\n        Node* curr = oldest;\\n        while (curr != nullptr) {\\n            Node* next = curr->next;\\n            delete curr;\\n            curr = next;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Node:\\n    def __init__(self, key, val):\\n        self.key = key\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cap = capacity\\n        self.cache = {}\\n\\n        self.oldest = Node(0, 0)\\n        self.latest = Node(0, 0)\\n        self.oldest.next = self.latest\\n        self.latest.prev = self.oldest\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            self.remove(self.cache[key])\\n            self.insert(self.cache[key])\\n            return self.cache[key].val\\n        return -1\\n\\n    def remove(self, node):\\n        prev, next = node.prev, node.next\\n        prev.next = next\\n        next.prev = prev\\n    \\n    def insert(self, node):\\n        prev, next = self.latest.prev, self.latest\\n        prev.next = next.prev = node\\n        node.next = next\\n        node.prev = prev\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.cache:\\n            self.remove(self.cache[key])\\n        self.cache[key] = Node(key, value)\\n        self.insert(self.cache[key])\\n\\n        if len(self.cache) > self.cap:\\n            lru = self.oldest.next\\n            self.remove(lru)\\n            del self.cache[lru.key]\\n\\n```\n```javascript []\\n/** \\n * https://leetcode.com/problems/lru-cache/\\n * Time O(1) | Space O(N)\\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n class LRUCache {\\n    constructor(capacity) {\\n        this.capacity = capacity;\\n        this.map = new Map();\\n\\n        this.head = {};\\n        this.tail = {};\\n\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n\\n    removeLastUsed () {\\n        const [ key, next, prev ]  = [ this.head.next.key, this.head.next.next, this.head ];\\n\\n        this.map.delete(key);\\n        this.head.next = next;\\n        this.head.next.prev = prev;\\n    }\\n\\n    put (key, value) {\\n        const hasKey = this.get(key) !== -1;\\n        const isAtCapacity = this.map.size === this.capacity;\\n        \\n        if (hasKey) return (this.tail.prev.value = value);\\n        if (isAtCapacity) this.removeLastUsed();\\n\\n        const node = { key, value };\\n        this.map.set(key, node);\\n        this.moveToFront(node);\\n    }\\n\\n    moveToFront (node) {\\n        const [ prev, next ] = [ this.tail.prev, this.tail ];\\n\\n        this.tail.prev.next = node;\\n        this.connectNode(node, { prev, next });\\n        this.tail.prev = node;\\n    }\\n\\n    connectNode (node, top) {\\n        node.prev = top.prev;\\n        node.next = top.next;\\n    }\\n\\n    get (key) {\\n        const hasKey = this.map.has(key);\\n        if (!hasKey) return -1;\\n\\n        const node = this.map.get(key);\\n        \\n        this.disconnectNode(node);\\n        this.moveToFront(node);\\n\\n        return node.value;\\n    }\\n\\n    disconnectNode (node) {\\n        node.next.prev = node.prev;\\n        node.prev.next = node.next;\\n    }\\n}\\n```\n```java []\\nclass Node {\\n    int key;\\n    int val;\\n    Node prev;\\n    Node next;\\n\\n    public Node(int key, int val) {\\n        this.key = key;\\n        this.val = val;\\n        this.prev = null;\\n        this.next = null;\\n    }\\n}\\n\\n\\nclass LRUCache {\\n\\n    private int cap;\\n    private Map<Integer, Node> cache;\\n    private Node oldest;\\n    private Node latest;\\n\\n    public LRUCache(int capacity) {\\n        this.cap = capacity;\\n        this.cache = new HashMap<>();\\n        this.oldest = new Node(0, 0);\\n        this.latest = new Node(0, 0);\\n        this.oldest.next = this.latest;\\n        this.latest.prev = this.oldest;\\n    }\\n\\n    public int get(int key) {\\n        if (cache.containsKey(key)) {\\n            Node node = cache.get(key);\\n            remove(node);\\n            insert(node);\\n            return node.val;\\n        }\\n        return -1;\\n    }\\n\\n    private void remove(Node node) {\\n        Node prev = node.prev;\\n        Node next = node.next;\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n\\n    private void insert(Node node) {\\n        Node prev = latest.prev;\\n        Node next = latest;\\n        prev.next = next.prev = node;\\n        node.next = next;\\n        node.prev = prev;\\n    }\\n\\n    public void put(int key, int value) {\\n        if (cache.containsKey(key)) {\\n            remove(cache.get(key));\\n        }\\n        Node newNode = new Node(key, value);\\n        cache.put(key, newNode);\\n        insert(newNode);\\n\\n        if (cache.size() > cap) {\\n            Node lru = oldest.next;\\n            remove(lru);\\n            cache.remove(lru.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```\n```C++ []\\nclass Node {\\npublic:\\n    int key;\\n    int val;\\n    Node* prev;\\n    Node* next;\\n\\n    Node(int key, int val) : key(key), val(val), prev(nullptr), next(nullptr) {}\\n};\\n\\nclass LRUCache {\\npublic:\\nprivate:\\n    int cap;\\n    std::unordered_map<int, Node*> cache;\\n    Node* oldest;\\n    Node* latest;\\n\\npublic:\\n    LRUCache(int capacity) : cap(capacity) {\\n        oldest = new Node(0, 0);\\n        latest = new Node(0, 0);\\n        oldest->next = latest;\\n        latest->prev = oldest;\\n    }\\n\\n    int get(int key) {\\n        if (cache.find(key) != cache.end()) {\\n            Node* node = cache[key];\\n            remove(node);\\n            insert(node);\\n            return node->val;\\n        }\\n        return -1;\\n    }\\n\\nprivate:\\n    void remove(Node* node) {\\n        Node* prev = node->prev;\\n        Node* next = node->next;\\n        prev->next = next;\\n        next->prev = prev;\\n    }\\n\\n    void insert(Node* node) {\\n        Node* prev = latest->prev;\\n        Node* next = latest;\\n        prev->next = next->prev = node;\\n        node->next = next;\\n        node->prev = prev;\\n    }\\n\\npublic:\\n    void put(int key, int value) {\\n        if (cache.find(key) != cache.end()) {\\n            remove(cache[key]);\\n        }\\n        Node* newNode = new Node(key, value);\\n        cache[key] = newNode;\\n        insert(newNode);\\n\\n        if (cache.size() > cap) {\\n            Node* lru = oldest->next;\\n            remove(lru);\\n            cache.erase(lru->key);\\n            delete lru;\\n        }\\n    }\\n\\n    // Destructor to release memory used by the nodes\\n    ~LRUCache() {\\n        Node* curr = oldest;\\n        while (curr != nullptr) {\\n            Node* next = curr->next;\\n            delete curr;\\n            curr = next;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781030,
                "title": "c-solution-for-lru-cache-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the LRUCache implementation is to use a combination of a dictionary and a linked list to efficiently store and manage the cache items. The dictionary provides fast access to cache items based on their keys, while the linked list maintains the order of recently used items.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves using a dictionary (cacheMap) to store the cache items, where the key is the item\\'s key and the value is a reference to the corresponding node in the linked list. The linked list (cacheList) keeps track of the order of the items, with the most recently used item at the front of the list.\\n\\nWhen performing a Get operation, the implementation checks if the key exists in the dictionary. If it does, the corresponding node is moved to the front of the linked list (representing the most recently used item) and its value is returned. If the key is not found, -1 is returned.\\n\\nWhen performing a Put operation, the implementation first checks if the key already exists in the cache. If it does, the corresponding node is updated with the new value, moved to the front of the linked list, and no additional space is used. If the key is not found, the implementation checks if the cache has reached its capacity. If it has, the least recently used item (at the end of the linked list) is removed from both the dictionary and the linked list. Then, a new node is created with the given key and value, added to the front of the linked list, and added to the dictionary for future access.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the Get and Put operations is O(1) on average since dictionary lookups, linked list operations (addition, removal), and updating the cache map all have constant time complexity. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(capacity) since the cache size is limited by the given capacity parameter, and both the dictionary and the linked list store the cache items.\\n\\n# Code\\n```\\npublic class LRUCache {\\n\\n    private readonly int capacity;\\n    private readonly Dictionary<int, LinkedListNode<CacheItem>> cacheMap;\\n    private readonly LinkedList<CacheItem> cacheList;\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        cacheMap = new Dictionary<int, LinkedListNode<CacheItem>>(capacity);\\n        cacheList = new LinkedList<CacheItem>();\\n    }\\n    \\n    public int Get(int key) {\\n        if (cacheMap.TryGetValue(key, out var node))\\n        {\\n            cacheList.Remove(node);\\n            cacheList.AddFirst(node);\\n            return node.Value.Value;\\n        }\\n        return -1;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if (cacheMap.TryGetValue(key, out var node))\\n        {\\n            node.Value.Value = value;\\n            cacheList.Remove(node);\\n            cacheList.AddFirst(node);\\n        }\\n        else\\n        {\\n            if (cacheMap.Count >= capacity)\\n            {\\n                var lastNode = cacheList.Last;\\n                cacheMap.Remove(lastNode.Value.Key);\\n                cacheList.RemoveLast();\\n            }\\n\\n            var newNode = new LinkedListNode<CacheItem>(new CacheItem(key, value));\\n            cacheMap.Add(key, newNode);\\n            cacheList.AddFirst(newNode);\\n        }\\n    }\\n\\n    private class CacheItem\\n    {\\n        public int Key { get; }\\n        public int Value { get; set; }\\n\\n        public CacheItem(int key, int value)\\n        {\\n            Key = key;\\n            Value = value;\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.Get(key);\\n * obj.Put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class LRUCache {\\n\\n    private readonly int capacity;\\n    private readonly Dictionary<int, LinkedListNode<CacheItem>> cacheMap;\\n    private readonly LinkedList<CacheItem> cacheList;\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        cacheMap = new Dictionary<int, LinkedListNode<CacheItem>>(capacity);\\n        cacheList = new LinkedList<CacheItem>();\\n    }\\n    \\n    public int Get(int key) {\\n        if (cacheMap.TryGetValue(key, out var node))\\n        {\\n            cacheList.Remove(node);\\n            cacheList.AddFirst(node);\\n            return node.Value.Value;\\n        }\\n        return -1;\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if (cacheMap.TryGetValue(key, out var node))\\n        {\\n            node.Value.Value = value;\\n            cacheList.Remove(node);\\n            cacheList.AddFirst(node);\\n        }\\n        else\\n        {\\n            if (cacheMap.Count >= capacity)\\n            {\\n                var lastNode = cacheList.Last;\\n                cacheMap.Remove(lastNode.Value.Key);\\n                cacheList.RemoveLast();\\n            }\\n\\n            var newNode = new LinkedListNode<CacheItem>(new CacheItem(key, value));\\n            cacheMap.Add(key, newNode);\\n            cacheList.AddFirst(newNode);\\n        }\\n    }\\n\\n    private class CacheItem\\n    {\\n        public int Key { get; }\\n        public int Value { get; set; }\\n\\n        public CacheItem(int key, int value)\\n        {\\n            Key = key;\\n            Value = value;\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.Get(key);\\n * obj.Put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279230,
                "title": "javascript-98-time-99-space",
                "content": "```\\nvar LRUCache = function(capacity) {\\n   this.cache = new Map();\\n   this.size = 0;\\n   this.capacity = capacity;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n  if (this.cache.has(key)){\\n    let val = this.cache.get(key);\\n    this.cache.delete(key);\\n    this.cache.set(key, val);\\n    return this.cache.get(key);\\n  }\\n  else return -1;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n  if (this.cache.has(key)){\\n    if (this.cache.size <= 1) this.cache.set(key, value)\\n    else {\\n      this.cache.delete(key)\\n      this.cache.set(key, value)\\n      return;\\n    }\\n  }\\n  \\n  if (this.size === this.capacity){\\n    const [firstKey] = this.cache.keys()\\n    this.cache.delete(firstKey)\\n    this.cache.set(key, value)\\n  } else{ \\n      this.cache.set(key, value)\\n      this.size++\\n  }\\n    \\n};\\n\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/7ab73c4c-d39d-4def-81d2-62410d89d99b_1657761175.3666575.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar LRUCache = function(capacity) {\\n   this.cache = new Map();\\n   this.size = 0;\\n   this.capacity = capacity;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n  if (this.cache.has(key)){\\n    let val = this.cache.get(key);\\n    this.cache.delete(key);\\n    this.cache.set(key, val);\\n    return this.cache.get(key);\\n  }\\n  else return -1;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n  if (this.cache.has(key)){\\n    if (this.cache.size <= 1) this.cache.set(key, value)\\n    else {\\n      this.cache.delete(key)\\n      this.cache.set(key, value)\\n      return;\\n    }\\n  }\\n  \\n  if (this.size === this.capacity){\\n    const [firstKey] = this.cache.keys()\\n    this.cache.delete(firstKey)\\n    this.cache.set(key, value)\\n  } else{ \\n      this.cache.set(key, value)\\n      this.size++\\n  }\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467995,
                "title": "short-sweet-and-simple-o-1-python-code-all-built-in-functions",
                "content": "```\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.cache = {} #As of Python 3.7, insertion order is maintained, so you don\\'t need an OrderedDict.\\n        self.count = 0 #Keeps track of how many elements are in the dict\\n        self.capacity = capacity #Keeps track of the max allowed elements in the dict\\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            value = self.cache.pop(key) #Removes... \\n            self.cache[key] = value #...and re-adds the dict item at the end since it is recently used\\n            return value\\n        else:\\n            return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.cache:\\n            self.count += 1 #Increases the count of the total elements if a new one is added\\n        else:\\n            self.cache.pop(key) #Removes... \\n        self.cache[key] = value #...and adds/re-adds the element at the end since it is recently used\\n        if self.count > self.capacity:\\n            self.cache.pop(next(iter(self.cache))) #Removes the first dict item\\n            self.count -= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.cache = {} #As of Python 3.7, insertion order is maintained, so you don\\'t need an OrderedDict.\\n        self.count = 0 #Keeps track of how many elements are in the dict\\n        self.capacity = capacity #Keeps track of the max allowed elements in the dict\\n\\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            value = self.cache.pop(key) #Removes... \\n            self.cache[key] = value #...and re-adds the dict item at the end since it is recently used\\n            return value\\n        else:\\n            return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.cache:\\n            self.count += 1 #Increases the count of the total elements if a new one is added\\n        else:\\n            self.cache.pop(key) #Removes... \\n        self.cache[key] = value #...and adds/re-adds the element at the end since it is recently used\\n        if self.count > self.capacity:\\n            self.cache.pop(next(iter(self.cache))) #Removes the first dict item\\n            self.count -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966267,
                "title": "easy-js-solution-using-map-put-and-get-o-1",
                "content": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.max = capacity;\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if (this.map.has(key)) {\\n        const tmp = this.map.get(key);\\n        this.map.delete(key);\\n        this.map.set(key, tmp);\\n        \\n        return tmp;\\n    }\\n    \\n    return -1;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if (this.map.has(key)) {\\n        this.map.delete(key);\\n    } else if (this.map.size === this.max) {\\n        this.map.delete(this.map.keys().next().value);\\n    }\\n    \\n    this.map.set(key, value);\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n    this.max = capacity;\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    if (this.map.has(key)) {\\n        const tmp = this.map.get(key);\\n        this.map.delete(key);\\n        this.map.set(key, tmp);\\n        \\n        return tmp;\\n    }\\n    \\n    return -1;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n    if (this.map.has(key)) {\\n        this.map.delete(key);\\n    } else if (this.map.size === this.max) {\\n        this.map.delete(this.map.keys().next().value);\\n    }\\n    \\n    this.map.set(key, value);\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798590,
                "title": "java-2-solutions",
                "content": "Using HashMap and doubly linked list\\n```\\nclass LRUCache {\\n    class Node {\\n        int key;\\n        int value;\\n        Node left;\\n        Node right;\\n        Node(int k, int v) {\\n            this.key = k;\\n            this.value = v;\\n            left = right = null;\\n        }\\n    }\\n    Map<Integer, Node> map;\\n    int capacity;\\n    Node front;\\n    Node rear;\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        map = new HashMap<>();\\n        front = rear = null;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key))\\n            return -1;\\n        Node curr = map.get(key);\\n        remove(curr);\\n        addFirst(curr);\\n        return curr.value;\\n    }\\n    \\n    \\n    public void addFirst(Node curr) {\\n        if(front == null) {\\n            front = rear = curr;\\n            return;\\n        }\\n        front.left = curr;\\n        curr.right = front;\\n        front = curr;\\n    }\\n    \\n    public void remove(Node curr) {\\n        if(front == curr && rear == curr) {\\n            front = rear = null;\\n            return;\\n        }\\n        if(front == curr) {\\n            front = front.right;\\n            front.left = null;\\n            return;\\n        }\\n        if(rear == curr) {\\n            rear = rear.left;\\n            rear.right = null;\\n            return;\\n        }\\n        Node prev = curr.left;\\n        Node next = curr.right;\\n        prev.right = next;\\n        next.left = prev;\\n    }\\n    \\n    public Node removeLast() {\\n        if(front == rear) {\\n            Node temp = front;\\n            front = rear = null;\\n            return temp;\\n        }\\n        Node temp = rear;\\n        rear = rear.left;\\n        rear.right = null;\\n        return temp;\\n    }\\n    \\n    public void put(int key, int value) {\\n        Node curr = map.containsKey(key)?map.get(key):null;\\n        if(curr == null) {\\n            curr = new Node(key, value);\\n            addFirst(curr);\\n            map.put(key,curr);\\n        }\\n        else {\\n            curr.value = value;\\n            remove(curr);\\n            addFirst(curr);\\n        }\\n        if(map.size() > capacity) {\\n            curr = removeLast();\\n            map.remove(curr.key);\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```\\n\\nUsing HashMap and Deque\\n```\\nclass LRUCache {\\n    class Node{\\n        int key;\\n        int value;\\n        Node(int k, int v) {\\n            this.key = k;\\n            this.value = v;\\n        }\\n    }\\n    Map<Integer, Node> map;\\n    Deque<Node> dq;\\n    int capacity;\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        map = new HashMap<>();\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key))\\n            return -1;\\n        dq.remove(map.get(key));\\n        dq.addFirst(map.get(key));\\n        return map.get(key).value;\\n    }\\n    \\n    public void put(int key, int value) {\\n        Node curr = map.containsKey(key)?map.get(key):null;\\n        if(curr == null) {\\n            curr = new Node(key, value);\\n            dq.addFirst(curr);\\n            map.put(key, curr);\\n        }\\n        else {\\n            curr.value = value;\\n            dq.remove(curr);\\n            dq.addFirst(curr);\\n        }\\n        if(map.size() > capacity) {\\n            curr = dq.removeLast();\\n            map.remove(curr.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LRUCache {\\n    class Node {\\n        int key;\\n        int value;\\n        Node left;\\n        Node right;\\n        Node(int k, int v) {\\n            this.key = k;\\n            this.value = v;\\n            left = right = null;\\n        }\\n    }\\n    Map<Integer, Node> map;\\n    int capacity;\\n    Node front;\\n    Node rear;\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        map = new HashMap<>();\\n        front = rear = null;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key))\\n            return -1;\\n        Node curr = map.get(key);\\n        remove(curr);\\n        addFirst(curr);\\n        return curr.value;\\n    }\\n    \\n    \\n    public void addFirst(Node curr) {\\n        if(front == null) {\\n            front = rear = curr;\\n            return;\\n        }\\n        front.left = curr;\\n        curr.right = front;\\n        front = curr;\\n    }\\n    \\n    public void remove(Node curr) {\\n        if(front == curr && rear == curr) {\\n            front = rear = null;\\n            return;\\n        }\\n        if(front == curr) {\\n            front = front.right;\\n            front.left = null;\\n            return;\\n        }\\n        if(rear == curr) {\\n            rear = rear.left;\\n            rear.right = null;\\n            return;\\n        }\\n        Node prev = curr.left;\\n        Node next = curr.right;\\n        prev.right = next;\\n        next.left = prev;\\n    }\\n    \\n    public Node removeLast() {\\n        if(front == rear) {\\n            Node temp = front;\\n            front = rear = null;\\n            return temp;\\n        }\\n        Node temp = rear;\\n        rear = rear.left;\\n        rear.right = null;\\n        return temp;\\n    }\\n    \\n    public void put(int key, int value) {\\n        Node curr = map.containsKey(key)?map.get(key):null;\\n        if(curr == null) {\\n            curr = new Node(key, value);\\n            addFirst(curr);\\n            map.put(key,curr);\\n        }\\n        else {\\n            curr.value = value;\\n            remove(curr);\\n            addFirst(curr);\\n        }\\n        if(map.size() > capacity) {\\n            curr = removeLast();\\n            map.remove(curr.key);\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```\n```\\nclass LRUCache {\\n    class Node{\\n        int key;\\n        int value;\\n        Node(int k, int v) {\\n            this.key = k;\\n            this.value = v;\\n        }\\n    }\\n    Map<Integer, Node> map;\\n    Deque<Node> dq;\\n    int capacity;\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        map = new HashMap<>();\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key))\\n            return -1;\\n        dq.remove(map.get(key));\\n        dq.addFirst(map.get(key));\\n        return map.get(key).value;\\n    }\\n    \\n    public void put(int key, int value) {\\n        Node curr = map.containsKey(key)?map.get(key):null;\\n        if(curr == null) {\\n            curr = new Node(key, value);\\n            dq.addFirst(curr);\\n            map.put(key, curr);\\n        }\\n        else {\\n            curr.value = value;\\n            dq.remove(curr);\\n            dq.addFirst(curr);\\n        }\\n        if(map.size() > capacity) {\\n            curr = dq.removeLast();\\n            map.remove(curr.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527709,
                "title": "cpp-code-following-the-official-solution",
                "content": "```\\nclass Node{\\npublic:\\n    Node *next,*previous;\\n    int key,value;\\n    \\n    Node(){\\n        next=previous=nullptr;\\n        key=value= -1;\\n    }\\n    \\n    Node(int key,int value){\\n        this->key= key;\\n        this->value = value;\\n        next=previous=nullptr;\\n    }\\n};\\n\\n\\n\\nclass LRUCache {\\nprivate:\\n    Node *head,*tail;\\n    int maxCapacity,currentCapacity;\\n    unordered_map<int,Node*> uMap;\\n    \\npublic:\\n    LRUCache(int capacity) {\\n        maxCapacity = capacity;\\n        currentCapacity = 0;\\n        head = new Node();\\n        tail = new Node();\\n        \\n        head->previous = tail;\\n        tail->next = head;\\n    }\\n    \\n    int get(int key) {\\n        if(uMap.find(key)==uMap.end())\\n            return -1;\\n        Node *node = uMap[key];\\n        int value = node->value;\\n        \\n        uMap.erase(key);\\n        eraseNode(node);\\n        addNode(key,value);\\n        \\n        return value;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(uMap.find(key)!=uMap.end()){\\n            currentCapacity--;\\n            Node *currentNode = uMap[key];\\n            uMap.erase(key);\\n            eraseNode(currentNode);\\n        }\\n        if(currentCapacity==maxCapacity){\\n            uMap.erase(tail->next->key);\\n            eraseNode(tail->next);\\n            currentCapacity--;\\n        }\\n        addNode(key,value);\\n        currentCapacity++;\\n    }\\n    \\n    void eraseNode(Node *node){\\n        node->previous->next = node->next;\\n        node->next->previous = node->previous;\\n        delete node;\\n    }\\n    \\n    void addNode(int key,int value){\\n        Node *node = new Node(key,value);\\n        node->next = head;\\n        node->previous = head->previous;\\n        head->previous->next = node;\\n        head->previous = node;\\n        uMap[key]=node;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n ```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    Node *next,*previous;\\n    int key,value;\\n    \\n    Node(){\\n        next=previous=nullptr;\\n        key=value= -1;\\n    }\\n    \\n    Node(int key,int value){\\n        this->key= key;\\n        this->value = value;\\n        next=previous=nullptr;\\n    }\\n};\\n\\n\\n\\nclass LRUCache {\\nprivate:\\n    Node *head,*tail;\\n    int maxCapacity,currentCapacity;\\n    unordered_map<int,Node*> uMap;\\n    \\npublic:\\n    LRUCache(int capacity) {\\n        maxCapacity = capacity;\\n        currentCapacity = 0;\\n        head = new Node();\\n        tail = new Node();\\n        \\n        head->previous = tail;\\n        tail->next = head;\\n    }\\n    \\n    int get(int key) {\\n        if(uMap.find(key)==uMap.end())\\n            return -1;\\n        Node *node = uMap[key];\\n        int value = node->value;\\n        \\n        uMap.erase(key);\\n        eraseNode(node);\\n        addNode(key,value);\\n        \\n        return value;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(uMap.find(key)!=uMap.end()){\\n            currentCapacity--;\\n            Node *currentNode = uMap[key];\\n            uMap.erase(key);\\n            eraseNode(currentNode);\\n        }\\n        if(currentCapacity==maxCapacity){\\n            uMap.erase(tail->next->key);\\n            eraseNode(tail->next);\\n            currentCapacity--;\\n        }\\n        addNode(key,value);\\n        currentCapacity++;\\n    }\\n    \\n    void eraseNode(Node *node){\\n        node->previous->next = node->next;\\n        node->next->previous = node->previous;\\n        delete node;\\n    }\\n    \\n    void addNode(int key,int value){\\n        Node *node = new Node(key,value);\\n        node->next = head;\\n        node->previous = head->previous;\\n        head->previous->next = node;\\n        head->previous = node;\\n        uMap[key]=node;\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 442751,
                "title": "python3-hashmap-doubly-linked-list",
                "content": "Algo\\nLRU (least recently used) cache is an important data structure that has wide application in practice. In the first implementation, I build it up from scratch using hash table and doubly-linked list. \\n\\n```\\nclass ListNode:\\n    def __init__(self, key=0, val=0, prev=None, next=None):\\n        self.key = key\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n        \\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        \"\"\"Initialize hash table & dll\"\"\"\\n        self.cpty = capacity\\n        self.htab = dict() #hash table \\n        self.head = ListNode() #doubly linked list\\n        self.tail = ListNode()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head \\n        \\n    def _del(self, key: int) -> int: \\n        \"\"\"Delete given key from hash table & dll\"\"\"\\n        node = self.htab.pop(key)\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        return node.val\\n\\n    def _ins(self, key: int, value: int) -> None: \\n        \"\"\"Insert at tail\"\"\"\\n        node = ListNode(key, value, self.tail.prev, self.tail)\\n        self.tail.prev.next = self.tail.prev = node\\n        self.htab[key] = node\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.htab: return -1\\n        value = self._del(key)\\n        self._ins(key, value)\\n        return value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.htab: self._del(key)\\n        self._ins(key, value)\\n        if len(self.htab) > self.cpty: \\n            self._del(self.head.next.key)\\n\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```\\n\\nIn Python 3.6+, dicitonary is ordered. Essentially, it is to a large extent the LRU cache that we want. So the below implementation leverages on this fact and achieves this functionality. \\n\\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cpty = capacity\\n        self.data = dict()\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.data: return -1\\n        value = self.data.pop(key)\\n        self.data[key] = value\\n        return value        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.data: self.data.pop(key)\\n        self.data[key] = value\\n        if len(self.data) > self.cpty: \\n            self.data.pop(next(iter(self.data.keys())))\\n\\n```\\n\\nIn addition, `OrderedDict` is better aligned with LRU cache (e.g. below)\\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cpty = capacity\\n        self.data = OrderedDict()\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.data: return -1\\n        self.data.move_to_end(key)\\n        return self.data[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.data: self.data.pop(key)\\n        self.data[key] = value\\n        if len(self.data) > self.cpty: \\n            self.data.popitem(last=False)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, key=0, val=0, prev=None, next=None):\\n        self.key = key\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n        \\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        \"\"\"Initialize hash table & dll\"\"\"\\n        self.cpty = capacity\\n        self.htab = dict() #hash table \\n        self.head = ListNode() #doubly linked list\\n        self.tail = ListNode()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head \\n        \\n    def _del(self, key: int) -> int: \\n        \"\"\"Delete given key from hash table & dll\"\"\"\\n        node = self.htab.pop(key)\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n        return node.val\\n\\n    def _ins(self, key: int, value: int) -> None: \\n        \"\"\"Insert at tail\"\"\"\\n        node = ListNode(key, value, self.tail.prev, self.tail)\\n        self.tail.prev.next = self.tail.prev = node\\n        self.htab[key] = node\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.htab: return -1\\n        value = self._del(key)\\n        self._ins(key, value)\\n        return value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.htab: self._del(key)\\n        self._ins(key, value)\\n        if len(self.htab) > self.cpty: \\n            self._del(self.head.next.key)\\n\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cpty = capacity\\n        self.data = dict()\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.data: return -1\\n        value = self.data.pop(key)\\n        self.data[key] = value\\n        return value        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.data: self.data.pop(key)\\n        self.data[key] = value\\n        if len(self.data) > self.cpty: \\n            self.data.pop(next(iter(self.data.keys())))\\n\\n```\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cpty = capacity\\n        self.data = OrderedDict()\\n        \\n    def get(self, key: int) -> int:\\n        if key not in self.data: return -1\\n        self.data.move_to_end(key)\\n        return self.data[key]\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.data: self.data.pop(key)\\n        self.data[key] = value\\n        if len(self.data) > self.cpty: \\n            self.data.popitem(last=False)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46045,
                "title": "js-implementation-with-very-detailed-explanation-easy-to-understand",
                "content": "First, the LRU(least recently used) means we need some data structure to record the order of the last used time of each node. An intuitive solution is a Queue. Because <code>First-In-First-Out</code> is exactly the LRU concept.  And a Queue can be implemented using linkedlist.  \\n  \\nSecond, after we <code>GET</code> a node from cache, we need to move that node to the head of queue, meaning it is most recently used. To achieve it in <code>O(1)</code> time, we need a hashmap to record a key-(node) info for each node. After we identify that node, we just cut it from the queue and attach it to the head. \\n  \\nThird, how about <code>SET</code>? First we try to locate a node with the <code>KEY</code>, if we found a node, we just change the value of that node and move the node to head(means it is most recently used). If we cannot find a node, we will create a new node with (key,val) and attach it to the head. If the size of cache exceeds the capacity, we need to <code>REMOVE</code> the <code>LAST</code> node(last recently used).\\n  \\nIn sumary, we basically need 3 operations  \\n- attachToHead: attach an isolated node to head\\n- moveToHead: move an existing node in the linkedlist to head\\n- removeLast: remove the last node in the linkedlist\\n\\nAs you can see, to access head and tail in O(1) time, doubly linkedlist is a good choice.\\n\\n\\n#### <code>Node</code>\\nprev<=>(key,value)<=>next\\n#### <code> Doubly LinkedList</code>\\n(head)<=>(node1)<=>(node2)<=>...<=>(nodex)<=>(tail)  \\nmost recently used >>>>>>>>>>>>>> least recently used\\n#### <code>HashMap</code>\\n[key1]=>(node1)  \\n[key2]=>(node2)  \\n...\\n\\n```\\n/**\\n * @constructor\\n */\\nvar ListNode = function(key,val){\\n    this.prev = null;\\n    this.next = null;\\n    this.val = val;\\n    this.key = key;\\n}\\nvar LRUCache = function(capacity) {\\n    this.head = new ListNode(-1,-1);\\n    this.tail = new ListNode(-1,-1);\\n    this.head.next = this.tail;\\n    this.tail.prev = this.head;\\n    this.size = 0;\\n    this.capacity = capacity;\\n    this.map = new Map();\\n};\\n\\n/**\\n * @param {number} key\\n * @returns {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    let node = this.map.get(key);\\n    if(node){\\n        this.moveToHead(node);\\n        return node.val;\\n    }else{\\n        return -1;\\n    }\\n};\\n\\n/**\\n * @param {number} key\\n * @param {number} value\\n * @returns {void}\\n */\\nLRUCache.prototype.set = function(key, value) {\\n    let node = this.map.get(key);\\n    if(!node){\\n        node = new ListNode(key,value);\\n        this.attachToHead(node);\\n        this.size++;\\n    }else{\\n        node.val = value;\\n        this.moveToHead(node);\\n    }\\n    if(this.size > this.capacity){\\n        this.removeLast();\\n        this.size--;\\n    }\\n    this.map.set(key,node);\\n};\\n\\nLRUCache.prototype.attachToHead = function(node){\\n    node.next = this.head.next;\\n    node.next.prev = node;\\n    this.head.next = node;\\n    node.prev = this.head;\\n}\\n\\nLRUCache.prototype.moveToHead = function(node){\\n    node.prev.next = node.next;\\n    node.next.prev = node.prev;\\n    this.attachToHead(node);\\n}\\n\\nLRUCache.prototype.removeLast = function(){\\n    let last = this.tail.prev;\\n    last.prev.next = this.tail;\\n    this.tail.prev = last.prev;\\n    this.map.delete(last.key);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @constructor\\n */\\nvar ListNode = function(key,val){\\n    this.prev = null;\\n    this.next = null;\\n    this.val = val;\\n    this.key = key;\\n}\\nvar LRUCache = function(capacity) {\\n    this.head = new ListNode(-1,-1);\\n    this.tail = new ListNode(-1,-1);\\n    this.head.next = this.tail;\\n    this.tail.prev = this.head;\\n    this.size = 0;\\n    this.capacity = capacity;\\n    this.map = new Map();\\n};\\n\\n/**\\n * @param {number} key\\n * @returns {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n    let node = this.map.get(key);\\n    if(node){\\n        this.moveToHead(node);\\n        return node.val;\\n    }else{\\n        return -1;\\n    }\\n};\\n\\n/**\\n * @param {number} key\\n * @param {number} value\\n * @returns {void}\\n */\\nLRUCache.prototype.set = function(key, value) {\\n    let node = this.map.get(key);\\n    if(!node){\\n        node = new ListNode(key,value);\\n        this.attachToHead(node);\\n        this.size++;\\n    }else{\\n        node.val = value;\\n        this.moveToHead(node);\\n    }\\n    if(this.size > this.capacity){\\n        this.removeLast();\\n        this.size--;\\n    }\\n    this.map.set(key,node);\\n};\\n\\nLRUCache.prototype.attachToHead = function(node){\\n    node.next = this.head.next;\\n    node.next.prev = node;\\n    this.head.next = node;\\n    node.prev = this.head;\\n}\\n\\nLRUCache.prototype.moveToHead = function(node){\\n    node.prev.next = node.next;\\n    node.next.prev = node.prev;\\n    this.attachToHead(node);\\n}\\n\\nLRUCache.prototype.removeLast = function(){\\n    let last = this.tail.prev;\\n    last.prev.next = this.tail;\\n    this.tail.prev = last.prev;\\n    this.map.delete(last.key);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46133,
                "title": "146-lru-cache-cpp-solution",
                "content": "    //146. LRU Cache\\n    //https://leetcode.com/problems/lru-cache/\\n    //https://github.com/soulmachine/leetcode\\n    #include <iostream>\\n    #include <list>\\n    #include <unordered_map>\\n    using namespace std;\\n    class LRUCache {\\n    public:\\n    \\tLRUCache(const int& c): capacity(c) {}\\n    \\n    \\tint get(const int& key) {\\n    \\t\\tint result(-1);\\n    \\t\\tif (this->CacheHashMap.count(key)) {\\n    \\t\\t\\tresult = this->CacheHashMap[key]->value;\\n    \\t\\t\\tthis->CacheList.splice(this->CacheList.begin(), this->CacheList, this->CacheHashMap[key]);\\n    \\t\\t\\tthis->CacheHashMap[key] = this->CacheList.begin();\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}\\n    \\n    \\tvoid set(const int& key, const int& value) {\\n    \\t\\tif (this->CacheHashMap.count(key)) {\\n    \\t\\t\\tthis->CacheHashMap[key]->value = value;\\n    \\t\\t\\tthis->CacheList.splice(this->CacheList.begin(), this->CacheList, this->CacheHashMap[key]);\\n    \\t\\t\\tthis->CacheHashMap[key] = this->CacheList.begin();\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tif (this->CacheList.size() >= this->capacity) {\\n    \\t\\t\\t\\tthis->CacheHashMap.erase(this->CacheList.back().key);\\n    \\t\\t\\t\\tthis->CacheList.pop_back();\\n    \\t\\t\\t}\\n    \\t\\t\\tthis->CacheList.push_front(CacheNode(key, value));\\n    \\t\\t\\tthis->CacheHashMap[key] = this->CacheList.begin();\\n    \\t\\t}\\n    \\t}\\n    private:\\n    \\tstruct CacheNode {\\n    \\t\\tint key;\\n    \\t\\tint value;\\n    \\t\\tCacheNode(const int& k, const int& v): key(k), value(v) {}\\n    \\t};\\n    \\tlist<CacheNode> CacheList;\\n    \\tunordered_map<int, list<CacheNode>::iterator> CacheHashMap;\\n    \\tint capacity;\\n    };\\n    int main(int argc, char** argv) {\\n    \\tLRUCache lrucache(10);\\n    \\treturn 0;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    //146. LRU Cache\\n    //https://leetcode.com/problems/lru-cache/\\n    //https://github.com/soulmachine/leetcode\\n    #include <iostream>\\n    #include <list>\\n    #include <unordered_map>\\n    using namespace std;\\n    class LRUCache {\\n    public:\\n    \\tLRUCache(const int& c): capacity(c) {}\\n    \\n    \\tint get(const int& key) {\\n    \\t\\tint result(-1);\\n    \\t\\tif (this->CacheHashMap.count(key)) {\\n    \\t\\t\\tresult = this->CacheHashMap[key]->value;\\n    \\t\\t\\tthis->CacheList.splice(this->CacheList.begin(), this->CacheList, this->CacheHashMap[key]);\\n    \\t\\t\\tthis->CacheHashMap[key] = this->CacheList.begin();\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}\\n    \\n    \\tvoid set(const int& key, const int& value) {\\n    \\t\\tif (this->CacheHashMap.count(key)) {\\n    \\t\\t\\tthis->CacheHashMap[key]->value = value;\\n    \\t\\t\\tthis->CacheList.splice(this->CacheList.begin(), this->CacheList, this->CacheHashMap[key]);\\n    \\t\\t\\tthis->CacheHashMap[key] = this->CacheList.begin();\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tif (this->CacheList.size() >= this->capacity) {\\n    \\t\\t\\t\\tthis->CacheHashMap.erase(this->CacheList.back().key);\\n    \\t\\t\\t\\tthis->CacheList.pop_back();\\n    \\t\\t\\t}\\n    \\t\\t\\tthis->CacheList.push_front(CacheNode(key, value));\\n    \\t\\t\\tthis->CacheHashMap[key] = this->CacheList.begin();\\n    \\t\\t}\\n    \\t}\\n    private:\\n    \\tstruct CacheNode {\\n    \\t\\tint key;\\n    \\t\\tint value;\\n    \\t\\tCacheNode(const int& k, const int& v): key(k), value(v) {}\\n    \\t};\\n    \\tlist<CacheNode> CacheList;\\n    \\tunordered_map<int, list<CacheNode>::iterator> CacheHashMap;\\n    \\tint capacity;\\n    };\\n    int main(int argc, char** argv) {\\n    \\tLRUCache lrucache(10);\\n    \\treturn 0;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 46166,
                "title": "28ms-solution-in-c-with-clear-comments",
                "content": "the algorithm uses hash table and double-linked list\\nthe hash table uses separate chain to solve the collision\\n\\n\\n    #include<stdio.h>\\n    #include<stdlib.h>\\n\\n    //2887 is a prime number, it is chosen to be the size of the hash table\\n    const int HASH_SIZE = 2887;\\n\\n    //double-linked list\\n    struct MyListNode\\n    {\\n    \\tint key;\\n        int value;\\n        struct MyListNode * next;\\n        struct MyListNode * prev;\\n    };\\n    typedef struct MyListNode MyListNode;\\n\\n    //the element of hash table, the hash table uses separate-chain to solve the collision\\n    struct HashElement\\n    {\\n\\t    MyListNode * node;\\n\\t    struct HashElement * next;\\n    };\\n    typedef struct HashElement HashElement;\\n\\n    //the head of double-linked list\\n    MyListNode my_head;\\n    //pointer to the head\\n    MyListNode * head;\\n    //total capacity of the LRU Cache\\n    int my_capacity;\\n    //current size of the LRU Cache\\n    int current_capacity;\\n    //memory pool for list node\\n    MyListNode * mem_pool;\\n    //hash table\\n    HashElement * hash_table;\\n\\n    //allocate list node from memory pool\\n    MyListNode * Alloc() { return &mem_pool[current_capacity++]; }\\n\\n    //insert an element into hash table\\n    void hash_insert(MyListNode * my_node)\\n    {\\n\\t    int pos = my_node->key % HASH_SIZE;\\n\\t    HashElement * p;\\n\\t    for (p = hash_table[pos].next; p; p = p->next)\\n\\t    {\\n\\t\\t    if (p->node == my_node) return;\\n\\t    }\\n\\t    p = (HashElement *)malloc(sizeof(*p));\\n\\t    p->node = my_node;\\n\\t    p->next = hash_table[pos].next;\\n\\t    hash_table[pos].next = p;\\n    }\\n\\n    //find a key in the hash table, if the key matches, return the list node, else return NULL\\n    MyListNode * hash_find(int key)\\n    {\\n\\t    int pos = key % HASH_SIZE;\\n\\t    HashElement * p;\\n\\t    for (p = hash_table[pos].next; p; p = p->next)\\n\\t    {\\n\\t\\t    if (p->node->key == key) break;\\n\\t    }\\n\\t    return p ? p->node : NULL;\\n    }\\n\\n    //delete a element from the hash table\\n    void hash_delete(int key)\\n    {\\n\\t    int pos = key % HASH_SIZE;\\n\\t    HashElement * p;\\n\\t    HashElement * q;\\n\\t    for (q = &hash_table[pos], p = hash_table[pos].next; p; q = p, p = p->next)\\n\\t    {\\n\\t\\t    if (p->node->key == key)\\n\\t\\t    {\\n\\t\\t\\t    q->next = p->next;\\n\\t\\t\\t    free(p);\\n\\t\\t    }\\n\\t    }\\n    }\\n\\n\\n    void lruCacheInit(int capacity)\\n    {\\n\\t    //initialization of the double-linked list\\n\\t    head = &my_head;\\n\\t    head->key = 0;\\n\\t    head->value = 0;\\n\\t    head->next = head;\\n\\t    head->prev = head;\\n\\t    my_capacity = capacity;\\n\\t    current_capacity = 0;\\n\\t    //allocate memory for the memory pool and hash table\\n\\t    mem_pool = (MyListNode *)malloc(sizeof(*mem_pool) * capacity);\\n\\t    hash_table = (HashElement *)calloc(HASH_SIZE, sizeof(*hash_table));\\n    }\\n\\n    void lruCacheFree()\\n    {\\n\\t    int i;\\n\\t    //free the memory pool\\n\\t    free(mem_pool);\\n\\t    //free each bucket of the hash table, and the separate-chain list nodes of these buckets. \\n\\t    for (i = 0; i < HASH_SIZE; ++i)\\n\\t    {\\n\\t\\t    HashElement * p;\\n\\t\\t    HashElement * q;\\n\\t\\t    for (q = &hash_table[i], p = hash_table[i].next; p;)\\n\\t\\t    {\\n\\t\\t    \\tq = p;\\n\\t\\t\\t    p = p->next;\\n\\t\\t\\t    free(q);\\n\\t\\t    }\\n\\t    }\\n\\t    //free the hash table\\n\\t    free(hash_table);\\n    }\\n\\n    int lruCacheGet(int key)\\n    {\\n\\t    MyListNode * p;\\n\\n\\t    p = hash_find(key);\\n\\t    //if find the key successfully, move the list node to the head of the list\\n\\t    if (p)\\n\\t    {\\n\\t\\t    p->prev->next = p->next;\\n\\t\\t    p->next->prev = p->prev;\\n\\t\\t    p->prev = head;\\n\\t\\t    p->next = head->next;\\n\\t\\t    p->prev->next = p;\\n\\t\\t    p->next->prev = p;\\n\\t    }\\n\\t    return p ? p->value : -1;\\n    }\\n\\n    void lruCacheSet(int key, int value)\\n    {\\n\\t    MyListNode * p;\\n\\n\\t    p = hash_find(key);\\n\\t    //if find the key successfully, modify its value, and move the list node to the head of the list\\n\\t    if (p)\\n\\t    {\\n\\t\\t    p->value = value;\\n\\t\\t    p->prev->next = p->next;\\n\\t\\t    p->next->prev = p->prev;\\n\\t\\t    p->prev = head;\\n\\t\\t    p->next = head->next;\\n\\t\\t    p->prev->next = p;\\n\\t\\t    p->next->prev = p;\\n\\t    }\\n\\t    //otherwise, try to allocate memory for the new key-value set, or try to vacate a key-value set for the new one\\n\\t    else\\n\\t    {\\n\\t\\t    //when LRU Cache is not full, try to allocate memory for the new key-value set\\n\\t\\t    if (current_capacity < my_capacity)\\n\\t\\t    {\\n\\t\\t\\t    p = (MyListNode *)Alloc(sizeof(*p));\\n\\t\\t\\t    p->key = key;\\n\\t\\t\\t    p->value = value;\\n\\t\\t\\t    p->prev = head;\\n\\t\\t\\t    p->next = head->next;\\n\\t\\t\\t    p->prev->next = p;\\n\\t\\t\\t    p->next->prev = p;\\n\\t\\t\\t    hash_insert(p);\\n\\t\\t    }\\n\\t\\t        //otherwise, try to vacate one\\n\\t\\t    else\\n\\t\\t    {\\n\\t\\t\\t    p = head->prev;\\n\\t\\t\\t    hash_delete(p->key);\\n\\t\\t\\t    p->key = key;\\n\\t\\t\\t    p->value = value;\\n\\t\\t\\t    p->prev->next = p->next;\\n\\t\\t\\t    p->next->prev = p->prev;\\n\\t\\t\\t    p->prev = head;\\n\\t\\t\\t    p->next = head->next;\\n\\t\\t\\t    p->prev->next = p;\\n\\t\\t\\t    p->next->prev = p;\\n\\t\\t\\t    hash_insert(p);\\n\\t\\t    }\\n\\t    }\\n    }",
                "solutionTags": [
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "the algorithm uses hash table and double-linked list\\nthe hash table uses separate chain to solve the collision\\n\\n\\n    #include<stdio.h>\\n    #include<stdlib.h>\\n\\n    //2887 is a prime number, it is chosen to be the size of the hash table\\n    const int HASH_SIZE = 2887;\\n\\n    //double-linked list\\n    struct MyListNode\\n    {\\n    \\tint key;\\n        int value;\\n        struct MyListNode * next;\\n        struct MyListNode * prev;\\n    };\\n    typedef struct MyListNode MyListNode;\\n\\n    //the element of hash table, the hash table uses separate-chain to solve the collision\\n    struct HashElement\\n    {\\n\\t    MyListNode * node;\\n\\t    struct HashElement * next;\\n    };\\n    typedef struct HashElement HashElement;\\n\\n    //the head of double-linked list\\n    MyListNode my_head;\\n    //pointer to the head\\n    MyListNode * head;\\n    //total capacity of the LRU Cache\\n    int my_capacity;\\n    //current size of the LRU Cache\\n    int current_capacity;\\n    //memory pool for list node\\n    MyListNode * mem_pool;\\n    //hash table\\n    HashElement * hash_table;\\n\\n    //allocate list node from memory pool\\n    MyListNode * Alloc() { return &mem_pool[current_capacity++]; }\\n\\n    //insert an element into hash table\\n    void hash_insert(MyListNode * my_node)\\n    {\\n\\t    int pos = my_node->key % HASH_SIZE;\\n\\t    HashElement * p;\\n\\t    for (p = hash_table[pos].next; p; p = p->next)\\n\\t    {\\n\\t\\t    if (p->node == my_node) return;\\n\\t    }\\n\\t    p = (HashElement *)malloc(sizeof(*p));\\n\\t    p->node = my_node;\\n\\t    p->next = hash_table[pos].next;\\n\\t    hash_table[pos].next = p;\\n    }\\n\\n    //find a key in the hash table, if the key matches, return the list node, else return NULL\\n    MyListNode * hash_find(int key)\\n    {\\n\\t    int pos = key % HASH_SIZE;\\n\\t    HashElement * p;\\n\\t    for (p = hash_table[pos].next; p; p = p->next)\\n\\t    {\\n\\t\\t    if (p->node->key == key) break;\\n\\t    }\\n\\t    return p ? p->node : NULL;\\n    }\\n\\n    //delete a element from the hash table\\n    void hash_delete(int key)\\n    {\\n\\t    int pos = key % HASH_SIZE;\\n\\t    HashElement * p;\\n\\t    HashElement * q;\\n\\t    for (q = &hash_table[pos], p = hash_table[pos].next; p; q = p, p = p->next)\\n\\t    {\\n\\t\\t    if (p->node->key == key)\\n\\t\\t    {\\n\\t\\t\\t    q->next = p->next;\\n\\t\\t\\t    free(p);\\n\\t\\t    }\\n\\t    }\\n    }\\n\\n\\n    void lruCacheInit(int capacity)\\n    {\\n\\t    //initialization of the double-linked list\\n\\t    head = &my_head;\\n\\t    head->key = 0;\\n\\t    head->value = 0;\\n\\t    head->next = head;\\n\\t    head->prev = head;\\n\\t    my_capacity = capacity;\\n\\t    current_capacity = 0;\\n\\t    //allocate memory for the memory pool and hash table\\n\\t    mem_pool = (MyListNode *)malloc(sizeof(*mem_pool) * capacity);\\n\\t    hash_table = (HashElement *)calloc(HASH_SIZE, sizeof(*hash_table));\\n    }\\n\\n    void lruCacheFree()\\n    {\\n\\t    int i;\\n\\t    //free the memory pool\\n\\t    free(mem_pool);\\n\\t    //free each bucket of the hash table, and the separate-chain list nodes of these buckets. \\n\\t    for (i = 0; i < HASH_SIZE; ++i)\\n\\t    {\\n\\t\\t    HashElement * p;\\n\\t\\t    HashElement * q;\\n\\t\\t    for (q = &hash_table[i], p = hash_table[i].next; p;)\\n\\t\\t    {\\n\\t\\t    \\tq = p;\\n\\t\\t\\t    p = p->next;\\n\\t\\t\\t    free(q);\\n\\t\\t    }\\n\\t    }\\n\\t    //free the hash table\\n\\t    free(hash_table);\\n    }\\n\\n    int lruCacheGet(int key)\\n    {\\n\\t    MyListNode * p;\\n\\n\\t    p = hash_find(key);\\n\\t    //if find the key successfully, move the list node to the head of the list\\n\\t    if (p)\\n\\t    {\\n\\t\\t    p->prev->next = p->next;\\n\\t\\t    p->next->prev = p->prev;\\n\\t\\t    p->prev = head;\\n\\t\\t    p->next = head->next;\\n\\t\\t    p->prev->next = p;\\n\\t\\t    p->next->prev = p;\\n\\t    }\\n\\t    return p ? p->value : -1;\\n    }\\n\\n    void lruCacheSet(int key, int value)\\n    {\\n\\t    MyListNode * p;\\n\\n\\t    p = hash_find(key);\\n\\t    //if find the key successfully, modify its value, and move the list node to the head of the list\\n\\t    if (p)\\n\\t    {\\n\\t\\t    p->value = value;\\n\\t\\t    p->prev->next = p->next;\\n\\t\\t    p->next->prev = p->prev;\\n\\t\\t    p->prev = head;\\n\\t\\t    p->next = head->next;\\n\\t\\t    p->prev->next = p;\\n\\t\\t    p->next->prev = p;\\n\\t    }\\n\\t    //otherwise, try to allocate memory for the new key-value set, or try to vacate a key-value set for the new one\\n\\t    else\\n\\t    {\\n\\t\\t    //when LRU Cache is not full, try to allocate memory for the new key-value set\\n\\t\\t    if (current_capacity < my_capacity)\\n\\t\\t    {\\n\\t\\t\\t    p = (MyListNode *)Alloc(sizeof(*p));\\n\\t\\t\\t    p->key = key;\\n\\t\\t\\t    p->value = value;\\n\\t\\t\\t    p->prev = head;\\n\\t\\t\\t    p->next = head->next;\\n\\t\\t\\t    p->prev->next = p;\\n\\t\\t\\t    p->next->prev = p;\\n\\t\\t\\t    hash_insert(p);\\n\\t\\t    }\\n\\t\\t        //otherwise, try to vacate one\\n\\t\\t    else\\n\\t\\t    {\\n\\t\\t\\t    p = head->prev;\\n\\t\\t\\t    hash_delete(p->key);\\n\\t\\t\\t    p->key = key;\\n\\t\\t\\t    p->value = value;\\n\\t\\t\\t    p->prev->next = p->next;\\n\\t\\t\\t    p->next->prev = p->prev;\\n\\t\\t\\t    p->prev = head;\\n\\t\\t\\t    p->next = head->next;\\n\\t\\t\\t    p->prev->next = p;\\n\\t\\t\\t    p->next->prev = p;\\n\\t\\t\\t    hash_insert(p);\\n\\t\\t    }\\n\\t    }\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 46180,
                "title": "pretty-clean-92-ms-c-solution",
                "content": "    class LRUCache {\\n    public:\\n    \\tint maxCap;\\n    \\tlist<pair<int, int>> cache;\\n    \\tunordered_map<int, list<pair<int, int>>::iterator> keyLoc;\\n    \\n    \\tLRUCache(int capacity) {\\n    \\t\\tmaxCap = capacity;\\n    \\t}\\n    \\n    \\tvoid touch(list<pair<int, int>>::iterator &iter) {\\n    \\t\\tcache.push_back(*iter);\\n    \\t\\tkeyLoc[iter->first] = --(cache.end());\\n    \\t\\tcache.erase(iter);\\n    \\t}\\n    \\n    \\tint get(int key) {\\n    \\t\\tint value = -1;\\n    \\n    \\t\\tif (keyLoc.find(key) != keyLoc.end()) {\\n    \\t\\t\\tlist<pair<int, int>>::iterator iter = keyLoc[key];\\n    \\t\\t\\tvalue = iter->second;\\n    \\t\\t\\ttouch(iter);\\n    \\t\\t}\\n    \\n    \\t\\treturn value;\\n    \\t}\\n    \\n    \\tvoid set(int key, int value) {\\n    \\t\\tlist<pair<int, int>>::iterator iter;\\n    \\n    \\t\\tif (keyLoc.find(key) == keyLoc.end()) {\\n    \\t\\t\\tif ((int) keyLoc.size() == maxCap) {\\n    \\t\\t\\t\\titer = cache.begin();\\n    \\t\\t\\t\\tkeyLoc.erase(iter->first);\\n    \\t\\t\\t\\tcache.erase(iter);\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tcache.push_front(make_pair(key, value));\\n    \\t\\t\\titer = cache.begin();\\n    \\t\\t} else {\\n    \\t\\t\\titer = keyLoc[key];\\n    \\t\\t\\titer->second = value;\\n    \\t\\t}\\n    \\n    \\t\\ttouch(iter);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "    class LRUCache {\\n    public:\\n    \\tint maxCap;\\n    \\tlist<pair<int, int>> cache;\\n    \\tunordered_map<int, list<pair<int, int>>::iterator> keyLoc;\\n    \\n    \\tLRUCache(int capacity) {\\n    \\t\\tmaxCap = capacity;\\n    \\t}\\n    \\n    \\tvoid touch(list<pair<int, int>>::iterator &iter) {\\n    \\t\\tcache.push_back(*iter);\\n    \\t\\tkeyLoc[iter->first] = --(cache.end());\\n    \\t\\tcache.erase(iter);\\n    \\t}\\n    \\n    \\tint get(int key) {\\n    \\t\\tint value = -1;\\n    \\n    \\t\\tif (keyLoc.find(key) != keyLoc.end()) {\\n    \\t\\t\\tlist<pair<int, int>>::iterator iter = keyLoc[key];\\n    \\t\\t\\tvalue = iter->second;\\n    \\t\\t\\ttouch(iter);\\n    \\t\\t}\\n    \\n    \\t\\treturn value;\\n    \\t}\\n    \\n    \\tvoid set(int key, int value) {\\n    \\t\\tlist<pair<int, int>>::iterator iter;\\n    \\n    \\t\\tif (keyLoc.find(key) == keyLoc.end()) {\\n    \\t\\t\\tif ((int) keyLoc.size() == maxCap) {\\n    \\t\\t\\t\\titer = cache.begin();\\n    \\t\\t\\t\\tkeyLoc.erase(iter->first);\\n    \\t\\t\\t\\tcache.erase(iter);\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tcache.push_front(make_pair(key, value));\\n    \\t\\t\\titer = cache.begin();\\n    \\t\\t} else {\\n    \\t\\t\\titer = keyLoc[key];\\n    \\t\\t\\titer->second = value;\\n    \\t\\t}\\n    \\n    \\t\\ttouch(iter);\\n    \\t}\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 46380,
                "title": "my-solution-o-1-complexity-for-both-for-your-reference",
                "content": "I used the following hash table:\\nkey->next younger key, next older key, value\\n\\nIf you think about it, you will see that it enjoys the convenience of both a hash table and a linked list.\\n \\n  \\n\\n     class LRUCache{\\n        public:\\n            struct triple{\\n                int older;\\n                int younger;\\n                int value;\\n            };\\n            \\n            bool debug;\\n            int capacity;\\n            unordered_map<int, triple> cache;  //key, next younger key, next older key, value\\n            int o_key;//oldest key, valid only if cache is non-empty\\n            int y_key;//youngest key, valid only if cache is non-empty\\n            LRUCache(int capacity) { //assume capacity>0\\n                this->capacity=capacity;\\n                cache.clear();\\n                debug=0;\\n            }\\n            \\n            void print(){\\n                if (cache.empty()) cout<<\"Empty!\"<<endl;\\n                else{\\n                    int current_key=y_key;\\n                    while (true){\\n                        cout<<current_key<<':'<<cache[current_key].value<<' ';\\n                        if (current_key==o_key) break;\\n                        current_key=cache[current_key].older;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n            \\n            int get(int key) {\\n                if (cache.count(key)>0){\\n                    \\n                    if (key!=y_key){  //need to update the ordering \\n                        if (key==o_key){  //accessed key is the oldest one\\n                            o_key=cache[key].younger;\\n                            cache[key].older=y_key;\\n                            cache[y_key].younger=key;\\n                            y_key=key;\\n                        }\\n                        else{\\n                            cache[cache[key].younger].older=cache[key].older;\\n                            cache[cache[key].older].younger=cache[key].younger;\\n                            cache[key].older=y_key;\\n                            cache[y_key].younger=key;\\n                            y_key=key;\\n                        }\\n                    }\\n                    if (debug) print();\\n                    return cache[key].value;\\n                }\\n                if (debug) print();\\n                return -1;\\n            }\\n            \\n            void set(int key, int value) {\\n                if (cache.empty()){\\n                    o_key=key;\\n                    y_key=key;\\n                    cache[key].value=value;\\n                    if (debug) print();\\n                    return;\\n                }\\n                if (cache.count(key)>0){ //already present\\n                    cache[key].value=value;  //update value\\n                    bool temp_debug=debug;\\n                    debug=0;\\n                    get(key);\\n                    debug=temp_debug;\\n                }else{\\n                    cache[key].value=value;  //insert entry\\n                    cache[key].older=y_key;\\n                    cache[y_key].younger=key;\\n                    y_key=key;\\n                    if (cache.size()>capacity){ //delete the oldest one\\n                        o_key=cache[o_key].younger;\\n                        cache.erase(cache[o_key].older);\\n                    }\\n                }\\n                if (debug) print();\\n            }\\n        };",
                "solutionTags": [],
                "code": "I used the following hash table:\\nkey->next younger key, next older key, value\\n\\nIf you think about it, you will see that it enjoys the convenience of both a hash table and a linked list.\\n \\n  \\n\\n     class LRUCache{\\n        public:\\n            struct triple{\\n                int older;\\n                int younger;\\n                int value;\\n            };\\n            \\n            bool debug;\\n            int capacity;\\n            unordered_map<int, triple> cache;  //key, next younger key, next older key, value\\n            int o_key;//oldest key, valid only if cache is non-empty\\n            int y_key;//youngest key, valid only if cache is non-empty\\n            LRUCache(int capacity) { //assume capacity>0\\n                this->capacity=capacity;\\n                cache.clear();\\n                debug=0;\\n            }\\n            \\n            void print(){\\n                if (cache.empty()) cout<<\"Empty!\"<<endl;\\n                else{\\n                    int current_key=y_key;\\n                    while (true){\\n                        cout<<current_key<<':'<<cache[current_key].value<<' ';\\n                        if (current_key==o_key) break;\\n                        current_key=cache[current_key].older;\\n                    }\\n                    cout<<endl;\\n                }\\n            }\\n            \\n            int get(int key) {\\n                if (cache.count(key)>0){\\n                    \\n                    if (key!=y_key){  //need to update the ordering \\n                        if (key==o_key){  //accessed key is the oldest one\\n                            o_key=cache[key].younger;\\n                            cache[key].older=y_key;\\n                            cache[y_key].younger=key;\\n                            y_key=key;\\n                        }\\n                        else{\\n                            cache[cache[key].younger].older=cache[key].older;\\n                            cache[cache[key].older].younger=cache[key].younger;\\n                            cache[key].older=y_key;\\n                            cache[y_key].younger=key;\\n                            y_key=key;\\n                        }\\n                    }\\n                    if (debug) print();\\n                    return cache[key].value;\\n                }\\n                if (debug) print();\\n                return -1;\\n            }\\n            \\n            void set(int key, int value) {\\n                if (cache.empty()){\\n                    o_key=key;\\n                    y_key=key;\\n                    cache[key].value=value;\\n                    if (debug) print();\\n                    return;\\n                }\\n                if (cache.count(key)>0){ //already present\\n                    cache[key].value=value;  //update value\\n                    bool temp_debug=debug;\\n                    debug=0;\\n                    get(key);\\n                    debug=temp_debug;\\n                }else{\\n                    cache[key].value=value;  //insert entry\\n                    cache[key].older=y_key;\\n                    cache[y_key].younger=key;\\n                    y_key=key;\\n                    if (cache.size()>capacity){ //delete the oldest one\\n                        o_key=cache[o_key].younger;\\n                        cache.erase(cache[o_key].older);\\n                    }\\n                }\\n                if (debug) print();\\n            }\\n        };",
                "codeTag": "C++"
            },
            {
                "id": 2814671,
                "title": "simple-c-doubly-linked-list-solution-hast-table",
                "content": "\\n\\n# Code\\n```\\n\\nclass LRUCache {\\npublic:\\nclass node{\\n    public:\\n    int key;\\n    int val;\\n\\n    node* next;\\n    node* prev;\\n\\n    node(int _key,int _val){\\n        key = _key;\\n        val = _val;\\n        next = NULL;\\n        prev = NULL;\\n    }\\n};\\n\\n\\n    int n;\\n    unordered_map<int,node*>mp;\\n\\n    // head and tail\\n    node* head = new node(0,0);\\n    node* tail = new node(0,0);    \\n\\n    void remove(node* root){\\n        mp.erase(root->key);\\n        node* r1 = root->next;\\n        node* r2 = root->prev;\\n        r2->next = r1;\\n        r1->prev = r2;  \\n    }\\n    \\n    void insert(node* root){\\n        mp[root->key] = root;\\n\\n        node* temp = head->next;\\n        head->next = root;\\n        root->next = temp;\\n        temp->prev = root;\\n        root->prev = head;        \\n    }\\n\\n    LRUCache(int capacity) {\\n        n = capacity;\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.count(key)==0){\\n            return -1;\\n        }\\n        node *temp = mp[key];\\n        remove(temp);\\n        insert(temp);\\n        return temp->val;\\n    }\\n    \\n    void put(int key, int value) {\\n        node* temp = new node(key,value);\\n        if(mp.count(key)!=0){\\n            remove(mp[key]);\\n        }\\n        if(mp.size() == n){\\n            remove(tail->prev);\\n        }\\n        insert(temp);\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\n\\nclass LRUCache {\\npublic:\\nclass node{\\n    public:\\n    int key;\\n    int val;\\n\\n    node* next;\\n    node* prev;\\n\\n    node(int _key,int _val){\\n        key = _key;\\n        val = _val;\\n        next = NULL;\\n        prev = NULL;\\n    }\\n};\\n\\n\\n    int n;\\n    unordered_map<int,node*>mp;\\n\\n    // head and tail\\n    node* head = new node(0,0);\\n    node* tail = new node(0,0);    \\n\\n    void remove(node* root){\\n        mp.erase(root->key);\\n        node* r1 = root->next;\\n        node* r2 = root->prev;\\n        r2->next = r1;\\n        r1->prev = r2;  \\n    }\\n    \\n    void insert(node* root){\\n        mp[root->key] = root;\\n\\n        node* temp = head->next;\\n        head->next = root;\\n        root->next = temp;\\n        temp->prev = root;\\n        root->prev = head;        \\n    }\\n\\n    LRUCache(int capacity) {\\n        n = capacity;\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.count(key)==0){\\n            return -1;\\n        }\\n        node *temp = mp[key];\\n        remove(temp);\\n        insert(temp);\\n        return temp->val;\\n    }\\n    \\n    void put(int key, int value) {\\n        node* temp = new node(key,value);\\n        if(mp.count(key)!=0){\\n            remove(mp[key]);\\n        }\\n        if(mp.size() == n){\\n            remove(tail->prev);\\n        }\\n        insert(temp);\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582386,
                "title": "typescript-design-lru-cache-with-doubly-lined-list",
                "content": "**Description**\\n\\nDesign a LRU Cache with Doubly Linked List and TypeScript.\\n\\n**Methods**\\n\\n- `get`: Returns `value` for a given `key` if it exists.\\n- `put`: Inserts or updates a given `value` and returns `void`.\\n- `detach*`: Remove given `node` from the list and return `void`.\\n- `prepend*`: Attach given `node` to the `head` and return `void`.\\n- `trim*`: Remove `tail` from the list and lookups and return `void`.\\n\\n**Program**\\n\\n```ts\\ntype CacheNode<T = number> = {\\n  prev?: CacheNode<T>;\\n  value: T;\\n  next?: CacheNode<T>;\\n};\\n\\nclass LRUCache {\\n  private capacity: number;\\n  private length: number;\\n  private head?: CacheNode;\\n  private tail?: CacheNode;\\n\\n  private lookup: Map<number, CacheNode>;\\n  private reverseLookup: Map<CacheNode, number>;\\n\\n  constructor(capacity: number) {\\n    this.capacity = capacity;\\n    this.length = 0;\\n    this.head = this.tail = undefined;\\n    this.lookup = new Map<number, CacheNode>();\\n    this.reverseLookup = new Map<CacheNode, number>();\\n  }\\n\\n  get(key: number): number {\\n    const node = this.lookup.get(key);\\n    if (!node) {\\n      return -1;\\n    }\\n    this.detach(node);\\n    this.prepend(node);\\n    return node.value;\\n  }\\n\\n  put(key: number, value: number): void {\\n    let node = this.lookup.get(key);\\n    if (!node) {\\n      node = { value } as CacheNode;\\n      this.length++;\\n      this.prepend(node);\\n      this.trim();\\n      this.lookup.set(key, node);\\n      this.reverseLookup.set(node, key);\\n    } else {\\n      this.detach(node);\\n      this.prepend(node);\\n      node.value = value;\\n    }\\n  }\\n\\n  private detach(node: CacheNode): void {\\n    if (node.prev) {\\n      node.prev.next = node.next;\\n    }\\n    if (node.next) {\\n      node.next.prev = node.prev;\\n    }\\n    if (this.head === node) {\\n      this.head = this.head.next;\\n    }\\n    if (this.tail === node) {\\n      this.tail = this.tail.prev;\\n    }\\n    node.next = node.prev = undefined;\\n  }\\n\\n  private prepend(node: CacheNode): void {\\n    if (!this.head) {\\n      this.head = this.tail = node;\\n      return;\\n    }\\n    node.next = this.head;\\n    this.head.prev = node;\\n    this.head = node;\\n  }\\n\\n  private trim(): void {\\n    if (this.length <= this.capacity) {\\n      return;\\n    }\\n    const tail = this.tail as CacheNode;\\n    this.detach(this.tail as CacheNode);\\n    const key = this.reverseLookup.get(tail) as number;\\n    this.lookup.delete(key);\\n    this.reverseLookup.delete(tail);\\n    this.length--;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Linked List"
                ],
                "code": "```ts\\ntype CacheNode<T = number> = {\\n  prev?: CacheNode<T>;\\n  value: T;\\n  next?: CacheNode<T>;\\n};\\n\\nclass LRUCache {\\n  private capacity: number;\\n  private length: number;\\n  private head?: CacheNode;\\n  private tail?: CacheNode;\\n\\n  private lookup: Map<number, CacheNode>;\\n  private reverseLookup: Map<CacheNode, number>;\\n\\n  constructor(capacity: number) {\\n    this.capacity = capacity;\\n    this.length = 0;\\n    this.head = this.tail = undefined;\\n    this.lookup = new Map<number, CacheNode>();\\n    this.reverseLookup = new Map<CacheNode, number>();\\n  }\\n\\n  get(key: number): number {\\n    const node = this.lookup.get(key);\\n    if (!node) {\\n      return -1;\\n    }\\n    this.detach(node);\\n    this.prepend(node);\\n    return node.value;\\n  }\\n\\n  put(key: number, value: number): void {\\n    let node = this.lookup.get(key);\\n    if (!node) {\\n      node = { value } as CacheNode;\\n      this.length++;\\n      this.prepend(node);\\n      this.trim();\\n      this.lookup.set(key, node);\\n      this.reverseLookup.set(node, key);\\n    } else {\\n      this.detach(node);\\n      this.prepend(node);\\n      node.value = value;\\n    }\\n  }\\n\\n  private detach(node: CacheNode): void {\\n    if (node.prev) {\\n      node.prev.next = node.next;\\n    }\\n    if (node.next) {\\n      node.next.prev = node.prev;\\n    }\\n    if (this.head === node) {\\n      this.head = this.head.next;\\n    }\\n    if (this.tail === node) {\\n      this.tail = this.tail.prev;\\n    }\\n    node.next = node.prev = undefined;\\n  }\\n\\n  private prepend(node: CacheNode): void {\\n    if (!this.head) {\\n      this.head = this.tail = node;\\n      return;\\n    }\\n    node.next = this.head;\\n    this.head.prev = node;\\n    this.head = node;\\n  }\\n\\n  private trim(): void {\\n    if (this.length <= this.capacity) {\\n      return;\\n    }\\n    const tail = this.tail as CacheNode;\\n    this.detach(this.tail as CacheNode);\\n    const key = this.reverseLookup.get(tail) as number;\\n    this.lookup.delete(key);\\n    this.reverseLookup.delete(tail);\\n    this.length--;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696454,
                "title": "easiest-clean-c-solution-u",
                "content": "```\\nclass LRUCache {\\npublic:\\n    list<pair<int,int>>l;\\n    unordered_map<int,list<pair<int,int>>::iterator>umap;\\n    int size;\\n    \\n    LRUCache(int capacity) {\\n        \\n        size = capacity;\\n    }\\n    \\n    int get(int key) {\\n        \\n        if(umap.find(key) == umap.end()) return -1;\\n        l.splice(begin(l), l, umap[key]);\\n        return umap[key]->second;\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        if(umap.find(key) != umap.end()){\\n            l.splice(begin(l), l, umap[key]);\\n            umap[key]->second = value; \\n            return;\\n        }\\n        if(l.size() == size){\\n            auto d_key = l.back().first;\\n            l.pop_back();\\n            umap.erase(d_key);\\n        }\\n            l.push_front({key, value});\\n            umap[key] = begin(l);\\n        }\\n};\\n\\n// any confusion in the code, pls let me know in the comment.\\n//Thanks :)\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    list<pair<int,int>>l;\\n    unordered_map<int,list<pair<int,int>>::iterator>umap;\\n    int size;\\n    \\n    LRUCache(int capacity) {\\n        \\n        size = capacity;\\n    }\\n    \\n    int get(int key) {\\n        \\n        if(umap.find(key) == umap.end()) return -1;\\n        l.splice(begin(l), l, umap[key]);\\n        return umap[key]->second;\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        if(umap.find(key) != umap.end()){\\n            l.splice(begin(l), l, umap[key]);\\n            umap[key]->second = value; \\n            return;\\n        }\\n        if(l.size() == size){\\n            auto d_key = l.back().first;\\n            l.pop_back();\\n            umap.erase(d_key);\\n        }\\n            l.push_front({key, value});\\n            umap[key] = begin(l);\\n        }\\n};\\n\\n// any confusion in the code, pls let me know in the comment.\\n//Thanks :)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1677936,
                "title": "python-dict-only",
                "content": "\\n\\n```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.capacity = capacity\\n        self.items = 0\\n        \\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            val = self.cache[key] # get value of key  and delete the key - value\\n            del self.cache[key]\\n            self.cache[key] = val # Puts the key - value to end of cache\\n            return self.cache[key]\\n        \\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.cache:  \\n            del self.cache[key]  # delete key\\n            self.cache[key] = value #place the key - value pair in the end of cache\\n            \\n        elif self.items == self.capacity:\\n            del self.cache[next(iter(self.cache))]  #delete the first key - value pair which is the LRU\\n            self.cache[key] = value\\n            \\n        else:\\n            self.cache[key] = value\\n            self.items += 1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.cache = {}\\n        self.capacity = capacity\\n        self.items = 0\\n        \\n    def get(self, key: int) -> int:\\n        if key in self.cache:\\n            val = self.cache[key] # get value of key  and delete the key - value\\n            del self.cache[key]\\n            self.cache[key] = val # Puts the key - value to end of cache\\n            return self.cache[key]\\n        \\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.cache:  \\n            del self.cache[key]  # delete key\\n            self.cache[key] = value #place the key - value pair in the end of cache\\n            \\n        elif self.items == self.capacity:\\n            del self.cache[next(iter(self.cache))]  #delete the first key - value pair which is the LRU\\n            self.cache[key] = value\\n            \\n        else:\\n            self.cache[key] = value\\n            self.items += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581028,
                "title": "go-using-standard-library",
                "content": "This is done using std library list https://pkg.go.dev/container/list\\n\\n```\\ntype LRUCache struct {\\n    cache map[int]*list.Element\\n    linklist *list.List\\n    capacity int\\n}\\n\\n\\nfunc Constructor(capacity int) LRUCache {\\n    return LRUCache{\\n        cache: make(map[int]*list.Element, capacity),\\n        linklist: list.New(),\\n        capacity: capacity,\\n    }\\n}\\n\\n// 0 is key and 1 is value\\nfunc (this *LRUCache) Get(key int) int {\\n    if _, ok := this.cache[key]; !ok {\\n        return -1\\n    }\\n    elem := this.cache[key]\\n    this.linklist.MoveToFront(elem)\\n    return elem.Value.([]int)[1]\\n}\\n\\n\\nfunc (this *LRUCache) Put(key int, value int)  {\\n    // if capacity reached\\n    if elem, ok := this.cache[key]; ok {\\n        this.linklist.Remove(elem)\\n        newelem := this.linklist.PushFront([]int{key, value})\\n        this.cache[key] = newelem\\n        return\\n    }\\n    if len(this.cache) == this.capacity {\\n        elem := this.linklist.Back()\\n        v := this.linklist.Remove(elem)\\n        delete(this.cache, v.([]int)[0])\\n    }\\n    newelem := this.linklist.PushFront([]int{key, value})\\n    this.cache[key] = newelem\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype LRUCache struct {\\n    cache map[int]*list.Element\\n    linklist *list.List\\n    capacity int\\n}\\n\\n\\nfunc Constructor(capacity int) LRUCache {\\n    return LRUCache{\\n        cache: make(map[int]*list.Element, capacity),\\n        linklist: list.New(),\\n        capacity: capacity,\\n    }\\n}\\n\\n// 0 is key and 1 is value\\nfunc (this *LRUCache) Get(key int) int {\\n    if _, ok := this.cache[key]; !ok {\\n        return -1\\n    }\\n    elem := this.cache[key]\\n    this.linklist.MoveToFront(elem)\\n    return elem.Value.([]int)[1]\\n}\\n\\n\\nfunc (this *LRUCache) Put(key int, value int)  {\\n    // if capacity reached\\n    if elem, ok := this.cache[key]; ok {\\n        this.linklist.Remove(elem)\\n        newelem := this.linklist.PushFront([]int{key, value})\\n        this.cache[key] = newelem\\n        return\\n    }\\n    if len(this.cache) == this.capacity {\\n        elem := this.linklist.Back()\\n        v := this.linklist.Remove(elem)\\n        delete(this.cache, v.([]int)[0])\\n    }\\n    newelem := this.linklist.PushFront([]int{key, value})\\n    this.cache[key] = newelem\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1264812,
                "title": "python-simple-readable-solution-time-o-1-space-o-n-lru-cache",
                "content": "# Approach + Code\\nLet\\'s go through the solution step by step\\nFirst We need to initialized the LRU Cache\\\\\\nfor that we need a \\n1. Capacity -> given by problem\\n2. Hashmap for storing the keys encounterd \\n3. Head and Tail nodes for initialzing DLL\\n```\\ndef __init__(self, capacity: int):\\n        self.cap=capacity\\n        self.d={}\\n        self.head=Node(0,0)\\n        self.tail=Node(0,0)\\n        \\n        self.head.nxt=self.tail\\n        self.tail.prev=self.head\\n```\\nNow that we initialized we need to define the **Node** \\nIt stores the\\n1. key\\n2. val\\n3. prev\\n4. next pointers\\n```\\nclass Node:\\n    def __init__(self,key,val):\\n        self.key=key\\n        self.val=val\\n        self.nxt=self.prev=None\\n```\\nAfter that we have the PUT function\\nFirst of all forget about the exception case -> \"When key is already present in the Hashmap\"\\nNow that we are settled on this condition let\\'s start\\n\\nFirst create a Node -> Node(key,val)\\nWe need to add this node to the tail of the DLL\\nSo a function **ADD** is defined \\n## ADD FUNCTION\\n```\\ndef ADD(self,node):\\n        n=self.tail\\n        p=n.prev\\n        \\n        node.prev=p\\n        p.nxt=node\\n        \\n        node.nxt=n\\n        n.prev=node\\n```\\n\\nNow discussing the exception case -> when the key is already present in the DLL\\nIn this case we need to update the key value pair\\nSo first remove the old node usign **REM** funtion\\nand the rest of the function is as discussed before\\n## REM FUNCTION\\n```\\ndef REM(self,node):\\n        p=node.prev\\n        n=node.nxt\\n        \\n        p.nxt=n\\n        n.prev=p\\n```\\n\\n## PUT FUNCTION\\n```\\ndef put(self, key: int, val: int) -> None:\\n        if key in self.d:\\n            n=self.d[key]\\n            self.REM(n)\\n        \\n        \\n        n=Node(key,val)\\n        self.ADD(n)\\n        self.d[key]=n\\n        if len(self.d)>self.cap:\\n            n=self.head.nxt\\n            self.REM(n)\\n            del self.d[n.key]\\n```\\n\\nNow coming to **GET** function\\nFirst we\\'ll discuss the easiest case -> When the key is not present in the DLL\\nWe check the Hashmap and simply return -1\\n\\nBut if the key is present\\nfirst we remove the node\\nand then add this node -> as we are accessing it. It is used recently hence moving it to the tail\\n```\\ndef get(self, key: int) -> int:\\n        if key not in self.d:\\n            return -1\\n        n=self.d[key]\\n        self.REM(n)\\n        self.ADD(n)\\n        return n.val\\n```\\n\\n# Complexity\\n# Time\\n**O(1)** \\nSearching takes only O(1) as we are storing in a HashMap \\nAdding and deleting a node will take O(1) as we are using a Doubly linked list \\n# Space\\n**O(N)**\\nN for Hashmap for each node\\nN for N nodes in a doubly linked list",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef __init__(self, capacity: int):\\n        self.cap=capacity\\n        self.d={}\\n        self.head=Node(0,0)\\n        self.tail=Node(0,0)\\n        \\n        self.head.nxt=self.tail\\n        self.tail.prev=self.head\\n```\n```\\nclass Node:\\n    def __init__(self,key,val):\\n        self.key=key\\n        self.val=val\\n        self.nxt=self.prev=None\\n```\n```\\ndef ADD(self,node):\\n        n=self.tail\\n        p=n.prev\\n        \\n        node.prev=p\\n        p.nxt=node\\n        \\n        node.nxt=n\\n        n.prev=node\\n```\n```\\ndef REM(self,node):\\n        p=node.prev\\n        n=node.nxt\\n        \\n        p.nxt=n\\n        n.prev=p\\n```\n```\\ndef put(self, key: int, val: int) -> None:\\n        if key in self.d:\\n            n=self.d[key]\\n            self.REM(n)\\n        \\n        \\n        n=Node(key,val)\\n        self.ADD(n)\\n        self.d[key]=n\\n        if len(self.d)>self.cap:\\n            n=self.head.nxt\\n            self.REM(n)\\n            del self.d[n.key]\\n```\n```\\ndef get(self, key: int) -> int:\\n        if key not in self.d:\\n            return -1\\n        n=self.d[key]\\n        self.REM(n)\\n        self.ADD(n)\\n        return n.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212701,
                "title": "java-solution-well-documented",
                "content": "```\\nclass LRUCache {\\n    class Node{\\n        int value;\\n        int key;\\n        Node prev;\\n        Node next;\\n        \\n        Node(int key, int value){\\n            //Actual node in the cache\\n            this.value = value;\\n            this.key = key;\\n        }\\n        \\n        Node(){\\n            //Dummy node to serve as head & tail of the cache\\n        }\\n    }\\n    \\n    Node head;\\n    Node tail;\\n    int maxCapacity;\\n    Map<Integer, Node> nodeMap;\\n    \\n    public LRUCache(int capacity) {\\n        maxCapacity = capacity;\\n        head= new Node();\\n        tail = new Node();\\n        nodeMap = new HashMap();\\n\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(nodeMap.containsKey(key)){\\n            //Node with required value\\n            Node valNode = nodeMap.get(key);\\n            \\n            //Move this value to the front of the cache by:\\n            //1. Delete this node from the current position\\n            //2. Insert it in the front of the cache\\n            deleteFromCurrentPosition(valNode);\\n            insertNearHead(valNode);\\n            \\n            //return the found value\\n            return valNode.value;\\n        }\\n        \\n        //Return -1 since the required value not found in the cache\\n        return -1;        \\n    }\\n    \\n    void deleteFromCurrentPosition(Node node){\\n        //delete the current node from the cache by re-wiring the previous & next nodes of the current node to each other, thereby bypassing the current node.\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n     \\n    void removeNearTail(){\\n        //Move the tail pointer one step backward, and set the next pointer of the new tail to null,\\n        // so that the reference to the previous tail node is gone\\n        tail = tail.prev;\\n        tail.next = null;\\n    }\\n    \\n    void insertNearHead(Node node){\\n        node.next=head.next;\\n        node.prev=head;\\n        \\n        head.next.prev=node;\\n        head.next = node;\\n    }\\n    \\n    public void put(int key, int value) {\\n        //check if this key already present in the nodeMap\\n        if(nodeMap.containsKey(key)){\\n            //The key is already exisiting in the map.\\n            //Get the node from the nodeMap using this key & delete it from its current position in the cache\\n            \\n            Node valNode = nodeMap.get(key);\\n            deleteFromCurrentPosition(valNode);\\n            \\n            //Update the existing node with the new value\\n            valNode.value = value;\\n            \\n            //Insert the modified node to the front of the cache\\n            insertNearHead(valNode);\\n        }else{\\n            //Existing node not found, hence create a new one\\n            Node newNode = new Node(key, value);\\n            \\n             //check if the current cache is already full\\n            if(nodeMap.size()==maxCapacity){\\n                //remove node from the node map, since it will be irrelevant after deletion\\n                nodeMap.remove(tail.prev.key);\\n\\n                //The cache is full here. Remove a  node from the tail of the cache\\n                removeNearTail();\\n            }\\n            //Insert the new node in the front of the cache\\n            insertNearHead(newNode); \\n            \\n             //Add this node to the map for tracking its reference\\n            nodeMap.put(key, newNode);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LRUCache {\\n    class Node{\\n        int value;\\n        int key;\\n        Node prev;\\n        Node next;\\n        \\n        Node(int key, int value){\\n            //Actual node in the cache\\n            this.value = value;\\n            this.key = key;\\n        }\\n        \\n        Node(){\\n            //Dummy node to serve as head & tail of the cache\\n        }\\n    }\\n    \\n    Node head;\\n    Node tail;\\n    int maxCapacity;\\n    Map<Integer, Node> nodeMap;\\n    \\n    public LRUCache(int capacity) {\\n        maxCapacity = capacity;\\n        head= new Node();\\n        tail = new Node();\\n        nodeMap = new HashMap();\\n\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(nodeMap.containsKey(key)){\\n            //Node with required value\\n            Node valNode = nodeMap.get(key);\\n            \\n            //Move this value to the front of the cache by:\\n            //1. Delete this node from the current position\\n            //2. Insert it in the front of the cache\\n            deleteFromCurrentPosition(valNode);\\n            insertNearHead(valNode);\\n            \\n            //return the found value\\n            return valNode.value;\\n        }\\n        \\n        //Return -1 since the required value not found in the cache\\n        return -1;        \\n    }\\n    \\n    void deleteFromCurrentPosition(Node node){\\n        //delete the current node from the cache by re-wiring the previous & next nodes of the current node to each other, thereby bypassing the current node.\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n     \\n    void removeNearTail(){\\n        //Move the tail pointer one step backward, and set the next pointer of the new tail to null,\\n        // so that the reference to the previous tail node is gone\\n        tail = tail.prev;\\n        tail.next = null;\\n    }\\n    \\n    void insertNearHead(Node node){\\n        node.next=head.next;\\n        node.prev=head;\\n        \\n        head.next.prev=node;\\n        head.next = node;\\n    }\\n    \\n    public void put(int key, int value) {\\n        //check if this key already present in the nodeMap\\n        if(nodeMap.containsKey(key)){\\n            //The key is already exisiting in the map.\\n            //Get the node from the nodeMap using this key & delete it from its current position in the cache\\n            \\n            Node valNode = nodeMap.get(key);\\n            deleteFromCurrentPosition(valNode);\\n            \\n            //Update the existing node with the new value\\n            valNode.value = value;\\n            \\n            //Insert the modified node to the front of the cache\\n            insertNearHead(valNode);\\n        }else{\\n            //Existing node not found, hence create a new one\\n            Node newNode = new Node(key, value);\\n            \\n             //check if the current cache is already full\\n            if(nodeMap.size()==maxCapacity){\\n                //remove node from the node map, since it will be irrelevant after deletion\\n                nodeMap.remove(tail.prev.key);\\n\\n                //The cache is full here. Remove a  node from the tail of the cache\\n                removeNearTail();\\n            }\\n            //Insert the new node in the front of the cache\\n            insertNearHead(newNode); \\n            \\n             //Add this node to the map for tracking its reference\\n            nodeMap.put(key, newNode);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176816,
                "title": "ruby-solution-using-hash",
                "content": "```\\nclass LRUCache\\n\\n=begin\\n    :type capacity: Integer\\n=end\\n    def initialize(capacity)\\n        # define global variable @capacity inside this class\\n        @capacity = capacity\\n        # define gloable cache as a Hash.new object\\n        # ruby hash maintains the order of insertion\\n        @cache = Hash.new\\n    end\\n\\n\\n=begin\\n    :type key: Integer\\n    :rtype: Integer\\n=end\\n    def get(key)\\n        val = @cache.delete(key)\\n        @cache[key] = val if val\\n        return val || -1\\n    end\\n\\n\\n=begin\\n    :type key: Integer\\n    :type value: Integer\\n    :rtype: Void\\n=end\\n    def put(key, value)\\n        @cache.delete(key)\\n        @cache[key] = value\\n        # delete cache\\'s 1st key\\n        @cache.delete @cache.keys[0] if @cache.size > @capacity\\n    end\\n\\nend\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache.new(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key, value)\\n```",
                "solutionTags": [],
                "code": "```\\nclass LRUCache\\n\\n=begin\\n    :type capacity: Integer\\n=end\\n    def initialize(capacity)\\n        # define global variable @capacity inside this class\\n        @capacity = capacity\\n        # define gloable cache as a Hash.new object\\n        # ruby hash maintains the order of insertion\\n        @cache = Hash.new\\n    end\\n\\n\\n=begin\\n    :type key: Integer\\n    :rtype: Integer\\n=end\\n    def get(key)\\n        val = @cache.delete(key)\\n        @cache[key] = val if val\\n        return val || -1\\n    end\\n\\n\\n=begin\\n    :type key: Integer\\n    :type value: Integer\\n    :rtype: Void\\n=end\\n    def put(key, value)\\n        @cache.delete(key)\\n        @cache[key] = value\\n        # delete cache\\'s 1st key\\n        @cache.delete @cache.keys[0] if @cache.size > @capacity\\n    end\\n\\nend\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache.new(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key, value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053038,
                "title": "linkedhashmap-of-java-does-all-the-overhead",
                "content": "LinkedHashMap is a class in Java which has best of both the worlds (LinkedList and HashMap). For simplicity, it can be thought of as a data structure which provides capabilities of both LinkedLists and Hashmaps.\\n\\n```\\nclass LRUCache {\\n    \\n    public LinkedHashMap<Integer, Integer> lhm;\\n    public int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        this.lhm = new LinkedHashMap<Integer, Integer>(capacity);\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if(this.lhm.containsKey(key)) {\\n            int retval = this.lhm.get(key);\\n            this.lhm.remove(key);\\n            this.put(key, retval);\\n            return retval;\\n        }\\n        return -1;\\n    }\\n    \\n    public void put(int key, int val) {\\n        \\n        if(this.lhm.containsKey(key)) {\\n            this.lhm.remove(key);\\n        } else if(this.lhm.size() == this.capacity) {\\n            int firstkey = this.lhm.entrySet().iterator().next().getKey();\\n            this.lhm.remove(firstkey);\\n        }\\n        this.lhm.put(key, val);\\n    }\\n}\\n```\\nOne of my seniors was asked a variation of this question in Microsoft. \\n\\nHappy Coding ;p",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass LRUCache {\\n    \\n    public LinkedHashMap<Integer, Integer> lhm;\\n    public int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        this.lhm = new LinkedHashMap<Integer, Integer>(capacity);\\n        this.capacity = capacity;\\n    }\\n    \\n    public int get(int key) {\\n        if(this.lhm.containsKey(key)) {\\n            int retval = this.lhm.get(key);\\n            this.lhm.remove(key);\\n            this.put(key, retval);\\n            return retval;\\n        }\\n        return -1;\\n    }\\n    \\n    public void put(int key, int val) {\\n        \\n        if(this.lhm.containsKey(key)) {\\n            this.lhm.remove(key);\\n        } else if(this.lhm.size() == this.capacity) {\\n            int firstkey = this.lhm.entrySet().iterator().next().getKey();\\n            this.lhm.remove(firstkey);\\n        }\\n        this.lhm.put(key, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978280,
                "title": "python-dictionary-and-doubly-linked-list-with-explanation",
                "content": "```\\nclass DLL:\\n    def __init__(self,key,val):\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n        \\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.size = 0\\n        self.dict = {}\\n        self.head = DLL(0,0)\\n        self.tail = DLL(0,0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key: int) -> int:\\n        if key in self.dict:\\n            #store the value (DLL node object) in a variable\\n            node = self.dict[key]\\n            # Remove node from the Doubly linked list\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            #Insert the node after the head node\\n            self.head.next.prev = node\\n            node.next = self.head.next\\n            self.head.next = node\\n            node.prev = self.head\\n            return node.val\\n        # Return -1 if the key is not present in the dictionary\\n        else:\\n            return -1\\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        # If key is present in the dictionary, means we just have to update the value.\\n        if key in self.dict:\\n            # call the get method so that the node can moved to the first( after the head node) as it is the most recently used\\n            self.get(key)\\n            #Update the val of the node with the new value\\n            self.dict[key].val = value\\n            return\\n        \\n        # If key is not present in the dictionary, we have to add it to the link list and the \\n        # dictionay but first, we have to check the size of the \\n        # dll and compare it to the capacity. If the size will be more than the capacity,\\n        # we delete the least recently used( that is the one before the tail node.)\\n        \\n        self.size +=1\\n        if self.size > self.capacity:\\n            lru = self.tail.prev\\n            del self.dict[lru.key]\\n            lru.prev.next = lru.next\\n            lru.next.prev = lru.prev\\n            self.size -= 1\\n        #Add the new node in the linked list and in the dictionary    \\n        new_head = DLL(key, value)\\n        self.head.next.prev = new_head\\n        new_head.next = self.head.next\\n        self.head.next = new_head\\n        new_head.prev = self.head\\n        self.dict[key] = new_head\\n\\n        \\n        \\n\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)",
                "solutionTags": [
                    "Python3",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass DLL:\\n    def __init__(self,key,val):\\n        self.key = key\\n        self.val = val\\n        self.next = None\\n        self.prev = None\\n        \\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.size = 0\\n        self.dict = {}\\n        self.head = DLL(0,0)\\n        self.tail = DLL(0,0)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n\\n    def get(self, key: int) -> int:\\n        if key in self.dict:\\n            #store the value (DLL node object) in a variable\\n            node = self.dict[key]\\n            # Remove node from the Doubly linked list\\n            node.prev.next = node.next\\n            node.next.prev = node.prev\\n            #Insert the node after the head node\\n            self.head.next.prev = node\\n            node.next = self.head.next\\n            self.head.next = node\\n            node.prev = self.head\\n            return node.val\\n        # Return -1 if the key is not present in the dictionary\\n        else:\\n            return -1\\n\\n\\n    def put(self, key: int, value: int) -> None:\\n        # If key is present in the dictionary, means we just have to update the value.\\n        if key in self.dict:\\n            # call the get method so that the node can moved to the first( after the head node) as it is the most recently used\\n            self.get(key)\\n            #Update the val of the node with the new value\\n            self.dict[key].val = value\\n            return\\n        \\n        # If key is not present in the dictionary, we have to add it to the link list and the \\n        # dictionay but first, we have to check the size of the \\n        # dll and compare it to the capacity. If the size will be more than the capacity,\\n        # we delete the least recently used( that is the one before the tail node.)\\n        \\n        self.size +=1\\n        if self.size > self.capacity:\\n            lru = self.tail.prev\\n            del self.dict[lru.key]\\n            lru.prev.next = lru.next\\n            lru.next.prev = lru.prev\\n            self.size -= 1\\n        #Add the new node in the linked list and in the dictionary    \\n        new_head = DLL(key, value)\\n        self.head.next.prev = new_head\\n        new_head.next = self.head.next\\n        self.head.next = new_head\\n        new_head.prev = self.head\\n        self.dict[key] = new_head\\n\\n        \\n        \\n\\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)",
                "codeTag": "Java"
            },
            {
                "id": 863836,
                "title": "1-c-brute-force-tle-and-optimized-approaches-codestorywithmik",
                "content": "YouTube Video Link - [LRU Cache](https://www.youtube.com/watch?v=81h8O-0U5oo)\\nMy Github treasure - [LRU Cache](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Design/LRU%20Cache.cpp)\\n\\n1) Brute Force (TLE: 20/22 passed) : Although, it gives TLE but it\\'s important to be able to implement the brute force approach as well. This is important for interviews. \\n\\n```\\nclass LRUCache {\\npublic:\\n    vector<pair<int,int>> cache;\\n    int cap ;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n        \\n    }\\n    \\n    \\n    int get(int key) {\\n        \\n        for(int i=0;i<cache.size();i++){\\n            if(cache[i].first==key){\\n                int val = cache[i].second;\\n                pair<int,int> temp = cache[i];\\n                cache.erase(cache.begin()+i);\\n                cache.push_back(temp);\\n                \\n                return val;             \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        bool found= false;\\n        for(int i=0;i<cache.size();i++){\\n            if(cache[i].first==key){\\n                found =true;\\n                cache.erase(cache.begin()+i);\\n                cache.push_back({key,value});\\n                break;\\n            }\\n        }\\n        if(found)\\n            return ;\\n        else{\\n            if(cache.size() == cap){\\n                cache.erase(cache.begin());\\n                cache.push_back({key,value});\\n            }\\n            else{\\n                cache.push_back({key,value});\\n            }\\n        }\\n      \\n    }\\n};\\n```\\n\\n2) Optimized (Accepted) :\\n\\n```\\nclass LRUCache {\\npublic:\\n    list<int> dll; //it contains the key\\n    map<int, pair<list<int>::iterator, int>> cache; //key->(list_node, value)\\n    int capacity;\\n    \\n    LRUCache(int capacity) {\\n        this->capacity = capacity;\\n    }\\n    \\n    void makeMostRecentlyUsed(int key) {\\n        dll.erase(cache[key].first);\\n        dll.push_front(key);\\n        cache[key].first = dll.begin();\\n    }\\n    \\n    int get(int key) {\\n        if(!cache.count(key))\\n            return -1;\\n        \\n        makeMostRecentlyUsed(key);\\n        return cache[key].second;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(cache.count(key)) {\\n            cache[key].second = value;\\n            makeMostRecentlyUsed(key);\\n        } else {\\n            dll.push_front(key);\\n            cache[key] = {dll.begin(), value};\\n            capacity--;\\n        }\\n        \\n        if(capacity < 0) {\\n            cache.erase(dll.back());\\n            dll.pop_back();\\n            capacity++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    vector<pair<int,int>> cache;\\n    int cap ;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n        \\n    }\\n    \\n    \\n    int get(int key) {\\n        \\n        for(int i=0;i<cache.size();i++){\\n            if(cache[i].first==key){\\n                int val = cache[i].second;\\n                pair<int,int> temp = cache[i];\\n                cache.erase(cache.begin()+i);\\n                cache.push_back(temp);\\n                \\n                return val;             \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        bool found= false;\\n        for(int i=0;i<cache.size();i++){\\n            if(cache[i].first==key){\\n                found =true;\\n                cache.erase(cache.begin()+i);\\n                cache.push_back({key,value});\\n                break;\\n            }\\n        }\\n        if(found)\\n            return ;\\n        else{\\n            if(cache.size() == cap){\\n                cache.erase(cache.begin());\\n                cache.push_back({key,value});\\n            }\\n            else{\\n                cache.push_back({key,value});\\n            }\\n        }\\n      \\n    }\\n};\\n```\n```\\nclass LRUCache {\\npublic:\\n    list<int> dll; //it contains the key\\n    map<int, pair<list<int>::iterator, int>> cache; //key->(list_node, value)\\n    int capacity;\\n    \\n    LRUCache(int capacity) {\\n        this->capacity = capacity;\\n    }\\n    \\n    void makeMostRecentlyUsed(int key) {\\n        dll.erase(cache[key].first);\\n        dll.push_front(key);\\n        cache[key].first = dll.begin();\\n    }\\n    \\n    int get(int key) {\\n        if(!cache.count(key))\\n            return -1;\\n        \\n        makeMostRecentlyUsed(key);\\n        return cache[key].second;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(cache.count(key)) {\\n            cache[key].second = value;\\n            makeMostRecentlyUsed(key);\\n        } else {\\n            dll.push_front(key);\\n            cache[key] = {dll.begin(), value};\\n            capacity--;\\n        }\\n        \\n        if(capacity < 0) {\\n            cache.erase(dll.back());\\n            dll.pop_back();\\n            capacity++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657672,
                "title": "c-not-best-but-something-different-no-nodes-used-only-map-vector",
                "content": "```\\n class LRUCache {\\n    public:\\n    \\n        unordered_map<int,int> m;\\n        vector<int> v;\\n        \\n        int cap;\\n        LRUCache(int capacity) {\\n            cap=capacity;\\n        }\\n        \\n\\t\\tint get(int key) {\\n\\t\\t\\tif(m.count(key)){\\n\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\tfor(;v[i]!=key;i++);\\n\\n\\t\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t\\tv.push_back(key);\\n\\t\\t\\t\\treturn m[key];\\n\\t\\t\\t}\\n\\n            return -1;\\n        }\\n\\n        void put(int key, int value) {            \\n            \\n            if(m.size()==cap && !m.count(key))\\n            {   \\n                m.erase(v.front());\\n                v.erase(v.begin());\\n            }   \\n\\n                 m[key]=value;\\n                for(int i=0;i<v.size();i++)\\n                    if(v[i]==key){\\n                        v.erase(v.begin()+i);\\n                        break;\\n                    }\\n                 v.push_back(key);\\n            \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n class LRUCache {\\n    public:\\n    \\n        unordered_map<int,int> m;\\n        vector<int> v;\\n        \\n        int cap;\\n        LRUCache(int capacity) {\\n            cap=capacity;\\n        }\\n        \\n\\t\\tint get(int key) {\\n\\t\\t\\tif(m.count(key)){\\n\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\tfor(;v[i]!=key;i++);\\n\\n\\t\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t\\tv.push_back(key);\\n\\t\\t\\t\\treturn m[key];\\n\\t\\t\\t}\\n\\n            return -1;\\n        }\\n\\n        void put(int key, int value) {            \\n            \\n            if(m.size()==cap && !m.count(key))\\n            {   \\n                m.erase(v.front());\\n                v.erase(v.begin());\\n            }   \\n\\n                 m[key]=value;\\n                for(int i=0;i<v.size();i++)\\n                    if(v[i]==key){\\n                        v.erase(v.begin()+i);\\n                        break;\\n                    }\\n                 v.push_back(key);\\n            \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596000,
                "title": "c-solution-with-dummies-explanation",
                "content": "```\\nLRU CACHE->Least Recently Used Cache \\nHow it Works:\\n\\n______________\\n|___|____|___|   <------Cache Size = 3\\n\\nInitially Empty.\\nLet Our Page requests be [1,3,4,5,3].\\n\\n1 is not present in the cache so its a cache miss. It get placed inot the cache.\\n __ __ ____ ____\\n|_____|____|__1_|  <------1 gets place at the back of the cache.\\n\\nsimilarly 3 and 4 are cache misses and will be the placed into the cache.\\n\\n __ __ ____ ____\\n|__4__|__3_|__1_|  <------3 and 4 gets place at the successive order of the cache.\\n\\nNow when 5 comes in it again a cache miss but there is no locaction to place it.\\nHere the actual working of the LRU algorithm works.\\nIt removes the LEAST RECENTLY USED element i.e the leftmost element.\\n\\n __ __ ____ ____\\n|__5__|_4__|__3_|  <------5 gets place at the front of the cache and 3 and 4 gets shifted to the right.\\n\\nNow when 3 comes in its not a cache miss. but it is going to be recently used.The recently used elements \\nare present at the leftmost side. so we shift all the elements to the left and place 3 at the leftmost location.\\n\\n __ __ ____ ____\\n|__3__|__5_|__4_|  <------3 gets place at the front of the cache.\\n\\n\\nSo we can sum up and write the algorithm as such\\n\\nFor get function\\n1. If the element is not found we return -1.\\n2. If found we erase that element by making sure the relative locations of the other elements are intact.\\n\\nFor put function\\n1. If the element is found in the cache we erase it and put it back to the front(as it becomed the most recently used element).\\n2. If the element is not found there are 2 cases to look for:\\n   Case 2a: if the cache size if full erase the last element and place the new element at the front of the cache.\\n   Case 2b: if the cache size is not full we simply place the element at the right location of the previously recently used element.\\n\\n\\nclass LRUCache {\\nprivate:\\n    int cache_size;\\n    deque<int> cache;\\n    unordered_map<int,int> map;\\npublic:\\n    LRUCache(int capacity) {\\n        cache_size=capacity;\\n        cache.clear();\\n        map.clear();\\n    }\\n    \\n    int get(int key) {\\n        if(map.find(key)==map.end())return -1;\\n        deque<int>::iterator it=cache.begin();\\n        while(*it!=key)\\n        {\\n            it++;\\n        }\\n        cache.erase(it);\\n        cache.push_front(key);\\n        return map[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(map.find(key)==map.end())\\n        {\\n            if(cache_size==cache.size())\\n            {\\n                int last=cache.back();\\n                cache.pop_back();\\n                map.erase(last);\\n            }\\n        }\\n        else\\n        {\\n            deque<int>::iterator it=cache.begin();\\n            while(*it!=key)it++;\\n            cache.erase(it);\\n            map.erase(key);\\n        }\\n        cache.push_front(key);\\n        map[key]=value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nLRU CACHE->Least Recently Used Cache \\nHow it Works:\\n\\n______________\\n|___|____|___|   <------Cache Size = 3\\n\\nInitially Empty.\\nLet Our Page requests be [1,3,4,5,3].\\n\\n1 is not present in the cache so its a cache miss. It get placed inot the cache.\\n __ __ ____ ____\\n|_____|____|__1_|  <------1 gets place at the back of the cache.\\n\\nsimilarly 3 and 4 are cache misses and will be the placed into the cache.\\n\\n __ __ ____ ____\\n|__4__|__3_|__1_|  <------3 and 4 gets place at the successive order of the cache.\\n\\nNow when 5 comes in it again a cache miss but there is no locaction to place it.\\nHere the actual working of the LRU algorithm works.\\nIt removes the LEAST RECENTLY USED element i.e the leftmost element.\\n\\n __ __ ____ ____\\n|__5__|_4__|__3_|  <------5 gets place at the front of the cache and 3 and 4 gets shifted to the right.\\n\\nNow when 3 comes in its not a cache miss. but it is going to be recently used.The recently used elements \\nare present at the leftmost side. so we shift all the elements to the left and place 3 at the leftmost location.\\n\\n __ __ ____ ____\\n|__3__|__5_|__4_|  <------3 gets place at the front of the cache.\\n\\n\\nSo we can sum up and write the algorithm as such\\n\\nFor get function\\n1. If the element is not found we return -1.\\n2. If found we erase that element by making sure the relative locations of the other elements are intact.\\n\\nFor put function\\n1. If the element is found in the cache we erase it and put it back to the front(as it becomed the most recently used element).\\n2. If the element is not found there are 2 cases to look for:\\n   Case 2a: if the cache size if full erase the last element and place the new element at the front of the cache.\\n   Case 2b: if the cache size is not full we simply place the element at the right location of the previously recently used element.\\n\\n\\nclass LRUCache {\\nprivate:\\n    int cache_size;\\n    deque<int> cache;\\n    unordered_map<int,int> map;\\npublic:\\n    LRUCache(int capacity) {\\n        cache_size=capacity;\\n        cache.clear();\\n        map.clear();\\n    }\\n    \\n    int get(int key) {\\n        if(map.find(key)==map.end())return -1;\\n        deque<int>::iterator it=cache.begin();\\n        while(*it!=key)\\n        {\\n            it++;\\n        }\\n        cache.erase(it);\\n        cache.push_front(key);\\n        return map[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(map.find(key)==map.end())\\n        {\\n            if(cache_size==cache.size())\\n            {\\n                int last=cache.back();\\n                cache.pop_back();\\n                map.erase(last);\\n            }\\n        }\\n        else\\n        {\\n            deque<int>::iterator it=cache.begin();\\n            while(*it!=key)it++;\\n            cache.erase(it);\\n            map.erase(key);\\n        }\\n        cache.push_front(key);\\n        map[key]=value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363611,
                "title": "python-double-linked-list-no-dummy-nodes",
                "content": "```\\nclass Node(object):\\n    def __init__(self, key, x):\\n        self.key = key\\n        self.value = x\\n        self.next = None\\n        self.prev = None\\n    \\nclass LRUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity    \\n        self.dic = {}\\n        self.head = None\\n        self.tail = None\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key in self.dic:\\n            node = self.dic[key]\\n            self.makeMostRecent(node)\\n            return node.value\\n        else:\\n            return -1\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if key not in self.dic:\\n            # Invalidate oldest if required:\\n            if len(self.dic) == self.capacity:\\n                del self.dic[self.head.key]\\n                self.removeHead()\\n            node = Node(key, value)\\n            self.dic[key] = node\\n        else:\\n            # Update the value:\\n            node = self.dic[key]\\n            node.value = value\\n        self.makeMostRecent(node)\\n            \\n    def makeMostRecent(self, node):\\n        if self.head and self.head.key == node.key:\\n            self.removeHead()\\n        # Make this item the most recently accessed (tail):\\n        if self.tail and not self.tail.key == node.key:\\n            if node.prev:\\n                node.prev.next = node.next\\n            if node.next:\\n                node.next.prev = node.prev\\n            node.next = None\\n            self.tail.next = node  # Old tail\\'s next is the node.\\n            node.prev = self.tail  # Node\\'s previous is the old tail.\\n        self.tail = node  # New tail is the node.\\n        if not self.head:\\n            self.head = node  # If this is the first item make it the head as well as tail.\\n    \\n    def removeHead(self):\\n        self.head = self.head.next\\n        if self.head:\\n            self.head.prev = None\\n```",
                "solutionTags": [
                    "Python",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self, key, x):\\n        self.key = key\\n        self.value = x\\n        self.next = None\\n        self.prev = None\\n    \\nclass LRUCache(object):\\n    def __init__(self, capacity):\\n        \"\"\"\\n        :type capacity: int\\n        \"\"\"\\n        self.capacity = capacity    \\n        self.dic = {}\\n        self.head = None\\n        self.tail = None\\n\\n    def get(self, key):\\n        \"\"\"\\n        :type key: int\\n        :rtype: int\\n        \"\"\"\\n        if key in self.dic:\\n            node = self.dic[key]\\n            self.makeMostRecent(node)\\n            return node.value\\n        else:\\n            return -1\\n\\n    def put(self, key, value):\\n        \"\"\"\\n        :type key: int\\n        :type value: int\\n        :rtype: None\\n        \"\"\"\\n        if key not in self.dic:\\n            # Invalidate oldest if required:\\n            if len(self.dic) == self.capacity:\\n                del self.dic[self.head.key]\\n                self.removeHead()\\n            node = Node(key, value)\\n            self.dic[key] = node\\n        else:\\n            # Update the value:\\n            node = self.dic[key]\\n            node.value = value\\n        self.makeMostRecent(node)\\n            \\n    def makeMostRecent(self, node):\\n        if self.head and self.head.key == node.key:\\n            self.removeHead()\\n        # Make this item the most recently accessed (tail):\\n        if self.tail and not self.tail.key == node.key:\\n            if node.prev:\\n                node.prev.next = node.next\\n            if node.next:\\n                node.next.prev = node.prev\\n            node.next = None\\n            self.tail.next = node  # Old tail\\'s next is the node.\\n            node.prev = self.tail  # Node\\'s previous is the old tail.\\n        self.tail = node  # New tail is the node.\\n        if not self.head:\\n            self.head = node  # If this is the first item make it the head as well as tail.\\n    \\n    def removeHead(self):\\n        self.head = self.head.next\\n        if self.head:\\n            self.head.prev = None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45995,
                "title": "c-solution",
                "content": "```\\npublic class LRUCache {\\n    private int capacity = 0;\\n    private LinkedList<int[]> list = new LinkedList<int[]>();\\n    private Dictionary<int, LinkedListNode<int[]>> dict = new Dictionary<int, LinkedListNode<int[]>>();\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if (!dict.ContainsKey(key))\\n            return -1;\\n        \\n        Reorder(dict[key]);\\n        \\n        return dict[key].Value[1];\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if (dict.ContainsKey(key))\\n            dict[key].Value[1] = value;\\n        else\\n        {\\n            if (dict.Count == this.capacity)\\n            {\\n                dict.Remove(list.Last.Value[0]);\\n                list.RemoveLast();\\n            }\\n            \\n            dict.Add(key, new LinkedListNode<int[]>(new int[] { key, value }));\\n        }\\n        \\n        Reorder(dict[key]);\\n    }\\n    \\n    private void Reorder(LinkedListNode<int[]> node)\\n    {\\n        if (node.Previous != null)\\n            list.Remove(node);\\n        \\n        if (list.First != node)\\n            list.AddFirst(node);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\npublic class LRUCache {\\n    private int capacity = 0;\\n    private LinkedList<int[]> list = new LinkedList<int[]>();\\n    private Dictionary<int, LinkedListNode<int[]>> dict = new Dictionary<int, LinkedListNode<int[]>>();\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n    \\n    public int Get(int key) {\\n        if (!dict.ContainsKey(key))\\n            return -1;\\n        \\n        Reorder(dict[key]);\\n        \\n        return dict[key].Value[1];\\n    }\\n    \\n    public void Put(int key, int value) {\\n        if (dict.ContainsKey(key))\\n            dict[key].Value[1] = value;\\n        else\\n        {\\n            if (dict.Count == this.capacity)\\n            {\\n                dict.Remove(list.Last.Value[0]);\\n                list.RemoveLast();\\n            }\\n            \\n            dict.Add(key, new LinkedListNode<int[]>(new int[] { key, value }));\\n        }\\n        \\n        Reorder(dict[key]);\\n    }\\n    \\n    private void Reorder(LinkedListNode<int[]> node)\\n    {\\n        if (node.Previous != null)\\n            list.Remove(node);\\n        \\n        if (list.First != node)\\n            list.AddFirst(node);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 46121,
                "title": "lru-cache-implementation-in-python-w-explanation",
                "content": "Note: I have used the Python 3 `print` function to better print the cache at any point (I still use Python 2.6!)\\n\\nThe basic idea behind the LRU cache is that we want to query our queue in `O(1)`/constant time. We also want to insert into the cache in `O(1)` time. Therefore, `get`, `set` should always run in constant time. This is the reason we use a hash map or a static array (of a given size with an appropriate hash function) to retrieve items in constant time.\\n\\nHere's what my LRU cache looks like:\\n\\n    Entity LRUCache(object):\\n        hash map = {}\\n\\n        # No explicit doubly linked queue here (you may create one yourself)\\n        head = Null\\n        end = Null\\n\\n        capacity \\n        current_size\\n\\nI have defined `head` and `end` pointers explicitly in the cache. You might want to create a new class (`DLLQueue`) to handle the operations explicitly but thats up to you.\\n\\nHere's what my node looks like:\\n\\n    \"\"\"\\n    QNode:\\n        _________\\n        |p      |\\n        |   X   |\\n        |______n|\\n\\n    \"\"\"\\n\\n    Entity QNode(object):\\n        key\\n        value\\n        prev = Null\\n        next = Null\\n\\nA simple doubly linked queue looks like (insert at head and dequeue at end; you may still remove from anywhere else):\\n\\n    \"\"\"\\n    HEAD & END point to 0 (NULL) at the start.\\n    ____\\n    |0 |\\n    |__|\\n     ^^\\n     HE\\n\\n    1. Insert 1st Node (HEAD => A <= END)\\n        ____\\n    0 <-|A |\\n        |__|-> 0\\n         ^^ \\n         HE \\n\\n    2. Insert 2nd Node\\n        ____  ____\\n    0 <-|A |<-|B |\\n        |__|->|__|->0\\n         ^     ^\\n         E     H\\n    \"\"\"\\n\\nHere's the code. \\n\\nYou would need to comment out the first line and the print function as it won't be accepted. Leetcode adds some metadata before submitting your piece of code; won't work with the __future__ command.\\n\\n    from __future__ import print_function\\n\\n    \"\"\"\\n    QNode -> holds key and value; as well as pointers to previous and next nodes.\\n    \"\"\"\\n    class QNode(object):\\n        def __init__(self, key, value):\\n            self.key = key\\n            self.value = value\\n            self.prev = None\\n            self.next = None\\n\\n\\n        def __str__(self):\\n            return \"(%s, %s)\" % (self.key, self.value)\\n\\n\\n    class LRUCache(object):\\n        def __init__(self, capacity):\\n            \"\"\"\\n            :type capacity: int\\n            \"\"\"\\n            if capacity <= 0:\\n                raise ValueError(\"capacity > 0\")\\n            self.hash_map = {}\\n\\n            # No explicit doubly linked queue here (you may create one yourself)\\n            self.head = None\\n            self.end = None\\n\\n            self.capacity = capacity\\n            self.current_size = 0\\n\\n\\n        # PUBLIC\\n\\n\\n        def get(self, key):\\n            \"\"\"\\n            :rtype: int\\n            \"\"\"\\n            if key not in self.hash_map:\\n                return -1\\n            \\n            node = self.hash_map[key]\\n\\n            # small optimization (1): just return the value if we are already looking at head\\n            if self.head == node:\\n                return node.value\\n            self.remove(node)\\n            self.set_head(node)\\n            return node.value\\n            \\n\\n        def set(self, key, value):\\n            \"\"\"\\n            :type key: int\\n            :type value: int\\n            :rtype: nothing\\n            \"\"\"\\n            if key in self.hash_map:\\n                node = self.hash_map[key]\\n                node.value = value\\n\\n                # small optimization (2): update pointers only if this is not head; otherwise return\\n                if self.head != node:\\n                    self.remove(node)\\n                    self.set_head(node)\\n            else:\\n                new_node = QNode(key, value)\\n                if self.current_size == self.capacity:\\n                    del self.hash_map[self.end.key]\\n                    self.remove(self.end)\\n                self.set_head(new_node)\\n                self.hash_map[key] = new_node\\n\\n\\n        # PRIVATE\\n\\n        def set_head(self, node):\\n            if not self.head:\\n                self.head = node\\n                self.end = node\\n            else:\\n                node.prev = self.head\\n                self.head.next = node\\n                self.head = node\\n            self.current_size += 1\\n\\n\\n        def remove(self, node):\\n            if not self.head:\\n                return\\n\\n            # removing the node from somewhere in the middle; update pointers\\n            if node.prev:\\n                node.prev.next = node.next\\n            if node.next:\\n                node.next.prev = node.prev\\n\\n            # head = end = node\\n            if not node.next and not node.prev:\\n                self.head = None\\n                self.end = None\\n\\n            # if the node we are removing is the one at the end, update the new end\\n            # also not completely necessary but set the new end's previous to be NULL\\n            if self.end == node:\\n                self.end = node.next\\n                self.end.prev = None\\n            self.current_size -= 1\\n            return node\\n\\n\\n        def print_elements(self):\\n            n = self.head\\n            print(\"[head = %s, end = %s]\" % (self.head, self.end), end=\" \")\\n            while n:\\n                print(\"%s -> \" % (n), end = \"\")\\n                n = n.prev\\n            print(\"NULL\")",
                "solutionTags": [
                    "Python"
                ],
                "code": "Note: I have used the Python 3 `print` function to better print the cache at any point (I still use Python 2.6!)\\n\\nThe basic idea behind the LRU cache is that we want to query our queue in `O(1)`/constant time. We also want to insert into the cache in `O(1)` time. Therefore, `get`, `set` should always run in constant time. This is the reason we use a hash map or a static array (of a given size with an appropriate hash function) to retrieve items in constant time.\\n\\nHere's what my LRU cache looks like:\\n\\n    Entity LRUCache(object):\\n        hash map = {}\\n\\n        # No explicit doubly linked queue here (you may create one yourself)\\n        head = Null\\n        end = Null\\n\\n        capacity \\n        current_size\\n\\nI have defined `head` and `end` pointers explicitly in the cache. You might want to create a new class (`DLLQueue`) to handle the operations explicitly but thats up to you.\\n\\nHere's what my node looks like:\\n\\n    \"\"\"\\n    QNode:\\n        _________\\n        |p      |\\n        |   X   |\\n        |______n|\\n\\n    \"\"\"\\n\\n    Entity QNode(object):\\n        key\\n        value\\n        prev = Null\\n        next = Null\\n\\nA simple doubly linked queue looks like (insert at head and dequeue at end; you may still remove from anywhere else):\\n\\n    \"\"\"\\n    HEAD & END point to 0 (NULL) at the start.\\n    ____\\n    |0 |\\n    |__|\\n     ^^\\n     HE\\n\\n    1. Insert 1st Node (HEAD => A <= END)\\n        ____\\n    0 <-|A |\\n        |__|-> 0\\n         ^^ \\n         HE \\n\\n    2. Insert 2nd Node\\n        ____  ____\\n    0 <-|A |<-|B |\\n        |__|->|__|->0\\n         ^     ^\\n         E     H\\n    \"\"\"\\n\\nHere's the code. \\n\\nYou would need to comment out the first line and the print function as it won't be accepted. Leetcode adds some metadata before submitting your piece of code; won't work with the __future__ command.\\n\\n    from __future__ import print_function\\n\\n    \"\"\"\\n    QNode -> holds key and value; as well as pointers to previous and next nodes.\\n    \"\"\"\\n    class QNode(object):\\n        def __init__(self, key, value):\\n            self.key = key\\n            self.value = value\\n            self.prev = None\\n            self.next = None\\n\\n\\n        def __str__(self):\\n            return \"(%s, %s)\" % (self.key, self.value)\\n\\n\\n    class LRUCache(object):\\n        def __init__(self, capacity):\\n            \"\"\"\\n            :type capacity: int\\n            \"\"\"\\n            if capacity <= 0:\\n                raise ValueError(\"capacity > 0\")\\n            self.hash_map = {}\\n\\n            # No explicit doubly linked queue here (you may create one yourself)\\n            self.head = None\\n            self.end = None\\n\\n            self.capacity = capacity\\n            self.current_size = 0\\n\\n\\n        # PUBLIC\\n\\n\\n        def get(self, key):\\n            \"\"\"\\n            :rtype: int\\n            \"\"\"\\n            if key not in self.hash_map:\\n                return -1\\n            \\n            node = self.hash_map[key]\\n\\n            # small optimization (1): just return the value if we are already looking at head\\n            if self.head == node:\\n                return node.value\\n            self.remove(node)\\n            self.set_head(node)\\n            return node.value\\n            \\n\\n        def set(self, key, value):\\n            \"\"\"\\n            :type key: int\\n            :type value: int\\n            :rtype: nothing\\n            \"\"\"\\n            if key in self.hash_map:\\n                node = self.hash_map[key]\\n                node.value = value\\n\\n                # small optimization (2): update pointers only if this is not head; otherwise return\\n                if self.head != node:\\n                    self.remove(node)\\n                    self.set_head(node)\\n            else:\\n                new_node = QNode(key, value)\\n                if self.current_size == self.capacity:\\n                    del self.hash_map[self.end.key]\\n                    self.remove(self.end)\\n                self.set_head(new_node)\\n                self.hash_map[key] = new_node\\n\\n\\n        # PRIVATE\\n\\n        def set_head(self, node):\\n            if not self.head:\\n                self.head = node\\n                self.end = node\\n            else:\\n                node.prev = self.head\\n                self.head.next = node\\n                self.head = node\\n            self.current_size += 1\\n\\n\\n        def remove(self, node):\\n            if not self.head:\\n                return\\n\\n            # removing the node from somewhere in the middle; update pointers\\n            if node.prev:\\n                node.prev.next = node.next\\n            if node.next:\\n                node.next.prev = node.prev\\n\\n            # head = end = node\\n            if not node.next and not node.prev:\\n                self.head = None\\n                self.end = None\\n\\n            # if the node we are removing is the one at the end, update the new end\\n            # also not completely necessary but set the new end's previous to be NULL\\n            if self.end == node:\\n                self.end = node.next\\n                self.end.prev = None\\n            self.current_size -= 1\\n            return node\\n\\n\\n        def print_elements(self):\\n            n = self.head\\n            print(\"[head = %s, end = %s]\" % (self.head, self.end), end=\" \")\\n            while n:\\n                print(\"%s -> \" % (n), end = \"\")\\n                n = n.prev\\n            print(\"NULL\")",
                "codeTag": "Java"
            },
            {
                "id": 46221,
                "title": "share-my-two-python-solutions",
                "content": "The first one uses deque and dictionary, quite simple but slow\\n\\n    from collections import deque\\n    \\n    class LRUCache:\\n        # @param capacity, an integer\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            # use dictionary to simulate LRU cache, deque to store cache usage order\\n            self.cache = dict()\\n            self.order = deque()\\n    \\n        # @return an integer\\n        def get(self, key):\\n            if key in self.cache:\\n                value = self.cache[key]\\n                # remove and append to tail\\n                self.order.remove(key)\\n                self.order.append(key)\\n                return value\\n            else:\\n                return -1\\n    \\n        # @param key, an integer\\n        # @param value, an integer\\n        # @return nothing\\n        def set(self, key, value):\\n            if key in self.cache:\\n                # remove key\\n                self.order.remove(key)\\n            self.cache[key] = value\\n            self.order.append(key)\\n            # remove an item (oldest) if cache is full\\n            if len(self.cache) > self.capacity:\\n                oldest = self.order.popleft()\\n                del self.cache[oldest]\\n\\nThe 2nd one uses OrderedDict. Simpler and much faster\\n\\n    from collections import OrderedDict\\n    \\n    class LRUCache:\\n        # @param capacity, an integer\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            # use OrderedDict to simulate LRU cache\\n            self.cache = OrderedDict()\\n    \\n        # @return an integer\\n        def get(self, key):\\n            if key in self.cache:\\n                value = self.cache[key]\\n                # remove key then add it again\\n                del self.cache[key]\\n                self.cache[key] = value\\n                return value\\n            else:\\n                return -1\\n    \\n        # @param key, an integer\\n        # @param value, an integer\\n        # @return nothing\\n        def set(self, key, value):\\n            if key in self.cache:\\n                # remove key if already in cache\\n                del self.cache[key]\\n            self.cache[key] = value\\n            # pop an item (oldest) if cache is full\\n            if len(self.cache) > self.capacity:\\n                self.cache.popitem(False)",
                "solutionTags": [
                    "Python"
                ],
                "code": "The first one uses deque and dictionary, quite simple but slow\\n\\n    from collections import deque\\n    \\n    class LRUCache:\\n        # @param capacity, an integer\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            # use dictionary to simulate LRU cache, deque to store cache usage order\\n            self.cache = dict()\\n            self.order = deque()\\n    \\n        # @return an integer\\n        def get(self, key):\\n            if key in self.cache:\\n                value = self.cache[key]\\n                # remove and append to tail\\n                self.order.remove(key)\\n                self.order.append(key)\\n                return value\\n            else:\\n                return -1\\n    \\n        # @param key, an integer\\n        # @param value, an integer\\n        # @return nothing\\n        def set(self, key, value):\\n            if key in self.cache:\\n                # remove key\\n                self.order.remove(key)\\n            self.cache[key] = value\\n            self.order.append(key)\\n            # remove an item (oldest) if cache is full\\n            if len(self.cache) > self.capacity:\\n                oldest = self.order.popleft()\\n                del self.cache[oldest]\\n\\nThe 2nd one uses OrderedDict. Simpler and much faster\\n\\n    from collections import OrderedDict\\n    \\n    class LRUCache:\\n        # @param capacity, an integer\\n        def __init__(self, capacity):\\n            self.capacity = capacity\\n            # use OrderedDict to simulate LRU cache\\n            self.cache = OrderedDict()\\n    \\n        # @return an integer\\n        def get(self, key):\\n            if key in self.cache:\\n                value = self.cache[key]\\n                # remove key then add it again\\n                del self.cache[key]\\n                self.cache[key] = value\\n                return value\\n            else:\\n                return -1\\n    \\n        # @param key, an integer\\n        # @param value, an integer\\n        # @return nothing\\n        def set(self, key, value):\\n            if key in self.cache:\\n                # remove key if already in cache\\n                del self.cache[key]\\n            self.cache[key] = value\\n            # pop an item (oldest) if cache is full\\n            if len(self.cache) > self.capacity:\\n                self.cache.popitem(False)",
                "codeTag": "Java"
            },
            {
                "id": 3781266,
                "title": "c-linked-list-map",
                "content": "# Code\\n```\\nclass LRUCache {\\npublic:\\n    struct node{\\n        int key,val;\\n        node *prev;\\n        node *next;\\n        node(int k,int v){\\n            key = k;\\n            val = v;\\n        }\\n    };\\n    int cap=0;\\n    node *head = new node(-1,-1);\\n    node *tail = new node(-1,-1);\\n    unordered_map<int,node *>m;\\n    LRUCache(int capi) {\\n        cap =capi;     \\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    void deletenode(node *n){\\n            node *n1=n->prev;\\n            node *n2 = n->next;\\n            n1->next=n2;\\n            n2->prev=n1;\\n    }\\n    void addnode(node *n){\\n        node *n1 = head->next;\\n        head->next = n;\\n        n->next = n1;\\n        n->prev= head;\\n        n1->prev = n;\\n    }\\n    int get(int key) {\\n        if(m.find(key)==m.end())return -1;\\n        node * address = m[key];\\n        int ans = address->val;\\n     //  m.erase(key);\\n        deletenode(address);\\n        addnode(address);\\n      //  m[key] = head->next;\\n        return ans;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.find(key)!=m.end()){\\n            node * add = m[key];\\n          //  m.erase(add->key);\\n            deletenode(add);\\n            addnode(add);\\n            head->next->val = value;\\n        }\\n        else{\\n        if(m.size()==cap){\\n            m.erase(tail->prev->key);\\n            deletenode(tail->prev);\\n        }\\n        addnode(new node(key,value));\\n        m[key] = head->next;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a7fd5b09-e90a-4397-b4a7-31fd8b871dee_1689656038.7712836.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    struct node{\\n        int key,val;\\n        node *prev;\\n        node *next;\\n        node(int k,int v){\\n            key = k;\\n            val = v;\\n        }\\n    };\\n    int cap=0;\\n    node *head = new node(-1,-1);\\n    node *tail = new node(-1,-1);\\n    unordered_map<int,node *>m;\\n    LRUCache(int capi) {\\n        cap =capi;     \\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    void deletenode(node *n){\\n            node *n1=n->prev;\\n            node *n2 = n->next;\\n            n1->next=n2;\\n            n2->prev=n1;\\n    }\\n    void addnode(node *n){\\n        node *n1 = head->next;\\n        head->next = n;\\n        n->next = n1;\\n        n->prev= head;\\n        n1->prev = n;\\n    }\\n    int get(int key) {\\n        if(m.find(key)==m.end())return -1;\\n        node * address = m[key];\\n        int ans = address->val;\\n     //  m.erase(key);\\n        deletenode(address);\\n        addnode(address);\\n      //  m[key] = head->next;\\n        return ans;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.find(key)!=m.end()){\\n            node * add = m[key];\\n          //  m.erase(add->key);\\n            deletenode(add);\\n            addnode(add);\\n            head->next->val = value;\\n        }\\n        else{\\n        if(m.size()==cap){\\n            m.erase(tail->prev->key);\\n            deletenode(tail->prev);\\n        }\\n        addnode(new node(key,value));\\n        m[key] = head->next;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780788,
                "title": "c-uses-self-dll-stl-list-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse C++ Doubly linked list list and unordered_map to make programming easier!\\n\\nOr it can be done by self made Doubly linked list!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAn update means remove and then insert! Both of get and put need update!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\nclass LRUCache {\\npublic:\\n    list<pair<int, int>> dll;  // Doubly linked list to store key-value\\n    unordered_map<int, list<pair<int, int>>::iterator> mp; \\n    int size;                 \\n\\n    LRUCache(int size) :size(size) {}\\n\\n    int get(int key) {\\n        // Check wether the key exists in the cache\\n        if (mp.count(key) == 0)\\n            return -1; // Key not found, return -1\\n\\n        auto Iterator = mp[key];                           \\n        auto Pair = *Iterator;                     \\n        dll.erase(Iterator);                                \\n        dll.push_front(Pair);                               \\n        auto newIterator = dll.begin();                      \\n        mp[key] = newIterator;\\n\\n        return Pair.second;                              \\n    }\\n\\n    void put(int key, int value) {\\n        // Check wether the key is in the cache\\n        if (mp.count(key) > 0) {\\n            \\n            auto Iterator = mp[key];                        \\n            auto Pair = *Iterator;                   \\n            dll.erase(Iterator);                               \\n            dll.push_front({key, value});                             \\n            mp[key] = dll.begin();                                      \\n            return;\\n        }\\n\\n        // check wether the cache is full\\n        if (dll.size() == size) {\\n            // Cache is full, remove the oldest used element\\n            auto lastElement = dll.back();                             \\n            mp.erase(lastElement.first);                               \\n            dll.pop_back();                                             \\n        }\\n   \\n        dll.push_front({key, value});                                  \\n        mp[key] = dll.begin();                                           \\n    }\\n};\\n\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\\n# Code for self-made DLL\\n```\\nstruct Node{\\n    int key;\\n    int value;\\n    Node* next;\\n    Node* prev;\\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\\n    Node(int key, int value): key(key), value(value), next(NULL), prev(NULL)\\n    {}\\n};\\nclass LRUCache {\\n    Node* head=new Node();\\n    Node* tail=new Node();\\n    int capacity;\\n    unordered_map<int, Node*> map;\\npublic:\\n    LRUCache(int capacity): capacity(capacity) {\\n        head->next=tail;\\n        tail->prev=head;\\n    }\\n    void add(Node* curr){\\n        curr->next=head->next;\\n        head->next->prev=curr;\\n        head->next=curr;\\n        curr->prev=head;\\n        map[curr->key]=curr;\\n    }\\n\\n    void erase(Node* ptr){\\n        map.erase(ptr->key);\\n        ptr->next->prev=ptr->prev;\\n        ptr->prev->next=ptr->next;\\n    }\\n    \\n    int get(int key) {\\n        if (map.count(key)==0) return -1;\\n        Node* curr=map[key];\\n        erase(curr);\\n        add(curr);\\n        return curr->value;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if (map.count(key)>0) erase(map[key]);\\n        if (map.size()==capacity) erase(tail->prev);\\n        add(new Node(key, value));\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    list<pair<int, int>> dll;  // Doubly linked list to store key-value\\n    unordered_map<int, list<pair<int, int>>::iterator> mp; \\n    int size;                 \\n\\n    LRUCache(int size) :size(size) {}\\n\\n    int get(int key) {\\n        // Check wether the key exists in the cache\\n        if (mp.count(key) == 0)\\n            return -1; // Key not found, return -1\\n\\n        auto Iterator = mp[key];                           \\n        auto Pair = *Iterator;                     \\n        dll.erase(Iterator);                                \\n        dll.push_front(Pair);                               \\n        auto newIterator = dll.begin();                      \\n        mp[key] = newIterator;\\n\\n        return Pair.second;                              \\n    }\\n\\n    void put(int key, int value) {\\n        // Check wether the key is in the cache\\n        if (mp.count(key) > 0) {\\n            \\n            auto Iterator = mp[key];                        \\n            auto Pair = *Iterator;                   \\n            dll.erase(Iterator);                               \\n            dll.push_front({key, value});                             \\n            mp[key] = dll.begin();                                      \\n            return;\\n        }\\n\\n        // check wether the cache is full\\n        if (dll.size() == size) {\\n            // Cache is full, remove the oldest used element\\n            auto lastElement = dll.back();                             \\n            mp.erase(lastElement.first);                               \\n            dll.pop_back();                                             \\n        }\\n   \\n        dll.push_front({key, value});                                  \\n        mp[key] = dll.begin();                                           \\n    }\\n};\\n\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```\n```\\nstruct Node{\\n    int key;\\n    int value;\\n    Node* next;\\n    Node* prev;\\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\\n    Node(int key, int value): key(key), value(value), next(NULL), prev(NULL)\\n    {}\\n};\\nclass LRUCache {\\n    Node* head=new Node();\\n    Node* tail=new Node();\\n    int capacity;\\n    unordered_map<int, Node*> map;\\npublic:\\n    LRUCache(int capacity): capacity(capacity) {\\n        head->next=tail;\\n        tail->prev=head;\\n    }\\n    void add(Node* curr){\\n        curr->next=head->next;\\n        head->next->prev=curr;\\n        head->next=curr;\\n        curr->prev=head;\\n        map[curr->key]=curr;\\n    }\\n\\n    void erase(Node* ptr){\\n        map.erase(ptr->key);\\n        ptr->next->prev=ptr->prev;\\n        ptr->prev->next=ptr->next;\\n    }\\n    \\n    int get(int key) {\\n        if (map.count(key)==0) return -1;\\n        Node* curr=map[key];\\n        erase(curr);\\n        add(curr);\\n        return curr->value;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if (map.count(key)>0) erase(map[key]);\\n        if (map.size()==capacity) erase(tail->prev);\\n        add(new Node(key, value));\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432059,
                "title": "beat-94-23-727ms-python3-easy-understanding-ordereddict-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import OrderedDict\\nclass LRUCache:\\n\\n    def __init__(self, capacity):\\n        self.odict = OrderedDict()\\n        self.capacity = capacity\\n\\n    def get(self, key):\\n        if key not in self.odict:\\n            return -1\\n        else:\\n            self.odict.move_to_end(key)\\n            return self.odict[key]\\n\\n    def put(self, key, value):\\n        if key in self.odict:\\n            self.odict[key] = value\\n            self.odict.move_to_end(key)\\n        else:\\n            self.odict[key] = value\\n            if len(self.odict) > self.capacity:\\n                self.odict.popitem(last = False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import OrderedDict\\nclass LRUCache:\\n\\n    def __init__(self, capacity):\\n        self.odict = OrderedDict()\\n        self.capacity = capacity\\n\\n    def get(self, key):\\n        if key not in self.odict:\\n            return -1\\n        else:\\n            self.odict.move_to_end(key)\\n            return self.odict[key]\\n\\n    def put(self, key, value):\\n        if key in self.odict:\\n            self.odict[key] = value\\n            self.odict.move_to_end(key)\\n        else:\\n            self.odict[key] = value\\n            if len(self.odict) > self.capacity:\\n                self.odict.popitem(last = False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115730,
                "title": "c-striver-approach-doubly-linked-list-hashmap",
                "content": "```\\nclass LRUCache {\\npublic:\\n    class node{\\n        public:\\n        int key;\\n        int val;\\n        node* next;\\n        node* prev;\\n        node(int _key, int _val){\\n            key = _key;\\n            val = _val;\\n        }\\n    };\\n    \\n   node * head = new node(-1, -1);\\n  node * tail = new node(-1, -1);\\n   \\n    int cap;\\n    unordered_map<int, node*> mp;\\n    \\n    LRUCache(int capacity) {\\n       cap = capacity;\\n       head->next = tail;\\n       tail->prev = head;\\n    }\\n    \\n    void addNode(node* newnode){\\n        node*temp = head->next;\\n        newnode->next = temp;\\n        newnode->prev = head;\\n        head->next = newnode;\\n        temp->prev = newnode;\\n    }\\n    \\n    void deleteNode(node* delnode){\\n        node* deleteprev = delnode->prev;\\n        node* deletenext = delnode->next;\\n        deleteprev->next =  deletenext;\\n        deletenext->prev =  deleteprev;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key) != mp.end()){\\n            node* tempnode = mp[key];\\n            int ans = tempnode->val;\\n            mp.erase(key);\\n            deleteNode(tempnode);\\n            addNode(tempnode);\\n            mp[key] = head->next;\\n            return ans;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n       if(mp.find(key) != mp.end()){\\n         node* tempnode = mp[key];\\n           mp.erase(key);\\n           deleteNode(tempnode);\\n       } \\n        \\n        if(mp.size()==cap){\\n            mp.erase(tail->prev->key);\\n            deleteNode(tail->prev);\\n        }\\n        \\n        addNode(new node(key,value));\\n        mp[key] = head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass LRUCache {\\npublic:\\n    class node{\\n        public:\\n        int key;\\n        int val;\\n        node* next;\\n        node* prev;\\n        node(int _key, int _val){\\n            key = _key;\\n            val = _val;\\n        }\\n    };\\n    \\n   node * head = new node(-1, -1);\\n  node * tail = new node(-1, -1);\\n   \\n    int cap;\\n    unordered_map<int, node*> mp;\\n    \\n    LRUCache(int capacity) {\\n       cap = capacity;\\n       head->next = tail;\\n       tail->prev = head;\\n    }\\n    \\n    void addNode(node* newnode){\\n        node*temp = head->next;\\n        newnode->next = temp;\\n        newnode->prev = head;\\n        head->next = newnode;\\n        temp->prev = newnode;\\n    }\\n    \\n    void deleteNode(node* delnode){\\n        node* deleteprev = delnode->prev;\\n        node* deletenext = delnode->next;\\n        deleteprev->next =  deletenext;\\n        deletenext->prev =  deleteprev;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key) != mp.end()){\\n            node* tempnode = mp[key];\\n            int ans = tempnode->val;\\n            mp.erase(key);\\n            deleteNode(tempnode);\\n            addNode(tempnode);\\n            mp[key] = head->next;\\n            return ans;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n       if(mp.find(key) != mp.end()){\\n         node* tempnode = mp[key];\\n           mp.erase(key);\\n           deleteNode(tempnode);\\n       } \\n        \\n        if(mp.size()==cap){\\n            mp.erase(tail->prev->key);\\n            deleteNode(tail->prev);\\n        }\\n        \\n        addNode(new node(key,value));\\n        mp[key] = head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930272,
                "title": "idiomatic-c-solution",
                "content": "C# solution using the language common idiom. \\n\\n```csharp\\npublic class LRUCache \\n{\\n    private readonly int _capacity;\\n    private readonly Dictionary<int, LinkedListNode<KeyValuePair<int, int>>> _cache;\\n    private readonly LinkedList<KeyValuePair<int, int>> _lru;\\n\\n    public LRUCache(int capacity) \\n    {\\n        _capacity = capacity;        \\n        _cache = new();\\n        _lru = new();\\n    }\\n    \\n    public int Get(int key) \\n    {\\n        if (!_cache.TryGetValue(key, out var node))\\n        {\\n            return -1;\\n        }\\n        \\n        _lru.Remove(node);\\n        _cache[key] = _lru.AddFirst(node.Value);\\n        \\n        return node.Value.Value;        \\n    }\\n    \\n    public void Put(int key, int value) \\n    {\\n        if (_cache.TryGetValue(key, out var node))\\n        {\\n            _lru.Remove(node);\\n            _cache.Remove(key);\\n        }\\n        \\n        node = _lru.AddFirst(new KeyValuePair<int, int>(key, value));\\n        _cache[key] = node;\\n        \\n        if (_lru.Count > _capacity)\\n        {\\n            node = _lru.Last;            \\n            _lru.RemoveLast();\\n            _cache.Remove(node.Value.Key);            \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class LRUCache \\n{\\n    private readonly int _capacity;\\n    private readonly Dictionary<int, LinkedListNode<KeyValuePair<int, int>>> _cache;\\n    private readonly LinkedList<KeyValuePair<int, int>> _lru;\\n\\n    public LRUCache(int capacity) \\n    {\\n        _capacity = capacity;        \\n        _cache = new();\\n        _lru = new();\\n    }\\n    \\n    public int Get(int key) \\n    {\\n        if (!_cache.TryGetValue(key, out var node))\\n        {\\n            return -1;\\n        }\\n        \\n        _lru.Remove(node);\\n        _cache[key] = _lru.AddFirst(node.Value);\\n        \\n        return node.Value.Value;        \\n    }\\n    \\n    public void Put(int key, int value) \\n    {\\n        if (_cache.TryGetValue(key, out var node))\\n        {\\n            _lru.Remove(node);\\n            _cache.Remove(key);\\n        }\\n        \\n        node = _lru.AddFirst(new KeyValuePair<int, int>(key, value));\\n        _cache[key] = node;\\n        \\n        if (_lru.Count > _capacity)\\n        {\\n            node = _lru.Last;            \\n            _lru.RemoveLast();\\n            _cache.Remove(node.Value.Key);            \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457985,
                "title": "c-11-code-74ms-hash-table-list",
                "content": "points to remember:- \\n1. make a map ,which stores key as key and value as pair of value and iterator of list<int> , so that we dont have to search the key for updating from  any position in the list to  take it to front of the list(as it is recently used),this situation will come when we call get() function for the any random key in the list or when we call put funtion for the key which is already present in the list.....we have to erase the key from that  position via iterator and push in the front of the list as it is recently used...\\n2.  list will store only key .\\n3.  max size of the list will always be capacity(given).\\n4.  if we want to put key after having list size equal to capacity..we have to pop the least recently used key (which is present in the back of the list) from the list as well from map.\\n\\n```\\n\\n\\nclass LRUCache {\\npublic:\\n    int n;\\n    unordered_map<int,pair<int,list <int> ::iterator>> m;\\n    list<int> dq;\\n    LRUCache(int capacity) {\\n        m.clear();\\n        dq.clear();\\n        n=capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key)!=m.end()){\\n            int val=m[key].first;\\n            auto it=m[key].second;\\n         \\n            dq.erase(it);\\n            dq.push_front(key);\\n            m[key]={val,dq.begin()};\\n            return val;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.find(key)==m.end())\\n        {\\n            if(dq.size()==n)\\n            {\\n                int last=dq.back();\\n                dq.pop_back();\\n                m.erase(last);\\n            }\\n        }\\n        else\\n        {\\n            auto it=m[key].second;\\n          \\n            dq.erase(it);\\n        }\\n        dq.push_front(key);\\n        m[key]={value,dq.begin()};\\n    }\\n};\\n```\\n\\n\\n************** UPVOTE IF YOU LIKE IT **********************************************",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n\\n\\nclass LRUCache {\\npublic:\\n    int n;\\n    unordered_map<int,pair<int,list <int> ::iterator>> m;\\n    list<int> dq;\\n    LRUCache(int capacity) {\\n        m.clear();\\n        dq.clear();\\n        n=capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(m.find(key)!=m.end()){\\n            int val=m[key].first;\\n            auto it=m[key].second;\\n         \\n            dq.erase(it);\\n            dq.push_front(key);\\n            m[key]={val,dq.begin()};\\n            return val;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    void put(int key, int value) {\\n        if(m.find(key)==m.end())\\n        {\\n            if(dq.size()==n)\\n            {\\n                int last=dq.back();\\n                dq.pop_back();\\n                m.erase(last);\\n            }\\n        }\\n        else\\n        {\\n            auto it=m[key].second;\\n          \\n            dq.erase(it);\\n        }\\n        dq.push_front(key);\\n        m[key]={value,dq.begin()};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374660,
                "title": "python-guys-nextiter",
                "content": "```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int): \\n        self.return1={}\\n        self.capacity=capacity\\n\\n    def get(self, key: int) -> int:\\n        if key in self.return1:\\n            get = self.return1[key]\\n            del self.return1[key]\\n            self.return1[key]=get\\n            return get\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.return1:\\n            del self.return1[key]\\n            self.return1[key]=value\\n        else:\\n            if len(self.return1)<self.capacity:\\n                self.return1[key]=value\\n            else:\\n                del self.return1[next(iter(self.return1))] ###This Guy Here is super important, Learn what this is in python\\n                self.return1[key]=value\\n                \\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int): \\n        self.return1={}\\n        self.capacity=capacity\\n\\n    def get(self, key: int) -> int:\\n        if key in self.return1:\\n            get = self.return1[key]\\n            del self.return1[key]\\n            self.return1[key]=get\\n            return get\\n        return -1\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.return1:\\n            del self.return1[key]\\n            self.return1[key]=value\\n        else:\\n            if len(self.return1)<self.capacity:\\n                self.return1[key]=value\\n            else:\\n                del self.return1[next(iter(self.return1))] ###This Guy Here is super important, Learn what this is in python\\n                self.return1[key]=value\\n                \\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089956,
                "title": "java-queue-and-hashmap-implementation",
                "content": "```\\nclass LRUCache {\\n    static int capacity;\\n    static Queue<Integer> q;\\n    static Map<Integer,Integer> map;\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        q=new LinkedList<>();\\n        map=new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (map.containsKey(key)) {\\n            q.remove(key);\\n            q.offer(key);\\n            return map.get(key);\\n        } else \\n            return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            q.remove(key);\\n            q.offer(key);\\n            map.put(key,value);\\n        } else {\\n            if(q.size() != capacity) {\\n                q.offer(key);\\n            } else {\\n                map.remove(q.poll());\\n                q.offer(key);\\n            }\\n                map.put(key,value);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass LRUCache {\\n    static int capacity;\\n    static Queue<Integer> q;\\n    static Map<Integer,Integer> map;\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        q=new LinkedList<>();\\n        map=new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (map.containsKey(key)) {\\n            q.remove(key);\\n            q.offer(key);\\n            return map.get(key);\\n        } else \\n            return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (map.containsKey(key)) {\\n            q.remove(key);\\n            q.offer(key);\\n            map.put(key,value);\\n        } else {\\n            if(q.size() != capacity) {\\n                q.offer(key);\\n            } else {\\n                map.remove(q.poll());\\n                q.offer(key);\\n            }\\n                map.put(key,value);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606728,
                "title": "intuitive-javascript-solution-with-map",
                "content": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n  this.capacity = capacity;\\n  // Map\\'s entries are ordered by the insertion order.\\n  this.map = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n  if (!this.map.has(key)) {\\n    return -1;\\n  }\\n  const value = this.map.get(key);\\n  this.map.delete(key);\\n  this.map.set(key, value);\\n  return value;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n  if (this.map.has(key)) {\\n    this.map.delete(key);\\n  }\\n  this.map.set(key, value);\\n  if (this.map.size > this.capacity) {\\n    const keys = this.map.keys(); // `keys` is an iterator\\n    this.map.delete(keys.next().value)\\n  }\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} capacity\\n */\\nvar LRUCache = function(capacity) {\\n  this.capacity = capacity;\\n  // Map\\'s entries are ordered by the insertion order.\\n  this.map = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number}\\n */\\nLRUCache.prototype.get = function(key) {\\n  if (!this.map.has(key)) {\\n    return -1;\\n  }\\n  const value = this.map.get(key);\\n  this.map.delete(key);\\n  this.map.set(key, value);\\n  return value;\\n};\\n\\n/** \\n * @param {number} key \\n * @param {number} value\\n * @return {void}\\n */\\nLRUCache.prototype.put = function(key, value) {\\n  if (this.map.has(key)) {\\n    this.map.delete(key);\\n  }\\n  this.map.set(key, value);\\n  if (this.map.size > this.capacity) {\\n    const keys = this.map.keys(); // `keys` is an iterator\\n    this.map.delete(keys.next().value)\\n  }\\n};\\n\\n/** \\n * Your LRUCache object will be instantiated and called as such:\\n * var obj = new LRUCache(capacity)\\n * var param_1 = obj.get(key)\\n * obj.put(key,value)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 569689,
                "title": "from-scratch-javascript-hashtable-dll-o-1",
                "content": "In this solution we will use a Hashtable & Doubly Linked List so we can perform O(1) operations. We will not be using built-in Javascript Data Structures such as `Map()`so we will build it from scratch. \\n \\n1. For the Hashtable we will simple use a Javascript object called`cache`.\\n1. For the Doubly Linked List we will create our own Data Structure called`recently`. \\n2. Finally we just initialize `capacity`. \\n\\nWe will create three methods for our Doubly Linked List class: `unshift()`, `pop()` & `remove()`. \\n* Add to the beginning of our DLL: `unshift()`\\n* Remove from the end of our DLL: `pop()`\\n* Remove a node from our DLL: `remove()`\\n\\nThe isea is: if we\\'re dealing with a value that is already in our cache we just simply remove that value `remove()` and push it to the beginning `unshift()`. If we are exceding our capacity we just `pop()` the last value and `unshift()` the new value. \\n\\n```\\nvar LRUCache = function (capacity) {\\n  class Node {\\n    constructor(key, val) {\\n      this.key = key\\n      this.val = val\\n      this.prev = null\\n      this.next = null\\n    }\\n  }\\n// Our DLL is just simply a way to unshift, pop & remove in O(1) time. \\n// We also initialize a length variable that keeps track of the size of our DLL.\\n  class DoublyLinkedList {\\n    constructor() {\\n      this.head = null\\n      this.tail = null\\n      this.length = 0\\n    }\\n    unshift(key, val) {\\n      const node = new Node(key, val) /\\n      if (this.length === 0) {\\n        this.head = node\\n        this.tail = node\\n      } else {\\n        node.next = this.head\\n        this.head.prev = node\\n        this.head = node\\n      }\\n      this.length++\\n      return node\\n    }\\n    pop() {\\n      if (this.head === this.tail) {\\n        this.head = null\\n        this.tail = null\\n        this.length = 0\\n      } else {\\n        this.tail = this.tail.prev\\n        this.tail.next.prev = null\\n        this.tail.next = null\\n        this.length--\\n      }\\n    }\\n    remove(node) {\\n      if (node.next !== null) {\\n        node.next.prev = node.prev\\n      } else {\\n        this.tail = node.prev\\n      }\\n      if (node.prev !== null) {\\n        node.prev.next = node.next\\n      } else {\\n        this.head = node.next\\n      }\\n      node.next = null\\n      node.prev = null\\n      this.length--\\n      return node\\n    }\\n  }\\n\\n  this.cache = {}\\n  this.recently = new DoublyLinkedList()\\n  this.capacity = capacity\\n}\\n\\nLRUCache.prototype.get = function (key) {\\n  if (this.cache[key]) {\\n    this.recently.remove(this.cache[key])\\n    this.cache[key] = this.recently.unshift(key, this.cache[key].val)\\n    return this.cache[key].val\\n  } else {\\n    return -1\\n  }\\n}\\nLRUCache.prototype.put = function (key, value) {\\n  if (this.cache[key]) {\\n    this.recently.remove(this.cache[key])\\n    this.cache[key] = this.recently.unshift(key, value)\\n  } else {\\n    if (this.recently.length < this.capacity) {\\n      this.cache[key] = this.recently.unshift(key, value)\\n    } else {\\n      delete this.cache[this.recently.tail.key]\\n      this.recently.pop()\\n      this.cache[key] = this.recently.unshift(key, value)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Doubly-Linked List"
                ],
                "code": "```\\nvar LRUCache = function (capacity) {\\n  class Node {\\n    constructor(key, val) {\\n      this.key = key\\n      this.val = val\\n      this.prev = null\\n      this.next = null\\n    }\\n  }\\n// Our DLL is just simply a way to unshift, pop & remove in O(1) time. \\n// We also initialize a length variable that keeps track of the size of our DLL.\\n  class DoublyLinkedList {\\n    constructor() {\\n      this.head = null\\n      this.tail = null\\n      this.length = 0\\n    }\\n    unshift(key, val) {\\n      const node = new Node(key, val) /\\n      if (this.length === 0) {\\n        this.head = node\\n        this.tail = node\\n      } else {\\n        node.next = this.head\\n        this.head.prev = node\\n        this.head = node\\n      }\\n      this.length++\\n      return node\\n    }\\n    pop() {\\n      if (this.head === this.tail) {\\n        this.head = null\\n        this.tail = null\\n        this.length = 0\\n      } else {\\n        this.tail = this.tail.prev\\n        this.tail.next.prev = null\\n        this.tail.next = null\\n        this.length--\\n      }\\n    }\\n    remove(node) {\\n      if (node.next !== null) {\\n        node.next.prev = node.prev\\n      } else {\\n        this.tail = node.prev\\n      }\\n      if (node.prev !== null) {\\n        node.prev.next = node.next\\n      } else {\\n        this.head = node.next\\n      }\\n      node.next = null\\n      node.prev = null\\n      this.length--\\n      return node\\n    }\\n  }\\n\\n  this.cache = {}\\n  this.recently = new DoublyLinkedList()\\n  this.capacity = capacity\\n}\\n\\nLRUCache.prototype.get = function (key) {\\n  if (this.cache[key]) {\\n    this.recently.remove(this.cache[key])\\n    this.cache[key] = this.recently.unshift(key, this.cache[key].val)\\n    return this.cache[key].val\\n  } else {\\n    return -1\\n  }\\n}\\nLRUCache.prototype.put = function (key, value) {\\n  if (this.cache[key]) {\\n    this.recently.remove(this.cache[key])\\n    this.cache[key] = this.recently.unshift(key, value)\\n  } else {\\n    if (this.recently.length < this.capacity) {\\n      this.cache[key] = this.recently.unshift(key, value)\\n    } else {\\n      delete this.cache[this.recently.tail.key]\\n      this.recently.pop()\\n      this.cache[key] = this.recently.unshift(key, value)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496938,
                "title": "java-detailed-explanation-must-read",
                "content": "I have added comments with the code which will help you understand the solution better. \\n```\\n// Create a Node Data Structure\\nprivate class Node {\\n\\tint key, value;                 // key, value pair\\n\\tNode prev, next;                // point to prev and next node in Double Linked List                \\n\\tNode(int k, int v) {            // constructor\\n\\t\\tthis.key = k;\\n\\t\\tthis.value = v;\\n\\t}\\n}\\n\\n//Global variables\\nprivate int capacity;\\nprivate Map<Integer, Node> map;\\nprivate Node head, tail;\\n\\npublic LRUCache(int capacity) {     // initialise all the global vars here\\n\\tthis.capacity = capacity;\\n\\tmap = new HashMap<>();\\n\\thead = new Node(0,0);           // head points to most recently used key\\n\\ttail = new Node(0,0);           // tail points to least recently used key\\n\\thead.next = tail;\\n\\ttail.prev = head;\\n}\\n\\npublic int get(int key) {\\n\\tNode n = map.get(key);\\n\\tif(n == null) return -1;        // no such key exists, so return -1\\n\\tremove(n);                      // else we remove the node from tail\\n\\tadd(n);                         // and add it add the head, because now it is most recently used\\n\\treturn n.value;     \\n}\\n\\npublic void put(int key, int value) {\\n\\tNode n = map.get(key);\\n\\tif(n == null) {                 // map does not contain key\\n\\t\\tn = new Node(key, value);   // create new node and put it in map\\n\\t\\tmap.put(key, n);\\n\\t\\tadd(n);\\n\\t\\t--capacity;                 // decrease the capacity by 1 because we have limited space\\n\\t} else {                        // map contains the key, so we just update the value and DLL\\n\\t\\tn.value = value;\\n\\t\\tremove(n);                  // we remove the node from tail\\n\\t\\tadd(n);                     // and add it add the head, because now it is most recently used\\n\\t}\\n\\tif(capacity < 0){               // if capacity is negative, we have to delete the least recently used\\n\\t\\tNode toDel = tail.prev;     // delete from the tail\\n\\t\\tremove(toDel);              \\n\\t\\tmap.remove(toDel.key);      // removing from the map, improves space complexity\\n\\t\\t++capacity;                 // cause we regain 1 unit of capacity\\n\\t}\\n}\\n\\npublic void add(Node n) {           // a simple routine to add a node at the head\\n\\tNode after = head.next;\\n\\thead.next = n;\\n\\tn.prev = head;\\n\\tn.next = after;\\n\\tafter.prev = n;\\n}\\n\\nprivate void remove(Node n){        // a simple routine to remove a node from the tail\\n\\tNode before = n.prev, after = n.next;\\n\\tbefore.next = after;\\n\\tafter.prev = before;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Create a Node Data Structure\\nprivate class Node {\\n\\tint key, value;                 // key, value pair\\n\\tNode prev, next;                // point to prev and next node in Double Linked List                \\n\\tNode(int k, int v) {            // constructor\\n\\t\\tthis.key = k;\\n\\t\\tthis.value = v;\\n\\t}\\n}\\n\\n//Global variables\\nprivate int capacity;\\nprivate Map<Integer, Node> map;\\nprivate Node head, tail;\\n\\npublic LRUCache(int capacity) {     // initialise all the global vars here\\n\\tthis.capacity = capacity;\\n\\tmap = new HashMap<>();\\n\\thead = new Node(0,0);           // head points to most recently used key\\n\\ttail = new Node(0,0);           // tail points to least recently used key\\n\\thead.next = tail;\\n\\ttail.prev = head;\\n}\\n\\npublic int get(int key) {\\n\\tNode n = map.get(key);\\n\\tif(n == null) return -1;        // no such key exists, so return -1\\n\\tremove(n);                      // else we remove the node from tail\\n\\tadd(n);                         // and add it add the head, because now it is most recently used\\n\\treturn n.value;     \\n}\\n\\npublic void put(int key, int value) {\\n\\tNode n = map.get(key);\\n\\tif(n == null) {                 // map does not contain key\\n\\t\\tn = new Node(key, value);   // create new node and put it in map\\n\\t\\tmap.put(key, n);\\n\\t\\tadd(n);\\n\\t\\t--capacity;                 // decrease the capacity by 1 because we have limited space\\n\\t} else {                        // map contains the key, so we just update the value and DLL\\n\\t\\tn.value = value;\\n\\t\\tremove(n);                  // we remove the node from tail\\n\\t\\tadd(n);                     // and add it add the head, because now it is most recently used\\n\\t}\\n\\tif(capacity < 0){               // if capacity is negative, we have to delete the least recently used\\n\\t\\tNode toDel = tail.prev;     // delete from the tail\\n\\t\\tremove(toDel);              \\n\\t\\tmap.remove(toDel.key);      // removing from the map, improves space complexity\\n\\t\\t++capacity;                 // cause we regain 1 unit of capacity\\n\\t}\\n}\\n\\npublic void add(Node n) {           // a simple routine to add a node at the head\\n\\tNode after = head.next;\\n\\thead.next = n;\\n\\tn.prev = head;\\n\\tn.next = after;\\n\\tafter.prev = n;\\n}\\n\\nprivate void remove(Node n){        // a simple routine to remove a node from the tail\\n\\tNode before = n.prev, after = n.next;\\n\\tbefore.next = after;\\n\\tafter.prev = before;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421049,
                "title": "c-shortest-easy-to-understand",
                "content": "```\\nclass LRUCache {\\n    \\nprivate:\\n    unordered_map<int, pair<int, list<int>::iterator>> cacheObj; // Support O(1) search\\n    list<int> LRUObj; // Will store our keys\\n    int capacity_;\\n    \\npublic:\\n    LRUCache(int capacity) {\\n        capacity_ = capacity;\\n    }\\n\\t\\n    // Everytime we use an iterator we want to update our LRU Cache\\n\\t// This is a helper function\\n    void useItem(unordered_map<int, pair<int, list<int>::iterator>>::iterator& iter) {\\n        LRUObj.erase(iter->second.second);\\n        LRUObj.push_front(iter->first);\\n        iter->second.second = LRUObj.begin();\\n    }\\n    \\n    \\n    int get(int key) {\\n        auto iter = cacheObj.find(key);\\n        if (iter == cacheObj.end()) {\\n            return -1;\\n        }\\n        useItem(iter);\\n        return iter->second.first;\\n    }\\n    \\n    void put(int key, int value) {\\n        // If the key exists\\n        auto iter = cacheObj.find(key);\\n        if (iter != cacheObj.end()) {\\n            useItem(iter);\\n            cacheObj[key] = {value, LRUObj.begin()};\\n            return;\\n        }\\n        // If we reached capacity, remove the last item in LRU from cache\\n        if (capacity_ == cacheObj.size()) {\\n            cacheObj.erase(LRUObj.back());\\n            LRUObj.pop_back();\\n        }\\n        \\n        // Push new key into front, insert it into cache.\\n        LRUObj.push_front(key);\\n        cacheObj.insert({key, {value, LRUObj.begin()}});\\n        return;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LRUCache {\\n    \\nprivate:\\n    unordered_map<int, pair<int, list<int>::iterator>> cacheObj; // Support O(1) search\\n    list<int> LRUObj; // Will store our keys\\n    int capacity_;\\n    \\npublic:\\n    LRUCache(int capacity) {\\n        capacity_ = capacity;\\n    }\\n\\t\\n    // Everytime we use an iterator we want to update our LRU Cache\\n\\t// This is a helper function\\n    void useItem(unordered_map<int, pair<int, list<int>::iterator>>::iterator& iter) {\\n        LRUObj.erase(iter->second.second);\\n        LRUObj.push_front(iter->first);\\n        iter->second.second = LRUObj.begin();\\n    }\\n    \\n    \\n    int get(int key) {\\n        auto iter = cacheObj.find(key);\\n        if (iter == cacheObj.end()) {\\n            return -1;\\n        }\\n        useItem(iter);\\n        return iter->second.first;\\n    }\\n    \\n    void put(int key, int value) {\\n        // If the key exists\\n        auto iter = cacheObj.find(key);\\n        if (iter != cacheObj.end()) {\\n            useItem(iter);\\n            cacheObj[key] = {value, LRUObj.begin()};\\n            return;\\n        }\\n        // If we reached capacity, remove the last item in LRU from cache\\n        if (capacity_ == cacheObj.size()) {\\n            cacheObj.erase(LRUObj.back());\\n            LRUObj.pop_back();\\n        }\\n        \\n        // Push new key into front, insert it into cache.\\n        LRUObj.push_front(key);\\n        cacheObj.insert({key, {value, LRUObj.begin()}});\\n        return;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 407889,
                "title": "c-solution-with-get-put-in-o-1-with-stl-containers-only",
                "content": "```c++\\nclass LRUCache {\\n  typedef pair<int, int> Node;\\n  typedef list<Node>::iterator ref;\\n\\n  list<Node> q;\\n  unordered_map<int, ref> m;\\n  int capacity;\\n\\n  void insert(int key, int value) {\\n    if (m.find(key) != m.end()) {\\n      q.erase(m[key]);\\n      m.erase(key);\\n    }\\n    q.push_front(make_pair(key, value));\\n    m[key] = q.begin();\\n    if (q.size() > capacity) {\\n      m.erase(q.back().first);\\n      q.pop_back();\\n    }\\n  }\\n\\n public:\\n  LRUCache(int v) : capacity(v) {\\n      m.reserve(capacity);\\n  }\\n\\n  int get(int key) {\\n    if (m.find(key) == m.end()) {\\n      return -1;\\n    }\\n    int value = m[key]->second;\\n    insert(key, value);\\n    return value;\\n  }\\n\\n  void put(int key, int value) {\\n    insert(key, value);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass LRUCache {\\n  typedef pair<int, int> Node;\\n  typedef list<Node>::iterator ref;\\n\\n  list<Node> q;\\n  unordered_map<int, ref> m;\\n  int capacity;\\n\\n  void insert(int key, int value) {\\n    if (m.find(key) != m.end()) {\\n      q.erase(m[key]);\\n      m.erase(key);\\n    }\\n    q.push_front(make_pair(key, value));\\n    m[key] = q.begin();\\n    if (q.size() > capacity) {\\n      m.erase(q.back().first);\\n      q.pop_back();\\n    }\\n  }\\n\\n public:\\n  LRUCache(int v) : capacity(v) {\\n      m.reserve(capacity);\\n  }\\n\\n  int get(int key) {\\n    if (m.find(key) == m.end()) {\\n      return -1;\\n    }\\n    int value = m[key]->second;\\n    insert(key, value);\\n    return value;\\n  }\\n\\n  void put(int key, int value) {\\n    insert(key, value);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395628,
                "title": "python-solution",
                "content": "```\\n\"\"\"\\ndifference between dict() and OrderedDict() is\\nOrderedDict preserves the order in which the keys are inserted. \\nA regular dict doesn\\u2019t track the insertion order, and iterating it \\ngives the values in an arbitrary order.\\n\\n\"\"\"\\nfrom collections import OrderedDict\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.d=OrderedDict() \\n        self.capacity=capacity\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.d.keys():\\n            v=self.d.pop(key)\\n            self.d[key]=v\\n            return v\\n        else:\\n            return -1\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.d:\\n            self.d.pop(key)\\n            self.d[key]=value\\n        else:\\n            if len(self.d)==self.capacity:\\n                \"\"\"popitem Remove and return a (key, value) pair from the dictionary. \\n                Pairs are returned in LIFO order.\"\"\"\\n                self.d.popitem(last=False)\\n            self.d[key]=value\\n           \\n        \\n          \\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```\\n\\n#vote up if approach is correct\\n#please comment if something is wrong",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\ndifference between dict() and OrderedDict() is\\nOrderedDict preserves the order in which the keys are inserted. \\nA regular dict doesn\\u2019t track the insertion order, and iterating it \\ngives the values in an arbitrary order.\\n\\n\"\"\"\\nfrom collections import OrderedDict\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.d=OrderedDict() \\n        self.capacity=capacity\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key in self.d.keys():\\n            v=self.d.pop(key)\\n            self.d[key]=v\\n            return v\\n        else:\\n            return -1\\n        \\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.d:\\n            self.d.pop(key)\\n            self.d[key]=value\\n        else:\\n            if len(self.d)==self.capacity:\\n                \"\"\"popitem Remove and return a (key, value) pair from the dictionary. \\n                Pairs are returned in LIFO order.\"\"\"\\n                self.d.popitem(last=False)\\n            self.d[key]=value\\n           \\n        \\n          \\n\\n# Your LRUCache object will be instantiated and called as such:\\n# obj = LRUCache(capacity)\\n# param_1 = obj.get(key)\\n# obj.put(key,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363569,
                "title": "c-using-linkedlist",
                "content": "```\\npublic class LRUCache {\\n    Dictionary<int, int> keyAndValue = new Dictionary<int, int>();\\n    Dictionary<int, LinkedListNode<int>> keyAndNode = new Dictionary<int, LinkedListNode<int>>();\\n    LinkedList<int> linkedList = new LinkedList<int>();\\n\\n    int capacity;\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n\\n    public int Get(int key) {\\n        if (!keyAndValue.ContainsKey(key)) {\\n            return -1;\\n        }\\n\\n        var result = keyAndValue[key];\\n\\n        var node = keyAndNode[key];\\n        linkedList.Remove(node);\\n        linkedList.AddFirst(node);\\n\\n        return result;\\n    }\\n\\n    public void Put(int key, int value) {\\n        if (!keyAndValue.ContainsKey(key)) {\\n            // new\\n            if (capacity == linkedList.Count) {\\n                var last = linkedList.Last;\\n                linkedList.RemoveLast();\\n                keyAndValue.Remove(last.Value);\\n                keyAndNode.Remove(last.Value);\\n            }\\n\\n            linkedList.AddFirst(key);\\n            keyAndNode[key] = linkedList.First;\\n            keyAndValue[key] = value;\\n        } else {\\n            // update\\n            keyAndValue[key] = value;\\n            var node = keyAndNode[key];\\n            linkedList.Remove(node);\\n            linkedList.AddFirst(node);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class LRUCache {\\n    Dictionary<int, int> keyAndValue = new Dictionary<int, int>();\\n    Dictionary<int, LinkedListNode<int>> keyAndNode = new Dictionary<int, LinkedListNode<int>>();\\n    LinkedList<int> linkedList = new LinkedList<int>();\\n\\n    int capacity;\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n    }\\n\\n    public int Get(int key) {\\n        if (!keyAndValue.ContainsKey(key)) {\\n            return -1;\\n        }\\n\\n        var result = keyAndValue[key];\\n\\n        var node = keyAndNode[key];\\n        linkedList.Remove(node);\\n        linkedList.AddFirst(node);\\n\\n        return result;\\n    }\\n\\n    public void Put(int key, int value) {\\n        if (!keyAndValue.ContainsKey(key)) {\\n            // new\\n            if (capacity == linkedList.Count) {\\n                var last = linkedList.Last;\\n                linkedList.RemoveLast();\\n                keyAndValue.Remove(last.Value);\\n                keyAndNode.Remove(last.Value);\\n            }\\n\\n            linkedList.AddFirst(key);\\n            keyAndNode[key] = linkedList.First;\\n            keyAndValue[key] = value;\\n        } else {\\n            // update\\n            keyAndValue[key] = value;\\n            var node = keyAndNode[key];\\n            linkedList.Remove(node);\\n            linkedList.AddFirst(node);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355310,
                "title": "lru-cache-simple-c-code-with-clear-comments",
                "content": "```\\n// Implementation of LRU Cache using two data structures:\\n// 1. Doubly Linked List\\n// 2. HashMap\\n\\nclass LRUCache {\\npublic:\\n    int cacheSize;\\n    map<int, int> m;\\n    deque<int> dq;\\n    \\n    LRUCache(int capacity) {\\n        m.clear();\\n        dq.clear();\\n        cacheSize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        // not found\\n        if (m.find(key) == m.end()) {\\n            return -1;\\n        } else {\\n            // found\\n            deque<int>::iterator it = dq.begin();\\n            while (*it != key) {\\n                it++;\\n            }\\n            \\n            // update queue: update it to most recent used value\\n            dq.erase(it);\\n            dq.push_front(key);\\n            \\n            return m[key];\\n        }\\n    }\\n    \\n    void put(int key, int value) {\\n        // not present in cache\\n        if (m.find(key) == m.end()) {\\n            // check if cache is full\\n            if (cacheSize == dq.size()) {\\n                int last = dq.back();\\n                dq.pop_back();\\n                m.erase(last);\\n            }\\n        } else {\\n            // present in cache, remove it from queue and map\\n            deque<int>::iterator it = dq.begin();\\n            while (*it != key) {\\n                it++;\\n            }\\n            \\n            dq.erase(it);\\n            m.erase(key);\\n        }\\n        \\n        // update the cache\\n        dq.push_front(key);\\n        m[key] = value;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Implementation of LRU Cache using two data structures:\\n// 1. Doubly Linked List\\n// 2. HashMap\\n\\nclass LRUCache {\\npublic:\\n    int cacheSize;\\n    map<int, int> m;\\n    deque<int> dq;\\n    \\n    LRUCache(int capacity) {\\n        m.clear();\\n        dq.clear();\\n        cacheSize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        // not found\\n        if (m.find(key) == m.end()) {\\n            return -1;\\n        } else {\\n            // found\\n            deque<int>::iterator it = dq.begin();\\n            while (*it != key) {\\n                it++;\\n            }\\n            \\n            // update queue: update it to most recent used value\\n            dq.erase(it);\\n            dq.push_front(key);\\n            \\n            return m[key];\\n        }\\n    }\\n    \\n    void put(int key, int value) {\\n        // not present in cache\\n        if (m.find(key) == m.end()) {\\n            // check if cache is full\\n            if (cacheSize == dq.size()) {\\n                int last = dq.back();\\n                dq.pop_back();\\n                m.erase(last);\\n            }\\n        } else {\\n            // present in cache, remove it from queue and map\\n            deque<int>::iterator it = dq.begin();\\n            while (*it != key) {\\n                it++;\\n            }\\n            \\n            dq.erase(it);\\n            m.erase(key);\\n        }\\n        \\n        // update the cache\\n        dq.push_front(key);\\n        m[key] = value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328050,
                "title": "c-98-beat-all-o-1-operations-good-implementation-koderz-kamp",
                "content": "Hmm, I\\'ve elected to go with a doubly-linked node implementation with sentinel nodes for the head and tail of the master list. I\\'ve also elected to implement the LRU cache in a manner in which Nodes never need to be deleted. Instead, we recycle the Least Recently Used node when we have a high enough count. \\n\\nI decided to make the head-end \"old\" and the tail-end \"new\" - so the most recently used item is always mTail->mPrev.\\n\\nOne thing to consider is allocating all of the nodes when we spawn the list on contiguous memory. This should give us a little extra speed if paging comes into play.\\n\\n```\\n\\nclass Node {\\npublic:\\n    Node(int pKey, int pVal) { mKey = pKey; mVal = pVal; mNext = NULL; mPrev = NULL; }\\n    Node *mNext, *mPrev;\\n    int mVal, mKey;\\n};\\n\\nclass LRUCache {\\npublic:\\n    \\n    int mCapacity, mCount;\\n    \\n    Node *mHead, *mTail;\\n    unordered_map<int, Node*> mBucket;\\n    \\n    LRUCache(int capacity) {\\n        mCapacity = capacity;\\n        mCount = 0;\\n        mHead = new Node(-1, -1);\\n        mTail = new Node(-1, -1);\\n        mHead->mNext = mTail;\\n        mTail->mPrev = mHead;\\n    }\\n    \\n    int get(int key) {\\n        Node *aNode = mBucket[key];\\n        if (aNode != NULL) {\\n            moveToEnd(aNode);\\n            return aNode->mVal;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        Node *aNode = mBucket[key];\\n        \\n        if (aNode == NULL) {\\n            if (mCount >= mCapacity) {\\n                aNode = dequeueOldest();\\n            } else {\\n                aNode = new Node(key, value);\\n                mCount++;\\n            }\\n            mBucket[key] = aNode;\\n        }\\n        \\n        aNode->mKey = key;\\n        aNode->mVal = value;\\n        \\n        moveToEnd(aNode);\\n    }\\n    \\n    \\nprivate:\\n    void moveToEnd(Node *pNode) {\\n        \\n        if (pNode->mPrev) { pNode->mPrev->mNext = pNode->mNext; }\\n        if (pNode->mNext) { pNode->mNext->mPrev = pNode->mPrev; }\\n        \\n        mTail->mPrev->mNext = pNode;\\n        pNode->mPrev = mTail->mPrev;\\n        pNode->mNext = mTail;\\n        mTail->mPrev = pNode;\\n    }\\n    \\n    Node *dequeueOldest() {\\n        Node *aResult = mHead->mNext;\\n        aResult->mNext->mPrev = mHead;\\n        mHead->mNext = aResult->mNext;\\n        aResult->mPrev = NULL;\\n        aResult->mNext = NULL;\\n        mBucket.erase(aResult->mKey);\\n        return aResult;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Node {\\npublic:\\n    Node(int pKey, int pVal) { mKey = pKey; mVal = pVal; mNext = NULL; mPrev = NULL; }\\n    Node *mNext, *mPrev;\\n    int mVal, mKey;\\n};\\n\\nclass LRUCache {\\npublic:\\n    \\n    int mCapacity, mCount;\\n    \\n    Node *mHead, *mTail;\\n    unordered_map<int, Node*> mBucket;\\n    \\n    LRUCache(int capacity) {\\n        mCapacity = capacity;\\n        mCount = 0;\\n        mHead = new Node(-1, -1);\\n        mTail = new Node(-1, -1);\\n        mHead->mNext = mTail;\\n        mTail->mPrev = mHead;\\n    }\\n    \\n    int get(int key) {\\n        Node *aNode = mBucket[key];\\n        if (aNode != NULL) {\\n            moveToEnd(aNode);\\n            return aNode->mVal;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        \\n        Node *aNode = mBucket[key];\\n        \\n        if (aNode == NULL) {\\n            if (mCount >= mCapacity) {\\n                aNode = dequeueOldest();\\n            } else {\\n                aNode = new Node(key, value);\\n                mCount++;\\n            }\\n            mBucket[key] = aNode;\\n        }\\n        \\n        aNode->mKey = key;\\n        aNode->mVal = value;\\n        \\n        moveToEnd(aNode);\\n    }\\n    \\n    \\nprivate:\\n    void moveToEnd(Node *pNode) {\\n        \\n        if (pNode->mPrev) { pNode->mPrev->mNext = pNode->mNext; }\\n        if (pNode->mNext) { pNode->mNext->mPrev = pNode->mPrev; }\\n        \\n        mTail->mPrev->mNext = pNode;\\n        pNode->mPrev = mTail->mPrev;\\n        pNode->mNext = mTail;\\n        mTail->mPrev = pNode;\\n    }\\n    \\n    Node *dequeueOldest() {\\n        Node *aResult = mHead->mNext;\\n        aResult->mNext->mPrev = mHead;\\n        mHead->mNext = aResult->mNext;\\n        aResult->mPrev = NULL;\\n        aResult->mNext = NULL;\\n        mBucket.erase(aResult->mKey);\\n        return aResult;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186539,
                "title": "my-cpp-solution",
                "content": "```\\n\\nstruct DLinkedNode {\\n\\tint key;\\n\\tint value;\\n\\tDLinkedNode *prev;\\n\\tDLinkedNode *next;\\n};\\n\\nclass LRUCache {\\nprivate:\\n    //Variables\\n    unordered_map<int,DLinkedNode*> m; //Key, Value\\n    int count;\\n    int capacity;\\n    DLinkedNode *head, *tail;\\n    \\n    //Functions\\n    \\n    /* Always add the new node right after head */\\n    void addNode(DLinkedNode* node){\\n        //Fit inside first\\n        node->prev = head;\\n        node->next = head->next;\\n\\n        node->prev->next = node;\\n        node->next->prev = node;\\n    }\\n\\n    /** Remove an existing node from the linked list */\\n    void removeNode(DLinkedNode* node){\\n        DLinkedNode *prevNode = node->prev;\\n        DLinkedNode *nextNode = node->next;\\n\\n        prevNode->next = nextNode;\\n        nextNode->prev = prevNode;\\n    }\\n\\n    /** Move certain node in between to the head. */\\n    void moveToHead(DLinkedNode* node){\\n        removeNode(node);\\n        addNode(node);\\n    }\\n  \\npublic:\\n    LRUCache(int _capacity) {\\n        count=0;\\n        capacity = _capacity;\\n        \\n        head = new DLinkedNode();\\n        head->prev = NULL;\\n\\n        tail = new DLinkedNode();\\n        tail->next = NULL;\\n\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    int get(int key) {\\n        \\n        //If Not in map\\n        if(m.find(key)==m.end())\\n            return -1; \\n        \\n        DLinkedNode *node = m[key];\\n        \\n        // Move the accessed node to the head\\n        moveToHead(node);\\n\\n        return node->value;\\n  \\n    }\\n    \\n    void put(int key, int value) {\\n    \\n        //If found in map\\n        if(m.find(key)!=m.end())\\n        {\\n            //Update the value and move it ahead\\n            m[key]->value = value;\\n            moveToHead(m[key]);\\n            return;\\n        }\\n\\n        //Else make a New Node\\n        DLinkedNode *newNode = new DLinkedNode();\\n        newNode->key = key;\\n        newNode->value = value;\\n\\n        m[key] = newNode;\\n        addNode(newNode);\\n\\n        ++count;\\n    \\n        //Remove the element before tail\\n        if(count > capacity){\\n            DLinkedNode *lastNode = tail->prev;\\n            \\n            m.erase(lastNode->key);\\n            removeNode(lastNode); \\n        }\\n     \\n        \\n    }//put\\n   \\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n \\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct DLinkedNode {\\n\\tint key;\\n\\tint value;\\n\\tDLinkedNode *prev;\\n\\tDLinkedNode *next;\\n};\\n\\nclass LRUCache {\\nprivate:\\n    //Variables\\n    unordered_map<int,DLinkedNode*> m; //Key, Value\\n    int count;\\n    int capacity;\\n    DLinkedNode *head, *tail;\\n    \\n    //Functions\\n    \\n    /* Always add the new node right after head */\\n    void addNode(DLinkedNode* node){\\n        //Fit inside first\\n        node->prev = head;\\n        node->next = head->next;\\n\\n        node->prev->next = node;\\n        node->next->prev = node;\\n    }\\n\\n    /** Remove an existing node from the linked list */\\n    void removeNode(DLinkedNode* node){\\n        DLinkedNode *prevNode = node->prev;\\n        DLinkedNode *nextNode = node->next;\\n\\n        prevNode->next = nextNode;\\n        nextNode->prev = prevNode;\\n    }\\n\\n    /** Move certain node in between to the head. */\\n    void moveToHead(DLinkedNode* node){\\n        removeNode(node);\\n        addNode(node);\\n    }\\n  \\npublic:\\n    LRUCache(int _capacity) {\\n        count=0;\\n        capacity = _capacity;\\n        \\n        head = new DLinkedNode();\\n        head->prev = NULL;\\n\\n        tail = new DLinkedNode();\\n        tail->next = NULL;\\n\\n        head->next = tail;\\n        tail->prev = head;\\n    }\\n    \\n    int get(int key) {\\n        \\n        //If Not in map\\n        if(m.find(key)==m.end())\\n            return -1; \\n        \\n        DLinkedNode *node = m[key];\\n        \\n        // Move the accessed node to the head\\n        moveToHead(node);\\n\\n        return node->value;\\n  \\n    }\\n    \\n    void put(int key, int value) {\\n    \\n        //If found in map\\n        if(m.find(key)!=m.end())\\n        {\\n            //Update the value and move it ahead\\n            m[key]->value = value;\\n            moveToHead(m[key]);\\n            return;\\n        }\\n\\n        //Else make a New Node\\n        DLinkedNode *newNode = new DLinkedNode();\\n        newNode->key = key;\\n        newNode->value = value;\\n\\n        m[key] = newNode;\\n        addNode(newNode);\\n\\n        ++count;\\n    \\n        //Remove the element before tail\\n        if(count > capacity){\\n            DLinkedNode *lastNode = tail->prev;\\n            \\n            m.erase(lastNode->key);\\n            removeNode(lastNode); \\n        }\\n     \\n        \\n    }//put\\n   \\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 175649,
                "title": "map-doubly-linkedlist",
                "content": "To insert and remove elements within a collection - that\\'s natural to a LinkedList.\\n\\nHowever, deletion in a Singly LinkedList costs O(2*n) time , Doubly LinkedList costs O(n) time. In order to reduce time to O(1), we have to figure out a node bounded to a key in O(1) - that can be achived by a mapping from key to node.\\n\\nWe always put the most recent one at the head of the Doubly LinkedList, then the least recent ones should be at the end. \\n\\nFor Doubly LinkedList, we add `head` and `tail` to avoid tedious `null` checks.\\n**** \\n```\\nclass LRUCache {\\n    private DNode head, tail;\\n    private Map<Integer, DNode> nodeMap; // map k to node\\n    private int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        head = new DNode(-1, -1);\\n        tail = new DNode(-1, -1);\\n        \\n        head.next= tail;\\n        tail.prev = head;\\n        this.capacity = capacity;\\n        \\n        nodeMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (nodeMap.containsKey(key)) {\\n            moveToFront(nodeMap.get(key));\\n            return nodeMap.get(key).v;\\n        } else\\n            return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (nodeMap.containsKey(key)) {\\n            DNode nodeToPut = nodeMap.get(key);\\n            nodeToPut.v = value;\\n            \\n            moveToFront(nodeToPut);\\n        } else {\\n            if (nodeMap.size() == capacity)\\n                evict();\\n            DNode nodeToPut = new DNode(key, value);\\n            nodeMap.put(key, nodeToPut);\\n            \\n            insertToFront(nodeToPut);\\n        }\\n    }\\n    \\n    private void moveToFront(DNode toMove) {\\n        delete(toMove);\\n        insertToFront(toMove);\\n    }\\n    \\n    private void delete(DNode toDelete) {\\n        DNode toDeletePrev = toDelete.prev; \\n        DNode toDeleteNext = toDelete.next; \\n        toDeletePrev.next = toDeleteNext;\\n        toDeleteNext.prev = toDeletePrev;\\n    }\\n    \\n    private void insertToFront(DNode toInsert) {\\n        DNode headNext = head.next;\\n        head.next = toInsert;\\n        toInsert.next = headNext;\\n        headNext.prev = toInsert;\\n        toInsert.prev = head;\\n    }\\n    \\n    void evict() {                   \\n        DNode toEvict = tail.prev;\\n        \\n        toEvict.prev.next = tail;\\n        tail.prev = toEvict.prev;\\n        \\n        nodeMap.remove(toEvict.k);\\n    }\\n    \\n    class DNode {\\n        int k, v;\\n        DNode next;\\n        DNode prev;\\n        public DNode(int k, int v) {\\n            this.k = k;\\n            this.v = v;\\n            next = null;\\n            prev = null;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass LRUCache {\\n    private DNode head, tail;\\n    private Map<Integer, DNode> nodeMap; // map k to node\\n    private int capacity;\\n    \\n    public LRUCache(int capacity) {\\n        head = new DNode(-1, -1);\\n        tail = new DNode(-1, -1);\\n        \\n        head.next= tail;\\n        tail.prev = head;\\n        this.capacity = capacity;\\n        \\n        nodeMap = new HashMap<>();\\n    }\\n    \\n    public int get(int key) {\\n        if (nodeMap.containsKey(key)) {\\n            moveToFront(nodeMap.get(key));\\n            return nodeMap.get(key).v;\\n        } else\\n            return -1;\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (nodeMap.containsKey(key)) {\\n            DNode nodeToPut = nodeMap.get(key);\\n            nodeToPut.v = value;\\n            \\n            moveToFront(nodeToPut);\\n        } else {\\n            if (nodeMap.size() == capacity)\\n                evict();\\n            DNode nodeToPut = new DNode(key, value);\\n            nodeMap.put(key, nodeToPut);\\n            \\n            insertToFront(nodeToPut);\\n        }\\n    }\\n    \\n    private void moveToFront(DNode toMove) {\\n        delete(toMove);\\n        insertToFront(toMove);\\n    }\\n    \\n    private void delete(DNode toDelete) {\\n        DNode toDeletePrev = toDelete.prev; \\n        DNode toDeleteNext = toDelete.next; \\n        toDeletePrev.next = toDeleteNext;\\n        toDeleteNext.prev = toDeletePrev;\\n    }\\n    \\n    private void insertToFront(DNode toInsert) {\\n        DNode headNext = head.next;\\n        head.next = toInsert;\\n        toInsert.next = headNext;\\n        headNext.prev = toInsert;\\n        toInsert.prev = head;\\n    }\\n    \\n    void evict() {                   \\n        DNode toEvict = tail.prev;\\n        \\n        toEvict.prev.next = tail;\\n        tail.prev = toEvict.prev;\\n        \\n        nodeMap.remove(toEvict.k);\\n    }\\n    \\n    class DNode {\\n        int k, v;\\n        DNode next;\\n        DNode prev;\\n        public DNode(int k, int v) {\\n            this.k = k;\\n            this.v = v;\\n            next = null;\\n            prev = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173926,
                "title": "kotlin-implementation-of-lrucache",
                "content": "```\\nclass LRUCache(private val capacity: Int) {\\n\\n    private val map = hashMapOf<Int, Node>()\\n    private val head: Node = Node(0, 0)\\n    private val tail: Node = Node(0, 0)\\n\\n    init {\\n        head.next = tail\\n        tail.prev = head\\n    }\\n\\n    fun get(key: Int): Int {\\n        if (map.containsKey(key)) {\\n            val node = map[key]!!\\n            remove(node)\\n            addAtEnd(node)\\n            return node.value\\n        }\\n        return -1\\n    }\\n\\n    fun put(key: Int, value: Int) {\\n        if (map.containsKey(key)) {\\n            remove(map[key]!!)\\n        }\\n        val node = Node(key, value)\\n        addAtEnd(node)\\n        map[key] = node\\n        if (map.size > capacity) {\\n            val first = head.next!!\\n            remove(first)\\n            map.remove(first.key)\\n        }\\n    }\\n\\n    private fun remove(node: Node) {\\n        val next = node.next!!\\n        val prev = node.prev!!\\n        prev.next = next\\n        next.prev = prev\\n    }\\n\\n    private fun addAtEnd(node: Node) {\\n        val prev = tail.prev!!\\n        prev.next = node\\n        node.prev = prev\\n        node.next = tail\\n        tail.prev = node\\n    }\\n\\n    data class Node(val key: Int, val value: Int) {\\n        var next: Node? = null\\n        var prev: Node? = null\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LRUCache(private val capacity: Int) {\\n\\n    private val map = hashMapOf<Int, Node>()\\n    private val head: Node = Node(0, 0)\\n    private val tail: Node = Node(0, 0)\\n\\n    init {\\n        head.next = tail\\n        tail.prev = head\\n    }\\n\\n    fun get(key: Int): Int {\\n        if (map.containsKey(key)) {\\n            val node = map[key]!!\\n            remove(node)\\n            addAtEnd(node)\\n            return node.value\\n        }\\n        return -1\\n    }\\n\\n    fun put(key: Int, value: Int) {\\n        if (map.containsKey(key)) {\\n            remove(map[key]!!)\\n        }\\n        val node = Node(key, value)\\n        addAtEnd(node)\\n        map[key] = node\\n        if (map.size > capacity) {\\n            val first = head.next!!\\n            remove(first)\\n            map.remove(first.key)\\n        }\\n    }\\n\\n    private fun remove(node: Node) {\\n        val next = node.next!!\\n        val prev = node.prev!!\\n        prev.next = next\\n        next.prev = prev\\n    }\\n\\n    private fun addAtEnd(node: Node) {\\n        val prev = tail.prev!!\\n        prev.next = node\\n        node.prev = prev\\n        node.next = tail\\n        tail.prev = node\\n    }\\n\\n    data class Node(val key: Int, val value: Int) {\\n        var next: Node? = null\\n        var prev: Node? = null\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149697,
                "title": "in-case-you-want-java-to-do-everything-for-you",
                "content": "```\\nclass LRUCache {\\n\\n    private LinkedHashMap<Integer, Integer> cache;\\n    \\n    public LRUCache(int capacity) {\\n        cache = new LinkedHashMap(capacity, 0.75f, true) {\\n            protected boolean removeEldestEntry(Map.Entry eldest) {\\n                return size() > capacity;\\n            }\\n        };\\n    }\\n    \\n    public int get(int key) {\\n        return cache.getOrDefault(key, -1);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (cache.containsKey(key)) cache.remove(key);\\n        cache.put(key, value);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass LRUCache {\\n\\n    private LinkedHashMap<Integer, Integer> cache;\\n    \\n    public LRUCache(int capacity) {\\n        cache = new LinkedHashMap(capacity, 0.75f, true) {\\n            protected boolean removeEldestEntry(Map.Entry eldest) {\\n                return size() > capacity;\\n            }\\n        };\\n    }\\n    \\n    public int get(int key) {\\n        return cache.getOrDefault(key, -1);\\n    }\\n    \\n    public void put(int key, int value) {\\n        if (cache.containsKey(key)) cache.remove(key);\\n        cache.put(key, value);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565345,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1575454,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1567624,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1569541,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1567888,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1565498,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1566106,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1975334,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1569797,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1567328,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1565345,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1575454,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1567624,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1569541,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1567888,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1565498,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1566106,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1975334,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1569797,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1567328,
                "content": [
                    {
                        "username": "pandora111",
                        "content": "Please define what \"used\" means in this least recently used.  Does insertion to cache for the very first time count as being used once?  Please clarify the following 2 case: \\n\\n1) I keep on inserting different key-value pairs to the cache by calling set, then eventually cache reaches its capacity, and I need to invalidate.   \\nset(1, 1)\\nset (2, 1)\\n....\\nset(100, 1) --> capacity is 99, capacity limit reached need to invalidate.  So far, I never called get, so does it matter which entry I invalidate?\\n\\n\\n2) I have a bunch of key-value pairs in the cache, the last entry before cache hits its capacity is a new entry.  The next insertion to cache exceeds the capacity so cache needs to be invalidated, do I invalidate the most recently inserted entry because it was never used?  Imagine I call get twice after inserting each new entry like this \\n\\nset(1, 1)\\nget(1)\\nget(1)\\nset (2, 1)\\nget(2)\\nget(2)\\n....\\nset(99, 1) --> capacity is 99, the next call is NOT get(99) \\nset(100,1) -->  which entry should be invalidated?  (99,1) or (1, 1)?"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "[@SimonKocurek](/SimonKocurek) Good Explanation."
                    },
                    {
                        "username": "SimonKocurek",
                        "content": "You can use this test input to see the expected behavior:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1],[2],[3]]\\n```\\n\\nThe `2, 3` should be in the cache and `1` should be invalidated.\\n\\nSimilarly, in:\\n```\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[3,3],[1,1],[1],[2],[3]]\\n```\\n\\n`1, 3` should be in the cache and `2` should be evicted."
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Does \"used\" mean used for a get, used for a put, or used for either? Question is unclear."
                    },
                    {
                        "username": "Ultron03",
                        "content": "whatever the operation you have done (like putting a new key,value or return a value corresponding to a key using get function ) .They all means that you have used that key ....\\n\\nHope it helps !!"
                    },
                    {
                        "username": "NamKNguyen",
                        "content": "both"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "# How would you design LRU cache?\\n\\nI got really excited aswering this question and decided to write a blog post with a whole walkthrough:\\n\\nhttps://www.romaglushko.com/blog/design-lru-cache/\\n\\nHope it will be helpful for some one \\uD83D\\uDE4C\\nLet me know what do you think and happy problem solving!"
                    },
                    {
                        "username": "shrijon610",
                        "content": "Legendary"
                    },
                    {
                        "username": "mangamojo",
                        "content": "This was awesome. Thank you for the great post!"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "Very easy to understand, and very well written. Simply amazing, thank you )"
                    },
                    {
                        "username": "TimurMP",
                        "content": "Amazing! Thanks!"
                    },
                    {
                        "username": "Arthis_",
                        "content": "very useful, thank you!"
                    },
                    {
                        "username": "yashagrawal20",
                        "content": "this shit is amazing"
                    },
                    {
                        "username": "hgon23",
                        "content": "Why is this question changed from hard to medium ?"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Yeah, I\\'m completely lost on this. Needing a mapping that is not just from int to int, but from int to a pointer or an iterator, absolutely screams Hard."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "the day I submitted this without help"
                    },
                    {
                        "username": "ks24",
                        "content": "There are two ambiguities in the task description. Please clarify the description, because taking the intention from the failed test cases is unnecessarily cumbersome.\\n\\na) The description does not specify which operations count as \"use\", i.e. which operation should trigger an LRU status update. get and set both do, and the description should say so.\\n\\nb) The wording for set() can suggest set-only-upon-add behaviour. Consider reading: \"((Set or insert) if the key is not present)\". Please change to something along: \"Set key, or add it if not present\"."
                    },
                    {
                        "username": "amancha9161",
                        "content": "[@bolemax](/bolemax)  Sed life"
                    },
                    {
                        "username": "bolemax",
                        "content": "It\\'s been 7 years since your comment in the discussions and the description of the problem still hasn\\'t changed. Pathetic."
                    },
                    {
                        "username": "umnik",
                        "content": "What makes this question\\'s difficulty level to change?"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "I think the wording of \"set or insert the value if the key is not already present\"\\n\\nI interpreted that to mean \"if key not present, set the value. If key is present, don\\'t do anything\"\\n\\nWhen the intention was \"no matter if key is present or not, set the key with the new given value\""
                    },
                    {
                        "username": "Romil_",
                        "content": "reason why English is not a programming language.  lol. "
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83C\\uDF89 This question has been a favorite among many companies, and by understanding the approach and implementation, you\\'ll be well-prepared to tackle it with confidence. So, let\\'s dive into the approach and make coding this LRU cache a breeze!\\n\\nApproach:\\n\\n1\\uFE0F\\u20E3 We need to choose a suitable data structure to design our LRU cache. Guess what? A linked list fits the bill perfectly! But why a linked list, you may ask? Well, linked lists allow for efficient addition and deletion of nodes, making them ideal for maintaining the LRU order. \\uD83D\\uDCDA\\n\\n2\\uFE0F\\u20E3 Now, let\\'s establish a vital fact: we want to store the most recently used item next to the head, and the least recently used item near the tail. This way, when we\\'re asked to return the LRU item or need to evict an item, we know exactly where to find it. \\uD83D\\uDCCC\\n\\nImplementation Steps:\\n\\n1\\uFE0F\\u20E3 Adding a new node:\\nTo keep things organized, let\\'s add new nodes just after the head. Don\\'t forget to delete any existing node with the same key before adding the new one. \\uD83C\\uDD95\\n\\n2\\uFE0F\\u20E3 Retrieving a value using a key:\\nInstead of traversing the entire linked list to find the corresponding node, let\\'s leverage the power of a map. We\\'ll store the nodes in the map, with their keys as the lookup values. Once we find the key in the map, it means we\\'ve used it, so we move its corresponding node next to the head. \\uD83D\\uDDFA\\uFE0F\\n\\n3\\uFE0F\\u20E3 Deleting a node:\\nWhen it\\'s time to bid farewell to a node, let\\'s make sure to update the neighboring nodes to bypass the one being deleted. This ensures our linked list remains intact. \\uD83D\\uDEAB\\n\\nThat\\'s it! By implementing these basic functionalities of adding, retrieving, and deleting nodes, you\\'ll have your LRU cache up.\\n\\nYou\\'ve got this! \\uD83D\\uDC69\\u200D\\uD83D\\uDCBB. Kudos if you came so far \\uD83D\\uDCAA!!!\\n\\n"
                    },
                    {
                        "username": "vr840",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nThe following test case has the expected output\\n[null,-1,null,-1,null,null,2,6] \\nand my test case output is this\\n[null,-1,null,-1,null,null,2,-1]\\n\\nAs the least recently used item will be the one at head, so that will be removed when the size of the capacity is more than 2, bit confused on this one?"
                    },
                    {
                        "username": "mustafij48",
                        "content": "This one got me first time too. \\nJust be careful about the update case. While the list is in it\\'s full capacity, there may be situation where you need to update the existing key: value pairs. \\n\\nIn this case, [1,2] will just update [1,5] as they have the same key. It will not evict [2,6]."
                    },
                    {
                        "username": "tire_ks",
                        "content": "[@sam_Eldoro](/sam_Eldoro) i\\'ve also stuck there, but fixed. Look where you\\'re doing putting a new pair. When you add new pair, you check only size of your cache, but you also need to check, if you cache contains new key, \\'cos in this testcase there is one modifying of pair 1-5 to pair 1-2, and you just checkin size, clear old 2-6 pair and then modify your 1-5 to 1-2 (if you check at all, and not just add new pair with the same key) "
                    },
                    {
                        "username": "rusty231",
                        "content": "[@minkowskiq](/minkowskiq)  LRU values here are {2,6} and {1,5}, but {1,5} is the most recent of two, so {2,6} should be removed. Leetcode implemented incorrect algorithm for the task, and now we need to adjust our code to pass the unit test.\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "rusty231",
                        "content": "I stuck here too, and I think unit test and the code behind it is incorrect, [2,6] should be removed from the cache"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "I dont know why but I am also stuck here, can u please explain why is it happing??\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You might be removing the element before inserting the new value.\\nFor the last put, your code might be doing this:\\n```\\n{2:6, 1:5}\\n// As capacity is 2 and we need to insert, remove LRU value\\n{1:5}\\n// Now insert / set\\n{1:2}\\n```"
                    },
                    {
                        "username": "nextgensh",
                        "content": "The test in question is -\n\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\n[[1],[2,1],[2],[3,2],[2],[3]]\n\nThe correct answer for this is - [null,null,1,null,-1,2]\n\nThe answer from my code when I click the \"Submit\" button is -\n[null,null,1,null,1,2]\n\nIf I copy paste this same test case in \"Run Code\" I get the answer from my code -\n[null,null,1,null,-1,2]\n\nMy answer when I use the \"Run Code\" option is correct, I have also checked my code manually by going throug in several times on paper.\n\nI am not using any global variables, using Python and have alread tried clearing my cache.\nAm I missing something here. Please let me know. \n\nThanks !"
                    }
                ]
            },
            {
                "id": 1566481,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1974988,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1569744,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1975132,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1569458,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1567215,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1920365,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1720520,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1568969,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1568971,
                "content": [
                    {
                        "username": "Meteo",
                        "content": "Input:\\n2\\n[0,2,1,0,2,2,1,2,0,1,1,0,4,1,1,2]\\n\\nI assume the first number is the capacity, but what is that array supposed to be?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "That is a good beginning. An update means remove and then insert! Both of get and put need update!\n```\nstruct Node{\n    int key;\n    int value;\n    Node* next;\n    Node* prev;\n    Node(): key(0), value(0), next(NULL), prev(NULL){}\n};\n```"
                    },
                    {
                        "username": "sarangk",
                        "content": "Wrong testcase (#4, same as example) - it is  \"Least\" Recently Used so with following operations:\\n\\n  LRUCache cache(2);\\n\\n  cache.put(1, 1);\\n  cache.put(2, 2);\\n  assert(cache.get(1) == 1);\\n  cache.put(3, 3);         // **evicts key 1, not 2**\\nassert(cache.get(2) == 2); // **should return 2 and not -1 (not found)**\\n  \\n  The example and testcase are wrong to assume that on entering 3, 2 should be evicted (it shouldn\\'t, since the LEAST recently used key is 1, not 2)."
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get() also counts as a use case, so while put(3,3), 2 was LRU since get(1) makes 1 the MostRU."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some more test cases :\\n\\n----------------------------\\n\\n[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"put\",\"put\",\"put\",\"put\",\"get\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\",\"put\"]\\n[[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]\\n\\n------------------------------\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\n\\n------------------------------------\\n\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\n-------------------"
                    },
                    {
                        "username": "mkaleem",
                        "content": "in the question example is\\n\\ncache.put(1, 1);\\ncache.put(2, 2);\\ncache.get(1);       // returns 1\\ncache.put(3, 3);    // evicts key 2\\ncache.get(2);       // returns -1 (not found)\\n\\nfirst (1,1) is put then (2,2) means means least recently used key is 1 so (1,1) should be deleted when going to put (3,3) as size of cache is 2 . but here evict key is 2.\\n\\ncan anyone clarify ?\\n\\n"
                    },
                    {
                        "username": "rahul_rasve_712",
                        "content": "get(1) makes it the MostRU and 2 LRU;\\nThat is, get() also counts as use case."
                    },
                    {
                        "username": "steven21",
                        "content": "Based on my benchmarks I suspect that copy elision is disabled.  I wonder if the tests are biased against use of STL containers which really need compiler optimization (eg inlining) to shine."
                    },
                    {
                        "username": "tejasX",
                        "content": "definitely a HARD one !!"
                    },
                    {
                        "username": "ritikraj26",
                        "content": "I am using a vector to store pointers to doubly-linked list. Why am I getting a TLE on tc 20?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "remove cout print statements from code"
                    },
                    {
                        "username": "guolei329",
                        "content": "I know that DoublyLinkedList in Java is an implementation of Deque, so do you guys really mean it?"
                    },
                    {
                        "username": "A5HU705H",
                        "content": "deque doesn\\'t support deletions at a pointer afaik"
                    },
                    {
                        "username": "XiSmartElf",
                        "content": "\\nInput:\\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput:\\t[1,1,-1]\\nExpected:\\t[1,-1,1]\\n\\n\\nI thought 2,1 would be the LRU and should be removed when set(4,1).\\nso get(1) should be fine but get(2) should be -1.\\n\\nDid I misunderstand LRU??"
                    }
                ]
            },
            {
                "id": 1566753,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 2045102,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 2031806,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1975312,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1974993,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1913482,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1569307,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1568972,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1568973,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1975841,
                "content": [
                    {
                        "username": "ruparel",
                        "content": "Given:\\nset(key, value) - Set or insert the value if the key is not already present\\n\\nBut for the following input\\nInput: \\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nset(2,2) shouldn't be considered because key '2' is already present in the cache with value '1'.\\nso the value for key '2' in the cache should be '1'.\\n\\nBut m getting\\n\\nOutput: \\t[1,-1]\\nExpected: \\t[2,-1]\\n\\nexpected should be [1,-1]"
                    },
                    {
                        "username": "pamphlet",
                        "content": "Should be Hard any day of the week. You don\\'t get away with bumping it down just because it\\'s a \"popular\" question."
                    },
                    {
                        "username": "sahsan73",
                        "content": "My old solution which was accepted now gets TLE on testcase 20."
                    },
                    {
                        "username": "suyash_5050",
                        "content": "Amazon 117 |  Facebook 60  | Microsoft 52 | Apple 20|  Bloomberg 19 |  Oracle 13 |  Salesforce 10 | Google 9 |  Intuit 8 |  Twilio 7 |  Goldman Sachs 6 | TikTok 6 |  LinkedIn 5 |  Byte Dance 5 |  Adobe 4|  Walmart Global Tech 4 |  Yahoo 3|  Snapchat 3|  Nvidia 3 |  VMware 2 |  Uber 2 |  Pay pal 2|  GoDaddy 2 |  Morgan Stanley 2 |  DocuSign | 2 Shopee \\nHard one, but totally worth solving \\uD83D\\uDE0A"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "so finally the question I've been trying, failing and avoiding many times."
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT)  Exactly 😅"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "now we have to solve this to save our streak :\\')"
                    },
                    {
                        "username": "MICIKARTY",
                        "content": "Is it a bug? 22/22 tests passed TL and no ability to view last executed test"
                    },
                    {
                        "username": "zhatka",
                        "content": "put: \"set or insert if the key is not present\"\n\nSo should put update(set) or not when the key is present?\n"
                    },
                    {
                        "username": "CharellkingQu",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]"
                    },
                    {
                        "username": "soysauce",
                        "content": "I used LinkedHashMap to implement Cache but OJ doesn't support this API. I think it is much simpler than creating a doubleLinkedList."
                    },
                    {
                        "username": "Dkj28",
                        "content": "what the test case 22 means. my understanding with it is no object is created, hence no methods call, result no output, when i run it , no output generates, and when i try to submit this testcase shows TLE.\\n\\nmy approach is i used array of size 1e4+1 to check which key is present in hashmap, and haspmap to store key value pair. \\n\\n\\nwant more clarification on testcase 22 and please review my code, i think it time complexity is O(1), correct if wrong? [code](https://onlinegdb.com/MCF_ppK3e)"
                    }
                ]
            },
            {
                "id": 1975553,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1975077,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1974996,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1951260,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1950440,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1694414,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1575063,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1574886,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1574542,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1573614,
                "content": [
                    {
                        "username": "evgkhm",
                        "content": "I used hash-table to store values, capacity of this hash-table and slice (stack in Go) to resolve this problem. \\n"
                    },
                    {
                        "username": "vimalspanwar",
                        "content": "the question is very unclear\\n"
                    },
                    {
                        "username": "fli033",
                        "content": "can someone explain why  the example ejects key 2 instead of key 1 first?"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "[@kylecrowley](/kylecrowley) I think in the time when we put (3,3) it should be (1,1),(3,3) because that is MRU not LRU => so in the next time, we put (4,4) into the cache (1,1) will be replaced by (4,4) and the cache is (4,4), (1,1)"
                    },
                    {
                        "username": "fli033",
                        "content": "[@kylecrowley](/kylecrowley) Thank you!"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Going to simplify the example to focus on the relevant calls:\\nPut(1,1)\\nPut(2,2)\\nGet(1)\\nPut(3,3)\\n\\n**NOTE**: Order is from Most Recently Used (MRU) to Least Recently Used (LRU)\\n\\n`Put(1,1)`: Puts (1,1) into the cache (fresh entry; did not already exist). Cache: { (1,1) }\\n\\n`Put(2,2)`: Puts (2,2) into the cache (fresh entry; did not already exist). Cache: { (2,2), (1,1) }\\n\\n`Get(1)`: Gets the value associated with key `1` (which is also `1`). Cache: { (1,1), (2,2) }\\n**Notice that (1,1) was moved to the front as it is now the MRU**.\\n\\n`Put(3,3)`: Puts (3,3) into the cache (fresh entry; did not already exist).\\nCache (BEFORE eviction): { (3,3), (1,1), (2,2) }\\nCache (AFTER eviction): { (3,3), (1,1) }\\n\\nSo, to answer your question, the reason `2` is ejected before `1` is due to the `Get(1)` call. It\\'s not defined explicitly in the problem but **both** `Get` and `Put` cause the ordering to change.\\n\\nHopefully that made sense."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "I think its better to mark this problem as Hard since its easy to think but hard to implement "
                    },
                    {
                        "username": "brian033",
                        "content": "bruh this is hard"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Hey, the task is obvious. Let\\'s make it more challenging (I was asked such question at FAANG interview onsite).\\n\\nImplement TTL and allow your cache work in multi-threading environment."
                    },
                    {
                        "username": "steman",
                        "content": "I see one of the proposed python solutions involves using OrderedDict. Would it be acceptable to use OrderedDict in an interview, or are you supposed to only use lists and dicts?"
                    },
                    {
                        "username": "code1234567",
                        "content": "In the Java JDK, it is mentioned that LinkedList implementation is of Doubly Linked List: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html#remove-java.lang.Object-\\n\\nSo, I guess in this question, we can use this instead of maintaining our head and tail pointer. Is that right? And I guess remove(object) with this would be O(1)"
                    },
                    {
                        "username": "pb1771",
                        "content": "I have seen many solutions using map and list iteration to solve this problem. A list that maintains a key value pair and a dictionary that points it\\'s respective pair in list for a given key. But what about the case when there is a collision of the keys. Say the simplified hash function= key%1000, then 0, 1000, 2000 hash to the same key location. In that case, the solution listed in the beginning wouldn\\'t work correctly. \\n\\nDoes anyone else think the same and how do I know in an interview when I should be really thinking about collisions?"
                    },
                    {
                        "username": "psionl0",
                        "content": "That is why hash tables employ chaining or probing when the slot is already occupied."
                    },
                    {
                        "username": "ashwin918",
                        "content": "Hi, I was unable to use move_to_end function of OrderedDict of Python as it was giving me an error. Implemented move to end with just 3 lines of codes\\n## Store the key value in temp, delete the key value and insert it again \\n\\n            temp = self.cache[key]\\n            del self.cache[key]\\n            self.cache[key] = temp"
                    }
                ]
            },
            {
                "id": 1573532,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1573525,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1573180,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1573148,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1573028,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1572897,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1572814,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1572731,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1572520,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1572222,
                "content": [
                    {
                        "username": "svashish",
                        "content": "The problem statement mentions that\\n*When the cache reached its capacity, it should invalidate the least recently **used** item before inserting a new item.*\\n\\nThe solution provided considers only an \"**insertion**\" as \"**use**\" while we can also interpret an \"**updation**\" of value as \"**use**\". If that\\'s the case, we also need to store the \"**address of the key in the linked list**\" in the \"**hash table**\" along with the \"**value**\"."
                    },
                    {
                        "username": "cbmsumit",
                        "content": "Use case:\\n[\"LRUCache\",\"put\",\"get\",\"put\",\"get\",\"get\"]\\n[[1],[2,1],[2],[3,2],[2],[3]]\\n\\nExpected output =\\n[null,null,1, null, null, ***1***, 2]\\n\\nActual output =[null,null,1, null, null, ***-1***, 2]\\n\\n\\n\\nCreates Cache with size 1 ==> null\\nPut [2,1] adds set to the cache ==> null\\nget[2] returns value 1 ==> 1\\nPut [3,2] should replace existing value in cache ==> null\\nget [2]  should return -1 because value is not present ==> -1 (expected 1)\\nget [3] should return 2 which is the only value in cache ==> 2\\n"
                    },
                    {
                        "username": "vikhram",
                        "content": "1. The description explicitly states:\\n`Set or insert the value if the key is not already present.`\\nAnd yet the solution expects you to update the value if the key is `put` again with a different value\\n1. The description doesn\\'t specify removal policy when all items in the cache have same age (accessed same number of times). And, yet the solution expects you to remove the last updated element\\n\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cache age is irrelevant. The caches are sorted in order from most recently accessed to least recently accessed."
                    },
                    {
                        "username": "mn002",
                        "content": "Test case 15 is long.  My output is correct up to the truncation point, but my solution is getting rejected.  Suggestions for how to debug?  I don\\'t want to just look at other solutions."
                    },
                    {
                        "username": "thegreatnovice",
                        "content": "As the title, I\\'m wondering if the anser is correct with this input:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nThe answer should be \\n`[null,null,null,1,null,null,-1]`\\nrather than the given one\\n`[null,null,null,2,null,null,-1]`\\n\\nWhat you guys think?\\n"
                    },
                    {
                        "username": "jpan127",
                        "content": "[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\\n\\nCorrect: [null,-1,null,-1,null,null,2,6]\\nExpected: [null,-1,null,-1,null,null,2,-1]\\n\\nHow come the last value for key=2 is 6, when I would think that pair is already evicted when [1,5] comes?\\nAm I wrong to assume that the first get for key=2 when the cache is empty, is useless?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first get will return -1 since the key hasn\\'t been set yet. [2,6] doesn\\'t get evicted when [1,5] comes because that is only modifying a cache that is already in the list."
                    },
                    {
                        "username": "needMoreCoffee",
                        "content": "Can someone tell me what happens when to different entry are in the input with same key?\\nDo I update the  the already present key,value pair with the new key? If so does it change the position?i.e does it act as recently used?\\nor should I insert the key,value pair as a seperate entry when another key,value pair exists with the same key? i.e just treat them as two different entry.\\nwhat should I do. Description nor the example test case is clearing this doubt."
                    },
                    {
                        "username": "user1397f",
                        "content": "Description clearly says: put(key, value) - Set or insert the value **if the key is not already present.**\\nMeaning if the key is present nothing should be done.\\nYet for the below test case it is expected that value for key \\'2\\' is updated from 1 to 2.\\nHow come?\\n\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]"
                    },
                    {
                        "username": "harvey2015",
                        "content": "I created two classes in python3, and the compiler complains about that class is not defined. Is it allowed to define new classes for python solutions?"
                    },
                    {
                        "username": "joemjr2",
                        "content": "I have a question about the expected behavior:\\n\\nWhen you insert a new value, is that value now considered the most recently used item?  Or, is get() the only thing that makes a value the most recently used?\\n\\nExample:\\n\\nLet\\'s say the cache size is 2, then we do:\\n\\nput(1,1)\\nput(2,2)\\nget(1)\\nget(2)\\nput(3,3)\\nput(4,4)\\n\\nWould we evict 3 because it\\'s never been \"used\" (via get()), or do we evict 1 because 3 became immediate \"used\" when it was inserted?\\n\\n-Joe"
                    }
                ]
            },
            {
                "id": 1571985,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1571312,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1571313,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1571315,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1571314,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1571316,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1571317,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1571318,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1574265,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1788261,
                "content": [
                    {
                        "username": "AslanMussinov",
                        "content": "Apparently, this line \"Set or insert the value if the key is not already present.\" means \"If the key is not present, insert the key-value pair, otherwise update the value.\" The ambiguity of that phrase led me to think that you should not process new key-value pair if the key is already present (and therefore you should not update the order of the cache)."
                    },
                    {
                        "username": "psuedoquasi",
                        "content": "I wrote up a tutorial where I go through my approach and my thinking all the way through this problem. I attempt to be language agnostic and describe each section with English or pseudocode before I get in-depth with C++. Check it out if you are having trouble or looking for an expected O(1) implementation.\\n\\nhttps://marquessv.github.io/AllTestsPassed/2017/11/22/leetcode-146-lru-cache.html\\n\\nI'll attempt to answer any questions here or on Twitter. I'd also appreciate feedback on writing style."
                    },
                    {
                        "username": "devika25",
                        "content": "I am trying my own classes for Node and Linked List for LRU Cache problem and while submitting the code it gives me the following compilation error :\\n\\n\"Line 3: error: Node is not public in java.util.stream; cannot be accessed from outside package\"\\n\\nCan someone please help"
                    },
                    {
                        "username": "noshel",
                        "content": "Hi,\\n\\nIn test number 4 i get the following error:\\n\\nInput:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\n\\nOutput:\\t        [1,-1]\\n\\nExpected:\\t[2,-1]\\n\\nBased in the information of set method:\\nset(key, value) - Set or insert the value if the key **is not already present**. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\\n\\nIf we have to avoid setting the new value if the key already exist, then the \"set(2,2)\" should be ignored and the output would be [1,-1].\\n\\nOr maybe the set method explanation needs to be more clarifying."
                    },
                    {
                        "username": "leoncrashcode89",
                        "content": "how to explain these two test data\\n\\ninput    2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\n\\noutput  [1,-1,1]\\n\\nand\\n\\ninput 2,[set(2,1),set(2,2),get(2),set(1,1), set(4,1),get(2)]\\n\\noutput [2,-1]\\n\\nset means used? or get means used? or both?"
                    },
                    {
                        "username": "nikoschen",
                        "content": "i established a queue to solve this quiz using links, and already passed. The idea is straightforward, but not as beautiful as i imagined. I guess there must be more efficient and beautiful methods beyond using queues."
                    },
                    {
                        "username": "yangzai",
                        "content": "Input:\\t2,[set(2,1),set(2,2),get(2),set(1,1),set(4,1),get(2)]\\nOutput:\\t[1,-1]\\nExpected:\\t[2,-1]\\n\\nI don't understand why the expected output is this.\\n\\nIn my understanding, the 2nd set(2,2) should not have any effect on the LRU values. This is because the instruction for the set function says: \"set or insert if the key is not already present\". So for the 1st get(2), the output is 1. After set(1,1) and set(4,1), the key 2 is no longer in the LRU. So 2nd get(2) produces -1.\\n\\nThus, if my understanding is correct, the output should be [1,-1]. Is there anything I am not getting correctly?"
                    },
                    {
                        "username": "Jeffnju",
                        "content": "Input: \\t2,[set(2,1),set(1,1),get(2),set(4,1),get(1),get(2)]\\nOutput: \\t[1,1,-1]\\nExpected: \\t[1,-1,1]\\n\\nThe reason for my output:\\nKey Value\\n 2      1\\n 1      1   get(2) == 1\\n  4     1   get(1) == 1, get(2) == -1 since 2 is not in the record"
                    },
                    {
                        "username": "srevis",
                        "content": "The following case is incorrect:\\n\\nInput:\\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\nOutput:\\n[null,null,null,1,null,null,-1]\\nExpected:\\n[null,null,null,2,null,null,-1]\\n\\nThe problem statement states \"put(key, value) - Set or insert the value if the key is not already present\"\\n\\nthus, the attempt to put (2,2) should be rejected since (2,1) is already consuming key 2.  Thus, the get(2) should return 1, not 2\\n\\nTo add insult to injury, there\\'s a different testcase where this is correctly implemented thus making it totally impossible to pass no matter what you actually do."
                    },
                    {
                        "username": "pranay2063",
                        "content": "Solution using a singly linked list and hashmaps (average TC O(1) ) https://leetcode.com/problems/lru-cache/submissions/891684724/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "You get an upvote for posting a link to your code instead of the entire solution."
                    }
                ]
            },
            {
                "id": 1572818,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 1572078,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 1571965,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2075638,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2074811,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2071293,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2065652,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2053112,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2050284,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2047316,
                "content": [
                    {
                        "username": "coding_medved",
                        "content": "It seems like before it was a \"Hard\" question.\\nDid they lower the difficulty? LRU cache problem seems like a meme."
                    },
                    {
                        "username": "bulldog0890",
                        "content": "I\\'ve actually gotten this question a few times lately in a few interviews. However, its really not difficult to implement, nor is it a rare or unusual structure. Just kind of requires you know to use a doubly linked list and a hash map really."
                    },
                    {
                        "username": "arpithaarpitha",
                        "content": "For the test case, \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\\n[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\\n\\nthe expected output is:\\n[null,null,null,2,null,null,-1]\\n\\nFor get[2], why is the output value 2. The question says that we should insert only if the key is not present. When we inserted [2,1], we insterted the key \\'2\\' and hence we do not need to insert [2,2]. Is my assumption wrong?"
                    },
                    {
                        "username": "fedorucho",
                        "content": "Even the Example1 is incorrect! They put (1, 1), then put (2, 2). When they put (3, 3), they say LRU key is 2, which is wrong, because LRU key is 1 as it was used before key=2 was used. So, this example contradicts with the basic concept of LRU-cache described on the link, that is attached to the task description.\\nSo, the task is very unclear."
                    },
                    {
                        "username": "i_am_loser",
                        "content": "The one and only best solution\\n@STRIVER\\nhttps://www.youtube.com/watch?v=xDEuM5qa0zg&ab_channel=takeUforward"
                    },
                    {
                        "username": "abhrajga",
                        "content": "why the solution with deque in c++, fails at deque.erase\n\nmy code - \nclass LRUCache {\npublic:\n    struct Node{\n        int key;\n        int value;\n        Node(int key, int value){\n            this->key = key;\n            this->value = value;\n        }\n    };\n    int capacity;\n    deque<Node> dq;\n    unordered_map<int, deque<Node>::iterator> ump;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n    \n    int get(int key) {\n        \n        if(ump.find(key)!=ump.end()){\n            auto itr = ump[key];\n            int value = itr->value;\n\n            \n            dq.push_front(*itr);\n            \n            dq.erase(itr); // ----> here the code fails\n            \n            \n            ump[key] = dq.begin();\n            return value;\n        }\n        \n        return -1;\n\n    }\n    \n    void put(int key, int value) {\n        \n        if(ump.find(key)!=ump.end()){\n           \n            auto itr = ump[key];\n            itr->value = value;\n            dq.push_front(*itr);\n            dq.erase(itr);\n            ump[key] = dq.begin();\n        }\n        else{\n            if(dq.size()==capacity){\n                \n                Node lru = dq.back();\n                dq.pop_back();\n                ump.erase(lru.key);\n            }\n            Node node = Node(key,value);\n            dq.push_front(node);\n            ump[key] = dq.begin();\n        }\n    }\n};\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "stupid and ugly question"
                    },
                    {
                        "username": "aussiedev81",
                        "content": "I\\'m so confused with regards to what constitutes \\'least recently used\\' (LRU), and hoping someone can help clarify this for me\\n\\n```\\n// Provided explanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n```\\nNo matter which way I look at the explanation provided, line 7 `lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}` is wrong as the LRU key would in fact be 3 because it hasn\\'t been called before, but key 1 has been called once before on line 4.  \\nThis would remove key 3 and add key 4 resulting in cache `{1=1, 4=4}`\\n\\nWhether LRU is applied only when the `get` method is called or both `get` and `put` I arrive at the exact same solution."
                    },
                    {
                        "username": "nikalinov",
                        "content": "That must be hard bruv. I could solve it only after 3 hours."
                    },
                    {
                        "username": "Vithesh",
                        "content": "A great thanks to this question for teaching me so many things.."
                    }
                ]
            },
            {
                "id": 2045046,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 2037396,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 2031543,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 2030018,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 2024158,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 1982438,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 1977024,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 1976749,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 1976206,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 1976184,
                "content": [
                    {
                        "username": "IlanIwumbwe",
                        "content": "I\\'m probably missing something, but for this test case,\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n\\nI don\\'t get why the output should be \\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]\\nAt that point, I belive the cache looks like this \\n3 {2: 2, 4: 4, 5: 5}, 3 having been removed in the previous iteration\\n\\nSo i expected this\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "[@IlanIwumbwe](/IlanIwumbwe)\nAfter the first four `put` operations:\n`{2: 2, 3: 3, 4: 4}` (least recent first)\nAfter the next four `get` operations:\n`{4: 4, 3: 3, 2: 2}`\nThen, when `5` is inserted, `4` is dropped."
                    },
                    {
                        "username": "IlanIwumbwe",
                        "content": "[@tifv](/tifv) Thanks for the reply. I think I take into account the get operation as well\\nThis is the full test case:\\n[\"LRUCache\",\"put\",\"put\",\"put\",\"put\",\"get\",\"get\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\",\"get\",\"get\"]\\n[[3],[1,1],[2,2],[3,3],[4,4],[4],[3],[2],[1],[5,5],[1],[2],[3],[4],[5]]\\nMy output:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,-1,4,5]\\nExpected:\\n[null,null,null,null,null,4,3,2,-1,null,-1,2,3,-1,5]"
                    },
                    {
                        "username": "tifv",
                        "content": "Test case has two input arrays, operations and parameters. You have only wrote one array, operations, so it is hard to tell what the output should be.\\n\\nAnyway, the most common misunderstanding is that `get` operations are also using (as in \\u201Cthe least recently used\\u201D) the value. Hope it helps :) otherwise, please give the full test case."
                    },
                    {
                        "username": "xiaochuanyang",
                        "content": "LeastRU or MostRU ?????\\n\\nThere is clearly an issue in test case 1.  \\nThe first evicted key should be 1 which comes first in the dictionary  (the least recent key).  "
                    },
                    {
                        "username": "tifv",
                        "content": "Did you notice that get operations also count as \\u201Cusing\\u201D the key?"
                    },
                    {
                        "username": "drdarker",
                        "content": "whats if wrong with my solution ..  \\n\\n\\n`class Node():\\n    def __init__(self, key=-1, val=-1, next=None, prev=None):\\n        self.val = val\\n        self.next = next\\n        self.prev = prev\\n        self.key = key\\n\\n\\nclass LRUCache:\\n\\n    def __init__(self, capacity: int):\\n        self.capacity = capacity\\n        self.head = Node()\\n        self.last = Node()\\n        self.head.next = self.last\\n        self.last.prev = self.head\\n        self.hash = {}\\n\\n    def deleteLeastUsed(self):\\n        node = self.last.prev\\n        # print(self.last.prev.val)\\n        del self.hash[node.key]\\n        last = self.last.prev.prev\\n        last.next = self.last\\n        self.last.prev = last\\n        \\n\\n    def get(self, key: int) -> int:\\n        if key not in self.hash:\\n            return -1\\n        node = self.hash[key]\\n        self.makeRecent(node)\\n        return node.val\\n        \\n        \\n    def makeRecent(self, node):\\n        prev = node.prev\\n        next = node.next\\n        prev.next = next\\n        next.prev = prev\\n        head_next = self.head.next\\n        self.head.next = node\\n        node.prev = self.head.next\\n        node.next = head_next\\n        head_next.prev = node\\n\\n    def put(self, key: int, value: int) -> None:\\n        \\n        if len(self.hash) + 1 > self.capacity:\\n            self.deleteLeastUsed()\\n        newNode = Node(val=value, key=key)\\n        head_next = self.head.next\\n        self.head.next = newNode\\n        newNode.prev = self.head.next\\n        newNode.next = head_next\\n        head_next.prev = newNode\\n        self.hash[key] = newNode`"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A stupid drill. The problem itself is not hard, but it requires tons of pointer juggling."
                    },
                    {
                        "username": "tifv",
                        "content": "Depends on approach. If you went with linked lists, then probably yes, you would need to work with pointers. Linked lists can usually be avoided, though."
                    },
                    {
                        "username": "Davidch4r",
                        "content": "For those who use python, OrderedDict() can be a god sent. I used minimal code for the cache and got very fast speed"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "test case 20 passed and after that TLE is coming"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Solved this question last night when I was high 🤯. Zuckerberg who? \nhttps://leetcode.com/problems/lru-cache/solutions/3787427/simple-java-solution-using-hashmap-only/"
                    },
                    {
                        "username": "ingato",
                        "content": "I\\'m confused about a few things. The first being what is consider a \"use\", but also what is that output and where does it come from? I assume the test is running through the input and looking at the result of the get function each time as the output, but what are all the \"null\" outputs? They match up with the constructor and put calls, but where in the world would you be outputting from these?"
                    },
                    {
                        "username": "Aetherus",
                        "content": "It turned out that both `get` and `put` are considered a \"use\".\n\nIn some languages, functions/methods always return something (as long as there's no error raised), even if it's a null / nil / None / undefined."
                    },
                    {
                        "username": "tifv",
                        "content": "`null` means exactly this, lack of output. In some languages every function returns some output, and `null` or `None` is a placeholder in cases there is no actual return value."
                    },
                    {
                        "username": "user5400vw",
                        "content": "wow, this was challenging!  the O(1) constraints with some hints from the comments showed me you can do some nice things with a combo of maps and doubly linked lists."
                    },
                    {
                        "username": "luckytheracerrr",
                        "content": "I had a doubt in this when\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n\nwhen it get(1) so after that cache should be {2=2,3=3} why it is {1=1,3=3}???"
                    }
                ]
            },
            {
                "id": 1976143,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1976089,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975952,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975911,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975745,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975620,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975579,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975511,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975430,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975356,
                "content": [
                    {
                        "username": "kumaraashish118",
                        "content": "I've implemented LRU Cache using Unordered Map and Doubly Linked List but getting runtime error on the following testcase. Can anyone please help on where the issue might be?\n\nTestcase:\n`[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]`\n`[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]`\nCode:\n```cpp\n\nclass LRUCache {\npublic:\n    class Node {\n    public:\n        int key;\n        int val;\n        Node *next;\n        Node *prev;\n\n        Node(int key, int val) {\n            this->key = key;\n            this->val = val;\n            this->next = NULL;\n            this->prev = NULL;\n        }\n    };\n\n    class NodeList {\n    public:\n        Node *head;\n        Node *tail;\n        int size;\n\n        NodeList() {\n            this->size = 0;\n            this->head = NULL;\n            this->tail = NULL;\n        }\n\n        Node* insert(int key, int val) {\n            Node *node = new Node(key, val);\n            if(this->size == 0) {\n                this->head = node;\n                this->tail = node;\n            } else {\n                if(this->tail)\n                    this->tail->next = node;\n                this->tail = node;\n            }\n            this->size++;\n            return node;\n        }\n\n        void remove(Node *node) {\n            if(!node || this->size == 0) return;\n\n            Node *prev = node->prev, *next = node->next;\n            if(prev)\n                prev->next = next;\n            else\n                this->head = next; \n            if(next)\n                next->prev = prev;\n            else\n                this->tail = prev;\n            delete(node);\n            this->size--;\n        }\n\n        void clear() {\n            this->head = NULL;\n            this->tail = NULL;\n            this->size = 0;\n        }\n\n        Node* front() {\n            return this->head;\n        }\n    };\n\n    int c, len = 0;\n    unordered_map<int, Node*> mp;\n    NodeList q;\n\n    LRUCache(int capacity) {\n        this->mp.clear();\n        this->q.clear();\n        this->c = capacity;\n        this->len = 0;\n    }\n    \n    int get(int key) {\n        if(this->len == 0 || this->mp.find(key) == this->mp.end())\n            return -1;\n    \n        Node* node = this->mp[key];\n        int val = node->val;\n        this->q.remove(node);\n        this->mp[key] = this->q.insert(key, val);\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(this->c == 0)\n            return;\n\n        if(this->mp.find(key) == this->mp.end()) {\n            if(this->len == this->c) {\n                Node* node = this->q.front();\n                this->mp.erase(node->key);\n                this->q.remove(node);\n            } else this->len++;\n        } else {\n            Node *node = this->mp[key];\n            this->mp.erase(key);\n            this->q.remove(node);\n        }\n        this->mp[key] = this->q.insert(key, value);\n    }\n};\n```"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`NodeList::insert()` should append a new node to the doubly-linked list. But it does not set all pointers correctly, `tail->prev` is always `NULL`, even if there are previous nodes.  \\nAlso, this solution dynamically allocates memory for the nodes with `new`, but does not `delete` them."
                    },
                    {
                        "username": "charonme",
                        "content": "PHP \"arrays\" are hash maps that also remember the order of item insertion, so should using this feature instead of implementing a doubly linked list be considered \"cheating\"?"
                    },
                    {
                        "username": "shrutisahu8024",
                        "content": "\ncan anyone tell me what's wrong?\nwhy for get(1) is giving me 1 not -1??\n\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\noutput:\n[null,null,null,1,null,-1,null,1,3,4]\n expected:\n[null,null,null,1,null,-1,null,-1,3,4]\n\nclass LRUCache {\n  int cacheSize;\n  unordered_map<int,int> LRU;\n  int numElement=0;\npublic:\n    LRUCache(int capacity) {\n      cacheSize=capacity;\n    }\n    \n    int get(int key) {\n      if(LRU.find(key)!=LRU.end())return LRU[key];\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if(LRU.find(key)==LRU.end() && numElement<cacheSize){\n        LRU[key]=value;\n        numElement++;\n      }\n      else{\n        if(numElement==cacheSize){\n          auto x=LRU.begin();\n          for(auto x:LRU)continue;\n          LRU.erase(x);\n          numElement--;\n        }\n        LRU[key]=value;\n      }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`LRU.erase(x)` effectively deletes the element that `LRU.begin()` refers to. (The `x` in the `for` loop is a separate variable, that loop has no effect.)\\nThis `LRU.begin()` can be *any* element, it\\'s unlikely that it\\'s the least-recently used element.  \\nYou have to find a way to keep track of the usage of the elements so that you can erase the least-recently used one.  "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "Is using LinkedHashMap allowed in interviews?"
                    },
                    {
                        "username": "sunny8080",
                        "content": "A Theoretical Type problem"
                    },
                    {
                        "username": "Ultron03",
                        "content": "kind of theoritical but a nice use of DLL."
                    },
                    {
                        "username": "datnguyen02",
                        "content": "i confuse about the example1: \\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\\nwhen we put(3,3) to the cache, i think we have to evict (1,1) but why the answer evict (2,2)?\\n\\n"
                    },
                    {
                        "username": "evanedeepraj",
                        "content": "consider get & post method element used as recently used element, so here after get (1)  LRU is 2 so we have to evict 2"
                    },
                    {
                        "username": "MayuD",
                        "content": "because we are accessing 1 thus moving 2 to the LRU\\n"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "NICE REVISION"
                    },
                    {
                        "username": "superpie",
                        "content": "This is the example which they have given: \\n\\nInput\\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\\nOutput\\n[null, null, null, 1, null, -1, null, -1, 3, 4]\\n\\nExplanation\\nLRUCache lRUCache = new LRUCache(2);\\nlRUCache.put(1, 1); // cache is {1=1}\\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\\nlRUCache.get(1);    // return 1\\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\\nlRUCache.get(2);    // returns -1 (not found)\\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\\nlRUCache.get(1);    // return -1 (not found)\\nlRUCache.get(3);    // return 3\\nlRUCache.get(4);    // return 4\\n\\n For this operation: lRUCache.put(3, 3); Why is the key 2 getting removed ? Isnt Key 1 the least recently used ?"
                    },
                    {
                        "username": "superpie",
                        "content": "[@MayuD](/MayuD) Ohh yes.. Thank you"
                    },
                    {
                        "username": "MayuD",
                        "content": "After accessign 1 through get() 2 is rthe least recently used as its not used before"
                    },
                    {
                        "username": "Isha307",
                        "content": "Why is this giving TLE?\n\npublic:\n    deque<int> d;\n    int size,k;\n    deque<int>::iterator it;\n    unordered_map<int,int> mp;\n    LRUCache(int capacity) {\n        size = capacity;\n    }\n    int get(int key) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k = *it;\n            d.erase(it);\n            d.push_back(k);\n            return mp[key];  \n        }\n        return -1;\n    }\n void put(int key, int value) {\n        it = find(d.begin(),d.end(),key);\n        if(it != d.end()){\n            k=*it;\n            d.erase(it);\n        }\n        if(d.size()==size){\n            mp.erase(d.front());\n            d.pop_front();\n        }\n        d.push_back(key);\n        mp[key]=value;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`find(d.begin(), d.end(), key)` and `d.erase(somewhere_in_the_middle)` take linear time, you need something faster.  \\nAlso, `d.erase()` invalidates all iterators.  "
                    },
                    {
                        "username": "arghyadas",
                        "content": "# You know what\\'s coming tomorrow\\nLFU Cache\\uD83D\\uDE2D "
                    }
                ]
            },
            {
                "id": 1975328,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975303,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975267,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975212,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975204,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975147,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975092,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975082,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975042,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1975016,
                "content": [
                    {
                        "username": "user7684d",
                        "content": "Somebody please explain me -- \" What is meant by least recently used key ?\""
                    },
                    {
                        "username": "psionl0",
                        "content": "It means that every other key in the cache list has been accessed more recently than the key in question."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Why GOD,\\nWHYYYYYY"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The problem can be AC by using set, but the time complexity of put and get are log(n). I am thinking how to optimize it to o(1) level."
                    },
                    {
                        "username": "huikinglam02",
                        "content": "this is a very nice problem... thoroughly test your understanding of data structure\nIn the first run I used the ordereddict in python, but really, to be good at DSA one should write this in different languages by yourself"
                    },
                    {
                        "username": "julkar9",
                        "content": "python dicts retain insertion ordering, so is there any advantage using a d-linked list ?"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Roughly took 100 lines of code \\u263A"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I couldnt understand using Java\\'s internal collection like map and linkedlist results in TimeLimitExceeds problem for last second test case.\\nIn general application side nobody writes our own linkedlist to traverse and insert node, everybody prefers to use inbuilt data structures."
                    },
                    {
                        "username": "Jayendra2688",
                        "content": "i just used vector  and incap variable to solve this problem ,\\nwhen ever incap increases cap i will go to v[ind-cap] and delete that key from the map, please exaplain why it is failing .(15/22)passed.\\nclass LRUCache {\\npublic:\\n    vector<int>v;\\n    int ind = -1;\\n    int cap ;\\n    int incap = 0;\\n    map<int,int>mp;\\n    LRUCache(int capacity) {\\n        cap = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)!=mp.end()){\\n            v.push_back(key);\\n            ind++;\\n            return mp[key];  \\n        }\\n        return -1;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            mp[key]=value;\\n            ind++;\\n            v.push_back(key);\\n            return;\\n        }\\n        mp.insert({key,value});\\n        v.push_back(key);\\n        incap++;\\n        ind++;\\n        if(incap>cap){\\n            mp.erase(v[ind-cap]);\\n            incap--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution removes `v[ind - cap]` but that\\'s not necessarily the least-recently used item.  \\nLook at this example:  \\n```cpp\\n    LRUCache* obj = new LRUCache(2);\\n    obj->put(1, 1);  // obj contains {{1,1}}\\n    obj->put(2, 2);  // obj contains {{2,2}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n    obj->put(3, 3);  // obj contains {{3,3}, {1,1}}\\n    assert(obj->get(1) == 1);    // obj contains {{1,1}, {2,2}}\\n```\\nBut in your solution during the `put(3, 3)` the item `{1,1}` gets deleted, not the least-recently used item `{2,2}`."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "An element is considered used when it is accessed by the \"Get\" method AND when it is added or modified by the \"Put\" method. The question description definitely isn\\'t clear on that."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s a good thing that this isn\\'t the LFU Cache problem. I still can\\'t figure out why testcase 25 (the final test) is the only one that gives a wrong answer in that problem."
                    }
                ]
            },
            {
                "id": 1970839,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1969782,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1960100,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1952032,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1949996,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1941739,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1938234,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1914953,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1903131,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1900337,
                "content": [
                    {
                        "username": "CaptainStark07",
                        "content": "\\n20 / 22 testcases passed \\uD83D\\uDE22"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\nstruct node {\n    int key;\n    int val;\n    node* next;\n    node* prev;\n    node(int key, int val)  {\n        this->key = key;\n        this->val = val;\n    }\n};\nint Size;\nunordered_map<int, node*> Map;\nnode* head = new node(-1, -1);\nnode* tail = new node(-1, -1);\nLRUCache::LRUCache(int capacity) {\n    Size = capacity;\n    head->next = tail;\n    tail->prev = head;\n}\nvoid addNode(node* Node)  {\n    node* tmp = head->next;\n    Node->next = tmp;\n    Node->prev = head;\n    head->next = Node;\n    tmp->prev = Node;\n}\nvoid deleteNode(node* Node)   {\n    node* tmp = Node->next;\n    node* prv = Node->prev;\n    tmp->prev = prv;\n    prv->next = tmp;\n}\nint LRUCache::get(int key) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        int res = address->val;\n        Map.erase(key);\n        deleteNode(address);\n        addNode(address);\n        Map[key] = head->next;\n        return res;\n    }\n    return -1;\n}\nvoid LRUCache::set(int key, int value) {\n    if(Map.find(key) != Map.end())  {\n        node* address = Map[key];\n        Map.erase(key);\n        deleteNode(address);\n    }\n    if(Map.size() == Size)  {\n        Map.erase(tail->prev->key);\n        deleteNode(tail->prev);\n    }\n    addNode(new node(key, value));\n    Map[key] = head->next;\n}\n```\nWhy this is showing runtime error?"
                    },
                    {
                        "username": "lancaster28",
                        "content": "The question as designed cannot be completed in Elixir. There are no classes so the idea of an init_ function makes no sense. Instead it needs to be changed so that the get and put accept a LRUCache to operate on..."
                    },
                    {
                        "username": "tifv",
                        "content": "Here is an (incorrect) implementation of cache that stores elements but lacks eviction capability (just a map, essentially). Hopefully it can be used it as a starting point.\\n\\n```elixir\\ndefmodule LRUCache do\\n\\n  @spec init_(capacity :: integer) :: any\\n  def init_(capacity) do\\n    try do\\n      :ets.delete(:lru_cache)\\n    rescue\\n      ArgumentError -> {}\\n    end\\n    :ets.new(:lru_cache, [:named_table])\\n  end\\n\\n  @spec get(key :: integer) :: integer\\n  def get(key) do\\n    case :ets.lookup(:lru_cache, key) do\\n        [] -> -1\\n        [{_, value} | _] -> value\\n    end\\n  end\\n\\n  @spec put(key :: integer, value :: integer) :: any\\n  def put(key, value) do\\n    :ets.insert(:lru_cache, {key, value})\\n  end\\nend\\n```"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Update the `value` of the `key-value` if the `key` exists."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "My second time doing this problem. Still can\\'t get it right. Gotta rethink about my career choices now."
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Well... I am also a noob programmer , i have practiced this problem around 3-4 times. I wont remember exact coding solution but i remember the concept. So my advice is \" Try to understand the concept or logic not the excat code\". Using the concept/logic try to build the answer. Hope, this will help you in long run. Try to understand \"LRU cache\" first. Then try to solve \"LFU cache\" only when you completly understand this problem."
                    },
                    {
                        "username": "tm20021392",
                        "content": "Probably my favorite design problem. Wish it defines what \\u201Cuse\\u201D means. Also curious about the use of OrderDict C# solution, even though it\\u2019s O(n)"
                    },
                    {
                        "username": "rkm6",
                        "content": "I used deque for tracking LRU information and unordered_map for maintaining the cache. I have 20/22 test cases passing and am seeing TLE error for the 21st case which has lots of operations (probably of the order of 10^5 edge case). Any ideas on why that is happening? Deque is supposed to be faster and more efficient than stacks and queues ([https://stackoverflow.com/questions/59542801/why-is-deque-faster-than-queue])."
                    },
                    {
                        "username": "The_Laughing_Storm",
                        "content": "I am trying to use list/queue to solve this problem. I have passed 15/22 testcases but i think i am missing some edge case or there is some silliy mistake in my code that i cannot find. If anyone of you can find it then please help\n \n`class LRUCache:\n\n    def __init__(self, capacity: int):\n\n        self.cap = capacity\n\n        self.keys = {}              #map to store keys and retrieve value\n\n        self.keyloc = {}            #map to store usage sequence of keys\n\n        self.q = []                 #usage sequence of keys\n\n    def get(self, key: int) -> int:\n\n        if key in self.keys:\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            val = self.keys[key]\n\n            return val\n\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n\n        if key in self.keys:\n\n            self.keys[key] = value\n\n            self.q.append(self.q.pop(self.keyloc[key]))\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        if len(self.q) < self.cap:\n\n            self.q.append(key)\n\n            self.keys[key] = value\n\n            self.keyloc[key] = len(self.q) - 1\n\n            return\n\n        p = self.q.pop(0)\n\n        del self.keys[p]\n\n        del self.keyloc[p]\n\n        for i in self.keyloc:\n\n            self.keyloc[i] -= 1\n\n        self.q.append(key)\n\n        self.keys[key] = value\n\n        self.keyloc[key] = len(self.q) - 1`"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "In OAs, is it fine to directly use dll (list<int>()) without manual implementation?"
                    },
                    {
                        "username": "kos2kos",
                        "content": "[\"LRUCache\",\"put\",\"get\"]\\n[[1],[2,1],[2]]\\n\\nCan someone explain this to me, in my head it is the following\\n\\nCreate cache of size 1\\ninsert value 2, of time 1.\\nCache = {2:1}\\nget: Return 2.\\n\\nWhy is the expected value one?!"
                    }
                ]
            },
            {
                "id": 1899320,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1873920,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1863450,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1838885,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1818562,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1818500,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1806162,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1790081,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1785420,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1781307,
                "content": [
                    {
                        "username": "mostafa00717",
                        "content": "honesly, this question is kind of useless. i've been studying computer engineering and in Computer Architechture lesson the LRU replacement policy is one of the policies but the expected algorithem has a bad descrption and worse testcases. WHY NOT DESCRIBING EXACTLY?! this policy can be written with different logics!"
                    },
                    {
                        "username": "praveen48",
                        "content": "I got this question in interview of CashFree..,   The interviewer has mugged this solution (without using linkedHashmap), and he was expecting me to come up with 100% working code as exactly provided in \\'Editorial\\' section within 30 minutes.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you manage?"
                    },
                    {
                        "username": "memohacan",
                        "content": "The question nor the wikipedia page state that you have to remove the last added. In the wiki page there is a value and lowest value gets deleted.  Confusing question"
                    },
                    {
                        "username": "elenaoat",
                        "content": "This question doesn\\'t have enough examples to explain the problem. I don\\'t know how to suggest more examples or modify the current ones. \\nFor example, it\\'s unclear what means least recently used. Apparently, \"using\" encompasses both the case when \\na) a key is accessed with get\\nb) a key is put\\nSo the case when a key already exists but you are trying to update it, is ambiguous. What they ask you for is:\\n1. you make the key most recently used\\n2. you don\\'t increase the current capacity counter. Meaning you don\\'t care about capacity in this case, because the key already existed and you are just updating. Except you aren\\'t just updating it, but you are also changing key\\'s order in the structure (above point 1.) "
                    },
                    {
                        "username": "vinnie17",
                        "content": "Please help\\nPlease tell why my code is failing\\n\\n\\nclass LRUCache {\\n    class Node{\\n        int key, val;\\n        Node next;\\n        Node prev;\\n\\n        Node(int key, int val){\\n            this.key = key;\\n            this.val = val;\\n            this.next = null;\\n            this.prev = null;\\n        }\\n    }\\n    int capacity;\\n    HashMap<Integer, Node> map = new HashMap<>();\\n    Node head = new Node(0, 0);\\n    Node tail = new Node(0, 0);\\n\\n    public void remove(Node node){\\n        Node prv = node.prev;\\n        Node nxt = node.next;\\n        prv.next = nxt;\\n        nxt.prev = prv;\\n    }\\n\\n    public void insert(Node node){\\n        Node prv = tail.prev;\\n        prv.next = node;\\n        node.prev = prv;\\n        node.next = tail;\\n        tail.prev = node;\\n    }\\n\\n    public LRUCache(int capacity) {\\n        this.capacity = capacity;\\n        head.next = tail;\\n        tail.prev = head;\\n    }\\n    \\n    public int get(int key) {\\n        if(!map.containsKey(key)){\\n            return -1;\\n        }\\n\\n        remove(map.get(key));\\n        insert(map.get(key));\\n        return map.get(key).val;   \\n    }\\n    \\n    public void put(int key, int value) {\\n        if(map.containsKey(key)){\\n            map.remove(key);\\n        }\\n        Node node = new Node(key, value);\\n        map.put(key, node);\\n        insert(node);\\n\\n        if(map.size() > capacity){\\n            Node temp = head.next;\\n            remove(temp);\\n            map.remove(temp.key);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache obj = new LRUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */"
                    },
                    {
                        "username": "vinnie17",
                        "content": "Why are we using doubly linked list instead of single linked list?\\nWe are not moving backwards?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@user4796V](/user4796V) Maybe but it would appear to have a space penalty compared to just adding an extra node pointer to a node."
                    },
                    {
                        "username": "user4796V",
                        "content": "[@psionl0](/psionl0) you can create another hash map that maintain the key for the node (of a sll ) and the the node that appears before"
                    },
                    {
                        "username": "psionl0",
                        "content": "To remove a node from a SL list, you have to follow the links from the head to the node in question which makes it an O(N) operation and since get and put both involve moving nodes to the head of the list, you will get TLE.\\n\\nBut a node in a DL list can remove itself without the need to follow links so it is an O(1) operation."
                    },
                    {
                        "username": "user4366Av",
                        "content": "For C# I\\'m getting time outs even with an O(1) reads/writes. I even looked at this solution, which is identical to what I\\'m doing and it times out on the larger test cases (even copy/pasting their solution). [https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ ](https://leetcode.com/problems/lru-cache/solutions/1065496/c-two-implementationsordered-dictionary-linkedlist-and-their-comparison-with-explanation/ )\\nWhat gives?"
                    },
                    {
                        "username": "darcese22",
                        "content": "Please change the description to state that both get and put update the cache\\'s most recently used order.\\n\\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\\n\\nImplement the LRUCache class:\\n\\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\\nThe functions get and put must each run in O(1) average time complexity.\\nBoth get and put calls should update the cache."
                    },
                    {
                        "username": "rusty231",
                        "content": "Incorrect unit test\n\n[\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n[[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\nExpected:\n[null,-1,null,-1,null,null,2,6]\nShould be:\n[null,-1,null,-1,null,null,2,-1]\n\nAfter putting {1,5} into the cache we end up with having two pairs in the cache\n{2,6}, {1,5}\n\nNow we need to add {1,2}\nWhich one to remove ? Both were never used.\nOfc {2,6}. Why would we keep oldest pair in our cache ?\n\nBut the leetcode algorithm removes {1,5} , which does not make any sense.\n\nLeetcode pls fix it."
                    },
                    {
                        "username": "Suryavanshi_97",
                        "content": "Can we solve this question using hashmap+queue datastructure\\nThe queue front would store the most recent element and the queue back would store the least recent element?\\nI was wondering if every operation could be done in O(1) TC"
                    }
                ]
            },
            {
                "id": 1779276,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1778422,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1774924,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1768478,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1761020,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1750385,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1738956,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1733597,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1729393,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1728689,
                "content": [
                    {
                        "username": "ajaygonepuri",
                        "content": "class LRUCache {\\npublic:\\n    int csize ;\\n    list<int> dl;\\n    unordered_map<int, int> mp;\\n    LRUCache(int capacity) {\\n        csize = capacity;\\n    }\\n    \\n    int get(int key) {\\n        if(mp.find(key)==mp.end()) return -1;\\n        dl.pop_back();\\n        dl.push_front(key);\\n        return mp[key];\\n    }\\n    \\n    void put(int key, int value) {\\n        if(mp.find(key)!=mp.end()){\\n            dl.pop_back();\\n\\n        }\\n        if(dl.size()==csize){\\n            mp.erase(dl.back());\\n            dl.pop_back();\\n        }\\n        dl.push_front(key);\\n        mp[key] = value;\\n    }\\n};\\nWhat is wrong in my code It fails at testcase15??\\nPlease Help!\\n"
                    },
                    {
                        "username": "Olegusaloe",
                        "content": "If we have pairs with the same key in the cache, like {2=1,2=2} which value should get(2) for example return?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You shouldn\\'t have that. It suggests that you added another case with the same key when you should have updated the existing key."
                    },
                    {
                        "username": "firby121",
                        "content": "This is the type of question that should be asked in an interview. There\\'s no trick and requires minimum prior knowledge. It well reflects the candidate\\'s ability of implementing their own thoughts. Be able to implement an idea is the most important thing in real work. Algorithms can be googled."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mars_999",
                        "content": "For me designing the LRU Cache was not intuitive. \n- why Doubly linked list: insert and remove needs be O(1).\n - After I got started with implementation, understood it has to be circular doubly linked list. Thats how we can remove the Least Recently Used key, value node(tail of doubly linked list) in O(1) time. "
                    },
                    {
                        "username": "gawalipraveen",
                        "content": "What is recommended solution for LRU Cache during interview ? using LinkedHashMap or Doubly linked list? Doubly linked list is much lengthy code and requires practice. Can I write solution usingLinkedHashMap and explain the approach using doubly linked list if needed?"
                    },
                    {
                        "username": "VladimirKataev",
                        "content": "So one part that seems to be hard to read, is that the \\'get\\' operation is using the key, but is the \\'put\\' operation using the key? Is this different for whether the key already exists or not?."
                    },
                    {
                        "username": "iviewdor",
                        "content": "The description is misleading - quoting:\\n\"The functions get and put must each run in O(1) average time complexity.\"\\n\\nNote that \"O(1)\" means \"worst case complexity\",\\nwhile \"Theta(1)\" is \"average case complexity\".\\n\\nSolving this question as described is *impossible* in today\\'s software technology.\\nRead more here:\\nhttps://en.wikipedia.org/wiki/Big_O_notation#Family_of_Bachmann%E2%80%93Landau_notations\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E O(1) FAANG Method Ever !!!\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/lru-cache/solutions/2952261/easiest-o-1-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            }
        ]
    },
    {
        "title": "Strobogrammatic Number",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564898,
                "content": [
                    {
                        "username": "jessieqiu126",
                        "content": "I think \\'2\\' and \\'5\\' can also be looked as \"Strobogrammatic Number\"\\n\\'1\\' and \\'8\\' are not even exactly Strobogrammatic if you want it to look perfectly rotationally symmetric .\\nWikipedia thinks \\'2\\' is Strobogrammatic.\\nIt really depends on how you define it. This is not a hard question, just please clarify it in the description."
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I was confused too. I also forgot that 0 is also a valid number. Though, I think it\\'s good to not have everything in the problem description because it\\'ll make us better at thinking edge cases ourself because for 2 and 5 I ran a test case and it return false. Kind of like asking the interviewer."
                    },
                    {
                        "username": "Noah492",
                        "content": "For those annoyed with the lack of clarity, the strobogrammatic numbers are 0, 1, and 8 on their own. The pair of 6 and 9 are counted."
                    },
                    {
                        "username": "JimHuddle",
                        "content": "I\\'m using a digital clock, and when I turn 629 upside down, it\\'s the same.\\nBoth 2 and 5 are strobogrammatic with themselves\\n555 = 555\\n2605092 = 2605092\\n\\nAssume we are \"rotating\" on the z-axis\\nAnd digital numbers are close enough\\n\\nI did a test of 629 and got \"expected false\""
                    },
                    {
                        "username": "zme",
                        "content": "This question is example that on interview better ask details before realisation. Or perform test for cases with 2, 5 and 1 before submit."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_strobogrammatic(num)\\n      num == num.tr(\"6923457\", \"96\").reverse\\n    end\\n\\nBased on [AsianHippo's solution](https://leetcode.com/discuss/85661/java-solution-by-comparing-the-reverse-string)."
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "The OJ does not consider a corner case that the input is \"00\""
                    },
                    {
                        "username": "joeantol",
                        "content": "How is \"1\" or \"11\" strobo, but \"10\" or \"18\" are not?"
                    }
                ]
            },
            {
                "id": 1687752,
                "content": [
                    {
                        "username": "jessieqiu126",
                        "content": "I think \\'2\\' and \\'5\\' can also be looked as \"Strobogrammatic Number\"\\n\\'1\\' and \\'8\\' are not even exactly Strobogrammatic if you want it to look perfectly rotationally symmetric .\\nWikipedia thinks \\'2\\' is Strobogrammatic.\\nIt really depends on how you define it. This is not a hard question, just please clarify it in the description."
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I was confused too. I also forgot that 0 is also a valid number. Though, I think it\\'s good to not have everything in the problem description because it\\'ll make us better at thinking edge cases ourself because for 2 and 5 I ran a test case and it return false. Kind of like asking the interviewer."
                    },
                    {
                        "username": "Noah492",
                        "content": "For those annoyed with the lack of clarity, the strobogrammatic numbers are 0, 1, and 8 on their own. The pair of 6 and 9 are counted."
                    },
                    {
                        "username": "JimHuddle",
                        "content": "I\\'m using a digital clock, and when I turn 629 upside down, it\\'s the same.\\nBoth 2 and 5 are strobogrammatic with themselves\\n555 = 555\\n2605092 = 2605092\\n\\nAssume we are \"rotating\" on the z-axis\\nAnd digital numbers are close enough\\n\\nI did a test of 629 and got \"expected false\""
                    },
                    {
                        "username": "zme",
                        "content": "This question is example that on interview better ask details before realisation. Or perform test for cases with 2, 5 and 1 before submit."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_strobogrammatic(num)\\n      num == num.tr(\"6923457\", \"96\").reverse\\n    end\\n\\nBased on [AsianHippo's solution](https://leetcode.com/discuss/85661/java-solution-by-comparing-the-reverse-string)."
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "The OJ does not consider a corner case that the input is \"00\""
                    },
                    {
                        "username": "joeantol",
                        "content": "How is \"1\" or \"11\" strobo, but \"10\" or \"18\" are not?"
                    }
                ]
            },
            {
                "id": 1567588,
                "content": [
                    {
                        "username": "jessieqiu126",
                        "content": "I think \\'2\\' and \\'5\\' can also be looked as \"Strobogrammatic Number\"\\n\\'1\\' and \\'8\\' are not even exactly Strobogrammatic if you want it to look perfectly rotationally symmetric .\\nWikipedia thinks \\'2\\' is Strobogrammatic.\\nIt really depends on how you define it. This is not a hard question, just please clarify it in the description."
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I was confused too. I also forgot that 0 is also a valid number. Though, I think it\\'s good to not have everything in the problem description because it\\'ll make us better at thinking edge cases ourself because for 2 and 5 I ran a test case and it return false. Kind of like asking the interviewer."
                    },
                    {
                        "username": "Noah492",
                        "content": "For those annoyed with the lack of clarity, the strobogrammatic numbers are 0, 1, and 8 on their own. The pair of 6 and 9 are counted."
                    },
                    {
                        "username": "JimHuddle",
                        "content": "I\\'m using a digital clock, and when I turn 629 upside down, it\\'s the same.\\nBoth 2 and 5 are strobogrammatic with themselves\\n555 = 555\\n2605092 = 2605092\\n\\nAssume we are \"rotating\" on the z-axis\\nAnd digital numbers are close enough\\n\\nI did a test of 629 and got \"expected false\""
                    },
                    {
                        "username": "zme",
                        "content": "This question is example that on interview better ask details before realisation. Or perform test for cases with 2, 5 and 1 before submit."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_strobogrammatic(num)\\n      num == num.tr(\"6923457\", \"96\").reverse\\n    end\\n\\nBased on [AsianHippo's solution](https://leetcode.com/discuss/85661/java-solution-by-comparing-the-reverse-string)."
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "The OJ does not consider a corner case that the input is \"00\""
                    },
                    {
                        "username": "joeantol",
                        "content": "How is \"1\" or \"11\" strobo, but \"10\" or \"18\" are not?"
                    }
                ]
            },
            {
                "id": 1696414,
                "content": [
                    {
                        "username": "jessieqiu126",
                        "content": "I think \\'2\\' and \\'5\\' can also be looked as \"Strobogrammatic Number\"\\n\\'1\\' and \\'8\\' are not even exactly Strobogrammatic if you want it to look perfectly rotationally symmetric .\\nWikipedia thinks \\'2\\' is Strobogrammatic.\\nIt really depends on how you define it. This is not a hard question, just please clarify it in the description."
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I was confused too. I also forgot that 0 is also a valid number. Though, I think it\\'s good to not have everything in the problem description because it\\'ll make us better at thinking edge cases ourself because for 2 and 5 I ran a test case and it return false. Kind of like asking the interviewer."
                    },
                    {
                        "username": "Noah492",
                        "content": "For those annoyed with the lack of clarity, the strobogrammatic numbers are 0, 1, and 8 on their own. The pair of 6 and 9 are counted."
                    },
                    {
                        "username": "JimHuddle",
                        "content": "I\\'m using a digital clock, and when I turn 629 upside down, it\\'s the same.\\nBoth 2 and 5 are strobogrammatic with themselves\\n555 = 555\\n2605092 = 2605092\\n\\nAssume we are \"rotating\" on the z-axis\\nAnd digital numbers are close enough\\n\\nI did a test of 629 and got \"expected false\""
                    },
                    {
                        "username": "zme",
                        "content": "This question is example that on interview better ask details before realisation. Or perform test for cases with 2, 5 and 1 before submit."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_strobogrammatic(num)\\n      num == num.tr(\"6923457\", \"96\").reverse\\n    end\\n\\nBased on [AsianHippo's solution](https://leetcode.com/discuss/85661/java-solution-by-comparing-the-reverse-string)."
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "The OJ does not consider a corner case that the input is \"00\""
                    },
                    {
                        "username": "joeantol",
                        "content": "How is \"1\" or \"11\" strobo, but \"10\" or \"18\" are not?"
                    }
                ]
            },
            {
                "id": 1567931,
                "content": [
                    {
                        "username": "jessieqiu126",
                        "content": "I think \\'2\\' and \\'5\\' can also be looked as \"Strobogrammatic Number\"\\n\\'1\\' and \\'8\\' are not even exactly Strobogrammatic if you want it to look perfectly rotationally symmetric .\\nWikipedia thinks \\'2\\' is Strobogrammatic.\\nIt really depends on how you define it. This is not a hard question, just please clarify it in the description."
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I was confused too. I also forgot that 0 is also a valid number. Though, I think it\\'s good to not have everything in the problem description because it\\'ll make us better at thinking edge cases ourself because for 2 and 5 I ran a test case and it return false. Kind of like asking the interviewer."
                    },
                    {
                        "username": "Noah492",
                        "content": "For those annoyed with the lack of clarity, the strobogrammatic numbers are 0, 1, and 8 on their own. The pair of 6 and 9 are counted."
                    },
                    {
                        "username": "JimHuddle",
                        "content": "I\\'m using a digital clock, and when I turn 629 upside down, it\\'s the same.\\nBoth 2 and 5 are strobogrammatic with themselves\\n555 = 555\\n2605092 = 2605092\\n\\nAssume we are \"rotating\" on the z-axis\\nAnd digital numbers are close enough\\n\\nI did a test of 629 and got \"expected false\""
                    },
                    {
                        "username": "zme",
                        "content": "This question is example that on interview better ask details before realisation. Or perform test for cases with 2, 5 and 1 before submit."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_strobogrammatic(num)\\n      num == num.tr(\"6923457\", \"96\").reverse\\n    end\\n\\nBased on [AsianHippo's solution](https://leetcode.com/discuss/85661/java-solution-by-comparing-the-reverse-string)."
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "The OJ does not consider a corner case that the input is \"00\""
                    },
                    {
                        "username": "joeantol",
                        "content": "How is \"1\" or \"11\" strobo, but \"10\" or \"18\" are not?"
                    }
                ]
            },
            {
                "id": 1571488,
                "content": [
                    {
                        "username": "jessieqiu126",
                        "content": "I think \\'2\\' and \\'5\\' can also be looked as \"Strobogrammatic Number\"\\n\\'1\\' and \\'8\\' are not even exactly Strobogrammatic if you want it to look perfectly rotationally symmetric .\\nWikipedia thinks \\'2\\' is Strobogrammatic.\\nIt really depends on how you define it. This is not a hard question, just please clarify it in the description."
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I was confused too. I also forgot that 0 is also a valid number. Though, I think it\\'s good to not have everything in the problem description because it\\'ll make us better at thinking edge cases ourself because for 2 and 5 I ran a test case and it return false. Kind of like asking the interviewer."
                    },
                    {
                        "username": "Noah492",
                        "content": "For those annoyed with the lack of clarity, the strobogrammatic numbers are 0, 1, and 8 on their own. The pair of 6 and 9 are counted."
                    },
                    {
                        "username": "JimHuddle",
                        "content": "I\\'m using a digital clock, and when I turn 629 upside down, it\\'s the same.\\nBoth 2 and 5 are strobogrammatic with themselves\\n555 = 555\\n2605092 = 2605092\\n\\nAssume we are \"rotating\" on the z-axis\\nAnd digital numbers are close enough\\n\\nI did a test of 629 and got \"expected false\""
                    },
                    {
                        "username": "zme",
                        "content": "This question is example that on interview better ask details before realisation. Or perform test for cases with 2, 5 and 1 before submit."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_strobogrammatic(num)\\n      num == num.tr(\"6923457\", \"96\").reverse\\n    end\\n\\nBased on [AsianHippo's solution](https://leetcode.com/discuss/85661/java-solution-by-comparing-the-reverse-string)."
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "The OJ does not consider a corner case that the input is \"00\""
                    },
                    {
                        "username": "joeantol",
                        "content": "How is \"1\" or \"11\" strobo, but \"10\" or \"18\" are not?"
                    }
                ]
            },
            {
                "id": 1911281,
                "content": [
                    {
                        "username": "jessieqiu126",
                        "content": "I think \\'2\\' and \\'5\\' can also be looked as \"Strobogrammatic Number\"\\n\\'1\\' and \\'8\\' are not even exactly Strobogrammatic if you want it to look perfectly rotationally symmetric .\\nWikipedia thinks \\'2\\' is Strobogrammatic.\\nIt really depends on how you define it. This is not a hard question, just please clarify it in the description."
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "I was confused too. I also forgot that 0 is also a valid number. Though, I think it\\'s good to not have everything in the problem description because it\\'ll make us better at thinking edge cases ourself because for 2 and 5 I ran a test case and it return false. Kind of like asking the interviewer."
                    },
                    {
                        "username": "Noah492",
                        "content": "For those annoyed with the lack of clarity, the strobogrammatic numbers are 0, 1, and 8 on their own. The pair of 6 and 9 are counted."
                    },
                    {
                        "username": "JimHuddle",
                        "content": "I\\'m using a digital clock, and when I turn 629 upside down, it\\'s the same.\\nBoth 2 and 5 are strobogrammatic with themselves\\n555 = 555\\n2605092 = 2605092\\n\\nAssume we are \"rotating\" on the z-axis\\nAnd digital numbers are close enough\\n\\nI did a test of 629 and got \"expected false\""
                    },
                    {
                        "username": "zme",
                        "content": "This question is example that on interview better ask details before realisation. Or perform test for cases with 2, 5 and 1 before submit."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_strobogrammatic(num)\\n      num == num.tr(\"6923457\", \"96\").reverse\\n    end\\n\\nBased on [AsianHippo's solution](https://leetcode.com/discuss/85661/java-solution-by-comparing-the-reverse-string)."
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "The OJ does not consider a corner case that the input is \"00\""
                    },
                    {
                        "username": "joeantol",
                        "content": "How is \"1\" or \"11\" strobo, but \"10\" or \"18\" are not?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Moving Average from Data Stream",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565182,
                "content": [
                    {
                        "username": "daniel123",
                        "content": "What if the size is too big to hold in memory?"
                    },
                    {
                        "username": "My3Forever",
                        "content": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\\n\\nso here is how to read this question: \\ninit an object, with a function \"next\" which gets a value and return the average of all last \"window size\"# previuse nembers given to \"next\" before.\\nfor example, let 3 be the window size.\\ncalling next(1) will return the ave of 1 which is 1\\ncalling next(3) will return (3+1)/2\\ncalling next(1) will return (1+3+1)/3\\ncalling next(2) will return (2+1+3)/3  ** we dropped the first 1 as we are limited to 3 values of \"window size\""
                    },
                    {
                        "username": "harsh_sahni",
                        "content": "Issue with LeetCode - multiple submissions of same solution is giving different runtimes.\\n\\nI have submitted the same solution 2-3 times. Sometimes it gives 72ms runtime, and sometimes it gives 40ms runtime. Even though I have not touched the code in both cases. :("
                    },
                    {
                        "username": "user1704Xs",
                        "content": "Running to an issue preventing me from getting the right answer. Despite outputting a float, it will truncate my decimal once I return it. Anyone else running into this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "A good example from your side would help a lot...\nAt least which language?\nIn java, you can have :\n```\n int count;\n double sum;\n return sum/count;\n```\nor \n```\n int count;\n lond sum;\n return (double)sum/count;\n```\nfor this particular task."
                    }
                ]
            },
            {
                "id": 1568473,
                "content": [
                    {
                        "username": "daniel123",
                        "content": "What if the size is too big to hold in memory?"
                    },
                    {
                        "username": "My3Forever",
                        "content": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\\n\\nso here is how to read this question: \\ninit an object, with a function \"next\" which gets a value and return the average of all last \"window size\"# previuse nembers given to \"next\" before.\\nfor example, let 3 be the window size.\\ncalling next(1) will return the ave of 1 which is 1\\ncalling next(3) will return (3+1)/2\\ncalling next(1) will return (1+3+1)/3\\ncalling next(2) will return (2+1+3)/3  ** we dropped the first 1 as we are limited to 3 values of \"window size\""
                    },
                    {
                        "username": "harsh_sahni",
                        "content": "Issue with LeetCode - multiple submissions of same solution is giving different runtimes.\\n\\nI have submitted the same solution 2-3 times. Sometimes it gives 72ms runtime, and sometimes it gives 40ms runtime. Even though I have not touched the code in both cases. :("
                    },
                    {
                        "username": "user1704Xs",
                        "content": "Running to an issue preventing me from getting the right answer. Despite outputting a float, it will truncate my decimal once I return it. Anyone else running into this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "A good example from your side would help a lot...\nAt least which language?\nIn java, you can have :\n```\n int count;\n double sum;\n return sum/count;\n```\nor \n```\n int count;\n lond sum;\n return (double)sum/count;\n```\nfor this particular task."
                    }
                ]
            },
            {
                "id": 1723078,
                "content": [
                    {
                        "username": "daniel123",
                        "content": "What if the size is too big to hold in memory?"
                    },
                    {
                        "username": "My3Forever",
                        "content": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\\n\\nso here is how to read this question: \\ninit an object, with a function \"next\" which gets a value and return the average of all last \"window size\"# previuse nembers given to \"next\" before.\\nfor example, let 3 be the window size.\\ncalling next(1) will return the ave of 1 which is 1\\ncalling next(3) will return (3+1)/2\\ncalling next(1) will return (1+3+1)/3\\ncalling next(2) will return (2+1+3)/3  ** we dropped the first 1 as we are limited to 3 values of \"window size\""
                    },
                    {
                        "username": "harsh_sahni",
                        "content": "Issue with LeetCode - multiple submissions of same solution is giving different runtimes.\\n\\nI have submitted the same solution 2-3 times. Sometimes it gives 72ms runtime, and sometimes it gives 40ms runtime. Even though I have not touched the code in both cases. :("
                    },
                    {
                        "username": "user1704Xs",
                        "content": "Running to an issue preventing me from getting the right answer. Despite outputting a float, it will truncate my decimal once I return it. Anyone else running into this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "A good example from your side would help a lot...\nAt least which language?\nIn java, you can have :\n```\n int count;\n double sum;\n return sum/count;\n```\nor \n```\n int count;\n lond sum;\n return (double)sum/count;\n```\nfor this particular task."
                    }
                ]
            },
            {
                "id": 1735359,
                "content": [
                    {
                        "username": "daniel123",
                        "content": "What if the size is too big to hold in memory?"
                    },
                    {
                        "username": "My3Forever",
                        "content": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\\n\\nso here is how to read this question: \\ninit an object, with a function \"next\" which gets a value and return the average of all last \"window size\"# previuse nembers given to \"next\" before.\\nfor example, let 3 be the window size.\\ncalling next(1) will return the ave of 1 which is 1\\ncalling next(3) will return (3+1)/2\\ncalling next(1) will return (1+3+1)/3\\ncalling next(2) will return (2+1+3)/3  ** we dropped the first 1 as we are limited to 3 values of \"window size\""
                    },
                    {
                        "username": "harsh_sahni",
                        "content": "Issue with LeetCode - multiple submissions of same solution is giving different runtimes.\\n\\nI have submitted the same solution 2-3 times. Sometimes it gives 72ms runtime, and sometimes it gives 40ms runtime. Even though I have not touched the code in both cases. :("
                    },
                    {
                        "username": "user1704Xs",
                        "content": "Running to an issue preventing me from getting the right answer. Despite outputting a float, it will truncate my decimal once I return it. Anyone else running into this?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "A good example from your side would help a lot...\nAt least which language?\nIn java, you can have :\n```\n int count;\n double sum;\n return sum/count;\n```\nor \n```\n int count;\n lond sum;\n return (double)sum/count;\n```\nfor this particular task."
                    }
                ]
            }
        ]
    }
]