[
    {
        "title": "Print in Order",
        "question_content": "Suppose we have a class:\n\npublic class Foo {\n  public void first() { print(\"first\"); }\n  public void second() { print(\"second\"); }\n  public void third() { print(\"third\"); }\n}\n\nThe same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().\nNote:\nWe do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests' comprehensiveness.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: \"firstsecondthird\"\nExplanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \"firstsecondthird\" is the correct output.\n\nExample 2:\n\nInput: nums = [1,3,2]\nOutput: \"firstsecondthird\"\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output.\n\n&nbsp;\nConstraints:\n\n\tnums is a permutation of [1, 2, 3].",
        "solutions": [
            {
                "id": 335939,
                "title": "5-python-threading-solutions-barrier-lock-event-semaphore-condition-with-explanation",
                "content": "\\nRaise two barriers. Both wait for two threads to reach them.\\n\\nFirst thread can print before reaching the first barrier. Second thread can print before reaching the second barrier. Third thread can print after the second barrier.\\n\\n```\\nfrom threading import Barrier\\n\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n            \\n    def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n        \\n    def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n            \\n    def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n ```\\n \\nStart with two locked locks. First thread unlocks the first lock that the second thread is waiting on. Second thread unlocks the second lock that the third thread is waiting on.\\n\\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```        \\nSet events from first and second threads when they are done. Have the second thread wait for first one to set its event. Have the third thread wait on the second thread to raise its event.\\n\\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.done = (Event(),Event())\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.done[0].set()\\n        \\n    def second(self, printSecond):\\n        self.done[0].wait()\\n        printSecond()\\n        self.done[1].set()\\n            \\n    def third(self, printThird):\\n        self.done[1].wait()\\n        printThird()\\n\\n```        \\nStart with two closed gates represented by 0-value semaphores. Second and third thread are waiting behind these gates. When the first thread prints, it opens the gate for the second thread. When the second thread prints, it opens the gate for the third thread.\\n\\n```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n            \\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n\\n ```        \\n\\nHave all three threads attempt to acquire an RLock via Condition. The first thread can always acquire a lock, while the other two have to wait for the `order` to be set to the right value. First thread sets the order after printing which signals for the second thread to run. Second thread does the same for the third.\\n\\n```\\nfrom threading import Condition\\n\\nclass Foo:\\n    def __init__(self):\\n        self.exec_condition = Condition()\\n        self.order = 0\\n        self.first_finish = lambda: self.order == 1\\n        self.second_finish = lambda: self.order == 2\\n\\n    def first(self, printFirst):\\n        with self.exec_condition:\\n            printFirst()\\n            self.order = 1\\n            self.exec_condition.notify(2)\\n\\n    def second(self, printSecond):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.first_finish)\\n            printSecond()\\n            self.order = 2\\n            self.exec_condition.notify()\\n\\n    def third(self, printThird):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.second_finish)\\n            printThird()\\n```\\n            \\n",
                "solutionTags": [],
                "code": "```\\nfrom threading import Barrier\\n\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n            \\n    def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n        \\n    def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n            \\n    def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n ```\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.done = (Event(),Event())\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.done[0].set()\\n        \\n    def second(self, printSecond):\\n        self.done[0].wait()\\n        printSecond()\\n        self.done[1].set()\\n            \\n    def third(self, printThird):\\n        self.done[1].wait()\\n        printThird()\\n\\n```\n```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n            \\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n\\n ```\n```\\nfrom threading import Condition\\n\\nclass Foo:\\n    def __init__(self):\\n        self.exec_condition = Condition()\\n        self.order = 0\\n        self.first_finish = lambda: self.order == 1\\n        self.second_finish = lambda: self.order == 2\\n\\n    def first(self, printFirst):\\n        with self.exec_condition:\\n            printFirst()\\n            self.order = 1\\n            self.exec_condition.notify(2)\\n\\n    def second(self, printSecond):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.first_finish)\\n            printSecond()\\n            self.order = 2\\n            self.exec_condition.notify()\\n\\n    def third(self, printThird):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.second_finish)\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332890,
                "title": "java-basic-semaphore-solution-8ms-36mb",
                "content": "\"Semaphore is a bowl of marbles\" - Professor Stark\\n\\n1. Semaphore is a bowl of marbles (or locks in this case). If you need a marble, and there are none, you wait. You wait until there is one marble and then you take it. If you release(), you will add one marble to the bowl (from thin air). If you release(100), you will add 100 marbles to the bowl. **run2.release();** will add one **\"run2\"** marble to the **\"run2 bowl\"**.\\n2. The thread calling **third()** will wait until the end of **second()** when it releases a **\\'run3\\'** marble. The **second()** will wait until the end of **first() **when it releases a **\\'run2\\'** marble. Since **first()** never acquires anything, it will never wait. There is a forced wait ordering.\\n3. With semaphores, you can start out with 1 marble or 0 marbles or 100 marbles. A thread can take marbles (up until it\\'s empty) or put many marbles at a time.\\n\\nYou can solve this using other solutions (check bottom), but if you wake up a thread and make it spin in a loop and wait for some condition, it is a waste of CPU. You can make the thread go to sleep and wait for someone to notify it to wake up.\\n\\nUpvote and check out my other concurrency solutions.\\n```\\nimport java.util.concurrent.*;\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        run2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire(); \\n        printThird.run();\\n    }\\n}\\n```\\n\\n---\\n\\nSide note:\\n**ruzveld83** has pointed something out.\\n\"According to JMM there\\'s no guarantee that a thread will see values assigned during construction of an object in another thread. There is no guarantee that some thread can\\'t see version of Foo that is not fully constructed. It\\'s possible to see Foo.run2 or Foo.run3 as nulls. And thread-safety of Semaphore class does not make any difference. The final keyword should fix this. See https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5\"\\n\\nI could argue that *maybe* Foo is being synchronized to allow for proper value visibility. But we can\\'t see the entire program so... \\xAF\\\\\\\\_(\\u30C4)_/\\xAF\\n\\n---\\n\\nHere\\'s another solution that requires 1 semaphore. It is 19ms. There is some \"waking and waiting\" due to the loops, so that causes some CPU waste. I should also note that we need **tryAcquire(number)** because it will try to get \"all or nothing.\" So if you **tryAcquire(3)**, it will try to \"get all 3 if all present and return true\" or \"grab nothing and return false.\" If you use **acquire(3)**, if there isn\\'t enough, it will grab 1 or 2 and then wait for the remainder. You may expect it to \"get 3 or wait for 3\" but it doesn\\'t do this and you may be in for a surprise.\\n```\\nclass Foo {\\n\\n    Semaphore semaphore1;\\n    public Foo() {\\n        semaphore1 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(1));\\n        \\n        printSecond.run();\\n        semaphore1.release(2);\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(2));\\n        \\n        printThird.run();\\n    }\\n}\\n```\\n---\\nFor new learners, you can also solve this using:\\n- **volatile** keyword.\\n- locks\\n- conditions (they are like sub-locks)\\n- atomic variables\\n- java\\'s concurrent data structures\\n\\nUse what works and is simple.",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        run2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire(); \\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n\\n    Semaphore semaphore1;\\n    public Foo() {\\n        semaphore1 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(1));\\n        \\n        printSecond.run();\\n        semaphore1.release(2);\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(2));\\n        \\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343384,
                "title": "c-why-most-of-the-solutions-using-mutex-are-wrong-solution",
                "content": "I actually started learning about threads recently only and even my first attempt was to take 2 mutex and lock/unlock them in order desired by us. That solution is actually accepted in leetcode.\\n\\nHowever, while researching for difference between mutex and conditional_variable usage, i realised that the way mutex are being used here are totally wrong.\\n\\nSome points that must be taken note of are: \\n* **Mutex** are used for **mutual exclusion** i.e to safe gaurd the critical sections of a code.\\n* **Semaphone/condition_variable** are used for **thread synchronisation**(which is what we want to achieve here).\\n* **Mutex have ownership assigned with them**, that is to say, *the thread that locks a mutex must only unlock it.* Also, we must not unlock a mutex that has not been locked **(This is what most programs have got wrong)**.\\n* If the mutex is not used as said above, **the behavior is undefined**, which however in our case produces the required result.\\n\\nReferences:\\n1. [If the mutex is not currently locked by the calling thread, it causes undefined behavior.](http://www.cplusplus.com/reference/mutex/mutex/unlock/)\\n2. [The precondition for calling unlock is holding an ownership of the mutex, according to (std)30.4.1.2](https://stackoverflow.com/questions/43487357/how-stdmutex-got-unlocked-in-different-thread)\\n\\nI did read few more places the same thing, but i think these do put the point across :)\\n\\nNow my solution using a condition_variable:\\n\\n```\\nclass Foo {\\npublic:\\n    int count = 0;\\n    mutex mtx;\\n    condition_variable cv;\\n    Foo() {\\n        count = 1;\\n        //cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        unique_lock<mutex> lck(mtx);\\n\\t\\t// No point of this wait as on start count will be 1, we need to make the other threads wait.\\n        // while(count != 1){\\n        //     cv.wait(lck);\\n        // }\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n\\n        printFirst();\\n        count = 2;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 2){\\n            cv.wait(lck);\\n        }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count = 3;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 3){\\n            cv.wait(lck);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**Disclaimer**:  I am still learning :P. So, please do enlighten me if you think my understanding of this topic is wrong/misleading.\\nThanks for reading :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    int count = 0;\\n    mutex mtx;\\n    condition_variable cv;\\n    Foo() {\\n        count = 1;\\n        //cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        unique_lock<mutex> lck(mtx);\\n\\t\\t// No point of this wait as on start count will be 1, we need to make the other threads wait.\\n        // while(count != 1){\\n        //     cv.wait(lck);\\n        // }\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n\\n        printFirst();\\n        count = 2;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 2){\\n            cv.wait(lck);\\n        }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count = 3;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 3){\\n            cv.wait(lck);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893827,
                "title": "java-synchronized-lock-semaphore-condition-variable",
                "content": "Synchronized Method:\\n```\\nclass Foo {\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        oneDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while (!oneDone) {\\n            wait();\\n        }\\n        printSecond.run();\\n        twoDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while (!twoDone) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```\\n\\nSynchronized on Object:\\n```\\nclass Foo {\\n    private Object lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!oneDone) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!twoDone) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\\nSynchronized on Two Objects (not needed for this question, just put it here in case someone wants to use one object to protect one variable):\\n```\\nclass Foo {\\n    private Object lock1;\\n    private Object lock2;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock1 = new Object();\\n        lock2 = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock1) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock1.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock1) {\\n            synchronized (lock2) {\\n                while (!oneDone) {\\n                    lock1.wait();\\n                }\\n                printSecond.run();\\n                twoDone = true;\\n                lock2.notifyAll();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock2) {\\n            while (!twoDone) {\\n                lock2.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\\nSemaphore:\\n```\\nclass Foo {\\n    private Semaphore s2;\\n    private Semaphore s3;\\n    \\n    public Foo() {\\n        s2 = new Semaphore(0);\\n        s3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        printThird.run();\\n    }\\n}\\n```\\nCondition Variable:\\n```\\nclass Foo {\\n    private Lock lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    private Condition one;\\n    private Condition two;\\n    \\n    public Foo() {\\n        lock = new ReentrantLock();\\n        one = lock.newCondition();\\n        two = lock.newCondition();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            oneDone = true;\\n            one.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!oneDone) {\\n                one.await();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            two.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!twoDone) {\\n                two.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        oneDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while (!oneDone) {\\n            wait();\\n        }\\n        printSecond.run();\\n        twoDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while (!twoDone) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Object lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!oneDone) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!twoDone) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Object lock1;\\n    private Object lock2;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock1 = new Object();\\n        lock2 = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock1) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock1.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock1) {\\n            synchronized (lock2) {\\n                while (!oneDone) {\\n                    lock1.wait();\\n                }\\n                printSecond.run();\\n                twoDone = true;\\n                lock2.notifyAll();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock2) {\\n            while (!twoDone) {\\n                lock2.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Semaphore s2;\\n    private Semaphore s3;\\n    \\n    public Foo() {\\n        s2 = new Semaphore(0);\\n        s3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Lock lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    private Condition one;\\n    private Condition two;\\n    \\n    public Foo() {\\n        lock = new ReentrantLock();\\n        one = lock.newCondition();\\n        two = lock.newCondition();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            oneDone = true;\\n            one.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!oneDone) {\\n                one.await();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            two.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!twoDone) {\\n                two.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333513,
                "title": "c-using-std-promise",
                "content": "```C++\\nclass Foo {\\nprivate:\\n  std::promise<void> p1;\\n  std::promise<void> p2;\\n\\npublic:\\n  void first(function<void()> printFirst) {\\n    printFirst();\\n    p1.set_value();\\n  }\\n\\n  void second(function<void()> printSecond) {\\n    p1.get_future().wait();\\n    printSecond();\\n    p2.set_value();\\n  }\\n\\n  void third(function<void()> printThird) {\\n    p2.get_future().wait();\\n    printThird();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Foo {\\nprivate:\\n  std::promise<void> p1;\\n  std::promise<void> p2;\\n\\npublic:\\n  void first(function<void()> printFirst) {\\n    printFirst();\\n    p1.set_value();\\n  }\\n\\n  void second(function<void()> printSecond) {\\n    p1.get_future().wait();\\n    printSecond();\\n    p2.set_value();\\n  }\\n\\n  void third(function<void()> printThird) {\\n    p2.get_future().wait();\\n    printThird();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333562,
                "title": "python-3-semaphore",
                "content": "```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.two = Semaphore(0)\\n        self.three = Semaphore(0)\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.two.release()\\n\\n    def second(self, printSecond):\\n        with self.two:\\n            printSecond()\\n            self.three.release()\\n\\n    def third(self, printThird):\\n        with self.three:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.two = Semaphore(0)\\n        self.three = Semaphore(0)\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.two.release()\\n\\n    def second(self, printSecond):\\n        with self.two:\\n            printSecond()\\n            self.three.release()\\n\\n    def third(self, printThird):\\n        with self.three:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394392,
                "title": "python-3-56ms-lock-vs-event",
                "content": "The fastest solution for the problem is to use Lock mechanism. See the following code with comments:\\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# create lock to control sequence between first and second functions\\n        self.lock1 = threading.Lock()\\n\\t\\tself.lock1.acquire()\\n\\t\\t\\n\\t\\t# create another lock to control sequence between second and third functions\\n        self.lock2 = threading.Lock()\\n        self.lock2.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t\\n\\t\\t# since second function is waiting for the lock1, let\\'s release it\\n        self.lock1.release()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for first funtion to finish\\n        self.lock1.acquire()\\n        \\n\\t\\tprintSecond()\\n\\t\\t\\n\\t\\t# let\\'s release lock2, so third function can run\\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for second funtion to finish\\n        self.lock2.acquire()\\n\\t\\t\\n        printThird()\\n```\\nNow, when I was solving the problem the result was showing only 76 ms, which is far from the fastest. If you encounter similar issue take into account that you are working with threading and the timing is very unpredictable when CPU decides to switch threads. This can cause different timing results.\\n\\nAs an alternative you can use other synchronization mechanisms, such as Semaphore or Event. If you peek into CPython code you will see both Event and Semaphore are using Lock inside. That means that technically Lock solution is the fastest.\\n\\nBut for the reference here is solution with Event synchronization. In my opinion it looks little better:\\n\\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1 = threading.Event()\\n        self.event2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# create lock to control sequence between first and second functions\\n        self.lock1 = threading.Lock()\\n\\t\\tself.lock1.acquire()\\n\\t\\t\\n\\t\\t# create another lock to control sequence between second and third functions\\n        self.lock2 = threading.Lock()\\n        self.lock2.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t\\n\\t\\t# since second function is waiting for the lock1, let\\'s release it\\n        self.lock1.release()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for first funtion to finish\\n        self.lock1.acquire()\\n        \\n\\t\\tprintSecond()\\n\\t\\t\\n\\t\\t# let\\'s release lock2, so third function can run\\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for second funtion to finish\\n        self.lock2.acquire()\\n\\t\\t\\n        printThird()\\n```\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1 = threading.Event()\\n        self.event2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333446,
                "title": "java-solution-beats-100-in-both-time-and-space",
                "content": "```\\nclass Foo {\\n    \\n    private volatile boolean onePrinted;\\n    private volatile boolean twoPrinted;\\n\\n    public Foo() {\\n        onePrinted = false;\\n        twoPrinted = false;        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        onePrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(!onePrinted) {\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        twoPrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(!twoPrinted) {\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private volatile boolean onePrinted;\\n    private volatile boolean twoPrinted;\\n\\n    public Foo() {\\n        onePrinted = false;\\n        twoPrinted = false;        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        onePrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(!onePrinted) {\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        twoPrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(!twoPrinted) {\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342306,
                "title": "java-simple-countdownlatch-solution",
                "content": "CountDownLatch seems a good fit for this, from java doc \" A synchronization aid that allows one or more threads to wait until, a set of operations being performed in other threads completes. \"\\n\\n```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    \\n    private final CountDownLatch l2;\\n    private final CountDownLatch l3;\\n    \\n    public Foo() {\\n        l2 = new CountDownLatch(1);\\n        l3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        l2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        l2.await();\\n        printSecond.run();\\n        l3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        l3.await();\\n        printThird.run();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    \\n    private final CountDownLatch l2;\\n    private final CountDownLatch l3;\\n    \\n    public Foo() {\\n        l2 = new CountDownLatch(1);\\n        l3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        l2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        l2.await();\\n        printSecond.run();\\n        l3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        l3.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343487,
                "title": "python-simple-working-solution",
                "content": "```python\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        \\n        self.lock1.acquire()\\n        self.lock2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        \\n        self.lock1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lock1.acquire() # Wait unti first finishes\\n        \\n        printSecond()\\n        \\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lock2.acquire() # Wait unti second finishes\\n        \\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        \\n        self.lock1.acquire()\\n        self.lock2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        \\n        self.lock1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lock1.acquire() # Wait unti first finishes\\n        \\n        printSecond()\\n        \\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lock2.acquire() # Wait unti second finishes\\n        \\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332979,
                "title": "c-2-mutex",
                "content": "Idea is grab and release locks in order.\\n```\\nclass Foo {   \\n    mutex m1, m2;\\npublic:\\n    Foo() {\\n        m1.lock(), m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {   \\n    mutex m1, m2;\\npublic:\\n    Foo() {\\n        m1.lock(), m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856697,
                "title": "c-semaphore-based-solution",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly Semaphore first = new Semaphore(1, 1);\\n    private readonly Semaphore second = new Semaphore(0, 1);\\n    private readonly Semaphore third = new Semaphore(0, 1);\\n\\n    public void First(Action printFirst) {\\n        first.WaitOne();\\n        printFirst();\\n        second.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        second.WaitOne();\\n        printSecond();\\n        third.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        third.WaitOne();\\n        printThird();\\n        first.Release();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly Semaphore first = new Semaphore(1, 1);\\n    private readonly Semaphore second = new Semaphore(0, 1);\\n    private readonly Semaphore third = new Semaphore(0, 1);\\n\\n    public void First(Action printFirst) {\\n        first.WaitOne();\\n        printFirst();\\n        second.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        second.WaitOne();\\n        printSecond();\\n        third.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        third.WaitOne();\\n        printThird();\\n        first.Release();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333253,
                "title": "clean-and-easy-java-solution",
                "content": "```\\nimport java.util.concurrent.Semaphore;\\n\\nclass Foo {\\n\\n    final Semaphore hasFirstRun = new Semaphore(0);\\n    final Semaphore hasSecondRun = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        hasFirstRun.release(); // Allows second() to run, and wakes it if it\\'s sleeping.\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        /*\\n            hasFirstRun is initialized to 0. This means that if second() is executed\\n            before first(), it can\\'t get the lock and goes to sleep. In this case, it\\n            will be waked up by first().\\n            \\n            If second() is executed after first(), then it can acquire the semaphore immediately\\n            and execute its code.\\n        */\\n        hasFirstRun.acquire(); \\n        printSecond.run();\\n        hasSecondRun.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        hasSecondRun.acquire(); // same logic as second()\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.concurrent.Semaphore;\\n\\nclass Foo {\\n\\n    final Semaphore hasFirstRun = new Semaphore(0);\\n    final Semaphore hasSecondRun = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        hasFirstRun.release(); // Allows second() to run, and wakes it if it\\'s sleeping.\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        /*\\n            hasFirstRun is initialized to 0. This means that if second() is executed\\n            before first(), it can\\'t get the lock and goes to sleep. In this case, it\\n            will be waked up by first().\\n            \\n            If second() is executed after first(), then it can acquire the semaphore immediately\\n            and execute its code.\\n        */\\n        hasFirstRun.acquire(); \\n        printSecond.run();\\n        hasSecondRun.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        hasSecondRun.acquire(); // same logic as second()\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846704,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-without-using-mutex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\n    promise<void> p1,p2;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        p1.get_future().wait();\\n        printSecond();\\n        p2.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        p2.get_future().wait();\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    promise<void> p1,p2;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        p1.get_future().wait();\\n        printSecond();\\n        p2.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        p2.get_future().wait();\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340233,
                "title": "java-two-methods-cas-ans-synchronized",
                "content": "**1. CAS**\\n```\\nimport java.util.concurrent.atomic.AtomicInteger;\\n\\nclass Foo {\\n\\n\\tAtomicInteger count = new AtomicInteger();\\n\\n\\tpublic Foo() {\\n\\t\\tcount.set(0);\\n\\t}\\n\\n\\tpublic void first(Runnable printFirst) throws InterruptedException {\\n\\n\\t\\twhile (!count.compareAndSet(0, 4)) {\\n\\t\\t\\t// printFirst.run() outputs \"first\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintFirst.run();\\n\\t\\tcount.set(1);\\n\\t}\\n\\n\\tpublic void second(Runnable printSecond) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(1, 4)) {\\n\\t\\t\\t// printSecond.run() outputs \"second\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintSecond.run();\\n\\t\\tcount.set(2);\\n\\n\\t}\\n\\n\\tpublic void third(Runnable printThird) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(2, 4)) {\\n\\t\\t\\t// printThird.run() outputs \"third\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintThird.run();\\n\\t\\tcount.set(3);\\n\\t}\\n}\\n```\\n\\n\\n**2. Synchronized**\\n```\\nimport java.util.concurrent.locks.*;\\n\\nclass Foo {\\n\\n    int count = 0;\\n    \\n    public Foo() {\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        \\n        printFirst.run();\\n        count++;\\n        this.notifyAll();\\n\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(count != 1){\\n           this.wait();\\n        }\\n        printSecond.run();\\n        count++;\\n        this.notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n\\n        while(count != 2){\\n          this.wait();\\n        }\\n        printThird.run();\\n        count++;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.atomic.AtomicInteger;\\n\\nclass Foo {\\n\\n\\tAtomicInteger count = new AtomicInteger();\\n\\n\\tpublic Foo() {\\n\\t\\tcount.set(0);\\n\\t}\\n\\n\\tpublic void first(Runnable printFirst) throws InterruptedException {\\n\\n\\t\\twhile (!count.compareAndSet(0, 4)) {\\n\\t\\t\\t// printFirst.run() outputs \"first\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintFirst.run();\\n\\t\\tcount.set(1);\\n\\t}\\n\\n\\tpublic void second(Runnable printSecond) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(1, 4)) {\\n\\t\\t\\t// printSecond.run() outputs \"second\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintSecond.run();\\n\\t\\tcount.set(2);\\n\\n\\t}\\n\\n\\tpublic void third(Runnable printThird) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(2, 4)) {\\n\\t\\t\\t// printThird.run() outputs \"third\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintThird.run();\\n\\t\\tcount.set(3);\\n\\t}\\n}\\n```\n```\\nimport java.util.concurrent.locks.*;\\n\\nclass Foo {\\n\\n    int count = 0;\\n    \\n    public Foo() {\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        \\n        printFirst.run();\\n        count++;\\n        this.notifyAll();\\n\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(count != 1){\\n           this.wait();\\n        }\\n        printSecond.run();\\n        count++;\\n        this.notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n\\n        while(count != 2){\\n          this.wait();\\n        }\\n        printThird.run();\\n        count++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786578,
                "title": "c-minimal-code",
                "content": "```\\ntypedef struct {\\n    // User defined data is declared here.\\n    // using \\'volatile\\' to prevent compiler from playing god and optimize out this critical variable\\n    // this is mutex variable, duh \\n    volatile int turn;\\n} Foo;\\n\\nvoid wait(Foo* obj, int my_turn) {\\n    // blocking this thread till my turn\\n    while(obj->turn != my_turn) pthread_yield(NULL); // Nope Gotta wait \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n    \\n    // Aha!! free at last guess I will return now\\n}\\n\\nvoid signal(Foo* obj) {\\n    ++obj->turn; // pass it to next in line (psst: for the future generations)\\n}\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    obj->turn = 1; // first will be executed first, lol \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid second(Foo* obj) {\\n    wait(obj, 2); // Ok I will wait till my (2) turn (\\u2565\\uFE4F\\u2565)\\n    printSecond();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid third(Foo* obj) {\\n    wait(obj, 3); // Ok I will wait till my (3) turn (\\u2565\\uFE4F\\u2565)\\n    printThird(); \\n    // Oh! no one else left to signal, I guess this ends with me now, *sigh* \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // I am a resposible citizen I clean up after me \\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    // User defined data is declared here.\\n    // using \\'volatile\\' to prevent compiler from playing god and optimize out this critical variable\\n    // this is mutex variable, duh \\n    volatile int turn;\\n} Foo;\\n\\nvoid wait(Foo* obj, int my_turn) {\\n    // blocking this thread till my turn\\n    while(obj->turn != my_turn) pthread_yield(NULL); // Nope Gotta wait \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n    \\n    // Aha!! free at last guess I will return now\\n}\\n\\nvoid signal(Foo* obj) {\\n    ++obj->turn; // pass it to next in line (psst: for the future generations)\\n}\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    obj->turn = 1; // first will be executed first, lol \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid second(Foo* obj) {\\n    wait(obj, 2); // Ok I will wait till my (2) turn (\\u2565\\uFE4F\\u2565)\\n    printSecond();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid third(Foo* obj) {\\n    wait(obj, 3); // Ok I will wait till my (3) turn (\\u2565\\uFE4F\\u2565)\\n    printThird(); \\n    // Oh! no one else left to signal, I guess this ends with me now, *sigh* \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // I am a resposible citizen I clean up after me \\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1028030,
                "title": "4-python-solutions",
                "content": "**Solution 1:**\\n```\\nfrom threading import Event\\nclass Foo:\\ndef __init__(self):\\n\\tself.done = (Event(),Event())\\n\\ndef first(self, printFirst):\\n\\tprintFirst()\\n\\tself.done[0].set()\\n\\ndef second(self, printSecond):\\n\\tself.done[0].wait()\\n\\tprintSecond()\\n\\tself.done[1].set()\\n\\ndef third(self, printThird):\\n\\tself.done[1].wait()\\n\\tprintThird()\\n```\\n\\n**Solution 2:**\\n```\\nfrom threading import Barrier\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n     def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n     def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n     def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n```\\n\\n**Solution 3:**\\n```\\nfrom threading import Lock\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n     def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n     def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\\n\\n**Solution 4:**\\n```\\nfrom threading import Semaphore\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Event\\nclass Foo:\\ndef __init__(self):\\n\\tself.done = (Event(),Event())\\n\\ndef first(self, printFirst):\\n\\tprintFirst()\\n\\tself.done[0].set()\\n\\ndef second(self, printSecond):\\n\\tself.done[0].wait()\\n\\tprintSecond()\\n\\tself.done[1].set()\\n\\ndef third(self, printThird):\\n\\tself.done[1].wait()\\n\\tprintThird()\\n```\n```\\nfrom threading import Barrier\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n     def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n     def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n     def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n```\n```\\nfrom threading import Lock\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n     def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n     def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\n```\\nfrom threading import Semaphore\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926614,
                "title": "python3-solution-using-5-primitives-lock-semaphore-condition-event-barrier",
                "content": "# Approach \\\\#1. Lock\\n- `RLock` is not suitable in this case. \\n\\n<iframe src=\"https://leetcode.com/playground/mgRcT2DB/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#2. Semaphore\\n- `Semaphore(1)` is equivalent to `Lock()`\\n<iframe src=\"https://leetcode.com/playground/c4bkiTBr/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#3. Condition\\n<iframe src=\"https://leetcode.com/playground/Z2up2An3/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>\\n\\n# Approach \\\\#4. Event \\n<iframe src=\"https://leetcode.com/playground/hTnE2h6z/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#5. Barrier\\n<iframe src=\"https://leetcode.com/playground/RxQpksKT/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n",
                "solutionTags": [
                    "Python3",
                    "Concurrency"
                ],
                "code": "# Approach \\\\#1. Lock\\n- `RLock` is not suitable in this case. \\n\\n<iframe src=\"https://leetcode.com/playground/mgRcT2DB/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#2. Semaphore\\n- `Semaphore(1)` is equivalent to `Lock()`\\n<iframe src=\"https://leetcode.com/playground/c4bkiTBr/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#3. Condition\\n<iframe src=\"https://leetcode.com/playground/Z2up2An3/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>\\n\\n# Approach \\\\#4. Event \\n<iframe src=\"https://leetcode.com/playground/hTnE2h6z/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#5. Barrier\\n<iframe src=\"https://leetcode.com/playground/RxQpksKT/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 339055,
                "title": "c-three-versions-condition-variables-semaphores-simple-bools-fastest-124ms",
                "content": "Version 1: One mutex lock + two condition variables\\n* 124 ms\\n* faster than 89.41%\\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_cond_t cv1 = PTHREAD_COND_INITIALIZER;\\n    pthread_cond_t cv2 = PTHREAD_COND_INITIALIZER;\\n\\t\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        pthread_mutex_lock(&m);\\n        firstRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) { \\n            pthread_cond_wait(&cv1, &m);\\n        }\\n\\t\\t\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        secondRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) {\\n             pthread_cond_wait(&cv1, &m);\\n        }\\n        while (!secondRan) {\\n             pthread_cond_wait(&cv2, &m);\\n        }\\n\\t\\t\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        pthread_mutex_unlock(&m);\\n    }\\n};\\n```\\n\\nVersion 2: Two semaphores\\n* 132 ms\\n* Faster than 82.37%\\n```\\n#include <semaphore.h>\\n\\nclass Foo {\\npublic:\\n    sem_t s1;\\n    sem_t s2;\\n    Foo() {\\n        sem_init(&s1, 0, 0);\\n        sem_init(&s2, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&s1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&s1);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&s2);\\n        \\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&s2);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\nVersion 3: Simple bools\\n* 1400 ms\\n* Faster than 8.13%\\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        firstRan = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!firstRan) { }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondRan = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (!(firstRan && secondRan))  { }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\nLet me know if anyone finds better ways to do what I did!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_cond_t cv1 = PTHREAD_COND_INITIALIZER;\\n    pthread_cond_t cv2 = PTHREAD_COND_INITIALIZER;\\n\\t\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        pthread_mutex_lock(&m);\\n        firstRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) { \\n            pthread_cond_wait(&cv1, &m);\\n        }\\n\\t\\t\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        secondRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) {\\n             pthread_cond_wait(&cv1, &m);\\n        }\\n        while (!secondRan) {\\n             pthread_cond_wait(&cv2, &m);\\n        }\\n\\t\\t\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        pthread_mutex_unlock(&m);\\n    }\\n};\\n```\n```\\n#include <semaphore.h>\\n\\nclass Foo {\\npublic:\\n    sem_t s1;\\n    sem_t s2;\\n    Foo() {\\n        sem_init(&s1, 0, 0);\\n        sem_init(&s2, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&s1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&s1);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&s2);\\n        \\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&s2);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        firstRan = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!firstRan) { }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondRan = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (!(firstRan && secondRan))  { }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 620623,
                "title": "c-using-autoreset",
                "content": "```csharp\\nusing System.Threading;    \\n\\npublic class Foo \\n{\\n    private EventWaitHandle waitFirst;\\n    private EventWaitHandle waitSecond;\\n\\n    public Foo() \\n    {\\n        waitFirst = new AutoResetEvent(initialState: false);\\n        waitSecond = new AutoResetEvent(initialState: false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {   \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        waitFirst.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        waitFirst.WaitOne();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        waitSecond.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        waitSecond.WaitOne();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\nusing System.Threading;    \\n\\npublic class Foo \\n{\\n    private EventWaitHandle waitFirst;\\n    private EventWaitHandle waitSecond;\\n\\n    public Foo() \\n    {\\n        waitFirst = new AutoResetEvent(initialState: false);\\n        waitSecond = new AutoResetEvent(initialState: false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {   \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        waitFirst.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        waitFirst.WaitOne();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        waitSecond.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        waitSecond.WaitOne();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062271,
                "title": "3-c-solutions-promises-condition-variables-atomic-bools",
                "content": "If you liked it please upvote!\\n\\n**C++ promise/future:**\\n1 of the 2 fastest (second one is the condition_variable)\\n```\\nclass Foo {\\nprivate:\\n    std::promise<void> prom_first;\\n    std::promise<void> prom_second;\\n    std::future<void> fut_first;\\n    std::future<void> fut_second;\\npublic:\\n    Foo() {\\n        fut_first = prom_first.get_future();\\n        fut_second = prom_second.get_future();\\n    }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        prom_first.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        fut_first.wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        prom_second.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        fut_second.wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**C++ condition variable**\\n1 of the 2 fastest (second one is the promises/futures)\\n```\\nclass Foo {\\nprivate:\\n    std::mutex mutex1, mutex2, mutex3;\\n    std::condition_variable cv2, cv3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        {\\n            std::lock_guard lock(mutex1);\\n            second_unlocked = true;\\n        }\\n        cv2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock lock(mutex2);\\n        cv2.wait(lock, [this] { return second_unlocked; });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n        lock.unlock();\\n        cv3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock lock(mutex3);\\n        cv3.wait(lock, [this] { return third_unlocked; });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**C++ atomic bools**\\nSimplest but obviously the slowest solution\\n```\\nclass Foo {\\nprivate:\\n    std::atomic<bool> second_unlocked = false, third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        second_unlocked = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!second_unlocked)\\n            ;\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        while(!third_unlocked)\\n            ;\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\nprivate:\\n    std::promise<void> prom_first;\\n    std::promise<void> prom_second;\\n    std::future<void> fut_first;\\n    std::future<void> fut_second;\\npublic:\\n    Foo() {\\n        fut_first = prom_first.get_future();\\n        fut_second = prom_second.get_future();\\n    }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        prom_first.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        fut_first.wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        prom_second.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        fut_second.wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\nprivate:\\n    std::mutex mutex1, mutex2, mutex3;\\n    std::condition_variable cv2, cv3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        {\\n            std::lock_guard lock(mutex1);\\n            second_unlocked = true;\\n        }\\n        cv2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock lock(mutex2);\\n        cv2.wait(lock, [this] { return second_unlocked; });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n        lock.unlock();\\n        cv3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock lock(mutex3);\\n        cv3.wait(lock, [this] { return third_unlocked; });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\nprivate:\\n    std::atomic<bool> second_unlocked = false, third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        second_unlocked = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!second_unlocked)\\n            ;\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        while(!third_unlocked)\\n            ;\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425597,
                "title": "c-the-most-correct-solution",
                "content": "``` csharp\\nusing System.Threading.Tasks;\\n\\npublic class Foo\\n{\\n    private TaskCompletionSource<bool> semaphore1 = new TaskCompletionSource<bool>();\\n    private TaskCompletionSource<bool> semaphore2 = new TaskCompletionSource<bool>();\\n\\n    public Foo()\\n    {\\n\\n    }\\n\\n    public void First(Action printFirst)\\n    {\\n        printFirst();\\n        semaphore1.SetResult(true);\\n    }\\n\\n    public void Second(Action printSecond)\\n    {\\n        semaphore1.Task.Wait();\\n        printSecond();\\n        semaphore2.SetResult(true);\\n    }\\n\\n    public void Third(Action printThird)\\n    {\\n        semaphore2.Task.Wait();\\n        printThird();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "``` csharp\\nusing System.Threading.Tasks;\\n\\npublic class Foo\\n{\\n    private TaskCompletionSource<bool> semaphore1 = new TaskCompletionSource<bool>();\\n    private TaskCompletionSource<bool> semaphore2 = new TaskCompletionSource<bool>();\\n\\n    public Foo()\\n    {\\n\\n    }\\n\\n    public void First(Action printFirst)\\n    {\\n        printFirst();\\n        semaphore1.SetResult(true);\\n    }\\n\\n    public void Second(Action printSecond)\\n    {\\n        semaphore1.Task.Wait();\\n        printSecond();\\n        semaphore2.SetResult(true);\\n    }\\n\\n    public void Third(Action printThird)\\n    {\\n        semaphore2.Task.Wait();\\n        printThird();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878544,
                "title": "python-simple-and-elegant-event-based",
                "content": "**Solution**:\\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1, self.event2 = Event(), Event()\\n\\n    def first(self, f):\\n        f()\\n        self.event1.set()\\n\\n    def second(self, f):\\n        self.event1.wait()\\n        f()\\n        self.event2.set()\\n\\n    def third(self, f):\\n        self.event2.wait()\\n        f()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1, self.event2 = Event(), Event()\\n\\n    def first(self, f):\\n        f()\\n        self.event1.set()\\n\\n    def second(self, f):\\n        self.event1.wait()\\n        f()\\n        self.event2.set()\\n\\n    def third(self, f):\\n        self.event2.wait()\\n        f()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212596,
                "title": "java-with-two-semaphores",
                "content": "```\\nclass Foo {\\n\\n    private Semaphore second;\\n    private Semaphore third;\\n\\n    public Foo() {\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private Semaphore second;\\n    private Semaphore third;\\n\\n    public Foo() {\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760743,
                "title": "java-4-different-solutions-w-explanation",
                "content": "## 0. Analysis\\nHere we have 3 threads and all we want to achieve is to make sure the 3 threads run in a specific order. To achieve this, we need coordination among the threads, which means accessing and managing some common objects/resources. I think the most important point to achieve is about **visibility**: the other threads should be able to know the state change of some commonly accessed objects/values used for the coordination.\\n\\nTo achieve this, we can either use some ready-to-use utility classes in `java.util.concurrent` package, or managing the visibility and status with some Java language features. \\n\\nBelow are a few possible solutions:\\n\\n## 1.  The volatile keyword\\nIn summary, the Java `volatile` keyword **guarantees visibility of changes** to variables across threads (from [this article](http://tutorials.jenkov.com/java-concurrency/volatile.html)), and that\\'s literally all we need here so that when` first()` and `second()` increment the `flag` value, the next methods (in other threads) are able to capture the updated value so that the execution condition can be met (i.e., the `while` loop will exit).\\n\\nSo we have the solution like below:\\n```\\nclass Foo {\\n    private static volatile int flag;\\n    \\n    public Foo() {\\n        flag = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag++; // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag != 2){} // wait until the flag turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag++; // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag != 3){} // wait until the flag turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 2. AtomicInteger\\nThe `AtomicXXX` classes are located in `java.util.concurrent` package. The main feature for those classes is that they ensure ***atomic actions*** on the instances, which in simple terms means that only a single thread will be able to access the object at a time, and the updated value will be visible to other threads. It\\'s achieved using CAS (compare and swap) strategy.\\n\\nSo the solution is like below:\\n```\\nclass Foo {\\n    private static AtomicInteger flag;\\n    \\n    public Foo() {\\n        flag = new AtomicInteger(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag.incrementAndGet(); // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag.get() != 2){} // wait until the flag value turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag.incrementAndGet();  // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag.get() != 3){} // wait until the flag value turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 3. Semaphore\\nA `Semaphore` manages a set of  virtual  permits; the  initial number of permits  is passed to the Semaphore constructor. Activities can `acquire` permits (as long as some remain) and `release` permits when they are done with them. If no permit is available, acquire blocks until one is (or until interrupted or the operation times out). The `release` method returns a permit to the semaphore. (from the book [Java Concurrency in Practice](https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601))\\n\\nSo we use 2 Semaphore objects, one to control when the` second()` method can proceed, the other to control when the `third()` method can proceed. Solution is like below:\\n\\n```\\nclass Foo {\\n    private static Semaphore sem2;\\n    private static Semaphore sem3;\\n    \\n    public Foo() {\\n        sem2 = new Semaphore(0);\\n        sem3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        sem2.release(); // release a sem2 permit so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        sem2.acquire();  // will block until any Semaphore permit is available\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        sem3.release(); // release a sem3 permit so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       sem3.acquire(); // will block until any Semaphore permit is available\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 4. CountDownLatch\\n`CountDownLatch` is another type of synchronizer. It can delay the progress of threads until it reaches its terminal state, i.e., when it counts down to 0. \\n\\nMuch like solution 3 with `Semaphore`, we use 2 `CountDownLatch` instances. One to control when the` second()` method can proceed, the other to control when the `third()` method can proceed. Solution is like below:\\n\\n```\\nclass Foo {\\n    private static CountDownLatch latch2;\\n    private static CountDownLatch latch3;\\n    \\n    public Foo() {\\n        latch2 = new CountDownLatch(1);\\n        latch3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown(); // count down latch2 to 0 so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await(); // wait until latch2 counts down to 0\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown(); // count down latche to 0 so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       latch3.await(); // wait until latch3 counts down to 0\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private static volatile int flag;\\n    \\n    public Foo() {\\n        flag = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag++; // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag != 2){} // wait until the flag turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag++; // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag != 3){} // wait until the flag turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static AtomicInteger flag;\\n    \\n    public Foo() {\\n        flag = new AtomicInteger(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag.incrementAndGet(); // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag.get() != 2){} // wait until the flag value turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag.incrementAndGet();  // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag.get() != 3){} // wait until the flag value turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static Semaphore sem2;\\n    private static Semaphore sem3;\\n    \\n    public Foo() {\\n        sem2 = new Semaphore(0);\\n        sem3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        sem2.release(); // release a sem2 permit so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        sem2.acquire();  // will block until any Semaphore permit is available\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        sem3.release(); // release a sem3 permit so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       sem3.acquire(); // will block until any Semaphore permit is available\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static CountDownLatch latch2;\\n    private static CountDownLatch latch3;\\n    \\n    public Foo() {\\n        latch2 = new CountDownLatch(1);\\n        latch3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown(); // count down latch2 to 0 so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await(); // wait until latch2 counts down to 0\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown(); // count down latche to 0 so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       latch3.await(); // wait until latch3 counts down to 0\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520552,
                "title": "c-future-promise",
                "content": "Using C++ 11 feature and locking the object automatically with future-promise idiom. \\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n    std::promise<void> one, two;\\n    \\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        one.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        one.get_future().get();\\n        printSecond();\\n        two.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        two.get_future().get();\\n        printThird();\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n    std::promise<void> one, two;\\n    \\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        one.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        one.get_future().get();\\n        printSecond();\\n        two.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        two.get_future().get();\\n        printThird();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430388,
                "title": "c-condition-variable-96-also-explaining-how-condition-variable-works",
                "content": "How `condition_variable` works:\\n1. First, you need to acquire a `mutex` using `unique_lock`. We need a unique_lock because before putting the thread to sleep, condition_variable will need to release the mutex and unique_lock provides that flexibility.\\n2. Next, you call the `wait` function of condition_variable with the above lock and optionally a `predicate`. It causes the current thread to block (sleep). The thread is unblocked when `notify_all` or `notify_one` is executed on some other thread. \\n4. It might also be unblocked *spuriously* that\\'s where the predicate comes handy. So, whenever there are spurious wake-ups, condition_variable will acquire the mutex and check the predicate. **If** the predicate returns true, thread will proceed further and mutex will stay acquired, **otherwise** it will release the mutex and sleep again.\\n5. When the thread has completed its work, it\\'s *generally* a better idea to release the lock before notifying other threads, if need be.\\n\\n```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst) {\\n        // first doesn\\'t have to wait for anyone and it doesn\\'t acquire any lock either\\n        printFirst();  \\n        // firstPrinted is atomic because second might be trying to read while this thread is modifying it.\\n        firstPrinted = true;\\n        // notify waiting threads\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // acquire lock, C++17 way\\n        unique_lock guard(m);\\n        // condition to wait for is => first should have printed.\\n        cv.wait(guard, [this] { return this->firstPrinted == true; });\\n        // now print\\n        printSecond();\\n        // secondPrinted need not be atomic, because its access is already protected by mutex in both second and third. \\n        secondPrinted = true;\\n        // release mutex before notifying\\n        guard.unlock();\\n        // notify\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // acquire lock\\n        unique_lock guard(m);\\n        // condition to wait for is => second should have printed. \\n        cv.wait(guard, [this] { return secondPrinted == true; });\\n        // now print\\n        printThird();\\n    }\\n    \\nprivate:\\n    condition_variable cv;\\n    mutex m;\\n    atomic_bool firstPrinted = false;\\n    bool secondPrinted = false;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst) {\\n        // first doesn\\'t have to wait for anyone and it doesn\\'t acquire any lock either\\n        printFirst();  \\n        // firstPrinted is atomic because second might be trying to read while this thread is modifying it.\\n        firstPrinted = true;\\n        // notify waiting threads\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // acquire lock, C++17 way\\n        unique_lock guard(m);\\n        // condition to wait for is => first should have printed.\\n        cv.wait(guard, [this] { return this->firstPrinted == true; });\\n        // now print\\n        printSecond();\\n        // secondPrinted need not be atomic, because its access is already protected by mutex in both second and third. \\n        secondPrinted = true;\\n        // release mutex before notifying\\n        guard.unlock();\\n        // notify\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // acquire lock\\n        unique_lock guard(m);\\n        // condition to wait for is => second should have printed. \\n        cv.wait(guard, [this] { return secondPrinted == true; });\\n        // now print\\n        printThird();\\n    }\\n    \\nprivate:\\n    condition_variable cv;\\n    mutex m;\\n    atomic_bool firstPrinted = false;\\n    bool secondPrinted = false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333018,
                "title": "naive-solution-without-using-built-in-libraries",
                "content": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.called = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        while self.called != 0:\\n            continue\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.called = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.called != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.called = 2\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.called != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```\\n\\nNot sure if it meets the goal of this problem, but it passed..",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.called = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        while self.called != 0:\\n            continue\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.called = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.called != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.called = 2\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.called != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961766,
                "title": "java-94-runtime-efficiency-using-synchronized-wait-and-notify-explained",
                "content": "Although I consider myself proficient in Java, this was a great refresher on synchronized, wait, and notify.  I did some research.  Based on Sonar, any wait() call should check a condition in a while loop, so I have two booleans to indicate if the first and second have been printed.  I declared two objects, firstObject and secondObject to use for synchronization.  Method first synchronizes on firstObject and can then run printFirst(), and does a notify on firstObject to signal completion of the first method.  Method second is synchronized on firstObject, has a while loop on !first, and waits for the notify on firstObject.  When the while loop is exited, it synchronizes on secondObject, prints second, sets second to true, and does a notify on secondObject to signal completion of the second method.  Method third does the same things, synchronizing on secondObject, looping while !second, and waits for the notify on secondObject.  When the loop is exited, printThird can be run. \\n\\nIf you like this post, please upvote!\\n```\\nclass Foo {\\n\\n    public Foo() {\\n        first = false;\\n        second = false;\\n    }\\n\\n    Object firstObject = new Object();\\n    Object secondObject = new Object();\\n    \\n    boolean first = false;\\n    boolean second = false;\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(firstObject) {\\n\\t\\t    // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            first = true;\\n            firstObject.notify();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(firstObject) {\\n            while (!first) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    firstObject.wait();\\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n            synchronized(secondObject) {\\n                // printSecond.run() outputs \"second\". Do not change or remove this line.\\n                printSecond.run();\\n                second = true;\\n                secondObject.notify();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(secondObject) {\\n            while (!second) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    secondObject.wait();  \\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line\\n        printThird.run();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Although I consider myself proficient in Java, this was a great refresher on synchronized, wait, and notify.  I did some research.  Based on Sonar, any wait() call should check a condition in a while loop, so I have two booleans to indicate if the first and second have been printed.  I declared two objects, firstObject and secondObject to use for synchronization.  Method first synchronizes on firstObject and can then run printFirst(), and does a notify on firstObject to signal completion of the first method.  Method second is synchronized on firstObject, has a while loop on !first, and waits for the notify on firstObject.  When the while loop is exited, it synchronizes on secondObject, prints second, sets second to true, and does a notify on secondObject to signal completion of the second method.  Method third does the same things, synchronizing on secondObject, looping while !second, and waits for the notify on secondObject.  When the loop is exited, printThird can be run. \\n\\nIf you like this post, please upvote!\\n```\\nclass Foo {\\n\\n    public Foo() {\\n        first = false;\\n        second = false;\\n    }\\n\\n    Object firstObject = new Object();\\n    Object secondObject = new Object();\\n    \\n    boolean first = false;\\n    boolean second = false;\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(firstObject) {\\n\\t\\t    // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            first = true;\\n            firstObject.notify();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(firstObject) {\\n            while (!first) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    firstObject.wait();\\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n            synchronized(secondObject) {\\n                // printSecond.run() outputs \"second\". Do not change or remove this line.\\n                printSecond.run();\\n                second = true;\\n                secondObject.notify();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(secondObject) {\\n            while (!second) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    secondObject.wait();  \\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line\\n        printThird.run();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 762759,
                "title": "boring-c-mutex-solution",
                "content": "```\\nclass Foo {\\n    mutex m1;\\n    mutex m2;\\npublic:\\n    Foo() {\\n        m1.lock();\\n        m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    mutex m1;\\n    mutex m2;\\npublic:\\n    Foo() {\\n        m1.lock();\\n        m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516472,
                "title": "semaphore",
                "content": "```\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        run2.release();\\n\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        run2.release();\\n\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440979,
                "title": "python3-solution-via-threading-event-36-ms-13-mb",
                "content": "```\\nfrom threading import Event\\n\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# Initialize events for threads\\n        self.event1 = Event()\\n        self.event2 = Event()\\n        \\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t# set flag\\n        self.event1.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event1.wait()\\n        printSecond()\\n\\t\\t# set flag\\n        self.event2.set()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event2.wait()\\n        printThird()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom threading import Event\\n\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# Initialize events for threads\\n        self.event1 = Event()\\n        self.event2 = Event()\\n        \\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t# set flag\\n        self.event1.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event1.wait()\\n        printSecond()\\n\\t\\t# set flag\\n        self.event2.set()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428095,
                "title": "c-autoresetevent-beats-100",
                "content": "```\\n    public class Foo\\n    {\\n        private static AutoResetEvent event_1 = new AutoResetEvent(false);\\n        private static AutoResetEvent event_2 = new AutoResetEvent(false);\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            event_1.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            event_1.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            event_2.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            event_2.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Foo\\n    {\\n        private static AutoResetEvent event_1 = new AutoResetEvent(false);\\n        private static AutoResetEvent event_2 = new AutoResetEvent(false);\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            event_1.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            event_1.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            event_2.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            event_2.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347706,
                "title": "c-2-solutions-with-or-without-thread",
                "content": "#1 with thead\\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) System.Threading.Thread.Sleep(1);\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) System.Threading.Thread.Sleep(1);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```\\n\\n#2 without thread\\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) continue;\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) continue;\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) System.Threading.Thread.Sleep(1);\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) System.Threading.Thread.Sleep(1);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) continue;\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) continue;\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693063,
                "title": "easy-java-solution",
                "content": "```\\nclass Foo {\\n\\n        private final CountDownLatch firstLatch;\\n        private final CountDownLatch secondLatch;\\n\\n        public Foo() {\\n            firstLatch = new CountDownLatch(1);\\n            secondLatch = new CountDownLatch(1);\\n        }\\n\\n        public void first(Runnable printFirst) throws InterruptedException {\\n            printFirst.run();\\n            firstLatch.countDown();\\n        }\\n\\n        public void second(Runnable printSecond) throws InterruptedException {\\n            firstLatch.await();\\n            printSecond.run();\\n            secondLatch.countDown();\\n        }\\n\\n        public void third(Runnable printThird) throws InterruptedException {\\n            secondLatch.await();\\n            printThird.run();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n        private final CountDownLatch firstLatch;\\n        private final CountDownLatch secondLatch;\\n\\n        public Foo() {\\n            firstLatch = new CountDownLatch(1);\\n            secondLatch = new CountDownLatch(1);\\n        }\\n\\n        public void first(Runnable printFirst) throws InterruptedException {\\n            printFirst.run();\\n            firstLatch.countDown();\\n        }\\n\\n        public void second(Runnable printSecond) throws InterruptedException {\\n            firstLatch.await();\\n            printSecond.run();\\n            secondLatch.countDown();\\n        }\\n\\n        public void third(Runnable printThird) throws InterruptedException {\\n            secondLatch.await();\\n            printThird.run();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825386,
                "title": "c-shortest-code-using-promise-class",
                "content": "```\\nclass Foo {\\n    \\nprivate:    \\n    promise<void> p1, p2;    \\n    \\npublic:\\n    Foo() {}\\n    void first(function<void()> printFirst)         {\\n        printFirst()                                ;\\n        p1.set_value()                              ;\\n                                                    }\\n    void second(function<void()> printSecond)       {\\n        p1.get_future().wait()                      ;\\n        printSecond()                               ;\\n        p2.set_value()                              ;}\\n\\n    void third(function<void()> printThird)         {\\n        p2.get_future().wait()                      ;\\n        printThird()                                ;}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    \\nprivate:    \\n    promise<void> p1, p2;    \\n    \\npublic:\\n    Foo() {}\\n    void first(function<void()> printFirst)         {\\n        printFirst()                                ;\\n        p1.set_value()                              ;\\n                                                    }\\n    void second(function<void()> printSecond)       {\\n        p1.get_future().wait()                      ;\\n        printSecond()                               ;\\n        p2.set_value()                              ;}\\n\\n    void third(function<void()> printThird)         {\\n        p2.get_future().wait()                      ;\\n        printThird()                                ;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140864,
                "title": "simple-python-solution",
                "content": "```\\nclass Foo(object):\\n    def __init__(self):\\n        self.x = 0\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.x += 1\\n\\n    def second(self, printSecond):\\n        while self.x < 1:\\n            pass\\n        printSecond()\\n        self.x += 1\\n            \\n    def third(self, printThird):\\n        while self.x < 2:\\n            pass\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo(object):\\n    def __init__(self):\\n        self.x = 0\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.x += 1\\n\\n    def second(self, printSecond):\\n        while self.x < 1:\\n            pass\\n        printSecond()\\n        self.x += 1\\n            \\n    def third(self, printThird):\\n        while self.x < 2:\\n            pass\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997508,
                "title": "python-using-events",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.first_event = threading.Event()\\n        self.second_event = threading.Event()\\n       \\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.first_event.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.first_event.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.second_event.set()\\n            \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.second_event.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.first_event = threading.Event()\\n        self.second_event = threading.Event()\\n       \\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.first_event.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.first_event.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.second_event.set()\\n            \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.second_event.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751895,
                "title": "java-simple-solution",
                "content": "```\\nclass Foo {\\n    \\n    CountDownLatch latchForSecond = new CountDownLatch(1);\\n    CountDownLatch latchForThird = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchForSecond.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchForSecond.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchForThird.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchForThird.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    CountDownLatch latchForSecond = new CountDownLatch(1);\\n    CountDownLatch latchForThird = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchForSecond.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchForSecond.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchForThird.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchForThird.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541307,
                "title": "c-semaphore-based-simple-and-short",
                "content": "```\\ntypedef struct {\\n    sem_t sem_a;\\n    sem_t sem_b;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = malloc(sizeof (Foo));\\n    sem_init(&obj->sem_a, 0, 0);\\n    sem_init(&obj->sem_b, 0, 0);\\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    sem_post(&obj->sem_a);\\n}\\n\\nvoid second(Foo* obj) {\\n    sem_wait(&obj->sem_a);\\n    printSecond();\\n    sem_post(&obj->sem_b);\\n}\\n\\nvoid third(Foo* obj) {\\n    sem_wait(&obj->sem_b);\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    sem_t sem_a;\\n    sem_t sem_b;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = malloc(sizeof (Foo));\\n    sem_init(&obj->sem_a, 0, 0);\\n    sem_init(&obj->sem_b, 0, 0);\\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    sem_post(&obj->sem_a);\\n}\\n\\nvoid second(Foo* obj) {\\n    sem_wait(&obj->sem_a);\\n    printSecond();\\n    sem_post(&obj->sem_b);\\n}\\n\\nvoid third(Foo* obj) {\\n    sem_wait(&obj->sem_b);\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 402339,
                "title": "accepted-c-using-autoresetevent",
                "content": "```\\nusing System.Threading;    \\n\\npublic class Foo\\n    {\\n        private EventWaitHandle _waitFirst;\\n        private EventWaitHandle _waitSecond;\\n\\n        public Foo()\\n        {\\n            _waitFirst = new AutoResetEvent(false);\\n            _waitSecond = new AutoResetEvent(false);\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            _waitFirst.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            _waitFirst.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            _waitSecond.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            _waitSecond.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;    \\n\\npublic class Foo\\n    {\\n        private EventWaitHandle _waitFirst;\\n        private EventWaitHandle _waitSecond;\\n\\n        public Foo()\\n        {\\n            _waitFirst = new AutoResetEvent(false);\\n            _waitSecond = new AutoResetEvent(false);\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            _waitFirst.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            _waitFirst.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            _waitSecond.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            _waitSecond.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376571,
                "title": "simple-java-solution-using-booleans-for-locking",
                "content": "class Foo {\\n    \\n        private volatile boolean executedFirst,executedSecond;\\n        public Foo() {}\\n    \\n        public void first(Runnable printFirst) throws InterruptedException {\\n            executedFirst = true;\\n            printFirst.run();\\n        }\\n    \\n        public void second(Runnable printSecond) throws InterruptedException {\\n    \\n            while (!executedFirst);\\n            executedSecond = true;\\n            printSecond.run();\\n        }\\n    \\n        public void third(Runnable printThird) throws InterruptedException {\\n            while (!executedSecond);\\n            printThird.run();\\n        }",
                "solutionTags": [],
                "code": "class Foo {\\n    \\n        private volatile boolean executedFirst,executedSecond;\\n        public Foo() {}\\n    \\n        public void first(Runnable printFirst) throws InterruptedException {\\n            executedFirst = true;\\n            printFirst.run();\\n        }\\n    \\n        public void second(Runnable printSecond) throws InterruptedException {\\n    \\n            while (!executedFirst);\\n            executedSecond = true;\\n            printSecond.run();\\n        }\\n    \\n        public void third(Runnable printThird) throws InterruptedException {\\n            while (!executedSecond);\\n            printThird.run();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 370780,
                "title": "java-solution-using-wait-and-notifyall",
                "content": "A lot of solutions on here are using busy waits or sleeps - which are only slightly better. That is essentially a \\'fail\\' w.r.t. this question on threads. Here\\'s the solution I believe an interviewer would be looking for that uses wait() and notifyAll() with a liveness check inside a synchronized block. The locking object instance used in this code is the instance of Foo. I.e. \\'this\\'. Using wait() and notifyAll() means that the processors aren\\'t spinning and unnecessarily burning through compute power! \\n\\nAlso - notice that the thread coordination logic happens inside a synchronized block. Without that, there is no guarantee that the JVM memory model will communicate the state of the variables between threads. Always, put this kind of thread-coordination logic inside synchronized blocks. \\n\\nAlso - the Java seed code for this question is incorrectly using the Runnable interface. You never call run() on a runnable! That is for the JVM to call in a new thread when it is started. \\n\\n```\\nclass Foo {\\n    private boolean firstDone = false;\\n    private boolean secondDone = false;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this) {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            firstDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this) {\\n            while (!firstDone) {\\n                this.wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            this.secondDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this) {\\n            while (!secondDone) {\\n                this.wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private boolean firstDone = false;\\n    private boolean secondDone = false;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this) {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            firstDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this) {\\n            while (!firstDone) {\\n                this.wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            this.secondDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this) {\\n            while (!secondDone) {\\n                this.wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281277,
                "title": "c-use-mutex",
                "content": "# Intuition\\nUse condition variable and count variable and based on the count value , the desigenated thread will be running accordingly \\n\\n\\n```\\nclass Foo {\\npublic:\\n\\n    std::mutex m; \\n    std::condition_variable cv;\\n    int count; \\n \\n    Foo():count{0} {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        std::unique_lock<std::mutex> lock(m);\\n\\n        count++;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 1 ? true : false;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count++;\\n        lock.unlock(); \\n        cv.notify_all();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 2 ? true : false;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n\\n    std::mutex m; \\n    std::condition_variable cv;\\n    int count; \\n \\n    Foo():count{0} {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        std::unique_lock<std::mutex> lock(m);\\n\\n        count++;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 1 ? true : false;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count++;\\n        lock.unlock(); \\n        cv.notify_all();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 2 ? true : false;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988841,
                "title": "using-manual-reset-event-set-wait-methods",
                "content": "# Intuition\\nWe need to synchronize the method execution in multi threaded environment so same can be achived using ManualResetEventslim class.  \\n\\n# Approach\\nWe can have two slim events, one to synchronize the call for first and second method to ensure that first always executed before second method. \\nAnd second slim event is to make sure that second method gets executed before the third method. \\nSo, we can intialize these instance in the constructions with disabled state. Till the time we enable them by calling Set method. The thread will wait on Wait method. \\nAfter priting first, we can set the first slim event. If a thread is waiting at Wait method in second method will get notified about its status change and now will resume its work. Same will happen for second slim event. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing System.Threading;\\n\\npublic class Foo {\\n\\n     public ManualResetEventSlim slimEvent { get; set; }\\n     public ManualResetEventSlim secondslimEvent { get; set; }\\n\\n    public Foo() \\n    {\\n        slimEvent = new ManualResetEventSlim(false);\\n        secondslimEvent = new ManualResetEventSlim(false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        slimEvent.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        slimEvent.Wait();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondslimEvent.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        secondslimEvent.Wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n\\n     public ManualResetEventSlim slimEvent { get; set; }\\n     public ManualResetEventSlim secondslimEvent { get; set; }\\n\\n    public Foo() \\n    {\\n        slimEvent = new ManualResetEventSlim(false);\\n        secondslimEvent = new ManualResetEventSlim(false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        slimEvent.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        slimEvent.Wait();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondslimEvent.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        secondslimEvent.Wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028788,
                "title": "simple-c-solution-with-mutex",
                "content": "```\\nclass Foo {\\npublic:\\n    mutex a, b;\\n    Foo() {\\n        a.lock();\\n        b.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        a.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        a.lock();\\n        printSecond();\\n        b.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        b.lock();\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    mutex a, b;\\n    Foo() {\\n        a.lock();\\n        b.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        a.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        a.lock();\\n        printSecond();\\n        b.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        b.lock();\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987717,
                "title": "java-simplest-solution-using-volatile-variable",
                "content": "Here, `volatile` keyword makes the variable threadsafe and making it visible to all threads works.\\n\\n```Java\\nclass Foo {\\n\\n    volatile int methodCompleted;\\n    \\n    public Foo() {\\n        methodCompleted = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        methodCompleted =  1;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (methodCompleted != 1) ;\\n        printSecond.run();\\n        methodCompleted =  2;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (methodCompleted != 2) ;\\n        printThird.run();\\n        methodCompleted =  3;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Foo {\\n\\n    volatile int methodCompleted;\\n    \\n    public Foo() {\\n        methodCompleted = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        methodCompleted =  1;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (methodCompleted != 1) ;\\n        printSecond.run();\\n        methodCompleted =  2;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (methodCompleted != 2) ;\\n        printThird.run();\\n        methodCompleted =  3;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894371,
                "title": "java-countdownlatch-simple-solution",
                "content": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n\\n    private final CountDownLatch firstLatch = new CountDownLatch(1);\\n    private final CountDownLatch secondLatch = new CountDownLatch(1);\\n\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n\\n    private final CountDownLatch firstLatch = new CountDownLatch(1);\\n    private final CountDownLatch secondLatch = new CountDownLatch(1);\\n\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844607,
                "title": "java-semaphore-solution",
                "content": "```\\nclass Foo {\\n    \\n    private final Semaphore second = new Semaphore(0);\\n    private final Semaphore third = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    private final Semaphore second = new Semaphore(0);\\n    private final Semaphore third = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631053,
                "title": "python-simple-solution-without-any-lib",
                "content": "\\tclass Foo:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.seq = 0\\n\\n\\t\\tdef first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\tprintFirst()\\n\\t\\t\\tself.seq = 1\\n\\n\\t\\tdef second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 1:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintSecond()\\n\\t\\t\\tself.seq = 2\\n\\n\\t\\tdef third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintThird()",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Foo:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.seq = 0\\n\\n\\t\\tdef first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\tprintFirst()\\n\\t\\t\\tself.seq = 1\\n\\n\\t\\tdef second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 1:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintSecond()\\n\\t\\t\\tself.seq = 2\\n\\n\\t\\tdef third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintThird()",
                "codeTag": "Java"
            },
            {
                "id": 907002,
                "title": "py3-runtime-32-ms-faster-than-93-93",
                "content": "Using thread lock and lock `first` and `second` first at the begining, then release `first` when `printFirst` being called, and release `second` when `printSecond` being called. After all `printThird` will be called.\\n\\n```class Foo:\\n    def __init__(self):\\n        self.tl1 = threading.Lock()\\n        self.tl2 = threading.Lock()\\n        self.tl1.acquire()\\n        self.tl2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.tl1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.tl1.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.tl2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.tl2.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        ```\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Foo:\\n    def __init__(self):\\n        self.tl1 = threading.Lock()\\n        self.tl2 = threading.Lock()\\n        self.tl1.acquire()\\n        self.tl2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.tl1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.tl1.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.tl2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.tl2.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 809116,
                "title": "java-solution-with-synchronized-methods",
                "content": "Code with a runtime of 10ms :\\n\\n```\\nclass Foo {\\n    public int count;\\n    \\n    public Foo() {\\n        this.count = 1;\\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        while(count != 1) wait();\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while(this.count != 2) wait();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while(this.count != 3) wait();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    public int count;\\n    \\n    public Foo() {\\n        this.count = 1;\\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        while(count != 1) wait();\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while(this.count != 2) wait();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while(this.count != 3) wait();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777380,
                "title": "python-loop-and-flag",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.f = True\\n        self.s = False\\n        self.t = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.s = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        while 1:\\n          if self.s:\\n            break\\n        printSecond()\\n        self.t = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        while 1:\\n          if self.t:\\n            break\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.f = True\\n        self.s = False\\n        self.t = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.s = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        while 1:\\n          if self.s:\\n            break\\n        printSecond()\\n        self.t = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        while 1:\\n          if self.t:\\n            break\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769363,
                "title": "java-simple-solution-using-volatile-97-faster",
                "content": "```\\nclass Foo {\\n\\n    public volatile int order;\\n    public Foo() {\\n        order= 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        order++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(order!=1);\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        order++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(order!=2);\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    public volatile int order;\\n    public Foo() {\\n        order= 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        order++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(order!=1);\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        order++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(order!=2);\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706604,
                "title": "python-use-2-queue-to-synchronize",
                "content": "```\\nfrom Queue import Queue\\n\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.q1.put(1)\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.q1.get()\\n        printSecond()\\n        self.q2.put(1)\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.q2.get()\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom Queue import Queue\\n\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.q1.put(1)\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.q1.get()\\n        printSecond()\\n        self.q2.put(1)\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.q2.get()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640143,
                "title": "simple-6-lines-java-explained-solution",
                "content": "Intutuion\\n1. Use volatile variable which will update variable \\'a\\' in different caches of multi core system. Note - It is only required if this code runs on multi core environment.\\n2. Run printFirst.run only when a=1;\\n3. Run printSecond.run only when a=2; \\n4. Similarly printThird.run only when a=3l\\n```\\nclass Foo {\\n    volatile int a;\\n    public Foo() {\\n        a=1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        while(a!=1);\\n        printFirst.run();\\n        a=2;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(a!=2);\\n        printSecond.run();\\n        a=3;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        while(a!=3);\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    volatile int a;\\n    public Foo() {\\n        a=1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        while(a!=1);\\n        printFirst.run();\\n        a=2;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(a!=2);\\n        printSecond.run();\\n        a=3;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        while(a!=3);\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485268,
                "title": "c-w-promise-124ms-92-14-9-4mb-100",
                "content": "* Runtime: 124 ms, faster than 92.14% of C++ online submissions for Print in Order.\\n* Memory Usage: 9.4 MB, less than 100.00% of C++ online submissions for Print in Order.\\n\\nThis is a simple task. I did try writing one solution with a condition_variable and one using future/promise.\\nThe performance was fairly close, with promise performing slightly better.\\n\\nIf the task was larger in some dimension, I could walk through the program to show where time is being wasted.  This is as simple as it gets and there ought to be a tight cluster of results, where relative performance is honestly random.\\n\\nMy reason for using promise is that it avoids synchronizing mutex locks between many threads, but there isn\\'t much tradeoff between memory or performance no matter what you choose.\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {}\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    promise<bool> p1;\\n    promise<bool> p2;\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {}\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    promise<bool> p1;\\n    promise<bool> p2;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355038,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nUse `Guarded Block`\\nhttps://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html\\n\\nBasically, adding `synchronized` keyword to all the methods will require any thread to acquire intrisic lock of the object of `Foo` (which is used by all the three thread below).\\nNow on this lock, we can conditionally block the threads based on current `counter` value. Only unblock the thread for which the condition that it was waiting for is met and rest of the threads will be blocked (their execution is suspended by the `wait()` call). \\n\\n```\\nclass Foo {\\n    int counter = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(counter != 1){\\n            wait();\\n        }\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(counter != 2){\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(counter != 3){\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    int counter = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(counter != 1){\\n            wait();\\n        }\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(counter != 2){\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(counter != 3){\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348334,
                "title": "c-autoresetevent-116ms",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    EventWaitHandle evnt1 = null;\\n    EventWaitHandle evnt2 = null;\\n    public Foo() {\\n        evnt1 = new AutoResetEvent(false);\\n        evnt2 = new AutoResetEvent(false);\\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        evnt1.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        evnt1.WaitOne();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        evnt2.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        evnt2.WaitOne();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        evnt2.Set();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    EventWaitHandle evnt1 = null;\\n    EventWaitHandle evnt2 = null;\\n    public Foo() {\\n        evnt1 = new AutoResetEvent(false);\\n        evnt2 = new AutoResetEvent(false);\\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        evnt1.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        evnt1.WaitOne();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        evnt2.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        evnt2.WaitOne();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        evnt2.Set();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339796,
                "title": "java-using-semaphores",
                "content": "```\\nimport java.util.concurrent.Semaphore;\\nclass Foo {\\n\\n    private final Semaphore second;\\n    private final Semaphore third;\\n    \\n    public Foo() {        \\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.Semaphore;\\nclass Foo {\\n\\n    private final Semaphore second;\\n    private final Semaphore third;\\n    \\n    public Foo() {        \\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333235,
                "title": "python-3-submission-with-threading-condition-beats-100-100",
                "content": "```\\nimport threading\\n\\n\\nclass Foo:\\n    def __init__(self):\\n        self.condition = threading.Condition()\\n        self.first_was_printed = False\\n        self.second_was_printed = False\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            printFirst()            \\n            self.first_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.first_was_printed\\n            )\\n            printSecond()\\n            self.second_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.second_was_printed\\n            )\\n            printThird()\\n            self.condition.notifyAll()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\n\\n\\nclass Foo:\\n    def __init__(self):\\n        self.condition = threading.Condition()\\n        self.first_was_printed = False\\n        self.second_was_printed = False\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            printFirst()            \\n            self.first_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.first_was_printed\\n            )\\n            printSecond()\\n            self.second_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.second_was_printed\\n            )\\n            printThird()\\n            self.condition.notifyAll()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511261,
                "title": "c-one-line-solution-with-std-atomic",
                "content": "# Intuition\\nWe use a variable (`turn`) to keep track of turns.\\n\\n# Approach\\nWe use `std::atomic` to prevent data race. Plus, we use `yield` to prevent busy waiting.\\n\\n# Code\\n```\\nclass Foo {\\n    std::atomic<int> turn = 1;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        while(turn!=1)\\n            this_thread::yield();\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn++;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(turn!=2)\\n            this_thread::yield();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn++;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(turn!=3)\\n            this_thread::yield();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    std::atomic<int> turn = 1;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        while(turn!=1)\\n            this_thread::yield();\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn++;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(turn!=2)\\n            this_thread::yield();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn++;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(turn!=3)\\n            this_thread::yield();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454807,
                "title": "semaphore-solution-simple-java-code",
                "content": "```\\nclass Foo {\\n\\n    private Semaphore forTwo;\\n    private Semaphore forThree;\\n    \\n    public Foo() {\\n        forTwo = new Semaphore(0);\\n        forThree = new Semaphore(0);\\n    }\\n\\n\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        forTwo.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        forTwo.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        forThree.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        \\n        forThree.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private Semaphore forTwo;\\n    private Semaphore forThree;\\n    \\n    public Foo() {\\n        forTwo = new Semaphore(0);\\n        forThree = new Semaphore(0);\\n    }\\n\\n\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        forTwo.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        forTwo.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        forThree.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        \\n        forThree.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147615,
                "title": "a-simple-solution-in-java",
                "content": "```\\nclass Foo {\\n    \\n    CountDownLatch second;\\n    CountDownLatch third;\\n\\n    public Foo() {\\n        second = new CountDownLatch(1);\\n        third = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    CountDownLatch second;\\n    CountDownLatch third;\\n\\n    public Foo() {\\n        second = new CountDownLatch(1);\\n        third = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013481,
                "title": "brainless-solution-using-time-sleep",
                "content": "Here is my simplest and brainless solution using time.sleep. Why and How did I think of it? People use this approach in automation where I work.\\n\\n```Python3\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        sleep(0.05)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        sleep(0.1)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python3\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        sleep(0.05)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        sleep(0.1)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856298,
                "title": "2-lines-python-solution-75-faster-memory-less-than-95",
                "content": "```\\nclass Foo:\\n    is_first_executed=False\\n    is_second_executed=False\\n    def __init__(self):\\n        pass\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.is_first_executed=True\\n\\n    def second(self, printSecond):\\n        while not self.is_first_executed: continue     \\n        printSecond()\\n        self.is_second_executed=True\\n                      \\n    def third(self, printThird):\\n        while not self.is_second_executed: continue\\n        printThird()\\n```\\n\\n-----------------\\n### ***Another Solution***\\n```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.event1=Event()\\n        self.event2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    is_first_executed=False\\n    is_second_executed=False\\n    def __init__(self):\\n        pass\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.is_first_executed=True\\n\\n    def second(self, printSecond):\\n        while not self.is_first_executed: continue     \\n        printSecond()\\n        self.is_second_executed=True\\n                      \\n    def third(self, printThird):\\n        while not self.is_second_executed: continue\\n        printThird()\\n```\n```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.event1=Event()\\n        self.event2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719686,
                "title": "c-zero-semaphore-with-comments",
                "content": "```\\n#include<semaphore.h>\\nclass Foo {\\npublic:\\n    sem_t sem1;\\n    sem_t sem2;\\n    Foo() {\\n        sem_init(&sem1,0,0);\\n        sem_init(&sem2,0,0);\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        printFirst();\\n        sem_post(&sem1);// increased the value to 1 so now two can be executed\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        sem_wait(&sem1);//see  if the value of the semaphore is > 0 or not if it is then one already was printed\\n        printSecond();\\n        sem_post(&sem2);// printed two so now increased the value of the semaphore sem2\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        sem_wait(&sem2);// if the value of the sem2 > 0 them two was already printed \\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<semaphore.h>\\nclass Foo {\\npublic:\\n    sem_t sem1;\\n    sem_t sem2;\\n    Foo() {\\n        sem_init(&sem1,0,0);\\n        sem_init(&sem2,0,0);\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        printFirst();\\n        sem_post(&sem1);// increased the value to 1 so now two can be executed\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        sem_wait(&sem1);//see  if the value of the semaphore is > 0 or not if it is then one already was printed\\n        printSecond();\\n        sem_post(&sem2);// printed two so now increased the value of the semaphore sem2\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        sem_wait(&sem2);// if the value of the sem2 > 0 them two was already printed \\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1548013,
                "title": "explanation-of-the-solution-in-java",
                "content": "You can use a countdownlatch, semaphore, regular mutex or lock object. I noticed a solution that relied upon volatile only but that is not right. A solution without wait/notify will cause CPU churns and spinning so you must introduce that if you are serious about MT safe programming. If you choose to go with CountDownLatch or Semaphores, you can create 2 indepent ones and there is an ordering one after another. I chose to use a lock object to demonstrate in detail how we enforce the ordering. Note that you must have a while loop to protect against the spurious wakeups. \\n\\n```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    private final Lock lock = new ReentrantLock();\\n    private final Condition secondThread = lock.newCondition();\\n    private final Condition thirdThread = lock.newCondition();\\n    private int step = 1;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();  \\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            // signal 2nd.\\n            step = 2;\\n            secondThread.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step != 2) {\\n                // protect against spurious wakeups.\\n                secondThread.await();        \\n            }\\n            printSecond.run();\\n            thirdThread.signal();\\n            step = 3;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step !=3) {\\n                // protect against spurious wakeups.\\n                thirdThread.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    private final Lock lock = new ReentrantLock();\\n    private final Condition secondThread = lock.newCondition();\\n    private final Condition thirdThread = lock.newCondition();\\n    private int step = 1;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();  \\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            // signal 2nd.\\n            step = 2;\\n            secondThread.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step != 2) {\\n                // protect against spurious wakeups.\\n                secondThread.await();        \\n            }\\n            printSecond.run();\\n            thirdThread.signal();\\n            step = 3;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step !=3) {\\n                // protect against spurious wakeups.\\n                thirdThread.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182618,
                "title": "simple-java-solution",
                "content": "Using wait and notifyAll to print in order. \\n``` \\nvolatile int loc = 0;\\n    public Foo() {\\n      loc = 0;   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            while(loc != 0){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 1){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printSecond.run();\\n         }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 2){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printThird.run();\\n         }\\n    }",
                "solutionTags": [],
                "code": "Using wait and notifyAll to print in order. \\n``` \\nvolatile int loc = 0;\\n    public Foo() {\\n      loc = 0;   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            while(loc != 0){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 1){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printSecond.run();\\n         }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 2){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printThird.run();\\n         }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1152634,
                "title": "c-mutex-and-condition-variable-12ms",
                "content": "```\\nclass Foo {\\n    mutex m;\\n    condition_variable firstCond;\\n    condition_variable secondCond;\\n    condition_variable thirdCond;\\n    int chance;\\npublic:\\n    Foo() {\\n        chance=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> locker(m);\\n        \\n        firstCond.wait(locker,[&](){\\n            return chance==1;\\n        });\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        chance=2;\\n        secondCond.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> locker(m);\\n        \\n        secondCond.wait(locker,[&](){\\n            return chance==2;\\n        });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        chance=3;\\n        thirdCond.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> locker(m);\\n        \\n        thirdCond.wait(locker,[&](){\\n            return chance==3;\\n        });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    mutex m;\\n    condition_variable firstCond;\\n    condition_variable secondCond;\\n    condition_variable thirdCond;\\n    int chance;\\npublic:\\n    Foo() {\\n        chance=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> locker(m);\\n        \\n        firstCond.wait(locker,[&](){\\n            return chance==1;\\n        });\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        chance=2;\\n        secondCond.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> locker(m);\\n        \\n        secondCond.wait(locker,[&](){\\n            return chance==2;\\n        });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        chance=3;\\n        thirdCond.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> locker(m);\\n        \\n        thirdCond.wait(locker,[&](){\\n            return chance==3;\\n        });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122967,
                "title": "c-simple-atomics-with-memory-order",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a1.store(true, memory_order_release);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!a1.load(std::memory_order_acquire)) this_thread::yield();\\n        printSecond();\\n        a2.store(true, memory_order_release);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(!a2.load(std::memory_order_acquire)) this_thread::yield();\\n        printThird();\\n    }\\nprivate:\\n    atomic<bool> a1{false};\\n    atomic<bool> a2{false};\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a1.store(true, memory_order_release);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!a1.load(std::memory_order_acquire)) this_thread::yield();\\n        printSecond();\\n        a2.store(true, memory_order_release);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(!a2.load(std::memory_order_acquire)) this_thread::yield();\\n        printThird();\\n    }\\nprivate:\\n    atomic<bool> a1{false};\\n    atomic<bool> a2{false};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055949,
                "title": "c-using-semaphores-short-with-comments",
                "content": "```\\n#include <semaphore.h>\\nclass Foo {\\n    sem_t firstSem;\\n    sem_t secondSem;\\npublic:\\n    Foo() {\\n\\t//init two semaphores with counter = 0\\n        sem_init(&firstSem, 0, 0);\\n        sem_init(&secondSem, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&firstSem); //increase firstSem counter to one to indicate printFirst() was finish \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&firstSem); //wait for printFirst() to finish\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&secondSem);  //increase secondSem counter to one to indicate printSecond() was finish \\n    }\\n\\n    void third(function<void()> printThird) {\\n         sem_wait(&secondSem); //wait for printSecond() to finish\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <semaphore.h>\\nclass Foo {\\n    sem_t firstSem;\\n    sem_t secondSem;\\npublic:\\n    Foo() {\\n\\t//init two semaphores with counter = 0\\n        sem_init(&firstSem, 0, 0);\\n        sem_init(&secondSem, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&firstSem); //increase firstSem counter to one to indicate printFirst() was finish \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&firstSem); //wait for printFirst() to finish\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&secondSem);  //increase secondSem counter to one to indicate printSecond() was finish \\n    }\\n\\n    void third(function<void()> printThird) {\\n         sem_wait(&secondSem); //wait for printSecond() to finish\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1033792,
                "title": "c-condition-variable-clean-code-easy-to-understand",
                "content": "```C++\\nclass Foo {\\n    atomic<int> cur;\\n    mutex mtx;\\n    condition_variable cv;\\nprotected:\\n    void do_work(function<void()> printS, function<bool()> check) {\\n        std::unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return check();});\\n        \\n        cur = (cur+1)%4;\\n        printS();\\n        cv.notify_all();\\n    }\\n    \\npublic:\\n    Foo() {\\n       this->cur = 1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        do_work(printFirst, [&]{return cur == 1;});\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        do_work(printSecond, [&]{return cur == 2;});\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n       do_work(printThird, [&]{return cur == 3;});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\nclass Foo {\\n    atomic<int> cur;\\n    mutex mtx;\\n    condition_variable cv;\\nprotected:\\n    void do_work(function<void()> printS, function<bool()> check) {\\n        std::unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return check();});\\n        \\n        cur = (cur+1)%4;\\n        printS();\\n        cv.notify_all();\\n    }\\n    \\npublic:\\n    Foo() {\\n       this->cur = 1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        do_work(printFirst, [&]{return cur == 1;});\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        do_work(printSecond, [&]{return cur == 2;});\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n       do_work(printThird, [&]{return cur == 3;});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008159,
                "title": "java-fastest-using-volatile-boolean-and-while-poll",
                "content": "```\\nclass Foo {\\n    volatile boolean waitTwo = true;\\n    volatile boolean waitThree = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        waitTwo = false;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(waitTwo){}\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        waitThree = false;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        while(waitThree){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    volatile boolean waitTwo = true;\\n    volatile boolean waitThree = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        waitTwo = false;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(waitTwo){}\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        waitThree = false;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        while(waitThree){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961280,
                "title": "python-solution-without-using-additional-libraries",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self._first = False\\n        self._second = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self._first = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while not self._first:\\n            pass\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self._second = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while not self._second:\\n            pass\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self._first = False\\n        self._second = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self._first = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while not self._first:\\n            pass\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self._second = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while not self._second:\\n            pass\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941730,
                "title": "countdownlatch-java",
                "content": "```\\nclass Foo {\\n\\n    private CountDownLatch latch1 = new CountDownLatch(1);\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n  \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n       \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        latch2.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private CountDownLatch latch1 = new CountDownLatch(1);\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n  \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n       \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        latch2.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940759,
                "title": "c-solution-using-2-mutexes",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        pthread_mutex_lock(&m_second);\\n        pthread_mutex_lock(&m_third);\\n    }\\n    \\n    ~Foo() {\\n        pthread_mutex_destroy(&m_second);\\n        pthread_mutex_destroy(&m_third);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        pthread_mutex_unlock(&m_second);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_second);\\n        printSecond();\\n        pthread_mutex_unlock(&m_third);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_third);\\n        printThird();\\n    }\\nprivate:\\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        pthread_mutex_lock(&m_second);\\n        pthread_mutex_lock(&m_third);\\n    }\\n    \\n    ~Foo() {\\n        pthread_mutex_destroy(&m_second);\\n        pthread_mutex_destroy(&m_third);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        pthread_mutex_unlock(&m_second);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_second);\\n        printSecond();\\n        pthread_mutex_unlock(&m_third);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_third);\\n        printThird();\\n    }\\nprivate:\\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850599,
                "title": "java-semaphore-simple-implementation",
                "content": "```\\nclass Foo {\\n    \\n    Semaphore second = new Semaphore(0);\\n    Semaphore third = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    Semaphore second = new Semaphore(0);\\n    Semaphore third = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757587,
                "title": "c-132ms-7-2mb-using-std-condition-variable-in-a-proper-way",
                "content": "Example with test cases\\nhttps://github.com/jimmy-park/leetcode-cpp-solution/blob/master/Concurrency/1114-Print-in-Order.h\\n\\n```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst)\\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n        {\\n            // prevent lost wakeup and spurious wakeup\\n            // and with CTAD (since C++17), you don\\'t need to type std::mutex as template argument\\n            std::lock_guard lock { mutex_ };\\n            done_first_ = true;\\n        }\\n\\n        cv_.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_first_; });\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        {\\n            std::lock_guard lock { mutex_ };\\n            done_second_ = true;\\n        }\\n        \\n        cv_.notify_one();\\n    }\\n\\n    void third(function<void()> printThird)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_second_; });\\n        }\\n\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    bool done_first_ { false };\\n    bool done_second_ { false };\\n    mutable std::mutex mutex_;\\n    std::condition_variable cv_;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst)\\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n        {\\n            // prevent lost wakeup and spurious wakeup\\n            // and with CTAD (since C++17), you don\\'t need to type std::mutex as template argument\\n            std::lock_guard lock { mutex_ };\\n            done_first_ = true;\\n        }\\n\\n        cv_.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_first_; });\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        {\\n            std::lock_guard lock { mutex_ };\\n            done_second_ = true;\\n        }\\n        \\n        cv_.notify_one();\\n    }\\n\\n    void third(function<void()> printThird)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_second_; });\\n        }\\n\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    bool done_first_ { false };\\n    bool done_second_ { false };\\n    mutable std::mutex mutex_;\\n    std::condition_variable cv_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567213,
                "title": "java-countdownlatch-solution",
                "content": "```\\nclass Foo {\\n\\n    CountDownLatch first = new CountDownLatch(1);\\n    CountDownLatch second = new CountDownLatch(1);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    CountDownLatch first = new CountDownLatch(1);\\n    CountDownLatch second = new CountDownLatch(1);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512327,
                "title": "python3-threading-using-lock",
                "content": "Algorithm:\\nUse two locks `self.lock1` and `self.lock2` to maintain the order of executions of 3 methods. \\n\\nImplementation (32ms, 90%): \\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        self.lock1.acquire() #lock\\n        self.lock2.acquire() #lock\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.lock1.release() #unlocked\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.lock1:\\n            # printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond()\\n            self.lock2.release() #unlocked\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.lock2:\\n            # printThird() outputs \"third\". Do not change or remove this line.\\n            printThird()\\n```\\n\\nThere is a very nice summary by @mereck in this [thread](https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation) of Python synchronization primitives.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        self.lock1.acquire() #lock\\n        self.lock2.acquire() #lock\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.lock1.release() #unlocked\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.lock1:\\n            # printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond()\\n            self.lock2.release() #unlocked\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.lock2:\\n            # printThird() outputs \"third\". Do not change or remove this line.\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477201,
                "title": "countdownlatch-java-100-100",
                "content": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    CountDownLatch latch1;\\n    CountDownLatch latch2;\\n    \\n    public Foo() {\\n        latch1 = new CountDownLatch(1);\\n        latch2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    CountDownLatch latch1;\\n    CountDownLatch latch2;\\n    \\n    public Foo() {\\n        latch1 = new CountDownLatch(1);\\n        latch2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476741,
                "title": "java-using-lock-synchronized-wait-notifyall-solution",
                "content": "```java\\nclass Foo {\\n    private final AtomicInteger i = new AtomicInteger();\\n    private final Object lock = new Object();\\n\\n    public Foo() {\\n        i.set(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 0) {\\n                lock.wait();\\n            }\\n            printFirst.run();\\n            i.set(1);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 1) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            i.set(2);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 2) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n            i.set(3);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    private final AtomicInteger i = new AtomicInteger();\\n    private final Object lock = new Object();\\n\\n    public Foo() {\\n        i.set(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 0) {\\n                lock.wait();\\n            }\\n            printFirst.run();\\n            i.set(1);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 1) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            i.set(2);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 2) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n            i.set(3);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456220,
                "title": "c-with-spinwait",
                "content": "```\\nusing System.Threading;\\npublic class Foo {\\n    private int _state = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        _state = 2; \\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==2);\\n        printSecond();\\n        _state=3;\\n    }\\n\\n    public void Third(Action printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==3);\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\npublic class Foo {\\n    private int _state = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        _state = 2; \\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==2);\\n        printSecond();\\n        _state=3;\\n    }\\n\\n    public void Third(Action printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==3);\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447099,
                "title": "simple-java-solution",
                "content": "```\\nclass Foo {\\n    CountDownLatch lock1;\\n    CountDownLatch lock2;\\n    public Foo() {\\n        lock1 = new CountDownLatch(1);\\n        lock2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        lock1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        lock2.countDown();\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock1.await();\\n        lock2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    CountDownLatch lock1;\\n    CountDownLatch lock2;\\n    public Foo() {\\n        lock1 = new CountDownLatch(1);\\n        lock2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        lock1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        lock2.countDown();\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock1.await();\\n        lock2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440715,
                "title": "why-sem-t-is-unknown-for-c",
                "content": "When I include semaphore.h in C code and use sem_t sem, it gives unknown data type sem_t?\\nerror:\\nLine 10: Char 5: error: unknown type name \\'sem_t\\'\\n     sem_t sem;\\n\\n#include <semaphore.h>\\n#include <pthread.h>\\n#include <unistd.h> \\n#include <sys/types.h>\\n\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int data;\\n    sem_t sem;\\n} Foo;\\n",
                "solutionTags": [],
                "code": "When I include semaphore.h in C code and use sem_t sem, it gives unknown data type sem_t?\\nerror:\\nLine 10: Char 5: error: unknown type name \\'sem_t\\'\\n     sem_t sem;\\n\\n#include <semaphore.h>\\n#include <pthread.h>\\n#include <unistd.h> \\n#include <sys/types.h>\\n\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int data;\\n    sem_t sem;\\n} Foo;\\n",
                "codeTag": "C++"
            },
            {
                "id": 436919,
                "title": "c-solution-no-need-a-lock",
                "content": "```\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int val;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    \\n    // Initialize user defined data here.\\n    obj->val = 0;\\n    \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    \\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    \\n    obj->val++;\\n}\\n\\nvoid second(Foo* obj) {\\n    while (obj->val < 1) {\\n       sched_yield();\\n    }\\n    \\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    \\n    obj->val++;\\n}\\n\\nvoid third(Foo* obj) {\\n    while (obj->val < 2) {\\n       sched_yield();\\n    }\\n    \\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // User defined data may be cleaned up here.\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int val;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    \\n    // Initialize user defined data here.\\n    obj->val = 0;\\n    \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    \\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    \\n    obj->val++;\\n}\\n\\nvoid second(Foo* obj) {\\n    while (obj->val < 1) {\\n       sched_yield();\\n    }\\n    \\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    \\n    obj->val++;\\n}\\n\\nvoid third(Foo* obj) {\\n    while (obj->val < 2) {\\n       sched_yield();\\n    }\\n    \\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // User defined data may be cleaned up here.\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 360882,
                "title": "c-super-simple-implementation-90",
                "content": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    int state;\\n    condition_variable cv;\\npublic:\\n    Foo(): state{0}{}\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==0;});\\n        state=1;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==1;});\\n        state=2;\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==2;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    int state;\\n    condition_variable cv;\\npublic:\\n    Foo(): state{0}{}\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==0;});\\n        state=1;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==1;});\\n        state=2;\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==2;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356791,
                "title": "c-future-promise-or-mutex-condition-variable",
                "content": "Solution 1: \\nfuture + promise.\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    std::promise<int> p1;\\n    std::promise<int> p2;\\n};\\n```\\n\\nsolution 2:\\nmutex + condition_variable\\n```\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        b1 = false;\\n        b2 = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        b1 = true;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b1;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        b2 = true;\\n        lk.unlock();\\n        cv.notify_one();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b2; });\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lk.unlock();\\n    }\\nprivate:    \\n    std::mutex mtx;\\n    bool b1, b2;\\n    condition_variable cv;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    std::promise<int> p1;\\n    std::promise<int> p2;\\n};\\n```\n```\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        b1 = false;\\n        b2 = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        b1 = true;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b1;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        b2 = true;\\n        lk.unlock();\\n        cv.notify_one();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b2; });\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lk.unlock();\\n    }\\nprivate:    \\n    std::mutex mtx;\\n    bool b1, b2;\\n    condition_variable cv;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353129,
                "title": "java-solution-with-single-semaphore",
                "content": "```\\nclass Foo {\\n\\n    java.util.concurrent.Semaphore semaphore = new java.util.concurrent.Semaphore(2);\\n    \\n    public Foo() {\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(semaphore.availablePermits() != 2){}\\n        \\n        printFirst.run();\\n\\n        semaphore.acquire();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(semaphore.availablePermits() != 1){}\\n        \\n        printSecond.run();        \\n\\n        semaphore.acquire();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(semaphore.availablePermits() != 0){}\\n        \\n        printThird.run();\\n\\n        semaphore.release(2);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    java.util.concurrent.Semaphore semaphore = new java.util.concurrent.Semaphore(2);\\n    \\n    public Foo() {\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(semaphore.availablePermits() != 2){}\\n        \\n        printFirst.run();\\n\\n        semaphore.acquire();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(semaphore.availablePermits() != 1){}\\n        \\n        printSecond.run();        \\n\\n        semaphore.acquire();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(semaphore.availablePermits() != 0){}\\n        \\n        printThird.run();\\n\\n        semaphore.release(2);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 347584,
                "title": "java-compareandset",
                "content": "```java\\nimport java.util.concurrent.atomic.AtomicInteger;\\nclass Foo {\\n\\n    private AtomicInteger integer;\\n    \\n    public Foo() {\\n        integer = new AtomicInteger();    \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(!integer.compareAndSet(0, 1));\\n        printFirst.run();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!integer.compareAndSet(1, 2));\\n        printSecond.run();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!integer.compareAndSet(2, 3));\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.util.concurrent.atomic.AtomicInteger;\\nclass Foo {\\n\\n    private AtomicInteger integer;\\n    \\n    public Foo() {\\n        integer = new AtomicInteger();    \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(!integer.compareAndSet(0, 1));\\n        printFirst.run();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!integer.compareAndSet(1, 2));\\n        printSecond.run();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!integer.compareAndSet(2, 3));\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336394,
                "title": "java-volatile-9ms",
                "content": "```\\nclass Foo {\\n    private  volatile Integer a;\\n    public Foo() {\\n        a = 0;\\n    }\\n    public void first(Runnable printFirst) throws InterruptedException {\\n         printFirst.run();\\n         a++;\\n    }\\n    public void second(Runnable printSecond) throws InterruptedException {\\n         while(a%3 != 1){}\\n         printSecond.run();\\n         a++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n          while(a%3 != 2){}\\n          printThird.run();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private  volatile Integer a;\\n    public Foo() {\\n        a = 0;\\n    }\\n    public void first(Runnable printFirst) throws InterruptedException {\\n         printFirst.run();\\n         a++;\\n    }\\n    public void second(Runnable printSecond) throws InterruptedException {\\n         while(a%3 != 1){}\\n         printSecond.run();\\n         a++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n          while(a%3 != 2){}\\n          printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332954,
                "title": "java-go-implements",
                "content": "Interesting, wish leetcode provide Go lang soon.\\n\\n**Java**\\n```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    Semaphore semaphore1 = new Semaphore(0);\\n    Semaphore semaphore2 = new Semaphore(0);\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        semaphore1.acquire();\\n        printSecond.run();\\n        semaphore2.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        semaphore2.acquire();        \\n        printThird.run();\\n    }\\n}\\n```\\n\\n**Go**\\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nvar oneDone = make(chan bool)\\nvar twoDone = make(chan bool)\\n\\nfunc first() {\\n\\tfmt.Println(\"one\")\\n\\toneDone <- true\\n}\\n\\nfunc second() {\\n\\t<-oneDone\\n\\tfmt.Println(\"two\")\\n\\ttwoDone <- true\\n}\\n\\nfunc third() {\\n\\t<-twoDone\\n\\tfmt.Println(\"three\")\\n}\\n\\nfunc main() {\\n\\tgo second()\\n\\tgo third()\\n\\tgo first()\\n\\n\\tfmt.Scanln()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    Semaphore semaphore1 = new Semaphore(0);\\n    Semaphore semaphore2 = new Semaphore(0);\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        semaphore1.acquire();\\n        printSecond.run();\\n        semaphore2.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        semaphore2.acquire();        \\n        printThird.run();\\n    }\\n}\\n```\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nvar oneDone = make(chan bool)\\nvar twoDone = make(chan bool)\\n\\nfunc first() {\\n\\tfmt.Println(\"one\")\\n\\toneDone <- true\\n}\\n\\nfunc second() {\\n\\t<-oneDone\\n\\tfmt.Println(\"two\")\\n\\ttwoDone <- true\\n}\\n\\nfunc third() {\\n\\t<-twoDone\\n\\tfmt.Println(\"three\")\\n}\\n\\nfunc main() {\\n\\tgo second()\\n\\tgo third()\\n\\tgo first()\\n\\n\\tfmt.Scanln()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022323,
                "title": "c-mutex-condition-variable-simple-code",
                "content": "# Note\\n\\n* We don\\'t need any wait for printing 1. Hence, no condition variable wait\\n* We don\\'t need to notify anyone after printing 3. Hence, no notify after printing 3.\\n* My code doesn\\'t work when I do \\n`if(currentPrint!=2) cv.wait(lock)`\\nbut works only when I do \\n`cv.wait(lock,[&](){return currentPrint==2;});`\\n\\nIt is best to pass the boolean expression as part of wait. Otherwise, there is a timeout.\\n\\n\\n# Code\\n```\\nclass Foo {\\n    condition_variable cv;\\n    mutex mtx;\\n    int currentPrint;\\npublic:\\n    Foo() {\\n        currentPrint=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex>lock(mtx);\\n        currentPrint=2;\\n        printFirst();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==2;});\\n        currentPrint=3;\\n        printSecond();\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==3;});\\n        printThird();\\n    }\\n};\\n```\\n\\n\\nPlease let me know if there are any feedbacks on this. Happy coding (^-^)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    condition_variable cv;\\n    mutex mtx;\\n    int currentPrint;\\npublic:\\n    Foo() {\\n        currentPrint=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex>lock(mtx);\\n        currentPrint=2;\\n        printFirst();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==2;});\\n        currentPrint=3;\\n        printSecond();\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==3;});\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475728,
                "title": "only-used-vector-no-lock-semaphore-low-level-objects",
                "content": "# Approach\\nNot a fan of low level stuff (even for easy questions), so here\\'s a solution using nothing but a vector.\\n\\nI made the class have a vector, printed, which contains bool values of whether any given print function executed. Since the same instance will be passed to each thread, all threads can update this vector so that other threads can see.\\n\\nAdditonally, since each thread calls a different function (Thread A calls first(), Thread B second(), Thread C third()), they will all manipulate a different section of the Foo object (Thread A printed[0], Thread B printed[1], Thread C printed[2]), so race conditions are taken into account in this solution.\\n\\nThis solution has a high run time (beats 9.36% of solutions), and is not anything remotely like any reasonable expected solution. This solution is for the software engineers that ventured into the land of concurrency out of curiosity, like me.\\n\\n\\n# Code\\n```\\nclass Foo {\\nprivate:\\n    vector<bool> printed; // keeps track of which print funcs executed\\npublic:\\n    Foo() : printed(3, false) {}\\n\\n    void first(function<void()> printFirst) {\\n        printFirst(); // this should always print first\\n        printed[0] = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (!printed[0]) {} // second will never print first, wait for first\\n        printSecond();\\n        printed[1] = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // no need to explicitly wait for first, since second should never execute before first\\n        // besides, waiting for first and second creates a race condition, since two threads are reading the same piece of data\\n        while (!printed[1]) {} // wait for second\\n        printThird();\\n        printed[2] = true;\\n    }\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Concurrency"
                ],
                "code": "```\\nclass Foo {\\nprivate:\\n    vector<bool> printed; // keeps track of which print funcs executed\\npublic:\\n    Foo() : printed(3, false) {}\\n\\n    void first(function<void()> printFirst) {\\n        printFirst(); // this should always print first\\n        printed[0] = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (!printed[0]) {} // second will never print first, wait for first\\n        printSecond();\\n        printed[1] = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // no need to explicitly wait for first, since second should never execute before first\\n        // besides, waiting for first and second creates a race condition, since two threads are reading the same piece of data\\n        while (!printed[1]) {} // wait for second\\n        printThird();\\n        printed[2] = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203351,
                "title": "c-simple-solution-using-only-this-thread-yield",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    int order = 1;\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n       if (order == 1) {\\n         order = 2;\\n       } \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (order != 2) {\\n          std::this_thread::yield();\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        if (order == 2) {\\n          order = 3;\\n        } \\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (order != 3) {\\n          std::this_thread::yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    int order = 1;\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n       if (order == 1) {\\n         order = 2;\\n       } \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (order != 2) {\\n          std::this_thread::yield();\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        if (order == 2) {\\n          order = 3;\\n        } \\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (order != 3) {\\n          std::this_thread::yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135932,
                "title": "java-reentrant-lock",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\n\\n    private final ReentrantLock lock = new ReentrantLock();\\n\\n    private final Condition condition1 = lock.newCondition();\\n\\n    private final Condition condition2 = lock.newCondition();\\n\\n    private boolean waitOne = true;\\n\\n    private boolean waitTwo = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            waitOne = false;\\n            condition1.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitOne) {\\n                condition1.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            waitTwo = false;\\n            condition2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitTwo) {\\n                condition2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printThird.run();\\n            waitOne = true;\\n            waitTwo = true;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n    private final ReentrantLock lock = new ReentrantLock();\\n\\n    private final Condition condition1 = lock.newCondition();\\n\\n    private final Condition condition2 = lock.newCondition();\\n\\n    private boolean waitOne = true;\\n\\n    private boolean waitTwo = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            waitOne = false;\\n            condition1.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitOne) {\\n                condition1.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            waitTwo = false;\\n            condition2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitTwo) {\\n                condition2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printThird.run();\\n            waitOne = true;\\n            waitTwo = true;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086543,
                "title": "java-solution-approach-1-using-object-lock-approach-2-using-countdown-latch",
                "content": "# Intuition\\nWe need to suspend the thread printing second until first completes, and third until second completes.\\n\\n# Approach 1 - Using Object lock\\nUse `synchronsed` block to guard the block of code, and suspend the thread using `buzy waiting` method until `first`, `second` is not printed in order.\\n\\n\\n# Code\\n```java\\nclass Foo {\\n    private int currentNum;\\n\\n    public Foo() {\\n        this.currentNum = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 1) {\\n                wait();\\n            }\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 2) {\\n                wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n         synchronized (this) {\\n            while (currentNum != 3) {\\n                wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n}\\n```\\n\\n\\n# Approach 2 - Using CountDownLatch\\nHere we make use of two countdown latches, \\nthe second thread waits on first latch to countDown to 0, and third thread waits on second latch to countDown to 0.\\n<br>\\nThe code is self explanatory.\\n\\n# Code\\n```java\\nclass Foo {\\n    private CountDownLatch firstLatch;\\n    private CountDownLatch secondLatch;\\n\\n    public Foo() {\\n        this.firstLatch = new CountDownLatch(1);\\n        this.secondLatch = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) {\\n        printFirst.run();\\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        printSecond.run();\\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Foo {\\n    private int currentNum;\\n\\n    public Foo() {\\n        this.currentNum = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 1) {\\n                wait();\\n            }\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 2) {\\n                wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n         synchronized (this) {\\n            while (currentNum != 3) {\\n                wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n}\\n```\n```java\\nclass Foo {\\n    private CountDownLatch firstLatch;\\n    private CountDownLatch secondLatch;\\n\\n    public Foo() {\\n        this.firstLatch = new CountDownLatch(1);\\n        this.secondLatch = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) {\\n        printFirst.run();\\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        printSecond.run();\\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823042,
                "title": "java-solution-using-semaphore",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Foo {\\n\\n    Semaphore first;\\n    Semaphore second;\\n    Semaphore third;\\n    public Foo() {\\n        first = new Semaphore(1);\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        first.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        first.release();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n    Semaphore first;\\n    Semaphore second;\\n    Semaphore third;\\n    public Foo() {\\n        first = new Semaphore(1);\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        first.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        first.release();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790990,
                "title": "java-phaser",
                "content": "# Code\\n```\\nclass Foo {\\n    private Phaser phaser = new Phaser(3);\\n\\n    public Foo() { }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (phaser.getPhase() != 1) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (phaser.getPhase() != 2) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private Phaser phaser = new Phaser(3);\\n\\n    public Foo() { }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (phaser.getPhase() != 1) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (phaser.getPhase() != 2) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755956,
                "title": "c-blocking-threads-with-autoresetevent-primitives",
                "content": "# Intuition\\nFirst thing that came to my mind was to block second, then third method until prefious will be completed\\n\\n# Approach\\nI decided to block set blockers in second and third methods. We create 2 blockers in nonsignal state, that means the method WaitOne() will block threads. \\n\\nMethod First() without blockers, after running printFirst() we transfer _secondBlocker in signal state by running method Set(), so _secondBlocker unblocks blocked threads. The same with method Third()\\n\\n# Code\\n```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly AutoResetEvent _secondBlocker = new AutoResetEvent(false);\\n    private readonly AutoResetEvent _thirdBlocker = new AutoResetEvent(false);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _secondBlocker.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _secondBlocker.WaitOne();\\n        printSecond();\\n        _thirdBlocker.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _thirdBlocker.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly AutoResetEvent _secondBlocker = new AutoResetEvent(false);\\n    private readonly AutoResetEvent _thirdBlocker = new AutoResetEvent(false);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _secondBlocker.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _secondBlocker.WaitOne();\\n        printSecond();\\n        _thirdBlocker.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _thirdBlocker.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716544,
                "title": "c-0ms-100",
                "content": "![image](https://assets.leetcode.com/users/images/65577e65-fc51-4d55-a6ff-ad0c635d4717_1666065469.4353917.png)\\n```\\ntypedef struct\\n{\\n    // User defined data may be declared here.\\n    int turn;\\n    pthread_mutex_t lock;\\n    pthread_cond_t cond;\\n} Foo;\\n\\nFoo* fooCreate()\\n{\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    // init mutex and cond\\n    pthread_mutex_init(&(obj->lock), NULL);\\n    pthread_cond_init(&(obj->cond), NULL);\\n    obj->turn = 1;\\n    return obj;\\n}\\n\\nvoid first(Foo* obj)\\n{\\n    // take lock\\n    pthread_mutex_lock(&(obj->lock));\\n    // while not my turn\\n    while(obj->turn != 1)\\n    {\\n        // wait and unlock\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    obj->turn = 2;\\n    // unlock\\n    pthread_mutex_unlock(&(obj->lock));\\n    // broadcast\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid second(Foo* obj)\\n{\\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 2)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock));\\n    }\\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    obj->turn = 3;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid third(Foo* obj)\\n{    \\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 3)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n    obj->turn = 1;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid fooFree(Foo* obj)\\n{\\n    // User defined data may be cleaned up here.\\n    free(obj);\\n}\\n```\\n\\u2B06\\uFE0Fplease upvote if helpful :)\\u2B06\\uFE0F",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct\\n{\\n    // User defined data may be declared here.\\n    int turn;\\n    pthread_mutex_t lock;\\n    pthread_cond_t cond;\\n} Foo;\\n\\nFoo* fooCreate()\\n{\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    // init mutex and cond\\n    pthread_mutex_init(&(obj->lock), NULL);\\n    pthread_cond_init(&(obj->cond), NULL);\\n    obj->turn = 1;\\n    return obj;\\n}\\n\\nvoid first(Foo* obj)\\n{\\n    // take lock\\n    pthread_mutex_lock(&(obj->lock));\\n    // while not my turn\\n    while(obj->turn != 1)\\n    {\\n        // wait and unlock\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    obj->turn = 2;\\n    // unlock\\n    pthread_mutex_unlock(&(obj->lock));\\n    // broadcast\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid second(Foo* obj)\\n{\\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 2)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock));\\n    }\\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    obj->turn = 3;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid third(Foo* obj)\\n{    \\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 3)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n    obj->turn = 1;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid fooFree(Foo* obj)\\n{\\n    // User defined data may be cleaned up here.\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2533398,
                "title": "java-real-simple-solution",
                "content": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403054,
                "title": "python-easy-solution",
                "content": "```\\nimport time\\nclass Foo:\\n    def __init__(self):\\n        self.state = [False,False,False]\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.state[0] = True\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.state[0]==False: time.sleep(0.001)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.state[1] = True\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.state[1]==False: time.sleep(0.001)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.state[2] = True\\n```",
                "solutionTags": [],
                "code": "```\\nimport time\\nclass Foo:\\n    def __init__(self):\\n        self.state = [False,False,False]\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.state[0] = True\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.state[0]==False: time.sleep(0.001)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.state[1] = True\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.state[1]==False: time.sleep(0.001)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.state[2] = True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356900,
                "title": "using-event",
                "content": "```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.t1=Event()\\n        self.t2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        printFirst()\\n        self.t1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.t1.wait()\\n        printSecond()\\n        self.t2.set()\\n        \\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.t2.wait()\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.t1=Event()\\n        self.t2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        printFirst()\\n        self.t1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.t1.wait()\\n        printSecond()\\n        self.t2.set()\\n        \\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.t2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313189,
                "title": "java-easy-solution",
                "content": "```\\nclass Foo {\\n    CountDownLatch c;\\n    CountDownLatch b;\\n\\n    public Foo() {\\n        b = new CountDownLatch(1);\\n        c = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        b.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        b.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        c.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        c.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    CountDownLatch c;\\n    CountDownLatch b;\\n\\n    public Foo() {\\n        b = new CountDownLatch(1);\\n        c = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        b.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        b.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        c.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        c.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265427,
                "title": "c-using-mutex-and-conditional-variable",
                "content": "In this solution I have used mutex and conditional variable. Also used an additional variable turn which will keep in track of which thread\\'s turn it is.\\n\\n```\\n// All the three threads got CPU and are running parallely. We don\\'t know which will run 1st, 2nd ...\\n\\n// Object of class Foo will be created. Foo --> foo1\\n// T1 = foo1.first\\n// T2 = foo1.second\\n// T3 = foo1.third\\n\\n// T2 will be waiting on some condition, which will become true when T1 has been executed\\n// T1 will make it true after printing first\\n\\n// Will use mutex and condition variable, and a variable turn to know who\\'s turn it is\\n// All the threads will shoot parallely. First turn = 0\\n\\nclass Foo {\\n    int turn;\\n    condition_variable(cv);\\n    mutex m;\\npublic:\\n    Foo() { // constructor\\n        turn = 0;\\n    }\\n\\n    void first(function<void()> printFirst) { // No condition on this as T1 will come first and execute it\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn = 1; // next turn is of T2\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(m);\\n        while(turn != 1){\\n            cv.wait(lock); // If it\\'s not turn of T2, thread will wait\\n        }\\n        // when signalled by T1, will go in while loop and check if turn == 1, if not then again wait.\\n        // else print second\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn = 2; // next turn is of T3\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(m);\\n        // When T1 will signal, CPU will come and check T3 also but due to condition of while loop it will again wait\\n        while(turn != 2){\\n            cv.wait(lock);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// All the three threads got CPU and are running parallely. We don\\'t know which will run 1st, 2nd ...\\n\\n// Object of class Foo will be created. Foo --> foo1\\n// T1 = foo1.first\\n// T2 = foo1.second\\n// T3 = foo1.third\\n\\n// T2 will be waiting on some condition, which will become true when T1 has been executed\\n// T1 will make it true after printing first\\n\\n// Will use mutex and condition variable, and a variable turn to know who\\'s turn it is\\n// All the threads will shoot parallely. First turn = 0\\n\\nclass Foo {\\n    int turn;\\n    condition_variable(cv);\\n    mutex m;\\npublic:\\n    Foo() { // constructor\\n        turn = 0;\\n    }\\n\\n    void first(function<void()> printFirst) { // No condition on this as T1 will come first and execute it\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn = 1; // next turn is of T2\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(m);\\n        while(turn != 1){\\n            cv.wait(lock); // If it\\'s not turn of T2, thread will wait\\n        }\\n        // when signalled by T1, will go in while loop and check if turn == 1, if not then again wait.\\n        // else print second\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn = 2; // next turn is of T3\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(m);\\n        // When T1 will signal, CPU will come and check T3 also but due to condition of while loop it will again wait\\n        while(turn != 2){\\n            cv.wait(lock);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064377,
                "title": "c-unique-lock-and-condition-variable-concurrency-in-c-notes",
                "content": "Tracking the last executed function using an integer. Then used a `condition_variable::wait` with a lambda expression to wait for the integer to change.\\n\\nConcurrency in C++ notes: https://github.com/akormous/dsa/tree/master/9_Concurrency\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        lastExecutedFunction = 0;   // initially\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);  // acquire lock\\n        cv.wait(lock, [&]{return lastExecutedFunction == 0;});  // wait until last executed function is 0, initial condition\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        lastExecutedFunction = 1;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 1;});  // wait until last exec function is first()\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        lastExecutedFunction = 2;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 2;});  // wait until last exec function is second()\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        lastExecutedFunction = 0;\\n        cv.notify_all();\\n    }\\nprivate:\\n    mutex mtx;\\n    condition_variable cv;\\n    int lastExecutedFunction;   // 0 (initial), 1, 2, or 3\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        lastExecutedFunction = 0;   // initially\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);  // acquire lock\\n        cv.wait(lock, [&]{return lastExecutedFunction == 0;});  // wait until last executed function is 0, initial condition\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        lastExecutedFunction = 1;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 1;});  // wait until last exec function is first()\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        lastExecutedFunction = 2;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 2;});  // wait until last exec function is second()\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        lastExecutedFunction = 0;\\n        cv.notify_all();\\n    }\\nprivate:\\n    mutex mtx;\\n    condition_variable cv;\\n    int lastExecutedFunction;   // 0 (initial), 1, 2, or 3\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908213,
                "title": "pthread-h-mutex-cond",
                "content": "```c\\ntypedef struct {\\n        int flag;\\n        pthread_mutex_t mtx;\\n        pthread_cond_t cnd;\\n} Foo;\\n\\nFoo *\\nfooCreate()\\n{\\n        Foo *foo;\\n        foo = malloc(sizeof(*foo));\\n        foo->flag = 0;\\n        pthread_mutex_init(&foo->mtx, NULL);\\n        pthread_cond_init(&foo->cnd, NULL);\\n        return foo;\\n}\\n\\nvoid\\nsignal(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        foo->flag = val;\\n        pthread_cond_broadcast(&foo->cnd);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nwait(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        while (foo->flag != val)\\n                pthread_cond_wait(&foo->cnd, &foo->mtx);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nfirst(Foo *foo)\\n{\\n        printFirst();\\n        signal(foo, 1);\\n}\\n\\nvoid\\nsecond(Foo *foo)\\n{\\n        wait(foo, 1);\\n        printSecond();\\n        signal(foo, 2);\\n}\\n\\nvoid\\nthird(Foo *foo)\\n{\\n        wait(foo, 2);\\n        printThird();\\n}\\n\\nvoid\\nfooFree(Foo *foo)\\n{\\n        pthread_mutex_destroy(&foo->mtx);\\n        pthread_cond_destroy(&foo->cnd);\\n        free(foo);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\ntypedef struct {\\n        int flag;\\n        pthread_mutex_t mtx;\\n        pthread_cond_t cnd;\\n} Foo;\\n\\nFoo *\\nfooCreate()\\n{\\n        Foo *foo;\\n        foo = malloc(sizeof(*foo));\\n        foo->flag = 0;\\n        pthread_mutex_init(&foo->mtx, NULL);\\n        pthread_cond_init(&foo->cnd, NULL);\\n        return foo;\\n}\\n\\nvoid\\nsignal(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        foo->flag = val;\\n        pthread_cond_broadcast(&foo->cnd);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nwait(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        while (foo->flag != val)\\n                pthread_cond_wait(&foo->cnd, &foo->mtx);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nfirst(Foo *foo)\\n{\\n        printFirst();\\n        signal(foo, 1);\\n}\\n\\nvoid\\nsecond(Foo *foo)\\n{\\n        wait(foo, 1);\\n        printSecond();\\n        signal(foo, 2);\\n}\\n\\nvoid\\nthird(Foo *foo)\\n{\\n        wait(foo, 2);\\n        printThird();\\n}\\n\\nvoid\\nfooFree(Foo *foo)\\n{\\n        pthread_mutex_destroy(&foo->mtx);\\n        pthread_cond_destroy(&foo->cnd);\\n        free(foo);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1896980,
                "title": "java-object-wait-notify-solution",
                "content": "As the same Foo instance passed to all threads, we can use the instance as a lock and use an index as identifier to arrange the correct order for printing.\\n```\\nclass Foo {\\n    private int index;\\n    public Foo() {\\n        index = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 0)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printFirst.run();\\n            index++;\\n            this.notifyAll();\\n            \\n        }\\n       \\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 1)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printSecond.run();\\n            index++;\\n            this.notifyAll();\\n       }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 2)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            index++;\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private int index;\\n    public Foo() {\\n        index = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 0)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printFirst.run();\\n            index++;\\n            this.notifyAll();\\n            \\n        }\\n       \\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 1)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printSecond.run();\\n            index++;\\n            this.notifyAll();\\n       }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 2)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            index++;\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839215,
                "title": "python3-using-3-locks-60ms",
                "content": "from threading import Thread, Lock\\n\\n```\\nclass Foo:\\n    def __init__(self):\\n        self.lockFirst = Lock()\\n        self.lockSecond = Lock()\\n        self.lockThird = Lock()\\n        self.lockSecond.acquire()\\n        self.lockThird.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.lockFirst.acquire()\\n        printFirst()\\n        self.lockSecond.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lockSecond.acquire()\\n        printSecond()\\n        self.lockThird.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lockThird.acquire()\\n        printThird()\\n        self.lockFirst.release()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.lockFirst = Lock()\\n        self.lockSecond = Lock()\\n        self.lockThird = Lock()\\n        self.lockSecond.acquire()\\n        self.lockThird.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.lockFirst.acquire()\\n        printFirst()\\n        self.lockSecond.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lockSecond.acquire()\\n        printSecond()\\n        self.lockThird.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lockThird.acquire()\\n        printThird()\\n        self.lockFirst.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748867,
                "title": "python-solution",
                "content": "```\\nfrom threading import Lock\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.locks[0].release()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.locks[1]:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Lock\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.locks[0].release()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.locks[1]:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606754,
                "title": "java-synchronized-on-the-foo-object",
                "content": "I\\'ve seen some more exotic solutions posted here. Is this standard or in any way problematic?\\n```class Foo {\\n    private static enum PrintState {\\n        ZERO, DID1, DID2\\n    }\\n    private PrintState printState = PrintState.ZERO;\\n    \\n    public Foo() {}\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(printState != PrintState.ZERO) wait();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        printState = PrintState.DID1;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(printState != PrintState.DID1) wait();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        printState = PrintState.DID2;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(printState != PrintState.DID2) wait();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        printState = PrintState.ZERO;\\n        notifyAll();\\n    }\\n}",
                "solutionTags": [],
                "code": "I\\'ve seen some more exotic solutions posted here. Is this standard or in any way problematic?\\n```class Foo {\\n    private static enum PrintState {\\n        ZERO, DID1, DID2\\n    }\\n    private PrintState printState = PrintState.ZERO;\\n    \\n    public Foo() {}\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(printState != PrintState.ZERO) wait();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        printState = PrintState.DID1;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(printState != PrintState.DID1) wait();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        printState = PrintState.DID2;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(printState != PrintState.DID2) wait();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        printState = PrintState.ZERO;\\n        notifyAll();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1569063,
                "title": "python-mutex",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        from threading import Lock\\n\\n        self._mutex1 = Lock()\\n        self._mutex2 = Lock()\\n        self._mutex1.acquire()\\n        self._mutex2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self._mutex1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self._mutex1.acquire()\\n        printSecond()\\n        self._mutex1.release()\\n        self._mutex2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:        \\n        self._mutex2.acquire()\\n        printThird()\\n        self._mutex2.release()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        from threading import Lock\\n\\n        self._mutex1 = Lock()\\n        self._mutex2 = Lock()\\n        self._mutex1.acquire()\\n        self._mutex2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self._mutex1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self._mutex1.acquire()\\n        printSecond()\\n        self._mutex1.release()\\n        self._mutex2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:        \\n        self._mutex2.acquire()\\n        printThird()\\n        self._mutex2.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405854,
                "title": "scalable-c-solution-without-mutexes-and-convars",
                "content": "Scalable c++ solution without mutexes and convars. We just wait untill n is equal 1,2,...\\n\\n```\\nclass Foo {\\npublic:\\n    std::atomic<std::size_t> n{0};\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        n.fetch_add(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(n.load() != 1) {\\n            std::this_thread::yield();\\n        }\\n        printSecond();\\n        n.fetch_add(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(n.load() != 2) {\\n            std::this_thread::yield();\\n        }\\n        printThird();\\n    }\\n};",
                "solutionTags": [],
                "code": "Scalable c++ solution without mutexes and convars. We just wait untill n is equal 1,2,...\\n\\n```\\nclass Foo {\\npublic:\\n    std::atomic<std::size_t> n{0};\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        n.fetch_add(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(n.load() != 1) {\\n            std::this_thread::yield();\\n        }\\n        printSecond();\\n        n.fetch_add(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(n.load() != 2) {\\n            std::this_thread::yield();\\n        }\\n        printThird();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1335161,
                "title": "java-java-lang-concurrency-synchronized-without-active-waiting",
                "content": "```\\nclass Foo {\\n    private boolean isFirstDone = false;\\n    private boolean isSecondDone = false;\\n    \\n    private Object firstMonitor = new Object();\\n    private Object secondMonitor = new Object();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            isFirstDone = true;\\n            firstMonitor.notify();\\n            \\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            while (!isFirstDone) {\\n                firstMonitor.wait();\\n            }\\n        }\\n        \\n        synchronized (secondMonitor) {\\n            isSecondDone = true;\\n            secondMonitor.notify();\\n            \\n            printSecond.run();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (secondMonitor) {\\n            while (!isSecondDone) {\\n                secondMonitor.wait();\\n            }\\n        }\\n\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private boolean isFirstDone = false;\\n    private boolean isSecondDone = false;\\n    \\n    private Object firstMonitor = new Object();\\n    private Object secondMonitor = new Object();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            isFirstDone = true;\\n            firstMonitor.notify();\\n            \\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            while (!isFirstDone) {\\n                firstMonitor.wait();\\n            }\\n        }\\n        \\n        synchronized (secondMonitor) {\\n            isSecondDone = true;\\n            secondMonitor.notify();\\n            \\n            printSecond.run();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (secondMonitor) {\\n            while (!isSecondDone) {\\n                secondMonitor.wait();\\n            }\\n        }\\n\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314293,
                "title": "c-solution",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    ManualResetEvent _second = new ManualResetEvent(false);\\n    ManualResetEvent _third = new ManualResetEvent(false);\\n    \\n    public Foo() {\\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _second.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _second.WaitOne();\\n        printSecond();\\n        _third.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _third.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    ManualResetEvent _second = new ManualResetEvent(false);\\n    ManualResetEvent _third = new ManualResetEvent(false);\\n    \\n    public Foo() {\\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _second.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _second.WaitOne();\\n        printSecond();\\n        _third.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _third.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100106,
                "title": "c-linux-semaphores",
                "content": "```\\n#include <semaphore.h>\\n \\nclass Foo {\\npublic:\\n    Foo() {\\n        sem_init(&_first_job_done, 0, 0);\\n        sem_init(&_second_job_done, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&_first_job_done);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&_first_job_done);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&_second_job_done);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&_second_job_done);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    sem_t _first_job_done{0};\\n    sem_t _second_job_done{0};\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <semaphore.h>\\n \\nclass Foo {\\npublic:\\n    Foo() {\\n        sem_init(&_first_job_done, 0, 0);\\n        sem_init(&_second_job_done, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&_first_job_done);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&_first_job_done);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&_second_job_done);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&_second_job_done);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    sem_t _first_job_done{0};\\n    sem_t _second_job_done{0};\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1078156,
                "title": "c-solution-with-condition-variable-and-mutex",
                "content": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    condition_variable produce2, produce3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    \\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<std::mutex> lck(mtx);\\n        printFirst();\\n        second_unlocked = true;\\n        produce2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce2.wait(lck, [this] {return second_unlocked;});\\n        printSecond();\\n        third_unlocked = true;\\n        produce3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce3.wait(lck, [this] {return third_unlocked;});\\n        printThird();\\n        lck.unlock();\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    condition_variable produce2, produce3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    \\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<std::mutex> lck(mtx);\\n        printFirst();\\n        second_unlocked = true;\\n        produce2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce2.wait(lck, [this] {return second_unlocked;});\\n        printSecond();\\n        third_unlocked = true;\\n        produce3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce3.wait(lck, [this] {return third_unlocked;});\\n        printThird();\\n        lck.unlock();\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1066739,
                "title": "java-just-volatile",
                "content": "```\\nclass Foo {\\n    \\n    private volatile int i = 0;\\n\\n    public Foo() {   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        i = 1;\\n        Thread.yield();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(i!=1){\\n            Thread.yield();\\n        }\\n        printSecond.run();\\n        i = 2;\\n        Thread.yield();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(i!=2){\\n            Thread.yield();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private volatile int i = 0;\\n\\n    public Foo() {   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        i = 1;\\n        Thread.yield();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(i!=1){\\n            Thread.yield();\\n        }\\n        printSecond.run();\\n        i = 2;\\n        Thread.yield();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(i!=2){\\n            Thread.yield();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020495,
                "title": "java-leverage-countdownlatch",
                "content": "```java\\nclass Foo {\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n    private CountDownLatch latch3 = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch3.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n    private CountDownLatch latch3 = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch3.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009752,
                "title": "c-monitor-wait-pulseall",
                "content": "```\\nusing System.Threading; \\n\\npublic class Foo\\n    {\\n        class Lock\\n        {\\n           public int Step;\\n        }\\n\\n        static Lock _Lock = new Lock(){ Step = 0 };\\n\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            lock (_Lock)\\n            {\\n                // printFirst() outputs \"first\". Do not change or remove this line.\\n                printFirst();\\n                _Lock.Step = 1;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            lock (_Lock)\\n            {\\n                while (_Lock.Step!= 1)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printSecond() outputs \"second\". Do not change or remove this line.\\n                printSecond();\\n                _Lock.Step = 2;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            lock (_Lock)\\n            {\\n                while(_Lock.Step!=2)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printThird() outputs \"third\". Do not change or remove this line.                \\n                printThird();\\n                _Lock.Step = 3;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading; \\n\\npublic class Foo\\n    {\\n        class Lock\\n        {\\n           public int Step;\\n        }\\n\\n        static Lock _Lock = new Lock(){ Step = 0 };\\n\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            lock (_Lock)\\n            {\\n                // printFirst() outputs \"first\". Do not change or remove this line.\\n                printFirst();\\n                _Lock.Step = 1;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            lock (_Lock)\\n            {\\n                while (_Lock.Step!= 1)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printSecond() outputs \"second\". Do not change or remove this line.\\n                printSecond();\\n                _Lock.Step = 2;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            lock (_Lock)\\n            {\\n                while(_Lock.Step!=2)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printThird() outputs \"third\". Do not change or remove this line.                \\n                printThird();\\n                _Lock.Step = 3;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006405,
                "title": "faster-then-100-java-countdownlatch",
                "content": "```\\nclass Foo {\\n    \\n    private final CountDownLatch first;\\n    private final CountDownLatch second;\\n\\n    public Foo() {\\n        first = new CountDownLatch(1);\\n        second = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private final CountDownLatch first;\\n    private final CountDownLatch second;\\n\\n    public Foo() {\\n        first = new CountDownLatch(1);\\n        second = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968990,
                "title": "c-1-mutex-1-condition-variable-simple-solution",
                "content": "Just check if the counter is equal to itself, if not then release lock and wait.\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        now = 0;        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 0;\\n            });\\n            ++now;\\n            printFirst();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 1;\\n            });\\n            ++now;\\n            printSecond();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 2;\\n            });\\n            ++now;\\n            printThird();\\n        }\\n        cv.notify_all();\\n    }\\n    condition_variable cv;\\n    mutex mtx;\\n    int now;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        now = 0;        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 0;\\n            });\\n            ++now;\\n            printFirst();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 1;\\n            });\\n            ++now;\\n            printSecond();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 2;\\n            });\\n            ++now;\\n            printThird();\\n        }\\n        cv.notify_all();\\n    }\\n    condition_variable cv;\\n    mutex mtx;\\n    int now;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960489,
                "title": "c-using-semaphore",
                "content": "```\\n\\n    private static Semaphore _First = new Semaphore(0,1);\\n    private static Semaphore _Second = new Semaphore(0,1);\\n    \\n    public void First(Action printFirst) {\\n        printFirst();\\n        _First.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _First.WaitOne();\\n        printSecond();\\n        _Second.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _Second.WaitOne();\\n        printThird();\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    private static Semaphore _First = new Semaphore(0,1);\\n    private static Semaphore _Second = new Semaphore(0,1);\\n    \\n    public void First(Action printFirst) {\\n        printFirst();\\n        _First.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _First.WaitOne();\\n        printSecond();\\n        _Second.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _Second.WaitOne();\\n        printThird();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 943530,
                "title": "simple-and-does-the-work-for-beginners",
                "content": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.call = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.   \\n        printFirst()\\n        self.call = 1\\n        \\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.call != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.call = 2\\n            \\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.call != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.call = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.   \\n        printFirst()\\n        self.call = 1\\n        \\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.call != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.call = 2\\n            \\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.call != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 899019,
                "title": "java-3-semaphore-solution",
                "content": "```java\\nclass Foo {\\n    \\n    private Semaphore s1 = new Semaphore(1);\\n    private Semaphore s2 = new Semaphore(0);\\n    private Semaphore s3 = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        s1.acquire();\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        s3.acquire();\\n        printThird.run();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    \\n    private Semaphore s1 = new Semaphore(1);\\n    private Semaphore s2 = new Semaphore(0);\\n    private Semaphore s3 = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        s1.acquire();\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        s3.acquire();\\n        printThird.run();\\n        \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 808148,
                "title": "java-solution-using-atomic-integer",
                "content": "```\\nclass Foo {\\n\\n    private AtomicInteger firstJobDone = new AtomicInteger(0);\\n    private AtomicInteger secondJobDone = new AtomicInteger(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstJobDone.incrementAndGet();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(firstJobDone.get()!=1){}\\n        printSecond.run();\\n        secondJobDone.incrementAndGet();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(secondJobDone.get() != 1){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private AtomicInteger firstJobDone = new AtomicInteger(0);\\n    private AtomicInteger secondJobDone = new AtomicInteger(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstJobDone.incrementAndGet();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(firstJobDone.get()!=1){}\\n        printSecond.run();\\n        secondJobDone.incrementAndGet();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(secondJobDone.get() != 1){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798189,
                "title": "python3-fastest-and-simplest-solution",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.firstlock = threading.Lock()\\n        self.secondlock = threading.Lock()\\n        self.thirdlock = threading.Lock()\\n        \\n        self.firstlock.acquire()\\n        self.secondlock.acquire()\\n        self.thirdlock.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.firstlock.release()\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.secondlock.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.secondlock.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.thirdlock.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.thirdlock.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.thirdlock.release()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.firstlock = threading.Lock()\\n        self.secondlock = threading.Lock()\\n        self.thirdlock = threading.Lock()\\n        \\n        self.firstlock.acquire()\\n        self.secondlock.acquire()\\n        self.thirdlock.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.firstlock.release()\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.secondlock.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.secondlock.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.thirdlock.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.thirdlock.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.thirdlock.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744073,
                "title": "py-soln-using-sleep-simple-and-fast",
                "content": "This simple solution was faster than 95.4% solutiions (32ms runtime)\\n```\\n\\n\\nclass Foo:\\n#flag variables \\n    calledFirst = 0\\n    calledSecond = 0\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        #print and set flag\\n        printFirst()\\n        self.calledFirst = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t#wait for 0.01s and then check for the condition again \\n        while(not self.calledFirst):\\n            time.sleep(0.01)\\n        printSecond()\\n\\t\\t#flag for second function\\n        self.calledSecond = 1\\n      \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n       \\n        while(not self.calledSecond):        \\n            time.sleep(0.01)\\n        printThird()\\n        \\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n\\nclass Foo:\\n#flag variables \\n    calledFirst = 0\\n    calledSecond = 0\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        #print and set flag\\n        printFirst()\\n        self.calledFirst = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t#wait for 0.01s and then check for the condition again \\n        while(not self.calledFirst):\\n            time.sleep(0.01)\\n        printSecond()\\n\\t\\t#flag for second function\\n        self.calledSecond = 1\\n      \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n       \\n        while(not self.calledSecond):        \\n            time.sleep(0.01)\\n        printThird()\\n        \\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 671719,
                "title": "java-locks-conditional",
                "content": "```\\nclass Foo {\\n    \\n    private int currentThreadNum = 1;\\n    private ReentrantLock locker = new ReentrantLock();\\n    private Condition condition = locker.newCondition();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            printFirst.run();\\n            currentThreadNum = 2;\\n            condition.signalAll();\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 2) {\\n                condition.await();\\n            }\\n            printSecond.run();\\n            currentThreadNum = 3;\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 3) {\\n                condition.await();\\n            }\\n            printThird.run();\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private int currentThreadNum = 1;\\n    private ReentrantLock locker = new ReentrantLock();\\n    private Condition condition = locker.newCondition();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            printFirst.run();\\n            currentThreadNum = 2;\\n            condition.signalAll();\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 2) {\\n                condition.await();\\n            }\\n            printSecond.run();\\n            currentThreadNum = 3;\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 3) {\\n                condition.await();\\n            }\\n            printThird.run();\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632100,
                "title": "java-with-countdown-latch",
                "content": "```\\nclass Foo {\\n\\n    private CountDownLatch firstFinished = new CountDownLatch(1);\\n    private CountDownLatch secondFinished = new CountDownLatch(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstFinished.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstFinished.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        secondFinished.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondFinished.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private CountDownLatch firstFinished = new CountDownLatch(1);\\n    private CountDownLatch secondFinished = new CountDownLatch(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstFinished.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstFinished.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        secondFinished.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondFinished.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601183,
                "title": "volatile-counter-java",
                "content": "```\\nclass Foo {\\n    volatile int count ;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        count++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(count!=1) {}\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        count++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(count!=2) {}\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    volatile int count ;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        count++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(count!=1) {}\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        count++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(count!=2) {}\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598546,
                "title": "java-lock-condition",
                "content": "```\\nclass Foo {\\n\\n    private final Lock lock;\\n    private final Condition c2;\\n    private final Condition c3;\\n    private boolean printed1 = false;\\n    private boolean printed2 = false;\\n\\n    public Foo() {\\n        lock = new ReentrantLock();\\n        c2 = lock.newCondition();\\n        c3 = lock.newCondition();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            printed1 = true;\\n            c2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed1) {\\n                c2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            printed2 = true;\\n            c3.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed2) {\\n                c3.await();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private final Lock lock;\\n    private final Condition c2;\\n    private final Condition c3;\\n    private boolean printed1 = false;\\n    private boolean printed2 = false;\\n\\n    public Foo() {\\n        lock = new ReentrantLock();\\n        c2 = lock.newCondition();\\n        c3 = lock.newCondition();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            printed1 = true;\\n            c2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed1) {\\n                c2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            printed2 = true;\\n            c3.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed2) {\\n                c3.await();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561105,
                "title": "java-most-efficient",
                "content": "```\\nclass Foo {\\n\\n    private int x = 0;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        x = x + 1;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while (x < 1) {\\n            wait();\\n        }\\n        printSecond.run();\\n        x = x + 1;                \\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while (x < 2) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private int x = 0;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        x = x + 1;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while (x < 1) {\\n            wait();\\n        }\\n        printSecond.run();\\n        x = x + 1;                \\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while (x < 2) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499799,
                "title": "python-solution-with-driver-code",
                "content": "Here\\'s the solution with driver code, so you can run it on your own machine.\\n```\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.second_lock = threading.Lock()\\n        self.second_lock.acquire()\\n        self.third_lock = threading.Lock()\\n        self.third_lock.acquire()\\n\\n    def first(self):\\n\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        print(\\'first\\')\\n        self.second_lock.release()\\n\\n    def second(self):\\n\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.second_lock:\\n            print(\\'second_lock\\')\\n            self.third_lock.release()\\n\\n    def third(self):\\n\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.third_lock:\\n            print(\\'third_lock\\')\\n\\na = Foo()\\nt1 = threading.Thread(target=a.third)\\nt2 = threading.Thread(target=a.second)\\nt3 = threading.Thread(target=a.first)\\n\\nt1.start()\\nt2.start()\\nt3.start()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.second_lock = threading.Lock()\\n        self.second_lock.acquire()\\n        self.third_lock = threading.Lock()\\n        self.third_lock.acquire()\\n\\n    def first(self):\\n\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        print(\\'first\\')\\n        self.second_lock.release()\\n\\n    def second(self):\\n\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.second_lock:\\n            print(\\'second_lock\\')\\n            self.third_lock.release()\\n\\n    def third(self):\\n\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.third_lock:\\n            print(\\'third_lock\\')\\n\\na = Foo()\\nt1 = threading.Thread(target=a.third)\\nt2 = threading.Thread(target=a.second)\\nt3 = threading.Thread(target=a.first)\\n\\nt1.start()\\nt2.start()\\nt3.start()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493520,
                "title": "non-blocking-solution-9ms",
                "content": "```\\nclass Foo {\\n    private volatile boolean firstCompleted;\\n    private volatile boolean secondCompleted;\\n\\t\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n      printFirst.run();\\n      firstCompleted = true;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n      while (!firstCompleted) {\\n        \\n      }\\n      printSecond.run();\\n      secondCompleted = true;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n      while (!secondCompleted) {\\n\\n      }\\n      printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private volatile boolean firstCompleted;\\n    private volatile boolean secondCompleted;\\n\\t\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n      printFirst.run();\\n      firstCompleted = true;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n      while (!firstCompleted) {\\n        \\n      }\\n      printSecond.run();\\n      secondCompleted = true;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n      while (!secondCompleted) {\\n\\n      }\\n      printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474102,
                "title": "simple-java-solution-using-wait-and-notify",
                "content": "```\\nclass Foo {\\n    \\n\\n    int count = 1;\\n    public Foo() {   \\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            printFirst.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        synchronized(this){\\n            while(count != 2){\\n                this.wait();\\n            }\\n            printSecond.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n\\n        synchronized(this){\\n            while(count != 3){\\n                this.wait();\\n            }\\n            printThird.run();\\n        }\\n   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n\\n    int count = 1;\\n    public Foo() {   \\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            printFirst.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        synchronized(this){\\n            while(count != 2){\\n                this.wait();\\n            }\\n            printSecond.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n\\n        synchronized(this){\\n            while(count != 3){\\n                this.wait();\\n            }\\n            printThird.run();\\n        }\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472228,
                "title": "c-same-pattern-for-all-3-functions-using-condition-variable",
                "content": "Extracted a run_step function that can be called by all three original functions. This can be easily extended to more steps.\\n\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        cur_step = 0;\\n    }\\n    \\n    void run_step(int step, function<void()> func) {\\n        std::unique_lock<std::mutex> lk(mtx);\\n        cv.wait(lk, [&]{return cur_step == step;}); // keep waiting until cur_step == step.\\n        func();\\n        cur_step++; // safely increasing cur_step.\\n        cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        run_step(0, printFirst);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        run_step(1, printSecond);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        run_step(2, printThird);\\n    }\\n\\nprivate:\\n    std::condition_variable cv;\\n    std::mutex mtx;\\n    volatile int cur_step;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        cur_step = 0;\\n    }\\n    \\n    void run_step(int step, function<void()> func) {\\n        std::unique_lock<std::mutex> lk(mtx);\\n        cv.wait(lk, [&]{return cur_step == step;}); // keep waiting until cur_step == step.\\n        func();\\n        cur_step++; // safely increasing cur_step.\\n        cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        run_step(0, printFirst);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        run_step(1, printSecond);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        run_step(2, printThird);\\n    }\\n\\nprivate:\\n    std::condition_variable cv;\\n    std::mutex mtx;\\n    volatile int cur_step;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467281,
                "title": "python-condition-readable-code",
                "content": "```\\nfrom threading import Condition\\nclass FooBar:\\n    def __init__(self, n):\\n        self.n = n\\n        self.condition = Condition()\\n        self.order = 1\\n        self.output_foo = lambda: self.order == 1\\n        self.output_bar = lambda: self.order == 2\\n\\n\\n    def foo(self, printFoo: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_foo)\\n                # printFoo() outputs \"foo\". Do not change or remove this line.\\n                printFoo()\\n                self.order += 1\\n                self.condition.notify()\\n\\n\\n    def bar(self, printBar: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_bar)\\n                # printBar() outputs \"bar\". Do not change or remove this line.\\n                printBar()\\n                self.order -= 1\\n                self.condition.notify()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Condition\\nclass FooBar:\\n    def __init__(self, n):\\n        self.n = n\\n        self.condition = Condition()\\n        self.order = 1\\n        self.output_foo = lambda: self.order == 1\\n        self.output_bar = lambda: self.order == 2\\n\\n\\n    def foo(self, printFoo: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_foo)\\n                # printFoo() outputs \"foo\". Do not change or remove this line.\\n                printFoo()\\n                self.order += 1\\n                self.condition.notify()\\n\\n\\n    def bar(self, printBar: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_bar)\\n                # printBar() outputs \"bar\". Do not change or remove this line.\\n                printBar()\\n                self.order -= 1\\n                self.condition.notify()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459232,
                "title": "java-simple-version-with-two-semaphores",
                "content": "```\\nclass Foo {\\n    \\n    private Semaphore firstSem;\\n    \\n    private Semaphore secondSem;\\n\\n    public Foo() {\\n        this.firstSem = new Semaphore(0);\\n        this.secondSem = new Semaphore(0); \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.firstSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        this.firstSem.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.secondSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        this.secondSem.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private Semaphore firstSem;\\n    \\n    private Semaphore secondSem;\\n\\n    public Foo() {\\n        this.firstSem = new Semaphore(0);\\n        this.secondSem = new Semaphore(0); \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.firstSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        this.firstSem.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.secondSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        this.secondSem.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457292,
                "title": "python-without-mutex-and-semaphore-only-1-counter",
                "content": "All threads are independent! We can create counter, which will show actual threads. It\\'s safe, therefore all threads modified counter only after printing + GIL makes operaion += atomary.\\n\\n```\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        self.counter = 0\\n\\n\\t# first thread will be called automaticly, without any conditions\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        \\n\\t\\t# open way for second thread\\n        self.counter += 1\\n\\n\\n\\t# second thread firstly wait finishing of 1st thread, and after printing text it can incriment counter for 3rd thread\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 1:\\n            sleep(0.01)\\n            \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        \\n        self.counter += 1\\n\\n\\n\\t# 3rd thread wait finish of 2nd, and doesn\\'t incerement counter, therefore it\\'s redundent.\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 2:\\n            sleep(0.01)\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        self.counter = 0\\n\\n\\t# first thread will be called automaticly, without any conditions\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        \\n\\t\\t# open way for second thread\\n        self.counter += 1\\n\\n\\n\\t# second thread firstly wait finishing of 1st thread, and after printing text it can incriment counter for 3rd thread\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 1:\\n            sleep(0.01)\\n            \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        \\n        self.counter += 1\\n\\n\\n\\t# 3rd thread wait finish of 2nd, and doesn\\'t incerement counter, therefore it\\'s redundent.\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 2:\\n            sleep(0.01)\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452975,
                "title": "simple-python-with-two-events",
                "content": "```\\nimport threading\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.second_cv = threading.Event() \\n        self.third_cv = threading.Event()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.second_cv.set()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.second_cv.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.third_cv.set()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.third_cv.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.second_cv = threading.Event() \\n        self.third_cv = threading.Event()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.second_cv.set()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.second_cv.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.third_cv.set()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.third_cv.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452783,
                "title": "2-c-solution-lock-2-mutex-lock-free-sched-yield",
                "content": "***Lock version - 2 mutex lock***\\nmtx1 is the lock indicating **first()** should be exec before **second()**.\\nmtx2 is the lock indicating **second()** should be exec before **third()**.\\n\\nUse **sched_yield()** to release the processor, when **second()** and **third()** does not have the lock.\\n**usleep(0)** would have the same effect, but it would be a little bit slower than **sched_yield()**.\\n```\\nclass Foo {\\n    mutex mtx1, mtx2;\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        mtx1.lock();\\n\\t\\t\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n        mtx1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        mtx2.lock();\\n        \\n        // try until runSecond set to true\\n        mtx1.lock();\\n        while (!runSecond) {\\n            mtx1.unlock();\\n            sched_yield();\\n            mtx1.lock();\\n        }\\n        mtx1.unlock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n        mtx2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        mtx2.lock();\\n        while (!runThird) {\\n            mtx2.unlock();\\n            sched_yield();\\n            mtx2.lock();\\n        }\\n        mtx2.unlock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n***Lock-free version***\\nWithout using lock, I thought it would be faster than previous version at first, but it seems not.\\nI\\'m still wondering why...\\n```\\nclass Foo {\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // try until runSecond set to true\\n        while (!runSecond) {\\n            sched_yield();\\n        }\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        while (!runThird) {\\n            sched_yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    mutex mtx1, mtx2;\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        mtx1.lock();\\n\\t\\t\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n        mtx1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        mtx2.lock();\\n        \\n        // try until runSecond set to true\\n        mtx1.lock();\\n        while (!runSecond) {\\n            mtx1.unlock();\\n            sched_yield();\\n            mtx1.lock();\\n        }\\n        mtx1.unlock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n        mtx2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        mtx2.lock();\\n        while (!runThird) {\\n            mtx2.unlock();\\n            sched_yield();\\n            mtx2.lock();\\n        }\\n        mtx2.unlock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // try until runSecond set to true\\n        while (!runSecond) {\\n            sched_yield();\\n        }\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        while (!runThird) {\\n            sched_yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432171,
                "title": "c-super-simple-solution-with-only-mutex",
                "content": "```\\n#include <mutex>\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        this->mtx_second.lock();\\n        this->mtx_third.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        this->mtx_second.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // std::cout << \"first: waiting...\" << std::endl;\\n        \\n        this->mtx_second.lock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        this->mtx_second.unlock();\\n        this->mtx_third.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        this->mtx_third.lock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        this->mtx_third.unlock();\\n    }\\n    \\nprivate:\\n    std::mutex mtx_second;\\n    std::mutex mtx_third;\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <mutex>\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        this->mtx_second.lock();\\n        this->mtx_third.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        this->mtx_second.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // std::cout << \"first: waiting...\" << std::endl;\\n        \\n        this->mtx_second.lock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        this->mtx_second.unlock();\\n        this->mtx_third.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        this->mtx_third.lock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        this->mtx_third.unlock();\\n    }\\n    \\nprivate:\\n    std::mutex mtx_second;\\n    std::mutex mtx_third;\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 431477,
                "title": "java-using-semaphores-runtime-10-ms-memory-usage-35-6-mb",
                "content": "class Foo {\\n    \\n    private final Semaphore bSem = new Semaphore(1);\\n    private final Semaphore cSem = new Semaphore(1);\\n\\n    public Foo() {\\n        bSem.drainPermits();\\n        cSem.drainPermits();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        bSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        bSem.acquire();\\n        printSecond.run();\\n        cSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        cSem.acquire();\\n        printThird.run();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Foo {\\n    \\n    private final Semaphore bSem = new Semaphore(1);\\n    private final Semaphore cSem = new Semaphore(1);\\n\\n    public Foo() {\\n        bSem.drainPermits();\\n        cSem.drainPermits();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        bSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        bSem.acquire();\\n        printSecond.run();\\n        cSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        cSem.acquire();\\n        printThird.run();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 413239,
                "title": "python-threading-event-implementation",
                "content": "```\\nimport threading\\nclass Foo:\\n    def __init__(self):\\n        self.ev1 = threading.Event()\\n        self.ev2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None: \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.ev1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:      \\n        self.ev1.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.ev2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:      \\n        self.ev2.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\nclass Foo:\\n    def __init__(self):\\n        self.ev1 = threading.Event()\\n        self.ev2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None: \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.ev1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:      \\n        self.ev1.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.ev2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:      \\n        self.ev2.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404181,
                "title": "java-very-simple-and-straight-solution-based-on-semaphore",
                "content": "```\\nclass Foo {\\n\\n    Semaphore s1= new Semaphore(1);\\n    Semaphore s2= new Semaphore(0);\\n    Semaphore s3= new Semaphore(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        s1.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    Semaphore s1= new Semaphore(1);\\n    Semaphore s2= new Semaphore(0);\\n    Semaphore s3= new Semaphore(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        s1.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393279,
                "title": "without-lock-related-function-simple-c-solution",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        a[0] = a[1] = 0;\\n    }\\n    \\n    int a[2];\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a[0] = 1;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(a[0] == 0);\\n        printSecond();\\n        a[1] = 1;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(a[1] == 0);\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        a[0] = a[1] = 0;\\n    }\\n    \\n    int a[2];\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a[0] = 1;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(a[0] == 0);\\n        printSecond();\\n        a[1] = 1;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(a[1] == 0);\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378965,
                "title": "java-solution-using-blockingqueue",
                "content": "- Second always runs after first because blockingQueue1.take() waits for blockingQueue1.add(\"done\");\\n- Third always runs after second using the same machenism with blockingQueue2.\\n\\n\\nimport java.util.concurrent.BlockingQueue;\\nimport java.util.concurrent.LinkedBlockingDeque;\\nclass Foo {\\n\\n    BlockingQueue<String> blockingQueue1 = new LinkedBlockingDeque<>(1);\\n    BlockingQueue<String> blockingQueue2 = new LinkedBlockingDeque<>(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        \\n        printFirst.run();\\n        blockingQueue1.add(\"done\");\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        String done = blockingQueue1.take();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        blockingQueue2.add(\"done\");\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        String done = blockingQueue2.take();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "- Second always runs after first because blockingQueue1.take() waits for blockingQueue1.add(\"done\");\\n- Third always runs after second using the same machenism with blockingQueue2.\\n\\n\\nimport java.util.concurrent.BlockingQueue;\\nimport java.util.concurrent.LinkedBlockingDeque;\\nclass Foo {\\n\\n    BlockingQueue<String> blockingQueue1 = new LinkedBlockingDeque<>(1);\\n    BlockingQueue<String> blockingQueue2 = new LinkedBlockingDeque<>(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        \\n        printFirst.run();\\n        blockingQueue1.add(\"done\");\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        String done = blockingQueue1.take();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        blockingQueue2.add(\"done\");\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        String done = blockingQueue2.take();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        \\n    }\\n}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565694,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565769,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568225,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566312,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569719,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568188,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1703405,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569562,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1806869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565694,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565769,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568225,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566312,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569719,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568188,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1703405,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569562,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1806869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            }
        ]
    }
]