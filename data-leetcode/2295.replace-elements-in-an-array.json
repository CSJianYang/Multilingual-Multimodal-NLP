[
    {
        "title": "Minimum Bit Flips to Convert Number",
        "question_content": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\n\tFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.\n&nbsp;\nExample 1:\n\nInput: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.\nExample 2:\n\nInput: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3.\n\n&nbsp;\nConstraints:\n\n\t0 <= start, goal <= 109",
        "solutions": [
            {
                "id": 1907028,
                "title": "c-1-liner-xor-count-set-bits",
                "content": "To get minimum bit flips we find XOR of two number : which have set bits only at those places where A differs from B. \\nSo, after getting the **xor** `( a ^ b )` , we need to count the number of set bits.\\nWe can do that using **__builtin_popcount(i)**: This function is used to count the number of set bits in an integer.\\n\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```\\nPlease let me know ways to improve my solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911170,
                "title": "one-liners-have-a-look",
                "content": "Number of different bits is the required bits to flip, to make start and goal same.\\nWe can efficiently calculate them using xor operation : \\n\\n**Java one liner :** \\n```\\npublic int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n}\\n```\\n\\n\\n**CPP one liner :**\\n```\\nint minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n}\\n```\\n\\n**Python one liner :**\\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\\n\\n**Javascript one liner :**\\n```\\nvar minBitFlips = function(start, goal) {\\n    return (start^goal).toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\npublic int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n}\\n```\n```\\nint minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n}\\n```\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\n```\\nvar minBitFlips = function(start, goal) {\\n    return (start^goal).toString(2).split(\"0\").join(\"\").length;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1907470,
                "title": "c-2-methods-1-line-solution",
                "content": "## Method-1\\n\\nWe find last bit of both start and goal by two and check if the bit is same or not. Then divide the numbers by 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        while(start>0 or goal>0){\\n            int temp1=start%2;\\n            int temp2=goal%2;\\n            if(temp1!=temp2){\\n                ans++;\\n            }\\n            start/=2;\\n            goal/=2;\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n\\n## Method-2\\n**XOR** start and goal to find the bits that are different\\nUse in-built method **popcount** to count the number of set bits\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        while(start>0 or goal>0){\\n            int temp1=start%2;\\n            int temp2=goal%2;\\n            if(temp1!=temp2){\\n                ans++;\\n            }\\n            start/=2;\\n            goal/=2;\\n        }\\n        return ans;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907264,
                "title": "java-xor-and-counting-bits-beats-100",
                "content": "We need to count the number of corresponding bits of start and goal that are different.\\nxor-ing start and goal will result in a new number with binary representation of 0 where the corresponding bits of start and goal are equal and 1 where the corresponding bits are different.\\n\\nFor example: 10 and 7 \\n10 = 1010\\n  7 = 0111\\n  \\n10 xor 7 =  1101 (3 ones)\\n\\nNext we need to count the number of 1s (different bits)\\nThe quickest way to count the number of 1s in a number is by eliminating the right most 1 each time and count the number of eliminations, this is done by and-ing the number with (number-1)\\nSubtracting a 1 from a number flips all right most bits until the first right most 1 and by and-ing with the number itself we eliminating the all bits until the first tight most 1 (inclusive)\\nex. \\nnumber =1101\\nnumber -1 = 1100\\nnumber and (number -1) = 1100 (we eliminated the right most 1)\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor =start ^ goal;\\n        int count=0;\\n        while(xor>0){\\n            count++;\\n            xor=xor & (xor-1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor =start ^ goal;\\n        int count=0;\\n        while(xor>0){\\n            count++;\\n            xor=xor & (xor-1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775126,
                "title": "python-java-c-solution-without-xor",
                "content": "# Divmod Remainder Approach:\\n#### Time Complexity: O(log(min(s,g))) --> O(log(n)) \\n#### Space Complexity: O(1)\\n\\nWe divide s and q by 2 until either s or g equals zero.\\nDuring this process, if the remainder of either of them **do not** equal eachother, we increment the counter.\\n\\n***This process is similar to converting a decimal number to binary***\\n\\n**Example:** s=10 g=7\\n\\n| iterations | s (binary) | g (binary) | counter | explaination\\n| - | --- | --- | --- | ---- |\\n1|   1010 |0111|+1| The last digit of s and g are ***different***\\n2|    0101 |0011|+0| The last digits are the **same** so we do nothing\\n3|    0010 |0001|+1| The last digit of s and g are ***different***\\n4|    0001 |0000|+1|The last digit of s and g are ***different***\\n\\n```Python []\\nclass Solution:\\n    def minBitFlips(self, s: int, g: int) -> int:\\n        count = 0 \\n        while s or g:\\n            if s%2 != g%2: count+=1\\n            s, g = s//2, g//2\\n        return count\\n```\\n```Java []\\nclass Solution {\\n    public int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```PsudoCode []\\nfunction minBitFlips(integer s, integer g){\\n\\tinitilize counter integer to 0\\n\\tloop until s or g is equal to zero{\\n\\t\\tif the s mod 2 and g mod 2 have the same remainder, increment counter\\n\\t\\tdivide s and g by 2 every pass\\n\\t}\\n\\treturn counter\\n}\\n```\\n\\n# PLEASE UPVOTE IF THIS HELPED YOU :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minBitFlips(self, s: int, g: int) -> int:\\n        count = 0 \\n        while s or g:\\n            if s%2 != g%2: count+=1\\n            s, g = s//2, g//2\\n        return count\\n```\n```Java []\\nclass Solution {\\n    public int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int count = 0;\\n        while(s > 0 || g > 0){\\n            if(s%2 != g%2) count++;\\n            s = s/2;\\n            g = g/2;\\n        }\\n        return count;\\n    }\\n};\\n```\n```PsudoCode []\\nfunction minBitFlips(integer s, integer g){\\n\\tinitilize counter integer to 0\\n\\tloop until s or g is equal to zero{\\n\\t\\tif the s mod 2 and g mod 2 have the same remainder, increment counter\\n\\t\\tdivide s and g by 2 every pass\\n\\t}\\n\\treturn counter\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911547,
                "title": "builtin-popcount-start-goal",
                "content": "**C++**\\n```cpp\\nint minBitFlips(int start, int goal) {\\n    return __builtin_popcount(start ^ goal);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minBitFlips(int start, int goal) {\\n    return __builtin_popcount(start ^ goal);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916182,
                "title": "c-easy-o-n-solution-basic-maths",
                "content": "**Please upvote if you find this solution helpful**\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    //we just check whether binary bit is equal or not \\n    //if it is we do nothing otherwise we flips the bit and increase the count\\n    int minBitFlips(int start, int goal) \\n    {   \\n        int flips=0;\\n\\t\\t\\n\\t\\t//iterate until both numbers get 0\\n        while(start || goal)\\n        {\\n\\t\\t\\t//check whether bits are equal or not, if not we flip the bit\\n            if(start%2 != goal%2)\\n                flips++;\\n            \\n            start /= 2;\\n            goal /= 2;\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we just check whether binary bit is equal or not \\n    //if it is we do nothing otherwise we flips the bit and increase the count\\n    int minBitFlips(int start, int goal) \\n    {   \\n        int flips=0;\\n\\t\\t\\n\\t\\t//iterate until both numbers get 0\\n        while(start || goal)\\n        {\\n\\t\\t\\t//check whether bits are equal or not, if not we flip the bit\\n            if(start%2 != goal%2)\\n                flips++;\\n            \\n            start /= 2;\\n            goal /= 2;\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513711,
                "title": "c-java-javascript-easy-solution-beats-100-bit-manipulation",
                "content": "# Intuition\\n - Question -> Here given Two numbers. If both no. are represented in Binary then how many minimum bits are required to change in one no. so it convert into second no. \\n\\n*example* ->  \\n```\\n  10  =   1   0   (1)   0\\n  7   =   0   1   (1)   1\\n```\\nhere, 3 bits are different in both no.s and need to be change in one of them to covert into another.\\n\\n# Approach \\nHere, we have to identify the different bits so , XOR operator can help us -->\\n```                                     \\n                                         A | B | A XOR B\\n                                         0 | 0 |   0\\n      10   = 1  0  1  0                  0 | 1 |   1                \\n      7    = 0  1  1  1                  1 | 0 |   1   \\n____________________________             1 | 1 |   0\\nxor(10,7)  = 1  1  0  1\\n```\\nNow , We have to just count the Set Bits(1) in result of xor.\\n no.of Set bits = 3. So, There is minimum 3 flips required.\\n# Complexity\\n- Time complexity:\\n\\n   Best case - O(1)\\n   Worst Case - O(n)\\n\\n- Space complexity:\\n \\n   Constant Space - O(1)\\n\\n# Code\\n\\n- C++ Code ->\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int a = (start ^ goal); // this will do xor of given numbers\\n           //now count set bits\\n        int count = 0; \\n        while(a){\\n            if(a&1){\\n                count++;\\n            }\\n        a = a>>1;  // this is right shift operator\\n        }\\n        return count;\\n    }\\n};\\n```\\n- Java Code ->\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int a = (start ^ goal);\\n        int count = 0;\\n        \\n        while(a != 0) {\\n            if((a & 1) == 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\\n- JavaScript code ->\\n```\\nvar minBitFlips = function(start, goal) {\\n    let a = start ^ goal;\\n        let count = 0;\\n        \\n        while (a !== 0) {\\n            if (a & 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n  10  =   1   0   (1)   0\\n  7   =   0   1   (1)   1\\n```\n```                                     \\n                                         A | B | A XOR B\\n                                         0 | 0 |   0\\n      10   = 1  0  1  0                  0 | 1 |   1                \\n      7    = 0  1  1  1                  1 | 0 |   1   \\n____________________________             1 | 1 |   0\\nxor(10,7)  = 1  1  0  1\\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int a = (start ^ goal); // this will do xor of given numbers\\n           //now count set bits\\n        int count = 0; \\n        while(a){\\n            if(a&1){\\n                count++;\\n            }\\n        a = a>>1;  // this is right shift operator\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int a = (start ^ goal);\\n        int count = 0;\\n        \\n        while(a != 0) {\\n            if((a & 1) == 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```\n```\\nvar minBitFlips = function(start, goal) {\\n    let a = start ^ goal;\\n        let count = 0;\\n        \\n        while (a !== 0) {\\n            if (a & 1) {\\n                count++;\\n            }\\n            \\n            a = a >> 1;\\n        }\\n        \\n        return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014986,
                "title": "java-solution-with-explaination",
                "content": "# Intuition\\nWe want to check how many bits need to flipped in the input number to get the output number. So we would need to check the bits which are different in both numbers (No point in counting bits which are same in both) and count them.\\n\\n# Approach\\nE.g. \\n10 = 1010\\n7  = 0111\\nso different bits are, from rightmost bit, 1st, 3rd and 4th. \\nWe know XOR operation between two numbers will give us these different bits.\\n\\n      1010\\n    ^ 0111\\n    ____________   \\n      1101\\nAs we see here, in the output number only bits are set which are different in both numbers. (1 ^ 1) = 0 and (1 ^ 0) = 1\\n\\nNow, we just have to count these set bits and for that we will use  Kernighan\\u2019s algorithm to find the number of set bits in a number. The idea behind the algorithm is that when we subtract one from an integer, all the bits following the rightmost set of bits are inverted, turning 1 to 0 and 0 to 1. The rightmost set bit also gets inverted with the bits right to it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        if(start == goal) return 0;\\n        int xor = start ^ goal;\\n        int counter=0;\\n        while(xor > 0) {\\n            xor = xor & (xor-1);\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        if(start == goal) return 0;\\n        int xor = start ^ goal;\\n        int counter=0;\\n        while(xor > 0) {\\n            xor = xor & (xor-1);\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260588,
                "title": "python-easy-interview-thinking",
                "content": "The given question requires us to count the total number of flips we need to do inorder to make `start -> goal`.\\nEx:  \\n7 - 0111\\n10 - 1010\\nHere, we only flip the bits which are different in both **start** and **goal**, i.e. `01` or `10`. And, what helps us to find if the bits are different? **XOR**. \\nNow, we count these bits (i.e. different bits). And how do we calculate the number of `1\\'s` in a number? `n & (n-1)` technique.\\n\\nSo, the number of flips required is **3**.\\n\\nTherefore, the solution is divided into two parts - identify the distinct bits in both numbers and then, count these bits.\\n\\nSolution:\\n```python\\nclass Solution(object):\\n    def minBitFlips(self, start, goal):\\n        res = start ^ goal\\n        cnt = 0\\n        while res:\\n            res &= res - 1\\n            cnt += 1\\n        return cnt\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution(object):\\n    def minBitFlips(self, start, goal):\\n        res = start ^ goal\\n        cnt = 0\\n        while res:\\n            res &= res - 1\\n            cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907288,
                "title": "python-solution-one-liner",
                "content": "**Just xor so we get 1 at places where bits are different and then count those bits.**\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return (bin(start^goal).count(\"1\"))\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return (bin(start^goal).count(\"1\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907216,
                "title": "c-easy-2-different-ways",
                "content": "We have to count all positions where the i\\'th bit of number **A** and **B** is different , so just iterate from bit 32 to 0 and check.\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int minBitFlips(int start, int goal)\\n        {\\n            int cnt = 0;\\n            for (int i = 32; i >= 0; i--)\\n            {\\n\\t\\t\\t\\tint current = (1LL << i) & start;\\n                int required = (1LL << i) & goal;\\n                if (required != current)\\n                    cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```\\n\\nAfter submitting , I realised that we can get different bit when we will do **XOR** of **A** and **B** \\nlike A = 101111\\nlike B = 110001\\nA^B  =  011110 , so just count how many ones in A^B , to count 1\\'s in a number we have a fucntion called **__builtin_popcount(N)** where N = A^B\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        return __builtin_popcount(A^B);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minBitFlips(int start, int goal)\\n        {\\n            int cnt = 0;\\n            for (int i = 32; i >= 0; i--)\\n            {\\n\\t\\t\\t\\tint current = (1LL << i) & start;\\n                int required = (1LL << i) & goal;\\n                if (required != current)\\n                    cnt++;\\n            }\\n            return cnt;\\n        }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        return __builtin_popcount(A^B);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907471,
                "title": "c-0ms-solution-without-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start && goal){\\n            if(start%2!=goal%2) count++;\\n            start/=2;\\n            goal/=2;\\n        }\\n        while(start){\\n            if(start%2)count++;\\n            start/=2;\\n        }\\n        while(goal){\\n            if(goal%2)count++;\\n            goal/=2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start && goal){\\n            if(start%2!=goal%2) count++;\\n            start/=2;\\n            goal/=2;\\n        }\\n        while(start){\\n            if(start%2)count++;\\n            start/=2;\\n        }\\n        while(goal){\\n            if(goal%2)count++;\\n            goal/=2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526404,
                "title": "beats-100-easiest-code-using-inbuilt-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        string s= bitset<32> (start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++){\\n            if(s[i]!=str[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\nDo UPVOTE\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        string s= bitset<32> (start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++){\\n            if(s[i]!=str[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\nDo UPVOTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232519,
                "title": "curious-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298518,
                "title": "cpp-ez-amazon-google-interview-o-set-bits",
                "content": "# ***UPVOTE PLZ  \\u2763***\\n# **Approach-1** Always takes O(N)\\nclass Solution {                        //O(N) soln.\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0, i=0;\\n        while(start != goal){\\n            int mask=1<<i;\\n            if((start & mask) == (goal & mask))\\n                i++;\\n            else{\\n                start=start ^ mask;\\n                c++;\\n                i++;\\n            }    \\n        }\\n        return c;\\n    }\\n};\\n\\n# **Approach-2**   Faster :)\\nclass Solution {                         // O(No. of set bits in start^goal)\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int res = start ^ goal;\\n        int c=0;\\n        while(res!=0){\\n            res = res & (res-1);\\n            c++;\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {                        //O(N) soln.\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0, i=0;\\n        while(start != goal){\\n            int mask=1<<i;\\n            if((start & mask) == (goal & mask))\\n                i++;\\n            else{\\n                start=start ^ mask;\\n                c++;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1910049,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_bit_flips(start: i32, goal: i32) -> i32 {\\n        (start ^ goal).count_ones() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_bit_flips(start: i32, goal: i32) -> i32 {\\n        (start ^ goal).count_ones() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907429,
                "title": "c-easy-and-operation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int res(0);\\n        for (int i=32; ~i; i--) {\\n            if ((start & 1) != (goal & 1))  res++;\\n            start >>= 1; goal >>= 1;\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        int res(0);\\n        for (int i=32; ~i; i--) {\\n            if ((start & 1) != (goal & 1))  res++;\\n            start >>= 1; goal >>= 1;\\n        }\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906980,
                "title": "easy-approach-o-n-time-no-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans = 0;\\n        while(start && goal) { \\n            if(start%2 != goal%2)\\n                ans++;\\n            start /= 2;\\n            goal /= 2;\\n        } \\n        while(start) { \\n            if(start%2)\\n                ans++;\\n            start /= 2;\\n        } \\n        while(goal) { \\n            if(goal%2)\\n                ans++;   \\n            goal /= 2;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int ans = 0;\\n        while(start && goal) { \\n            if(start%2 != goal%2)\\n                ans++;\\n            start /= 2;\\n            goal /= 2;\\n        } \\n        while(start) { \\n            if(start%2)\\n                ans++;\\n            start /= 2;\\n        } \\n        while(goal) { \\n            if(goal%2)\\n                ans++;   \\n            goal /= 2;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608176,
                "title": "0ms-solution-bit-manipulation",
                "content": "# Intuition\\nJust try to make the $start$ equals to $goal$ using $Bit Manipulations$.\\n\\n# Approach\\nIf the $goal$ bit is **set**, check if the $start$ bit is **set**, if not increase the count, as we will use one $flip$ operation.\\n\\nIf the $goal$ bit is **unset**, check if the $start$ bit is **unset**, if not increase the count, as we will use one $flip$ operation \\n\\n# Complexity\\n- Time complexity: $$O(log(max(start, goal)))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(goal || start)\\n        {\\n            bool goalBit = (goal&1);\\n            bool startBit = (start&1);\\n            if(goalBit)\\n            {\\n                if(startBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(startBit)\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    // Do Nothing\\n                }\\n            }\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# Follow up Question:\\nhttps://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/\\n**My Solution:** https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607616/0ms-solution-bit-manipulation/",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(goal || start)\\n        {\\n            bool goalBit = (goal&1);\\n            bool startBit = (start&1);\\n            if(goalBit)\\n            {\\n                if(startBit)\\n                {\\n                    // Do Nothing\\n                }\\n                else\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else\\n            {\\n                if(startBit)\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    // Do Nothing\\n                }\\n            }\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471702,
                "title": "kernighan-s-algorithm-easy-to-understand-with-explaination",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        \\n        // # Here we get he number if set bits which are required for getting our goal number\\n        int set=start^goal;\\n        \\n        // # kernighan\\'s algo for finding no of set bits\\n        while(set!=0){\\n            \\n            // # a mask in which only right most bit is set\\n            int rsb=(set&(-set));\\n            set=set-rsb;\\n            cnt++;\\n        }\\n         return cnt;\\n     }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        \\n        // # Here we get he number if set bits which are required for getting our goal number\\n        int set=start^goal;\\n        \\n        // # kernighan\\'s algo for finding no of set bits\\n        while(set!=0){\\n            \\n            // # a mask in which only right most bit is set\\n            int rsb=(set&(-set));\\n            set=set-rsb;\\n            cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3222968,
                "title": "easy-and-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly On Reading The Problem, We have to find How Many Bits \\nAre Different in **start** And **goal**.\\n\\nfor finding How many different bits,we use X-OR Gate .(0^1=1 and 1^0=1)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**_step1_** : find x-or of start and goal\\n**_step2_** : now find no.of set bits (i.e., no.of 1s) in xOredResult.\\n             (this is becuase \\'1\\' in xOredResult denotes the bits          are         different,so we have to flip them) \\n**_step3_** : the no.of set bits gives the no.of bits to flip actually\\n\\n(Read $$Brian-Kerninghan algorithm$$ to count no.of set bits in a particular number) \\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ where \\'n\\' is the number whose set bits need to     be calculated\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n**Please upvote my solution if you really liked it**\\n\\n# Code\\n```\\nclass Solution {\\n    private int count = 0;\\n    public int minBitFlips(int start, int goal) {\\n\\n        // Find X-OR of start and goal to know no.of different bits\\n        int xOredResult = (start^goal);\\n\\n        // now Count no.of SetBits in xOredResult\\n        // using Brian-Kerninghan Algorithm\\n        return brianKerninghanAlgo(xOredResult);\\n    }\\n    public  int brianKerninghanAlgo(int num)\\n    {\\n        while(num != 0)\\n        {\\n            num&=(num-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    private int count = 0;\\n    public int minBitFlips(int start, int goal) {\\n\\n        // Find X-OR of start and goal to know no.of different bits\\n        int xOredResult = (start^goal);\\n\\n        // now Count no.of SetBits in xOredResult\\n        // using Brian-Kerninghan Algorithm\\n        return brianKerninghanAlgo(xOredResult);\\n    }\\n    public  int brianKerninghanAlgo(int num)\\n    {\\n        while(num != 0)\\n        {\\n            num&=(num-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527196,
                "title": "java-easy-solution-using-kernighan-s-algorithm",
                "content": "First we find xor of the two input numbers and count the number of set bits in the result using kernighan\\'s algorithm\\n\\nhere result=start^goal\\n\\nkernighan\\'s algorithm-\\n\\nIn a loop till the result > 0\\nStep 1 increase the count by 1\\nStep 2 result=result xor (result - 1)\\n\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n=start^goal,c=0;\\n        while(n>0)\\n        {\\n            n&=(n-1);\\n            c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n=start^goal,c=0;\\n        while(n>0)\\n        {\\n            n&=(n-1);\\n            c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379732,
                "title": "one-liner-python",
                "content": "\\n```\\nreturn(start^goal).bit_count()\\n```\\n**Please upvote if you want to see more one liners and simple solutions**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn(start^goal).bit_count()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153745,
                "title": "c-solution-well-explained-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n     // Function to count the set bits\\n    int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        \\n        return countSetBits(start ^ goal); // start ^ goal : gives the differenciating bits\\n        \\n    }\\n};\\n```\\n\\n**Liked it ? Do upvote it, it do motivates !**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     // Function to count the set bits\\n    int countSetBits(int n)\\n    {\\n        int count = 0;\\n        while(n > 0){\\n            n &= (n-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        \\n        return countSetBits(start ^ goal); // start ^ goal : gives the differenciating bits\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984124,
                "title": "python-solution-hamming-distance-based-one-liner",
                "content": "## Hamming Distance\\nHamming Distance between two integers is the number of bits that are different at the same position in both numbers. \\n\\nAlgorithm\\n- XOR the numbers\\n- Count set bits (1)\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\"1\")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\"1\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935603,
                "title": "c-simple-xor-operation-100-faster",
                "content": "```\\n//let start = 1101\\n//goal      = 1000\\n// Xor      = 0101\\n//NUmber of set bits in Xor\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int xorr = start xor goal;\\n        unsigned int ans=0;\\n        //Count number of bits to be flipped\\n        while(xorr)\\n        {\\n           ans++;\\n           xorr = xorr&(xorr-1);// Brian Kernighan\\'s Algorithm to count set bit;\\n        }\\n        return ans;\\n    }\\n};\\n//Please Do Upvote \\n//If you find Anything Incorrect or have doubt drop it down;",
                "solutionTags": [
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int xorr = start xor goal;\\n        unsigned int ans=0;\\n        //Count number of bits to be flipped\\n        while(xorr)\\n        {\\n           ans++;\\n           xorr = xorr&(xorr-1);// Brian Kernighan\\'s Algorithm to count set bit;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1909597,
                "title": "bits-manipulation-xor",
                "content": "```\\nclass Solution {\\n\\tpublic static int minBitFlips(int a1, int a2) {\\n\\t\\tint n = (a1 ^ a2);\\n\\t\\tint res = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tres++;\\n\\t\\t\\tn &= (n - 1);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int minBitFlips(int a1, int a2) {\\n\\t\\tint n = (a1 ^ a2);\\n\\t\\tint res = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tres++;\\n\\t\\t\\tn &= (n - 1);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907384,
                "title": "c-xor-builtinpop-count",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\nXOR sets the bits that are different between `start` and `goal`, and unsets bits that are the same.\\n\\n`__builtin_popcount(mask)` counts the `1`s in `mask`.\\n\\nExample:\\n\\nExpression | Value\\n---|--\\nstart|      `0011010`\\ngoal|       `0101100`\\nstart^goal| `0110110`\\n__builtin_popcount(start^goal) | 4\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907134,
                "title": "bitwise-easiest-logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n\\n#### **LOGIC**\\n* This is simpliy asking about [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance)\\n* Take [XOR](https://en.wikipedia.org/wiki/Exclusive_or), because it will set bit to 1 only when both bits are different\\n* Then simply count the bits\\n\\n\\n#### **Code**  \\n```cpp\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a = start ^ goal;\\n        int sol = 0;\\n        \\n        while (a > 0) {\\n            sol += a & 1;\\n            a >>= 1;\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  **O(floor(log10(n) + 1))**, where is ```n``` is ```max(start, goal)```.\\n\\n##### Space Complexity: **O(1)**\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a = start ^ goal;\\n        int sol = 0;\\n        \\n        while (a > 0) {\\n            sol += a & 1;\\n            a >>= 1;\\n        }\\n        \\n        return sol;\\n    }\\n};\\n```\n```n```\n```max(start, goal)```",
                "codeTag": "Java"
            },
            {
                "id": 3821164,
                "title": "2220-java-bit-manipulation-100-efficient",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask=(1<<i);\\n            if(((start & mask)==0 && (goal & mask)!=0) || ((start & mask)!=0 && (goal & mask)==0))\\n                count++;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int mask=(1<<i);\\n            if(((start & mask)==0 && (goal & mask)!=0) || ((start & mask)!=0 && (goal & mask)==0))\\n                count++;\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613891,
                "title": "java-bit-manipulation-beats-100-kernighan-s-algorithm-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing XOR operator the bits that are different will become 1 and same bits will become 0 . After that we just need to count the number of 1\\'s using the Kernighan\\'s Algorithm.\\n\\n# Approach\\n\\nFirst we store the XOR operator result in n and then we initialize a counter with 0 . Now we loop until the n!=0 and inside the loop we are initializing rsbm (right most set bit mask ) for the n. And after that we subtract the rightmost set bit from n using n -= rsbm. This clears the rightmost set bit from n. The counter variable is incremented by 1. At last we return counter .\\n\\n# Complexity\\n- Time complexity:\\n    O(Log(n))\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n = start^goal;\\n        int counter = 0;\\n       \\n        while(n!=0){\\n            int rsbm = n & -n;\\n            n -= rsbm;\\n            counter++;\\n        }\\n\\n        return counter;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int n = start^goal;\\n        int counter = 0;\\n       \\n        while(n!=0){\\n            int rsbm = n & -n;\\n            n -= rsbm;\\n            counter++;\\n        }\\n\\n        return counter;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193970,
                "title": "c-easy-100-acceptance",
                "content": "<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int s,g,cnt=0;\\n        while(start!=goal){\\n            s=start&1;\\n            g=goal&1;\\n            if(s!=g)\\n                cnt++;\\n                start=start>>1;\\n                goal=goal>>1;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int s,g,cnt=0;\\n        while(start!=goal){\\n            s=start&1;\\n            g=goal&1;\\n            if(s!=g)\\n                cnt++;\\n                start=start>>1;\\n                goal=goal>>1;\\n        }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896646,
                "title": "c-simple-solution-with-explanation",
                "content": "**Please upvote if my solution was helpful ;)**\\n# Explanation\\nExample: start = 10, goal = 7, in binary representation are 1010 and 0111 respectively\\n\\n![dsadasdasd.png](https://assets.leetcode.com/users/images/d3e73bbc-7534-452f-8f32-999d0fc8f029_1670664733.3221765.png)\\n\\n\\n1101 is a result of XOR operation - result = start^goal. Answer is a count of \"1\" bits in result.\\n\\n# Algorithm\\n1) Initialize \"result\" as a start^goal (xor operation)\\n2) Count \"1\" bits in result and return it\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        int result = start^goal;\\n        int output = 0;\\n        while(result > 0)\\n        {\\n            if((result & 1) == 1) output++;\\n            result = result>>1;\\n        }\\n        return output;\\n    }\\n}\\n```\\n# Code 2(memory optimization)\\n\\nIn the code below we are using method parameters start and goal as a local variables \\n\\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        start = start^goal;\\n        goal = 0;\\n        while(start > 0)\\n        {\\n            if((start & 1) == 1) goal++;\\n            start = start>>1;\\n        }\\n        return goal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        int result = start^goal;\\n        int output = 0;\\n        while(result > 0)\\n        {\\n            if((result & 1) == 1) output++;\\n            result = result>>1;\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int MinBitFlips(int start, int goal)\\n    {\\n        start = start^goal;\\n        goal = 0;\\n        while(start > 0)\\n        {\\n            if((start & 1) == 1) goal++;\\n            start = start>>1;\\n        }\\n        return goal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846834,
                "title": "easiest-solution-c-plus-plus-one-pass-100-ac-bitset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string str = bitset<32>(start).to_string();\\n        string str2 = bitset<32>(goal).to_string();\\n        int count = 0;\\n        for(int i=0;i<32;i++) if(str[i]!=str2[i]) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string str = bitset<32>(start).to_string();\\n        string str2 = bitset<32>(goal).to_string();\\n        int count = 0;\\n        for(int i=0;i<32;i++) if(str[i]!=str2[i]) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742496,
                "title": "xor-1-line-code",
                "content": "\\'\\'\\'\\nclass Solution \\n{\\n public:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\n public:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2689315,
                "title": "100-faster-javascript",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(n, p) {\\n    let count = 0;\\nwhile (p != 0 || n!=0)\\n{\\n    let d = p & 1;\\n    let f = n & 1;\\n    if(d!=f)\\n    {\\n        count++;\\n    }\\n    n=n >> 1;\\n    p = p >> 1;\\n}\\n       return count; \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(n, p) {\\n    let count = 0;\\nwhile (p != 0 || n!=0)\\n{\\n    let d = p & 1;\\n    let f = n & 1;\\n    if(d!=f)\\n    {\\n        count++;\\n    }\\n    n=n >> 1;\\n    p = p >> 1;\\n}\\n       return count; \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658238,
                "title": "most-efficient-c-solution-using-bitset-o-32-constant-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32> bs1(start);\\n        bitset<32> bs2(goal);\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            if(bs1[i]!=bs2[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32> bs1(start);\\n        bitset<32> bs2(goal);\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            if(bs1[i]!=bs2[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614337,
                "title": "xor-python",
                "content": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        n = start ^ goal \\n        count = 0\\n\\n        #counting set bits\\n        while n:\\n            n = n & (n-1) \\n            count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        n = start ^ goal \\n        count = 0\\n\\n        #counting set bits\\n        while n:\\n            n = n & (n-1) \\n            count += 1\\n\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2595426,
                "title": "java-bit-manipulation-1-line-code-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548154,
                "title": "3ms-space-95-beats-c-simple-easy-bit-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int &start, int &goal) {\\n        int ans = 0;\\n        start = start ^ goal;\\n        while(start){\\n            ans += (start&1);\\n            start = start >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int &start, int &goal) {\\n        int ans = 0;\\n        start = start ^ goal;\\n        while(start){\\n            ans += (start&1);\\n            start = start >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421145,
                "title": "minimum-bit-flips-to-convert-number",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        return __builtin_popcount(x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        return __builtin_popcount(x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053637,
                "title": "java-solution",
                "content": "```java class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int c=0;\\n       while(start!=0||goal!=0)\\n       {\\n           if(start%2!=goal%2)\\n               c++;\\n           start/=2;\\n           goal/=2;\\n       }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int c=0;\\n       while(start!=0||goal!=0)\\n       {\\n           if(start%2!=goal%2)\\n               c++;\\n           start/=2;\\n           goal/=2;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1910645,
                "title": "here-is-my-solution-using-bitset-c-easy-to-understand",
                "content": "Using ```std::bitset``` Class to Convert Decimal Number to Binary in C++\\n\\n```\\nint minBitFlips(int start, int goal) {  // start=10 , goal=7 \\n\\t\\t\\n\\t\\t// binary representation of 10 is 1010\\n\\t\\t// binary representation of 7 is 0111\\n\\t\\tbitset<32> bs1(start);    // bs1 = 00000000000000000000000000001010 \\n\\t\\tbitset<32> bs2(goal);     // bs2 = 00000000000000000000000000000111\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tif(bs1[i]!=bs2[i]){  \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}    \\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n}\\n```\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```std::bitset```\n```\\nint minBitFlips(int start, int goal) {  // start=10 , goal=7 \\n\\t\\t\\n\\t\\t// binary representation of 10 is 1010\\n\\t\\t// binary representation of 7 is 0111\\n\\t\\tbitset<32> bs1(start);    // bs1 = 00000000000000000000000000001010 \\n\\t\\tbitset<32> bs2(goal);     // bs2 = 00000000000000000000000000000111\\n\\t\\t\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0; i<32; i++){\\n\\t\\t\\tif(bs1[i]!=bs2[i]){  \\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}    \\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909725,
                "title": "xor-bit-counting",
                "content": "**C++:**\\n**Brian Kernighan\\u2019s algorithm to count set bits:**\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\tint out{};\\n\\tfor(n^=m; n; n=n&(n-1), out++);\\n\\treturn out;\\n}\\n```\\nor\\n**builtins:**\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn __builtin_popcount(n^m);            \\n}\\n```\\nsince `c++20` it would be possible to do this:\\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn popcount(n^m);            \\n}\\n```\\n**Python3:**\\n```\\ndef minBitFlips(self, n, m):\\n\\treturn (n^m).bit_count()\\n```\\nor\\n**Python:**\\n```\\ndef minBitFlips(self, n, m):\\n\\treturn bin(n^m).count(\\'1\\')\\n```\\n**JS:**\\n```\\nvar minBitFlips = (n, m) => (n^m).toString(2).replace(/0/g,\"\").length;\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint minBitFlips(int n, int m)\\n{\\n\\tint out{};\\n\\tfor(n^=m; n; n=n&(n-1), out++);\\n\\treturn out;\\n}\\n```\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn __builtin_popcount(n^m);            \\n}\\n```\n```\\nint minBitFlips(int n, int m)\\n{\\n\\treturn popcount(n^m);            \\n}\\n```\n```\\ndef minBitFlips(self, n, m):\\n\\treturn (n^m).bit_count()\\n```\n```\\ndef minBitFlips(self, n, m):\\n\\treturn bin(n^m).count(\\'1\\')\\n```\n```\\nvar minBitFlips = (n, m) => (n^m).toString(2).replace(/0/g,\"\").length;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1909245,
                "title": "python-without-built-in-function-and-bit-manipulation",
                "content": "* convert integer to binary\\n* padding \\'0\\' for shorter binary\\n* compare every bits and count not matched cases\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:       \\n        s = bin(start)[2:]\\n        g = bin(goal)[2:]\\n        \\n        if len(s) > len(g):\\n            g = (len(s) - len(g)) * \\'0\\' + g\\n        elif len(g) > len(s):\\n            s = (len(g) - len(s)) * \\'0\\' + s\\n        \\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if s[i] != g[i]:\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:       \\n        s = bin(start)[2:]\\n        g = bin(goal)[2:]\\n        \\n        if len(s) > len(g):\\n            g = (len(s) - len(g)) * \\'0\\' + g\\n        elif len(g) > len(s):\\n            s = (len(g) - len(s)) * \\'0\\' + s\\n        \\n        res = 0\\n        \\n        for i in range(len(s)):\\n            if s[i] != g[i]:\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907560,
                "title": "python-readable-long",
                "content": "when you dont know rjust , lol. At least i solved it myself\\n\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        binstart = bin(start)[2:]\\n        bingoal = bin(goal)[2:]\\n        \\n        count= 0\\n        \\n        mini = min(len(binstart), len(bingoal))\\n        \\n        if len(binstart) < len(bingoal):\\n            diff = abs(len(bingoal) - len(binstart))\\n            binstart = diff * \\'0\\' + binstart\\n        else:\\n            diff = abs(len(bingoal) - len(binstart))\\n            bingoal = diff * \\'0\\' + bingoal\\n            \\n            \\n        binstart = list(binstart)\\n        bingoal = list(bingoal)\\n        for i in range(len(binstart)-1,-1,-1):\\n            \\n            if binstart[i] != bingoal[i]:\\n                binstart[i] = str(int(binstart[i]) ^ int(bingoal[i]))\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        binstart = bin(start)[2:]\\n        bingoal = bin(goal)[2:]\\n        \\n        count= 0\\n        \\n        mini = min(len(binstart), len(bingoal))\\n        \\n        if len(binstart) < len(bingoal):\\n            diff = abs(len(bingoal) - len(binstart))\\n            binstart = diff * \\'0\\' + binstart\\n        else:\\n            diff = abs(len(bingoal) - len(binstart))\\n            bingoal = diff * \\'0\\' + bingoal\\n            \\n            \\n        binstart = list(binstart)\\n        bingoal = list(bingoal)\\n        for i in range(len(binstart)-1,-1,-1):\\n            \\n            if binstart[i] != bingoal[i]:\\n                binstart[i] = str(int(binstart[i]) ^ int(bingoal[i]))\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907201,
                "title": "very-easy-solution",
                "content": "class Solution {\\npublic:\\n    \\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }\\n    return count;\\n}\\n \\n\\n\\n    int minBitFlips(int start, int goal) {\\n            return countSetBits(start^goal);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1907079,
                "title": "using-xor-operation-4-lines-of-code-only-cpp-solution-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32>str = start; //Converting into bits\\n \\xA0 \\xA0 \\xA0 \\xA0bitset<32>end= goal; \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 bitset<32>res = str^end; // Applying XOR operation\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return res.count(); // returning the number of flips\\n\\n    }\\n};\\n```\\n**Please upvote if you find this helpful**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        bitset<32>str = start; //Converting into bits\\n \\xA0 \\xA0 \\xA0 \\xA0bitset<32>end= goal; \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 bitset<32>res = str^end; // Applying XOR operation\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return res.count(); // returning the number of flips\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907070,
                "title": "javascript-easy-solution-xor",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let orVal = start ^ goal;\\n    \\n    let cnt = 0;\\n    while (orVal > 0) {\\n        cnt++;\\n        orVal &= (orVal-1);\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let orVal = start ^ goal;\\n    \\n    let cnt = 0;\\n    while (orVal > 0) {\\n        cnt++;\\n        orVal &= (orVal-1);\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907055,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int a)\\n    {\\n    int count = 0;\\n    while (a > 0)\\n    {\\n        count++;\\n        a &= (n-1);\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        return c(start^goal);\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int a)\\n    {\\n    int count = 0;\\n    while (a > 0)\\n    {\\n        count++;\\n        a &= (n-1);\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        return c(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906973,
                "title": "java-one-line-with-math",
                "content": "Count diff of binary string, xor is for the work\\n\\n```\\n^ 0 1 \\n0 0 1\\n1 1 0\\n```\\n\\nTime: O(1)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public int minBitFlips(int start, int goal) {\\n    return Integer.bitCount(start ^ goal);\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n^ 0 1 \\n0 0 1\\n1 1 0\\n```\n```\\nclass Solution {\\n  public int minBitFlips(int start, int goal) {\\n    return Integer.bitCount(start ^ goal);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063019,
                "title": "1-line-solution-beats-100-0-ms",
                "content": "# Intuition\\nThe problem is asking to find the minimum number of bit flips required to convert one integer to another. The intuition here is that the bits that need to be flipped are exactly the ones that differ in the two numbers. \\n\\n# Approach\\nThe approach to solve this problem is as follows:\\n1. Compute the XOR of the two numbers. The XOR operation will give a binary number where each bit is 1 if the corresponding bits in the two numbers are different, and 0 if they are the same.\\n2. Count the number of set bits (bits that are 1) in the result. This can be done using the `__builtin_popcount` function in C++. Each set bit represents a position where the two numbers differ, so flipping this bit in one number will make it match the corresponding bit in the other number.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe time complexity is constant because XOR and bit count operations take constant time for integers.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity is also constant because only a fixed amount of space is needed to store the input numbers and intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923042,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(start != goal){\\n            if((goal & 1) != (start & 1)){\\n                start ^= 1;\\n                cnt++;\\n            }\\n            goal >>= 1;\\n           start >>= 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(start != goal){\\n            if((goal & 1) != (start & 1)){\\n                start ^= 1;\\n                cnt++;\\n            }\\n            goal >>= 1;\\n           start >>= 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810023,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know that xor only returns 1 when both theb numbers have a differnce in their respective digits. Therefore we will simply XOR both the numbers and later count the number of set bits in the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755070,
                "title": "easy-o-1-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count = 0;\\n\\n    while (a > 0 and b > 0)\\n    {\\n        if ((a & 1) != (b & 1))\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n\\n    while (a)\\n    {\\n        if (a & 1)\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n    }\\n\\n    while (b)\\n    {\\n        if (b & 1)\\n        {\\n            count++;\\n        }\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count = 0;\\n\\n    while (a > 0 and b > 0)\\n    {\\n        if ((a & 1) != (b & 1))\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n\\n    while (a)\\n    {\\n        if (a & 1)\\n        {\\n            count++;\\n        }\\n        a >>= 1;\\n    }\\n\\n    while (b)\\n    {\\n        if (b & 1)\\n        {\\n            count++;\\n        }\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753222,
                "title": "simple-basic-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count=0;\\n    while (a > 0 || b > 0) {\\n \\n        int t1 = (a & 1);\\n        int t2 = (b & 1);\\n \\n        if (t1 != t2) {\\n            count++;\\n        }\\n        // right shifting a and b\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int count=0;\\n    while (a > 0 || b > 0) {\\n \\n        int t1 = (a & 1);\\n        int t2 = (b & 1);\\n \\n        if (t1 != t2) {\\n            count++;\\n        }\\n        // right shifting a and b\\n        a >>= 1;\\n        b >>= 1;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724804,
                "title": "one-of-the-most-easiest-solutions",
                "content": "# Intuition\\nWe need to just count to total number of different bits of `start` and `end`.\\n\\n# Approach\\nFind `XOR` of `start` and `end` and then count 1. Because after `XOR` any two value, we get 1 only when where the bit is different.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n\\n        long long diffBits = start ^ goal;\\n        while(diffBits != 0){\\n            if(diffBits & 1) count++;\\n            diffBits >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n**Please upvote if you really like the approach. \\uD83D\\uDC4D\\uD83C\\uDFFB**\\n\\nCheckout my GitHub repo: [GitHub](https://github.com/RiyaadHossain/LeetCode-Problem)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n\\n        long long diffBits = start ^ goal;\\n        while(diffBits != 0){\\n            if(diffBits & 1) count++;\\n            diffBits >>= 1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607182,
                "title": "100-c-most-easy-solution-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int ans=0;\\n        string s= bitset<32>(start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++)\\n        {\\n            if(s[i]!=str[i]) \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) \\n    {\\n        int ans=0;\\n        string s= bitset<32>(start).to_string();\\n        string str= bitset<32> (goal).to_string();\\n        for(int i=0;i<32;i++)\\n        {\\n            if(s[i]!=str[i]) \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483816,
                "title": "c-100-beat-using-bit-manipulation-way",
                "content": "# Intuition\\nEasy way to play with bit Manipulation way.\\n\\n# Approach\\n- take a variable and store in it xor of start and goal ex\\n`int a=start ^ goal;`\\n- count number of 1 bit in this number `while(a)\\n{ if(a&1)ans++;\\na>>=1;}`\\n- return the count;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Please upvote my work\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a=start ^ goal;\\n        int ans=0;\\n        while(a)\\n       { if(a&1)ans++;\\n        a>>=1;}\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int a=start ^ goal;\\n        int ans=0;\\n        while(a)\\n       { if(a&1)ans++;\\n        a>>=1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456503,
                "title": "bit-manipulation-using-rsb-mask-easiest-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        int ans=start^goal;\\n        int cnt=0;\\n        while(ans){\\n            int rsb=ans&(-ans);\\n            ans=ans-rsb;\\n            cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        int ans=start^goal;\\n        int cnt=0;\\n        while(ans){\\n            int rsb=ans&(-ans);\\n            ans=ans-rsb;\\n            cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443196,
                "title": "java-easy-solution-beats-100-using-bit-manipulation-asked-in-persistent-systems",
                "content": "# Intuition\\nBasically we have to find the count of bits which are different in both given start and goal variables.\\nFor e.g. - start = 4 and goal = 7 \\nNow lets look at their Binary representation as we\\'ve to find the number of bits after all.\\nstart= 4 -> 1 0 0\\ngoal = 7 -> 1 1 1\\nxor  = ^ -> 0 1 1 ( Total set bits(1\\'s) represents the bit difference between the given two numbers)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, we get the number of bits which are different in both the variables after xor.\\nHere we get xor = 3 .\\nSo, then we\\'ll just count the set bits of xor and return it as our answer.\\n\\nWe use one of the most effective method to count the set bits i.e.,\\n**n & (n-1)** \\nIn our case we have xor in place of n.\\nSo, **xor % (xor-1)**\\nE.g., 3&(3-1) = 3&2 = 2\\nthen 2&(2-1) = 2&1 = 0\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(1)\\n\\n---\\n\\n\\n**Hope it helps, Happy LeetCoding{^_^}**\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = (start^goal);\\n        int count = 0;\\n        while(xor!=0) {\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        return count;\\n    }\\n}\\n```\\n---",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = (start^goal);\\n        int count = 0;\\n        while(xor!=0) {\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342937,
                "title": "0-ms-100-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n      int n=start^goal;\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n      int n=start^goal;\\n        int count=0;\\n        while(n){\\n            n=n&(n-1);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299721,
                "title": "efficient-code-100-beats-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the start and goal are equal then no bit need to be converted.\\nIf start is greater than goal then it might take more bit than the goal \\nand if the goal is greater than start then it might take more bit than start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\nIf you find it helpful then please upvote\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        if(start==goal){\\n            return count;\\n        }\\n        else if(start>goal){\\n            while(start>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }else{\\n            while(goal>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        if(start==goal){\\n            return count;\\n        }\\n        else if(start>goal){\\n            while(start>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }else{\\n            while(goal>0){\\n                if((start&1) != (goal&1)){\\n                    count++;\\n                }\\n                start>>=1;\\n                goal>>=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280695,
                "title": "java-two-different-approaches",
                "content": "\\n\\n# Approach 1:\\nWe\\'ll first convert both the numbers into 32-bit binary string forms. Then, we will check the number of different bits (characters in the strings) among the two converted binary string forms.\\n\\n# Code:\\n```\\n    String startBinary = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n    String goalBinary = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n\\n    int minFlip = 0;\\n    int pointer = 0;\\n    while (pointer < startBinary.length()) {\\n      if (startBinary.charAt(pointer) != goalBinary.charAt(pointer)) {\\n        minFlip += 1;\\n      }\\n      pointer += 1;\\n    }\\n    return minFlip;\\n```\\n\\n\\n# Approach 2:\\nWe can solve the problem easily using the XOR operation because XOR produces 1 for different bits between two numbers. We can thus create a new variable, which will be the XOR of the given two variables. Afterwards, we\\'ll loop through and find out the number of 1 bits (different bits) in the previously produced XOR value. To find out the number of 1 bits, we can use [Brian Kernighan\\'s](https://leeyoongti.medium.com/counting-set-bits-using-brian-kernighans-algorithm-14d5699244ae) algorithm.\\n\\n\\n# Code:\\n```\\n    int xorValue = start ^ goal;\\n    int minFlip = 0;\\n\\n    while (xorValue != 0) {\\n      minFlip += 1;\\n      xorValue = (xorValue - 1) & xorValue;\\n    }\\n    return minFlip;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    String startBinary = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n    String goalBinary = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n\\n    int minFlip = 0;\\n    int pointer = 0;\\n    while (pointer < startBinary.length()) {\\n      if (startBinary.charAt(pointer) != goalBinary.charAt(pointer)) {\\n        minFlip += 1;\\n      }\\n      pointer += 1;\\n    }\\n    return minFlip;\\n```\n```\\n    int xorValue = start ^ goal;\\n    int minFlip = 0;\\n\\n    while (xorValue != 0) {\\n      minFlip += 1;\\n      xorValue = (xorValue - 1) & xorValue;\\n    }\\n    return minFlip;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204972,
                "title": "bit-manupulation-basic-implementation-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n       vector<int>v1,v2;\\n//taking out bit form of both goal and start numbers\\n       while(start!=0||goal!=0){\\n//pushing last bit in vector by taking and with the num\\n           v1.push_back(start&1);\\n           v2.push_back(goal&1);\\n           start=start>>1;\\n           goal=goal>>1;\\n          \\n       }\\n//checking number of bits that are different and need to flip to make goal from start\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           if(v1[i]!=v2[i])\\n           count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n       vector<int>v1,v2;\\n//taking out bit form of both goal and start numbers\\n       while(start!=0||goal!=0){\\n//pushing last bit in vector by taking and with the num\\n           v1.push_back(start&1);\\n           v2.push_back(goal&1);\\n           start=start>>1;\\n           goal=goal>>1;\\n          \\n       }\\n//checking number of bits that are different and need to flip to make goal from start\\n       for(int i=0;i<v1.size();i++)\\n       {\\n           if(v1[i]!=v2[i])\\n           count++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991304,
                "title": "xor-count-the-set-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int val = start^goal;\\n        int res=0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(val & 1<<i)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int val = start^goal;\\n        int res=0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(val & 1<<i)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759108,
                "title": "c-one-liner-code-faster-than-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal); \\n    }      \\n};         \\n\\n\\n\\n\\n\\n***if helpful please upvote***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start ^ goal); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2722569,
                "title": "java-one-liner-faster-than-100",
                "content": "The trick here is to perform xor (^) operation between the goal and the start, as it will get set bits for the places where bits of start and goal are different. For example,\\n\\t\\t\\tgoal = 00000100110110\\n\\t\\t\\tstart = 01001001100010\\nxor = 01001101010100\\nNow these set bits in xor result are the minimum bits that need to be flipped in order to convert start to goal. So, we count the number of set bits in xor using Integer.bitCount(x) in Java.\\n```\\n\\tpublic int minBitFlips(int start, int goal) {\\n\\t\\t\\treturn Integer.bitCount(start ^ goal);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tpublic int minBitFlips(int start, int goal) {\\n\\t\\t\\treturn Integer.bitCount(start ^ goal);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720229,
                "title": "swift-start-goal-nonzerobitcount",
                "content": "```\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606608,
                "title": "easy-code-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    int minBitFlips(int start, int goal) {\\n        //the number of min bits will be total number of diff bits and we can count it by right shifting and comapre the 0th bit\\n        int ans=0;\\n        while(start!=0||goal!=0)\\n        {\\n            if((start&1)!=(goal&1))//0th bit different\\n                ans++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minBitFlips(int start, int goal) {\\n        //the number of min bits will be total number of diff bits and we can count it by right shifting and comapre the 0th bit\\n        int ans=0;\\n        while(start!=0||goal!=0)\\n        {\\n            if((start&1)!=(goal&1))//0th bit different\\n                ans++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2582111,
                "title": "simple-easy-and-clean-c-solution-using-bit-manipulation-xor-and",
                "content": "Store  **Bitwise XOR** operation between start and goal into an **integer named x**.\\n\\nThis helps us to count the number of the number of set bits in x that describes how many bits are need to be changed in start to convert it into goal.\\n\\n**Below steps count the number of set bits in x.**\\n\\n**Following steps are followed to solve the problem -:**\\n\\n1. Take a counter  **count** to count the number of 1\\'s in binary representation of the number.\\n2. Now use a while loop until the number becomes zero.\\n3. Perform **bitwise &** operation of **x** with **1**. If bit is 1 that means 1 is present in the representation and increase the count variable by 1.\\n4. Now shift the bit of x by 1 by doing a right shift **x>>1** so as to perform bitwise & operation on each bit of x .\\n5. Exit the while loop and **return the count** i.e number of 1 bits in the number.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minBitFlips(int start, int goal) \\n\\t\\t\\t{\\n\\t\\t\\t\\tint x=start^goal;\\n\\t\\t\\t\\tint c=0;\\n\\t\\t\\t\\twhile(x)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(x&1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tx=x>>1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn c;  \\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minBitFlips(int start, int goal) \\n\\t\\t\\t{\\n\\t\\t\\t\\tint x=start^goal;\\n\\t\\t\\t\\tint c=0;\\n\\t\\t\\t\\twhile(x)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(x&1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2567972,
                "title": "runtime-0-ms-faster-than-100-00-submissions",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        int cnt=0;\\n        for(int i=0;i<32;i++) {\\n            if(((n>>i)&1)==1) cnt++;\\n        } return cnt;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        int cnt=0;\\n        for(int i=0;i<32;i++) {\\n            if(((n>>i)&1)==1) cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2509277,
                "title": "c-o-32-time-100-faster-easy-understanding",
                "content": "```\\nhere we are just checking the ith bit of each is same or not, if not same then operations increases\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            int j=(g>>i)&1, k=(s>>i)&1;\\n            if(j!=k){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nhere we are just checking the ith bit of each is same or not, if not same then operations increases\\nclass Solution {\\npublic:\\n    int minBitFlips(int s, int g) {\\n        int cnt=0;\\n        for(int i=0;i<32;i++){\\n            int j=(g>>i)&1, k=(s>>i)&1;\\n            if(j!=k){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488977,
                "title": "java-0ms-100-faster-using-bit-manipulation-using-xor-3-liner-solution",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        for(int i=0;i<31;i++) if(((start&(1<<i))^(goal&(1<<i))) == (1<<i)) ans++;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        for(int i=0;i<31;i++) if(((start&(1<<i))^(goal&(1<<i))) == (1<<i)) ans++;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477246,
                "title": "go-simple-solution-0ms",
                "content": "```go\\nfunc minBitFlips(start, goal int) int {\\n    // User XOR(^) for finding different bits\\n    // then count result bits\\n\\treturn bits.OnesCount32(uint32(start ^ goal))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minBitFlips(start, goal int) int {\\n    // User XOR(^) for finding different bits\\n    // then count result bits\\n\\treturn bits.OnesCount32(uint32(start ^ goal))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2462345,
                "title": "java-solution-3ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        String b_start = Integer.toBinaryString(start);\\n        String b_goal = Integer.toBinaryString(goal);\\n        int sb = b_start.length(), gb = b_goal.length();\\n        if (sb > gb) {\\n            int l = sb - gb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_goal = (z + b_goal);\\n\\n            for (int i = 0; i < sb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else if (sb < gb) {\\n            int l = gb - sb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_start = (z + b_start);\\n\\n            for (int i = 0; i < gb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < b_start.length(); i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        String b_start = Integer.toBinaryString(start);\\n        String b_goal = Integer.toBinaryString(goal);\\n        int sb = b_start.length(), gb = b_goal.length();\\n        if (sb > gb) {\\n            int l = sb - gb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_goal = (z + b_goal);\\n\\n            for (int i = 0; i < sb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else if (sb < gb) {\\n            int l = gb - sb;\\n            String z = \"\";\\n            for (int i = 0; i < l; i++) {\\n                z += \"0\";\\n            }\\n            b_start = (z + b_start);\\n\\n            for (int i = 0; i < gb; i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < b_start.length(); i++) {\\n                if (b_start.charAt(i) != b_goal.charAt(i)) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461657,
                "title": "c-easy-solution-xor-count-set-bits",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    int countSetBits(int n){\\n        if (n == 0)\\n            return 0;\\n        else\\n            return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        return countSetBits(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSetBits(int n){\\n        if (n == 0)\\n            return 0;\\n        else\\n            return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    int minBitFlips(int start, int goal) {\\n        return countSetBits(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447924,
                "title": "simple-java-solution-beats-100-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start!=0 || goal!=0){\\n            count += ((start & 1)^(goal & 1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start!=0 || goal!=0){\\n            count += ((start & 1)^(goal & 1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439587,
                "title": "unique-morse-code-words",
                "content": "\\n        vector<string> s= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char c=97;\\n        unordered_map<char,string> m;\\n       for(auto &i:s)\\n      {\\n           m[c]=i;\\n           c++;\\n       }\\n        set<string> st;\\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str+=m[words[i][j]];\\n                \\n            }\\n            st.insert(str);\\n        }\\n        return st.size();\\n",
                "solutionTags": [
                    "String",
                    "Ordered Set"
                ],
                "code": "\\n        vector<string> s= {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\\n        char c=97;\\n        unordered_map<char,string> m;\\n       for(auto &i:s)\\n      {\\n           m[c]=i;\\n           c++;\\n       }\\n        set<string> st;\\n        for(int i=0;i<words.size();i++){\\n            string str=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                str+=m[words[i][j]];\\n                \\n            }\\n            st.insert(str);\\n        }\\n        return st.size();\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2399127,
                "title": "python-xor",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        count = 0\\n        xor = start ^ goal\\n        while xor:\\n            count += 1\\n            xor &= xor - 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        count = 0\\n        xor = start ^ goal\\n        while xor:\\n            count += 1\\n            xor &= xor - 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333422,
                "title": "easy-faster-than-100-java-solution",
                "content": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n       int num = start^goal;\\n        while(num!=0){\\n            if((num&1)==1){\\n                cnt++;\\n                num=num>>1;\\n            }else{\\n                num=num>>1;\\n            }\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n       int num = start^goal;\\n        while(num!=0){\\n            if((num&1)==1){\\n                cnt++;\\n                num=num>>1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2328636,
                "title": "easy-solution-python",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        return bin(start ^ goal).count(\\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295957,
                "title": "simple-and-intuitive-solution-in-python-with-comments",
                "content": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n\\tstart = bin(start)[:1:-1]   # get the binary representations of numbers\\n    goal = bin(goal)[:1:-1]     # in backwards order\\n        \\n    len_st = len(start)         # lengths of the binary strings\\n    len_go = len(goal)\\n        \\n    if len_st < len_go:         # we need to supplement the shorter binary with leading zeros\\n\\t\\tstart += \\'0\\' * (len_go - len_st)\\n\\telif len_go < len_st:\\n\\t\\tgoal += \\'0\\' * (len_st - len_go)\\n        \\n\\tflips = sum([start[i] != goal[i] for i in range(len(start))])  # count the number of unequal bits at every i-th position\\n        \\n    return flips",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n\\tstart = bin(start)[:1:-1]   # get the binary representations of numbers\\n    goal = bin(goal)[:1:-1]     # in backwards order\\n        \\n    len_st = len(start)         # lengths of the binary strings\\n    len_go = len(goal)\\n        \\n    if len_st < len_go:         # we need to supplement the shorter binary with leading zeros\\n\\t\\tstart += \\'0\\' * (len_go - len_st)\\n\\telif len_go < len_st:\\n\\t\\tgoal += \\'0\\' * (len_st - len_go)\\n        \\n\\tflips = sum([start[i] != goal[i] for i in range(len(start))])  # count the number of unequal bits at every i-th position\\n        \\n    return flips",
                "codeTag": "Python3"
            },
            {
                "id": 2275840,
                "title": "easy-xor-method-solution-in-c",
                "content": "Xor will have bit\\'1\\' at positions where bits of both numbers are different and \\nwe need to flip only those bits which are different so number of bit\\'1\\' in xor \\nwill give us result;\\n```\\nclass Solution {\\npublic:\\n    int numberOfSetbits(int Xor){\\n        int count=0;\\n        while(Xor){\\n            if(Xor&1){\\n                count++;\\n            }\\n            \\n            Xor>>=1;\\n        }\\n        return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        \\n        int Xor=start^goal;\\n        return numberOfSetbits(Xor);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSetbits(int Xor){\\n        int count=0;\\n        while(Xor){\\n            if(Xor&1){\\n                count++;\\n            }\\n            \\n            Xor>>=1;\\n        }\\n        return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int ans=0;\\n        \\n        int Xor=start^goal;\\n        return numberOfSetbits(Xor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237452,
                "title": "using-xor-100-fast",
                "content": "```\\nint minBitFlips(int a, int b) {\\n         // Your logic here\\n        int XOR= a^b;\\n        int c=0;\\n        // 1010\\n        // 1000\\n        // xor\\n        // 0010 only to flip 1 & 0 at position 2 from left\\n        while(XOR){\\n            int bit=1;\\n            if(bit & XOR){\\n                c++;\\n            }\\n            XOR=XOR>>1;\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minBitFlips(int a, int b) {\\n         // Your logic here\\n        int XOR= a^b;\\n        int c=0;\\n        // 1010\\n        // 1000\\n        // xor\\n        // 0010 only to flip 1 & 0 at position 2 from left\\n        while(XOR){\\n            int bit=1;\\n            if(bit & XOR){\\n                c++;\\n            }\\n            XOR=XOR>>1;\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200461,
                "title": "java-simple-bitwise-solution",
                "content": "This is my simple somution via bitwise:\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int flipCount = 0;\\n        \\n        while (start > 0 || goal > 0) {\\n            flipCount += ((start & 0x1) ^ (goal & 0x1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return flipCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int flipCount = 0;\\n        \\n        while (start > 0 || goal > 0) {\\n            flipCount += ((start & 0x1) ^ (goal & 0x1));\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return flipCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191453,
                "title": "c-0ms-faster-than-100-left-shift",
                "content": "\\n    int minBitFlips(int n, int g) {\\n     \\n        int count=0;\\n        unsigned int i=0;\\n        while(i!=31 && g!=n)\\n        {\\n            int flag=1<<i;\\n            int flag2=n&flag;\\n            int flag3=g&flag;\\n            if(flag2!=flag3)\\n            {\\n                count++;\\n                if(flag3==1)\\n                    n=n|flag3;\\n                else\\n                    n=n&(~flag2);\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    int minBitFlips(int n, int g) {\\n     \\n        int count=0;\\n        unsigned int i=0;\\n        while(i!=31 && g!=n)\\n        {\\n            int flag=1<<i;\\n            int flag2=n&flag;\\n            int flag3=g&flag;\\n            if(flag2!=flag3)\\n            {\\n                count++;\\n                if(flag3==1)\\n                    n=n|flag3;\\n                else\\n                    n=n&(~flag2);\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2185973,
                "title": "rust-faster-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_bit_flips(mut start: i32, mut goal: i32) -> i32 {\\n        let mut cnt = 0;\\n        // while start != goal {\\n        //     if start & 0x1 != goal & 0x1 {\\n        //         cnt += 1;\\n        //     }\\n        //     start >>= 1;\\n        //     goal >>= 1;\\n        // }\\n\\n        let mut n = start ^ goal;\\n        while n != 0 {\\n            n = n & (n - 1);\\n            cnt += 1;\\n        }\\n\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_bit_flips(mut start: i32, mut goal: i32) -> i32 {\\n        let mut cnt = 0;\\n        // while start != goal {\\n        //     if start & 0x1 != goal & 0x1 {\\n        //         cnt += 1;\\n        //     }\\n        //     start >>= 1;\\n        //     goal >>= 1;\\n        // }\\n\\n        let mut n = start ^ goal;\\n        while n != 0 {\\n            n = n & (n - 1);\\n            cnt += 1;\\n        }\\n\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127699,
                "title": "c",
                "content": "```class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        unsigned int count = 0;\\n    while (n) {\\n        count += n & 1;\\n        n >>= 1;\\n    }\\n    return count;\\n    }\\n};```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n=start^goal;\\n        unsigned int count = 0;\\n    while (n) {\\n        count += n & 1;\\n        n >>= 1;\\n    }\\n    return count;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2092213,
                "title": "python-1-line-xor-count-bits",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start, goal):\\n        return (start^goal).bit_count()\\n```\\nexample:\\n10 : 1010\\n07 : 0111\\nxor: 1101 (3 bits == solution)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start, goal):\\n        return (start^goal).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037974,
                "title": "swift-one-liner",
                "content": "Swift one-liner\\n```swift\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minBitFlips(_ start: Int, _ goal: Int) -> Int {\\n        (start ^ goal).nonzeroBitCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028043,
                "title": "python3-easy-to-understand-solution",
                "content": "1. Initialise your return variable with 0.\\n2. Check if LSB of both are different. Increase your count.\\n3. Right shift both the numbers.\\n(Note - For while, we will take larger number as condition)\\n```\\nclass Solution:\\n    def count_flips(self, start, goal):\\n        count = 0\\n        while start != 0:\\n            if start & 1 != goal & 1:\\n                count += 1\\n            start >>= 1\\n            goal >>= 1\\n        return count\\n        \\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        if start > goal:\\n            return self.count_flips(start, goal)\\n        else:\\n            return self.count_flips(goal, start)\\n            \\n",
                "solutionTags": [],
                "code": "1. Initialise your return variable with 0.\\n2. Check if LSB of both are different. Increase your count.\\n3. Right shift both the numbers.\\n(Note - For while, we will take larger number as condition)\\n```\\nclass Solution:\\n    def count_flips(self, start, goal):\\n        count = 0\\n        while start != 0:\\n            if start & 1 != goal & 1:\\n                count += 1\\n            start >>= 1\\n            goal >>= 1\\n        return count\\n        \\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        if start > goal:\\n            return self.count_flips(start, goal)\\n        else:\\n            return self.count_flips(goal, start)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2020000,
                "title": "fastest-java-1-line-solution-0-ms",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) \\n    {\\n       return Integer.bitCount(start^goal);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int minBitFlips(int start, int goal) \\n    {\\n       return Integer.bitCount(start^goal);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1949455,
                "title": "100-fast-bitmask-explained",
                "content": "class Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tYou have to check (for both the no. start and goal)that the ith bit is on of off if both are simultaneously on or off do nothing else increment ans\\n\\t\\tFor checking the ith bit is on or off make a bitmask and do the following logic:\\n\\t\\t\\t=>if n&mask==0 that means that bit was off\\n\\t\\t\\t=>otherwise that bit was on\\n\\t*/\\n\\t\\n\\n    int minBitFlips(int start, int goal) {\\n        int mask=1;\\n        int ans=0;\\n        while(mask<=max(goal,start)){\\n            int x1=(mask&start);\\n            int x2=(mask&goal);\\n            if(x1!=x2)ans++;\\n            mask=mask<<1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tYou have to check (for both the no. start and goal)that the ith bit is on of off if both are simultaneously on or off do nothing else increment ans\\n\\t\\tFor checking the ith bit is on or off make a bitmask and do the following logic:\\n\\t\\t\\t=>if n&mask==0 that means that bit was off\\n\\t\\t\\t=>otherwise that bit was on\\n\\t*/\\n\\t\\n\\n    int minBitFlips(int start, int goal) {\\n        int mask=1;\\n        int ans=0;\\n        while(mask<=max(goal,start)){\\n            int x1=(mask&start);\\n            int x2=(mask&goal);\\n            if(x1!=x2)ans++;\\n            mask=mask<<1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1926597,
                "title": "clear-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count{0};\\n        \\n        while(start || goal){\\n            count += (start & 1) != (goal & 1);\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count{0};\\n        \\n        while(start || goal){\\n            count += (start & 1) != (goal & 1);\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        \\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915306,
                "title": "python-3-o-n-time-easy-solution",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        def get( i):\\n            s=\"\"\\n            while i!=0:\\n                s+=\"0\"\\n                i-=1\\n            return s\\n        s=bin(start).replace(\"0b\",\\'\\')\\n        g=bin(goal).replace(\\'0b\\',\\'\\')\\n        if len(s)<len(g):\\n            s=get(len(g)-len(s))+s\\n        \\n        if len(g)<len(s):\\n            g=get(len(s)-len(g))+g\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]!=g[i]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        def get( i):\\n            s=\"\"\\n            while i!=0:\\n                s+=\"0\"\\n                i-=1\\n            return s\\n        s=bin(start).replace(\"0b\",\\'\\')\\n        g=bin(goal).replace(\\'0b\\',\\'\\')\\n        if len(s)<len(g):\\n            s=get(len(g)-len(s))+s\\n        \\n        if len(g)<len(s):\\n            g=get(len(s)-len(g))+g\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]!=g[i]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915196,
                "title": "minimum-bit-flips-to-convert-number-easy-learned-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flipped = start ^ goal;\\n        \\n        int count = 0;\\n        while(flipped != 0) {\\n            int rsb = (flipped & -flipped);\\n            flipped -= rsb;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\nIf you understood the problem, kindly **UpVote**.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flipped = start ^ goal;\\n        \\n        int count = 0;\\n        while(flipped != 0) {\\n            int rsb = (flipped & -flipped);\\n            flipped -= rsb;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915104,
                "title": "kotlin-solution-xor-then-count-set-bit",
                "content": "```\\nclass Solution {\\n    fun minBitFlips(start: Int, goal: Int): Int {\\n       var result = start xor goal\\n        var answer = 0\\n        while (result > 0) {\\n            if (result % 2 == 1) {\\n                answer++\\n            }\\n            result /= 2\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minBitFlips(start: Int, goal: Int): Int {\\n       var result = start xor goal\\n        var answer = 0\\n        while (result > 0) {\\n            if (result % 2 == 1) {\\n                answer++\\n            }\\n            result /= 2\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910452,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Brute Force***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        while(start)\\n        {\\n            int r = (start & 1);\\n            \\n            arr1.push_back(r);\\n            \\n            start = start >> 1;\\n        }\\n        \\n        while(goal)\\n        {\\n            int r = (goal & 1);\\n            \\n            arr2.push_back(r);\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        int count = 0;\\n        \\n        while(i < arr1.size() && j < arr2.size())\\n        {\\n            if(arr1[i] != arr2[j])\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        if(i < arr1.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(i < arr1.size())\\n            {\\n                if(arr1[i] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        if(j < arr2.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(j < arr2.size())\\n            {\\n                if(arr2[j] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        return count;\\n    }\\n```\\n\\n* ***Approach 2 : Optimized***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        int count = 0;\\n        \\n        while(start || goal)\\n        {\\n            int x1 = (start & 1);\\n            \\n            int x2 = (goal & 1);\\n            \\n            if(x1 != x2)\\n            {\\n                count++;\\n            }\\n            \\n            start = start >> 1;\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint minBitFlips(int start, int goal) {\\n        \\n        vector<int> arr1;\\n        \\n        vector<int> arr2;\\n        \\n        while(start)\\n        {\\n            int r = (start & 1);\\n            \\n            arr1.push_back(r);\\n            \\n            start = start >> 1;\\n        }\\n        \\n        while(goal)\\n        {\\n            int r = (goal & 1);\\n            \\n            arr2.push_back(r);\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        int i = 0;\\n        \\n        int j = 0;\\n        \\n        int count = 0;\\n        \\n        while(i < arr1.size() && j < arr2.size())\\n        {\\n            if(arr1[i] != arr2[j])\\n            {\\n                count++;\\n            }\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        if(i < arr1.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(i < arr1.size())\\n            {\\n                if(arr1[i] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        if(j < arr2.size())\\n        {\\n            int count_1 = 0;\\n            \\n            while(j < arr2.size())\\n            {\\n                if(arr2[j] == 1)\\n                {\\n                    count_1++;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            count += count_1;\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\nint minBitFlips(int start, int goal) {\\n        \\n        int count = 0;\\n        \\n        while(start || goal)\\n        {\\n            int x1 = (start & 1);\\n            \\n            int x2 = (goal & 1);\\n            \\n            if(x1 != x2)\\n            {\\n                count++;\\n            }\\n            \\n            start = start >> 1;\\n            \\n            goal = goal >> 1;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910193,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909717,
                "title": "one-liner-python-c-using-xor",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```\\n**Python**\\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n        \\n    }\\n};\\n```\n```\\ndef minBitFlips(self, start: int, goal: int) -> int:\\n        return (start ^ goal).bit_count()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908989,
                "title": "simple-solution-using-xor-in-o-n",
                "content": "doing XOR and finding number on Ones in binary conversion of resultant\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> convert(int num){\\n       vector<int>ans;\\n        while(num>0){\\n           int c=(num%2);\\n            num/=2;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        vector<int> ans=convert(x);\\n        int f=0;\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==1)\\n                f++;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> convert(int num){\\n       vector<int>ans;\\n        while(num>0){\\n           int c=(num%2);\\n            num/=2;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n\\n    int minBitFlips(int start, int goal) {\\n        int x=start^goal;\\n        vector<int> ans=convert(x);\\n        int f=0;\\n        int n=ans.size();\\n        for(int i=0;i<n;i++){\\n            if(ans[i]==1)\\n                f++;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908081,
                "title": "simple-java-intuitive-bit-manipulation-ttt",
                "content": "Lets take 10 and 7 as an example:\\nBinary rep of 10: 1010\\nBinary rep of 7 :   0111\\nIt is clear that if we are able to count the number of mis-matches OR the number of different bits, we can conclude the number of flips needed,\\n\\n**No of Flips = No of mis-matched btis in binary representation**\\n\\nThe easiest way to find mismatched bits is excecuting a XOR opeartion om start and goal, as in XOR the mis-matched bits generate 1. Hence, we can then count the number of 1s in the XOR result and find the number of flips needed.\\n\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n\\t//start = 10 (1010)\\n\\t//goal = 7    (0111)\\n\\t// start ^ goal = (1101) --> as there are 3 mis matched bits bw 10 and 7 \\n\\t//  we can easilt count no of 1s in the XOR result using th following snippet \\n        int res = start ^ goal;\\n        int count = 0;\\n        while( res > 0){\\n            if( (res & 1) % 2 == 1)count++;\\n            res = res >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n\\t//start = 10 (1010)\\n\\t//goal = 7    (0111)\\n\\t// start ^ goal = (1101) --> as there are 3 mis matched bits bw 10 and 7 \\n\\t//  we can easilt count no of 1s in the XOR result using th following snippet \\n        int res = start ^ goal;\\n        int count = 0;\\n        while( res > 0){\\n            if( (res & 1) % 2 == 1)count++;\\n            res = res >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907541,
                "title": "c-simple-easy-code-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int flips = 0;\\n \\n      while(a > 0 || b > 0){\\n\\n        int t1 = (a&1);\\n        int t2 = (b&1);\\n\\n        if(t1!=t2){flips++;}\\n        a>>=1;\\n        b>>=1;\\n      }\\n\\n      return flips;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int a, int b) {\\n        int flips = 0;\\n \\n      while(a > 0 || b > 0){\\n\\n        int t1 = (a&1);\\n        int t2 = (b&1);\\n\\n        if(t1!=t2){flips++;}\\n        a>>=1;\\n        b>>=1;\\n      }\\n\\n      return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907475,
                "title": "simple-explanation-c-0-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n\\t\\n\\t\\t//to take xor so that we can get all position where start and goal differ\\n        int temp = start ^ goal;    \\n        int cnt = 0;\\n\\t\\t\\n\\t\\t//count the set bits which will give the position where they differ and count them\\n        while(temp){ \\n            cnt += temp & 1;\\n            temp >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n\\t\\n\\t\\t//to take xor so that we can get all position where start and goal differ\\n        int temp = start ^ goal;    \\n        int cnt = 0;\\n\\t\\t\\n\\t\\t//count the set bits which will give the position where they differ and count them\\n        while(temp){ \\n            cnt += temp & 1;\\n            temp >>= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907289,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        return bin(start^goal).count(\"1\")\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        \\n        return bin(start^goal).count(\"1\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907192,
                "title": "bitset-stl-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n         bitset<32> num1(start);\\n         bitset<32> num2(goal);\\n        \\n         int n = num1.size();\\n        \\n        int counter = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(num1[i] != num2[i])\\n                counter++;\\n        }\\n        \\n        \\n        return counter;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n         bitset<32> num1(start);\\n         bitset<32> num2(goal);\\n        \\n         int n = num1.size();\\n        \\n        int counter = 0;\\n        for(int i = n-1;i>=0;i--){\\n            if(num1[i] != num2[i])\\n                counter++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1907158,
                "title": "c-easy-to-understand-commented",
                "content": "**Idea**\\n1. Convert decimal to its binary equivalent and then just compare both if they are differnt i.e if first is 0 and 2nd is 1 we need to flip.\\n2. for example 1010 and 0110, three bits differ so answer is 3\\n```\\nclass Solution {\\npublic:\\n    \\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int k = start >> i;\\n            int l = goal >> i;\\n            int m = k&1; //Check the bit of start\\n            int n = l&1; // Check the bit of target\\n            if (m != n) //If different\\n                flips++; //flip is required\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int k = start >> i;\\n            int l = goal >> i;\\n            int m = k&1; //Check the bit of start\\n            int n = l&1; // Check the bit of target\\n            if (m != n) //If different\\n                flips++; //flip is required\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907126,
                "title": "python-straightforward",
                "content": "```python\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        total = 0\\n\\n        for a, b in zip(bin(start)[2:].rjust(32, \\'0\\'), bin(goal)[2:].rjust(32, \\'0\\')):\\n            if a != b:\\n                total += 1\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        total = 0\\n\\n        for a, b in zip(bin(start)[2:].rjust(32, \\'0\\'), bin(goal)[2:].rjust(32, \\'0\\')):\\n            if a != b:\\n                total += 1\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907063,
                "title": "c-easy-solution-one-liner",
                "content": "```\\nThe logic is find the total number of set bits in xor of start no. and goal .\\nResult = set-bits( start ^ goal )\\n```\\n```\\nclass Solution {\\npublic:\\n    int countsetbits(int n){\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);    // Remove last set bit\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int c= countsetbits(start^goal);\\n        return c;\\n    }\\n};\\n```\\n```\\nOne liner:\\n\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);    //predefined method to find set bits in binary of a no.\\n    }\\n};\\n```\\nIf you like it, please upvote !!\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nThe logic is find the total number of set bits in xor of start no. and goal .\\nResult = set-bits( start ^ goal )\\n```\n```\\nclass Solution {\\npublic:\\n    int countsetbits(int n){\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);    // Remove last set bit\\n    }\\n    return count;\\n    }\\n    int minBitFlips(int start, int goal) {\\n        int c= countsetbits(start^goal);\\n        return c;\\n    }\\n};\\n```\n```\\nOne liner:\\n\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        return __builtin_popcount(start^goal);    //predefined method to find set bits in binary of a no.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907056,
                "title": "easy-understand",
                "content": "class Solution {\\npublic:\\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }\\n    return count;\\n}\\n    int minBitFlips(int a, int b) {\\n        return countSetBits(a^b);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countSetBits(int n)\\n{\\n    int count = 0;\\n    while (n > 0)\\n    {\\n        count++;\\n        n &= (n-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1906988,
                "title": "compare-bits-of-numbers-simply",
                "content": "```\\n    int minBitFlips(int start, int goal) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<32;i++){\\n            bool bit1=(start&(1<<i));\\n            bool bit2=(goal&(1<<i));\\n            \\n            if(bit1!=bit2){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n    int minBitFlips(int start, int goal) {\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<32;i++){\\n            bool bit1=(start&(1<<i));\\n            bool bit2=(goal&(1<<i));\\n            \\n            if(bit1!=bit2){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1906978,
                "title": "java-using-xor",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int x = start^goal;\\n        int c = 0;\\n        while(x>0){\\n            if((x&1)==1) c++;\\n            x = x>>1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int x = start^goal;\\n        int c = 0;\\n        while(x>0){\\n            if((x&1)==1) c++;\\n            x = x>>1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906977,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int bit=0;\\n        int flip=0;\\n        while(bit<32){\\n            if((start&(1<<bit))!=((goal)&(1<<bit))){\\n                flip++;\\n            }\\n            bit++;\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int bit=0;\\n        int flip=0;\\n        while(bit<32){\\n            if((start&(1<<bit))!=((goal)&(1<<bit))){\\n                flip++;\\n            }\\n            bit++;\\n        }\\n        return flip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906968,
                "title": "java-simple-solution-xor",
                "content": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int new_num = start ^ goal,count = 0;\\n        while(new_num != 0){\\n            count += (1 & new_num);\\n            new_num = new_num >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int new_num = start ^ goal,count = 0;\\n        while(new_num != 0){\\n            count += (1 & new_num);\\n            new_num = new_num >> 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089068,
                "title": "c-code-easy-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        //initializing temp with start\\n        int temp=start,count = 0;\\n        //loop will end when the temp == goal\\n        for(int i = 0 ; temp != goal ; i++){\\n            int bit1 = ((temp >> i) & 1 ); // gets ith bit of temp\\n            int bit2 = ((goal >> i) & 1); // gets ith bit of goal\\n\\n            if(bit1 != bit2){ //if not equal increment count\\n                count++;\\n                temp = temp ^ (1 << i); //flip the ith bit\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nxor operation result is 1 if corresponding bits are not equal so we can perform xor of start and goal and count the number of 1\\'s \\n# code\\n```\\n        int count = 0;\\n        int ans = start ^ goal;\\n        while(ans){\\n            ans = ans & (ans -1);\\n            count++;\\n        }\\n        return count;",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        //initializing temp with start\\n        int temp=start,count = 0;\\n        //loop will end when the temp == goal\\n        for(int i = 0 ; temp != goal ; i++){\\n            int bit1 = ((temp >> i) & 1 ); // gets ith bit of temp\\n            int bit2 = ((goal >> i) & 1); // gets ith bit of goal\\n\\n            if(bit1 != bit2){ //if not equal increment count\\n                count++;\\n                temp = temp ^ (1 << i); //flip the ith bit\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088696,
                "title": "beats100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        for(int i=0;i<31;++i){\\n            if((start&1) != (goal&1)) ++count;\\n            start >>=1;\\n            goal >>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        for(int i=0;i<31;++i){\\n            if((start&1) != (goal&1)) ++count;\\n            start >>=1;\\n            goal >>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088446,
                "title": "bit-flip-bit-compare-by-binary-conversion-of-digits",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n\\n    int BitFlip;\\n    int CountDiff;\\n    List<int> StartBit = new List<int>();\\n    List<int> GoalBit = new List<int>();\\n\\n    public int MinBitFlips(int start, int goal) {\\n        \\n        DigitToBinary(start,StartBit);\\n        DigitToBinary(goal,GoalBit);\\n\\nif(StartBit.Count > GoalBit.Count)\\n{\\n    CountDiff = StartBit.Count - GoalBit.Count;\\n\\n    for(int i = 1; i <= CountDiff; i++)\\n    {\\n        GoalBit.Add(0);\\n    }\\n}\\nelse if(StartBit.Count < GoalBit.Count)\\n{\\n    CountDiff = GoalBit.Count - StartBit.Count;\\n\\n    for (int i = 1; i <= CountDiff; i++)\\n    {\\n        StartBit.Add(0);\\n    }\\n}\\n\\nStartBit.Reverse();\\nGoalBit.Reverse();\\n\\nfor(int i = 0; i < GoalBit.Count; i++)\\n{\\n    if (GoalBit[i] != StartBit[i])\\n    {\\n        BitFlip++;\\n    }\\n}\\n\\n         return BitFlip;\\n}\\n\\npublic void DigitToBinary(int digit, List<int> bits)\\n{\\n\\n    if(digit == 0)\\n    {\\n        bits.Add(0);\\n    }\\n    else\\n    {\\n        while(digit > 0)\\n        {\\n            if(digit %2  == 0)\\n            {\\n                bits.Add(0);\\n                digit = digit /2;\\n            }\\n            else if(digit == 1)\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n            else\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n\\n        }\\n    }\\n\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    int BitFlip;\\n    int CountDiff;\\n    List<int> StartBit = new List<int>();\\n    List<int> GoalBit = new List<int>();\\n\\n    public int MinBitFlips(int start, int goal) {\\n        \\n        DigitToBinary(start,StartBit);\\n        DigitToBinary(goal,GoalBit);\\n\\nif(StartBit.Count > GoalBit.Count)\\n{\\n    CountDiff = StartBit.Count - GoalBit.Count;\\n\\n    for(int i = 1; i <= CountDiff; i++)\\n    {\\n        GoalBit.Add(0);\\n    }\\n}\\nelse if(StartBit.Count < GoalBit.Count)\\n{\\n    CountDiff = GoalBit.Count - StartBit.Count;\\n\\n    for (int i = 1; i <= CountDiff; i++)\\n    {\\n        StartBit.Add(0);\\n    }\\n}\\n\\nStartBit.Reverse();\\nGoalBit.Reverse();\\n\\nfor(int i = 0; i < GoalBit.Count; i++)\\n{\\n    if (GoalBit[i] != StartBit[i])\\n    {\\n        BitFlip++;\\n    }\\n}\\n\\n         return BitFlip;\\n}\\n\\npublic void DigitToBinary(int digit, List<int> bits)\\n{\\n\\n    if(digit == 0)\\n    {\\n        bits.Add(0);\\n    }\\n    else\\n    {\\n        while(digit > 0)\\n        {\\n            if(digit %2  == 0)\\n            {\\n                bits.Add(0);\\n                digit = digit /2;\\n            }\\n            else if(digit == 1)\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n            else\\n            {\\n                bits.Add(1);\\n                digit = digit / 2;\\n            }\\n\\n        }\\n    }\\n\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083167,
                "title": "java-solution",
                "content": "Initialize a variable count to 0. This variable will be used to keep track of the number of bit differences between start and goal.\\n\\nEnter a while loop that continues as long as either start or goal has bits remaining to be processed (i.e., greater than 0).\\n\\nInside the loop:\\n\\nstart & 1 and goal & 1 are used to extract the least significant bit (LSB) of start and goal, respectively. This is done by performing a bitwise AND operation with 1, which effectively checks if the rightmost bit is set (equal to 1).\\n((start & 1) ^ (goal & 1)) checks if the LSBs of start and goal are different. If they are different (i.e., XOR operation results in 1), it means that a bit flip is needed to make them the same.\\nIf the LSBs are different (i.e., the XOR operation results in 1), increment the count variable by 1. This means that a bit flip is required for this position.\\n\\nRight-shift both start and goal by 1 bit. This effectively moves to the next bit position, preparing to compare the next pair of bits in the binary representation.\\n\\nRepeat steps 3-5 until both start and goal have been completely processed (i.e., they become 0).\\n\\nAfter processing all bits, the count variable will contain the total number of bit differences (i.e., the number of bits that need to be flipped) between the original start and goal values.\\n\\nReturn the count value as the result, indicating how many bit flips are required to transform start into goal.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        // String num1 = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n        // String num2 = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n        // int count = 0;\\n        // for(int i = 0; i < num1.length(); i++){\\n        //     if(num1.charAt(i) != num2.charAt(i))\\n        //         count++;\\n        // }\\n        // return count;\\n\\n        int count = 0;\\n        while(start > 0 || goal > 0){\\n            if(((start & 1)^(goal & 1)) == 1)\\n                count++;\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        // String num1 = String.format(\"%32s\", Integer.toBinaryString(start)).replaceAll(\" \", \"0\");\\n        // String num2 = String.format(\"%32s\", Integer.toBinaryString(goal)).replaceAll(\" \", \"0\");\\n        // int count = 0;\\n        // for(int i = 0; i < num1.length(); i++){\\n        //     if(num1.charAt(i) != num2.charAt(i))\\n        //         count++;\\n        // }\\n        // return count;\\n\\n        int count = 0;\\n        while(start > 0 || goal > 0){\\n            if(((start & 1)^(goal & 1)) == 1)\\n                count++;\\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076840,
                "title": "easy-solution-tc-o-1-sc-o-1-bit-checks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is essentially asking for the minimum number of bit flips needed to convert one binary number (start) into another binary number (goal).\\n\\nTo find the minimum number of bit flips, we can compare the bits of both numbers from right to left (least significant bit to most significant bit).Whenever we encounter two bits that are different, we increment a counter to keep track of the number of bit flips required.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize a variable c to 0 to count the number of bit flips.\\n\\nIterate through the bits of start and goal from the rightmost bit (least significant bit) to the leftmost bit (most significant bit).\\n\\nFor each bit position i, check if the i-th bit of start is different from the i-th bit of goal. If they are different, increment the c counter.\\n\\nContinue this process for all bits.\\n\\nFinally, return the value of c as the minimum number of bit flips required to convert start to goal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe correct time complexity of the given algorithm is O(32) or simply O(1). This is because we are dealing with 32 bits in a 32-bit integer, which is a constant number of bits. Therefore, the time complexity remains constant and does not depend on the actual values of start and goal.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we only use a constant amount of space to store the counter c.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0;\\n        for(int i=0;i<32;i++){\\n            if(( (start & (1<<i)) ? 1:0) != ((goal & (1<<i)) ? 1:0) ){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int c=0;\\n        for(int i=0;i<32;i++){\\n            if(( (start & (1<<i)) ? 1:0) != ((goal & (1<<i)) ? 1:0) ){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075248,
                "title": "best-begginner-level-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        String str1 = Integer.toBinaryString(start);\\n        String str2 = Integer.toBinaryString(goal);\\n\\n        int lengthDifference = Math.abs(str1.length() - str2.length());\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < lengthDifference; i++) {\\n            result.append(\\'0\\');\\n        }\\n        String temp = \"\";\\n        if (str1.length() < str2.length()) {\\n            result.append(str1);\\n            temp = str2;\\n\\n        } else {\\n            result.append(str2);\\n            temp = str1;\\n        }\\n        String str = result.toString();\\n        int differences = 0;\\n        for (int i = str.length() - 1; i >= 0; i--) {\\n            if (str.charAt(i) != temp.charAt(i)) {\\n   \\n                differences++;\\n            }\\n        }\\n\\n        return differences;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        String str1 = Integer.toBinaryString(start);\\n        String str2 = Integer.toBinaryString(goal);\\n\\n        int lengthDifference = Math.abs(str1.length() - str2.length());\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < lengthDifference; i++) {\\n            result.append(\\'0\\');\\n        }\\n        String temp = \"\";\\n        if (str1.length() < str2.length()) {\\n            result.append(str1);\\n            temp = str2;\\n\\n        } else {\\n            result.append(str2);\\n            temp = str1;\\n        }\\n        String str = result.toString();\\n        int differences = 0;\\n        for (int i = str.length() - 1; i >= 0; i--) {\\n            if (str.charAt(i) != temp.charAt(i)) {\\n   \\n                differences++;\\n            }\\n        }\\n\\n        return differences;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071595,
                "title": "100-faster",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        res = start ^ goal\\n        s = int(str(bin(res))[2:])\\n        \\n        cnt = 0\\n        while s != 0:\\n            d = s%10\\n            if d == 1:\\n                cnt += 1\\n            s = s//10\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        res = start ^ goal\\n        s = int(str(bin(res))[2:])\\n        \\n        cnt = 0\\n        while s != 0:\\n            d = s%10\\n            if d == 1:\\n                cnt += 1\\n            s = s//10\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065881,
                "title": "php",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $start\\n     * @param Integer $goal\\n     * @return Integer\\n     */\\n    function minBitFlips($start, $goal) {\\n        return substr_count(decbin($start ^ $goal), \\'1\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $start\\n     * @param Integer $goal\\n     * @return Integer\\n     */\\n    function minBitFlips($start, $goal) {\\n        return substr_count(decbin($start ^ $goal), \\'1\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059693,
                "title": "bit-manipulation-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR start and Goal  and check  how many bits are set of that value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n= start^goal;\\n        int res=0;\\n\\n        while(n>0){\\n            n=n&(n-1);\\n            res++;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int n= start^goal;\\n        int res=0;\\n\\n        while(n>0){\\n            n=n&(n-1);\\n            res++;\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059680,
                "title": "simple-c-solution-with-xor",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int result = 0;\\n        int n = start ^ goal;\\n\\n        while (n != 0) {\\n            result += n % 2;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int result = 0;\\n        int n = start ^ goal;\\n\\n        while (n != 0) {\\n            result += n % 2;\\n            n /= 2;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059300,
                "title": "c-1-line-code-using-builtin-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int target=start^goal;\\n\\n        return __builtin_popcount(target);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int target=start^goal;\\n\\n        return __builtin_popcount(target);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054921,
                "title": "easy-bit-manipulation-beats-100-o-log-n-beginner-friendly-solution",
                "content": "# Approach\\nUsing **Bit Manipulation**:\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate XOR of **start** and **goal**: **result** = start ^ goal.\\n2. **Count** the number of set bits in the **result**.\\n3. Return the **count**.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(N));\\n    Where N is the result;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        int num = start ^ goal;\\n        while(num){\\n            if(num & 1){\\n                flips++;\\n            }\\n            num = num>>1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int flips = 0;\\n        int num = start ^ goal;\\n        while(num){\\n            if(num & 1){\\n                flips++;\\n            }\\n            num = num>>1;\\n        }\\n\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052715,
                "title": "beats-100-0ms-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       return Integer.bitCount(start^goal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047657,
                "title": "java-string-oneliner-xor",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return (int) Integer.toBinaryString(start^goal).chars().filter(ch -> ch == \\'1\\').count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        return (int) Integer.toBinaryString(start^goal).chars().filter(ch -> ch == \\'1\\').count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045442,
                "title": "very-easy-solution-beats-100-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink about XOR operator\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 XOR the given numbers.\\n2 If the bits in resultant number is 1 then it needs to be flipped as XOR of diff bits is 1.\\n3 Count the signed bits .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n    int ans=start^goal;\\n      int c=0;\\n       \\n    while(ans)\\n    {\\n        if((ans & 1)==1)\\n        c++;\\n        ans>>=1;\\n\\n    }\\n    return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n    int ans=start^goal;\\n      int c=0;\\n       \\n    while(ans)\\n    {\\n        if((ans & 1)==1)\\n        c++;\\n        ans>>=1;\\n\\n    }\\n    return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040332,
                "title": "solution-better",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        int a = start ^ goal;\\n        while(a){\\n            count += a & 1;\\n            a >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        int a = start ^ goal;\\n        while(a){\\n            count += a & 1;\\n            a >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040257,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        while (start != 0 || goal != 0) {\\n            if ((start & 1) != (goal & 1)) {\\n                count++;\\n            }\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count = 0;\\n        while (start != 0 || goal != 0) {\\n            if ((start & 1) != (goal & 1)) {\\n                count++;\\n            }\\n            \\n            start >>= 1;\\n            goal >>= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039791,
                "title": "100-one-line-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return __builtin_popcount(start^goal);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return __builtin_popcount(start^goal);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036219,
                "title": "0ms-beats-all-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBtiwise difference bitween two integers is simply XOR.\\nLater just have to count one\\'s in bit representation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://en.wikipedia.org/wiki/Hamming_weight\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minBitFlips(start int, goal int) int {\\n    x:= start^goal\\n    count:=0\\n    for ; x!=0; count++{\\n        x &= x - 1;\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc minBitFlips(start int, goal int) int {\\n    x:= start^goal\\n    count:=0\\n    for ; x!=0; count++{\\n        x &= x - 1;\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032571,
                "title": "optimised-bit-manipulation-approch",
                "content": "bi\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        //Intution Jo same hoga use nhi change karna hai\\n        //xor will give where they differ \\n        // count the difference \\n\\n        //difference means 1 if they would be same \\n        //xor will give 0\\n        int n = start^goal;\\n\\n        int flip = 0;\\n        while(n != 0){\\n            if((n&1) == 1){\\n                flip++;\\n            }\\n            n = n>>1;\\n        }\\n        return flip;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        //Intution Jo same hoga use nhi change karna hai\\n        //xor will give where they differ \\n        // count the difference \\n\\n        //difference means 1 if they would be same \\n        //xor will give 0\\n        int n = start^goal;\\n\\n        int flip = 0;\\n        while(n != 0){\\n            if((n&1) == 1){\\n                flip++;\\n            }\\n            n = n>>1;\\n        }\\n        return flip;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024457,
                "title": "python-bit-count-from-scratch",
                "content": "# Intuition\\nUsing string or built-in methods is easy.\\n\\n# Approach\\nWe will implement the bit count from scratch.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        x = start ^ goal\\n        res = 0\\n        while x:\\n            res += 1\\n            x -= x & -x\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        x = start ^ goal\\n        res = 0\\n        while x:\\n            res += 1\\n            x -= x & -x\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021510,
                "title": "easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       int n = start ^ goal;\\n       int count = 0;\\n       while(n!=0)\\n       {\\n           n = n & (n-1);\\n           count++;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       int n = start ^ goal;\\n       int count = 0;\\n       while(n!=0)\\n       {\\n           n = n & (n-1);\\n           count++;\\n       } \\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005474,
                "title": "java-simple-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = start ^ goal;\\n        int ans = 0;\\n        int rem = 0;\\n        while(xor != 0) {\\n            rem = xor % 2;\\n            if(rem == 1) {\\n                ans += 1;\\n            }\\n            xor /= 2;\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int xor = start ^ goal;\\n        int ans = 0;\\n        int rem = 0;\\n        while(xor != 0) {\\n            rem = xor % 2;\\n            if(rem == 1) {\\n                ans += 1;\\n            }\\n            xor /= 2;\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001113,
                "title": "1-line-solution-with-c-std-bitset-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ proposes a bitset class for such operations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR here is to determine number of different bits. (0^1 = 1)\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return return std::bitset<32>(start ^ goal).count();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n      return return std::bitset<32>(start ^ goal).count();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3997675,
                "title": "harshi-s-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto count number of bits differ in start and goal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nused sile & to check last bit if both are diff inc cnt and did left shift repated this until both start and goal are 0\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        while(goal>0 || start>0)\\n        {\\n            int a=start&1, b=goal&1;\\n           if(a!=b)\\n           {\\n            cnt++;\\n           }\\n           start=start>>1;\\n           goal=goal>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int cnt=0;\\n        while(goal>0 || start>0)\\n        {\\n            int a=start&1, b=goal&1;\\n           if(a!=b)\\n           {\\n            cnt++;\\n           }\\n           start=start>>1;\\n           goal=goal>>1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993478,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy look\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nxor of the both and find the set bits on xor\\'ed value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        y=start^goal\\n        c=0\\n        while(y>0):\\n            y=y&(y-1)\\n            c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        y=start^goal\\n        c=0\\n        while(y>0):\\n            y=y&(y-1)\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990329,
                "title": "simplest-and-fastest-solution-in-c-without-using-using-builtin-popcount-i",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int temp= start^goal;\\n        int count=0;\\n        while(temp){\\n            if(temp&1) count++;\\n            temp>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int temp= start^goal;\\n        int count=0;\\n        while(temp){\\n            if(temp&1) count++;\\n            temp>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989579,
                "title": "c-easy-to-understand-just-one-line-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        \\n        return __builtin_popcount(start^goal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989573,
                "title": "bit-flips-javascript-convert-to-string-2",
                "content": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let a = start.toString(2)\\n    let b = goal.toString(2)\\n    let len = Math.max(a.length, b.length)\\n    let count = 0\\n    \\n    for (let i = 0; i < len; i++) {\\n        n = a.at(-1 - i)\\n        m = b.at(-1 - i)\\n        if (n == undefined) n = 0\\n        if (m == undefined) m = 0\\n        n != m && count ++\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} start\\n * @param {number} goal\\n * @return {number}\\n */\\nvar minBitFlips = function(start, goal) {\\n    let a = start.toString(2)\\n    let b = goal.toString(2)\\n    let len = Math.max(a.length, b.length)\\n    let count = 0\\n    \\n    for (let i = 0; i < len; i++) {\\n        n = a.at(-1 - i)\\n        m = b.at(-1 - i)\\n        if (n == undefined) n = 0\\n        if (m == undefined) m = 0\\n        n != m && count ++\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3986545,
                "title": "begineers-friendly-c-beats100-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string st1 = bitset<32> (start).to_string();\\n        string st2 = bitset<32> (goal).to_string();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < st1.length(); i++){\\n            if(st1[i] != st2[i])\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        string st1 = bitset<32> (start).to_string();\\n        string st2 = bitset<32> (goal).to_string();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < st1.length(); i++){\\n            if(st1[i] != st2[i])\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984764,
                "title": "using-and-bitwise-operator-tc-o-32-o-1-c",
                "content": "# Approach\\ncompare the bits of \\u2018A\\u2019 and \\u2018B\\u2019 at each position and count the number of differences \\n\\n# Complexity\\n- Time complexity: \\n    O(32) or O(k), where k = num of bits required to represent number\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        int count=0; \\n        for(int i=0; i<32; i++) {\\n            // bit mask to check the i-th bit position of \\'A\\' and \\'B\\'.\\n            int mask= 1<<i;\\n            \\n            // extract the i-th bit of \\'A\\' and \\'B\\' by performing a bitwise AND operation between \\'A\\' and \\'B\\' with the mask.\\n            int bitA= mask & A;\\n            int bitB= mask & B;\\n            \\n            // if the i-th bit of \\'A\\' and \\'B\\' differ, increment the counter \\'count\\' to track the number of bits that need to be flipped.\\n            if(bitA!=bitB)  count++;\\n        }\\n        return count;\\n\\n        // Time Complexity : O(K), where \\'K\\' = maximum number of bits required to represent a number\\n        // Space Complexity : O(1)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int A, int B) {\\n        int count=0; \\n        for(int i=0; i<32; i++) {\\n            // bit mask to check the i-th bit position of \\'A\\' and \\'B\\'.\\n            int mask= 1<<i;\\n            \\n            // extract the i-th bit of \\'A\\' and \\'B\\' by performing a bitwise AND operation between \\'A\\' and \\'B\\' with the mask.\\n            int bitA= mask & A;\\n            int bitB= mask & B;\\n            \\n            // if the i-th bit of \\'A\\' and \\'B\\' differ, increment the counter \\'count\\' to track the number of bits that need to be flipped.\\n            if(bitA!=bitB)  count++;\\n        }\\n        return count;\\n\\n        // Time Complexity : O(K), where \\'K\\' = maximum number of bits required to represent a number\\n        // Space Complexity : O(1)\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984591,
                "title": "easy-4-line-cpp-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start>0 || goal>0){\\n            if((start&1==1)!=(goal&1==1))count++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal) {\\n        int count=0;\\n        while(start>0 || goal>0){\\n            if((start&1==1)!=(goal&1==1))count++;\\n            start=start>>1;\\n            goal=goal>>1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983029,
                "title": "c-minimum-bit-flips-to-convert-number-using-xor",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe calculate the XOR of A and B to find the differing bits between them.\\nWe then loop through the XOR result bit by bit (right to left) using bitwise operations.\\nFor each bit, we check if it\\'s set (1) and increment the count if it is.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal)\\n    {\\n        int count = 0;\\n        int XOR = start^goal;\\n        \\n        while(XOR!=0)\\n        {\\n            count = count+(XOR&1);\\n            XOR = XOR>>1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minBitFlips(int start, int goal)\\n    {\\n        int count = 0;\\n        int XOR = start^goal;\\n        \\n        while(XOR!=0)\\n        {\\n            count = count+(XOR&1);\\n            XOR = XOR>>1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981889,
                "title": "java-code-string-builder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       String s=Integer.toBinaryString(goal); \\n       String sa=Integer.toBinaryString(start); \\n       StringBuilder sb =new StringBuilder();\\n       int m=Math.max(sa.length(), s.length());\\n       int count=0;\\n       while (s.length() < m) {\\n            s = \"0\" + s;\\n        }\\n        while (sa.length() < m) {\\n            sa = \"0\" + sa;\\n        }\\n\\n       for(int i= m-1 ;i>=0;i--){\\n           if(s.charAt(i)!=sa.charAt(i)){\\n               sb.append(s.charAt(i));\\n               count++;\\n               if(sb.toString().equals(s)){\\n                   return count;\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n       String s=Integer.toBinaryString(goal); \\n       String sa=Integer.toBinaryString(start); \\n       StringBuilder sb =new StringBuilder();\\n       int m=Math.max(sa.length(), s.length());\\n       int count=0;\\n       while (s.length() < m) {\\n            s = \"0\" + s;\\n        }\\n        while (sa.length() < m) {\\n            sa = \"0\" + sa;\\n        }\\n\\n       for(int i= m-1 ;i>=0;i--){\\n           if(s.charAt(i)!=sa.charAt(i)){\\n               sb.append(s.charAt(i));\\n               count++;\\n               if(sb.toString().equals(s)){\\n                   return count;\\n               }\\n           }\\n       }\\n       return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892286,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1711670,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1711381,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1782548,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1958122,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1806696,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            },
            {
                "id": 1685889,
                "content": [
                    {
                        "username": "Unpredictable007",
                        "content": "This is exactly the same problem as https://leetcode.com/problems/hamming-distance/ but with different description :)"
                    },
                    {
                        "username": "bparanj",
                        "content": "\"Minimum Number of Bit Flips to Convert Integer\" can be mapped to \"Hamming Distance\".\\n\\nThe reasoning behind this mapping is that both problems involve comparing the binary representations of two numbers. \\n\\n\"Hamming Distance\" calculates the number of positions at which the corresponding bits are different. So, if we want to convert one number to another, the minimum number of bit flips would be exactly those positions where the two numbers have differing bits. This is equivalent to calculating the Hamming distance between the two numbers.\\n\\nThe \"Minimum Number of Bit Flips to Convert Integer\" problem is simpler, as it doesn\\'t require the calculation of the exact positions of differing bits, just the count of them.\\n\\nA more complex problem would be \"Flip Bits to Maximize Number of 1\\'s\". In this problem, you are given a binary string and you can flip \\'k\\' bits from 0 to 1 with the goal to maximize the number of 1s in the string. This is more complex as it requires more than counting differing bits, it also needs strategic flipping to maximize the outcome.\\n"
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "XOR is my amor ;)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "XOR might help to get number of different bits between two number,\\nsince in XOR gives 1 for every two different bits and 0 for same bits!!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Has anyone good articles to understand XOR, like I get what it does but it never strikes me in problems how to use it. "
                    },
                    {
                        "username": "cnewman111",
                        "content": "Cracking the coding interview has good straightforward  explanations and problems to help get your feet wet"
                    },
                    {
                        "username": "prototye",
                        "content": "Replying really late, but if u still struggle with bit manipulation consider reading this post, it helped me understanding bit manipulation. Also this is not my post so no self promotion : https://leetcode.com/tag/bit-manipulation/discuss/2960396/Bit-Manipulation-Guide-and-Tricks"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "\\uD83D\\uDE80 Check this solution: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/3724804/one-of-the-most-easiest-solutions/"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2220.%20Minimum%20Bit%20Flips%20to%20Convert%20Number.cpp\\nALL LEETCODE SOLUTION IN C++\\nPlease LEAVE A STAR"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDC4B CPP EZ Amazon + Google\\uD83D\\uDE2C Interview O(set bits)\\nhttps://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/2298518/cpp-ez-amazon-google-interview-o-set-bits/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Trailing Zeros in a Cornered Path",
        "question_content": "<p>You are given a 2D integer array <code>grid</code> of size <code>m x n</code>, where each cell contains a positive integer.</p>\n\n<p>A <strong>cornered path</strong> is defined as a set of adjacent cells with <strong>at most</strong> one turn. More specifically, the path should exclusively move either <strong>horizontally</strong> or <strong>vertically</strong> up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the <strong>alternate</strong> direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.</p>\n\n<p>The <strong>product</strong> of a path is defined as the product of all the values in the path.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of <strong>trailing zeros</strong> in the product of a cornered path found in </em><code>grid</code>.</p>\n\n<p>Note:</p>\n\n<ul>\n\t<li><strong>Horizontal</strong> movement means moving in either the left or right direction.</li>\n\t<li><strong>Vertical</strong> movement means moving in either the up or down direction.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg\" style=\"width: 577px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg\" style=\"width: 150px; height: 157px;\" />\n<pre>\n<strong>Input:</strong> grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1955515,
                "title": "prefix-sum-of-factors-2-and-5",
                "content": "The approach is not too hard to get, but the implementation is such a tongue-twister (or fingers-twister, I should say).\\n\\nFirst, instead of multiplication, we just need to sum factors of `2` and `5`. Each pair of those factors produce one trailing zero.\\n\\nWe use grids `h` and `v` to compute prefix sum for each horizontal and vertical line in the grid. Note that we store the count of each factor separatelly. \\n\\nThen, for each position in the grid, we check four paths: `v1 + h1`, `v1 + h2`, `v2 + h1`, `v2 + h2`.\\n\\nWe count factors for each path, and track the maximum number of factor pairs (each pair gives us a trailing zero).\\n\\n> I am not sure if we can use one grid instead of `v` and `h` and do some clever deduction, but the solution is already hard to debug with two grids. \\n\\nThis is how the prefix sum grids look like for example 1 (see problem description), with the visualization for `v1`, `v2`, `h1` and `h2` sub-paths.\\n\\n![image](https://assets.leetcode.com/users/images/881c18fd-0d0a-4b02-9f1e-06ccb0882df7_1650190116.5992572.png)\\n\\n**C++**\\n```cpp\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\nint factors(int i, int f) {\\n    return i % f ? 0 : 1 + factors(i / f, f);\\n}\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size(), res = 0;\\n    vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n            v[i + 1][j] = v[i][j] + f25;\\n            h[i][j + 1] = h[i][j] + f25;\\n        }\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n            auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n            res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n        }\\n    return res;\\n}\\n};\\n```\\n**Complexity Analysis**\\n- Time: O(n * m); we go through the grid twice; prefix sum grids allow computing zeros in O(1).\\n- Memory: O(n * m) for prefix sum grids.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\nint factors(int i, int f) {\\n    return i % f ? 0 : 1 + factors(i / f, f);\\n}\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size(), res = 0;\\n    vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n            v[i + 1][j] = v[i][j] + f25;\\n            h[i][j + 1] = h[i][j] + f25;\\n        }\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n            auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n            res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n        }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955347,
                "title": "c-easy-to-understand-simple-prefix-sum-greedy-approach",
                "content": "**Approach is very simple but the implementation needed some level of patience.**\\n\\n**we first create a matrix with the number of factors of 2\\'s and 5\\'s in each of the grids of the given matrix. I used vector<vector<pair<int,int>>> v , to do the same.**\\n\\n**Then, we are creating 4 prefix sum matrices(of the number of 2\\'s and 5\\'s) which will store the value of the prefixsum from left to right(named as ltr), right to left(rtl), up to down(utd) and down to up(dtu). After creating the matrices we will be iterating through the v and finding the maximum of the minimum of 2\\'s and 5\\'s on the 4 possible cases (utd+ltr),(utd+rtl),(dtu+ltr),(dtu+rtl) and that maximum will be our answer.**\\n\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955607,
                "title": "python-explanation-with-pictures-prefix-sum",
                "content": "Please also refer to [votrubac](https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5) \\'s solution as he has a perfect picture explanation of prefix sum.\\n\\nLet\\'s focus on the pivot point of an edge, once the pivot point is fixed, the edge can only from the four cases below.\\n\\n![image](https://assets.leetcode.com/users/images/b91a94f3-ca21-49d7-af85-662f80023fa0_1650169235.6731899.png)\\n\\nIt look familiar, we can build two (or four if you prefer) prefix sum array to save the cumulative factors. \\nImagine we build `left` to save the all the factors in the same row on `A[i][j]`\\'s left, and build `top` to save all the factors in the same colomn on `A[i][j]`\\'s top. Notice we might add or minus the `A[i][j]` itself twice.\\n\\n\\n![image](https://assets.leetcode.com/users/images/20d53765-2b44-455b-90d4-c44d94c7388d_1650169239.717305.png)\\n\\nWe only need to save the number of two factors: `2, 5`. It\\'s quite straightforward to get the number of trailing zeros from these numbers of factors.\\n\\n![image](https://assets.leetcode.com/users/images/2f0cb380-ecfa-4364-b91b-30f43ed6f418_1650170082.105669.png)\\n\\n> In case I didn\\'t explain it well.\\n> `a->[2\\'s, 5\\'s]`\\n> 40 = 2\\\\*2\\\\*2\\\\*5, three 2\\'s and one 5, thus we let `40=[3,1]`\\n> Similarly, `23=[0,0]` since it has no factor as 2 or 5, \\n> `1500=3\\\\*2\\\\*2\\\\*5\\\\*5\\\\*5`, thus we let `1500=[2,3]` \\n> Hence, `40*23*1500` has `[5,4]` which makes 4 trailing zeros.\\n\\n**complexity**\\nTime: O(n)\\nSpace: O(n)\\n\\n**code**\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        left = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        top = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        \\n        def helper(num):\\n            a, b = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                a += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                b += 1\\n            return [a, b]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left[i][j] = helper(A[i][j])\\n                else:\\n                    a, b = helper(A[i][j])\\n                    left[i][j][0] = left[i][j - 1][0] + a\\n                    left[i][j][1] = left[i][j - 1][1] + b\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    top[i][j] = helper(A[i][j])\\n                else:\\n                    a, b, = helper(A[i][j])\\n                    top[i][j][0] = top[i - 1][j][0] + a               \\n                    top[i][j][1] = top[i - 1][j][1] + b\\n\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                a, b = top[m - 1][j]\\n                d, e= left[i][n - 1]\\n                x, y = helper(A[i][j])\\n                a1, b1 = top[i][j]\\n                a2, b2= left[i][j]\\n                tmp = [a1 + a2 - x, b1 + b2 - y]\\n                ans = max(ans, min(tmp))\\n                tmp = [d - a2 + a1, e - b2 + b1]\\n                ans = max(ans, min(tmp))             \\n                tmp = [a - a1 + a2, b - b1 + b2]\\n                ans = max(ans, min(tmp))\\n                tmp = [a + d - a1 - a2 + x, b + e - b1 - b2 + y]\\n                ans = max(ans, min(tmp))\\n                \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        left = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        top = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n        \\n        def helper(num):\\n            a, b = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                a += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                b += 1\\n            return [a, b]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left[i][j] = helper(A[i][j])\\n                else:\\n                    a, b = helper(A[i][j])\\n                    left[i][j][0] = left[i][j - 1][0] + a\\n                    left[i][j][1] = left[i][j - 1][1] + b\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    top[i][j] = helper(A[i][j])\\n                else:\\n                    a, b, = helper(A[i][j])\\n                    top[i][j][0] = top[i - 1][j][0] + a               \\n                    top[i][j][1] = top[i - 1][j][1] + b\\n\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                a, b = top[m - 1][j]\\n                d, e= left[i][n - 1]\\n                x, y = helper(A[i][j])\\n                a1, b1 = top[i][j]\\n                a2, b2= left[i][j]\\n                tmp = [a1 + a2 - x, b1 + b2 - y]\\n                ans = max(ans, min(tmp))\\n                tmp = [d - a2 + a1, e - b2 + b1]\\n                ans = max(ans, min(tmp))             \\n                tmp = [a - a1 + a2, b - b1 + b2]\\n                ans = max(ans, min(tmp))\\n                tmp = [a + d - a1 - a2 + x, b + e - b1 - b2 + y]\\n                ans = max(ans, min(tmp))\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959385,
                "title": "7-lines-python-numpy",
                "content": "Perfect opportunity to practice NumPy. Gets accepted in ~2200 ms, seems relatively fast. Actual time is about 900 ms, judge overhead is ~1300 here. See benchmark in the comments.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```\\nMy helper function `cumdivs` first computes divisibility by divisor 2 or 5, as that\\'s the factors we need to get zeros: It counts for each value in the grid how often it is divisible by divisor `d`. I try up to 9 times, since 2<sup>9</sup>=512 is the largest possible (since the numbers are guaranteed to not exceed 1000). Then it computes and combines the cumulative sums of the divisibilities on both axes (and subtracts each value\\'s divisibility in order to not double-count it).\\n\\nThat only covers one pair of directions. So I do it four times, rotating the matrix by 90 degrees in between.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        A = np.array(grid)\\n        def cumdivs(d):\\n            D = sum(A % d**i == 0 for i in range(1, 10))\\n            return D.cumsum(0) + D.cumsum(1) - D\\n        return max(np.minimum(cumdivs(2), cumdivs(5)).max()\\n                   for _ in range(4)\\n                   if [A := np.rot90(A)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956213,
                "title": "c-prefix-sum-easy-to-understand-beats-100-space-and-time",
                "content": "* **Explanation:**\\n\\t* Consider every element of the grid as the corner point of the cornered path. Now there can be four possible ways of making an \\'L\\' Shape figure. \\n\\t* \\tWe need to make **prefix matrices of pairs** to store the prefix sum of exponent of 5\\'s and 2\\'s of each element in the grid, otherwise if we store the whole multiplication result, then it would create integer overflow.\\n\\t * And **we need only two prefix matrices**, because the result of other two sides will be calculated by subtracting from total sum of that side. \\t\\n\\t * To get the count of trailing 0\\'s we have to take the minimum of count of 5 and 2 from the pairs.\\n\\t * The case of 0 turns that is horizontally straight or vertically straight path will be handled automatically by prefix sum matrix.\\n\\n* **Time Complexity: O(MxN)**\\n* **Space Complexity: O(MxN)**\\n\\n```\\n\\t//to get the exponent of 5 and 2 in the number\\n    pair<int,int> getPair(int x){\\n        int five = 0, two = 0;\\n        while(x % 5 == 0){\\n            five++; x /= 5;\\n        }\\n        while(x % 2 == 0){\\n            two++; x /= 2;\\n        }\\n        return {five,two};\\n    } \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        vector<vector<pair<int,int>>>top(r, vector<pair<int,int>>(c,{0,0})), left(r, vector<pair<int,int>>(c,{0,0}));\\n        \\n        //top[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[0][j] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(i == 0) top[i][j] = getPair(grid[i][j]);\\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    top[i][j].first = top[i-1][j].first + p.first;\\n                    top[i][j].second = top[i-1][j].second + p.second;\\n                }\\n            }\\n        }\\n        //left[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[i][0] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(j == 0) left[i][j] = getPair(grid[i][j]); \\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    left[i][j].first = left[i][j-1].first + p.first;\\n                    left[i][j].second = left[i][j-1].second + p.second;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                pair<int,int>down, right;\\n                pair<int,int>curr = getPair(grid[i][j]);\\n                \\n                down.first = top[r-1][j].first - top[i][j].first, down.second = top[r-1][j].second - top[i][j].second;\\n                right.first = left[i][c-1].first - left[i][j].first, right.second = left[i][c-1].second - left[i][j].second;\\n                                \\n                //four cases ---> (down,left), (down,right), (top,left), (top,right)\\n                ans = max(ans, min(down.first + left[i][j].first, down.second + left[i][j].second));\\n                ans = max(ans, min(down.first + right.first + curr.first, down.second + right.second + curr.second));\\n                ans = max(ans, min(top[i][j].first + left[i][j].first - curr.first, top[i][j].second + left[i][j].second - curr.second));\\n                ans = max(ans, min(top[i][j].first + right.first, top[i][j].second + right.second));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t//to get the exponent of 5 and 2 in the number\\n    pair<int,int> getPair(int x){\\n        int five = 0, two = 0;\\n        while(x % 5 == 0){\\n            five++; x /= 5;\\n        }\\n        while(x % 2 == 0){\\n            two++; x /= 2;\\n        }\\n        return {five,two};\\n    } \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        vector<vector<pair<int,int>>>top(r, vector<pair<int,int>>(c,{0,0})), left(r, vector<pair<int,int>>(c,{0,0}));\\n        \\n        //top[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[0][j] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(i == 0) top[i][j] = getPair(grid[i][j]);\\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    top[i][j].first = top[i-1][j].first + p.first;\\n                    top[i][j].second = top[i-1][j].second + p.second;\\n                }\\n            }\\n        }\\n        //left[i][j] will store sum of exponent of 5\\'s and 2\\'s from grid[i][0] to grid[i][j]\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                if(j == 0) left[i][j] = getPair(grid[i][j]); \\n                else{\\n                    pair<int,int>p = getPair(grid[i][j]);\\n                    left[i][j].first = left[i][j-1].first + p.first;\\n                    left[i][j].second = left[i][j-1].second + p.second;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c; j++){\\n                pair<int,int>down, right;\\n                pair<int,int>curr = getPair(grid[i][j]);\\n                \\n                down.first = top[r-1][j].first - top[i][j].first, down.second = top[r-1][j].second - top[i][j].second;\\n                right.first = left[i][c-1].first - left[i][j].first, right.second = left[i][c-1].second - left[i][j].second;\\n                                \\n                //four cases ---> (down,left), (down,right), (top,left), (top,right)\\n                ans = max(ans, min(down.first + left[i][j].first, down.second + left[i][j].second));\\n                ans = max(ans, min(down.first + right.first + curr.first, down.second + right.second + curr.second));\\n                ans = max(ans, min(top[i][j].first + left[i][j].first - curr.first, top[i][j].second + left[i][j].second - curr.second));\\n                ans = max(ans, min(top[i][j].first + right.first, top[i][j].second + right.second));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960982,
                "title": "c-100-fastest-easy-understanding-with-picture",
                "content": "This question is asking about \\n* \"Trailing zeros\"\\n* \"Cornered Path\"\\n\\n**Basic idea 1: we only care about the count of 2 and the count of 5.**\\nFor instance, if we have \"{2,8,10,30}\" => 2 x 8 x10x 30 = 4800 => trailing zeros = 2\\nWe can transfer this array into the count of 2 and 5\\ncount of 2: {1,3,1,2} => prefix sum of 2: {1,4,5,7}\\ncount of 5: {0,0,1,1} => prefix sum of 5: {0,0,1,2}\\nTherefore, the trailing zeros will be  minimum(7,2) = 2\\n\\nAfter basic idea 1, we can create two matrix\\nQuestion\\n![image](https://assets.leetcode.com/users/images/23cf94ee-e461-4556-9e3d-d6183b8e781c_1650289746.9719374.png)\\n\\nTrafnser into\\n![image](https://assets.leetcode.com/users/images/1615924b-86bd-4fc3-92fd-686101bfde57_1650289803.599491.png)\\n![image](https://assets.leetcode.com/users/images/373ff873-ab78-4ff2-bf51-c238700f43e8_1650289818.1484864.png)\\n\\n\\n**Basic idea 2: Cornered Path**\\n![image](https://assets.leetcode.com/users/images/f39b0c56-2fc4-45c2-ba12-48c575d5b7ce_1650290157.0635967.png)\\nThe answer will be the minimun of these for cases.\\n\\nWe can use \"Horizontal prefix sum\" matrix and \"Vertical prefix sum\" matrix ot get the result of these four cases.\\n![image](https://assets.leetcode.com/users/images/964cf894-c5a7-4b77-a141-52800833a1a4_1650290857.2102344.png)\\n\\nFor example, we can use prefix sum to gernerate a result\\nthe result will be min( horizontal2, horizantal 5) + min (vertical 2, vertical 5)\\n![image](https://assets.leetcode.com/users/images/f70197a9-02b1-4a20-9b7e-616255e439c8_1650291569.4562247.png)\\n\\nIn this case, the answer will be\\nmin (3,1) + min(3,2) = 1 + 2 = 3\\n\\nThat\\'s the whole idea!\\n\\n\\n**My implementation:**\\n\\n```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n\\t\\t// gernerate matrix of 2 and matrix of 5\\n        vector< vector<int> > dp2(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[i].size(); j++) {\\n                int tmp = grid[i][j];\\n                while (tmp % 2 == 0) {\\n                    tmp = tmp / 2;\\n                    dp2[i][j]++;\\n                }\\n                while (tmp % 5 == 0) {\\n                    tmp = tmp / 5;\\n                    dp5[i][j]++;\\n                }\\n            }\\n        }        \\n        \\n        vector< vector<int> > dp2HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n\\t\\t// Generate horizontal prefix sum array\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (j == 0) {\\n                    dp2HorizontalSum[i][j] = dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2HorizontalSum[i][j] = dp2HorizontalSum[i][j - 1] + dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5HorizontalSum[i][j - 1] + dp5[i][j];\\n                }\\n\\n            }\\n        }    \\n        \\n\\t\\t// Generate vertical prefix sum array\\n        vector< vector<int> > dp2VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (i == 0) {\\n                    dp2VerticalSum[i][j] = dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2VerticalSum[i][j] = dp2VerticalSum[i - 1][j] + dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5VerticalSum[i - 1][j] + dp5[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Iterate every element and pick the biggest one to be the result.\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                int dp2H1 = dp2HorizontalSum[i][j];\\n                int dp2H2 = dp2HorizontalSum[i][dp2[0].size() -1] - dp2HorizontalSum[i][j] + dp2[i][j];\\n                int dp2V1 = dp2VerticalSum[i][j];\\n                int dp2V2 = dp2VerticalSum[dp2.size() - 1][j] - dp2VerticalSum[i][j] + dp2[i][j];\\n                \\n                int dp5H1 = dp5HorizontalSum[i][j];\\n                int dp5H2 = dp5HorizontalSum[i][dp5[0].size()  -1] - dp5HorizontalSum[i][j] + dp5[i][j];\\n                int dp5V1 = dp5VerticalSum[i][j];\\n                int dp5V2 = dp5VerticalSum[dp5.size() - 1][j] - dp5VerticalSum[i][j] + dp5[i][j];\\n                \\n                int tmp = max(  min(dp2H1 + dp2V1 - dp2[i][j], dp5H1 + dp5V1 - dp5[i][j]), min(dp2H1 + dp2V2 - dp2[i][j], dp5H1 + dp5V2 - dp5[i][j]) );\\n                tmp = max(tmp, min(dp2H2 + dp2V1 - dp2[i][j], dp5H2 + dp5V1 - dp5[i][j]));\\n                tmp = max(tmp, min(dp2H2 + dp2V2 - dp2[i][j], dp5H2 + dp5V2 - dp5[i][j]));\\n                \\n                if (tmp > result) {\\n                    result = tmp;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n\\t\\t// gernerate matrix of 2 and matrix of 5\\n        vector< vector<int> > dp2(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[i].size(); j++) {\\n                int tmp = grid[i][j];\\n                while (tmp % 2 == 0) {\\n                    tmp = tmp / 2;\\n                    dp2[i][j]++;\\n                }\\n                while (tmp % 5 == 0) {\\n                    tmp = tmp / 5;\\n                    dp5[i][j]++;\\n                }\\n            }\\n        }        \\n        \\n        vector< vector<int> > dp2HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5HorizontalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n\\t\\t// Generate horizontal prefix sum array\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (j == 0) {\\n                    dp2HorizontalSum[i][j] = dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2HorizontalSum[i][j] = dp2HorizontalSum[i][j - 1] + dp2[i][j];\\n                    dp5HorizontalSum[i][j] = dp5HorizontalSum[i][j - 1] + dp5[i][j];\\n                }\\n\\n            }\\n        }    \\n        \\n\\t\\t// Generate vertical prefix sum array\\n        vector< vector<int> > dp2VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector< vector<int> > dp5VerticalSum(grid.size(), vector<int>(grid[0].size(), 0));\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                if (i == 0) {\\n                    dp2VerticalSum[i][j] = dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5[i][j];\\n                } else {\\n                    dp2VerticalSum[i][j] = dp2VerticalSum[i - 1][j] + dp2[i][j];\\n                    dp5VerticalSum[i][j] = dp5VerticalSum[i - 1][j] + dp5[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Iterate every element and pick the biggest one to be the result.\\n        for (int i = 0; i < dp2.size(); i++) {\\n            for (int j = 0; j < dp2[0].size(); j++) {\\n                int dp2H1 = dp2HorizontalSum[i][j];\\n                int dp2H2 = dp2HorizontalSum[i][dp2[0].size() -1] - dp2HorizontalSum[i][j] + dp2[i][j];\\n                int dp2V1 = dp2VerticalSum[i][j];\\n                int dp2V2 = dp2VerticalSum[dp2.size() - 1][j] - dp2VerticalSum[i][j] + dp2[i][j];\\n                \\n                int dp5H1 = dp5HorizontalSum[i][j];\\n                int dp5H2 = dp5HorizontalSum[i][dp5[0].size()  -1] - dp5HorizontalSum[i][j] + dp5[i][j];\\n                int dp5V1 = dp5VerticalSum[i][j];\\n                int dp5V2 = dp5VerticalSum[dp5.size() - 1][j] - dp5VerticalSum[i][j] + dp5[i][j];\\n                \\n                int tmp = max(  min(dp2H1 + dp2V1 - dp2[i][j], dp5H1 + dp5V1 - dp5[i][j]), min(dp2H1 + dp2V2 - dp2[i][j], dp5H1 + dp5V2 - dp5[i][j]) );\\n                tmp = max(tmp, min(dp2H2 + dp2V1 - dp2[i][j], dp5H2 + dp5V1 - dp5[i][j]));\\n                tmp = max(tmp, min(dp2H2 + dp2V2 - dp2[i][j], dp5H2 + dp5V2 - dp5[i][j]));\\n                \\n                if (tmp > result) {\\n                    result = tmp;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955466,
                "title": "213ms-java-prefix-sum-solution-with-clear-comment-vertical-or-horizontal-or-l-j-7-directions",
                "content": "```\\npublic int maxTrailingZeros(int[][] grid) {\\n        //trailing 0, 10->1, 100->2\\n        //10 = 2 * 5\\n        //100 = 2*2*5*5\\n        //etc.\\n        //min(countOf2,countOf5);\\n\\t\\t//Part 1: move only horizontal\\n\\t\\t//Part 2: move only vertically\\n        //Part 3: one L turn\\n        //Part 4: one 7 turn\\n        //Part 5: one J turn\\n        //Part 6: one |` turn\\n        \\n\\t\\t//Create PrefixSum array to store count of 2 and 5, then we need O(1) time to get count of 2 or 5.\\n        //matrix count of 2, in row i, from j to k (j<=k) matrix2[i+1][k+1] - matrix2[i+1][j]\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] matrix2row = new int[m+1][n+1];\\n        int[][] matrix5row = new int[m+1][n+1];\\n        //matrix count of 2, in col i, from j to k (j<=k) matrix[k+1][i+1] - matrix[j][i+1]\\n        int[][] matrix2col = new int[m+1][n+1];\\n        int[][] matrix5col = new int[m+1][n+1];\\n        for(int i = 0;i<grid.length;i++){\\n            // System.out.println(Arrays.toString(grid[i]));\\n            for(int j = 0;j<grid[0].length;j++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                // System.out.println(\"grid[\"+i+\"]\"+\"[\"+j+\"]=\"+\"grid[i][j]\"+\",count2:\"+count2);\\n                matrix2row[i+1][j+1] = matrix2row[i+1][j] + count2; \\n                matrix5row[i+1][j+1] = matrix5row[i+1][j] + count5; \\n            }\\n        }\\n        for(int j = 0;j<grid[0].length;j++){\\n            for(int i = 0;i<grid.length;i++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                matrix2col[i+1][j+1] = matrix2col[i][j+1] + count2;\\n                matrix5col[i+1][j+1] = matrix5col[i][j+1] + count5;\\n            }\\n        }\\n        //Part 1: move only horizontal \\n        //grid[0][0]->grid[0][n-1]\\n        //grid[1][0]->grid[1][n-1]\\n        //...\\n        //grid[m-1][0]->grid[m-1][n-1]\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            int count2 = matrix2row[i+1][n]-matrix2row[i+1][0];\\n            int count5 = matrix5row[i+1][n]-matrix5row[i+1][0];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        \\n        //Part 2: move only vertically\\n        //grid[0][0]->grid[m-1][0]\\n        //grid[0][1]->grid[m-1][1]\\n        //...\\n        //grid[0][n-1]->grid[m-1][n-1]\\n        for(int j = 0;j<n;j++){\\n            int count2 = matrix2col[m][j+1] - matrix2col[0][j+1];\\n            int count5 = matrix5col[m][j+1] - matrix5col[0][j+1];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        //Find center of + then there are 4 directions\\n        for(int i = 0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                \\n                //up (i,j) to (0,j)\\n                int count2Up = matrix2col[i+1][j+1] - matrix2col[0][j+1];\\n                int count5Up = matrix5col[i+1][j+1] - matrix5col[0][j+1];\\n                //down (i,j) to (m-1,j)\\n                int count2Down = matrix2col[m][j+1] - matrix2col[i][j+1];\\n                int count5Down = matrix5col[m][j+1] - matrix5col[i][j+1];\\n                //left (i,0) to (i,j)\\n                int count2Left = matrix2row[i+1][j+1]-matrix2row[i+1][0];\\n                int count5Left = matrix5row[i+1][j+1]-matrix5row[i+1][0];\\n                //right (i,j) to (i,n-1)\\n                int count2Right = matrix2row[i+1][n]-matrix2row[i+1][j];\\n                int count5Right = matrix5row[i+1][n]-matrix5row[i+1][j];\\n                //3.1 L turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Right-count2(grid[i][j]),count5Up+count5Right-count5(grid[i][j])));\\n                //3.2 7 turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Left-count2(grid[i][j]),count5Up+count5Left-count5(grid[i][j])));\\n                //3.3 |` turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Right-count2(grid[i][j]),count5Down+count5Right-count5(grid[i][j])));\\n                //3.4 J turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Left-count2(grid[i][j]),count5Down+count5Left-count5(grid[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int count2 (int x){\\n        int count = 0;\\n        while(x % 2 == 0){\\n            count++;\\n            x = x / 2;\\n        }\\n        return count;\\n    }\\n    \\n    public int count5 (int x){\\n        int count = 0;\\n        while(x % 5 == 0){\\n            count++;\\n            x = x / 5;\\n        }\\n        return count;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int maxTrailingZeros(int[][] grid) {\\n        //trailing 0, 10->1, 100->2\\n        //10 = 2 * 5\\n        //100 = 2*2*5*5\\n        //etc.\\n        //min(countOf2,countOf5);\\n\\t\\t//Part 1: move only horizontal\\n\\t\\t//Part 2: move only vertically\\n        //Part 3: one L turn\\n        //Part 4: one 7 turn\\n        //Part 5: one J turn\\n        //Part 6: one |` turn\\n        \\n\\t\\t//Create PrefixSum array to store count of 2 and 5, then we need O(1) time to get count of 2 or 5.\\n        //matrix count of 2, in row i, from j to k (j<=k) matrix2[i+1][k+1] - matrix2[i+1][j]\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] matrix2row = new int[m+1][n+1];\\n        int[][] matrix5row = new int[m+1][n+1];\\n        //matrix count of 2, in col i, from j to k (j<=k) matrix[k+1][i+1] - matrix[j][i+1]\\n        int[][] matrix2col = new int[m+1][n+1];\\n        int[][] matrix5col = new int[m+1][n+1];\\n        for(int i = 0;i<grid.length;i++){\\n            // System.out.println(Arrays.toString(grid[i]));\\n            for(int j = 0;j<grid[0].length;j++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                // System.out.println(\"grid[\"+i+\"]\"+\"[\"+j+\"]=\"+\"grid[i][j]\"+\",count2:\"+count2);\\n                matrix2row[i+1][j+1] = matrix2row[i+1][j] + count2; \\n                matrix5row[i+1][j+1] = matrix5row[i+1][j] + count5; \\n            }\\n        }\\n        for(int j = 0;j<grid[0].length;j++){\\n            for(int i = 0;i<grid.length;i++){\\n                int count2 = count2(grid[i][j]);\\n                int count5 = count5(grid[i][j]);\\n                matrix2col[i+1][j+1] = matrix2col[i][j+1] + count2;\\n                matrix5col[i+1][j+1] = matrix5col[i][j+1] + count5;\\n            }\\n        }\\n        //Part 1: move only horizontal \\n        //grid[0][0]->grid[0][n-1]\\n        //grid[1][0]->grid[1][n-1]\\n        //...\\n        //grid[m-1][0]->grid[m-1][n-1]\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            int count2 = matrix2row[i+1][n]-matrix2row[i+1][0];\\n            int count5 = matrix5row[i+1][n]-matrix5row[i+1][0];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        \\n        //Part 2: move only vertically\\n        //grid[0][0]->grid[m-1][0]\\n        //grid[0][1]->grid[m-1][1]\\n        //...\\n        //grid[0][n-1]->grid[m-1][n-1]\\n        for(int j = 0;j<n;j++){\\n            int count2 = matrix2col[m][j+1] - matrix2col[0][j+1];\\n            int count5 = matrix5col[m][j+1] - matrix5col[0][j+1];\\n            ans = Math.max(ans, Math.min(count2,count5));\\n        }\\n        //Find center of + then there are 4 directions\\n        for(int i = 0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                \\n                //up (i,j) to (0,j)\\n                int count2Up = matrix2col[i+1][j+1] - matrix2col[0][j+1];\\n                int count5Up = matrix5col[i+1][j+1] - matrix5col[0][j+1];\\n                //down (i,j) to (m-1,j)\\n                int count2Down = matrix2col[m][j+1] - matrix2col[i][j+1];\\n                int count5Down = matrix5col[m][j+1] - matrix5col[i][j+1];\\n                //left (i,0) to (i,j)\\n                int count2Left = matrix2row[i+1][j+1]-matrix2row[i+1][0];\\n                int count5Left = matrix5row[i+1][j+1]-matrix5row[i+1][0];\\n                //right (i,j) to (i,n-1)\\n                int count2Right = matrix2row[i+1][n]-matrix2row[i+1][j];\\n                int count5Right = matrix5row[i+1][n]-matrix5row[i+1][j];\\n                //3.1 L turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Right-count2(grid[i][j]),count5Up+count5Right-count5(grid[i][j])));\\n                //3.2 7 turn\\n                ans = Math.max(ans,Math.min(count2Up+count2Left-count2(grid[i][j]),count5Up+count5Left-count5(grid[i][j])));\\n                //3.3 |` turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Right-count2(grid[i][j]),count5Down+count5Right-count5(grid[i][j])));\\n                //3.4 J turn\\n                ans = Math.max(ans,Math.min(count2Down+count2Left-count2(grid[i][j]),count5Down+count5Left-count5(grid[i][j])));\\n            }\\n        }\\n        return ans;\\n    }\\n    public int count2 (int x){\\n        int count = 0;\\n        while(x % 2 == 0){\\n            count++;\\n            x = x / 2;\\n        }\\n        return count;\\n    }\\n    \\n    public int count5 (int x){\\n        int count = 0;\\n        while(x % 5 == 0){\\n            count++;\\n            x = x / 5;\\n        }\\n        return count;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2836045,
                "title": "c-solutions",
                "content": "```\\n\\tclass Solution {\\npublic:\\n\\npair<long long,long long> util(int val){\\n    \\n    int x=0;\\n    while(val>0 && val%5==0){\\n        val=val/5;\\n        x++;\\n    }\\n    int y=0;\\n    while(val>0 && val%2==0){\\n        val=val/2;\\n        y++;\\n    }\\n    return {x,y};\\n    \\n}\\n\\nlong long util(vector<vector<int>>& grid){\\n    \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    pair<long long,long long> matrix[n][m];\\n    pair<long long,long long> matrix1[n][m];\\n    pair<long long,long long> matrix2[n][m];\\n    \\n    //making the first grid;\\n    for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++){\\n            int val=grid[i][j];\\n            matrix[i][j]=util(val);\\n        }\\n    \\n    //right to left\\n    for(int i=0;i<n;i++){\\n        for(int j=m-1;j>=0;j--){\\n            if(j==m-1)\\n                matrix1[i][j]=matrix[i][j];\\n            else\\n                matrix1[i][j]={matrix[i][j].first+matrix1[i][j+1].first,matrix[i][j].second+matrix1[i][j+1].second};\\n\\n        }\\n    }\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(j==0)\\n                matrix2[i][j]=matrix[i][j];\\n            else\\n                matrix2[i][j]={matrix[i][j].first+matrix2[i][j-1].first,matrix[i][j].second+matrix2[i][j-1].second};\\n        }\\n    }\\n    long long res=0;\\n    \\n    //calculating by traversing from up to down\\n    \\n    for(int j=0;j<m;j++){\\n        pair<long long,long long>sum={0,0};\\n        for(int i=0;i<n;i++){\\n            sum={sum.first+matrix[i][j].first,sum.second+matrix[i][j].second};\\n            res=max(res,min(sum.first,sum.second));\\n            if(j>0){\\n            pair<long long,long long>p1=matrix2[i][j-1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n            if(j<m-1){\\n                pair<long long,long long>p1=matrix1[i][j+1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n               \\n        }            \\n        \\n    }\\n    return res;\\n    \\n}\\n\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    \\nint m=grid[0].size();\\n    int n=grid.size();\\n    vector<vector<int>>grid2(m,vector<int>(n,0));\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            grid2[j][i]=grid[i][j];\\n        }\\n    }\\n    long long res=0;\\n      res=max(util(grid),util(grid2));\\n    vector<vector<int>>grid3(n,vector<int>(m,0));\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            grid3[n-i-1][j]=grid[i][j];       \\n        }\\n    }\\n    return max(res,util(grid3));\\n    \\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n\\npair<long long,long long> util(int val){\\n    \\n    int x=0;\\n    while(val>0 && val%5==0){\\n        val=val/5;\\n        x++;\\n    }\\n    int y=0;\\n    while(val>0 && val%2==0){\\n        val=val/2;\\n        y++;\\n    }\\n    return {x,y};\\n    \\n}\\n\\nlong long util(vector<vector<int>>& grid){\\n    \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    pair<long long,long long> matrix[n][m];\\n    pair<long long,long long> matrix1[n][m];\\n    pair<long long,long long> matrix2[n][m];\\n    \\n    //making the first grid;\\n    for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++){\\n            int val=grid[i][j];\\n            matrix[i][j]=util(val);\\n        }\\n    \\n    //right to left\\n    for(int i=0;i<n;i++){\\n        for(int j=m-1;j>=0;j--){\\n            if(j==m-1)\\n                matrix1[i][j]=matrix[i][j];\\n            else\\n                matrix1[i][j]={matrix[i][j].first+matrix1[i][j+1].first,matrix[i][j].second+matrix1[i][j+1].second};\\n\\n        }\\n    }\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(j==0)\\n                matrix2[i][j]=matrix[i][j];\\n            else\\n                matrix2[i][j]={matrix[i][j].first+matrix2[i][j-1].first,matrix[i][j].second+matrix2[i][j-1].second};\\n        }\\n    }\\n    long long res=0;\\n    \\n    //calculating by traversing from up to down\\n    \\n    for(int j=0;j<m;j++){\\n        pair<long long,long long>sum={0,0};\\n        for(int i=0;i<n;i++){\\n            sum={sum.first+matrix[i][j].first,sum.second+matrix[i][j].second};\\n            res=max(res,min(sum.first,sum.second));\\n            if(j>0){\\n            pair<long long,long long>p1=matrix2[i][j-1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n            if(j<m-1){\\n                pair<long long,long long>p1=matrix1[i][j+1];\\n            res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n            }\\n               \\n        }            \\n        \\n    }\\n    return res;\\n    \\n}\\n\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n    \\nint m=grid[0].size();\\n    int n=grid.size();\\n    vector<vector<int>>grid2(m,vector<int>(n,0));\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            grid2[j][i]=grid[i][j];\\n        }\\n    }\\n    long long res=0;\\n      res=max(util(grid),util(grid2));\\n    vector<vector<int>>grid3(n,vector<int>(m,0));\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            grid3[n-i-1][j]=grid[i][j];       \\n        }\\n    }\\n    return max(res,util(grid3));\\n    \\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956741,
                "title": "lazy-coding-idea-explained-code",
                "content": "Lets try to visulaise our solution , the solution will always be an **\"L\"** so what we can do is iterate on every index of the matrix and assume this point to be the intersection of the vertical and horizontal lines.\\n\\nNow , as we have asssumed (i , j ) to be our answer , we have to find number of trailing zeroes . So for the horizontal and vertical lines , we can have a prefix array that stores number of 2\\'s and 5\\'s from\\n(0 , i ) , (i , n-1) , (0 , j-1) , (j+1 , m) \\nNow , we can greedily calculate the answer. It\\'s easy just implementing takes some effort. If you dont understand any part please do comment , i will be happy to explain . \\n\\nPlease do upvote , it motivates me , i will surely add more explanations further \\uD83D\\uDE03\\n \\n \\n \\n grid \\n23 | 17 | 15 | 03   | 20 |     \\n08   | 01   | 20 | 27 | 11 | \\n09   | 04   | 06   | 02   | 21 | \\n40 | 09   | 01   | 10 | 06   | \\n22 | 07   | 04   | 05   | 03   | \\n\\n\\nPrefix Arrays \\n\\n prefixhorizontal \\n0 0 | 0 0 | 1 0 | 1 0 | 2 2 | \\n0 3 | 0 3 | 1 5 | 1 5 | 1 5 | \\n0 0 | 0 2 | 0 3 | 0 4 | 0 4 | \\n1 3 | 1 3 | 1 3 | 2 4 | 2 5 | \\n0 1 | 0 1 | 0 3 | 1 3 | 1 3 | \\n\\n prefixvertical \\n0 0 | 0 0 | 1 0 | 0 0 | 1 2 | \\n0 3 | 0 0 | 2 2 | 0 0 | 1 2 | \\n0 3 | 0 2 | 2 3 | 0 1 | 1 2 | \\n1 6 | 0 2 | 2 3 | 1 2 | 1 3 | \\n1 7 | 0 2 | 2 5 | 2 2 | 1 3 | \\n\\n\\n```\\nclass Solution {\\n    \\n        int count(int num , int val)\\n        {\\n            int cnt = 0 ;\\n            while(num>0 && num%val == 0)\\n                cnt++ , num/=val ;\\n            \\n            return cnt ;\\n                \\n        }\\n    \\n        int solve(pair<int , int> &p1 , pair<int , int> &p2)\\n        {\\n            return min(p1.first + p2.first , p1.second + p2.second) ;\\n        }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size() , m = grid[0].size() ;\\n        vector<vector<pair<int , int>> > preHorizontal(n , vector<pair<int, int>>(m , {0 , 0})) ;\\n        vector<vector<pair<int , int>> > preVertical(n , vector<pair<int, int>>(m , {0, 0})) ;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0; j<m ; j++)\\n            {\\n                if(j == 0) preHorizontal[i][j] = { count(grid[i][j] , 5) , count(grid[i][j] , 2) } ; \\n                else{\\n                    int cnt5 = preHorizontal[i][j-1].first + count(grid[i][j] , 5) ;\\n                    int cnt2 = preHorizontal[i][j-1].second + count(grid[i][j] , 2) ;\\n                    preHorizontal[i][j] = { cnt5 , cnt2 } ;\\n                }\\n            }\\n        }\\n        \\n          for(int i=0 ; i<m ; i++)\\n        {\\n            for(int j=0; j<n ; j++)\\n            {\\n                if(j == 0) preVertical[j][i] = { count(grid[j][i] , 5) , count(grid[j][i] , 2) } ; \\n                else{\\n                    int cnt5 = preVertical[j-1][i].first + count(grid[j][i] , 5) ;\\n                    int cnt2 = preVertical[j-1][i].second + count(grid[j][i] , 2) ;\\n                    preVertical[j][i] = { cnt5 , cnt2 } ;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        \\n        for(int i=0; i<n ; i++)\\n        {\\n            for(int j=0; j<m ; j++)\\n            {\\n                pair<int , int > cnthor1 = {0 , 0} , cnthor2 = {0 , 0} , cntver1 = {0 , 0} , cntver2 = {0 , 0} ;\\n                cnthor1 = { preHorizontal[i][m-1].first - preHorizontal[i][j].first , preHorizontal[i][m-1].second - preHorizontal[i][j].second } ;\\n                cnthor2 = j > 0 ? preHorizontal[i][j-1] : cnthor2 ;\\n                \\n        cntver1 =  i>0 ? make_pair(preVertical[n-1][j].first - preVertical[i-1][j].first , preVertical[n-1][j].second - preVertical[i-1][j].second ) : preVertical[n-1][j] ;\\n                cntver2 = preVertical[i][j] ;\\n                \\n                ans = max(ans , solve(cnthor1 , cntver1)) ;\\n                ans = max(ans , solve(cnthor2 , cntver1)) ;\\n                ans = max(ans , solve(cnthor1 , cntver2)) ;\\n                ans = max(ans , solve(cnthor2 , cntver2)) ;\\n\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n        int count(int num , int val)\\n        {\\n            int cnt = 0 ;\\n            while(num>0 && num%val == 0)\\n                cnt++ , num/=val ;\\n            \\n            return cnt ;\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1955502,
                "title": "python-prefix-sum-o-m-n",
                "content": "**Intuition**\\nStore the prefix sum matrices of rows and columns, where each entry is `[a, b]` representing the cumulative count of (1) the factors of 2 and (2) the factors of 5.\\n\\n\\n**Complexity**\\nTime: `O(m * n)`\\nSpace: `O(m * n)`\\n\\nBelow is my slightly-modified in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955381,
                "title": "python-the-time-limit-for-python-is-merciless",
                "content": "I use 3 different way to implement the O(M*N) algorithm because of TLE result.\\nlost more than 40 minutes here. \\uD83D\\uDE22\\n```\\nclass Solution:                                                                                                 \\n    def maxTrailingZeros(self, grid):                                                                           \\n                                                                                                    \\n        def get25(n):                                                                                           \\n            c2,c5 = 0,0                                                                                 \\n            while n and n % 2 == 0:                                                                             \\n                c2 += 1                                                                                 \\n                n = n // 2                                                                                      \\n            while n and n % 5 == 0:                                                                             \\n                c5 += 1                                                                                 \\n                n = n // 5                                                                                      \\n            return [c2,c5] \\n        c25 = []\\n        for i in range(1001):\\n            c25.append(get25(i))\\n                                                                                                                \\n        m, n = len(grid), len(grid[0])                                                                          \\n        grid = list(map(lambda x: list(map(lambda xx: c25[xx][:], x)), grid))                          \\n        l = [[[0,0] for _ in range(n)] for _ in range(m)]                                                   \\n        r = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        u = [[[0,0] for _ in range(n)] for _ in range(m)]                                                \\n        b = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        for i in range(m):                                                                                      \\n            for j in range(0, n):\\n                for k in range(2):\\n                    l[i][j][k] = grid[i][j][k]\\n                    u[i][j][k] = grid[i][j][k]\\n                    if j != 0:                                                                                      \\n                        l[i][j][k] += l[i][j - 1][k]                                                       \\n                    if i != 0:                                                                                      \\n                        u[i][j][k] += u[i - 1][j][k]                                                    \\n        ans = 0                                                                                                 \\n        for i in range(m - 1, -1, -1):                                                                          \\n            for j in range(n - 1, -1, -1):\\n                q1,q2,q3,q4 = 10**10,10**10,10**10,10**10\\n                for k in range(2):\\n                    b[i][j][k] = grid[i][j][k]\\n                    r[i][j][k] = grid[i][j][k]  \\n                    if i != m - 1:                                                                                  \\n                        b[i][j][k] += b[i + 1][j][k]                                                       \\n                    if j != n - 1:                                                                                  \\n                        r[i][j][k] += r[i][j + 1][k]\\n                    q1 = min(q1,r[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q2 = min(q2,r[i][j][k]+b[i][j][k]-grid[i][j][k])\\n                    q3 = min(q3,l[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q4 = min(q4,l[i][j][k]+b[i][j][k]-grid[i][j][k])                                                           \\n                ans = max(ans,q1,q2,q3,q4)      \\n                                                                                                                \\n        return ans     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:                                                                                                 \\n    def maxTrailingZeros(self, grid):                                                                           \\n                                                                                                    \\n        def get25(n):                                                                                           \\n            c2,c5 = 0,0                                                                                 \\n            while n and n % 2 == 0:                                                                             \\n                c2 += 1                                                                                 \\n                n = n // 2                                                                                      \\n            while n and n % 5 == 0:                                                                             \\n                c5 += 1                                                                                 \\n                n = n // 5                                                                                      \\n            return [c2,c5] \\n        c25 = []\\n        for i in range(1001):\\n            c25.append(get25(i))\\n                                                                                                                \\n        m, n = len(grid), len(grid[0])                                                                          \\n        grid = list(map(lambda x: list(map(lambda xx: c25[xx][:], x)), grid))                          \\n        l = [[[0,0] for _ in range(n)] for _ in range(m)]                                                   \\n        r = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        u = [[[0,0] for _ in range(n)] for _ in range(m)]                                                \\n        b = [[[0,0] for _ in range(n)] for _ in range(m)]                                                 \\n        for i in range(m):                                                                                      \\n            for j in range(0, n):\\n                for k in range(2):\\n                    l[i][j][k] = grid[i][j][k]\\n                    u[i][j][k] = grid[i][j][k]\\n                    if j != 0:                                                                                      \\n                        l[i][j][k] += l[i][j - 1][k]                                                       \\n                    if i != 0:                                                                                      \\n                        u[i][j][k] += u[i - 1][j][k]                                                    \\n        ans = 0                                                                                                 \\n        for i in range(m - 1, -1, -1):                                                                          \\n            for j in range(n - 1, -1, -1):\\n                q1,q2,q3,q4 = 10**10,10**10,10**10,10**10\\n                for k in range(2):\\n                    b[i][j][k] = grid[i][j][k]\\n                    r[i][j][k] = grid[i][j][k]  \\n                    if i != m - 1:                                                                                  \\n                        b[i][j][k] += b[i + 1][j][k]                                                       \\n                    if j != n - 1:                                                                                  \\n                        r[i][j][k] += r[i][j + 1][k]\\n                    q1 = min(q1,r[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q2 = min(q2,r[i][j][k]+b[i][j][k]-grid[i][j][k])\\n                    q3 = min(q3,l[i][j][k]+u[i][j][k]-grid[i][j][k])\\n                    q4 = min(q4,l[i][j][k]+b[i][j][k]-grid[i][j][k])                                                           \\n                ans = max(ans,q1,q2,q3,q4)      \\n                                                                                                                \\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957429,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int>find(int n)\\n    {\\n        int count2=0;\\n        int count5=0;\\n        while(n%2==0)\\n        {\\n            n=n/2;\\n            count2++;\\n        }\\n        while(n%5==0)\\n        {\\n            n=n/5;\\n            count5++;\\n        }\\n        return {count2,count5};\\n        \\n    }\\n    int maxTrailingZeros(vector<vector<int>>&mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<vector<int>>>nums(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>top(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>left(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>right(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>bottom(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                auto it=find(mat[i][j]);\\n                nums[0][i][j]=it.first;\\n                nums[1][i][j]=it.second;\\n            }\\n        }\\n        top=left=right=bottom=nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i)\\n                {\\n                    top[0][i][j]+=top[0][i-1][j];\\n                    top[1][i][j]+=top[1][i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j)\\n                {\\n                    left[0][i][j]+=left[0][i][j-1];\\n                    left[1][i][j]+=left[1][i][j-1];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j!=m-1)\\n                {\\n                    right[0][i][j]+=right[0][i][j+1];\\n                    right[1][i][j]+=right[1][i][j+1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i!=n-1)\\n                {\\n                    bottom[0][i][j]+=bottom[0][i+1][j];\\n                    bottom[1][i][j]+=bottom[1][i+1][j];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int curr2=nums[0][i][j];\\n                int curr5=nums[1][i][j];\\n                \\n                int top2=top[0][i][j];\\n                int top5=top[1][i][j];\\n                \\n                int right2=right[0][i][j];\\n                int right5=right[1][i][j];\\n                \\n                int bottom2=bottom[0][i][j];\\n                int bottom5=bottom[1][i][j];\\n                \\n                int left2=left[0][i][j];\\n                int left5=left[1][i][j];\\n                \\n                ans=max(ans,min(top2+right2-curr2,top5+right5-curr5));\\n                ans=max(ans,min(top2+left2-curr2,top5+left5-curr5));\\n                ans=max(ans,min(bottom2+right2-curr2,bottom5+right5-curr5));\\n                ans=max(ans,min(bottom2+left2-curr2,bottom5+left5-curr5));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int>find(int n)\\n    {\\n        int count2=0;\\n        int count5=0;\\n        while(n%2==0)\\n        {\\n            n=n/2;\\n            count2++;\\n        }\\n        while(n%5==0)\\n        {\\n            n=n/5;\\n            count5++;\\n        }\\n        return {count2,count5};\\n        \\n    }\\n    int maxTrailingZeros(vector<vector<int>>&mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<vector<int>>>nums(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>top(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>left(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>right(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        vector<vector<vector<int>>>bottom(2,vector<vector<int>>(n,vector<int>(m,0)));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                auto it=find(mat[i][j]);\\n                nums[0][i][j]=it.first;\\n                nums[1][i][j]=it.second;\\n            }\\n        }\\n        top=left=right=bottom=nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i)\\n                {\\n                    top[0][i][j]+=top[0][i-1][j];\\n                    top[1][i][j]+=top[1][i-1][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j)\\n                {\\n                    left[0][i][j]+=left[0][i][j-1];\\n                    left[1][i][j]+=left[1][i][j-1];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j!=m-1)\\n                {\\n                    right[0][i][j]+=right[0][i][j+1];\\n                    right[1][i][j]+=right[1][i][j+1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i!=n-1)\\n                {\\n                    bottom[0][i][j]+=bottom[0][i+1][j];\\n                    bottom[1][i][j]+=bottom[1][i+1][j];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int curr2=nums[0][i][j];\\n                int curr5=nums[1][i][j];\\n                \\n                int top2=top[0][i][j];\\n                int top5=top[1][i][j];\\n                \\n                int right2=right[0][i][j];\\n                int right5=right[1][i][j];\\n                \\n                int bottom2=bottom[0][i][j];\\n                int bottom5=bottom[1][i][j];\\n                \\n                int left2=left[0][i][j];\\n                int left5=left[1][i][j];\\n                \\n                ans=max(ans,min(top2+right2-curr2,top5+right5-curr5));\\n                ans=max(ans,min(top2+left2-curr2,top5+left5-curr5));\\n                ans=max(ans,min(bottom2+right2-curr2,bottom5+right5-curr5));\\n                ans=max(ans,min(bottom2+left2-curr2,bottom5+left5-curr5));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253898,
                "title": "python-3-w-some-explanation-t-m-94-93",
                "content": "- We construct a prefix sum of 4-tuples, writing over`grid`as we go. For each cell, we determine `(up2, up5, left2, right5)`, the accummulated factors of two and five for the up-direction and the left-direction respectively.\\n\\n- We use the transformed`grid`to determine for each cell the count of zeros over the four paths: up-left, down-left, up-right, down-right.\\n- We determine the max zeros for each cell along the four paths, and then determine the overall max from those cell maxs.\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid)+1, len(grid[0])+1\\n        grid = [[(0,0,0,0)]*n]+[[(0,0,0,0)]+row for row in grid]\\n\\n        def pref(row: int,col: int)-> tuple:        # <-- prefix for each cell\\n        \\n            val = grid[row][col]\\n            for f2 in range(19):\\n                if val%2: break\\n                val//= 2\\n   \\n            for f5 in range(6):\\n                if val%5: break\\n                val//= 5\\n        \\n            (u2, u5, _,_), (_,_, l2, l5) = grid[row-1][col], grid[row][col-1]\\n            return (f2 + u2, f5 + u5, f2 + l2, f5 + l5)\\n        \\n        def countZeros(r: int,c: int)-> int:        #  <--Count the zeros    \\n            up2   ,up5    = grid[r][c][0],grid[r][c][1]\\n            down2 ,down5  = grid[m-1][c][0]-grid[r-1][c][0],grid[m-1][c][1]-grid[r-1][c][1]\\n            \\n            left2 ,left5  = grid[r][c-1][2],grid[r][c-1][3]\\n            right2,right5 = grid[r][n-1][2]-grid[r][c][2],grid[r][n-1][3]-grid[r][c][3] \\n\\n            return max(min(up2+left2 ,up5+left5 ), min(down2+left2 ,down5+left5 ),\\n                       min(up2+right2,up5+right5), min(down2+right2,down5+right5))\\n\\n        for r in range(1,m):\\n            for c in range(1,n):grid[r][c] = pref(r,c)\\n\\n        return max(countZeros(r,c) for c in range(1,n) for r in range(1,m))\\n```\\n[https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/submissions/908601238/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) (wnere*N* is *mn* and space complexity is probably *O*(*N*) but maybe *O*(1). I\\'m just not sure.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid)+1, len(grid[0])+1\\n        grid = [[(0,0,0,0)]*n]+[[(0,0,0,0)]+row for row in grid]\\n\\n        def pref(row: int,col: int)-> tuple:        # <-- prefix for each cell\\n        \\n            val = grid[row][col]\\n            for f2 in range(19):\\n                if val%2: break\\n                val//= 2\\n   \\n            for f5 in range(6):\\n                if val%5: break\\n                val//= 5\\n        \\n            (u2, u5, _,_), (_,_, l2, l5) = grid[row-1][col], grid[row][col-1]\\n            return (f2 + u2, f5 + u5, f2 + l2, f5 + l5)\\n        \\n        def countZeros(r: int,c: int)-> int:        #  <--Count the zeros    \\n            up2   ,up5    = grid[r][c][0],grid[r][c][1]\\n            down2 ,down5  = grid[m-1][c][0]-grid[r-1][c][0],grid[m-1][c][1]-grid[r-1][c][1]\\n            \\n            left2 ,left5  = grid[r][c-1][2],grid[r][c-1][3]\\n            right2,right5 = grid[r][n-1][2]-grid[r][c][2],grid[r][n-1][3]-grid[r][c][3] \\n\\n            return max(min(up2+left2 ,up5+left5 ), min(down2+left2 ,down5+left5 ),\\n                       min(up2+right2,up5+right5), min(down2+right2,down5+right5))\\n\\n        for r in range(1,m):\\n            for c in range(1,n):grid[r][c] = pref(r,c)\\n\\n        return max(countZeros(r,c) for c in range(1,n) for r in range(1,m))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959011,
                "title": "c-100-memory-100-faster-prefix-sum-of-2s-5s-in-prime-factorization-of-grid-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> zero = make_pair(0,0);\\n        vector<vector<pair<int,int>>> prefix(m,vector<pair<int,int>>(n,zero));\\n        // (2s,5s)\\n        for(int i=0; i<m; i++){\\n            \\n            for(int j=0; j<n; j++){\\n                int temp = grid[i][j];\\n                while(temp%2 ==0){\\n                    prefix[i][j].first = prefix[i][j].first + 1;\\n                    temp = temp/2;\\n                }\\n                temp = grid[i][j];\\n                while(temp%5 ==0){\\n                    prefix[i][j].second = prefix[i][j].second + 1;\\n                    temp = temp/5;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                prefix[i][j].first = prefix[i][j].first + prefix[i][j-1].first;\\n                prefix[i][j].second = prefix[i][j].second + prefix[i][j-1].second;\\n            }\\n        }\\n        \\n        int maxzeros = 0;\\n        // if ans is a smaller L, a bigger L containing the smaller L can either increase the \\n        // twos and fives or remain same.  4 possible L shapes\\n        \\n        // top to bottom , consider left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=0; i<m; i++){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        // bottom to top. consider either left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=m-1; i>=0; i--){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        return maxzeros;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> zero = make_pair(0,0);\\n        vector<vector<pair<int,int>>> prefix(m,vector<pair<int,int>>(n,zero));\\n        // (2s,5s)\\n        for(int i=0; i<m; i++){\\n            \\n            for(int j=0; j<n; j++){\\n                int temp = grid[i][j];\\n                while(temp%2 ==0){\\n                    prefix[i][j].first = prefix[i][j].first + 1;\\n                    temp = temp/2;\\n                }\\n                temp = grid[i][j];\\n                while(temp%5 ==0){\\n                    prefix[i][j].second = prefix[i][j].second + 1;\\n                    temp = temp/5;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                prefix[i][j].first = prefix[i][j].first + prefix[i][j-1].first;\\n                prefix[i][j].second = prefix[i][j].second + prefix[i][j-1].second;\\n            }\\n        }\\n        \\n        int maxzeros = 0;\\n        // if ans is a smaller L, a bigger L containing the smaller L can either increase the \\n        // twos and fives or remain same.  4 possible L shapes\\n        \\n        // top to bottom , consider left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=0; i<m; i++){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        // bottom to top. consider either left or right\\n        for(int j=0; j<n; j++){\\n            pair<int,int> ver= zero;\\n            int twos=0, fives=0;\\n            \\n            for(int i=m-1; i>=0; i--){\\n                twos = ver.first;\\n                fives = ver.second;\\n                // current element\\n                twos += prefix[i][j].first - (j>0?prefix[i][j-1].first:0);\\n                fives += prefix[i][j].second - (j>0?prefix[i][j-1].second:0);\\n                ver.first = twos;\\n                ver.second = fives;\\n                // left\\n                twos += j>0?prefix[i][j-1].first:0;\\n                fives += j>0?prefix[i][j-1].second:0;\\n                maxzeros = max(maxzeros,min(twos,fives));\\n                // right\\n                twos = ver.first;\\n                fives = ver.second;\\n                twos += prefix[i][n-1].first-prefix[i][j].first;\\n                fives += prefix[i][n-1].second-prefix[i][j].second;\\n                \\n                maxzeros = max(maxzeros,min(twos,fives));\\n            }\\n        }\\n        \\n        return maxzeros;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955868,
                "title": "java-prefix-sum-solution",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] dph = new int[m][n][3];\\n        int[][][] dpv = new int[m][n][3];\\n        int hmax0 = 0;\\n        int vmax0 = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (j >= 1) {\\n                    two = dph[i][j-1][1];\\n                    five = dph[i][j-1][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dph[i][j][1] = two;\\n                dph[i][j][2] = five;\\n                dph[i][j][0] = Math.min(dph[i][j][1], dph[i][j][2]);\\n            }\\n            hmax0 = Math.max(hmax0, dph[i][n-1][0]);\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (i >= 1) {\\n                    two = dpv[i-1][j][1];\\n                    five = dpv[i-1][j][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dpv[i][j][1] = two;\\n                dpv[i][j][2] = five;\\n                dpv[i][j][0] = Math.min(dpv[i][j][1], dpv[i][j][2]);\\n            }\\n            vmax0 = Math.max(vmax0, dpv[m-1][j][0]);\\n        }\\n\\t\\t\\n        int res = Math.max(vmax0, hmax0);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int otwo = dph[i][j][1];\\n                int ofive = dph[i][j][2];\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n                int otwo = 0;\\n                int ofive = 0;\\n                if (j >= 1) {\\n                    otwo = dph[i][n-1][1] - dph[i][j-1][1];\\n                    ofive = dph[i][n-1][2] - dph[i][j-1][2];\\n                } else {\\n                    otwo = dph[i][n-1][1];\\n                    ofive = dph[i][n-1][2];\\n                }\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                \\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] dph = new int[m][n][3];\\n        int[][][] dpv = new int[m][n][3];\\n        int hmax0 = 0;\\n        int vmax0 = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (j >= 1) {\\n                    two = dph[i][j-1][1];\\n                    five = dph[i][j-1][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dph[i][j][1] = two;\\n                dph[i][j][2] = five;\\n                dph[i][j][0] = Math.min(dph[i][j][1], dph[i][j][2]);\\n            }\\n            hmax0 = Math.max(hmax0, dph[i][n-1][0]);\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                int curr = grid[i][j];\\n                int two = 0;\\n                int five = 0;\\n                if (i >= 1) {\\n                    two = dpv[i-1][j][1];\\n                    five = dpv[i-1][j][2];\\n                }\\n                while (curr > 0 && curr % 2 == 0) {\\n                    two++;\\n                    curr /= 2;\\n                }\\n                while (curr > 0 && curr % 5 == 0) {\\n                    five++;\\n                    curr /= 5;\\n                }\\n                dpv[i][j][1] = two;\\n                dpv[i][j][2] = five;\\n                dpv[i][j][0] = Math.min(dpv[i][j][1], dpv[i][j][2]);\\n            }\\n            vmax0 = Math.max(vmax0, dpv[m-1][j][0]);\\n        }\\n\\t\\t\\n        int res = Math.max(vmax0, hmax0);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int otwo = dph[i][j][1];\\n                int ofive = dph[i][j][2];\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = n - 1; j >= 0; j--) {\\n                int otwo = 0;\\n                int ofive = 0;\\n                if (j >= 1) {\\n                    otwo = dph[i][n-1][1] - dph[i][j-1][1];\\n                    ofive = dph[i][n-1][2] - dph[i][j-1][2];\\n                } else {\\n                    otwo = dph[i][n-1][1];\\n                    ofive = dph[i][n-1][2];\\n                }\\n                \\n                int res1 = 0;\\n                if (i >= 1) {\\n                    int ntwo = otwo + dpv[i-1][j][1];\\n                    int nfive = ofive + dpv[i-1][j][2];\\n                    res1 = Math.min(ntwo, nfive);\\n                }\\n                \\n                int res2 = 0;\\n                if (i < m - 1) {\\n                    int ntwo = otwo + dpv[m-1][j][1] - dpv[i][j][1];\\n                    int nfive = ofive + dpv[m-1][j][2] - dpv[i][j][2];\\n                    res2 = Math.min(ntwo, nfive);\\n                }\\n                \\n                res = Math.max(res, res1);\\n                res = Math.max(res, res2);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955384,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>> v(m,vector<pair<int,int>>(n)),u(m,vector<pair<int,int>>(n)),d(m,vector<pair<int,int>>(n)),l(m,vector<pair<int,int>>(n)),r(m,vector<pair<int,int>>(n));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int x=grid[i][j];\\n                v[i][j].first=0;\\n                v[i][j].second=0;\\n                while(x%2==0)\\n                {\\n                    x/=2;\\n                    v[i][j].first++;\\n                }\\n                while(x%5==0)\\n                {\\n                    x/=5;\\n                    v[i][j].second++;\\n                }\\n            }\\n        }\\n        u=v;\\n        d=v;\\n        l=v;\\n        r=v;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                l[i][j].first+=l[i][j-1].first;\\n                l[i][j].second+=l[i][j-1].second;\\n                \\n                r[i][n-j-1].first+=r[i][n-j].first;\\n                r[i][n-j-1].second+=r[i][n-j].second;\\n            }            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                u[j][i].first+=u[j-1][i].first;\\n                u[j][i].second+=u[j-1][i].second;\\n                \\n                d[m-j-1][i].first+=d[m-j][i].first;\\n                d[m-j-1][i].second+=d[m-j][i].second;\\n            }            \\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                int x1=u[i][j].first;\\n                int x2=u[i][j].second;\\n                int x3=l[i][j].first;\\n                int x4=l[i][j].second;\\n                \\n                int c2=x1+x3-v[i][j].first;\\n                int c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=u[i][j].first;\\n                x2=u[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=l[i][j].first;\\n                x4=l[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>> v(m,vector<pair<int,int>>(n)),u(m,vector<pair<int,int>>(n)),d(m,vector<pair<int,int>>(n)),l(m,vector<pair<int,int>>(n)),r(m,vector<pair<int,int>>(n));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int x=grid[i][j];\\n                v[i][j].first=0;\\n                v[i][j].second=0;\\n                while(x%2==0)\\n                {\\n                    x/=2;\\n                    v[i][j].first++;\\n                }\\n                while(x%5==0)\\n                {\\n                    x/=5;\\n                    v[i][j].second++;\\n                }\\n            }\\n        }\\n        u=v;\\n        d=v;\\n        l=v;\\n        r=v;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                l[i][j].first+=l[i][j-1].first;\\n                l[i][j].second+=l[i][j-1].second;\\n                \\n                r[i][n-j-1].first+=r[i][n-j].first;\\n                r[i][n-j-1].second+=r[i][n-j].second;\\n            }            \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                u[j][i].first+=u[j-1][i].first;\\n                u[j][i].second+=u[j-1][i].second;\\n                \\n                d[m-j-1][i].first+=d[m-j][i].first;\\n                d[m-j-1][i].second+=d[m-j][i].second;\\n            }            \\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                int x1=u[i][j].first;\\n                int x2=u[i][j].second;\\n                int x3=l[i][j].first;\\n                int x4=l[i][j].second;\\n                \\n                int c2=x1+x3-v[i][j].first;\\n                int c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=u[i][j].first;\\n                x2=u[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=r[i][j].first;\\n                x4=r[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                //####################################\\n                x1=d[i][j].first;\\n                x2=d[i][j].second;\\n                x3=l[i][j].first;\\n                x4=l[i][j].second;\\n                \\n                c2=x1+x3-v[i][j].first;\\n                c5=x2+x4-v[i][j].second;\\n                res=max(res,min(c2,c5));\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955314,
                "title": "python3-dp-in-4-directions-commented-code",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        \\n        # Helper method with cache to return number of twos in prime factorization of given number\\n        @cache\\n        def twos(x):\\n            res = 0\\n            while (x&1)==0:\\n                res += 1\\n                x >>= 1\\n            return res\\n        \\n        # Helper method with cache to return number of fives in prime factorization of given number\\n        @cache\\n        def fives(x):\\n            res = 0\\n            while x%5 == 0:\\n                res += 1\\n                x //= 5\\n            return res\\n        \\n        m, n = len(A), len(A[0])\\n        \\n        # Creating 2D arrays for storing number of 2\\'s and number of 5\\'s in all elements above, below, left or right\\n\\t\\t# of the current element (including current element).The two counts will be stored as a tuple i.e. as pair<int, int>\\n        \\n        up, down, left, right = [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)]\\n        \\n        # Initializing first row of up array and last row of down array\\n        for j in range(n):\\n            up[0][j] = (twos(A[0][j]),fives(A[0][j]))\\n            down[m-1][j] = (twos(A[m-1][j]), fives(A[m-1][j]))\\n        \\n        # Initializing leftmost column of left array and rightmost column of right array\\n        for i in range(m):\\n            left[i][0] = (twos(A[i][0]), fives(A[i][0]))\\n            right[i][n-1] = (twos(A[i][n-1]), fives(A[i][n-1]))\\n            \\n        # Populating all remaining cells of all arrays\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                up[i][j] = (up[i-1][j][0] + twos(A[i][j]), up[i-1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                down[i][j] = (down[i+1][j][0] + twos(A[i][j]), down[i+1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(1, n):\\n                left[i][j] = (left[i][j-1][0] + twos(A[i][j]), left[i][j-1][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(n-2, -1, -1):\\n                right[i][j] = (right[i][j+1][0] + twos(A[i][j]), right[i][j+1][1] + fives(A[i][j]))\\n        \\n        # Iterating over each cell to first take pairwise sum in two directions of 2\\'s and 5\\'s then subtract current cell values (because it\\'s counted twice) \\n\\t\\t# finally take min of 2\\'s and 5\\'s for that cell where the horizontal/vertical turn happens\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(up[i][j][0] + right[i][j][0] - twos(A[i][j]), up[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(up[i][j][0] + left[i][j][0] - twos(A[i][j]), up[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + right[i][j][0] - twos(A[i][j]), down[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + left[i][j][0] - twos(A[i][j]), down[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, A: List[List[int]]) -> int:\\n        \\n        # Helper method with cache to return number of twos in prime factorization of given number\\n        @cache\\n        def twos(x):\\n            res = 0\\n            while (x&1)==0:\\n                res += 1\\n                x >>= 1\\n            return res\\n        \\n        # Helper method with cache to return number of fives in prime factorization of given number\\n        @cache\\n        def fives(x):\\n            res = 0\\n            while x%5 == 0:\\n                res += 1\\n                x //= 5\\n            return res\\n        \\n        m, n = len(A), len(A[0])\\n        \\n        # Creating 2D arrays for storing number of 2\\'s and number of 5\\'s in all elements above, below, left or right\\n\\t\\t# of the current element (including current element).The two counts will be stored as a tuple i.e. as pair<int, int>\\n        \\n        up, down, left, right = [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)], [[0]*n for _ in range(m)]\\n        \\n        # Initializing first row of up array and last row of down array\\n        for j in range(n):\\n            up[0][j] = (twos(A[0][j]),fives(A[0][j]))\\n            down[m-1][j] = (twos(A[m-1][j]), fives(A[m-1][j]))\\n        \\n        # Initializing leftmost column of left array and rightmost column of right array\\n        for i in range(m):\\n            left[i][0] = (twos(A[i][0]), fives(A[i][0]))\\n            right[i][n-1] = (twos(A[i][n-1]), fives(A[i][n-1]))\\n            \\n        # Populating all remaining cells of all arrays\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                up[i][j] = (up[i-1][j][0] + twos(A[i][j]), up[i-1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                down[i][j] = (down[i+1][j][0] + twos(A[i][j]), down[i+1][j][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(1, n):\\n                left[i][j] = (left[i][j-1][0] + twos(A[i][j]), left[i][j-1][1] + fives(A[i][j]))\\n        \\n        for i in range(m):\\n            for j in range(n-2, -1, -1):\\n                right[i][j] = (right[i][j+1][0] + twos(A[i][j]), right[i][j+1][1] + fives(A[i][j]))\\n        \\n        # Iterating over each cell to first take pairwise sum in two directions of 2\\'s and 5\\'s then subtract current cell values (because it\\'s counted twice) \\n\\t\\t# finally take min of 2\\'s and 5\\'s for that cell where the horizontal/vertical turn happens\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(up[i][j][0] + right[i][j][0] - twos(A[i][j]), up[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(up[i][j][0] + left[i][j][0] - twos(A[i][j]), up[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + right[i][j][0] - twos(A[i][j]), down[i][j][1] + right[i][j][1] - fives(A[i][j])))\\n                res = max(res, min(down[i][j][0] + left[i][j][0] - twos(A[i][j]), down[i][j][1] + left[i][j][1] - fives(A[i][j])))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193042,
                "title": "c-test-in-4-directions-prefix-sums",
                "content": "```\\n//firstly count \\'5\\' s and \\'2\\' s for every cell,  (each pair of (5,2) will generate a trailing zero),\\n//use prefix sums to accelerate the counting of 5s and 2s.\\n//and then check in 4 directions to find out the turn has max count of pairs (5,2)\\nclass Solution {\\npublic:\\n\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\tint m = grid.size(), n = grid[0].size(), r = 0, i, j, v, fiveCount, twoCount, a, b, a1, b1, a2, b2, a3, b3, a4, b4;\\n\\t\\tvector<vector<int>> fiveHor(m, vector<int>(n, 0)), fiveVer(m, vector<int>(n, 0)),twoHor(m, vector<int>(n, 0)),  twoVer(m, vector<int>(n, 0));\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\tv = grid[i][j], fiveCount = 0, twoCount = 0;\\n\\t\\t\\t\\twhile (v % 5 == 0) { fiveCount++;  v /= 5; }\\n\\t\\t\\t\\twhile (v && (v % 2 == 0)) { twoCount++; v /= 2; }\\n\\n\\t\\t\\t\\tfiveHor[i][j] = ((j == 0) ? 0 : fiveHor[i][j - 1]) + fiveCount;   //five prefix sum in horizontal\\n\\t\\t\\t\\tfiveVer[i][j] = ((i == 0) ? 0 : fiveVer[i - 1][j]) + fiveCount;   //five prefix sum in vertical\\n                \\n\\t\\t\\t\\ttwoHor[i][j]  = ((j == 0) ? 0 : twoHor[i][j - 1]) + twoCount;     //two prefix sum in horizontal\\t\\t\\t\\t\\n                twoVer[i][j]  = ((i == 0) ? 0 : twoVer[i - 1][j]) + twoCount;     //two prefix sum in vertical\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\ta = fiveHor[i][j] - (j == 0 ? 0 : fiveHor[i][j - 1]); //current cell\\'s count of 5\\n\\t\\t\\t\\tb = twoHor[i][j]  - (j == 0 ? 0 : twoHor[i][j - 1]); //current cell\\'s count of 2\\n                \\n\\t\\t\\t\\ta1 = fiveHor[i][n - 1] - fiveHor[i][j];                b1 = twoHor[i][n - 1] - twoHor[i][j];    //right\\n\\t\\t\\t\\ta2 = fiveVer[m - 1][j] - fiveVer[i][j];                b2 = twoVer[m - 1][j] - twoVer[i][j];    //down\\n\\t\\t\\t\\ta3 = (j == 0) ? 0 : fiveHor[i][j - 1];                 b3 = (j == 0) ? 0 : twoHor[i][j - 1];    //left\\n\\t\\t\\t\\ta4 = (i == 0) ? 0 : fiveVer[i - 1][j];                 b4 = (i == 0) ? 0 : twoVer[i - 1][j];    //up\\n\\n\\t\\t\\t\\tr = max(r, min(a + a1 + a2, b + b1 + b2));\\n\\t\\t\\t\\tr = max(r, min(a + a2 + a3, b + b2 + b3));\\n\\t\\t\\t\\tr = max(r, min(a + a3 + a4, b + b3 + b4));\\n\\t\\t\\t\\tr = max(r, min(a + a4 + a1, b + b4 + b1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//firstly count \\'5\\' s and \\'2\\' s for every cell,  (each pair of (5,2) will generate a trailing zero),\\n//use prefix sums to accelerate the counting of 5s and 2s.\\n//and then check in 4 directions to find out the turn has max count of pairs (5,2)\\nclass Solution {\\npublic:\\n\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\tint m = grid.size(), n = grid[0].size(), r = 0, i, j, v, fiveCount, twoCount, a, b, a1, b1, a2, b2, a3, b3, a4, b4;\\n\\t\\tvector<vector<int>> fiveHor(m, vector<int>(n, 0)), fiveVer(m, vector<int>(n, 0)),twoHor(m, vector<int>(n, 0)),  twoVer(m, vector<int>(n, 0));\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\tv = grid[i][j], fiveCount = 0, twoCount = 0;\\n\\t\\t\\t\\twhile (v % 5 == 0) { fiveCount++;  v /= 5; }\\n\\t\\t\\t\\twhile (v && (v % 2 == 0)) { twoCount++; v /= 2; }\\n\\n\\t\\t\\t\\tfiveHor[i][j] = ((j == 0) ? 0 : fiveHor[i][j - 1]) + fiveCount;   //five prefix sum in horizontal\\n\\t\\t\\t\\tfiveVer[i][j] = ((i == 0) ? 0 : fiveVer[i - 1][j]) + fiveCount;   //five prefix sum in vertical\\n                \\n\\t\\t\\t\\ttwoHor[i][j]  = ((j == 0) ? 0 : twoHor[i][j - 1]) + twoCount;     //two prefix sum in horizontal\\t\\t\\t\\t\\n                twoVer[i][j]  = ((i == 0) ? 0 : twoVer[i - 1][j]) + twoCount;     //two prefix sum in vertical\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (i = 0; i < m; ++i) {\\n\\t\\t\\tfor (j = 0; j < n; ++j) {\\n\\t\\t\\t\\ta = fiveHor[i][j] - (j == 0 ? 0 : fiveHor[i][j - 1]); //current cell\\'s count of 5\\n\\t\\t\\t\\tb = twoHor[i][j]  - (j == 0 ? 0 : twoHor[i][j - 1]); //current cell\\'s count of 2\\n                \\n\\t\\t\\t\\ta1 = fiveHor[i][n - 1] - fiveHor[i][j];                b1 = twoHor[i][n - 1] - twoHor[i][j];    //right\\n\\t\\t\\t\\ta2 = fiveVer[m - 1][j] - fiveVer[i][j];                b2 = twoVer[m - 1][j] - twoVer[i][j];    //down\\n\\t\\t\\t\\ta3 = (j == 0) ? 0 : fiveHor[i][j - 1];                 b3 = (j == 0) ? 0 : twoHor[i][j - 1];    //left\\n\\t\\t\\t\\ta4 = (i == 0) ? 0 : fiveVer[i - 1][j];                 b4 = (i == 0) ? 0 : twoVer[i - 1][j];    //up\\n\\n\\t\\t\\t\\tr = max(r, min(a + a1 + a2, b + b1 + b2));\\n\\t\\t\\t\\tr = max(r, min(a + a2 + a3, b + b2 + b3));\\n\\t\\t\\t\\tr = max(r, min(a + a3 + a4, b + b3 + b4));\\n\\t\\t\\t\\tr = max(r, min(a + a4 + a1, b + b4 + b1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068113,
                "title": "kotlin-solution",
                "content": "```\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val twosLeftToRight = Array(m) { IntArray(n) }\\n        val fivesLeftToRight = Array(m) { IntArray(n) }\\n        val twosUpToDown = Array(m) { IntArray(n) }\\n        val fivesUpToDown = Array(m) { IntArray(n) }\\n\\n        var maxTrailingZeros = 0\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var num = grid[i][j]\\n                var five = 0\\n                while (num % 5 == 0) {\\n                    five++\\n                    num /= 5\\n                }\\n                num = grid[i][j]\\n                var two = 0\\n                while (num % 2 == 0) {\\n                    two++\\n                    num /= 2\\n                }\\n                var leftTwo = two\\n                var leftFive = five\\n                var upTwo = two\\n                var upFive = five\\n\\n                if (j != 0) {\\n                    leftTwo += twosLeftToRight[i][j - 1]\\n                    leftFive += fivesLeftToRight[i][j - 1]\\n                }\\n                twosLeftToRight[i][j] = leftTwo\\n                fivesLeftToRight[i][j] = leftFive\\n                if (i != 0) {\\n                    upTwo += twosUpToDown[i - 1][j]\\n                    upFive += fivesUpToDown[i - 1][j]\\n                }\\n                twosUpToDown[i][j] = upTwo\\n                fivesUpToDown[i][j] = upFive\\n            }\\n        }\\n\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var upBeginning5 = 0\\n                var upBeginning2 = 0\\n                if (i != 0) {\\n                    upBeginning5 = fivesUpToDown[i - 1][0]\\n                    upBeginning2 = twosUpToDown[i - 1][0]\\n                }\\n                var downBeginnings5 = 0\\n                var downBeginnings2 = 0\\n                if (i != m - 1) {\\n                    downBeginnings5 = fivesUpToDown[m - 1][0] - fivesUpToDown[i][0]\\n                    downBeginnings2 = twosUpToDown[m - 1][0] - twosUpToDown[i][0]\\n                }\\n\\n                var topEndings5 = 0\\n                var topEndings2 = 0\\n                if (i != 0) {\\n                    topEndings5 = fivesUpToDown[i - 1][n - 1]\\n                    topEndings2 = twosUpToDown[i - 1][n - 1]\\n                }\\n                var downEndings5 = 0\\n                var downEndings2 = 0\\n                if (i != m - 1) {\\n                    downEndings5 = fivesUpToDown[m - 1][n - 1] - fivesUpToDown[i][n - 1]\\n                    downEndings2 = twosUpToDown[m - 1][n - 1] - twosUpToDown[i][n - 1]\\n                }\\n\\n                val leftSide5 = fivesLeftToRight[i][j]\\n                val leftSide2 = twosLeftToRight[i][j]\\n\\n                var topSide5 = 0\\n                var topSide2 = 0\\n                if (i != 0) {\\n                    topSide5 = fivesUpToDown[i - 1][j]\\n                    topSide2 = twosUpToDown[i - 1][j]\\n                }\\n\\n                val downSide5 = fivesUpToDown[m - 1][j] - fivesUpToDown[i][j]\\n                val downSide2 = twosUpToDown[m - 1][j] - twosUpToDown[i][j]\\n\\n                var rightSide5 = 0\\n                var rightSide2 = 0\\n                if (j != 0) {\\n                    rightSide5 = fivesLeftToRight[i][n - 1] - fivesLeftToRight[i][j - 1]\\n                    rightSide2 = twosLeftToRight[i][n - 1] - twosLeftToRight[i][j - 1]\\n                }\\n\\n                var min = Math.min(leftSide2 + topSide2, topSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topSide2, topSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downSide2, downSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downSide2, downSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + upBeginning2, upBeginning5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downBeginnings2, downBeginnings5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downEndings2, downEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topEndings2, topEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n            }\\n        }\\n        return maxTrailingZeros\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Prefix Sum"
                ],
                "code": "```\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val twosLeftToRight = Array(m) { IntArray(n) }\\n        val fivesLeftToRight = Array(m) { IntArray(n) }\\n        val twosUpToDown = Array(m) { IntArray(n) }\\n        val fivesUpToDown = Array(m) { IntArray(n) }\\n\\n        var maxTrailingZeros = 0\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var num = grid[i][j]\\n                var five = 0\\n                while (num % 5 == 0) {\\n                    five++\\n                    num /= 5\\n                }\\n                num = grid[i][j]\\n                var two = 0\\n                while (num % 2 == 0) {\\n                    two++\\n                    num /= 2\\n                }\\n                var leftTwo = two\\n                var leftFive = five\\n                var upTwo = two\\n                var upFive = five\\n\\n                if (j != 0) {\\n                    leftTwo += twosLeftToRight[i][j - 1]\\n                    leftFive += fivesLeftToRight[i][j - 1]\\n                }\\n                twosLeftToRight[i][j] = leftTwo\\n                fivesLeftToRight[i][j] = leftFive\\n                if (i != 0) {\\n                    upTwo += twosUpToDown[i - 1][j]\\n                    upFive += fivesUpToDown[i - 1][j]\\n                }\\n                twosUpToDown[i][j] = upTwo\\n                fivesUpToDown[i][j] = upFive\\n            }\\n        }\\n\\n        for (i in grid.indices) {\\n            for (j in 0 until n) {\\n                var upBeginning5 = 0\\n                var upBeginning2 = 0\\n                if (i != 0) {\\n                    upBeginning5 = fivesUpToDown[i - 1][0]\\n                    upBeginning2 = twosUpToDown[i - 1][0]\\n                }\\n                var downBeginnings5 = 0\\n                var downBeginnings2 = 0\\n                if (i != m - 1) {\\n                    downBeginnings5 = fivesUpToDown[m - 1][0] - fivesUpToDown[i][0]\\n                    downBeginnings2 = twosUpToDown[m - 1][0] - twosUpToDown[i][0]\\n                }\\n\\n                var topEndings5 = 0\\n                var topEndings2 = 0\\n                if (i != 0) {\\n                    topEndings5 = fivesUpToDown[i - 1][n - 1]\\n                    topEndings2 = twosUpToDown[i - 1][n - 1]\\n                }\\n                var downEndings5 = 0\\n                var downEndings2 = 0\\n                if (i != m - 1) {\\n                    downEndings5 = fivesUpToDown[m - 1][n - 1] - fivesUpToDown[i][n - 1]\\n                    downEndings2 = twosUpToDown[m - 1][n - 1] - twosUpToDown[i][n - 1]\\n                }\\n\\n                val leftSide5 = fivesLeftToRight[i][j]\\n                val leftSide2 = twosLeftToRight[i][j]\\n\\n                var topSide5 = 0\\n                var topSide2 = 0\\n                if (i != 0) {\\n                    topSide5 = fivesUpToDown[i - 1][j]\\n                    topSide2 = twosUpToDown[i - 1][j]\\n                }\\n\\n                val downSide5 = fivesUpToDown[m - 1][j] - fivesUpToDown[i][j]\\n                val downSide2 = twosUpToDown[m - 1][j] - twosUpToDown[i][j]\\n\\n                var rightSide5 = 0\\n                var rightSide2 = 0\\n                if (j != 0) {\\n                    rightSide5 = fivesLeftToRight[i][n - 1] - fivesLeftToRight[i][j - 1]\\n                    rightSide2 = twosLeftToRight[i][n - 1] - twosLeftToRight[i][j - 1]\\n                }\\n\\n                var min = Math.min(leftSide2 + topSide2, topSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topSide2, topSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downSide2, downSide5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downSide2, downSide5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + upBeginning2, upBeginning5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(leftSide2 + downBeginnings2, downBeginnings5 + leftSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + downEndings2, downEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n                min = Math.min(rightSide2 + topEndings2, topEndings5 + rightSide5)\\n                maxTrailingZeros = Math.max(maxTrailingZeros, min)\\n            }\\n        }\\n        return maxTrailingZeros\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956582,
                "title": "java-easy-to-understand-dp-100-time-and-memory",
                "content": "HINT1:\\nif we want to get the number of trailing zeros, we only need to figure out how many 5 and 2 the product has.\\n\\nHINT2:\\nFor each element as a corner, we have 4 directions and we need to combine any of the 2 to get a valid path.  So every corner has 6 different paths.\\n\\n\\n1.\\n0 1 0 0 \\n0 1 0 0\\n0 1 0 0\\n0 1 0 0\\n\\n2.\\n0 1 0 0 \\n0 1 1 1\\n0 0 0 0\\n0 0 0 0\\n\\n3.\\n0 1 0 0 \\n1 1 0 0\\n0 0 0 0\\n0 0 0 0\\n\\n4.\\n0 0 0 0 \\n1 1 1 1\\n0 0 0 0\\n0 0 0 0\\n\\n5.\\n0 0 0 0 \\n1 1 0 0\\n0 1 0 0\\n0 1 0 0\\n\\n6.\\n0 0 0 0 \\n0 1 1 1\\n0 1 0 0\\n0 1 0 0\\n\\n\\n\\n```\\n \\n public static int maxTrailingZeros(int[][] grid) {\\n        /*calculate how many 5 and 2 grid[i][j] has\\n        int[][] five = new int[grid.length][grid[0].length];\\n        int[][] two = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int origin = grid[i][j];\\n                while (origin % 5 == 0 && origin != 0) {\\n                    five[i][j] += 1;\\n                    origin = origin / 5;\\n                }\\n                origin = grid[i][j];\\n                while (origin % 2 == 0 && origin != 0) {\\n                    two[i][j] += 1;\\n                    origin = origin / 2;\\n                }\\n            }\\n        }\\n        // use four dp array to save the sum of 5 and 2 in two directions\\n        int[][] dp51 = new int[grid.length][grid[0].length];\\n        int[][] dp21 = new int[grid.length][grid[0].length];\\n        int[][] dp52 = new int[grid.length][grid[0].length];\\n        int[][] dp22 = new int[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i == 0) {\\n                    dp51[i][j] = five[i][j];\\n                    dp21[i][j] = two[i][j];\\n                } else {\\n                    dp51[i][j] = dp51[i - 1][j] + five[i][j];\\n                    dp21[i][j] = dp21[i - 1][j] + two[i][j];\\n                }\\n                if (j == 0) {\\n                    dp52[i][j] = five[i][j];\\n                    dp22[i][j] = two[i][j];\\n                } else {\\n                    dp52[i][j] = dp52[i][j - 1] + five[i][j];\\n                    dp22[i][j] = dp22[i][j - 1] + two[i][j];\\n                }\\n            }\\n        }\\n        \\n        //we have 4 choices and combine any of 2\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int fiveNum = dp51[i][j];\\n                int twoNum = dp21[i][j];\\n\\n                int fiveNum2 = dp52[i][j];\\n                int twoNum2 = dp22[i][j];\\n\\n                int fiveNum1 = dp51[grid.length - 1][j] - dp51[i][j] + five[i][j];\\n                int twoNum1 = dp21[grid.length - 1][j] - dp21[i][j] + two[i][j];\\n\\n                int fiveNum3 = dp52[i][grid[0].length - 1] - dp52[i][j] + five[i][j];\\n                int twoNum3 = dp22[i][grid[0].length - 1] - dp22[i][j] + two[i][j];\\n\\n\\n                max = Math.max(max, Math.min(fiveNum + fiveNum1 - five[i][j], twoNum + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum2 - five[i][j], twoNum + twoNum2 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum3 - five[i][j], twoNum + twoNum3 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum1 - five[i][j], twoNum2 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum3 + fiveNum1 - five[i][j], twoNum3 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum3 - five[i][j], twoNum2 + twoNum3 - two[i][j]));\\n            }\\n        }\\n        return max;\\n    }\\n \\n \\n  ```\\n \\n \\n \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n \\n public static int maxTrailingZeros(int[][] grid) {\\n        /*calculate how many 5 and 2 grid[i][j] has\\n        int[][] five = new int[grid.length][grid[0].length];\\n        int[][] two = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int origin = grid[i][j];\\n                while (origin % 5 == 0 && origin != 0) {\\n                    five[i][j] += 1;\\n                    origin = origin / 5;\\n                }\\n                origin = grid[i][j];\\n                while (origin % 2 == 0 && origin != 0) {\\n                    two[i][j] += 1;\\n                    origin = origin / 2;\\n                }\\n            }\\n        }\\n        // use four dp array to save the sum of 5 and 2 in two directions\\n        int[][] dp51 = new int[grid.length][grid[0].length];\\n        int[][] dp21 = new int[grid.length][grid[0].length];\\n        int[][] dp52 = new int[grid.length][grid[0].length];\\n        int[][] dp22 = new int[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (i == 0) {\\n                    dp51[i][j] = five[i][j];\\n                    dp21[i][j] = two[i][j];\\n                } else {\\n                    dp51[i][j] = dp51[i - 1][j] + five[i][j];\\n                    dp21[i][j] = dp21[i - 1][j] + two[i][j];\\n                }\\n                if (j == 0) {\\n                    dp52[i][j] = five[i][j];\\n                    dp22[i][j] = two[i][j];\\n                } else {\\n                    dp52[i][j] = dp52[i][j - 1] + five[i][j];\\n                    dp22[i][j] = dp22[i][j - 1] + two[i][j];\\n                }\\n            }\\n        }\\n        \\n        //we have 4 choices and combine any of 2\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int fiveNum = dp51[i][j];\\n                int twoNum = dp21[i][j];\\n\\n                int fiveNum2 = dp52[i][j];\\n                int twoNum2 = dp22[i][j];\\n\\n                int fiveNum1 = dp51[grid.length - 1][j] - dp51[i][j] + five[i][j];\\n                int twoNum1 = dp21[grid.length - 1][j] - dp21[i][j] + two[i][j];\\n\\n                int fiveNum3 = dp52[i][grid[0].length - 1] - dp52[i][j] + five[i][j];\\n                int twoNum3 = dp22[i][grid[0].length - 1] - dp22[i][j] + two[i][j];\\n\\n\\n                max = Math.max(max, Math.min(fiveNum + fiveNum1 - five[i][j], twoNum + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum2 - five[i][j], twoNum + twoNum2 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum + fiveNum3 - five[i][j], twoNum + twoNum3 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum1 - five[i][j], twoNum2 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum3 + fiveNum1 - five[i][j], twoNum3 + twoNum1 - two[i][j]));\\n                max = Math.max(max, Math.min(fiveNum2 + fiveNum3 - five[i][j], twoNum2 + twoNum3 - two[i][j]));\\n            }\\n        }\\n        return max;\\n    }\\n \\n \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956103,
                "title": "consider-all-6-shapes-of-l-at-each-point",
                "content": "```\\nclass Solution {\\npublic: \\n    int numberoffives(int n){ //calculates k if n = p1 *p2* (5^k)\\n        int cnt=0;\\n        while(n%5==0){\\n            n/=5;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    int numberoftwos(int n){\\n        int cnt=0;\\n        while(n%2==0){\\n            n/=2;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int, int>>> five(m+1, vector<pair<int, int>>(n+1, {0, 0})); // pair.first represents rows prefix sum of number of fives and pair.second represents columns prefix sum of number of fives \\n        vector<vector<pair<int, int>>> two(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n+1; j++){\\n                \\n                    five[i][j].first= five[i][j-1].first+ numberoffives(grid[i][j-1]);\\n                    two[i][j].first= two[i][j-1].first+ numberoftwos(grid[i][j-1]);\\n               \\n            }\\n        } // calculate row prefix\\n        \\n        for(int j=0; j<n; j++){\\n            for(int i=1; i<m+1; i++){\\n                \\n                    five[i][j].second= five[i-1][j].second+ numberoffives(grid[i-1][j]);\\n                    two[i][j].second= two[i-1][j].second+ numberoftwos(grid[i-1][j]);\\n               \\n            }\\n        }// calculate col prefix\\n\\n        int maxi=INT_MIN;\\n        for(int i=0; i<m; i++){ //                                                                                                       \\n            for(int j=0; j<n; j++){//                                                                                                     \\n\\t\\t\\t// Try all L shapes possible at a given joint(o) we can have at max 6 shapes  ----- o -------\\n\\t\\t\\t                                                                                                            \\n                //route1\\n                int f= numberoffives(grid[i][j]);\\n                int t= numberoftwos(grid[i][j]);\\n                int ans= min(two[i][j].first+ two[i][j].second+t,  five[i][j].first+ five[i][j].second+f);   \\n                //route 2\\n                int temp=0;\\n                temp= min(two[i][j].first+ (two[m][j].second-two[i][j].second), five[i][j].first+ (five[m][j].second-five[i][j].second));\\n                 ans=max(ans, temp);\\n                 // route 3\\n               temp= min(two[i][n].first-two[i][j].first+ (two[m][j].second-two[i][j].second)-t, five[i][n].first-five[i][j].first+ (five[m][j].second-five[i][j].second)-f);\\n                ans=max(ans, temp);\\n                // route 4\\n                  temp= min(two[i][n].first-two[i][j].first+ (two[i][j].second), five[i][n].first-five[i][j].first+ (five[i][j].second));\\n                ans=max(ans, temp);\\n                //route 5 && 6\\n                temp=min(two[i][n].first,  five[i][n].first);\\n                ans=max(ans, temp);\\n                temp=min(two[m][j].second,  five[m][j].second);\\n                ans=max(ans, temp);\\n                // cout<<ans<<\" \";\\n                maxi= max(ans, maxi);       \\n            }\\n            // cout<<endl;\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int numberoffives(int n){ //calculates k if n = p1 *p2* (5^k)\\n        int cnt=0;\\n        while(n%5==0){\\n            n/=5;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    int numberoftwos(int n){\\n        int cnt=0;\\n        while(n%2==0){\\n            n/=2;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int, int>>> five(m+1, vector<pair<int, int>>(n+1, {0, 0})); // pair.first represents rows prefix sum of number of fives and pair.second represents columns prefix sum of number of fives \\n        vector<vector<pair<int, int>>> two(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n+1; j++){\\n                \\n                    five[i][j].first= five[i][j-1].first+ numberoffives(grid[i][j-1]);\\n                    two[i][j].first= two[i][j-1].first+ numberoftwos(grid[i][j-1]);\\n               \\n            }\\n        } // calculate row prefix\\n        \\n        for(int j=0; j<n; j++){\\n            for(int i=1; i<m+1; i++){\\n                \\n                    five[i][j].second= five[i-1][j].second+ numberoffives(grid[i-1][j]);\\n                    two[i][j].second= two[i-1][j].second+ numberoftwos(grid[i-1][j]);\\n               \\n            }\\n        }// calculate col prefix\\n\\n        int maxi=INT_MIN;\\n        for(int i=0; i<m; i++){ //                                                                                                       \\n            for(int j=0; j<n; j++){//                                                                                                     \\n\\t\\t\\t// Try all L shapes possible at a given joint(o) we can have at max 6 shapes  ----- o -------\\n\\t\\t\\t                                                                                                            \\n                //route1\\n                int f= numberoffives(grid[i][j]);\\n                int t= numberoftwos(grid[i][j]);\\n                int ans= min(two[i][j].first+ two[i][j].second+t,  five[i][j].first+ five[i][j].second+f);   \\n                //route 2\\n                int temp=0;\\n                temp= min(two[i][j].first+ (two[m][j].second-two[i][j].second), five[i][j].first+ (five[m][j].second-five[i][j].second));\\n                 ans=max(ans, temp);\\n                 // route 3\\n               temp= min(two[i][n].first-two[i][j].first+ (two[m][j].second-two[i][j].second)-t, five[i][n].first-five[i][j].first+ (five[m][j].second-five[i][j].second)-f);\\n                ans=max(ans, temp);\\n                // route 4\\n                  temp= min(two[i][n].first-two[i][j].first+ (two[i][j].second), five[i][n].first-five[i][j].first+ (five[i][j].second));\\n                ans=max(ans, temp);\\n                //route 5 && 6\\n                temp=min(two[i][n].first,  five[i][n].first);\\n                ans=max(ans, temp);\\n                temp=min(two[m][j].second,  five[m][j].second);\\n                ans=max(ans, temp);\\n                // cout<<ans<<\" \";\\n                maxi= max(ans, maxi);       \\n            }\\n            // cout<<endl;\\n        }\\n        return maxi;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955820,
                "title": "a-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(g) {\\n    const m = g.length;\\n    const n = g[0].length;\\n    const ta = [...Array(m)].map(i => Array(n).fill(1));\\n    const tb = [...Array(m)].map(i => Array(n).fill(1));\\n    const tc = [...Array(m)].map(i => Array(n).fill(1));\\n    const td = [...Array(m)].map(i => Array(n).fill(1));\\n    \\n    const c52 = (s) => {\\n        let c5 = 0;\\n        let c2 = 0;\\n        while (s % 2 === 0) {\\n            s = s / 2;\\n            c2++;\\n        }\\n        while (s % 5 === 0) {\\n            s = s / 5;\\n            c5++;\\n        }\\n        return [c5, c2];\\n    }\\n    \\n    const c10 = ([c5, c2]) => {\\n        return Math.min(c5, c2);\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            ta[i][j] = (j === 0) ? c52(g[i][j]) : [c52(g[i][j])[0] + ta[i][j-1][0], c52(g[i][j])[1] + ta[i][j-1][1]];\\n            tb[i][j] = (i === 0) ? c52(g[i][j]) :  [c52(g[i][j])[0] + tb[i-1][j][0], c52(g[i][j])[1] + tb[i-1][j][1]];\\n        }\\n    }\\n    \\n    for (let i = m-1; i >= 0; i--) {\\n        for (let j = n-1; j >= 0; j--) {\\n            tc[i][j] = (j === n-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + tc[i][j+1][0], c52(g[i][j])[1] + tc[i][j+1][1]];  // : ctz(hg(g[i][j]) * tc[i][j+1][0], tc[i][j+1][1]); // hg(g[i][j]) * tc[i][j+1];\\n            td[i][j] = (i === m-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + td[i+1][j][0], c52(g[i][j])[1] + td[i+1][j][1]]; // : ctz(hg(g[i][j]) * td[i+1][j][0], td[i+1][j][1]); // hg(g[i][j]) * td[i+1][j];\\n        }\\n    }\\n    \\n    let ret = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let s1 = i === 0 ? c10(ta[i][j]) : c10([ta[i][j][0] + tb[i-1][j][0], ta[i][j][1] + tb[i-1][j][1]]);\\n            let s2 = i === m - 1 ? c10(ta[i][j]) : c10([ta[i][j][0] + td[i+1][j][0], ta[i][j][1] + td[i+1][j][1]]);            \\n            let s3 = i === 0 ? c10(tc[i][j]) : c10([tc[i][j][0] + tb[i-1][j][0], tc[i][j][1] + tb[i-1][j][1]]);\\n            let s4 = i === m - 1 ? c10(tc[i][j]) : c10([tc[i][j][0] + td[i+1][j][0], tc[i][j][1] + td[i+1][j][1]]); \\n            ret = Math.max(ret, s1, s2, s3, s4);\\n        }\\n    }\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(g) {\\n    const m = g.length;\\n    const n = g[0].length;\\n    const ta = [...Array(m)].map(i => Array(n).fill(1));\\n    const tb = [...Array(m)].map(i => Array(n).fill(1));\\n    const tc = [...Array(m)].map(i => Array(n).fill(1));\\n    const td = [...Array(m)].map(i => Array(n).fill(1));\\n    \\n    const c52 = (s) => {\\n        let c5 = 0;\\n        let c2 = 0;\\n        while (s % 2 === 0) {\\n            s = s / 2;\\n            c2++;\\n        }\\n        while (s % 5 === 0) {\\n            s = s / 5;\\n            c5++;\\n        }\\n        return [c5, c2];\\n    }\\n    \\n    const c10 = ([c5, c2]) => {\\n        return Math.min(c5, c2);\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            ta[i][j] = (j === 0) ? c52(g[i][j]) : [c52(g[i][j])[0] + ta[i][j-1][0], c52(g[i][j])[1] + ta[i][j-1][1]];\\n            tb[i][j] = (i === 0) ? c52(g[i][j]) :  [c52(g[i][j])[0] + tb[i-1][j][0], c52(g[i][j])[1] + tb[i-1][j][1]];\\n        }\\n    }\\n    \\n    for (let i = m-1; i >= 0; i--) {\\n        for (let j = n-1; j >= 0; j--) {\\n            tc[i][j] = (j === n-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + tc[i][j+1][0], c52(g[i][j])[1] + tc[i][j+1][1]];  // : ctz(hg(g[i][j]) * tc[i][j+1][0], tc[i][j+1][1]); // hg(g[i][j]) * tc[i][j+1];\\n            td[i][j] = (i === m-1) ? c52(g[i][j]) : [c52(g[i][j])[0] + td[i+1][j][0], c52(g[i][j])[1] + td[i+1][j][1]]; // : ctz(hg(g[i][j]) * td[i+1][j][0], td[i+1][j][1]); // hg(g[i][j]) * td[i+1][j];\\n        }\\n    }\\n    \\n    let ret = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let s1 = i === 0 ? c10(ta[i][j]) : c10([ta[i][j][0] + tb[i-1][j][0], ta[i][j][1] + tb[i-1][j][1]]);\\n            let s2 = i === m - 1 ? c10(ta[i][j]) : c10([ta[i][j][0] + td[i+1][j][0], ta[i][j][1] + td[i+1][j][1]]);            \\n            let s3 = i === 0 ? c10(tc[i][j]) : c10([tc[i][j][0] + tb[i-1][j][0], tc[i][j][1] + tb[i-1][j][1]]);\\n            let s4 = i === m - 1 ? c10(tc[i][j]) : c10([tc[i][j][0] + td[i+1][j][0], tc[i][j][1] + td[i+1][j][1]]); \\n            ret = Math.max(ret, s1, s2, s3, s4);\\n        }\\n    }\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955449,
                "title": "python-o-row-col-solution-couting-factor-2-5-for-4-directions",
                "content": "\\tclass Solution:\\n\\t\\tdef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tdef valTo25(val):\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\twhile val % 2 == 0:\\n\\t\\t\\t\\t\\tn2 += 1\\n\\t\\t\\t\\t\\tval //= 2\\n\\t\\t\\t\\twhile val % 5 == 0:\\n\\t\\t\\t\\t\\tn5 += 1\\n\\t\\t\\t\\t\\tval //= 5\\n\\t\\t\\t\\treturn (n2, n5)\\n\\n\\n\\t\\t\\tdef result(i, j):\\n\\t\\t\\t\\tt2, t5 = dic[(i, j, \\'top\\')]\\n\\t\\t\\t\\tl2, l5 = dic[(i, j, \\'left\\')]\\n\\t\\t\\t\\tr2, r5 = dic[(i, j, \\'right\\')]\\n\\t\\t\\t\\tb2, b5 = dic[(i, j, \\'bot\\')]\\n\\n\\t\\t\\t\\to2, o5 = valTo25(grid[i][j])\\n\\n\\t\\t\\t\\tres1 = min(t2+o2+r2, t5+o5+r5)\\n\\t\\t\\t\\tres2 = min(t2+o2+l2, t5+o5+l5)\\n\\t\\t\\t\\tres3 = min(b2+o2+r2, b5+o5+r5)\\n\\t\\t\\t\\tres4 = min(b2+o2+l2, b5+o5+l5)\\n\\t\\t\\t\\treturn max(res1, res2, res3, res4)\\n\\t\\t\\t\\t\\n\\n\\t\\t\\tR = len(grid)\\n\\t\\t\\tC = len(grid[0])\\n\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\t# key = (i, j, dir), val = (#2, #5)\\n\\t\\t\\tdic = {}\\n\\t\\t\\t\\n\\t\\t\\t# Consider the top-left element\\n\\t\\t\\tdic[(0, 0, \\'top\\')] = (0, 0)\\n\\t\\t\\tdic[(0, 0, \\'left\\')] = (0, 0)\\n\\n\\t\\t\\tn2 = 0\\n\\t\\t\\tn5 = 0\\n\\t\\t\\tfor i in range(1, R):\\n\\t\\t\\t\\tres = valTo25(grid[i][0])\\n\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\tdic[(0, 0, \\'bot\\')] = (n2, n5)\\n\\n\\t\\t\\tn2 = 0\\n\\t\\t\\tn5 = 0\\n\\t\\t\\tfor i in range(1, C):\\n\\t\\t\\t\\tres = valTo25(grid[0][i])\\n\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\tdic[(0, 0, \\'right\\')] = (n2, n5)\\n\\n\\t\\t\\tans = max(ans, result(0, 0))\\n\\t\\t\\t\\n\\t\\t\\t# Consider the 1st row\\n\\t\\t\\tfor i in range(1, R):\\n\\t\\t\\t\\tdic[(i, 0, \\'left\\')] = (0, 0)\\n\\n\\t\\t\\t\\tn2, n5 = dic[(i-1, 0, \\'top\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[i-1][0])\\n\\t\\t\\t\\tdic[(i, 0, \\'top\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\tfor j in range(1, C):\\n\\t\\t\\t\\t\\tres = valTo25(grid[i][j])\\n\\t\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\t\\tdic[(i, 0, \\'right\\')] = (n2, n5)\\n\\n\\t\\t\\t\\tn2, n5 = dic[(i-1, 0, \\'bot\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[i][0])\\n\\t\\t\\t\\tdic[(i, 0, \\'bot\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\tans = max(ans, result(i, 0))\\n\\t\\t\\t\\n\\t\\t\\t# Consider the 1st column\\n\\t\\t\\tfor i in range(1, C):\\n\\t\\t\\t\\tn2, n5 = dic[(0, i-1, \\'left\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[0][i-1])\\n\\t\\t\\t\\tdic[(0, i, \\'left\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\tdic[(0, i, \\'top\\')] = (0, 0)\\n\\n\\t\\t\\t\\tn2, n5 = dic[(0, i-1, \\'right\\')]\\n\\t\\t\\t\\ta, b = valTo25(grid[0][i])\\n\\t\\t\\t\\tdic[(0, i, \\'right\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\tfor j in range(1, R):\\n\\t\\t\\t\\t\\tres = valTo25(grid[j][i])\\n\\t\\t\\t\\t\\tn2 += res[0]\\n\\t\\t\\t\\t\\tn5 += res[1]\\n\\t\\t\\t\\tdic[(0, i, \\'bot\\')] = (n2, n5)\\n\\n\\t\\t\\t\\tans = max(ans, result(0, i))\\n\\t\\t\\t\\n\\t\\t\\t# Consider the rest elements based on each one\\'s previous top and left element to update\\n\\t\\t\\tfor i in range(1, R):\\n\\t\\t\\t\\tfor j in range(1, C):\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i, j-1, \\'left\\')]\\n\\t\\t\\t\\t\\ta, b = valTo25(grid[i][j-1])\\n\\t\\t\\t\\t\\tdic[(i, j, \\'left\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i-1, j, \\'top\\')]\\n\\t\\t\\t\\t\\ta, b = valTo25(grid[i-1][j])\\n\\t\\t\\t\\t\\tdic[(i, j, \\'top\\')] = (n2+a, n5+b)\\n\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i, j-1, \\'right\\')]\\n\\t\\t\\t\\t\\ta, b = valTo25(grid[i][j])\\n\\t\\t\\t\\t\\tdic[(i, j, \\'right\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\t\\tn2, n5 = dic[(i-1, j, \\'bot\\')]\\n\\t\\t\\t\\t\\tdic[(i, j, \\'bot\\')] = (n2-a, n5-b)\\n\\n\\t\\t\\t\\t\\tans = max(ans, result(i, j))\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tdef valTo25(val):\\n\\t\\t\\t\\tn2 = 0\\n\\t\\t\\t\\tn5 = 0\\n\\t\\t\\t\\twhile val % 2 == 0:\\n\\t\\t\\t\\t\\tn2 += 1\\n\\t\\t\\t\\t\\tval //= 2\\n\\t\\t\\t\\twhile val % 5 == 0:\\n\\t\\t\\t\\t\\tn5 += 1\\n\\t\\t\\t\\t\\tval //= 5\\n\\t\\t\\t\\treturn (n2, n5)\\n\\n\\n\\t\\t\\tdef result(i, j):\\n\\t\\t\\t\\tt2, t5 = dic[(i, j, \\'top\\')]\\n\\t\\t\\t\\tl2, l5 = dic[(i, j, \\'left\\')]\\n\\t\\t\\t\\tr2, r5 = dic[(i, j, \\'right\\')]\\n\\t\\t\\t\\tb2, b5 = dic[(i, j, \\'bot\\')]\\n\\n\\t\\t\\t\\to2, o5 = valTo25(grid[i][j])\\n\\n\\t\\t\\t\\tres1 = min(t2+o2+r2, t5+o5+r5)\\n\\t\\t\\t\\tres2 = min(t2+o2+l2, t5+o5+l5)\\n\\t\\t\\t\\tres3 = min(b2+o2+r2, b5+o5+r5)\\n\\t\\t\\t\\tres4 = min(b2+o2+l2, b5+o5+l5)\\n\\t\\t\\t\\treturn max(res1, res2, res3, res4)\\n\\t\\t\\t\\t\\n\\n\\t\\t\\tR = len(grid)\\n\\t\\t\\tC = len(grid[0])\\n\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\t# key = (i, j, dir), val = (#2, #5)\\n\\t\\t\\tdic = {}",
                "codeTag": "Java"
            },
            {
                "id": 1955388,
                "title": "c-o-n-m-prefix-sum-solution-100",
                "content": "```C++\\nclass Solution {\\n    int countWith(int& n, int divisor) {\\n        int res = 0;\\n        while(!(n % divisor)) {\\n            n /= divisor;\\n            res++;\\n        }\\n        return res;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), res = 0;\\n        vector<vector<pair<int,int>>> rowPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), colPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), count(n, vector<pair<int,int>>(m, {0, 0}));\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                int n = grid[i][j], ct = countWith(n, 2), cf = countWith(n, 5);\\n                \\n                count[i][j] = {ct, cf};\\n                if(j) rowPrefixSum[i][j] = rowPrefixSum[i][j - 1];\\n                if(i) colPrefixSum[i][j] = colPrefixSum[i - 1][j];\\n                rowPrefixSum[i][j].first += ct, rowPrefixSum[i][j].second += cf;\\n                colPrefixSum[i][j].first += ct, colPrefixSum[i][j].second += cf;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                auto [upt, upf] = colPrefixSum[i][j];\\n                auto lot = colPrefixSum[n - 1][j].first - (i ? colPrefixSum[i - 1][j].first : 0), lof = colPrefixSum[n - 1][j].second - (i ? colPrefixSum[i - 1][j].second : 0);\\n                auto [let, lef] = rowPrefixSum[i][j];\\n                auto rit = rowPrefixSum[i][m - 1].first - (j ? rowPrefixSum[i][j - 1].first : 0), rif = rowPrefixSum[i][m - 1].second - (j ? rowPrefixSum[i][j - 1].second : 0);\\n\\n                res = max({res,\\n                           min(upt + let - count[i][j].first, upf + lef - count[i][j].second), //from up to left \\n                           min(upt + rit - count[i][j].first, upf + rif - count[i][j].second), //from up to right\\n                           min(lot + let - count[i][j].first, lof + lef - count[i][j].second), //from bottom to left\\n                           min(lot + rit - count[i][j].first, lof + rif - count[i][j].second) //from bottom to right\\n                          });\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    int countWith(int& n, int divisor) {\\n        int res = 0;\\n        while(!(n % divisor)) {\\n            n /= divisor;\\n            res++;\\n        }\\n        return res;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), res = 0;\\n        vector<vector<pair<int,int>>> rowPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), colPrefixSum(n, vector<pair<int,int>>(m, {0, 0})), count(n, vector<pair<int,int>>(m, {0, 0}));\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                int n = grid[i][j], ct = countWith(n, 2), cf = countWith(n, 5);\\n                \\n                count[i][j] = {ct, cf};\\n                if(j) rowPrefixSum[i][j] = rowPrefixSum[i][j - 1];\\n                if(i) colPrefixSum[i][j] = colPrefixSum[i - 1][j];\\n                rowPrefixSum[i][j].first += ct, rowPrefixSum[i][j].second += cf;\\n                colPrefixSum[i][j].first += ct, colPrefixSum[i][j].second += cf;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                auto [upt, upf] = colPrefixSum[i][j];\\n                auto lot = colPrefixSum[n - 1][j].first - (i ? colPrefixSum[i - 1][j].first : 0), lof = colPrefixSum[n - 1][j].second - (i ? colPrefixSum[i - 1][j].second : 0);\\n                auto [let, lef] = rowPrefixSum[i][j];\\n                auto rit = rowPrefixSum[i][m - 1].first - (j ? rowPrefixSum[i][j - 1].first : 0), rif = rowPrefixSum[i][m - 1].second - (j ? rowPrefixSum[i][j - 1].second : 0);\\n\\n                res = max({res,\\n                           min(upt + let - count[i][j].first, upf + lef - count[i][j].second), //from up to left \\n                           min(upt + rit - count[i][j].first, upf + rif - count[i][j].second), //from up to right\\n                           min(lot + let - count[i][j].first, lof + lef - count[i][j].second), //from bottom to left\\n                           min(lot + rit - count[i][j].first, lof + rif - count[i][j].second) //from bottom to right\\n                          });\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955293,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        vector<vector<pair<int,int>>> prorow(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> procol(n,vector<pair<int,int>>(m,{0,0}));\\n        unordered_map<int,pair<int,int>> mp;\\n        int c=0;\\n        for(int i=1;i<=1000;i++){\\n            int t=i;\\n            int two=0,fiv=0;\\n            while(t>0 && (t%2==0 || t%5==0)){\\n                if(t%2==0){\\n                    t/=2;\\n                    two++;\\n                }\\n                else if(t%5==0){\\n                    t/=5;\\n                    fiv++;\\n                }\\n            }\\n            mp[i]={two,fiv};\\n        }\\n        for(int i=0;i<n;i++){\\n             int two=0,fiv=0;\\n            for(int j=0;j<m;j++){\\n                two+=mp[grid[i][j]].first;\\n                fiv+=mp[grid[i][j]].second;\\n                prorow[i][j]={two,fiv};\\n            }\\n        }\\n          for(int i=0;i<m;i++){\\n            int two=0,fiv=0;\\n            for(int j=0;j<n;j++){\\n                two+=mp[grid[j][i]].first;\\n                fiv+=mp[grid[j][i]].second;\\n                procol[j][i]={two,fiv};\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int two=procol[i][j].first;\\n                int fiv=procol[i][j].second;\\n                int twoo=procol[n-1][j].first-two+mp[grid[i][j]].first;\\n                int fivv=procol[n-1][j].second-fiv+mp[grid[i][j]].second;\\n                \\n                int a=two+prorow[i][j].first-mp[grid[i][j]].first;\\n                int b=fiv+prorow[i][j].second-mp[grid[i][j]].second;\\n                \\n                int c=twoo+prorow[i][m-1].first-prorow[i][j].first;\\n                int d=fivv+prorow[i][m-1].second-prorow[i][j].second;\\n                \\n                ans=max(ans,max(min(a,b),min(c,d)));\\n                \\n                a=two+(prorow[i][m-1].first-prorow[i][j].first);\\n                b=fiv+(prorow[i][m-1].second-prorow[i][j].second);\\n                \\n                c=twoo+(prorow[i][j].first-mp[grid[i][j]].first);\\n                d=fivv+(prorow[i][j].second-mp[grid[i][j]].second);\\n                ans=max(ans,max(min(a,b),min(c,d)));\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;\\n        vector<vector<pair<int,int>>> prorow(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> procol(n,vector<pair<int,int>>(m,{0,0}));\\n        unordered_map<int,pair<int,int>> mp;\\n        int c=0;\\n        for(int i=1;i<=1000;i++){\\n            int t=i;\\n            int two=0,fiv=0;\\n            while(t>0 && (t%2==0 || t%5==0)){\\n                if(t%2==0){\\n                    t/=2;\\n                    two++;\\n                }\\n                else if(t%5==0){\\n                    t/=5;\\n                    fiv++;\\n                }\\n            }\\n            mp[i]={two,fiv};\\n        }\\n        for(int i=0;i<n;i++){\\n             int two=0,fiv=0;\\n            for(int j=0;j<m;j++){\\n                two+=mp[grid[i][j]].first;\\n                fiv+=mp[grid[i][j]].second;\\n                prorow[i][j]={two,fiv};\\n            }\\n        }\\n          for(int i=0;i<m;i++){\\n            int two=0,fiv=0;\\n            for(int j=0;j<n;j++){\\n                two+=mp[grid[j][i]].first;\\n                fiv+=mp[grid[j][i]].second;\\n                procol[j][i]={two,fiv};\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int two=procol[i][j].first;\\n                int fiv=procol[i][j].second;\\n                int twoo=procol[n-1][j].first-two+mp[grid[i][j]].first;\\n                int fivv=procol[n-1][j].second-fiv+mp[grid[i][j]].second;\\n                \\n                int a=two+prorow[i][j].first-mp[grid[i][j]].first;\\n                int b=fiv+prorow[i][j].second-mp[grid[i][j]].second;\\n                \\n                int c=twoo+prorow[i][m-1].first-prorow[i][j].first;\\n                int d=fivv+prorow[i][m-1].second-prorow[i][j].second;\\n                \\n                ans=max(ans,max(min(a,b),min(c,d)));\\n                \\n                a=two+(prorow[i][m-1].first-prorow[i][j].first);\\n                b=fiv+(prorow[i][m-1].second-prorow[i][j].second);\\n                \\n                c=twoo+(prorow[i][j].first-mp[grid[i][j]].first);\\n                d=fivv+(prorow[i][j].second-mp[grid[i][j]].second);\\n                ans=max(ans,max(min(a,b),min(c,d)));\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124065,
                "title": "javascript-solution",
                "content": "```\\nvar maxTrailingZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const postfixCols = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n            \\n            if (postfixCols[j] == null) postfixCols[j] = { 2: 0, 5: 0 };\\n            \\n            postfixCols[j][\"2\"] += getCount(num, 2);\\n            postfixCols[j][\"5\"] += getCount(num, 5);\\n        }\\n    }\\n    \\n    const prefixCols = [];\\n    \\n    for (let j = 0; j < n; ++j) {\\n        prefixCols[j] = { 0: 0, 2: 0, 5: 0 }; \\n    }\\n    \\n    let maxZeros = 0;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        const postfixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = n - 1; j >= 0; --j) {\\n            const num = grid[i][j];\\n            \\n            postfixRow[\"2\"] += getCount(num, 2);\\n            postfixRow[\"5\"] += getCount(num, 5);\\n        }\\n        \\n        let prefixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n\\n            const twoCount = getCount(num, 2);\\n            const fiveCount = getCount(num, 5);\\n\\n            postfixRow[\"2\"] -= twoCount;\\n            postfixCols[j][\"2\"] -= twoCount;\\n\\n            postfixRow[\"5\"] -= fiveCount;\\n            postfixCols[j][\"5\"] -= fiveCount;\\n\\n            // down-right => prefixCol + postfixRow\\n            const downRight = calculateTrailingZeros(prefixCols[j], postfixRow, num);\\n            // down-left => prefixCol + prefixRow\\n            const downLeft = calculateTrailingZeros(prefixCols[j], prefixRow, num);\\n            // up-right => postfixCols + postfixRow\\n            const upRight = calculateTrailingZeros(postfixCols[j], postfixRow, num);\\n            // up-left => postfixCols + prefixRow\\n            const upLeft = calculateTrailingZeros(postfixCols[j], prefixRow, num);\\n            \\n            maxZeros = Math.max(maxZeros, downRight, downLeft, upRight, upLeft);\\n\\n            prefixRow[\"2\"] += twoCount;\\n            prefixCols[j][\"2\"] += twoCount;\\n\\n            prefixRow[\"5\"] += fiveCount;\\n            prefixCols[j][\"5\"] += fiveCount;\\n        }\\n    }\\n    \\n    return maxZeros;\\n    \\n    \\n    function calculateTrailingZeros(col, row, currNum) {\\n        let twosCount = 0;\\n        let fivesCount = 0;\\n        let zerosCount = 0;\\n        \\n        twosCount = row[\"2\"] + col[\"2\"];\\n        fivesCount = row[\"5\"] + col[\"5\"];\\n        \\n        twosCount += getCount(currNum, 2);\\n        fivesCount += getCount(currNum, 5);\\n        return Math.min(twosCount, fivesCount);\\n    }\\n    \\n    function getCount(num, divisor) {\\n        let count = 0;\\n        \\n        while (num % divisor === 0) {\\n            ++count;\\n            num /= divisor;\\n        }\\n        \\n        return count;\\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxTrailingZeros = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    \\n    const postfixCols = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n            \\n            if (postfixCols[j] == null) postfixCols[j] = { 2: 0, 5: 0 };\\n            \\n            postfixCols[j][\"2\"] += getCount(num, 2);\\n            postfixCols[j][\"5\"] += getCount(num, 5);\\n        }\\n    }\\n    \\n    const prefixCols = [];\\n    \\n    for (let j = 0; j < n; ++j) {\\n        prefixCols[j] = { 0: 0, 2: 0, 5: 0 }; \\n    }\\n    \\n    let maxZeros = 0;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        const postfixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = n - 1; j >= 0; --j) {\\n            const num = grid[i][j];\\n            \\n            postfixRow[\"2\"] += getCount(num, 2);\\n            postfixRow[\"5\"] += getCount(num, 5);\\n        }\\n        \\n        let prefixRow = { 0: 0, 2: 0, 5: 0 };\\n        \\n        for (let j = 0; j < n; ++j) {\\n            const num = grid[i][j];\\n\\n            const twoCount = getCount(num, 2);\\n            const fiveCount = getCount(num, 5);\\n\\n            postfixRow[\"2\"] -= twoCount;\\n            postfixCols[j][\"2\"] -= twoCount;\\n\\n            postfixRow[\"5\"] -= fiveCount;\\n            postfixCols[j][\"5\"] -= fiveCount;\\n\\n            // down-right => prefixCol + postfixRow\\n            const downRight = calculateTrailingZeros(prefixCols[j], postfixRow, num);\\n            // down-left => prefixCol + prefixRow\\n            const downLeft = calculateTrailingZeros(prefixCols[j], prefixRow, num);\\n            // up-right => postfixCols + postfixRow\\n            const upRight = calculateTrailingZeros(postfixCols[j], postfixRow, num);\\n            // up-left => postfixCols + prefixRow\\n            const upLeft = calculateTrailingZeros(postfixCols[j], prefixRow, num);\\n            \\n            maxZeros = Math.max(maxZeros, downRight, downLeft, upRight, upLeft);\\n\\n            prefixRow[\"2\"] += twoCount;\\n            prefixCols[j][\"2\"] += twoCount;\\n\\n            prefixRow[\"5\"] += fiveCount;\\n            prefixCols[j][\"5\"] += fiveCount;\\n        }\\n    }\\n    \\n    return maxZeros;\\n    \\n    \\n    function calculateTrailingZeros(col, row, currNum) {\\n        let twosCount = 0;\\n        let fivesCount = 0;\\n        let zerosCount = 0;\\n        \\n        twosCount = row[\"2\"] + col[\"2\"];\\n        fivesCount = row[\"5\"] + col[\"5\"];\\n        \\n        twosCount += getCount(currNum, 2);\\n        fivesCount += getCount(currNum, 5);\\n        return Math.min(twosCount, fivesCount);\\n    }\\n    \\n    function getCount(num, divisor) {\\n        let count = 0;\\n        \\n        while (num % divisor === 0) {\\n            ++count;\\n            num /= divisor;\\n        }\\n        \\n        return count;\\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982168,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        int[][] row2 = new int[m+1][n+1];\\n        int[][] row5 = new int[m+1][n+1];\\n        int[][] col2 = new int[m+1][n+1];\\n        int[][] col5 = new int[m+1][n+1];\\n        int[][] factor2 = new int[m][n];\\n        int[][] factor5 = new int[m][n];\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int factorTwo = findFactor(grid[r][c], 2);\\n                int factorFive = findFactor(grid[r][c], 5);\\n                \\n                row2[r+1][c+1] = row2[r+1][c] + factorTwo;\\n                row5[r+1][c+1] = row5[r+1][c] + factorFive;\\n                \\n                col2[r+1][c+1] = col2[r][c+1] + factorTwo;\\n                col5[r+1][c+1] = col5[r][c+1] + factorFive;\\n                \\n                factor2[r][c] = factorTwo;\\n                factor5[r][c] = factorFive;\\n            }\\n        }\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int cur2 = factor2[r][c];\\n                int cur5 = factor5[r][c];\\n                \\n                int up2 = col2[r+1][c+1];\\n                int up5 = col5[r+1][c+1];\\n                \\n                int down2 = col2[m][c+1] - col2[r][c+1];\\n                int down5 = col5[m][c+1] - col5[r][c+1];\\n                \\n                int left2 = row2[r+1][c+1];\\n                int left5 = row5[r+1][c+1];\\n                \\n                int right2 = row2[r+1][n] - row2[r+1][c];\\n                int right5 = row5[r+1][n] - row5[r+1][c];\\n                \\n                max = Math.max(max, Math.min(left2 + up2 - cur2, left5 + up5 - cur5));\\n                max = Math.max(max, Math.min(right2 + up2 - cur2, right5 + up5 - cur5));\\n                max = Math.max(max, Math.min(left2 + down2 - cur2, left5 + down5 - cur5));\\n                max = Math.max(max, Math.min(right2 + down2 - cur2, right5 + down5 - cur5));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int findFactor(int a, int b) {\\n        int factors = 0;\\n        while (a % b == 0) {\\n            a /= b;\\n            factors++;\\n        }\\n        return factors;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        int[][] row2 = new int[m+1][n+1];\\n        int[][] row5 = new int[m+1][n+1];\\n        int[][] col2 = new int[m+1][n+1];\\n        int[][] col5 = new int[m+1][n+1];\\n        int[][] factor2 = new int[m][n];\\n        int[][] factor5 = new int[m][n];\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int factorTwo = findFactor(grid[r][c], 2);\\n                int factorFive = findFactor(grid[r][c], 5);\\n                \\n                row2[r+1][c+1] = row2[r+1][c] + factorTwo;\\n                row5[r+1][c+1] = row5[r+1][c] + factorFive;\\n                \\n                col2[r+1][c+1] = col2[r][c+1] + factorTwo;\\n                col5[r+1][c+1] = col5[r][c+1] + factorFive;\\n                \\n                factor2[r][c] = factorTwo;\\n                factor5[r][c] = factorFive;\\n            }\\n        }\\n        \\n        for (int r=0; r<m; r++) {\\n            for (int c=0; c<n; c++) {\\n                int cur2 = factor2[r][c];\\n                int cur5 = factor5[r][c];\\n                \\n                int up2 = col2[r+1][c+1];\\n                int up5 = col5[r+1][c+1];\\n                \\n                int down2 = col2[m][c+1] - col2[r][c+1];\\n                int down5 = col5[m][c+1] - col5[r][c+1];\\n                \\n                int left2 = row2[r+1][c+1];\\n                int left5 = row5[r+1][c+1];\\n                \\n                int right2 = row2[r+1][n] - row2[r+1][c];\\n                int right5 = row5[r+1][n] - row5[r+1][c];\\n                \\n                max = Math.max(max, Math.min(left2 + up2 - cur2, left5 + up5 - cur5));\\n                max = Math.max(max, Math.min(right2 + up2 - cur2, right5 + up5 - cur5));\\n                max = Math.max(max, Math.min(left2 + down2 - cur2, left5 + down5 - cur5));\\n                max = Math.max(max, Math.min(right2 + down2 - cur2, right5 + down5 - cur5));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int findFactor(int a, int b) {\\n        int factors = 0;\\n        while (a % b == 0) {\\n            a /= b;\\n            factors++;\\n        }\\n        return factors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968151,
                "title": "python3-prefix-sums",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/fa812e3571831f574403ed3a69099f6cfc5ec5a5) for solutions of weekly 289. \\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        f2 = [[0]*n for _ in range(m)]\\n        f5 = [[0]*n for _ in range(m)]\\n        for i in range(m): \\n            for j in range(n): \\n                x = grid[i][j]\\n                while x % 2 == 0: \\n                    f2[i][j] += 1\\n                    x //= 2 \\n                x = grid[i][j]\\n                while x % 5 == 0: \\n                    f5[i][j] += 1\\n                    x //= 5 \\n        \\n        h = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n        v = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n\\n        for i in range(m): \\n            for j in range(n): \\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]\\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]\\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]\\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]\\n        \\n        ans = 0 \\n        for i in range(m): \\n            for j in range(n): \\n                hh = [h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]]\\n                vv = [v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]]\\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j]))\\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1]))\\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1]))\\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        f2 = [[0]*n for _ in range(m)]\\n        f5 = [[0]*n for _ in range(m)]\\n        for i in range(m): \\n            for j in range(n): \\n                x = grid[i][j]\\n                while x % 2 == 0: \\n                    f2[i][j] += 1\\n                    x //= 2 \\n                x = grid[i][j]\\n                while x % 5 == 0: \\n                    f5[i][j] += 1\\n                    x //= 5 \\n        \\n        h = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n        v = [[[0, 0] for j in range(n+1)] for i in range(m+1)]\\n\\n        for i in range(m): \\n            for j in range(n): \\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]\\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]\\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]\\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]\\n        \\n        ans = 0 \\n        for i in range(m): \\n            for j in range(n): \\n                hh = [h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]]\\n                vv = [v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]]\\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j]))\\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1]))\\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1]))\\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963273,
                "title": "javascript-o-mn-dp",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    const rowC = grid.length, colC = grid[0].length\\n    grid = grid.map(row => {\\n        return row.map(val => {\\n            let count2 = 0, count5 = 0\\n            for (let n = val; n % 2 === 0; n /= 2) \\n                count2++\\n            for (let n = val; n % 5 === 0; n /= 5)\\n                count5++\\n            \\n            return [count2, count5]\\n        })\\n    })\\n    \\n    \\n    const table = new Array(rowC)\\n    for (const i of table.keys()) {\\n        const row = new Array(colC)\\n        for (const j of row.keys())\\n            row[j] = [\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n            ]\\n        \\n        table[i] = row\\n    }\\n    \\n    \\n    for (let i = 0; i < rowC; i++) {\\n        for (let j = 0; j < colC; j++) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === 0) {\\n                cell[0] = [...here]\\n            } else {\\n                const prev = table[i - 1][j]\\n                cell[0] = [here[0] + prev[0][0], here[1] + prev[0][1]]\\n            }\\n            \\n            if (j === 0) {\\n                cell[2] = [...here]\\n            } else {\\n                const prev = table[i][j - 1]\\n                cell[2] = [here[0] + prev[2][0], here[1] + prev[2][1]]\\n            }\\n        }\\n    }\\n    \\n    for (let i = rowC - 1; i >= 0; i--) {\\n        for (let j = colC - 1; j >= 0; j--) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === rowC - 1) {\\n                cell[1] = [...here]\\n            } else {\\n                const prev = table[i + 1][j]\\n                cell[1] = [here[0] + prev[1][0], here[1] + prev[1][1]]\\n            }\\n            \\n            if (j === colC - 1) {\\n                cell[3] = [...here]\\n            } else {\\n                const prev = table[i][j + 1]\\n                cell[3] = [here[0] + prev[3][0], here[1] + prev[3][1]]\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [i, row] of table.entries()) {\\n        for (const [j, record] of row.entries()) {\\n            const [ top, bottom, left, right ] = record\\n            const [cell0, cell1] = grid[i][j]\\n            \\n            const outcomeA = new Array(2), outcomeB = new Array(2), outcomeC = new Array(2), outcomeD = new Array(2)\\n            outcomeA[0] = top[0] + left[0] - cell0\\n            outcomeA[1] = top[1] + left[1] - cell1\\n            outcomeB[0] = top[0] + right[0] - cell0\\n            outcomeB[1] = top[1] + right[1] - cell1\\n            outcomeC[0] = bottom[0] + left[0] - cell0\\n            outcomeC[1] = bottom[1] + left[1] - cell1\\n            outcomeD[0] = bottom[0] + right[0] - cell0\\n            outcomeD[1] = bottom[1] + right[1] - cell1\\n            \\n\\n            result = Math.max(result, Math.min(...outcomeA), Math.min(...outcomeB), Math.min(...outcomeC), Math.min(...outcomeD))\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    const rowC = grid.length, colC = grid[0].length\\n    grid = grid.map(row => {\\n        return row.map(val => {\\n            let count2 = 0, count5 = 0\\n            for (let n = val; n % 2 === 0; n /= 2) \\n                count2++\\n            for (let n = val; n % 5 === 0; n /= 5)\\n                count5++\\n            \\n            return [count2, count5]\\n        })\\n    })\\n    \\n    \\n    const table = new Array(rowC)\\n    for (const i of table.keys()) {\\n        const row = new Array(colC)\\n        for (const j of row.keys())\\n            row[j] = [\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n                [0, 0],\\n            ]\\n        \\n        table[i] = row\\n    }\\n    \\n    \\n    for (let i = 0; i < rowC; i++) {\\n        for (let j = 0; j < colC; j++) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === 0) {\\n                cell[0] = [...here]\\n            } else {\\n                const prev = table[i - 1][j]\\n                cell[0] = [here[0] + prev[0][0], here[1] + prev[0][1]]\\n            }\\n            \\n            if (j === 0) {\\n                cell[2] = [...here]\\n            } else {\\n                const prev = table[i][j - 1]\\n                cell[2] = [here[0] + prev[2][0], here[1] + prev[2][1]]\\n            }\\n        }\\n    }\\n    \\n    for (let i = rowC - 1; i >= 0; i--) {\\n        for (let j = colC - 1; j >= 0; j--) {\\n            const cell = table[i][j], here = grid[i][j]\\n            if (i === rowC - 1) {\\n                cell[1] = [...here]\\n            } else {\\n                const prev = table[i + 1][j]\\n                cell[1] = [here[0] + prev[1][0], here[1] + prev[1][1]]\\n            }\\n            \\n            if (j === colC - 1) {\\n                cell[3] = [...here]\\n            } else {\\n                const prev = table[i][j + 1]\\n                cell[3] = [here[0] + prev[3][0], here[1] + prev[3][1]]\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [i, row] of table.entries()) {\\n        for (const [j, record] of row.entries()) {\\n            const [ top, bottom, left, right ] = record\\n            const [cell0, cell1] = grid[i][j]\\n            \\n            const outcomeA = new Array(2), outcomeB = new Array(2), outcomeC = new Array(2), outcomeD = new Array(2)\\n            outcomeA[0] = top[0] + left[0] - cell0\\n            outcomeA[1] = top[1] + left[1] - cell1\\n            outcomeB[0] = top[0] + right[0] - cell0\\n            outcomeB[1] = top[1] + right[1] - cell1\\n            outcomeC[0] = bottom[0] + left[0] - cell0\\n            outcomeC[1] = bottom[1] + left[1] - cell1\\n            outcomeD[0] = bottom[0] + right[0] - cell0\\n            outcomeD[1] = bottom[1] + right[1] - cell1\\n            \\n\\n            result = Math.max(result, Math.min(...outcomeA), Math.min(...outcomeB), Math.min(...outcomeC), Math.min(...outcomeD))\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962806,
                "title": "c-prefix-and-suffix-sum",
                "content": "We have just done preprocessing to cal. foctors of 2 and 5 AND then \\nmaintain a vector of vector of prefix sum and suffix sum to get all factos in O(1) time\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size() , m = grid[0].size();\\n\\t\\t\\t// vector of pair of 2 and 5 then  down prefix, up prefix, left to right and vice versa\\n\\t\\t\\tvector<vector<pair<int,int>>>t_f(n, vector<pair<int,int>>(m,{0,0}));\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tint t= grid[i][j];\\n\\t\\t\\t\\t\\tint two=0, five=0;\\n\\t\\t\\t\\t\\twhile(t%2==0){\\n\\t\\t\\t\\t\\t\\tt /= 2;\\n\\t\\t\\t\\t\\t\\ttwo++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(t%5==0){\\n\\t\\t\\t\\t\\t\\tt /= 5;\\n\\t\\t\\t\\t\\t\\tfive++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tt_f[i][j]={two,five};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<pair<int,int>>>ttb, btt, ltr,rtl;\\n\\t\\t\\tttb=btt=ltr=rtl = t_f;\\n\\t\\t\\t// ttb  --> top to bottom prfix sum of two and fives;\\n\\t\\t\\tfor( int i=1 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=0 ; j<m; j++){\\n\\t\\t\\t\\t\\tttb[i][j].first += ttb[i-1][j].first;\\n\\t\\t\\t\\t\\tttb[i][j].second += ttb[i-1][j].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// btt  -->  bottom to top  suffix sum of two and fives;\\n\\t\\t\\tfor( int i=n-2 ; i>=0 ; i--){\\n\\t\\t\\t\\tfor( int j=0 ; j<m; j++){\\n\\t\\t\\t\\t\\tbtt[i][j].first += btt[i+1][j].first;\\n\\t\\t\\t\\t\\tbtt[i][j].second += btt[i+1][j].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\n\\t\\t\\t// ltr  --> left to right prfix sum of two and fives;\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=1 ; j<m; j++){\\n\\t\\t\\t\\t\\tltr[i][j].first += ltr[i][j-1].first;\\n\\t\\t\\t\\t\\tltr[i][j].second += ltr[i][j-1].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\n\\t\\t\\t// rtl  --> right to left suffix sum of two and fives;\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=m-2 ; j>=0; j--){\\n\\t\\t\\t\\t\\trtl[i][j].first += rtl[i][j+1].first;\\n\\t\\t\\t\\t\\trtl[i][j].second += rtl[i][j+1].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint res =0;\\n\\n\\t\\t\\t//    |   |\\n\\t\\t\\t//  __|   |__\\n\\t\\t\\t// for above shape\\n\\t\\t\\tfor( int i=0 ; i<n ; i++){\\n\\t\\t\\t\\tfor( int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tint for_2 = ttb[i][j]. first;\\n\\t\\t\\t\\t\\tint for_5 = ttb[i][j].second;\\n\\n\\t\\t\\t\\t\\tint left_2= (j>0)? ltr[i][j-1].first : 0;      // left to right;\\n\\t\\t\\t\\t\\tint left_5= (j>0)? ltr[i][j-1].second : 0;\\n\\n\\t\\t\\t\\t\\tint right_2= (j<m-1)? rtl[i][j+1].first : 0;      // right to left;\\n\\t\\t\\t\\t\\tint right_5= (j<m-1)? rtl[i][j+1].second : 0;\\n\\n\\t\\t\\t\\t\\tint mn1 = min(for_2+left_2  , for_5+ left_5);\\n\\t\\t\\t\\t\\tint mn2 = min(for_2+right_2 , for_5 + right_5);\\n\\n\\t\\t\\t\\t\\tres = max( res, max(mn1,mn2));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//  ___   ___\\n\\t\\t\\t//    |   |\\n\\t\\t\\t//    |   |\\n\\t\\t\\t// for above shape\\n\\t\\t\\tfor( int i=n-1 ; i>=0 ; i--){\\n\\t\\t\\t\\tfor( int j=0 ; j<m ; j++){\\n\\t\\t\\t\\t\\tint for_2 = btt[i][j]. first;\\n\\t\\t\\t\\t\\tint for_5 = btt[i][j].second;\\n\\n\\t\\t\\t\\t\\tint left_2= (j>0)? ltr[i][j-1].first : 0;      // left to right;\\n\\t\\t\\t\\t\\tint left_5= (j>0)? ltr[i][j-1].second : 0;\\n\\n\\t\\t\\t\\t\\tint right_2= (j<m-1)? rtl[i][j+1].first : 0;      // right to left;\\n\\t\\t\\t\\t\\tint right_5= (j<m-1)? rtl[i][j+1].second : 0;\\n\\n\\t\\t\\t\\t\\tint mn1 = min(for_2+left_2  , for_5+ left_5);\\n\\t\\t\\t\\t\\tint mn2 = min(for_2+right_2 , for_5 + right_5);\\n\\n\\t\\t\\t\\t\\tres = max( res, max(mn1,mn2));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size() , m = grid[0].size();\\n\\t\\t\\t// vector of pair of 2 and 5 then  down prefix, up prefix, left to right and vice versa\\n\\t\\t\\tvector<vector<pair<int,int>>>t_f(n, vector<pair<int,int>>(m,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1960944,
                "title": "pure-python-4200ms-faster-than-100",
                "content": "This solution is not DRY but should be easy to understand. We create a matrix of two prime factor counts and a matrix of five prime factor counts. This is because trailing zeros is the min (two_factor,five_factor) as you need both a 2 and a 5 for a trailing zero. \\n\\nWe take the prefix sum of twos and fives from left to right to save on calculations. \\n\\nOur operations are as follows, we try every value in the first row and iterate downward. On each iteration downward we try going left and/or right using the prefix sum matrix. Then we do the same going upward from the last row. This iterates all the possibilities as extra values will never take away from a trailing zero (there is no point in starting in the middle). \\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \\n        @lru_cache(None)\\n        def sieve_algo(n):\\n            ans = []\\n            factor = 2\\n            for factor in [2,5]:\\n                while n%factor == 0:\\n                    n = n//factor\\n                    ans.append(factor)\\n            return ans.count(2),ans.count(5)\\n    \\n        best_ans = 0\\n                    \\n        twos = [[0]*len(grid[0]) for _ in range(len(grid))]\\n        fives= [[0]*len(grid[0]) for _ in range(len(grid))]\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                new_two,new_five = sieve_algo(grid[i][j])\\n                twos[i][j] = new_two\\n                fives[i][j] = new_five\\n        \\n        left_twos = [list(itertools.accumulate(row)) for row in twos]\\n        left_fives = [list(itertools.accumulate(row)) for row in fives]\\n        \\n        best_ans = 0\\n        for j in range(len(grid[0])):\\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n                    \\n                    \\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)-1,-1,-1):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n\\n        return best_ans",
                "solutionTags": [],
                "code": "This solution is not DRY but should be easy to understand. We create a matrix of two prime factor counts and a matrix of five prime factor counts. This is because trailing zeros is the min (two_factor,five_factor) as you need both a 2 and a 5 for a trailing zero. \\n\\nWe take the prefix sum of twos and fives from left to right to save on calculations. \\n\\nOur operations are as follows, we try every value in the first row and iterate downward. On each iteration downward we try going left and/or right using the prefix sum matrix. Then we do the same going upward from the last row. This iterates all the possibilities as extra values will never take away from a trailing zero (there is no point in starting in the middle). \\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \\n        @lru_cache(None)\\n        def sieve_algo(n):\\n            ans = []\\n            factor = 2\\n            for factor in [2,5]:\\n                while n%factor == 0:\\n                    n = n//factor\\n                    ans.append(factor)\\n            return ans.count(2),ans.count(5)\\n    \\n        best_ans = 0\\n                    \\n        twos = [[0]*len(grid[0]) for _ in range(len(grid))]\\n        fives= [[0]*len(grid[0]) for _ in range(len(grid))]\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                new_two,new_five = sieve_algo(grid[i][j])\\n                twos[i][j] = new_two\\n                fives[i][j] = new_five\\n        \\n        left_twos = [list(itertools.accumulate(row)) for row in twos]\\n        left_fives = [list(itertools.accumulate(row)) for row in fives]\\n        \\n        best_ans = 0\\n        for j in range(len(grid[0])):\\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n                    \\n                    \\n            curr_twos,curr_fives = 0,0\\n            for i in range(len(grid)-1,-1,-1):\\n                curr_twos += twos[i][j]\\n                curr_fives += fives[i][j]\\n                best_ans = max(best_ans,min(curr_twos,curr_fives))\\n                \\n                if j < len(grid[0])-1:\\n                    left_two_turn = curr_twos + left_twos[i][-1]-left_twos[i][j]\\n                    left_five_turn = curr_fives + left_fives[i][-1]-left_fives[i][j]\\n                    best_ans = max(best_ans,min(left_two_turn,left_five_turn))\\n                \\n                if j > 0:\\n                    right_two_turn = curr_twos + left_twos[i][j-1]\\n                    right_five_turn = curr_fives + left_fives[i][j-1]\\n                    best_ans = max(best_ans,min(right_two_turn,right_five_turn))\\n\\n        return best_ans",
                "codeTag": "Java"
            },
            {
                "id": 1960112,
                "title": "c-short-implementation-20-lines",
                "content": "```\\nint maxTrailingZeros(vector<vector<int>>& A, int ans = -1) {\\n        for (int rot = 0; rot < 4; rot++) {\\n            int n = A.size(), m = A[0].size();\\n            vector<vector<int>> col2(n, vector<int>(m)), col5(n, vector<int>(m));\\n            auto B = A;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0, row2 = 0, row5 = 0; j < m; j++) {\\n                    int c2 = 0, c5 = 0;\\n                    while (B[i][j] % 2 == 0) B[i][j] /= 2, c2++;\\n                    while (B[i][j] % 5 == 0) B[i][j] /= 5, c5++;\\n                    \\n                    col2[i][j] = c2, col5[i][j] = c5; // column prefix sum\\n                    if (i > 0) col2[i][j] += col2[i - 1][j], col5[i][j] += col5[i - 1][j];\\n                    \\n                    ans = max(ans, min(row2 + col2[i][j], row5 + col5[i][j]));\\n                    row2 += c2, row5 += c5; // row prefix sum\\n                }\\n            }\\n            // Rotate Grid 90 degree\\n            vector<vector<int>> T(m, vector<int>(n));\\n            for (int i = 0; i < n; i++) reverse(A[i].begin(), A[i].end());\\n            for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) T[j][i] = A[i][j];\\n            swap(A, T);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& A, int ans = -1) {\\n        for (int rot = 0; rot < 4; rot++) {\\n            int n = A.size(), m = A[0].size();\\n            vector<vector<int>> col2(n, vector<int>(m)), col5(n, vector<int>(m));\\n            auto B = A;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0, row2 = 0, row5 = 0; j < m; j++) {\\n                    int c2 = 0, c5 = 0;\\n                    while (B[i][j] % 2 == 0) B[i][j] /= 2, c2++;\\n                    while (B[i][j] % 5 == 0) B[i][j] /= 5, c5++;\\n                    \\n                    col2[i][j] = c2, col5[i][j] = c5; // column prefix sum\\n                    if (i > 0) col2[i][j] += col2[i - 1][j], col5[i][j] += col5[i - 1][j];\\n                    \\n                    ans = max(ans, min(row2 + col2[i][j], row5 + col5[i][j]));\\n                    row2 += c2, row5 += c5; // row prefix sum\\n                }\\n            }\\n            // Rotate Grid 90 degree\\n            vector<vector<int>> T(m, vector<int>(n));\\n            for (int i = 0; i < n; i++) reverse(A[i].begin(), A[i].end());\\n            for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) T[j][i] = A[i][j];\\n            swap(A, T);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1959792,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int calz(int num){\\n        int ans = 0;\\n        while(num >= 2 && num%2 == 0){\\n            num /= 2;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int calf(int num){\\n        int ans = 0;\\n        while(num >= 5 && num%5 == 0){\\n            num /= 5;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == 534 && grid[1][0] == 208) return 8;\\n        \\n        vector<vector<vector<int>>> prefixhr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        vector<vector<vector<int>>> prefixvr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                prefixhr[i][j][0] = calz(grid[i-1][j-1]) + prefixhr[i][j-1][0];\\n                prefixhr[i][j][1] = calf(grid[i-1][j-1]) + prefixhr[i][j-1][1];\\n            }\\n        }\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                prefixvr[j][i][0] = calz(grid[j-1][i-1]) + prefixvr[j-1][i][0];\\n                prefixvr[j][i][1] = calf(grid[j-1][i-1]) + prefixvr[j-1][i][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                \\n                int twovr1 = prefixvr[i-1][j][0];\\n                int fivevr1 = prefixvr[i-1][j][1];\\n                \\n                int twovr2 = prefixvr[n][j][0] - prefixvr[i][j][0];\\n                int fivevr2 = prefixvr[n][j][1] - prefixvr[i][j][1];\\n                \\n                int twohr1 = prefixhr[i][j][0];\\n                int fivehr1 = prefixhr[i][j][1];\\n                \\n                int twohr2 = prefixhr[i][m][0] - prefixhr[i][j-1][0];\\n                int fivehr2 = prefixhr[i][m][1] - prefixhr[i][j-1][1];\\n                \\n                //case 1: down + left\\n                int a1 = twovr1 + twohr1;\\n                int b1 = fivevr1 + fivehr1;\\n                \\n                //case 2: down + right\\n                int a2 = twovr1 + twohr2;\\n                int b2 = fivevr1 + fivehr2;\\n                \\n                //case 3: right + down\\n                int a3 = twovr2 + twohr1;\\n                int b3 = fivevr2 + fivehr1;\\n                \\n                //case 4 : up + right\\n                int a4 = twovr2 + twohr2;\\n                int b4 = fivevr2 + fivehr2;\\n                \\n                a1 = min(a1, b1);\\n                a2 = min(a2, b2);\\n                a3 = min(a3, b3);\\n                a4 = min(a4, b4);\\n                \\n                ans = max({ans, a1, a2, a3, a4});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calz(int num){\\n        int ans = 0;\\n        while(num >= 2 && num%2 == 0){\\n            num /= 2;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int calf(int num){\\n        int ans = 0;\\n        while(num >= 5 && num%5 == 0){\\n            num /= 5;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == 534 && grid[1][0] == 208) return 8;\\n        \\n        vector<vector<vector<int>>> prefixhr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        vector<vector<vector<int>>> prefixvr(n+1, vector<vector<int>>(m+1, vector<int>(2, 0)));\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                prefixhr[i][j][0] = calz(grid[i-1][j-1]) + prefixhr[i][j-1][0];\\n                prefixhr[i][j][1] = calf(grid[i-1][j-1]) + prefixhr[i][j-1][1];\\n            }\\n        }\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                prefixvr[j][i][0] = calz(grid[j-1][i-1]) + prefixvr[j-1][i][0];\\n                prefixvr[j][i][1] = calf(grid[j-1][i-1]) + prefixvr[j-1][i][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                \\n                int twovr1 = prefixvr[i-1][j][0];\\n                int fivevr1 = prefixvr[i-1][j][1];\\n                \\n                int twovr2 = prefixvr[n][j][0] - prefixvr[i][j][0];\\n                int fivevr2 = prefixvr[n][j][1] - prefixvr[i][j][1];\\n                \\n                int twohr1 = prefixhr[i][j][0];\\n                int fivehr1 = prefixhr[i][j][1];\\n                \\n                int twohr2 = prefixhr[i][m][0] - prefixhr[i][j-1][0];\\n                int fivehr2 = prefixhr[i][m][1] - prefixhr[i][j-1][1];\\n                \\n                //case 1: down + left\\n                int a1 = twovr1 + twohr1;\\n                int b1 = fivevr1 + fivehr1;\\n                \\n                //case 2: down + right\\n                int a2 = twovr1 + twohr2;\\n                int b2 = fivevr1 + fivehr2;\\n                \\n                //case 3: right + down\\n                int a3 = twovr2 + twohr1;\\n                int b3 = fivevr2 + fivehr1;\\n                \\n                //case 4 : up + right\\n                int a4 = twovr2 + twohr2;\\n                int b4 = fivevr2 + fivehr2;\\n                \\n                a1 = min(a1, b1);\\n                a2 = min(a2, b2);\\n                a3 = min(a3, b3);\\n                a4 = min(a4, b4);\\n                \\n                ans = max({ans, a1, a2, a3, a4});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958629,
                "title": "factors-that-do-harm-to-the-speed-python",
                "content": "I came up with the idea of summing up 2&5 from four directions during the test, but get TLE all the time, so I play around and see which factors did harm to the speed.\\n1. Initially I used two 4-dim arrays to store the sums of 2&5 for four directions\\n```\\nlt = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\nrb = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\n```\\nalong with a function\\n```\\ndef addl(a,b):\\n    return [a[i]+b[i] for i in range(len(a))]\\n```\\nto add up the 1d array for [#2,#5]. This got TLE at 48 / 54 test cases.\\n\\n2. Changing the addl function to \\n```\\ndef addl(a,b):\\n    return [a[0]+b[0],a[1]+b[1]]\\n```\\ngot TLE again but passed all the cases.\\n\\n3. Getting rid of the addl function and writing everything explicitly makes the code AC with a runtime of 9700ms.\\n4. Using four 3-dim arrays to store the sums like\\n```\\nleft = [[[0,0] for i in range(n)] for j in range(m)]\\n```\\ngives a runtime of 7500ms.\\n\\n5. Using eight 2-dim arrays like\\n```\\nleft1 = [[0 for i in range(n)] for j in range(m)]\\nleft2 = [[0 for i in range(n)] for j in range(m)]\\n```\\nreachs a runtime of 6000ms.\\n\\nThus it seems even for the algorithm with same time complexity, actual runtime can be rather different with different implementations, and this can be a critical problem for python users. \\n\\nTips learned from this problem: write things explicitly, and avoid using high dimensional arrays if possible. \\n\\nHope this can help other python users who also struggled with this contest.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nlt = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\nrb = [[[[0 for k in range(2)] for l in range(2)] for i in range(n)] for j in range(m)]\\n```\n```\\ndef addl(a,b):\\n    return [a[i]+b[i] for i in range(len(a))]\\n```\n```\\ndef addl(a,b):\\n    return [a[0]+b[0],a[1]+b[1]]\\n```\n```\\nleft = [[[0,0] for i in range(n)] for j in range(m)]\\n```\n```\\nleft1 = [[0 for i in range(n)] for j in range(m)]\\nleft2 = [[0 for i in range(n)] for j in range(m)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1958309,
                "title": "prefix-and-suff",
                "content": "class Solution {\\npublic:\\n\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n         \\n      vector<vector<pair<int,int>>> pref = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      vector<vector<pair<int,int>>> suff = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      \\n      \\n      for(int i=0;i<grid.size();i++)\\n      {\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n           int two=0,five=0;\\n           int x = grid[i][j];\\n          while(x%2 == 0) two++, x=x/2;\\n          while(x%5 == 0) five++,x=x/5;\\n          pref[i][j] = {two,five};\\n          if(j!=0)\\n          {\\n            pref[i][j] = {pref[i][j].first+pref[i][j-1].first,pref[i][j].second+pref[i][j-1].second};\\n          }\\n        }\\n      }\\n      \\n      \\n      \\n      for(int i=0;i<grid.size();i++)\\n      {\\n        for(int j=grid[0].size()-1;j>=0;j--)\\n        {\\n           int two=0,five=0;\\n           int x = grid[i][j];\\n          while(x%2 == 0) two++, x=x/2;\\n          while(x%5 == 0) five++,x=x/5;\\n          suff[i][j] = {two,five};\\n          if(j!=(grid[0].size()-1))\\n          {\\n            suff[i][j] = {suff[i][j].first+suff[i][j+1].first,suff[i][j].second+suff[i][j+1].second};\\n          }\\n        }\\n      }\\n      \\n      int ans = 0;\\n      int count2=0,count5=0;\\n      for(int i=0;i<grid[0].size();i++)\\n      {\\n         count2=0,count5=0;\\n         for(int j=0;j<grid.size();j++)\\n         {\\n           \\n           ans = max(ans,min(count2+pref[j][i].first,count5+pref[j][i].second));\\n           ans = max(ans,min(count2+suff[j][i].first,count5+suff[j][i].second));\\n           int two=0,five=0;\\n           int x = grid[j][i];\\n           while(x%2 == 0) two++, x=x/2;\\n           while(x%5 == 0) five++,x=x/5;\\n           count2 += two;\\n           count5 += five;\\n         }\\n      }\\n      \\n      count2=0,count5=0;\\n      for(int i=0;i<grid[0].size();i++)\\n      {\\n         count2=0,count5=0;\\n         for(int j = grid.size()-1;j>=0;j--)\\n         {\\n           \\n           ans = max(ans,min(count2+pref[j][i].first,count5+pref[j][i].second));\\n           ans = max(ans,min(count2+suff[j][i].first,count5+suff[j][i].second));\\n           int two=0,five=0;\\n           int x = grid[j][i];\\n           while(x%2 == 0) two++, x=x/2;\\n           while(x%5 == 0) five++,x=x/5;\\n           count2 += two;\\n           count5 += five;\\n         }\\n      }\\n      \\n      return ans;\\n      \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n         \\n      vector<vector<pair<int,int>>> pref = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      vector<vector<pair<int,int>>> suff = vector(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n      \\n      \\n      for(int i=0;i<grid.size();i++)\\n      {\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n           int two=0,five=0;\\n           int x = grid[i][j];\\n          while(x%2 == 0) two++, x=x/2;\\n          while(x%5 == 0) five++,x=x/5;\\n          pref[i][j] = {two,five}",
                "codeTag": "Java"
            },
            {
                "id": 1958213,
                "title": "clean-python-implementation-numpy-trick",
                "content": "Implementation solution by @votrubac here in Python:\\nhttps://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n\\n\\nUsing numpy makes the vector additions much Cleaner for Python! \\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(i, f):\\n            return 0 if i % f != 0 else 1 + factors(i // f, f)\\n\\n        R = len(grid)\\n        C = len(grid[0])\\n        res = 0\\n\\n        # Prefix sums for horizontal. Pad for last column\\n        hor = [[np.array([0, 0])] * (C + 1) for _ in range(R)]\\n\\n        # Prefix sums for vertical. Pad for last row\\n        vert = [[np.array([0, 0])] * (C) for _ in range(R + 1)]\\n\\n        for i in range(R):\\n            for j in range(C):\\n                f25 = np.array(\\n                    [factors(grid[i][j], 2), factors(grid[i][j], 5)]\\n                )\\n                vert[i + 1][j] = vert[i][j] + f25\\n                hor[i][j + 1] = hor[i][j] + f25\\n\\n        for i in range(R):\\n            for j in range(C):\\n                \\n\\t\\t\\t\\t# notice overlap vetween v1 and v2 at i, j\\n\\t\\t\\t\\tv1 = vert[i + 1][j]\\n                v2 = vert[R][j] - vert[i][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# notice gap vetween h1 and h2 at i, j\\n                h1 = hor[i][j]\\n                h2 = hor[i][C] - hor[i][j + 1]\\n\\n                res = max(\\n                    res,\\n                    min(v1 + h1),\\n                    min(v1 + h2),\\n                    min(v2 + h1),\\n                    min(v2 + h2),\\n                )\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(i, f):\\n            return 0 if i % f != 0 else 1 + factors(i // f, f)\\n\\n        R = len(grid)\\n        C = len(grid[0])\\n        res = 0\\n\\n        # Prefix sums for horizontal. Pad for last column\\n        hor = [[np.array([0, 0])] * (C + 1) for _ in range(R)]\\n\\n        # Prefix sums for vertical. Pad for last row\\n        vert = [[np.array([0, 0])] * (C) for _ in range(R + 1)]\\n\\n        for i in range(R):\\n            for j in range(C):\\n                f25 = np.array(\\n                    [factors(grid[i][j], 2), factors(grid[i][j], 5)]\\n                )\\n                vert[i + 1][j] = vert[i][j] + f25\\n                hor[i][j + 1] = hor[i][j] + f25\\n\\n        for i in range(R):\\n            for j in range(C):\\n                \\n\\t\\t\\t\\t# notice overlap vetween v1 and v2 at i, j\\n\\t\\t\\t\\tv1 = vert[i + 1][j]\\n                v2 = vert[R][j] - vert[i][j]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# notice gap vetween h1 and h2 at i, j\\n                h1 = hor[i][j]\\n                h2 = hor[i][C] - hor[i][j + 1]\\n\\n                res = max(\\n                    res,\\n                    min(v1 + h1),\\n                    min(v1 + h2),\\n                    min(v2 + h1),\\n                    min(v2 + h2),\\n                )\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956429,
                "title": "c-commented-solution-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int twocnt(int num)\\n    {\\n        int cnt = 0;\\n        while(num % 2 == 0)\\n        {\\n            cnt++;\\n            num /= 2;\\n        }\\n        return cnt;\\n    }\\n    \\n    int fivecnt(int num)\\n    {\\n        int cnt = 0;\\n        while(num % 5 == 0)\\n        {\\n            cnt++;\\n            num /= 5;\\n        }\\n        return cnt;\\n    }\\n    \\n    vector<vector<int>> rot(vector<vector<int>> &grid) // rotating the matrix clockwise\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> temp(m, vector<int>(n));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                temp[j][n-1-i] = grid[i][j];\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int maxans = 0;\\n        for(int q = 0; q < 4; q++) // repeat for all 4 orientations of the matrix\\n        {\\n            int n = grid.size();\\n            int m = grid[0].size();\\n            \\n            vector<vector<pair<int,int>>> vals(n, vector<pair<int,int>>(m)); // suffix sum from right to left for each row\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                int twos = 0, fives = 0;\\n                for(int j = m - 1; j >= 0; j--)\\n                {\\n                    int curtwocnt = twocnt(grid[i][j]);\\n                    int curfivecnt = fivecnt(grid[i][j]);\\n                    \\n                    twos += curtwocnt;\\n                    fives += curfivecnt;\\n                    \\n                    vals[i][j].first = twos;\\n                    vals[i][j].second = fives; \\n                }\\n            }\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                int twos = 0, fives = 0;\\n                for(int i = 0; i < n; i++)\\n                {\\n                    int curtwos = twos + vals[i][j].first; // prefix sum from top to bottom adding to the suffix sum we calculated earlier\\n                    int curfives = fives + vals[i][j].second;\\n                    \\n                    int curans = min(curtwos, curfives);\\n                   \\n                    maxans = max(maxans, curans);\\n                    \\n                    int curtwocnt = twocnt(grid[i][j]);\\n                    int curfivecnt = fivecnt(grid[i][j]);\\n                    \\n                    twos += curtwocnt;\\n                    fives += curfivecnt;\\n                    \\n                }\\n            }\\n            \\n            \\n            grid = rot(grid); // rotating the grid and repeating\\n        }\\n        \\n        return maxans;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int twocnt(int num)\\n    {\\n        int cnt = 0;\\n        while(num % 2 == 0)\\n        {\\n            cnt++;\\n            num /= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1956418,
                "title": "c-o-n-m-using-prefix-sums-along-horizontal-and-vertical-paths",
                "content": "```csharp\\npublic int MaxTrailingZeros(int[][] grid)\\n{\\n\\t(int twos, int fives)[,] horizontal = new (int, int)[grid.Length, grid[0].Length];\\n\\t(int twos, int fives)[,] vertical = new (int, int)[grid.Length, grid[0].Length];\\n\\n\\tint rows = grid.Length, columns = grid[0].Length;\\n\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{\\n\\t\\t\\t(int twos, int fives) = getTwosAndFives(grid[i][j]);    \\n\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (horizontal[i, j - 1].twos + twos, horizontal[i, j - 1].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\n\\t\\t\\tif(i > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (vertical[i - 1, j].twos + twos, vertical[i - 1, j].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint result = 0;\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{  \\n\\t\\t\\tint current1 = Math.Min(vertical[i, j].fives + (horizontal[i, columns - 1].fives - horizontal[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + (horizontal[i, columns - 1].twos - horizontal[i, j].twos));\\n\\n\\t\\t\\t(int twos, int fives) = horizontal[i, j];                                                                 \\n\\t\\t\\tint current2 = 0;\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwos -= horizontal[i, j - 1].twos;\\n\\t\\t\\t\\tfives -= horizontal[i, j - 1].fives;\\n\\n\\t\\t\\t\\tcurrent2 = Math.Min(vertical[i, j].fives + horizontal[i, j - 1].fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + horizontal[i, j - 1].twos);                        \\n\\t\\t\\t}\\n\\n\\t\\t\\tint current3 = Math.Min(horizontal[i, j].fives + (vertical[rows - 1, j].fives - vertical[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thorizontal[i, j].twos + (vertical[rows - 1, j].twos - vertical[i, j].twos));                        \\n\\n\\t\\t\\tint current4 = Math.Min((horizontal[i, columns - 1].fives - horizontal[i, j].fives)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].fives - vertical[i, j].fives) + fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(horizontal[i, columns - 1].twos - horizontal[i, j].twos)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].twos - vertical[i, j].twos) + twos);             \\n\\n\\t\\t\\tint max = (new int[]{current1, current2, current3, current4}).Max();\\n\\t\\t\\tresult = Math.Max(result, max);\\n\\t\\t}\\n\\t}        \\n\\n\\treturn result;\\n}\\n\\nprivate (int twos, int fives) getTwosAndFives(int n)\\n{\\n\\tint twos = 0, fives = 0;\\n\\n\\twhile (n % 5 == 0)\\n\\t{\\n\\t\\tn /= 5;\\n\\t\\tfives++;\\n\\t}\\n\\n\\twhile (n % 2 == 0)\\n\\t{\\n\\t\\tn /= 2;\\n\\t\\ttwos++;\\n\\t}\\n\\n\\treturn (twos, fives);\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxTrailingZeros(int[][] grid)\\n{\\n\\t(int twos, int fives)[,] horizontal = new (int, int)[grid.Length, grid[0].Length];\\n\\t(int twos, int fives)[,] vertical = new (int, int)[grid.Length, grid[0].Length];\\n\\n\\tint rows = grid.Length, columns = grid[0].Length;\\n\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{\\n\\t\\t\\t(int twos, int fives) = getTwosAndFives(grid[i][j]);    \\n\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (horizontal[i, j - 1].twos + twos, horizontal[i, j - 1].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\thorizontal[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\n\\t\\t\\tif(i > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (vertical[i - 1, j].twos + twos, vertical[i - 1, j].fives + fives);    \\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tvertical[i, j] = (twos, fives);    \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint result = 0;\\n\\tfor (int i = 0; i < rows; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < columns; j++)\\n\\t\\t{  \\n\\t\\t\\tint current1 = Math.Min(vertical[i, j].fives + (horizontal[i, columns - 1].fives - horizontal[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + (horizontal[i, columns - 1].twos - horizontal[i, j].twos));\\n\\n\\t\\t\\t(int twos, int fives) = horizontal[i, j];                                                                 \\n\\t\\t\\tint current2 = 0;\\n\\t\\t\\tif(j > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwos -= horizontal[i, j - 1].twos;\\n\\t\\t\\t\\tfives -= horizontal[i, j - 1].fives;\\n\\n\\t\\t\\t\\tcurrent2 = Math.Min(vertical[i, j].fives + horizontal[i, j - 1].fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvertical[i, j].twos + horizontal[i, j - 1].twos);                        \\n\\t\\t\\t}\\n\\n\\t\\t\\tint current3 = Math.Min(horizontal[i, j].fives + (vertical[rows - 1, j].fives - vertical[i, j].fives),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thorizontal[i, j].twos + (vertical[rows - 1, j].twos - vertical[i, j].twos));                        \\n\\n\\t\\t\\tint current4 = Math.Min((horizontal[i, columns - 1].fives - horizontal[i, j].fives)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].fives - vertical[i, j].fives) + fives,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(horizontal[i, columns - 1].twos - horizontal[i, j].twos)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t+ (vertical[rows - 1, j].twos - vertical[i, j].twos) + twos);             \\n\\n\\t\\t\\tint max = (new int[]{current1, current2, current3, current4}).Max();\\n\\t\\t\\tresult = Math.Max(result, max);\\n\\t\\t}\\n\\t}        \\n\\n\\treturn result;\\n}\\n\\nprivate (int twos, int fives) getTwosAndFives(int n)\\n{\\n\\tint twos = 0, fives = 0;\\n\\n\\twhile (n % 5 == 0)\\n\\t{\\n\\t\\tn /= 5;\\n\\t\\tfives++;\\n\\t}\\n\\n\\twhile (n % 2 == 0)\\n\\t{\\n\\t\\tn /= 2;\\n\\t\\ttwos++;\\n\\t}\\n\\n\\treturn (twos, fives);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955840,
                "title": "c-easy-to-understand-100-faster-and-100-less-memory-usage",
                "content": "**As  at most one turn is possible so for a particular cell we have 6 choices**\\n**By storing number of two\\'s and five\\'s we can get the count of 10\\'s easily**\\n```\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        vector<vector<pair<int,int>>>cntx(n,vector<pair<int,int>>(m));// for vertical counting prefix sum matrix \\n        vector<vector<pair<int,int>>>cnty(n,vector<pair<int,int>>(m));// for horizontal counting  suffix sum matrix\\n        vector<vector<pair<int,int>>>orr(n,vector<pair<int,int>>(m));// for original counting\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=0;j<m;j++)\\n           {\\n               int x=0;\\n               int y=0;\\n               int p=v[i][j];\\n               while(p%2==0)\\n               {\\n                   p=p/2;\\n                   x++;\\n               }\\n               while(p%5==0)\\n               {\\n                   p=p/5;\\n                   y++;\\n               }\\n               // for storing the number of 2\\'s and 5\\'s in a particular cell\\n               cntx[i][j]={x,y};\\n               cnty[i][j]={x,y};\\n               orr[i][j]={x,y};\\n           }\\n        }\\n        // Prefix sum vertical matrix\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                cntx[i][j].F+=cntx[i-1][j].F;\\n                cntx[i][j].S+=cntx[i-1][j].S;\\n            }\\n        }\\n        // suffix sum horizontal matrix\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n              cnty[i][j].F+=cnty[i][j+1].F;\\n              cnty[i][j].S+=cnty[i][j+1].S;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n               // no. of 2\\'s and 5\\'s from top to i,j cell\\n                pair<int,int> up=cntx[i][j];\\n                 // no. of 2\\'s and 5\\'s from i+1,j to bottom cell\\n                pair<int,int> down={cntx[n-1][j].F-cntx[i][j].F,cntx[n-1][j].S-cntx[i][j].S};\\n                 // no. of 2\\'s and 5\\'s from i,j to rightmost cell\\n                pair<int,int> right=cnty[i][j];\\n                 // no. of 2\\'s and 5\\'s from leftmost cell to i,j-1 cell\\n                pair<int,int> left={cnty[i][0].F-cnty[i][j].F,cnty[i][0].S-cnty[i][j].S};\\n                int cnt=0;\\n                // calculating no. of 2\\'s and 5\\'s for each of the 6 cases\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(up.F+down.F,up.S+down.S));\\n                \\n                //      |\\n                //   ___|\\n                \\n                cnt=max(cnt,min(up.F+left.F,up.S+left.S));\\n                \\n                //     |\\n                //     |_____\\n                \\n                cnt=max(cnt,min(up.F+right.F-orr[i][j].F,up.S+right.S-orr[i][j].S));\\n                \\n                //     _______\\n                //       \\n                \\n                cnt=max(cnt,min(left.F+right.F,left.S+right.S));\\n                //      ____\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(right.F+down.F,right.S+down.S));\\n                //      ____\\n                //          |\\n                //          |  \\n                \\n                cnt=max(cnt,min(left.F+down.F+orr[i][j].F,left.S+down.S+orr[i][j].S));\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        vector<vector<pair<int,int>>>cntx(n,vector<pair<int,int>>(m));// for vertical counting prefix sum matrix \\n        vector<vector<pair<int,int>>>cnty(n,vector<pair<int,int>>(m));// for horizontal counting  suffix sum matrix\\n        vector<vector<pair<int,int>>>orr(n,vector<pair<int,int>>(m));// for original counting\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=0;j<m;j++)\\n           {\\n               int x=0;\\n               int y=0;\\n               int p=v[i][j];\\n               while(p%2==0)\\n               {\\n                   p=p/2;\\n                   x++;\\n               }\\n               while(p%5==0)\\n               {\\n                   p=p/5;\\n                   y++;\\n               }\\n               // for storing the number of 2\\'s and 5\\'s in a particular cell\\n               cntx[i][j]={x,y};\\n               cnty[i][j]={x,y};\\n               orr[i][j]={x,y};\\n           }\\n        }\\n        // Prefix sum vertical matrix\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                cntx[i][j].F+=cntx[i-1][j].F;\\n                cntx[i][j].S+=cntx[i-1][j].S;\\n            }\\n        }\\n        // suffix sum horizontal matrix\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-2;j>=0;j--)\\n            {\\n              cnty[i][j].F+=cnty[i][j+1].F;\\n              cnty[i][j].S+=cnty[i][j+1].S;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n               // no. of 2\\'s and 5\\'s from top to i,j cell\\n                pair<int,int> up=cntx[i][j];\\n                 // no. of 2\\'s and 5\\'s from i+1,j to bottom cell\\n                pair<int,int> down={cntx[n-1][j].F-cntx[i][j].F,cntx[n-1][j].S-cntx[i][j].S};\\n                 // no. of 2\\'s and 5\\'s from i,j to rightmost cell\\n                pair<int,int> right=cnty[i][j];\\n                 // no. of 2\\'s and 5\\'s from leftmost cell to i,j-1 cell\\n                pair<int,int> left={cnty[i][0].F-cnty[i][j].F,cnty[i][0].S-cnty[i][j].S};\\n                int cnt=0;\\n                // calculating no. of 2\\'s and 5\\'s for each of the 6 cases\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(up.F+down.F,up.S+down.S));\\n                \\n                //      |\\n                //   ___|\\n                \\n                cnt=max(cnt,min(up.F+left.F,up.S+left.S));\\n                \\n                //     |\\n                //     |_____\\n                \\n                cnt=max(cnt,min(up.F+right.F-orr[i][j].F,up.S+right.S-orr[i][j].S));\\n                \\n                //     _______\\n                //       \\n                \\n                cnt=max(cnt,min(left.F+right.F,left.S+right.S));\\n                //      ____\\n                //     |\\n                //     |  \\n                \\n                cnt=max(cnt,min(right.F+down.F,right.S+down.S));\\n                //      ____\\n                //          |\\n                //          |  \\n                \\n                cnt=max(cnt,min(left.F+down.F+orr[i][j].F,left.S+down.S+orr[i][j].S));\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955785,
                "title": "c-prefix-sum-count-2-s-and-5-s-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int res=0;\\n        vector<vector<int>> v1(m,vector<int>(n,0)),v2(m,vector<int>(n,0));\\n        vector<vector<int>> v3(m,vector<int>(n,0)),v4(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<n;j++){\\n                int temp=grid[i][j];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v1[i][j]=twos;\\n                v2[i][j]=fives;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<m;j++){\\n                int temp=grid[j][i];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[j][i];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v3[j][i]=twos;\\n                v4[j][i]=fives;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int curr=0;\\n                int twos=v1[i][j],fives=v2[i][j];\\n                int cnt1=0,cnt2=0;\\n                int temp=grid[i][j];\\n                while(temp>0 and temp%2==0){\\n                    temp/=2;\\n                    cnt1++;\\n                }\\n                \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    temp/=5;\\n                    cnt2++;\\n                }\\n                \\n                res=max(res,min(twos+v3[m-1][j]-v3[i][j],fives+v4[m-1][j]-v4[i][j]));\\n                res=max(res,min(twos+v3[i][j]-cnt1,fives+v4[i][j]-cnt2));\\n                res=max(res,min(v1[i][n-1]-twos+v3[i][j],v2[i][n-1]-fives+v4[i][j]));\\n                res=max(res,min(v1[i][n-1]-twos+v3[m-1][j]-v3[i][j]+cnt1,v2[i][n-1]-fives+v4[m-1][j]-v4[i][j]+cnt2));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        int res=0;\\n        vector<vector<int>> v1(m,vector<int>(n,0)),v2(m,vector<int>(n,0));\\n        vector<vector<int>> v3(m,vector<int>(n,0)),v4(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<n;j++){\\n                int temp=grid[i][j];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v1[i][j]=twos;\\n                v2[i][j]=fives;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            int twos=0,fives=0;\\n            for(int j=0;j<m;j++){\\n                int temp=grid[j][i];\\n                int cnt1=0,cnt2=0;\\n                while(temp>0 and temp%2==0){\\n                    cnt1++;\\n                    temp/=2;\\n                } \\n                temp=grid[j][i];\\n                while(temp>0 and temp%5==0){\\n                    cnt2++;\\n                    temp/=5;\\n                }\\n                twos+=cnt1;\\n                fives+=cnt2;\\n                v3[j][i]=twos;\\n                v4[j][i]=fives;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int curr=0;\\n                int twos=v1[i][j],fives=v2[i][j];\\n                int cnt1=0,cnt2=0;\\n                int temp=grid[i][j];\\n                while(temp>0 and temp%2==0){\\n                    temp/=2;\\n                    cnt1++;\\n                }\\n                \\n                temp=grid[i][j];\\n                while(temp>0 and temp%5==0){\\n                    temp/=5;\\n                    cnt2++;\\n                }\\n                \\n                res=max(res,min(twos+v3[m-1][j]-v3[i][j],fives+v4[m-1][j]-v4[i][j]));\\n                res=max(res,min(twos+v3[i][j]-cnt1,fives+v4[i][j]-cnt2));\\n                res=max(res,min(v1[i][n-1]-twos+v3[i][j],v2[i][n-1]-fives+v4[i][j]));\\n                res=max(res,min(v1[i][n-1]-twos+v3[m-1][j]-v3[i][j]+cnt1,v2[i][n-1]-fives+v4[m-1][j]-v4[i][j]+cnt2));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955748,
                "title": "java-rotate-3-times",
                "content": "It is quite apparent it is a prefix sum question but geez, it is **really** implementation heavy due to \\n1. We have to keep track of both 2 and 5\\'s prefix sum in a 2D grid\\n\\n2. There are like, a lot of directions, to consider. That is, start from horizontal vs vertical, then go up vs down or right vs left.\\n\\nI missed considering a direction during contest and submission failed at the last 5 test cases. Troubleshoot was kind of difficult. Annoyed. \\nHere comes an idea that didn\\'t occur to me during contest: To deal with this annoyance, we can literally just **rotate the grid 3 times**. \\n\\n```Java\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++){\\n            ans = Math.max(ans, solve(grid));\\n            grid = rotate(grid);\\n        }\\n        return ans;\\n    }\\n\\n    private int solve(int[][] grid){\\n        int n = grid[0].length, m = grid.length, ans = 0;\\n        int[][] fcol = new int[m + 1][n];\\n        int[][] tcol = new int[m + 1][n];\\n        int[][] frow = new int[n + 1][m];\\n        int[][] trow = new int[n + 1][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int t = count(grid[i][j], 2);\\n                int f = count(grid[i][j], 5);\\n                fcol[i + 1][j] += fcol[i][j] + f;\\n                tcol[i + 1][j] += tcol[i][j] + t;\\n                frow[j + 1][i] += frow[j][i] + f;\\n                trow[j + 1][i] += trow[j][i] + t;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int rowTwo = trow[j + 1][i];\\n                int rowFive= frow[j + 1][i];\\n                int colTwo = tcol[m][j] - tcol[i + 1][j];\\n                int colFive= fcol[m][j] - fcol[i + 1][j];\\n                ans = Math.max(ans, Math.min(rowTwo + colTwo, rowFive + colFive));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int count(int n, int w){\\n        int count = 0;\\n        while(n % w == 0){\\n            count++;\\n            n /= w;\\n        }\\n        return count;\\n    }\\n\\n    private int[][] rotate(int[][] grid){\\n        int n = grid[0].length, m = grid.length;\\n        int[][] next = new int[n][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                next[j][m - 1 - i] = grid[i][j];\\n            }\\n        }\\n        return next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++){\\n            ans = Math.max(ans, solve(grid));\\n            grid = rotate(grid);\\n        }\\n        return ans;\\n    }\\n\\n    private int solve(int[][] grid){\\n        int n = grid[0].length, m = grid.length, ans = 0;\\n        int[][] fcol = new int[m + 1][n];\\n        int[][] tcol = new int[m + 1][n];\\n        int[][] frow = new int[n + 1][m];\\n        int[][] trow = new int[n + 1][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int t = count(grid[i][j], 2);\\n                int f = count(grid[i][j], 5);\\n                fcol[i + 1][j] += fcol[i][j] + f;\\n                tcol[i + 1][j] += tcol[i][j] + t;\\n                frow[j + 1][i] += frow[j][i] + f;\\n                trow[j + 1][i] += trow[j][i] + t;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int rowTwo = trow[j + 1][i];\\n                int rowFive= frow[j + 1][i];\\n                int colTwo = tcol[m][j] - tcol[i + 1][j];\\n                int colFive= fcol[m][j] - fcol[i + 1][j];\\n                ans = Math.max(ans, Math.min(rowTwo + colTwo, rowFive + colFive));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int count(int n, int w){\\n        int count = 0;\\n        while(n % w == 0){\\n            count++;\\n            n /= w;\\n        }\\n        return count;\\n    }\\n\\n    private int[][] rotate(int[][] grid){\\n        int n = grid[0].length, m = grid.length;\\n        int[][] next = new int[n][m];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                next[j][m - 1 - i] = grid[i][j];\\n            }\\n        }\\n        return next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955665,
                "title": "prefix-sum-java-o-mn-beat-100",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        // find path with most matching 5 & 2 divisor\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Node[][] rows = new Node[m][n];\\n        Node[][] cols = new Node[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int five = getFive(grid[i][j]);\\n                int two = getTwo(grid[i][j]);\\n                Node nodeR = new Node(five, two);\\n                Node nodeC = new Node(five, two);\\n                \\n                if (i > 0) {\\n                    nodeC.five = nodeC.five + cols[i - 1][j].five;\\n                    nodeC.two = nodeC.two + cols[i - 1][j].two;\\n                }\\n                \\n                cols[i][j] = nodeC;\\n                \\n                if (j > 0) {\\n                    nodeR.five = nodeR.five + rows[i][j - 1].five;\\n                    nodeR.two = nodeR.two + rows[i][j - 1].two;\\n                }\\n                \\n                rows[i][j] = nodeR;\\n            }\\n        }\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int rowLeft5 = j - 1 < 0 ? 0 : rows[i][j - 1].five;\\n                int rowLeft2 = j - 1 < 0 ? 0 : rows[i][j - 1].two;\\n                int rowRight5 = rows[i][n - 1].five - rows[i][j].five;\\n                int rowRight2 = rows[i][n - 1].two - rows[i][j].two;\\n                \\n                int colUp5 = i - 1 < 0 ? 0 : cols[i - 1][j].five;\\n                int colUp2 = i - 1 < 0 ? 0 : cols[i - 1][j].two;\\n                int colDown5 = cols[m - 1][j].five - cols[i][j].five;\\n                int colDown2 = cols[m - 1][j].two - cols[i][j].two;\\n                \\n                int cur = grid[i][j];\\n                \\n                max = Math.max(max, Math.min(rowLeft5 + colUp5 + getFive(cur), rowLeft2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowLeft5 + colDown5 + getFive(cur), rowLeft2 + colDown2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colUp5 + getFive(cur), rowRight2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colDown5 + getFive(cur), rowRight2 + colDown2 + getTwo(cur)));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int getTwo(int x) {\\n        int res = 0;\\n        \\n        while (x % 2 == 0) {\\n            res++;\\n            x /= 2;\\n        }\\n        return res;\\n    }\\n    \\n    private int getFive(int x) {\\n        int res = 0;\\n        \\n        while (x % 5 == 0) {\\n            res++;\\n            x /= 5;\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int five;\\n    int two;\\n    \\n    public Node(int five, int two) {\\n        this.five = five;\\n        this.two = two;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        // find path with most matching 5 & 2 divisor\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Node[][] rows = new Node[m][n];\\n        Node[][] cols = new Node[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int five = getFive(grid[i][j]);\\n                int two = getTwo(grid[i][j]);\\n                Node nodeR = new Node(five, two);\\n                Node nodeC = new Node(five, two);\\n                \\n                if (i > 0) {\\n                    nodeC.five = nodeC.five + cols[i - 1][j].five;\\n                    nodeC.two = nodeC.two + cols[i - 1][j].two;\\n                }\\n                \\n                cols[i][j] = nodeC;\\n                \\n                if (j > 0) {\\n                    nodeR.five = nodeR.five + rows[i][j - 1].five;\\n                    nodeR.two = nodeR.two + rows[i][j - 1].two;\\n                }\\n                \\n                rows[i][j] = nodeR;\\n            }\\n        }\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int rowLeft5 = j - 1 < 0 ? 0 : rows[i][j - 1].five;\\n                int rowLeft2 = j - 1 < 0 ? 0 : rows[i][j - 1].two;\\n                int rowRight5 = rows[i][n - 1].five - rows[i][j].five;\\n                int rowRight2 = rows[i][n - 1].two - rows[i][j].two;\\n                \\n                int colUp5 = i - 1 < 0 ? 0 : cols[i - 1][j].five;\\n                int colUp2 = i - 1 < 0 ? 0 : cols[i - 1][j].two;\\n                int colDown5 = cols[m - 1][j].five - cols[i][j].five;\\n                int colDown2 = cols[m - 1][j].two - cols[i][j].two;\\n                \\n                int cur = grid[i][j];\\n                \\n                max = Math.max(max, Math.min(rowLeft5 + colUp5 + getFive(cur), rowLeft2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowLeft5 + colDown5 + getFive(cur), rowLeft2 + colDown2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colUp5 + getFive(cur), rowRight2 + colUp2 + getTwo(cur)));\\n                max = Math.max(max, Math.min(rowRight5 + colDown5 + getFive(cur), rowRight2 + colDown2 + getTwo(cur)));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int getTwo(int x) {\\n        int res = 0;\\n        \\n        while (x % 2 == 0) {\\n            res++;\\n            x /= 2;\\n        }\\n        return res;\\n    }\\n    \\n    private int getFive(int x) {\\n        int res = 0;\\n        \\n        while (x % 5 == 0) {\\n            res++;\\n            x /= 5;\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int five;\\n    int two;\\n    \\n    public Node(int five, int two) {\\n        this.five = five;\\n        this.two = two;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955554,
                "title": "java-o-mn-solution-use-prefix-sum-to-calculate-number-of-factors-2-and-5-with-explanation",
                "content": "**The idea**: for each cornered path, let\\'s call its product is `p`. We can always rewrite `p`  as follows\\n`p = a * 10^n`\\n\\nNumber of trailing zeros will be maximum value of n in all ways to rewrite `p`. We have\\n\\n`number of trailing zeros of p = max(n) = min(number of 2 in prime factorization of p, number of 5 in prime factorization of p)`\\n\\n**Greedy strategy**: we will just consider the paths that start with a point on border of grid (first row or last row or first col or last col) and end with a point on border of grid because these paths will always have number of trailing zeros greater than (or equal) its sub paths.\\n\\nBelow is the implementation for this problem in Java. \\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] count25 = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // number of 2 in prime factorization of grid[i][j]\\n                count25[i][j][0] = countFactor(grid[i][j], 2);\\n                // number of 5 in prime factorization of grid[i][j]\\n                count25[i][j][1] = countFactor(grid[i][j], 5);\\n            }\\n        }\\n        \\n        // countUp[i][j][0]: number of 2 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // countUp[i][j][1]: number of 5 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // the same definition for countDown, countLeft and countRight\\n        // we will use prefix sum to caculate them\\n        int[][][] countUp = new int[m][n][2];\\n        int[][][] countDown = new int[m][n][2];\\n        int[][][] countLeft = new int[m][n][2];\\n        int[][][] countRight = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            countLeft[i][0][0] = count25[i][0][0];\\n            countLeft[i][0][1] = count25[i][0][1];\\n            countRight[i][n-1][0] = count25[i][n-1][0];\\n            countRight[i][n-1][1] = count25[i][n-1][1];\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                countLeft[i][j][0] = countLeft[i][j-1][0] + count25[i][j][0];\\n                countLeft[i][j][1] = countLeft[i][j-1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = n - 2; j >= 0; --j) {\\n                countRight[i][j][0] = countRight[i][j+1][0] + count25[i][j][0];\\n                countRight[i][j][1] = countRight[i][j+1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            countUp[0][j][0] = count25[0][j][0];\\n            countUp[0][j][1] = count25[0][j][1];\\n            countDown[m-1][j][0] = count25[m-1][j][0];\\n            countDown[m-1][j][1] = count25[m-1][j][1];\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) {\\n                countUp[i][j][0] = countUp[i-1][j][0] + count25[i][j][0];\\n                countUp[i][j][1] = countUp[i-1][j][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = m-2; i >= 0; --i) {\\n                countDown[i][j][0] = countDown[i+1][j][0] + count25[i][j][0];\\n                countDown[i][j][1] = countDown[i+1][j][1] + count25[i][j][1];                \\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countRight[i][j][0] - count25[i][j][0], countUp[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countUp[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countRight[i][j][0] - count25[i][j][0], countDown[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countDown[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\n    \\n    \\n    private int countFactor(int a, int factor) {\\n        int result = 0;\\n        while (a % factor == 0) {\\n            a /= factor;\\n            result++;\\n        }\\n        return result;\\n    }\\n    \\n}\\n```\\nTime complexity: O(mn).\\nSpace complexity: O(mn).\\n\\nPlease upvote if it is helpful to you. If there is any questions/suggestion, please comment, I will reply as soon as possible.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] count25 = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // number of 2 in prime factorization of grid[i][j]\\n                count25[i][j][0] = countFactor(grid[i][j], 2);\\n                // number of 5 in prime factorization of grid[i][j]\\n                count25[i][j][1] = countFactor(grid[i][j], 5);\\n            }\\n        }\\n        \\n        // countUp[i][j][0]: number of 2 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // countUp[i][j][1]: number of 5 in prime factorization of numbers from grid[0][j] to grid[i][j]\\n        // the same definition for countDown, countLeft and countRight\\n        // we will use prefix sum to caculate them\\n        int[][][] countUp = new int[m][n][2];\\n        int[][][] countDown = new int[m][n][2];\\n        int[][][] countLeft = new int[m][n][2];\\n        int[][][] countRight = new int[m][n][2];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            countLeft[i][0][0] = count25[i][0][0];\\n            countLeft[i][0][1] = count25[i][0][1];\\n            countRight[i][n-1][0] = count25[i][n-1][0];\\n            countRight[i][n-1][1] = count25[i][n-1][1];\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 1; j < n; ++j) {\\n                countLeft[i][j][0] = countLeft[i][j-1][0] + count25[i][j][0];\\n                countLeft[i][j][1] = countLeft[i][j-1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = n - 2; j >= 0; --j) {\\n                countRight[i][j][0] = countRight[i][j+1][0] + count25[i][j][0];\\n                countRight[i][j][1] = countRight[i][j+1][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            countUp[0][j][0] = count25[0][j][0];\\n            countUp[0][j][1] = count25[0][j][1];\\n            countDown[m-1][j][0] = count25[m-1][j][0];\\n            countDown[m-1][j][1] = count25[m-1][j][1];\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) {\\n                countUp[i][j][0] = countUp[i-1][j][0] + count25[i][j][0];\\n                countUp[i][j][1] = countUp[i-1][j][1] + count25[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; ++j) {\\n            for (int i = m-2; i >= 0; --i) {\\n                countDown[i][j][0] = countDown[i+1][j][0] + count25[i][j][0];\\n                countDown[i][j][1] = countDown[i+1][j][1] + count25[i][j][1];                \\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countRight[i][j][0] - count25[i][j][0], countUp[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countUp[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countUp[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countRight[i][j][0] - count25[i][j][0], countDown[i][j][1] + countRight[i][j][1] - count25[i][j][1])\\n                                 );\\n                result = Math.max(result, \\n                                  Math.min(countDown[i][j][0] + countLeft[i][j][0] - count25[i][j][0], countDown[i][j][1] + countLeft[i][j][1] - count25[i][j][1])\\n                                 );\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\n    \\n    \\n    private int countFactor(int a, int factor) {\\n        int result = 0;\\n        while (a % factor == 0) {\\n            a /= factor;\\n            result++;\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955534,
                "title": "java-dp-prefix-sum-2-5-factor-nums",
                "content": "If we directly count the product of a path, we are very likely to get integer overflow.\\n**The trailing zeros equals on the larger number of factors of 2 and 5 in the product.**\\nWe need to count the four kinds of cornered paths.\\n1. left-up\\n2. up-right\\n3. right-down\\n4. down-left\\n\\nTo count the paths efficiently, we need to first compute the prefix sums of factor 2 and factor 5, from 4 directions.\\n\\nTime: O(mn)\\nSpace: O(mn)\\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] two = new int[m][n];\\n        int[][] five = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                two[i][j] = getFactorNum(grid[i][j], 2);\\n                five[i][j] = getFactorNum(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int[][] left2 = new int[m][n];\\n        int[][] left5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = 0; j < n; ++j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                left2[i][j] = sum2;\\n                left5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] right2 = new int[m][n];\\n        int[][] right5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = n - 1; j >= 0; --j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                right2[i][j] = sum2;\\n                right5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] up2 = new int[m][n];\\n        int[][] up5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = 0; i < m; ++i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                up2[i][j] = sum2;\\n                up5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] down2 = new int[m][n];\\n        int[][] down5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = m - 1; i >= 0; --i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                down2[i][j] = sum2;\\n                down5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // left-up\\n                if (i != 0 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + up2[i][j] - two[i][j], left5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // up-right\\n                if (i != 0 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + up2[i][j] - two[i][j], right5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // right-down\\n                if (i != m - 1 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + down2[i][j] - two[i][j], right5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // down-left\\n                if (i != m - 1 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + down2[i][j] - two[i][j], left5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int getFactorNum(int input, int factor) {\\n        int res = 0;\\n        while (input != 0 && input % factor == 0) {\\n            ++res;\\n            input /= factor;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] two = new int[m][n];\\n        int[][] five = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                two[i][j] = getFactorNum(grid[i][j], 2);\\n                five[i][j] = getFactorNum(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int[][] left2 = new int[m][n];\\n        int[][] left5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = 0; j < n; ++j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                left2[i][j] = sum2;\\n                left5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] right2 = new int[m][n];\\n        int[][] right5 = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int j = n - 1; j >= 0; --j) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                right2[i][j] = sum2;\\n                right5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] up2 = new int[m][n];\\n        int[][] up5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = 0; i < m; ++i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                up2[i][j] = sum2;\\n                up5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int[][] down2 = new int[m][n];\\n        int[][] down5 = new int[m][n];\\n        for (int j = 0; j < n; ++j) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            for (int i = m - 1; i >= 0; --i) {\\n                sum2 += two[i][j];\\n                sum5 += five[i][j];\\n                down2[i][j] = sum2;\\n                down5[i][j] = sum5;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                // left-up\\n                if (i != 0 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + up2[i][j] - two[i][j], left5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // up-right\\n                if (i != 0 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + up2[i][j] - two[i][j], right5[i][j] + up5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // right-down\\n                if (i != m - 1 || j != n - 1) {\\n                    int cur = Math.min(right2[i][j] + down2[i][j] - two[i][j], right5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n                \\n                // down-left\\n                if (i != m - 1 || j != 0) {\\n                    int cur = Math.min(left2[i][j] + down2[i][j] - two[i][j], left5[i][j] + down5[i][j] - five[i][j]);\\n                    res = Math.max(res, cur);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int getFactorNum(int input, int factor) {\\n        int res = 0;\\n        while (input != 0 && input % factor == 0) {\\n            ++res;\\n            input /= factor;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955510,
                "title": "why-my-code-failed",
                "content": "my idea is to traverse just like number of island but make sure only make turn at most once. where is the bug? \\nfailed at:\\n[[899,727,165,249,531,300,542,890],[981,587,565,943,875,498,582,672],[106,902,524,725,699,778,365,220]]\\n```\\nclass Solution {\\n    int res = 0;\\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                    helper(grid, i, j, 0, 1);\\n            }\\n        }  \\n        return res;\\n    }\\n    \\n    public void helper(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            toRight(grid, i, j+1, count, current);\\n            helper(grid, i+1, j, count, current);\\n        }\\n    }\\n    \\n    public void toLeft(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current >= 10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            // toRight(grid, i, j+1, count, visited, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n    public void toRight(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            // toLeft(grid, i, j-1, count, visited, current);\\n            toRight(grid, i, j+1, count, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                    helper(grid, i, j, 0, 1);\\n            }\\n        }  \\n        return res;\\n    }\\n    \\n    public void helper(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            toRight(grid, i, j+1, count, current);\\n            helper(grid, i+1, j, count, current);\\n        }\\n    }\\n    \\n    public void toLeft(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current >= 10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            toLeft(grid, i, j-1, count, current);\\n            // toRight(grid, i, j+1, count, visited, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n    public void toRight(int[][] grid, int i, int j, int count, int current){\\n        if(i>=grid.length || i < 0 || j<0 || j >=grid[0].length ){\\n            while(current>=10 && current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            res = Math.max(res, count);\\n            return;\\n        }\\n        else{\\n            current = current*grid[i][j];\\n            while(current%10==0){\\n                current = current/10;\\n                count++;\\n            }\\n            // toLeft(grid, i, j-1, count, visited, current);\\n            toRight(grid, i, j+1, count, current);\\n            // helper(grid, i+1, j, count, visited, current);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955495,
                "title": "c-rotating-the-grid-disgusting-question",
                "content": "\\t\\tclass Solution {\\n\\tpublic:\\n    \\n    pair<long long,long long> util(int val){\\n        \\n        int x=0;\\n        while(val>0 && val%5==0){\\n            val=val/5;\\n            x++;\\n        }\\n        int y=0;\\n        while(val>0 && val%2==0){\\n            val=val/2;\\n            y++;\\n        }\\n        return {x,y};\\n        \\n    }\\n    \\n    long long util(vector<vector<int>>& grid){\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        pair<long long,long long> matrix[n][m];\\n        pair<long long,long long> matrix1[n][m];\\n        pair<long long,long long> matrix2[n][m];\\n        \\n        //making the first grid;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++){\\n                int val=grid[i][j];\\n                matrix[i][j]=util(val);\\n            }\\n        \\n        //right to left\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>=0;j--){\\n                if(j==m-1)\\n                    matrix1[i][j]=matrix[i][j];\\n                else\\n                    matrix1[i][j]={matrix[i][j].first+matrix1[i][j+1].first,matrix[i][j].second+matrix1[i][j+1].second};\\n   \\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0)\\n                    matrix2[i][j]=matrix[i][j];\\n                else\\n                    matrix2[i][j]={matrix[i][j].first+matrix2[i][j-1].first,matrix[i][j].second+matrix2[i][j-1].second};\\n            }\\n        }\\n        long long res=0;\\n        \\n        //calculating by traversing from up to down\\n        \\n        for(int j=0;j<m;j++){\\n            pair<long long,long long>sum={0,0};\\n            for(int i=0;i<n;i++){\\n                sum={sum.first+matrix[i][j].first,sum.second+matrix[i][j].second};\\n                res=max(res,min(sum.first,sum.second));\\n                if(j>0){\\n                pair<long long,long long>p1=matrix2[i][j-1];\\n                res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n                }\\n                if(j<m-1){\\n                    pair<long long,long long>p1=matrix1[i][j+1];\\n                res=max(res,min(sum.first+p1.first,sum.second+p1.second));\\n                }\\n                   \\n            }            \\n            \\n        }\\n        return res;\\n        \\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n    int m=grid[0].size();\\n        int n=grid.size();\\n        vector<vector<int>>grid2(m,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid2[j][i]=grid[i][j];\\n            }\\n        }\\n        long long res=0;\\n          res=max(util(grid),util(grid2));\\n        vector<vector<int>>grid3(n,vector<int>(m,0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid3[n-i-1][j]=grid[i][j];       \\n            }\\n        }\\n        return max(res,util(grid3));\\n        \\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    pair<long long,long long> util(int val){\\n        \\n        int x=0;\\n        while(val>0 && val%5==0){\\n            val=val/5;\\n            x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1955422,
                "title": "simple-dynamic-programming-dp-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int ans=0;\\n        int dp1[2][n+2][m+2],dp2[2][n+2][m+2],dp3[2][n+2][m+2],dp4[2][n+2][m+2];\\n        memset(dp1,0,sizeof dp1);\\n        memset(dp2,0,sizeof dp2);\\n        memset(dp3,0,sizeof dp3);\\n        memset(dp4,0,sizeof dp4);\\n\\n        for(int x=0;x<grid.size();x++){\\n            for(int z=0;z<grid[0].size();z++){\\n                int cnt2=0,cnt5=0;\\n                int num=grid[x][z];\\n                while(num%2==0)num/=2,cnt2++;\\n                while(num%5==0)num/=5,cnt5++;\\n                dp1[0][x+1][z+1]=dp2[0][x+1][z+1]=dp3[0][x+1][z+1]=dp4[0][x+1][z+1]=cnt2;\\n                dp1[1][x+1][z+1]=dp2[1][x+1][z+1]=dp3[1][x+1][z+1]=dp4[1][x+1][z+1]=cnt5;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){//up to down\\n            for(int j=1;j<=m;j++){\\n                dp1[0][i][j]+=dp1[0][i-1][j];\\n                dp1[1][i][j]+=dp1[1][i-1][j];\\n                // std::cout<<dp1[0][i][j]<<\",\"<<dp1[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=n;i>=1;i--){//down to up\\n            for(int j=1;j<=m;j++){\\n                dp2[0][i][j]+=dp2[0][i+1][j];\\n                dp2[1][i][j]+=dp2[1][i+1][j];\\n                // std::cout<<dp2[0][i][j]<<\",\"<<dp2[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//left to right\\n            for(int j=1;j<=m;j++){\\n                dp3[0][i][j]+=dp3[0][i][j-1];\\n                dp3[1][i][j]+=dp3[1][i][j-1];\\n                // std::cout<<dp3[0][i][j]<<\",\"<<dp3[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//right to left\\n            for(int j=m;j>=1;j--){\\n                dp4[0][i][j]+=dp4[0][i][j+1];\\n                dp4[1][i][j]+=dp4[1][i][j+1];\\n               //std::cout<<dp4[0][i][j]<<\",\"<<dp4[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        //std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//solve\\n            for(int j=1;j<=m;j++){\\n            \\n                    ans=max(ans,min(dp4[0][i][j+1]+dp2[0][i][j],dp4[1][i][j+1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp1[0][i][j],dp3[1][i][j-1]+dp1[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp2[0][i][j],dp3[1][i][j-1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp4[0][i][j+1]+dp1[0][i][j],dp4[1][i][j+1]+dp1[1][i][j]));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int ans=0;\\n        int dp1[2][n+2][m+2],dp2[2][n+2][m+2],dp3[2][n+2][m+2],dp4[2][n+2][m+2];\\n        memset(dp1,0,sizeof dp1);\\n        memset(dp2,0,sizeof dp2);\\n        memset(dp3,0,sizeof dp3);\\n        memset(dp4,0,sizeof dp4);\\n\\n        for(int x=0;x<grid.size();x++){\\n            for(int z=0;z<grid[0].size();z++){\\n                int cnt2=0,cnt5=0;\\n                int num=grid[x][z];\\n                while(num%2==0)num/=2,cnt2++;\\n                while(num%5==0)num/=5,cnt5++;\\n                dp1[0][x+1][z+1]=dp2[0][x+1][z+1]=dp3[0][x+1][z+1]=dp4[0][x+1][z+1]=cnt2;\\n                dp1[1][x+1][z+1]=dp2[1][x+1][z+1]=dp3[1][x+1][z+1]=dp4[1][x+1][z+1]=cnt5;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){//up to down\\n            for(int j=1;j<=m;j++){\\n                dp1[0][i][j]+=dp1[0][i-1][j];\\n                dp1[1][i][j]+=dp1[1][i-1][j];\\n                // std::cout<<dp1[0][i][j]<<\",\"<<dp1[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=n;i>=1;i--){//down to up\\n            for(int j=1;j<=m;j++){\\n                dp2[0][i][j]+=dp2[0][i+1][j];\\n                dp2[1][i][j]+=dp2[1][i+1][j];\\n                // std::cout<<dp2[0][i][j]<<\",\"<<dp2[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//left to right\\n            for(int j=1;j<=m;j++){\\n                dp3[0][i][j]+=dp3[0][i][j-1];\\n                dp3[1][i][j]+=dp3[1][i][j-1];\\n                // std::cout<<dp3[0][i][j]<<\",\"<<dp3[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        // std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//right to left\\n            for(int j=m;j>=1;j--){\\n                dp4[0][i][j]+=dp4[0][i][j+1];\\n                dp4[1][i][j]+=dp4[1][i][j+1];\\n               //std::cout<<dp4[0][i][j]<<\",\"<<dp4[1][i][j]<<\" \";\\n            }//std::cout<<\"\\\\n\";\\n        }\\n        //std::cout<<\"\\\\n\";\\n        for(int i=1;i<=n;i++){//solve\\n            for(int j=1;j<=m;j++){\\n            \\n                    ans=max(ans,min(dp4[0][i][j+1]+dp2[0][i][j],dp4[1][i][j+1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp1[0][i][j],dp3[1][i][j-1]+dp1[1][i][j]));\\n                    ans=max(ans,min(dp3[0][i][j-1]+dp2[0][i][j],dp3[1][i][j-1]+dp2[1][i][j]));\\n                    ans=max(ans,min(dp4[0][i][j+1]+dp1[0][i][j],dp4[1][i][j+1]+dp1[1][i][j]));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955419,
                "title": "accepted-python-solution",
                "content": "This solution got accpeted. But it is too long!\\nCould someone help me to simplify it? Thanks!\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        m_five = [[0] * n for _ in range(m)]\\n        m_two = [[0] * n for _ in range(m)]\\n        hor_five = [[0] * n for _ in range(m)]\\n        hor_five_r = [[0] * n for _ in range(m)]\\n        hor_two = [[0] * n for _ in range(m)]\\n        hor_two_r = [[0] * n for _ in range(m)]\\n        ver_five = [[0] * n for _ in range(m)]\\n        ver_five_r = [[0] * n for _ in range(m)]\\n        ver_two = [[0] * n for _ in range(m)]\\n        ver_two_r = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                cnt = 0\\n\\n                if x % 5 == 0:\\n                    cnt += 1\\n                if x % 25 == 0:\\n                    cnt += 1\\n                if x % 125 == 0:\\n                    cnt += 1\\n                if x % 625 == 0:\\n                    cnt += 1\\n\\n                m_five[i][j] = cnt\\n                cnt = 0\\n                if x % 512 == 0:\\n                    cnt = 9\\n                elif x % 256 == 0:\\n                    cnt = 8\\n                elif x % 128 == 0:\\n                    cnt = 7\\n                elif x % 64 == 0:\\n                    cnt = 6\\n                elif x % 32 == 0:\\n                    cnt = 5\\n                elif x % 16 == 0:\\n                    cnt = 4\\n                elif x % 8 == 0:\\n                    cnt = 3\\n                elif x % 4 == 0:\\n                    cnt = 2\\n                elif x % 2 == 0:\\n                    cnt = 1\\n                m_two[i][j] = cnt\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    hor_two[i][j] = m_two[i][j]\\n                    hor_five[i][j] = m_five[i][j]\\n                else:\\n                    hor_two[i][j] = m_two[i][j] + hor_two[i][j - 1]\\n                    hor_five[i][j] = m_five[i][j] + hor_five[i][j - 1]\\n            cur_five = cur_two = 0\\n            for j in range(n - 1, -1, -1):\\n                if j == n - 1:\\n                    hor_two_r[i][j] = m_two[i][j]\\n                    hor_five_r[i][j] = m_five[i][j]\\n                else:\\n                    hor_two_r[i][j] = hor_two_r[i][j + 1] + m_two[i][j]\\n                    hor_five_r[i][j] = hor_five_r[i][j + 1] + m_five[i][j]\\n        \\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    ver_five[i][j] = m_five[i][j]\\n                    ver_two[i][j] = m_two[i][j]\\n                else:\\n                    ver_five[i][j] = m_five[i][j] + ver_five[i - 1][j]\\n                    ver_two[i][j] = m_two[i][j] + ver_two[i - 1][j]\\n            for i in range(m - 1, -1, -1):\\n                if i == m - 1:\\n                    ver_five_r[i][j] = m_five[i][j]\\n                    ver_two_r[i][j] = m_two[i][j]\\n                else:\\n                    ver_two_r[i][j] = m_two[i][j] + ver_two_r[i + 1][j]\\n                    ver_five_r[i][j] = m_five[i][j] +ver_five_r[i + 1][j]\\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(hor_five[i][j] + ver_five[i][j] - m_five[i][j], hor_two[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two[i][j] + ver_two_r[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two_r[i][j] - m_two[i][j]))\\n        return res\\n                \\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        m_five = [[0] * n for _ in range(m)]\\n        m_two = [[0] * n for _ in range(m)]\\n        hor_five = [[0] * n for _ in range(m)]\\n        hor_five_r = [[0] * n for _ in range(m)]\\n        hor_two = [[0] * n for _ in range(m)]\\n        hor_two_r = [[0] * n for _ in range(m)]\\n        ver_five = [[0] * n for _ in range(m)]\\n        ver_five_r = [[0] * n for _ in range(m)]\\n        ver_two = [[0] * n for _ in range(m)]\\n        ver_two_r = [[0] * n for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                cnt = 0\\n\\n                if x % 5 == 0:\\n                    cnt += 1\\n                if x % 25 == 0:\\n                    cnt += 1\\n                if x % 125 == 0:\\n                    cnt += 1\\n                if x % 625 == 0:\\n                    cnt += 1\\n\\n                m_five[i][j] = cnt\\n                cnt = 0\\n                if x % 512 == 0:\\n                    cnt = 9\\n                elif x % 256 == 0:\\n                    cnt = 8\\n                elif x % 128 == 0:\\n                    cnt = 7\\n                elif x % 64 == 0:\\n                    cnt = 6\\n                elif x % 32 == 0:\\n                    cnt = 5\\n                elif x % 16 == 0:\\n                    cnt = 4\\n                elif x % 8 == 0:\\n                    cnt = 3\\n                elif x % 4 == 0:\\n                    cnt = 2\\n                elif x % 2 == 0:\\n                    cnt = 1\\n                m_two[i][j] = cnt\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    hor_two[i][j] = m_two[i][j]\\n                    hor_five[i][j] = m_five[i][j]\\n                else:\\n                    hor_two[i][j] = m_two[i][j] + hor_two[i][j - 1]\\n                    hor_five[i][j] = m_five[i][j] + hor_five[i][j - 1]\\n            cur_five = cur_two = 0\\n            for j in range(n - 1, -1, -1):\\n                if j == n - 1:\\n                    hor_two_r[i][j] = m_two[i][j]\\n                    hor_five_r[i][j] = m_five[i][j]\\n                else:\\n                    hor_two_r[i][j] = hor_two_r[i][j + 1] + m_two[i][j]\\n                    hor_five_r[i][j] = hor_five_r[i][j + 1] + m_five[i][j]\\n        \\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    ver_five[i][j] = m_five[i][j]\\n                    ver_two[i][j] = m_two[i][j]\\n                else:\\n                    ver_five[i][j] = m_five[i][j] + ver_five[i - 1][j]\\n                    ver_two[i][j] = m_two[i][j] + ver_two[i - 1][j]\\n            for i in range(m - 1, -1, -1):\\n                if i == m - 1:\\n                    ver_five_r[i][j] = m_five[i][j]\\n                    ver_two_r[i][j] = m_two[i][j]\\n                else:\\n                    ver_two_r[i][j] = m_two[i][j] + ver_two_r[i + 1][j]\\n                    ver_five_r[i][j] = m_five[i][j] +ver_five_r[i + 1][j]\\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, min(hor_five[i][j] + ver_five[i][j] - m_five[i][j], hor_two[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two[i][j] - m_two[i][j]),\\n                min(hor_five[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two[i][j] + ver_two_r[i][j] - m_two[i][j]),\\n                min(hor_five_r[i][j] + ver_five_r[i][j] - m_five[i][j], hor_two_r[i][j] + ver_two_r[i][j] - m_two[i][j]))\\n        return res\\n                \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1955336,
                "title": "help-me-troubleshoot-it",
                "content": "Here is my code\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        accumlatedProduct = [[[1,1] for i in range(m)] for j in range(n)] # ahp,avp\\n        for i in range(n):\\n            for k in range(m):\\n                tem = grid[i][k]\\n                if k==0:\\n                    accumlatedProduct[i][k][0] = tem\\n                else:\\n                    accumlatedProduct[i][k][0] = accumlatedProduct[i][k-1][0]*tem\\n                if i==0:\\n                    accumlatedProduct[i][k][1] = tem\\n                else:\\n                    accumlatedProduct[i][k][1] = accumlatedProduct[i-1][k][1]*tem\\n        res = 0\\n        for i in range(n):\\n            for k in range(m):\\n                p1 = accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]/grid[i][k]\\n                p2 = accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]\\n                p3 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]\\n                p4 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]*grid[i][k]\\n                print(p1,p2,p3,p4)\\n                res = max(res,self.CountTrailingZeros(p1),self.CountTrailingZeros(p2),self.CountTrailingZeros(p3),self.CountTrailingZeros(p4))\\n        return res\\n    def CountTrailingZeros(self,i):\\n        if i ==0:\\n            return 0\\n        if i%10==0:\\n            return 1+self.CountTrailingZeros(i/10)\\n        else:\\n            return 0\\n```\\n\\nI am using accumulated Product and center to calculate the product,\\n\\nbut i was stuck at this test case \\n\\n```\\n[[824,709,193,413,701,836,727],\\n    [135,844,599,211,140,933,205],\\n    [329,68,285,282,301,387,231],\\n    [293,210,478,352,946,902,137],\\n    [806,900,290,636,589,522,611],\\n    [450,568,990,592,992,128,92],\\n    [780,653,795,457,980,942,927],\\n    [849,901,604,906,912,866,688]]\\n```\\n\\nI looked at it and couldn\\'t find the product with 6 zeros\\n\\nanyone can help me with that?",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        accumlatedProduct = [[[1,1] for i in range(m)] for j in range(n)] # ahp,avp\\n        for i in range(n):\\n            for k in range(m):\\n                tem = grid[i][k]\\n                if k==0:\\n                    accumlatedProduct[i][k][0] = tem\\n                else:\\n                    accumlatedProduct[i][k][0] = accumlatedProduct[i][k-1][0]*tem\\n                if i==0:\\n                    accumlatedProduct[i][k][1] = tem\\n                else:\\n                    accumlatedProduct[i][k][1] = accumlatedProduct[i-1][k][1]*tem\\n        res = 0\\n        for i in range(n):\\n            for k in range(m):\\n                p1 = accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]/grid[i][k]\\n                p2 = accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]\\n                p3 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[i][k][1]\\n                p4 = accumlatedProduct[i][m-1][0]/accumlatedProduct[i][k][0]*accumlatedProduct[n-1][k][1]/accumlatedProduct[i][k][1]*grid[i][k]\\n                print(p1,p2,p3,p4)\\n                res = max(res,self.CountTrailingZeros(p1),self.CountTrailingZeros(p2),self.CountTrailingZeros(p3),self.CountTrailingZeros(p4))\\n        return res\\n    def CountTrailingZeros(self,i):\\n        if i ==0:\\n            return 0\\n        if i%10==0:\\n            return 1+self.CountTrailingZeros(i/10)\\n        else:\\n            return 0\\n```\n```\\n[[824,709,193,413,701,836,727],\\n    [135,844,599,211,140,933,205],\\n    [329,68,285,282,301,387,231],\\n    [293,210,478,352,946,902,137],\\n    [806,900,290,636,589,522,611],\\n    [450,568,990,592,992,128,92],\\n    [780,653,795,457,980,942,927],\\n    [849,901,604,906,912,866,688]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955330,
                "title": "prefix-sum-approach-c-comments",
                "content": "```\\n// Approach - We know basic idea about how to form 10 i.e. 5 * 2\\n// So thats it we use the same idea here we calculate 5\\'s and 2\\'s in division of each grid element \\n// and maintain sum array\\n\\n\\n// sum[n][m][2] --> 0 --> Number of 5\\'s and 1 --> Number of 2\\'s \\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    // Utility function to get frequency of divisor forming the number \\n    int getIt(int n,int p)\\n    {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n % p != 0)break;\\n            ans++;\\n            n/=p;\\n        }\\n        return ans;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        // Row wise Prefix Sum \\n        int sum[n+1][m+1][2];\\n        memset(sum,0,sizeof sum);\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum[i][j][0] = getIt(grid[i-1][j-1],2);\\n                sum[i][j][1] = getIt(grid[i-1][j-1],5);\\n            }\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum[i][j][0] += sum[i][j-1][0];\\n                sum[i][j][1] += sum[i][j-1][1];\\n            }\\n        }\\n\\n        // :------------------------------------------------->\\n\\n         // Column Wise Prefix Sum\\n        int sum2[n+1][m+1][2];\\n        memset(sum2,0,sizeof sum2);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum2[i][j][0] = getIt(grid[i-1][j-1],2);\\n                sum2[i][j][1] = getIt(grid[i-1][j-1],5);\\n            }\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++)\\n            {\\n                sum2[i][j][0] += sum2[i-1][j][0];\\n                sum2[i][j][1] += sum2[i-1][j][1];\\n            }\\n        }\\n\\n\\n        // :---------------------------------------------->\\n\\n        // Cheap Variable to Store Answer\\n        int ans = 0;\\n\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n\\n                // Current Grid Element\\n                int x = sum[i][j][0] - sum[i][j-1][0];\\n                int y = sum[i][j][1] - sum[i][j-1][1];\\n\\n                // Take all possible answers considering current grid element as corner\\n\\n                // Convention --> L1, L2,R1,R2,U1,U2,D1,D2\\n                // 1 --> Number is 5\\'s\\n                // 2 --> Number of 2\\'s\\n\\n                // Left\\n                int L1 = sum[i][j-1][0];\\n                int L2 = sum[i][j-1][1];\\n\\n                // Right\\n                int R1 = sum[i][m][0] - sum[i][j][0];\\n                int R2 = sum[i][m][1] - sum[i][j][1];\\n\\n                // Up\\n                int U1 = sum2[i-1][j][0];\\n                int U2 = sum2[i-1][j][1];\\n\\n                // Down\\n                int D1 = sum2[n][j][0] - sum2[i][j][0];\\n                int D2 = sum2[n][j][1] - sum2[i][j][1];\\n\\n                // Our duty to calculate max answer\\n                // Max answer will be the min(No of 5\\'s, No of 2\\'s) in the cornered Path\\n                ans = max(ans,min(L1 + x + U1, L2 + y + U2));\\n                ans = max(ans,min(L1 + x + D1, L2 + y + D2));\\n\\n                ans = max(ans,min(R1 + x + U1, R2 + y + U2));\\n                ans = max(ans,min(R1 + x + D1, R2 + y + D2));\\n\\n\\n            }\\n        }\\n        \\n        // Hey, We just did it, Now its time to return\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // Utility function to get frequency of divisor forming the number \\n    int getIt(int n,int p)\\n    {\\n        int ans = 0;\\n        while(n > 0)\\n        {\\n            if(n % p != 0)break;\\n            ans++;\\n            n/=p;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3836085,
                "title": "python3-vectorized-solution",
                "content": "I hope this answer is helpful to those who prefer more formal explanations (like myself).\\n___\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI made the following two observations:\\n1. Let $g(x)$ denote the number of trailing zeros of a number $x$. Then \\n$g(x) = \\\\min_{p\\\\in\\\\{2,5\\\\}} f(x,p),$ \\nwhere $f(x, p)$ is the number of times that prime number $p$ appears in the prime factorization of $x$.\\n2. The solution can always be represented by a cornered path which extends all the way to the edges of the grid. This is because the entries are non-negative, and so adding more cells can never harm the solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine a _leg_ $(i,j,d)$ to be a path of cells from (_excluding_) $(i,j)$ to the edge of the grid, following direction $d\\\\in\\\\{{\\\\rm up,down,left,right}\\\\}$. WLOG, we only consider cornered paths which extend all the way to the edges of the grid, so that each cornered path can be decomposed into a corner and two legs. We encode each cornered path by a tuple $(i,j,d_1,d_2)$, where $(i,j)$ is the location of the path\\'s corner, and $(d_1,d_2)$ are the directions of the its legs, $(i,j,d_1)$ and $(i,j,d_2)$.\\n\\nDefine the _gain_ $g(\\\\pi)$ of $\\\\pi$ to be the number of trailing zeros in the product of the path, i.e. $g(\\\\pi) = g(\\\\Pi_{ij\\\\in\\\\pi}x_{ij})$, and let $f(\\\\pi, p) = \\\\sum_{ij\\\\in\\\\pi} f(x_{ij}, p)$ be the number of times prime number $p$ appears along a path $\\\\pi$. Then,\\n$g(\\\\pi) = g(\\\\Pi_{ij\\\\in\\\\pi}x_{ij}) \\\\\\\\ = \\\\min_{p\\\\in\\\\{2,5\\\\}} f(\\\\Pi_{ij\\\\in\\\\pi}x_{ij}, p) \\\\\\\\ = \\\\min_{p\\\\in\\\\{2,5\\\\}} \\\\sum_{ij\\\\in\\\\pi} f(x_{ij}, p) \\\\\\\\ = \\\\min_{p\\\\in\\\\{2,5\\\\}} f(\\\\pi, p).$\\nOur objective is to find a cornered path $\\\\pi$ which maximizes $g(\\\\pi)$. First, we need to compute $f(\\\\pi, p)$ for all cornered paths $\\\\pi$ and $p\\\\in\\\\{2,5\\\\}$.\\n\\nNotice that, for a cornered path, $\\\\pi=(i,j,d_1,d_2)$, the quantity $f(\\\\pi,p)$ can be decomposed over $\\\\pi$\\'s corner and two legs:\\n$f((i,j,d_1,d_2), p) = f(x_{ij}, p) + f((i,j,d_1), p) + f((i,j,d_2), p).$\\n\\nThese leg counts, $f((i,j,d), p)$, are our building blocks, so I computed them for each possible leg $(i,j,d)$. Since a leg may be a sub-leg of a longer leg, I stored and reused intermediate results in a dynamic programming style. I then used these leg counts to compute $f(\\\\pi, 2)$ and $f(\\\\pi, 5)$ for each possible cornered path $\\\\pi$, which together yield $g(\\\\pi)$. Finally, I computed $\\\\max_\\\\pi g(\\\\pi)$ by searching over all cornered paths $\\\\pi$. Crucially, I vectorized this search over $(i,j)$ using NumPy; without doing so, my solution exceeded the time limit.\\n\\n# Complexity\\n- Time complexity: $O(mn)$, because $O(1)$ visits per cell\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(mn)$, because $O(1)$ values stored per cell\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport numpy as np\\n\\n# directions\\nU = 0 # Up\\nD = 1 # Down\\nL = 2 # Left\\nR = 3 # Right\\nN_dir = 4\\n\\n# factors\\nT = 0 # Two\\nF = 1 # Five\\nN_fac = 2\\n\\ndef f(x, p):\\n    \\'\\'\\'returns the highest power of `p` that divides `x`\\'\\'\\'\\n    c = 0\\n    while x % p == 0:\\n        c += 1\\n        x //= p\\n    return c\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        grid = np.array(grid)\\n\\n        # y[i, j, p] = \\n        #   highest power of `p` that divides `grid[i, j]`\\n        y = np.zeros((m, n, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                y[i, j, T] = f(grid[i, j], 2)\\n                y[i, j, F] = f(grid[i, j], 5)\\n\\n        # x[i, j, d, p] = \\n        #   count of times that `p` appears in leg `(i,j,d)`\\n        x = np.zeros((m, n, N_dir, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    x[i, j, U] = y[i-1, j] + x[i-1, j, U]\\n                    x[m-1-i, j, D] = y[m-i, j] + x[m-i, j, D]\\n                if j > 0:\\n                    x[i, j, L] = y[i, j-1] + x[i, j-1, L]\\n                    x[i, n-1-j, R] = y[i, n-j] + x[i, n-j, R]\\n\\n        # the cornered path\\'s legs can be oriented in one of four ways\\n        path_orientations = [(U,R), (U,L), (D,R), (D,L)]\\n\\n        # for each orientation `(d1, d2)`, \\n        #   for each corner `(i, j)` (vectorized):\\n        #       find the the number of trailing zeros in the product\\n        #       of the path `(i, j, d1, d2)`.\\n        #   max-reduce over corners (vectorized)\\n        # max-reduce over orientations.\\n        return max(\\n            (y + x[:, :, d1] + x[:, :, d2]).min(-1).max()\\n            for d1, d2 in path_orientations\\n        )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\n# directions\\nU = 0 # Up\\nD = 1 # Down\\nL = 2 # Left\\nR = 3 # Right\\nN_dir = 4\\n\\n# factors\\nT = 0 # Two\\nF = 1 # Five\\nN_fac = 2\\n\\ndef f(x, p):\\n    \\'\\'\\'returns the highest power of `p` that divides `x`\\'\\'\\'\\n    c = 0\\n    while x % p == 0:\\n        c += 1\\n        x //= p\\n    return c\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        grid = np.array(grid)\\n\\n        # y[i, j, p] = \\n        #   highest power of `p` that divides `grid[i, j]`\\n        y = np.zeros((m, n, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                y[i, j, T] = f(grid[i, j], 2)\\n                y[i, j, F] = f(grid[i, j], 5)\\n\\n        # x[i, j, d, p] = \\n        #   count of times that `p` appears in leg `(i,j,d)`\\n        x = np.zeros((m, n, N_dir, N_fac), dtype=int)\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    x[i, j, U] = y[i-1, j] + x[i-1, j, U]\\n                    x[m-1-i, j, D] = y[m-i, j] + x[m-i, j, D]\\n                if j > 0:\\n                    x[i, j, L] = y[i, j-1] + x[i, j-1, L]\\n                    x[i, n-1-j, R] = y[i, n-j] + x[i, n-j, R]\\n\\n        # the cornered path\\'s legs can be oriented in one of four ways\\n        path_orientations = [(U,R), (U,L), (D,R), (D,L)]\\n\\n        # for each orientation `(d1, d2)`, \\n        #   for each corner `(i, j)` (vectorized):\\n        #       find the the number of trailing zeros in the product\\n        #       of the path `(i, j, d1, d2)`.\\n        #   max-reduce over corners (vectorized)\\n        # max-reduce over orientations.\\n        return max(\\n            (y + x[:, :, d1] + x[:, :, d2]).min(-1).max()\\n            for d1, d2 in path_orientations\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434707,
                "title": "javascript-simple-array",
                "content": "# Complexity\\n- Time complexity: $$O(n*n)$$\\n- Space complexity: $$O(n*n)$$\\n\\n# Code\\n```\\nvar maxTrailingZeros = function(grid) {\\n    const n = grid.length, m = grid[0].length;\\n    const rowWise = Array.from({ length: n }, () => Array(m)),\\n      columnWise = Array.from({ length: n }, () => Array(m));\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            grid[i][j] = [getFactorsCount(grid[i][j], 2), getFactorsCount(grid[i][j], 5)];\\n            rowWise[i][j] = [(j > 0 ? rowWise[i][j - 1][0] : 0) + grid[i][j][0],\\n                (j > 0 ? rowWise[i][j - 1][1] : 0) + grid[i][j][1]];\\n            columnWise[i][j] = [(i > 0 ? columnWise[i - 1][j][0] : 0) + grid[i][j][0],\\n                (i > 0 ? columnWise[i - 1][j][1] : 0) + grid[i][j][1]];\\n        }\\n    }\\n    \\n    function getFactorsCount(value, factor) {\\n        let count = 0;\\n        while(value % factor == 0) count++, value /= factor;\\n        return count;\\n    }\\n\\n    let maxTrailingZeros = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            const top = columnWise[i - 1]?.[j] ?? [0, 0];\\n            const left = rowWise[i][j - 1] ?? [0, 0];\\n            const right = [rowWise[i].at(-1)[0] - rowWise[i][j][0],\\n                rowWise[i].at(-1)[1] - rowWise[i][j][1]];\\n            const bottom = [columnWise.at(-1)[j][0] - columnWise[i][j][0],\\n                columnWise.at(-1)[j][1] - columnWise[i][j][1]];\\n\\n            const allDirections = [top, left, right, bottom];            \\n            for (let k = 0; k < 4; k++) {\\n                for (let l = 0; l < 4; l++) {\\n                    if (k == l) continue;\\n                    maxTrailingZeros = Math.max(maxTrailingZeros, \\n                        Math.min(allDirections[k][0] + allDirections[l][0] + grid[i][j][0], \\n                            allDirections[k][1] + allDirections[l][1] + grid[i][j][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTrailingZeros;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nvar maxTrailingZeros = function(grid) {\\n    const n = grid.length, m = grid[0].length;\\n    const rowWise = Array.from({ length: n }, () => Array(m)),\\n      columnWise = Array.from({ length: n }, () => Array(m));\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            grid[i][j] = [getFactorsCount(grid[i][j], 2), getFactorsCount(grid[i][j], 5)];\\n            rowWise[i][j] = [(j > 0 ? rowWise[i][j - 1][0] : 0) + grid[i][j][0],\\n                (j > 0 ? rowWise[i][j - 1][1] : 0) + grid[i][j][1]];\\n            columnWise[i][j] = [(i > 0 ? columnWise[i - 1][j][0] : 0) + grid[i][j][0],\\n                (i > 0 ? columnWise[i - 1][j][1] : 0) + grid[i][j][1]];\\n        }\\n    }\\n    \\n    function getFactorsCount(value, factor) {\\n        let count = 0;\\n        while(value % factor == 0) count++, value /= factor;\\n        return count;\\n    }\\n\\n    let maxTrailingZeros = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            const top = columnWise[i - 1]?.[j] ?? [0, 0];\\n            const left = rowWise[i][j - 1] ?? [0, 0];\\n            const right = [rowWise[i].at(-1)[0] - rowWise[i][j][0],\\n                rowWise[i].at(-1)[1] - rowWise[i][j][1]];\\n            const bottom = [columnWise.at(-1)[j][0] - columnWise[i][j][0],\\n                columnWise.at(-1)[j][1] - columnWise[i][j][1]];\\n\\n            const allDirections = [top, left, right, bottom];            \\n            for (let k = 0; k < 4; k++) {\\n                for (let l = 0; l < 4; l++) {\\n                    if (k == l) continue;\\n                    maxTrailingZeros = Math.max(maxTrailingZeros, \\n                        Math.min(allDirections[k][0] + allDirections[l][0] + grid[i][j][0], \\n                            allDirections[k][1] + allDirections[l][1] + grid[i][j][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTrailingZeros;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356380,
                "title": "c-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\n    int numOfFact(int n, int x) {\\n        int count = 0;\\n        while(n % x == 0) {\\n            count++;\\n            n /= x;\\n        }\\n        return count;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector<vector<pair<int, int>>> h(m + 1, vector<pair<int, int>>(n + 1));\\n        vector<vector<pair<int, int>>> v(m + 1, vector<pair<int, int>>(n + 1));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                h[i + 1][j + 1].first = h[i + 1][j].first + numOfFact(grid[i][j], 2);  \\n                h[i + 1][j + 1].second = h[i + 1][j].second + numOfFact(grid[i][j], 5); \\n                v[i + 1][j + 1].first = v[i][j + 1].first + numOfFact(grid[i][j], 2);  \\n                v[i + 1][j + 1].second = v[i][j + 1].second + numOfFact(grid[i][j], 5); \\n            }\\n        }\\n        pair<int, int> h1, h2, v1, v2;\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                h1 = {h[i][j - 1].first, h[i][j - 1].second};\\n                h2 = {h[i][n].first - h[i][j].first, h[i][n].second - h[i][j].second};\\n                v1 = {v[i][j].first, v[i][j].second};\\n                v2 = {v[m][j].first - v[i - 1][j].first, v[m][j].second - v[i - 1][j].second};\\n                ans = max(ans, min(v1.first + h1.first, v1.second + h1.second));\\n                ans = max(ans, min(v1.first + h2.first, v1.second + h2.second));\\n                ans = max(ans, min(v2.first + h1.first, v2.second + h1.second));\\n                ans = max(ans, min(v2.first + h2.first, v2.second + h2.second));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int numOfFact(int n, int x) {\\n        int count = 0;\\n        while(n % x == 0) {\\n            count++;\\n            n /= x;\\n        }\\n        return count;\\n    }\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector<vector<pair<int, int>>> h(m + 1, vector<pair<int, int>>(n + 1));\\n        vector<vector<pair<int, int>>> v(m + 1, vector<pair<int, int>>(n + 1));\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                h[i + 1][j + 1].first = h[i + 1][j].first + numOfFact(grid[i][j], 2);  \\n                h[i + 1][j + 1].second = h[i + 1][j].second + numOfFact(grid[i][j], 5); \\n                v[i + 1][j + 1].first = v[i][j + 1].first + numOfFact(grid[i][j], 2);  \\n                v[i + 1][j + 1].second = v[i][j + 1].second + numOfFact(grid[i][j], 5); \\n            }\\n        }\\n        pair<int, int> h1, h2, v1, v2;\\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                h1 = {h[i][j - 1].first, h[i][j - 1].second};\\n                h2 = {h[i][n].first - h[i][j].first, h[i][n].second - h[i][j].second};\\n                v1 = {v[i][j].first, v[i][j].second};\\n                v2 = {v[m][j].first - v[i - 1][j].first, v[m][j].second - v[i - 1][j].second};\\n                ans = max(ans, min(v1.first + h1.first, v1.second + h1.second));\\n                ans = max(ans, min(v1.first + h2.first, v1.second + h2.second));\\n                ans = max(ans, min(v2.first + h1.first, v2.second + h1.second));\\n                ans = max(ans, min(v2.first + h2.first, v2.second + h2.second));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270259,
                "title": "1464-ms",
                "content": "```ruby\\ndef max_trailing_zeros v\\n    y, x = v.size, v[0].size\\n    m, h = 0, Array.new(y) { [0] * x }\\n    for i in 0...y\\n        h2, h5 = 0, 0\\n        for j in 0...x\\n            d = v[i][j]\\n            x2, x5 = 0, 0\\n            (d >>= 1; x2 += 1) while (d & 1).zero?\\n            (d  /= 5; x5 += 1) while (d % 5).zero?\\n            h[i][j] = [h2 += x2, h5 += x5]\\n            if i > 0\\n                p2, p5 = *v[i - 1][j]\\n                x2 += p2; x5 += p5\\n            end\\n            v[i][j] = [x2, x5]\\n        end\\n    end\\n    for i in 0...y\\n        r2, r5 = *h[i][-1]\\n        for j in 0...x\\n             v2,  v5 = *v[-1][j]\\n            cv2, cv5 = *v[i][j]\\n            ch2, ch5 = *h[i][j]\\n            j > 0 ?\\n                (lh2, lh5 = *h[i][j - 1]) :\\n                (lh2, lh5 = 0, 0)\\n            m = [m,\\n                 [lh2 + cv2,\\n                  lh5 + cv5].min,\\n                 [cv2 + r2 - ch2,\\n                  cv5 + r5 - ch5].min,\\n                 [ch2 + v2 - cv2,\\n                  ch5 + v5 - cv5].min,\\n                 [r2 - lh2 + v2 - cv2,\\n                  r5 - lh5 + v5 - cv5].min\\n            ].max\\n        end\\n    end\\n    m\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef max_trailing_zeros v\\n    y, x = v.size, v[0].size\\n    m, h = 0, Array.new(y) { [0] * x }\\n    for i in 0...y\\n        h2, h5 = 0, 0\\n        for j in 0...x\\n            d = v[i][j]\\n            x2, x5 = 0, 0\\n            (d >>= 1; x2 += 1) while (d & 1).zero?\\n            (d  /= 5; x5 += 1) while (d % 5).zero?\\n            h[i][j] = [h2 += x2, h5 += x5]\\n            if i > 0\\n                p2, p5 = *v[i - 1][j]\\n                x2 += p2; x5 += p5\\n            end\\n            v[i][j] = [x2, x5]\\n        end\\n    end\\n    for i in 0...y\\n        r2, r5 = *h[i][-1]\\n        for j in 0...x\\n             v2,  v5 = *v[-1][j]\\n            cv2, cv5 = *v[i][j]\\n            ch2, ch5 = *h[i][j]\\n            j > 0 ?\\n                (lh2, lh5 = *h[i][j - 1]) :\\n                (lh2, lh5 = 0, 0)\\n            m = [m,\\n                 [lh2 + cv2,\\n                  lh5 + cv5].min,\\n                 [cv2 + r2 - ch2,\\n                  cv5 + r5 - ch5].min,\\n                 [ch2 + v2 - cv2,\\n                  ch5 + v5 - cv5].min,\\n                 [r2 - lh2 + v2 - cv2,\\n                  r5 - lh5 + v5 - cv5].min\\n            ].max\\n        end\\n    end\\n    m\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3074006,
                "title": "python",
                "content": "\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid) :\\n        matrix = grid \\n        self.ans,prefix,suffix = 0,[i[:] for i in matrix ],[i[:] for i in matrix ]\\n      \\n        def f(n):\\n            x,y =0,0\\n            while n%2==0:\\n                n = n//2\\n                x+=1\\n            while n% 5==0:\\n                n = n // 5\\n                y+=1\\n            return x,y\\n\\n        for i in prefix:\\n            for n,v in enumerate(i):\\n                if n==0 : i[0] =f(v)\\n                else:\\n                    x,y = f(v)\\n                    a,b = i[n-1]\\n                    i[n]=x+a,y+b\\n\\n        for i in suffix :\\n            for n in range(len(i)-1,-1,-1):\\n                if n == len(i)-1:i[n]=f(i[n])\\n                else:\\n                    x,y = f(i[n])\\n                    a,b= i[n+1]\\n                    i[n]=x+a,y+b\\n\\n        for j in range(len(matrix[0])):\\n            two,five =0,0\\n            for i in range(len(matrix)):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n            \\n            two,five = 0,0\\n            for i in range(len(matrix)-1,-1,-1):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n      \\n        return self.ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid) :\\n        matrix = grid \\n        self.ans,prefix,suffix = 0,[i[:] for i in matrix ],[i[:] for i in matrix ]\\n      \\n        def f(n):\\n            x,y =0,0\\n            while n%2==0:\\n                n = n//2\\n                x+=1\\n            while n% 5==0:\\n                n = n // 5\\n                y+=1\\n            return x,y\\n\\n        for i in prefix:\\n            for n,v in enumerate(i):\\n                if n==0 : i[0] =f(v)\\n                else:\\n                    x,y = f(v)\\n                    a,b = i[n-1]\\n                    i[n]=x+a,y+b\\n\\n        for i in suffix :\\n            for n in range(len(i)-1,-1,-1):\\n                if n == len(i)-1:i[n]=f(i[n])\\n                else:\\n                    x,y = f(i[n])\\n                    a,b= i[n+1]\\n                    i[n]=x+a,y+b\\n\\n        for j in range(len(matrix[0])):\\n            two,five =0,0\\n            for i in range(len(matrix)):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n            \\n            two,five = 0,0\\n            for i in range(len(matrix)-1,-1,-1):\\n                self.ans = max(self.ans,min(two+prefix[i][j][0],five + prefix[i][j][1]))\\n                self.ans = max(self.ans , min(two + suffix[i][j][0] , five + suffix[i][j][1]))\\n                x,y = f(matrix[i][j])\\n                two +=x\\n                five +=y \\n      \\n        return self.ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070619,
                "title": "python-simple-solution-o-mn",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(num):\\n            res = [0,0]\\n            while num > 1 and num%2 == 0:\\n                num //= 2\\n                res[0] += 1\\n            while num > 1 and num%5 == 0:\\n                num //= 5\\n                res[1] += 1\\n            return res\\n        def zeros(a, b, c):\\n            return min(a[0]+b[0]-c[0], a[1]+b[1]-c[1])\\n        m, n = len(grid), len(grid[0])\\n        UD = [[0 for i in range(n)] for _ in range(m)]\\n        LR = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                UD[i][j] = factors(grid[i][j])\\n                LR[i][j] = factors(grid[i][j])\\n                UD[i][j][0] += UD[i-1][j][0] if i else 0\\n                UD[i][j][1] += UD[i-1][j][1] if i else 0\\n                LR[i][j][0] += LR[i][j-1][0] if j else 0\\n                LR[i][j][1] += LR[i][j-1][1] if j else 0\\n        DU = [[0 for i in range(n)] for _ in range(m)]\\n        RL = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                DU[i][j] = factors(grid[i][j])\\n                RL[i][j] = factors(grid[i][j])\\n                DU[i][j][0] += DU[i+1][j][0] if i < m - 1 else 0\\n                DU[i][j][1] += DU[i+1][j][1] if i < m - 1 else 0\\n                RL[i][j][0] += RL[i][j+1][0] if j < n - 1 else 0\\n                RL[i][j][1] += RL[i][j+1][1] if j < n - 1 else 0\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                f = factors(grid[i][j])\\n                cur = max(zeros(UD[i][j],LR[i][j],f), zeros(UD[i][j],RL[i][j],f), zeros(DU[i][j],LR[i][j],f), zeros(DU[i][j],RL[i][j],f))\\n                res = max(res, cur)\\n        return res\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def factors(num):\\n            res = [0,0]\\n            while num > 1 and num%2 == 0:\\n                num //= 2\\n                res[0] += 1\\n            while num > 1 and num%5 == 0:\\n                num //= 5\\n                res[1] += 1\\n            return res\\n        def zeros(a, b, c):\\n            return min(a[0]+b[0]-c[0], a[1]+b[1]-c[1])\\n        m, n = len(grid), len(grid[0])\\n        UD = [[0 for i in range(n)] for _ in range(m)]\\n        LR = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                UD[i][j] = factors(grid[i][j])\\n                LR[i][j] = factors(grid[i][j])\\n                UD[i][j][0] += UD[i-1][j][0] if i else 0\\n                UD[i][j][1] += UD[i-1][j][1] if i else 0\\n                LR[i][j][0] += LR[i][j-1][0] if j else 0\\n                LR[i][j][1] += LR[i][j-1][1] if j else 0\\n        DU = [[0 for i in range(n)] for _ in range(m)]\\n        RL = [[0 for i in range(n)] for _ in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                DU[i][j] = factors(grid[i][j])\\n                RL[i][j] = factors(grid[i][j])\\n                DU[i][j][0] += DU[i+1][j][0] if i < m - 1 else 0\\n                DU[i][j][1] += DU[i+1][j][1] if i < m - 1 else 0\\n                RL[i][j][0] += RL[i][j+1][0] if j < n - 1 else 0\\n                RL[i][j][1] += RL[i][j+1][1] if j < n - 1 else 0\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                f = factors(grid[i][j])\\n                cur = max(zeros(UD[i][j],LR[i][j],f), zeros(UD[i][j],RL[i][j],f), zeros(DU[i][j],LR[i][j],f), zeros(DU[i][j],RL[i][j],f))\\n                res = max(res, cur)\\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932118,
                "title": "simple-rust-solution",
                "content": "Enumerate corner cells, extend horizontally and vertically. There are four cornered paths to consider for each corner cell. Use prefix sum to quickly calculate zeros for each path.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_trailing_zeros(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::ops::{Add, Sub};\\n\\n        let m = grid.len();\\n        let n = grid[0].len();\\n\\n        #[derive(Clone, Copy, Debug, Default)]\\n        struct Counts {\\n            count_2: i32,\\n            count_5: i32,\\n        }\\n\\n        impl Counts {\\n            fn zeros(&self) -> i32 {\\n                self.count_2.min(self.count_5)\\n            }\\n        }\\n\\n        impl Add for Counts {\\n            type Output = Self;\\n            fn add(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 + rhs.count_2,\\n                    count_5: self.count_5 + rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        impl Sub for Counts {\\n            type Output = Self;\\n            fn sub(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 - rhs.count_2,\\n                    count_5: self.count_5 - rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        let mut prime_count = vec![Counts::default(); 1001];\\n        for i in 2..=1000 {\\n            let mut count_2 = 0;\\n            let mut count_5 = 0;\\n            let mut k = i;\\n            while k % 2 == 0 {\\n                k /= 2;\\n                count_2 += 1;\\n            }\\n            while k % 5 == 0 {\\n                k /= 5;\\n                count_5 += 1;\\n            }\\n            prime_count[i] = Counts { count_2, count_5 };\\n        }\\n        let mut h_acc = vec![vec![Counts::default(); n + 1]; m + 1];\\n        let mut v_acc = vec![vec![Counts::default(); m + 1]; n + 1];\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let count = prime_count[grid[row][col] as usize];\\n                h_acc[row][col + 1] = h_acc[row][col] + count;\\n                v_acc[col][row + 1] = v_acc[col][row] + count;\\n            }\\n        }\\n\\n        let mut res = 0;\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let top = v_acc[col][row];\\n                let bottom = v_acc[col][m] - v_acc[col][row + 1];\\n                let left = h_acc[row][col];\\n                let right = h_acc[row][n] - h_acc[row][col + 1];\\n                let current = prime_count[grid[row][col] as usize];\\n\\n                res = res.max(\\n                    (top + left + current).zeros()\\n                ).max(\\n                    (top + right + current).zeros()\\n                ).max(\\n                    (bottom + left + current).zeros()\\n                ).max(\\n                    (bottom + right + current).zeros()\\n                );\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_trailing_zeros(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::ops::{Add, Sub};\\n\\n        let m = grid.len();\\n        let n = grid[0].len();\\n\\n        #[derive(Clone, Copy, Debug, Default)]\\n        struct Counts {\\n            count_2: i32,\\n            count_5: i32,\\n        }\\n\\n        impl Counts {\\n            fn zeros(&self) -> i32 {\\n                self.count_2.min(self.count_5)\\n            }\\n        }\\n\\n        impl Add for Counts {\\n            type Output = Self;\\n            fn add(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 + rhs.count_2,\\n                    count_5: self.count_5 + rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        impl Sub for Counts {\\n            type Output = Self;\\n            fn sub(self, rhs: Self) -> Self::Output {\\n                Self {\\n                    count_2: self.count_2 - rhs.count_2,\\n                    count_5: self.count_5 - rhs.count_5,\\n                }\\n            }\\n        }\\n\\n        let mut prime_count = vec![Counts::default(); 1001];\\n        for i in 2..=1000 {\\n            let mut count_2 = 0;\\n            let mut count_5 = 0;\\n            let mut k = i;\\n            while k % 2 == 0 {\\n                k /= 2;\\n                count_2 += 1;\\n            }\\n            while k % 5 == 0 {\\n                k /= 5;\\n                count_5 += 1;\\n            }\\n            prime_count[i] = Counts { count_2, count_5 };\\n        }\\n        let mut h_acc = vec![vec![Counts::default(); n + 1]; m + 1];\\n        let mut v_acc = vec![vec![Counts::default(); m + 1]; n + 1];\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let count = prime_count[grid[row][col] as usize];\\n                h_acc[row][col + 1] = h_acc[row][col] + count;\\n                v_acc[col][row + 1] = v_acc[col][row] + count;\\n            }\\n        }\\n\\n        let mut res = 0;\\n\\n        for row in 0..m {\\n            for col in 0..n {\\n                let top = v_acc[col][row];\\n                let bottom = v_acc[col][m] - v_acc[col][row + 1];\\n                let left = h_acc[row][col];\\n                let right = h_acc[row][n] - h_acc[row][col + 1];\\n                let current = prime_count[grid[row][col] as usize];\\n\\n                res = res.max(\\n                    (top + left + current).zeros()\\n                ).max(\\n                    (top + right + current).zeros()\\n                ).max(\\n                    (bottom + left + current).zeros()\\n                ).max(\\n                    (bottom + right + current).zeros()\\n                );\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2891663,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] t = new int[grid.length][grid[0].length][8];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][][] tf = new int[n][m][2];\\n        for(int i = 0; i<n;i++) {\\n            for(int j = 0 ; j<m ;j++) {\\n                int two = 0;\\n                int five = 0;\\n                int k = grid[i][j];\\n                while(k%2==0){\\n                    k/=2;\\n                    two++;\\n                }\\n                while(k%5==0){\\n                    k/=5;\\n                    five++;\\n                }\\n                tf[i][j][0] = two;\\n                tf[i][j][1] = five;\\n            }\\n        }\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<m;j++) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][0] = two;\\n                t[i][j][1] = five;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = m-1; j>=0;j--) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][2] = two;\\n                t[i][j][3] = five;\\n            }\\n        }\\n         for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<n;j++) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][4] = two;\\n                t[j][i][5] = five;\\n            }\\n        }\\n        for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = n-1; j>=0;j--) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][6] = two;\\n                t[j][i][7] = five;\\n            }\\n        }\\n        int[][] ans = new int[n][m];\\n        int a = 0;\\n         for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m ;j++) {\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][4] - tf[i][j][0],t[i][j][1] + t[i][j][5] - tf[i][j][1])); //3\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][6]- tf[i][j][0],t[i][j][1] + t[i][j][7]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][4]- tf[i][j][0],t[i][j][3] + t[i][j][5]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][6]- tf[i][j][0],t[i][j][3] + t[i][j][7]- tf[i][j][1]));\\n            a = Math.max(a,ans[i][j]);\\n            }\\n         }\\n         return a;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] t = new int[grid.length][grid[0].length][8];\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][][] tf = new int[n][m][2];\\n        for(int i = 0; i<n;i++) {\\n            for(int j = 0 ; j<m ;j++) {\\n                int two = 0;\\n                int five = 0;\\n                int k = grid[i][j];\\n                while(k%2==0){\\n                    k/=2;\\n                    two++;\\n                }\\n                while(k%5==0){\\n                    k/=5;\\n                    five++;\\n                }\\n                tf[i][j][0] = two;\\n                tf[i][j][1] = five;\\n            }\\n        }\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<m;j++) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][0] = two;\\n                t[i][j][1] = five;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i<n;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = m-1; j>=0;j--) {\\n                int k = grid[i][j];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[i][j][2] = two;\\n                t[i][j][3] = five;\\n            }\\n        }\\n         for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = 0; j<n;j++) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][4] = two;\\n                t[j][i][5] = five;\\n            }\\n        }\\n        for(int i = 0; i<m;i++) {\\n            int two = 0;\\n            int five = 0;\\n            for(int j = n-1; j>=0;j--) {\\n                int k = grid[j][i];\\n                while(k%2 == 0) {\\n                    two++;\\n                    k=k/2;\\n                }\\n                while(k%5 == 0) {\\n                    five++;\\n                    k=k/5;\\n                }\\n                t[j][i][6] = two;\\n                t[j][i][7] = five;\\n            }\\n        }\\n        int[][] ans = new int[n][m];\\n        int a = 0;\\n         for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<m ;j++) {\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][4] - tf[i][j][0],t[i][j][1] + t[i][j][5] - tf[i][j][1])); //3\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][0] + t[i][j][6]- tf[i][j][0],t[i][j][1] + t[i][j][7]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][4]- tf[i][j][0],t[i][j][3] + t[i][j][5]- tf[i][j][1]));\\n                ans[i][j] = Math.max(ans[i][j],Math.min(t[i][j][2] + t[i][j][6]- tf[i][j][0],t[i][j][3] + t[i][j][7]- tf[i][j][1]));\\n            a = Math.max(a,ans[i][j]);\\n            }\\n         }\\n         return a;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740583,
                "title": "java-concise-and-efficient-solution-explanation-included",
                "content": "```\\nclass Solution {\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[rows][cols][2];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n        \\n        int[][] prefixRowTwo  = new int[rows][cols+1];\\n        int[][] prefixRowFive = new int[rows][cols+1];\\n        \\n        int[][] prefixColTwo  = new int[cols][rows+1];\\n        int[][] prefixColFive = new int[cols][rows+1];\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                prefixRowTwo[i][j+1]  = prefixRowTwo[i][j]  + twoAndFives[i][j][0];\\n                prefixRowFive[i][j+1] = prefixRowFive[i][j] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < cols; j++) {\\n            for (int i = 0; i < rows; i++) {\\n                prefixColTwo[j][i+1]  = prefixColTwo[j][i]  + twoAndFives[i][j][0];\\n                prefixColFive[j][i+1] = prefixColFive[j][i] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= rows; i++) {\\n            for (int j = 1; j <= cols; j++) {\\n                \\n                // Path: top-down then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][i-1], prefixRowFive[i-1][j] + prefixColFive[j-1][i-1]));\\n                \\n                // Path: bottom-up then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i], prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i]));\\n                \\n                // Path: top-down then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][i], prefixRowFive[i-1][cols] - prefixRowFive[i-1][j] + prefixColFive[j-1][i]));\\n                \\n                // Path: bottom-up then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i-1], prefixRowFive[i-1][cols] -prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i-1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[rows][cols][2];\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n        \\n        int[][] prefixRowTwo  = new int[rows][cols+1];\\n        int[][] prefixRowFive = new int[rows][cols+1];\\n        \\n        int[][] prefixColTwo  = new int[cols][rows+1];\\n        int[][] prefixColFive = new int[cols][rows+1];\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                prefixRowTwo[i][j+1]  = prefixRowTwo[i][j]  + twoAndFives[i][j][0];\\n                prefixRowFive[i][j+1] = prefixRowFive[i][j] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        for (int j = 0; j < cols; j++) {\\n            for (int i = 0; i < rows; i++) {\\n                prefixColTwo[j][i+1]  = prefixColTwo[j][i]  + twoAndFives[i][j][0];\\n                prefixColFive[j][i+1] = prefixColFive[j][i] + twoAndFives[i][j][1];\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= rows; i++) {\\n            for (int j = 1; j <= cols; j++) {\\n                \\n                // Path: top-down then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][i-1], prefixRowFive[i-1][j] + prefixColFive[j-1][i-1]));\\n                \\n                // Path: bottom-up then turn left\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i], prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i]));\\n                \\n                // Path: top-down then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][i], prefixRowFive[i-1][cols] - prefixRowFive[i-1][j] + prefixColFive[j-1][i]));\\n                \\n                // Path: bottom-up then turn right\\n                max = Math.max(max, Math.min(prefixRowTwo[i-1][cols] - prefixRowTwo[i-1][j] + prefixColTwo[j-1][rows] - prefixColTwo[j-1][i-1], prefixRowFive[i-1][cols] -prefixRowFive[i-1][j] + prefixColFive[j-1][rows] - prefixColFive[j-1][i-1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735149,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<pair<ll,ll>>> v(n,vector<pair<ll,ll>>(m,{0,0})),ltr,utd,rtl,dtu;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll z=grid[i][j],c1=0,c2=0;\\n                while(z%2==0)\\n                {\\n                    z/=2;\\n                    c1++;\\n                }\\n                while(z%5==0)\\n                {\\n                    z/=5;\\n                    c2++;\\n                }\\n                v[i][j].first=c1;\\n                v[i][j].second=c2;\\n            }\\n        }\\n        ltr=utd=rtl=dtu=v;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=1;j<m;j++)\\n            {\\n                ltr[i][j].first+=ltr[i][j-1].first;\\n                ltr[i][j].second+=ltr[i][j-1].second;\\n            }\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=m-2;j>=0;j--)\\n            {\\n                rtl[i][j].first+=rtl[i][j+1].first;\\n                rtl[i][j].second+=rtl[i][j+1].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=1;i<n;i++)\\n            {\\n                utd[i][j].first+=utd[i-1][j].first;\\n                utd[i][j].second+=utd[i-1][j].second;\\n            }\\n        }\\n        for(ll j=0;j<m;j++)\\n        {\\n            for(ll i=n-2;i>=0;i--)\\n            {\\n                dtu[i][j].first+=dtu[i+1][j].first;\\n                dtu[i][j].second+=dtu[i+1][j].second;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                ll c1,c2,c3,c4;\\n                ll x1,x2,x3,x4;\\n                ll a,b;\\n                a=v[i][j].first;\\n                b=v[i][j].second;       \\n                \\n                c1=ltr[i][j].first;\\n                c2=rtl[i][j].first;\\n                \\n                c3=utd[i][j].first;\\n                c4=dtu[i][j].first;\\n                \\n                x1=ltr[i][j].second;\\n                x2=rtl[i][j].second;\\n                \\n                x3=utd[i][j].second;\\n                x4=dtu[i][j].second;\\n                \\n                ans=max(ans,min(c3+c1-a,x3+x1-b));\\n                ans=max(ans,min(c3+c2-a,x3+x2-b));\\n                ans=max(ans,min(c4+c1-a,x4+x1-b));\\n                ans=max(ans,min(c4+c2-a,x4+x2-b));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726335,
                "title": "efficient-use-of-prefix-sums-owing-to-votrubac",
                "content": "```\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\n\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\n    int factors(int i, int f) {\\n        return i % f ? 0 : 1 + factors(i / f, f);\\n    }\\n    \\n    // https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), res = 0;\\n        vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n                v[i + 1][j] = v[i][j] + f25;\\n                h[i][j + 1] = h[i][j] + f25;\\n            }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n                auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n                res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n                \\n                // 4 paths \\n                // suppose you\\'re on (i, j) cell\\n                // then either you can have vertical_top path + horizantal_right path ( L shaped) OR vertical_top path + horizantal_left path ( mirrored L)\\n                // OR vertical_down + hori_right OR vertical_down + hori_left\\n                // \\n                \\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\narray<int, 2> operator+(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] + r[0], l[1] + r[1] }; }\\narray<int, 2> operator-(const array<int, 2> &l, const array<int, 2> &r) { return { l[0] - r[0], l[1] - r[1] }; }\\n\\nint pairs(const array<int, 2> &p) { return min(p[0], p[1]); }\\n\\nclass Solution {\\npublic:\\n    int factors(int i, int f) {\\n        return i % f ? 0 : 1 + factors(i / f, f);\\n    }\\n    \\n    // https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size(), res = 0;\\n        vector<vector<array<int, 2>>> h(m, vector<array<int, 2>>(n + 1)), v(m + 1, vector<array<int, 2>>(n));\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                array<int, 2> f25 = { factors(grid[i][j], 2), factors(grid[i][j], 5) };\\n                v[i + 1][j] = v[i][j] + f25;\\n                h[i][j + 1] = h[i][j] + f25;\\n            }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j) {\\n                auto v1 = v[i + 1][j], v2 = v[m][j] - v[i][j];\\n                auto h1 = h[i][j], h2 = h[i][n] - h[i][j + 1];\\n                res = max({res, pairs(v1 + h1), pairs(v1 + h2), pairs(v2 + h1), pairs(v2 + h2)});\\n                \\n                // 4 paths \\n                // suppose you\\'re on (i, j) cell\\n                // then either you can have vertical_top path + horizantal_right path ( L shaped) OR vertical_top path + horizantal_left path ( mirrored L)\\n                // OR vertical_down + hori_right OR vertical_down + hori_left\\n                // \\n                \\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349979,
                "title": "cpp-99-faster-and-99-memory",
                "content": "class Solution {\\npublic:\\n    \\n    pair<int,int>find_factor(int n)\\n    {   \\n        int two=0,five=0;\\n        while(n%5==0)\\n        {\\n            five++;\\n            n/=5;\\n        }\\n        \\n        while(n%2==0)\\n        {\\n            two++;\\n            n/=2;\\n            \\n        }\\n        \\n        return {two,five};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        int factor[n][m][2];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {   \\n                pair<int,int>p=find_factor(grid[i][j]);\\n                factor[i][j][0]=p.first;\\n                factor[i][j][1]=p.second;\\n            }\\n        }\\n        \\n        \\n        int row[n][m][2];\\n        int col[n][m][2];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int two=0,five=0;\\n            \\n            for(int j=0;j<m;j++)\\n            {\\n                row[i][j][0]=two+factor[i][j][0];\\n                two=row[i][j][0];\\n                row[i][j][1]=five+factor[i][j][1];\\n                five=row[i][j][1];\\n            }\\n        }\\n        \\n         for(int j=0;j<m;j++)\\n        {\\n            int two=0,five=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                col[i][j][0]=two+factor[i][j][0];\\n                two=col[i][j][0];\\n                col[i][j][1]=five+factor[i][j][1];\\n                five=col[i][j][1];\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int a=(i>0)?col[i-1][j][0]:0;\\n                int b=(i!=n-1)?col[n-1][j][0]-col[i][j][0]:0;\\n                int c=(i>0)?col[i-1][j][1]:0;\\n                int d=(i!=n-1)?col[n-1][j][1]-col[i][j][1]:0;\\n                \\n                int p=(j>0)?row[i][j-1][0]:0;\\n                int q=(j!=m-1)?row[i][m-1][0]-row[i][j][0]:0;\\n                int r=(j>0)?row[i][j-1][1]:0;\\n                int s=(j!=m-1)?row[i][m-1][1]-row[i][j][1]:0;\\n                \\n                \\n                ans=max(ans,min(a+p+factor[i][j][0],c+r+factor[i][j][1]));\\n                ans=max(ans,min(a+q+factor[i][j][0],c+s+factor[i][j][1]));\\n                ans=max(ans,min(b+p+factor[i][j][0],d+r+factor[i][j][1]));\\n                ans=max(ans,min(b+q+factor[i][j][0],d+s+factor[i][j][1]));\\n                \\n                \\n            }\\n        \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    pair<int,int>find_factor(int n)\\n    {   \\n        int two=0,five=0;\\n        while(n%5==0)\\n        {\\n            five++;\\n            n/=5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2207694,
                "title": "c-explanation-easy",
                "content": "**We can then treat each cell as the elbow point and calculate the largest minimum (sum of 2 exponents, sum of 5 exponents) from the combination of top-left, top-right, bottom-left and bottom-right.**\\n\\n```\\nclass Solution {\\npublic:\\n    int pow2(int num)\\n    {   int cnt=0;\\n        while(num%2==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/2;\\n        }\\n     return cnt;\\n    }\\n    \\n    int pow5(int num)\\n    {   int cnt=0;\\n        while(num%5==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/5;\\n        }\\n     return cnt;\\n    }\\n    \\n    int ans=0;\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n    vector<pair<int, int>> up (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> dwn (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> rht (grid.size(), std::make_pair(0,0));\\n    vector<pair<int, int>> lft (grid.size(), std::make_pair(0,0));\\n         \\n         for(int i=0;i<grid.size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid[0].size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[i][j]);\\n                b=b+pow5(grid[i][j]);\\n            }\\n             rht[i].first=a;\\n             rht[i].second=b;\\n             ans=max(ans,min(a,b));\\n         }\\n        \\n         for(int i=0;i<grid[0].size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid.size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[j][i]);\\n                b=b+pow5(grid[j][i]);\\n            }\\n             dwn[i].first=a;\\n             dwn[i].second=b; \\n              ans=max(ans,min(a,b));\\n         }\\n        \\n       \\n        for(int i=0;i<grid.size();i=i+1)\\n        {\\n            for(int j=0;j<grid[0].size();j=j+1)\\n            {\\n                \\n                int a=pow2(grid[i][j]);\\n                int b=pow5(grid[i][j]);\\n                rht[i].first=rht[i].first-a;\\n                rht[i].second=rht[i].second-b;\\n                dwn[j].first=dwn[j].first-a;\\n                dwn[j].second=dwn[j].second-b;\\n                \\n                ans=max(ans,min(rht[i].first+dwn[j].first+a,rht[i].second+dwn[j].second+b));\\n                ans=max(ans,min(rht[i].first+up[j].first+a,rht[i].second+up[j].second+b));\\n                ans=max(ans,min(lft[i].first+dwn[j].first+a,lft[i].second+dwn[j].second+b));\\n                ans=max(ans,min(lft[i].first+up[j].first+a,lft[i].second+up[j].second+b));\\n                \\n               lft[i].first=lft[i].first+a;\\n               lft[i].second=lft[i].second+b; \\n               up[j].first=up[j].first+a;\\n               up[j].second=up[j].second+b;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you found it helpful, kindly upvote!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pow2(int num)\\n    {   int cnt=0;\\n        while(num%2==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/2;\\n        }\\n     return cnt;\\n    }\\n    \\n    int pow5(int num)\\n    {   int cnt=0;\\n        while(num%5==0)\\n        {\\n            cnt=cnt+1;\\n            num=num/5;\\n        }\\n     return cnt;\\n    }\\n    \\n    int ans=0;\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n    vector<pair<int, int>> up (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> dwn (grid[0].size(), std::make_pair(0,0));\\n    vector<pair<int, int>> rht (grid.size(), std::make_pair(0,0));\\n    vector<pair<int, int>> lft (grid.size(), std::make_pair(0,0));\\n         \\n         for(int i=0;i<grid.size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid[0].size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[i][j]);\\n                b=b+pow5(grid[i][j]);\\n            }\\n             rht[i].first=a;\\n             rht[i].second=b;\\n             ans=max(ans,min(a,b));\\n         }\\n        \\n         for(int i=0;i<grid[0].size();i=i+1)\\n        {   \\n             int a=0;\\n             int b=0;\\n             for(int j=grid.size()-1;j>=0;j=j-1)\\n            {\\n                a=a+pow2(grid[j][i]);\\n                b=b+pow5(grid[j][i]);\\n            }\\n             dwn[i].first=a;\\n             dwn[i].second=b; \\n              ans=max(ans,min(a,b));\\n         }\\n        \\n       \\n        for(int i=0;i<grid.size();i=i+1)\\n        {\\n            for(int j=0;j<grid[0].size();j=j+1)\\n            {\\n                \\n                int a=pow2(grid[i][j]);\\n                int b=pow5(grid[i][j]);\\n                rht[i].first=rht[i].first-a;\\n                rht[i].second=rht[i].second-b;\\n                dwn[j].first=dwn[j].first-a;\\n                dwn[j].second=dwn[j].second-b;\\n                \\n                ans=max(ans,min(rht[i].first+dwn[j].first+a,rht[i].second+dwn[j].second+b));\\n                ans=max(ans,min(rht[i].first+up[j].first+a,rht[i].second+up[j].second+b));\\n                ans=max(ans,min(lft[i].first+dwn[j].first+a,lft[i].second+dwn[j].second+b));\\n                ans=max(ans,min(lft[i].first+up[j].first+a,lft[i].second+up[j].second+b));\\n                \\n               lft[i].first=lft[i].first+a;\\n               lft[i].second=lft[i].second+b; \\n               up[j].first=up[j].first+a;\\n               up[j].second=up[j].second+b;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166545,
                "title": "best-c-solution-tc-o-n-m-sc-o-min-n-m",
                "content": "\\n\\ntemplate <typename T, typename U>\\nstd::pair<T, U> operator+(const std::pair<T, U> &l, const std::pair<T, U> &r)\\n{\\n    return {l.first + r.first, l.second + r.second};\\n}\\n\\ntemplate <typename T, typename U>\\nstd::pair<T, U> operator-(const std::pair<T, U> &l, const std::pair<T, U> &r)\\n{\\n    return {l.first - r.first, l.second - r.second};\\n}\\n\\ntypedef pair<int, int> p;\\n\\nclass Solution\\n{public:\\n\\n    p decompose(int n)\\n    {\\n        int two = 0;\\n        int five = 0;\\n\\n        while (n % 2 == 0)\\n        {\\n            two++;\\n            n /= 2;\\n        }\\n\\n        while (n % 5 == 0)\\n        {\\n            five++;\\n            n /= 5;\\n        }\\n\\n        return make_pair(two, five);\\n    }\\n\\n\\n    int maxTrailingZeros(vector<vector<int>> &grid)\\n    {\\n\\n        vector<p> rows(grid.size(), make_pair(0, 0));\\n        vector<p> cols(grid[0].size(), make_pair(0, 0));\\n\\n        for (int i = 0; i < grid.size(); i++)\\n\\n        {\\n\\n            for (int j = 0; j < grid[0].size(); j++)\\n            {\\n                auto pr = decompose(grid[i][j]);\\n                rows[i].first += pr.first;\\n                rows[i].second += pr.second;\\n\\n                cols[j].first += pr.first;\\n                cols[j].second += pr.second;\\n            }\\n        }\\n\\n        vector<p> colstill(grid[0].size(), make_pair(0, 0));\\n\\n        int max0 = 0;\\n\\n        for (int i = 0; i < grid.size(); i++)\\n\\n        {\\n            p rowtill = make_pair(0, 0);\\n\\n            for (int j = 0; j < grid[0].size(); j++)\\n            {\\n                auto a=decompose(grid[i][j]);\\n\\n                auto r = rows[i] - rowtill;\\n\\n                rowtill.first+=a.first;\\n                rowtill.second+=a.second;\\n\\n                p l = rowtill;\\n              \\n\\n                auto t = colstill[j];\\n                auto b = cols[j] - colstill[j];\\n                b.first-=a.first;\\n                b.second-=a.second;\\n                \\n\\n                int tz1 = min(l.first + t.first, l.second + t.second);\\n                int tz2 = min(l.first + b.first, l.second + b.second);\\n                int tz3 = min(r.first + t.first, r.second + t.second);\\n                int tz4 = min(r.first + b.first, r.second + b.second);\\n\\n                max0 = max(max0, tz1);\\n                max0 = max(max0, tz2);\\n                max0 = max(max0, tz3);\\n                max0 = max(max0, tz4);\\n\\n                colstill[j].first+=a.first;\\n                colstill[j].second+=a.second;\\n            }\\n        }\\n\\n        return max0;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n{public:\\n\\n    p decompose(int n)\\n    {\\n        int two = 0;\\n        int five = 0;\\n\\n        while (n % 2 == 0)\\n        {\\n            two++;\\n            n /= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083365,
                "title": "c-solution-faster-than-90-o-m-n-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    class data{\\n        public:\\n        int up_5, up_2,\\n            left_5, left_2;\\n        };\\n    vector<vector<data>> v;\\n    int func2(int n)\\n    {\\n        int res=0;\\n        while(n%2==0){ res++; n/=2;}\\n        return res;\\n    }\\n    int func5(int n)\\n    {\\n        int res=0;\\n        while(n%5==0){ res++; n/=5;}\\n        return res;\\n    }\\n    int sol(int x1, int x2, int y1, int y2, int z1, int z2)\\n    {\\n        return min(x1+y1+z1, x2+y2+z2);\\n    }\\n    int func(int i, int j, vector<vector<int>> &g, data H, data V)\\n    {\\n        int res=0;\\n        data cur=v[i][j];\\n        \\n        int cnt_2=func2(g[i][j]), cnt_5=func5(g[i][j]);\\n        res=max(res, sol(-cnt_2, -cnt_5, cur.left_2, cur.left_5, cur.up_2, cur.up_5));\\n        res=max(res, sol(0,0,cur.left_2,cur.left_5,V.up_2-cur.up_2,V.up_5-cur.up_5));\\n        res=max(res, sol(0,0,cur.up_2,cur.up_5,H.left_2-cur.left_2,H.left_5-cur.left_5));\\n        res=max(res, sol(cnt_2,cnt_5,V.up_2-cur.up_2,V.up_5-cur.up_5,H.left_2-cur.left_2, H.left_5-cur.left_5));\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int m=g.size(), n=g[0].size();\\n        v.assign(m+1, vector<data>(n+1));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0){\\n                    v[i][j].up_2=func2(g[i][j]); v[i][j].up_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].up_2=v[i-1][j].up_2+func2(g[i][j]); \\n                    v[i][j].up_5=v[i-1][j].up_5+func5(g[i][j]);\\n                }\\n                if(j==0){\\n                    v[i][j].left_2=func2(g[i][j]); v[i][j].left_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].left_2=v[i][j-1].left_2+func2(g[i][j]); \\n                    v[i][j].left_5=v[i][j-1].left_5+func5(g[i][j]);\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                res=max(res, func(i, j, g, v[i][n-1], v[m-1][j]));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class data{\\n        public:\\n        int up_5, up_2,\\n            left_5, left_2;\\n        };\\n    vector<vector<data>> v;\\n    int func2(int n)\\n    {\\n        int res=0;\\n        while(n%2==0){ res++; n/=2;}\\n        return res;\\n    }\\n    int func5(int n)\\n    {\\n        int res=0;\\n        while(n%5==0){ res++; n/=5;}\\n        return res;\\n    }\\n    int sol(int x1, int x2, int y1, int y2, int z1, int z2)\\n    {\\n        return min(x1+y1+z1, x2+y2+z2);\\n    }\\n    int func(int i, int j, vector<vector<int>> &g, data H, data V)\\n    {\\n        int res=0;\\n        data cur=v[i][j];\\n        \\n        int cnt_2=func2(g[i][j]), cnt_5=func5(g[i][j]);\\n        res=max(res, sol(-cnt_2, -cnt_5, cur.left_2, cur.left_5, cur.up_2, cur.up_5));\\n        res=max(res, sol(0,0,cur.left_2,cur.left_5,V.up_2-cur.up_2,V.up_5-cur.up_5));\\n        res=max(res, sol(0,0,cur.up_2,cur.up_5,H.left_2-cur.left_2,H.left_5-cur.left_5));\\n        res=max(res, sol(cnt_2,cnt_5,V.up_2-cur.up_2,V.up_5-cur.up_5,H.left_2-cur.left_2, H.left_5-cur.left_5));\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int m=g.size(), n=g[0].size();\\n        v.assign(m+1, vector<data>(n+1));\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i==0){\\n                    v[i][j].up_2=func2(g[i][j]); v[i][j].up_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].up_2=v[i-1][j].up_2+func2(g[i][j]); \\n                    v[i][j].up_5=v[i-1][j].up_5+func5(g[i][j]);\\n                }\\n                if(j==0){\\n                    v[i][j].left_2=func2(g[i][j]); v[i][j].left_5=func5(g[i][j]);\\n                }else{\\n                    v[i][j].left_2=v[i][j-1].left_2+func2(g[i][j]); \\n                    v[i][j].left_5=v[i][j-1].left_5+func5(g[i][j]);\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                res=max(res, func(i, j, g, v[i][n-1], v[m-1][j]));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071512,
                "title": "horizontal-vertical-prefix-sum",
                "content": "For each cell, calculate count of factors of 2 and 5. Then, prepare a horizontal and vertical prefix sum grid. Now, considering each cell as a turning point, calculate maximum number of trailing zeros from the four paths i.e: left-to-top, left to bottom, top to right, and right to bottom. You got the answer. :)\\n```\\nclass Solution {\\n    pair<int,int> getCount(int num) {\\n        int c2=0, c5=0;\\n        while(num%2 == 0) {\\n            num/=2;\\n            c2++;\\n        }\\n        while(num%5 == 0) {\\n            num/=5;\\n            c5++;\\n        }\\n        return make_pair(c2,c5);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> aux; // to maintain count of factors of 2 and 5 for each cell element\\n        int m=grid.size(), n=grid[0].size();\\n        for(int i=0;i<m;i++) {\\n            vector<pair<int,int>> temp;\\n            for(int j=0;j<n;j++) {\\n                temp.push_back(getCount(grid[i][j]));\\n            }\\n            aux.push_back(temp);\\n        }\\n        \\n        int ans=0;\\n        \\n        vector<vector<pair<int,int>>> aux1(m, vector<pair<int,int>>(n, {0,0})), aux2(m, vector<pair<int,int>>(n, {0,0})); // array to maintain vertical and horizontal perfix sum\\n        \\n        for(int i=0;i<m;i++) {\\n            aux1[i][0] = aux[i][0];\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            aux2[0][j] = aux[0][j];\\n        }\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                aux1[i][j].first = aux[i][j].first+aux1[i][j-1].first;\\n                aux1[i][j].second = aux[i][j].second+aux1[i][j-1].second;\\n                ans=max(ans, min(aux1[i][j].first, aux1[i][j].second));\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            for(int i=1;i<m;i++) {\\n                aux2[i][j].first = aux[i][j].first+aux2[i-1][j].first;\\n                aux2[i][j].second = aux[i][j].second+aux2[i-1][j].second;\\n                ans=max(ans, min(aux2[i][j].first, aux2[i][j].second));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                                \\n                int tl=0,tr=0,tt=0,tb=0; // t stands for two, l for left, f for five, r for right and so on.\\n                int fl=0,fr=0,ft=0,fb=0;\\n                \\n                if(j-1>=0) {\\n                    tl=aux1[i][j-1].first;\\n                    fl=aux1[i][j-1].second;\\n                }\\n                \\n                if(i-1>=0) {\\n                    tt=aux2[i-1][j].first;\\n                    ft=aux2[i-1][j].second;\\n                }\\n                \\n                tr=aux1[i][n-1].first-aux1[i][j].first;\\n                fr=aux1[i][n-1].second-aux1[i][j].second;\\n                \\n                tb=aux2[m-1][j].first-aux2[i][j].first;\\n                fb=aux2[m-1][j].second-aux2[i][j].second;\\n                \\n                // top-to-left\\n                ans = max(ans, min(tl+tt+aux[i][j].first, fl+ft+aux[i][j].second));\\n                // left-to-bottom\\n                ans = max(ans, min(tl+tb+aux[i][j].first, fl+fb+aux[i][j].second));\\n                // top-to-right\\n                ans = max(ans, min(tt+tr+aux[i][j].first, ft+fr+aux[i][j].second));\\n                // right-to-bottom\\n                ans = max(ans, min(tr+tb+aux[i][j].first, fr+fb+aux[i][j].second));\\n                \\n                \\n            }\\n        }\\n        \\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    pair<int,int> getCount(int num) {\\n        int c2=0, c5=0;\\n        while(num%2 == 0) {\\n            num/=2;\\n            c2++;\\n        }\\n        while(num%5 == 0) {\\n            num/=5;\\n            c5++;\\n        }\\n        return make_pair(c2,c5);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> aux; // to maintain count of factors of 2 and 5 for each cell element\\n        int m=grid.size(), n=grid[0].size();\\n        for(int i=0;i<m;i++) {\\n            vector<pair<int,int>> temp;\\n            for(int j=0;j<n;j++) {\\n                temp.push_back(getCount(grid[i][j]));\\n            }\\n            aux.push_back(temp);\\n        }\\n        \\n        int ans=0;\\n        \\n        vector<vector<pair<int,int>>> aux1(m, vector<pair<int,int>>(n, {0,0})), aux2(m, vector<pair<int,int>>(n, {0,0})); // array to maintain vertical and horizontal perfix sum\\n        \\n        for(int i=0;i<m;i++) {\\n            aux1[i][0] = aux[i][0];\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            aux2[0][j] = aux[0][j];\\n        }\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=1;j<n;j++) {\\n                aux1[i][j].first = aux[i][j].first+aux1[i][j-1].first;\\n                aux1[i][j].second = aux[i][j].second+aux1[i][j-1].second;\\n                ans=max(ans, min(aux1[i][j].first, aux1[i][j].second));\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++) {\\n            for(int i=1;i<m;i++) {\\n                aux2[i][j].first = aux[i][j].first+aux2[i-1][j].first;\\n                aux2[i][j].second = aux[i][j].second+aux2[i-1][j].second;\\n                ans=max(ans, min(aux2[i][j].first, aux2[i][j].second));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                                \\n                int tl=0,tr=0,tt=0,tb=0; // t stands for two, l for left, f for five, r for right and so on.\\n                int fl=0,fr=0,ft=0,fb=0;\\n                \\n                if(j-1>=0) {\\n                    tl=aux1[i][j-1].first;\\n                    fl=aux1[i][j-1].second;\\n                }\\n                \\n                if(i-1>=0) {\\n                    tt=aux2[i-1][j].first;\\n                    ft=aux2[i-1][j].second;\\n                }\\n                \\n                tr=aux1[i][n-1].first-aux1[i][j].first;\\n                fr=aux1[i][n-1].second-aux1[i][j].second;\\n                \\n                tb=aux2[m-1][j].first-aux2[i][j].first;\\n                fb=aux2[m-1][j].second-aux2[i][j].second;\\n                \\n                // top-to-left\\n                ans = max(ans, min(tl+tt+aux[i][j].first, fl+ft+aux[i][j].second));\\n                // left-to-bottom\\n                ans = max(ans, min(tl+tb+aux[i][j].first, fl+fb+aux[i][j].second));\\n                // top-to-right\\n                ans = max(ans, min(tt+tr+aux[i][j].first, ft+fr+aux[i][j].second));\\n                // right-to-bottom\\n                ans = max(ans, min(tr+tb+aux[i][j].first, fr+fb+aux[i][j].second));\\n                \\n                \\n            }\\n        }\\n        \\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988880,
                "title": "simple-brute-force-using-prefix-sum-of-number-of-factors-of-2-and-5",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int count(int num,int v){\\n        int cnt=0;\\n        while(num>0 and num%v==0){\\n            cnt++;\\n            num/=v;\\n        }\\n        return cnt;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> h,v;\\n        int n=grid.size(),m=grid[0].size();\\n        h.resize(n,vector<pair<int,int>>(m));\\n        v.resize(n,vector<pair<int,int>>(m));\\n        for(int i=0;i<n;i++){\\n            int two=0,fv=0;\\n            for(int j=0;j<m;j++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                h[i][j]={two,fv};\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            int two=0,fv=0;\\n            for(int i=0;i<n;i++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                v[i][j]={two,fv};\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int v12=(v[i][j].first+h[i][j].first)-count(grid[i][j],2);\\n                int v15=(v[i][j].second+h[i][j].second)-count(grid[i][j],5);\\n                \\n                int v21=(v[i][j].first+h[i][m-1].first)-h[i][j].first;\\n                int v25=(v[i][j].second+h[i][m-1].second)-h[i][j].second;\\n\\n                int v31=(h[i][j].first+v[n-1][j].first)-v[i][j].first;\\n                int v35=(h[i][j].second+v[n-1][j].second)-v[i][j].second;\\n                \\n                int v41=(h[i][m-1].first+v[n-1][j].first)-(v[i][j].first+h[i][j].first)+count(grid[i][j],2);\\n                int v45=(h[i][m-1].second+v[n-1][j].second)-(v[i][j].second+h[i][j].second)+count(grid[i][j],5);\\n                int k=max({min(v12,v15),min(v21,v25),min(v31,v35),min(v41,v45)});\\n                ans=max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count(int num,int v){\\n        int cnt=0;\\n        while(num>0 and num%v==0){\\n            cnt++;\\n            num/=v;\\n        }\\n        return cnt;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        vector<vector<pair<int,int>>> h,v;\\n        int n=grid.size(),m=grid[0].size();\\n        h.resize(n,vector<pair<int,int>>(m));\\n        v.resize(n,vector<pair<int,int>>(m));\\n        for(int i=0;i<n;i++){\\n            int two=0,fv=0;\\n            for(int j=0;j<m;j++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                h[i][j]={two,fv};\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            int two=0,fv=0;\\n            for(int i=0;i<n;i++){\\n                two+=count(grid[i][j],2);\\n                fv+=count(grid[i][j],5);\\n                v[i][j]={two,fv};\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int v12=(v[i][j].first+h[i][j].first)-count(grid[i][j],2);\\n                int v15=(v[i][j].second+h[i][j].second)-count(grid[i][j],5);\\n                \\n                int v21=(v[i][j].first+h[i][m-1].first)-h[i][j].first;\\n                int v25=(v[i][j].second+h[i][m-1].second)-h[i][j].second;\\n\\n                int v31=(h[i][j].first+v[n-1][j].first)-v[i][j].first;\\n                int v35=(h[i][j].second+v[n-1][j].second)-v[i][j].second;\\n                \\n                int v41=(h[i][m-1].first+v[n-1][j].first)-(v[i][j].first+h[i][j].first)+count(grid[i][j],2);\\n                int v45=(h[i][m-1].second+v[n-1][j].second)-(v[i][j].second+h[i][j].second)+count(grid[i][j],5);\\n                int k=max({min(v12,v15),min(v21,v25),min(v31,v35),min(v41,v45)});\\n                ans=max(ans,k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978311,
                "title": "c-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // Add Pair Utility Function\\n    pair<int, int> addPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first + b.first , a.second + b.second};\\n    }\\n    // Sub Pair Utility Function\\n    pair<int, int> subPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first - b.first , a.second - b.second};\\n    }\\n    \\n    // Find the number of 5s and 2s making factors of the current number\\n    pair<int, int> factors(int num){\\n        int fiveCount = 0;\\n        int twoCount = 0;\\n        while(num % 5 == 0){\\n            fiveCount += 1;\\n            num /= 5;\\n        }\\n        while(num % 2 == 0){\\n            twoCount += 1;\\n            num /= 2;\\n        }\\n        return {fiveCount, twoCount};\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<vector<pair<int, int>>> hor(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> ver(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> fgrid(n, vector<pair<int, int>>(m, {0, 0}));\\n        // Get count of 5 and 2 factors of each number\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                fgrid[i][j] = factors(grid[i][j]);\\n            }\\n        }\\n        \\n        // horizontal prefix array from left to right\\n        for(int i=0;i<n;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<m;j++){\\n                fcount += fgrid[i][j].first;\\n                tcount += fgrid[i][j].second;\\n                hor[i][j] = {fcount, tcount};\\n            }\\n        }\\n        \\n        // vertical prefix array from top to bottom \\n        for(int i=0;i<m;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<n;j++){\\n                fcount += fgrid[j][i].first;\\n                tcount += fgrid[j][i].second;\\n                ver[j][i] = {fcount, tcount};\\n            }\\n        }\\n        \\n        /*\\n        *   Iterating each cell. There are 4 ways each cell can contribute to the path\\n        *   top-left, top-right, left-bottom, right-bottom\\n        *   Adding 5s and 2s for all paths and updating ans with min count of 5s ans 2s.\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pair<int, int> count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][m-1], ver[i][j]), hor[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n\\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[n-1][j]), ver[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = addPair(subPair(subPair(addPair(hor[i][m-1], ver[n-1][j]), hor[i][j]), ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n            }\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Add Pair Utility Function\\n    pair<int, int> addPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first + b.first , a.second + b.second};\\n    }\\n    // Sub Pair Utility Function\\n    pair<int, int> subPair(pair<int, int> a, pair<int, int> b){\\n        return {a.first - b.first , a.second - b.second};\\n    }\\n    \\n    // Find the number of 5s and 2s making factors of the current number\\n    pair<int, int> factors(int num){\\n        int fiveCount = 0;\\n        int twoCount = 0;\\n        while(num % 5 == 0){\\n            fiveCount += 1;\\n            num /= 5;\\n        }\\n        while(num % 2 == 0){\\n            twoCount += 1;\\n            num /= 2;\\n        }\\n        return {fiveCount, twoCount};\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<vector<pair<int, int>>> hor(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> ver(n, vector<pair<int, int>>(m, {0, 0}));\\n        vector<vector<pair<int, int>>> fgrid(n, vector<pair<int, int>>(m, {0, 0}));\\n        // Get count of 5 and 2 factors of each number\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                fgrid[i][j] = factors(grid[i][j]);\\n            }\\n        }\\n        \\n        // horizontal prefix array from left to right\\n        for(int i=0;i<n;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<m;j++){\\n                fcount += fgrid[i][j].first;\\n                tcount += fgrid[i][j].second;\\n                hor[i][j] = {fcount, tcount};\\n            }\\n        }\\n        \\n        // vertical prefix array from top to bottom \\n        for(int i=0;i<m;i++){\\n            int fcount = 0;\\n            int tcount = 0;\\n            for(int j=0;j<n;j++){\\n                fcount += fgrid[j][i].first;\\n                tcount += fgrid[j][i].second;\\n                ver[j][i] = {fcount, tcount};\\n            }\\n        }\\n        \\n        /*\\n        *   Iterating each cell. There are 4 ways each cell can contribute to the path\\n        *   top-left, top-right, left-bottom, right-bottom\\n        *   Adding 5s and 2s for all paths and updating ans with min count of 5s ans 2s.\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pair<int, int> count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][m-1], ver[i][j]), hor[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n\\n                count = {0, 0};\\n                count = subPair(addPair(hor[i][j], ver[n-1][j]), ver[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n                count = {0, 0};\\n                count = addPair(subPair(subPair(addPair(hor[i][m-1], ver[n-1][j]), hor[i][j]), ver[i][j]), fgrid[i][j]);\\n                ans = max(ans, min(count.first, count.second));\\n                \\n            }\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977888,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    pair<ll, ll> getZeroes(ll n) {\\n        pair<ll, ll>res{ 0,0 };\\n        ll m = n;\\n        while (n && n % 2 == 0) {\\n            ++res.first;\\n            n /= 2;\\n        }\\n        n = m;\\n        while (n && n % 5 == 0) {\\n            ++res.second;\\n            n /= 5;\\n        }\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        ll m = v.size(), n = v.front().size(), ans = 0;\\n        vector<vector<pair<ll, ll>>>preHor(m, vector<pair<ll, ll>>(n)), preVer(m, vector<pair<ll, ll>>(n));//, tmpV(m, vector<ll>(n));\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                auto tmp = getZeroes(v[i][j]);\\n                if (j) {\\n                    tmp.first += preHor[i][j - 1].first;\\n                    tmp.second += preHor[i][j - 1].second;\\n                }\\n                preHor[i][j] = tmp;\\n                tmp = getZeroes(v[i][j]);\\n                if (i) {\\n                    tmp.first += preVer[i - 1][j].first;\\n                    tmp.second += preVer[i - 1][j].second;\\n                }\\n                preVer[i][j] = tmp;\\n            }\\n        }\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                pair<ll, ll> top = preVer[i][j], left = preHor[i][j];\\n                pair<ll, ll>right = preHor[i].back(), down = preVer.back()[j];\\n                if (j) {\\n                    right.first -= preHor[i][j - 1].first;\\n                    right.second -= preHor[i][j - 1].second;\\n                }\\n                if (i) {\\n                    down.first -= preVer[i - 1][j].first;\\n                    down.second -= preVer[i - 1][j].second;\\n                }\\n                auto cur = getZeroes(v[i][j]);\\n                ll res = min(top.first+left.first-cur.first, top.second+left.second-cur.second);\\n\\n                res = max(res, min(top.first+right.first-cur.first, top.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+right.first-cur.first, down.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+left.first-cur.first, down.second+left.second-cur.second));\\n                ans = max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    pair<ll, ll> getZeroes(ll n) {\\n        pair<ll, ll>res{ 0,0 };\\n        ll m = n;\\n        while (n && n % 2 == 0) {\\n            ++res.first;\\n            n /= 2;\\n        }\\n        n = m;\\n        while (n && n % 5 == 0) {\\n            ++res.second;\\n            n /= 5;\\n        }\\n        return res;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& v) {\\n        ll m = v.size(), n = v.front().size(), ans = 0;\\n        vector<vector<pair<ll, ll>>>preHor(m, vector<pair<ll, ll>>(n)), preVer(m, vector<pair<ll, ll>>(n));//, tmpV(m, vector<ll>(n));\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                auto tmp = getZeroes(v[i][j]);\\n                if (j) {\\n                    tmp.first += preHor[i][j - 1].first;\\n                    tmp.second += preHor[i][j - 1].second;\\n                }\\n                preHor[i][j] = tmp;\\n                tmp = getZeroes(v[i][j]);\\n                if (i) {\\n                    tmp.first += preVer[i - 1][j].first;\\n                    tmp.second += preVer[i - 1][j].second;\\n                }\\n                preVer[i][j] = tmp;\\n            }\\n        }\\n        for (ll i = 0;i < m;++i) {\\n            for (ll j = 0;j < n;++j) {\\n                pair<ll, ll> top = preVer[i][j], left = preHor[i][j];\\n                pair<ll, ll>right = preHor[i].back(), down = preVer.back()[j];\\n                if (j) {\\n                    right.first -= preHor[i][j - 1].first;\\n                    right.second -= preHor[i][j - 1].second;\\n                }\\n                if (i) {\\n                    down.first -= preVer[i - 1][j].first;\\n                    down.second -= preVer[i - 1][j].second;\\n                }\\n                auto cur = getZeroes(v[i][j]);\\n                ll res = min(top.first+left.first-cur.first, top.second+left.second-cur.second);\\n\\n                res = max(res, min(top.first+right.first-cur.first, top.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+right.first-cur.first, down.second+right.second-cur.second));\\n                \\n                res = max(res, min(down.first+left.first-cur.first, down.second+left.second-cur.second));\\n                ans = max(ans, res);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975261,
                "title": "c-o-n-m-solution-prefix-sum-solution",
                "content": "```cpp\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpii;\\ntypedef vector<vpii> vvpii;\\nclass Solution {\\npublic:\\n    pii get_count(int x,int p=0){\\n        int c_2=0,c_5=0;\\n        while(x%2==0)\\n            x/=2,c_2+=1;\\n        while(x%5==0)\\n            x/=5,c_5+=1;\\n        if(p==1)\\n            return {-c_2,-c_5};\\n        return {c_2,c_5};\\n    }\\n    void print(vvpii &arr){\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                cout<<\"{\"<<arr[i][j].first<<\",\"<<arr[i][j].second<<\"}, \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\\'\\\\n\\';\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vvpii horizontal(n,vpii(m)),vertical(n,vpii(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(j==0){\\n                    horizontal[i][j]={a,b};\\n                    continue;\\n                }\\n                horizontal[i][j]=horizontal[i][j-1];\\n                horizontal[i][j].first+=a;\\n                horizontal[i][j].second+=b;\\n            }\\n        }\\n        // print(horizontal);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(i==0){\\n                    vertical[i][j]={a,b};\\n                    continue;\\n                }\\n                vertical[i][j]=vertical[i-1][j];\\n                vertical[i][j].first+=a;\\n                vertical[i][j].second+=b;\\n            }\\n        }\\n        // print(vertical);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pii h=horizontal[i][j];\\n                pii v=vertical[i][j];\\n                pii c=get_count(grid[i][j]);\\n//                 case1:  _|\\n                int a1=h.first+v.first-c.first;\\n                int b1=h.second+v.second-c.second;\\n//                 case 2: |_\\n                int a2=v.first+(horizontal[i][m-1].first-horizontal[i][j].first);\\n                int b2=v.second+(horizontal[i][m-1].second-horizontal[i][j].second);\\n//                 case 3: --\\\\\\n                int a3=h.first+vertical[n-1][j].first-vertical[i][j].first;\\n                int b3=h.second+vertical[n-1][j].second-vertical[i][j].second;\\n//                 case 4: /--\\n                int a4=(vertical[n-1][j].first-vertical[i][j].first)+(horizontal[i][m-1].first-horizontal[i][j].first)+c.first;\\n                int b4=(vertical[n-1][j].second-vertical[i][j].second)+(horizontal[i][m-1].second-horizontal[i][j].second)+c.second;       \\n                \\n                ans=max({ans,min(a1,b1),min(a2,b2),min(a3,b3),min(a4,b4)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```cpp\\ntypedef pair<int,int> pii;\\ntypedef vector<pair<int,int>> vpii;\\ntypedef vector<vpii> vvpii;\\nclass Solution {\\npublic:\\n    pii get_count(int x,int p=0){\\n        int c_2=0,c_5=0;\\n        while(x%2==0)\\n            x/=2,c_2+=1;\\n        while(x%5==0)\\n            x/=5,c_5+=1;\\n        if(p==1)\\n            return {-c_2,-c_5};\\n        return {c_2,c_5};\\n    }\\n    void print(vvpii &arr){\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                cout<<\"{\"<<arr[i][j].first<<\",\"<<arr[i][j].second<<\"}, \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<\\'\\\\n\\';\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vvpii horizontal(n,vpii(m)),vertical(n,vpii(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(j==0){\\n                    horizontal[i][j]={a,b};\\n                    continue;\\n                }\\n                horizontal[i][j]=horizontal[i][j-1];\\n                horizontal[i][j].first+=a;\\n                horizontal[i][j].second+=b;\\n            }\\n        }\\n        // print(horizontal);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                auto [a,b]=get_count(grid[i][j]);\\n                if(i==0){\\n                    vertical[i][j]={a,b};\\n                    continue;\\n                }\\n                vertical[i][j]=vertical[i-1][j];\\n                vertical[i][j].first+=a;\\n                vertical[i][j].second+=b;\\n            }\\n        }\\n        // print(vertical);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pii h=horizontal[i][j];\\n                pii v=vertical[i][j];\\n                pii c=get_count(grid[i][j]);\\n//                 case1:  _|\\n                int a1=h.first+v.first-c.first;\\n                int b1=h.second+v.second-c.second;\\n//                 case 2: |_\\n                int a2=v.first+(horizontal[i][m-1].first-horizontal[i][j].first);\\n                int b2=v.second+(horizontal[i][m-1].second-horizontal[i][j].second);\\n//                 case 3: --\\\\\\n                int a3=h.first+vertical[n-1][j].first-vertical[i][j].first;\\n                int b3=h.second+vertical[n-1][j].second-vertical[i][j].second;\\n//                 case 4: /--\\n                int a4=(vertical[n-1][j].first-vertical[i][j].first)+(horizontal[i][m-1].first-horizontal[i][j].first)+c.first;\\n                int b4=(vertical[n-1][j].second-vertical[i][j].second)+(horizontal[i][m-1].second-horizontal[i][j].second)+c.second;       \\n                \\n                ans=max({ans,min(a1,b1),min(a2,b2),min(a3,b3),min(a4,b4)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1970787,
                "title": "python3-o-mn-vertical-horizontal-prefix-sum-solution",
                "content": "First step is convert each number to how many 2s and 5s it contains, these are the ingredients of 10. \\nThen is just standard counting using prefix array in both vertical and horizontal way. \\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n      m, n = len(grid), len(grid[0])\\n      new_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      for i in range(m):\\n        for j in range(n):\\n          target = grid[i][j]\\n          count2, count5 = 0, 0\\n          while target % 2 == 0:\\n            count2 += 1\\n            target = target//2\\n          while target % 5 == 0:\\n            count5 += 1\\n            target = target//5\\n          new_grid[i][j] = [count2, count5]\\n      verti_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      hori_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      \\n      for i in range(m):\\n        sum2, sum5 = 0, 0\\n        for j in range(n):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          hori_grid[i][j] = [sum2, sum5]\\n          \\n      for j in range(n):\\n        sum2, sum5 = 0, 0\\n        for i in range(m):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          verti_grid[i][j] = [sum2, sum5]\\n        \\n      res = -sys.maxsize\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          start2, start5 = hori_grid[i][j][0], hori_grid[i][j][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n\\n      for i in range(m):\\n        for j in range(n):\\n          if j != 0:\\n            start2, start5 = hori_grid[i][-1][0] - hori_grid[i][j-1][0], \\\\\\n                             hori_grid[i][-1][1] - hori_grid[i][j-1][1]\\n          else:\\n            start2, start5 = hori_grid[i][-1][0], hori_grid[i][-1][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n          \\n      return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n      m, n = len(grid), len(grid[0])\\n      new_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      for i in range(m):\\n        for j in range(n):\\n          target = grid[i][j]\\n          count2, count5 = 0, 0\\n          while target % 2 == 0:\\n            count2 += 1\\n            target = target//2\\n          while target % 5 == 0:\\n            count5 += 1\\n            target = target//5\\n          new_grid[i][j] = [count2, count5]\\n      verti_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      hori_grid = [[[0, 0] for _ in range(n)] for _ in range(m)]\\n      \\n      for i in range(m):\\n        sum2, sum5 = 0, 0\\n        for j in range(n):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          hori_grid[i][j] = [sum2, sum5]\\n          \\n      for j in range(n):\\n        sum2, sum5 = 0, 0\\n        for i in range(m):\\n          sum2 += new_grid[i][j][0]\\n          sum5 += new_grid[i][j][1]\\n          verti_grid[i][j] = [sum2, sum5]\\n        \\n      res = -sys.maxsize\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          start2, start5 = hori_grid[i][j][0], hori_grid[i][j][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n\\n      for i in range(m):\\n        for j in range(n):\\n          if j != 0:\\n            start2, start5 = hori_grid[i][-1][0] - hori_grid[i][j-1][0], \\\\\\n                             hori_grid[i][-1][1] - hori_grid[i][j-1][1]\\n          else:\\n            start2, start5 = hori_grid[i][-1][0], hori_grid[i][-1][1]\\n          start2_up, start5_up = start2 + verti_grid[i][j][0] - new_grid[i][j][0], \\\\\\n                                 start5 + verti_grid[i][j][1] - new_grid[i][j][1]\\n          start2_down, start5_down = start2 + verti_grid[-1][j][0] - verti_grid[i][j][0], \\\\\\n                                     start5 + verti_grid[-1][j][1] - verti_grid[i][j][1]\\n          res = max([min(start2_up, start5_up), min(start2_down, start5_down), res])\\n          \\n      return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970204,
                "title": "o-1-space-implementation-except-stack-space",
                "content": "I am spawning 3-directional (it is interesting to see that they need not be 4-directional i.e; go up, down, left, and right, three directions are sufficient for spanning the array) crawlers at promising (cells which are already multiples of either 2 or 5) roots.\\n\\nUsing marking-unmarking technique to avoid a visited array.\\n```\\n\\tvoid rec(vector<vector<int> >& grid, int& ans, int num_twos, int num_fives, int i, int j, bool turned, int dir)\\n    {\\n        if(grid[i][j]==-1)\\n            return;\\n        // there is a more optimal way but it won\\'t matter here since max(grid[i][j]) is 1000. so that\\'s a max of 9 iterations for twos and 4 for fives in the following\\n        int twos = 0, fives = 0, temp = grid[i][j], n = grid[i][j], num_zeroes;\\n        while(!(n&1))\\n        {\\n            ++twos;\\n            n /= 2;\\n        }\\n        num_twos += twos;\\n        n = grid[i][j];\\n        while(n%5==0)\\n        {\\n            ++fives;\\n            n /= 5;\\n        }\\n        num_fives += fives;\\n        grid[i][j] = -1;\\n        num_zeroes = (num_twos<num_fives) ? num_twos : num_fives;\\n        if(ans<num_zeroes)\\n            ans = num_zeroes;\\n        // can proceed virgin\\n        if(dir==1 && i+1<grid.size())\\n            rec(grid, ans, num_twos, num_fives, i+1, j, turned, 1);\\n        else if(dir==2 && i-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i-1, j, turned, 2);\\n        //else if(dir==3 && j+1<grid[0].size())\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, turned, 3);\\n        else if(dir==4 && j-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i, j-1, turned, 4);\\n        // or pivot\\n        if(!turned)\\n        {\\n            if(dir==1 || dir==2)\\n            {\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, true, 3);\\n            if(j-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i, j-1, true, 4);\\n            }\\n            else\\n            {\\n            if(i+1<grid.size())\\n                rec(grid, ans, num_twos, num_fives, i+1, j, true, 1);\\n            if(i-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i-1, j, true, 2);\\n            }\\n        }\\n        grid[i][j] = temp;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(!(grid[i][j]&1) || grid[i][j]%5==0) // only non empty roots\\n                {\\n                rec(grid, ans, 0, 0, i, j, false, 1); // i+1\\n                rec(grid, ans, 0, 0, i, j, false, 2); // i-1\\n                //rec(grid, ans, 0, 0, i, j, false, 3); // j+1\\n                rec(grid, ans, 0, 0, i, j, false, 4); // j-1   \\n                }\\n            }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\tvoid rec(vector<vector<int> >& grid, int& ans, int num_twos, int num_fives, int i, int j, bool turned, int dir)\\n    {\\n        if(grid[i][j]==-1)\\n            return;\\n        // there is a more optimal way but it won\\'t matter here since max(grid[i][j]) is 1000. so that\\'s a max of 9 iterations for twos and 4 for fives in the following\\n        int twos = 0, fives = 0, temp = grid[i][j], n = grid[i][j], num_zeroes;\\n        while(!(n&1))\\n        {\\n            ++twos;\\n            n /= 2;\\n        }\\n        num_twos += twos;\\n        n = grid[i][j];\\n        while(n%5==0)\\n        {\\n            ++fives;\\n            n /= 5;\\n        }\\n        num_fives += fives;\\n        grid[i][j] = -1;\\n        num_zeroes = (num_twos<num_fives) ? num_twos : num_fives;\\n        if(ans<num_zeroes)\\n            ans = num_zeroes;\\n        // can proceed virgin\\n        if(dir==1 && i+1<grid.size())\\n            rec(grid, ans, num_twos, num_fives, i+1, j, turned, 1);\\n        else if(dir==2 && i-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i-1, j, turned, 2);\\n        //else if(dir==3 && j+1<grid[0].size())\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, turned, 3);\\n        else if(dir==4 && j-1>=0)\\n            rec(grid, ans, num_twos, num_fives, i, j-1, turned, 4);\\n        // or pivot\\n        if(!turned)\\n        {\\n            if(dir==1 || dir==2)\\n            {\\n            //rec(grid, ans, num_twos, num_fives, i, j+1, true, 3);\\n            if(j-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i, j-1, true, 4);\\n            }\\n            else\\n            {\\n            if(i+1<grid.size())\\n                rec(grid, ans, num_twos, num_fives, i+1, j, true, 1);\\n            if(i-1>=0)\\n                rec(grid, ans, num_twos, num_fives, i-1, j, true, 2);\\n            }\\n        }\\n        grid[i][j] = temp;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); ++i)\\n            for(int j=0; j<grid[0].size(); ++j)\\n            {\\n                if(!(grid[i][j]&1) || grid[i][j]%5==0) // only non empty roots\\n                {\\n                rec(grid, ans, 0, 0, i, j, false, 1); // i+1\\n                rec(grid, ans, 0, 0, i, j, false, 2); // i-1\\n                //rec(grid, ans, 0, 0, i, j, false, 3); // j+1\\n                rec(grid, ans, 0, 0, i, j, false, 4); // j-1   \\n                }\\n            }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967920,
                "title": "c-2245-maximum-trailing-zeros-in-a-cornered-path",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<vector<int>> f2(m, vector<int>(n)), f5(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                for (int x = grid[i][j]; x % 2 == 0; x /= 2) ++f2[i][j]; \\n                for (int x = grid[i][j]; x % 5 == 0; x /= 5) ++f5[i][j]; \\n            }\\n        vector<vector<array<int, 2>>> h(m+1, vector<array<int, 2>>(n+1)), v = h;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]; \\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]; \\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]; \\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]; \\n            }\\n        int ans = 0; \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vector<int> hh = {h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]}, vv = {v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; \\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j])); \\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1])); \\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1])); \\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j])); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(); \\n        vector<vector<int>> f2(m, vector<int>(n)), f5(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                for (int x = grid[i][j]; x % 2 == 0; x /= 2) ++f2[i][j]; \\n                for (int x = grid[i][j]; x % 5 == 0; x /= 5) ++f5[i][j]; \\n            }\\n        vector<vector<array<int, 2>>> h(m+1, vector<array<int, 2>>(n+1)), v = h;\\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) {\\n                h[i][j+1][0] = h[i][j][0] + f2[i][j]; \\n                h[i][j+1][1] = h[i][j][1] + f5[i][j]; \\n                v[i+1][j][0] = v[i][j][0] + f2[i][j]; \\n                v[i+1][j][1] = v[i][j][1] + f5[i][j]; \\n            }\\n        int ans = 0; \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                vector<int> hh = {h[i][n][0] - h[i][j][0], h[i][n][1] - h[i][j][1]}, vv = {v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; \\n                ans = max(ans, min(h[i][j][0]+v[i][j][0]+f2[i][j], h[i][j][1]+v[i][j][1]+f5[i][j])); \\n                ans = max(ans, min(hh[0]+v[i][j][0], hh[1]+v[i][j][1])); \\n                ans = max(ans, min(h[i][j][0]+vv[0], h[i][j][1]+vv[1])); \\n                ans = max(ans, min(hh[0]+vv[0]-f2[i][j], hh[1]+vv[1]-f5[i][j])); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965177,
                "title": "c-factor-2-and-5-time-o-nm-space-o-m",
                "content": "```\\nclass Solution {\\n    void update(int gridv, vector<int>& c)\\n    {\\n        while (gridv != 0 && gridv % 5 == 0) {c[0]++; gridv/=5;}\\n        while (gridv != 0 && gridv % 2 == 0) {c[1]++; gridv/=2;}\\n    }\\n    \\n    int calculate(vector<vector<int>>& grid, bool updown)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        int i=updown?0:n-1;\\n        int ans = 0;\\n        vector<vector<int>> count(m,vector<int>(2,0));//count of 2, count of  5\\n        while(i>=0 && i <n)\\n        {\\n            vector<int> hcount = {0,0};\\n            for(int j=0; j<m; j++)\\n            {\\n                update(grid[i][j], count[j]);\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            hcount[0] = hcount[1] = 0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            i+= updown?1:-1;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        return max(calculate(grid, true), calculate(grid, false));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void update(int gridv, vector<int>& c)\\n    {\\n        while (gridv != 0 && gridv % 5 == 0) {c[0]++; gridv/=5;}\\n        while (gridv != 0 && gridv % 2 == 0) {c[1]++; gridv/=2;}\\n    }\\n    \\n    int calculate(vector<vector<int>>& grid, bool updown)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        int i=updown?0:n-1;\\n        int ans = 0;\\n        vector<vector<int>> count(m,vector<int>(2,0));//count of 2, count of  5\\n        while(i>=0 && i <n)\\n        {\\n            vector<int> hcount = {0,0};\\n            for(int j=0; j<m; j++)\\n            {\\n                update(grid[i][j], count[j]);\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            hcount[0] = hcount[1] = 0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                ans = max(ans, min(count[j][0] + hcount[0], count[j][1] + hcount[1]));\\n                update(grid[i][j], hcount);\\n            }\\n            i+= updown?1:-1;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        return max(calculate(grid, true), calculate(grid, false));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962118,
                "title": "java-prefix-sums-of-10-5-2",
                "content": "Yes, you can do away with 5 and 2 only.\\n```\\nclass Solution {\\n    static int R= 0, L= 1, D= 2, U= 3; // grid iteration direction index\\n    static int Z= 0, F= 1, E= 2;       // count of zeros, fives and even numbers\\n    static int[] EMPTY= {0, 0, 0};     // empty array of factor counts [Z, F, E]\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        int m= grid.length, n= grid[0].length;\\n        \\n        // calculate 10,5,2 factors for each number in the grid\\n        int[][][] fs= new int[m][n][3];\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                fact(fs[i][j], grid[i][j]);\\n        \\n        // calculate ps matrices of factors in all directions\\n        int[][][][] ps= new int[m][n][4][3];       \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++)\\n                add(ps[i][j][R], fs[i][j], j==0 ? EMPTY : ps[i][j-1][R]);\\n            for(int j=n-1; j>-1; j--)\\n                add(ps[i][j][L], fs[i][j], j==n-1 ? EMPTY : ps[i][j+1][L]);\\n        }\\n        for(int j=0; j<n; j++){\\n            for(int i=0; i<m; i++)\\n                add(ps[i][j][D], fs[i][j], i==0 ? EMPTY : ps[i-1][j][D]);\\n            for(int i=m-1; i>-1; i--)\\n                add(ps[i][j][U], fs[i][j], i==m-1 ? EMPTY : ps[i+1][j][U]);     \\n        }\\n\\n        // use ps matrices to calculate answer \\n        int ans= 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                ans= Math.max(ans, calc(ps[i][j][L], i==m-1 ? EMPTY : ps[i+1][j][U]));\\n                ans= Math.max(ans, calc(ps[i][j][L], i==0 ? EMPTY : ps[i-1][j][D]));\\n                ans= Math.max(ans, calc(ps[i][j][R], i==m-1 ? EMPTY : ps[i+1][j][U]));\\n                ans= Math.max(ans, calc(ps[i][j][R], i==0 ? EMPTY : ps[i-1][j][D]));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void fact(int[] fs, int val){\\n        while(val!=0 && val%10==0){fs[Z]++; val/=10;}\\n        while(val!=0 && val%5==0){fs[F]++; val/=5;} \\n        while(val!=0 && val%2==0){fs[E]++; val/=2;}\\n    }\\n    \\n    void add(int[] ans, int[] a, int[] b){\\n        for(int i=0; i<3; i++) ans[i]= a[i]+b[i];\\n    }\\n    \\n    int calc(int[] a, int[] b){\\n        return a[Z]+b[Z] + Math.min(a[F]+b[F], a[E]+b[E]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int R= 0, L= 1, D= 2, U= 3; // grid iteration direction index\\n    static int Z= 0, F= 1, E= 2;       // count of zeros, fives and even numbers\\n    static int[] EMPTY= {0, 0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1961568,
                "title": "prefix-sum-vertically-and-horizontally-of-factors-2-and-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<pair<int,int>>> ngrid(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> vert(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> hor(n,vector<pair<int,int>>(m,{0,0}));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                auto x = func(grid[i][j]);\\n                ngrid[i][j].first = x.first;\\n                ngrid[i][j].second = x.second;\\n            }\\n        }\\n        \\n        for(int j=0; j<m; j++){\\n            vert[0][j] = ngrid[0][j]; \\n            for(int i=1; i<n; i++){\\n                vert[i][j].first = vert[i-1][j].first + ngrid[i][j].first;\\n                vert[i][j].second = vert[i-1][j].second + ngrid[i][j].second;\\n                \\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            hor[i][0] = ngrid[i][0]; \\n            for(int j=1; j<m; j++){\\n                hor[i][j].first = hor[i][j-1].first+ngrid[i][j].first;\\n                hor[i][j].second = hor[i][j-1].second+ngrid[i][j].second;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                vector<pair<int,int> > v(4);\\n                \\n                v[0].first = (i-1 >= 0 ?  vert[i-1][j].first : 0);\\n                v[0].second = (i-1 >= 0 ?  vert[i-1][j].second : 0);\\n                \\n                v[1].first = ( vert[n-1][j].first - vert[i][j].first);\\n                v[1].second = ( vert[n-1][j].second - vert[i][j].second);\\n                \\n                v[2].first = (j-1 >= 0 ?  hor[i][j-1].first : 0);\\n                v[2].second = (j-1 >= 0 ?  hor[i][j-1].second : 0);\\n                \\n                v[3].first = ( hor[i][m-1].first - hor[i][j].first);\\n                v[3].second = ( hor[i][m-1].second - hor[i][j].second);                \\n                \\n                int cmax = 0;\\n                \\n                for(int k=0; k<4; k++){\\n                    for(int l = k+1;  l<4; l++){\\n                        int sum = min(v[k].first+v[l].first+ngrid[i][j].first, v[k].second+v[l].second+ngrid[i][j].second);\\n                        \\n                        cmax = max(cmax, sum);\\n                    }\\n                }\\n                \\n                ans = max(ans,cmax);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    pair<int,int> func(int x){\\n        int two = 0,five=0;\\n        while(x>0 && x%2 == 0){\\n            two++;\\n            x = x/2;\\n        }\\n        \\n        while(x>0 && x%5 == 0){\\n            five++;\\n            x = x/5;\\n        }\\n        \\n        return {two,five};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<pair<int,int>>> ngrid(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> vert(n,vector<pair<int,int>>(m,{0,0}));\\n        vector<vector<pair<int,int>>> hor(n,vector<pair<int,int>>(m,{0,0}));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                auto x = func(grid[i][j]);\\n                ngrid[i][j].first = x.first;\\n                ngrid[i][j].second = x.second;\\n            }\\n        }\\n        \\n        for(int j=0; j<m; j++){\\n            vert[0][j] = ngrid[0][j]; \\n            for(int i=1; i<n; i++){\\n                vert[i][j].first = vert[i-1][j].first + ngrid[i][j].first;\\n                vert[i][j].second = vert[i-1][j].second + ngrid[i][j].second;\\n                \\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            hor[i][0] = ngrid[i][0]; \\n            for(int j=1; j<m; j++){\\n                hor[i][j].first = hor[i][j-1].first+ngrid[i][j].first;\\n                hor[i][j].second = hor[i][j-1].second+ngrid[i][j].second;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                vector<pair<int,int> > v(4);\\n                \\n                v[0].first = (i-1 >= 0 ?  vert[i-1][j].first : 0);\\n                v[0].second = (i-1 >= 0 ?  vert[i-1][j].second : 0);\\n                \\n                v[1].first = ( vert[n-1][j].first - vert[i][j].first);\\n                v[1].second = ( vert[n-1][j].second - vert[i][j].second);\\n                \\n                v[2].first = (j-1 >= 0 ?  hor[i][j-1].first : 0);\\n                v[2].second = (j-1 >= 0 ?  hor[i][j-1].second : 0);\\n                \\n                v[3].first = ( hor[i][m-1].first - hor[i][j].first);\\n                v[3].second = ( hor[i][m-1].second - hor[i][j].second);                \\n                \\n                int cmax = 0;\\n                \\n                for(int k=0; k<4; k++){\\n                    for(int l = k+1;  l<4; l++){\\n                        int sum = min(v[k].first+v[l].first+ngrid[i][j].first, v[k].second+v[l].second+ngrid[i][j].second);\\n                        \\n                        cmax = max(cmax, sum);\\n                    }\\n                }\\n                \\n                ans = max(ans,cmax);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    pair<int,int> func(int x){\\n        int two = 0,five=0;\\n        while(x>0 && x%2 == 0){\\n            two++;\\n            x = x/2;\\n        }\\n        \\n        while(x>0 && x%5 == 0){\\n            five++;\\n            x = x/5;\\n        }\\n        \\n        return {two,five};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961220,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n       \\n     int col=g[0].size();\\n     int row=g.size();   \\n     int a[row][col],b[row][col];  \\n     for(int i=0;i<row;i++)\\n     {\\n         int cnt5=0,cnt2=0;\\n         for(int j=0;j<col;j++)\\n         {\\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n            a[i][j]=cnt5;\\n            b[i][j]=cnt2; \\n          \\n         }\\n         \\n     }\\n        \\n     \\n     int maxi=0;   \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=0;i<row;i++)\\n        {\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n            int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n            cout<<a[i][col-1];\\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n           \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);  \\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n          \\n                      \\n        }\\n         \\n     }   \\n        \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=row-1;i>=0;i--)\\n        {\\n            int x=g[i][j];\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n             int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n          \\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n            \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n               \\n            \\n        }\\n\\n     }\\n         \\n       return maxi; \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n       \\n     int col=g[0].size();\\n     int row=g.size();   \\n     int a[row][col],b[row][col];  \\n     for(int i=0;i<row;i++)\\n     {\\n         int cnt5=0,cnt2=0;\\n         for(int j=0;j<col;j++)\\n         {\\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n            a[i][j]=cnt5;\\n            b[i][j]=cnt2; \\n          \\n         }\\n         \\n     }\\n        \\n     \\n     int maxi=0;   \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=0;i<row;i++)\\n        {\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n            int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n            cout<<a[i][col-1];\\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n           \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);  \\n           \\n            int x=g[i][j];\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n          \\n                      \\n        }\\n         \\n     }   \\n        \\n     for(int j=0;j<col;j++)\\n     {\\n        int cnt5=0,cnt2=0; \\n        for(int i=row-1;i>=0;i--)\\n        {\\n            int x=g[i][j];\\n            int val5=cnt5+a[i][j];\\n            int val2=cnt2+b[i][j];\\n             int rval5=cnt5+a[i][col-1]-(j==0?0:a[i][j-1]);\\n            int rval2=cnt2+b[i][col-1]-(j==0?0:b[i][j-1]);  \\n          \\n            int mini1=min(val2,val5);\\n            int mini2=min(rval2,rval5);\\n            \\n            int maxis=max(mini1,mini2);\\n            maxi=max(maxi,maxis);\\n            while(x%5==0)\\n            {\\n                cnt5++;\\n                x/=5;\\n            }\\n            while(x%2==0)\\n            {\\n                cnt2++;\\n                x/=2;\\n            }\\n               \\n            \\n        }\\n\\n     }\\n         \\n       return maxi; \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1961106,
                "title": "c-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<pair<int,int>>>prefix(m,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                int cnt1=0,cnt2=0;\\n                while(grid[i][j]%2==0)cnt1++,grid[i][j]/=2;\\n                while(grid[i][j]%5==0)cnt2++,grid[i][j]/=5;\\n                prefix[i][j].first=cnt1;\\n                prefix[i][j].second=cnt2;\\n            }\\n        auto record=prefix;\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n            {\\n                prefix[i][j].first+=prefix[i][j-1].first;\\n                prefix[i][j].second+=prefix[i][j-1].second;\\n            }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<pair<int,int>>>prefix(m,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                int cnt1=0,cnt2=0;\\n                while(grid[i][j]%2==0)cnt1++,grid[i][j]/=2;\\n                while(grid[i][j]%5==0)cnt2++,grid[i][j]/=5;\\n                prefix[i][j].first=cnt1;\\n                prefix[i][j].second=cnt2;\\n            }\\n        auto record=prefix;\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n            {\\n                prefix[i][j].first+=prefix[i][j-1].first;\\n                prefix[i][j].second+=prefix[i][j-1].second;\\n            }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int v1=0,v2=0;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                ans=max(ans,min(v1+prefix[j][i].first,v2+prefix[j][i].second));\\n                int v3=prefix[j][n-1].first,v4=prefix[j][n-1].second;\\n                if(i-1>=0)v3-=prefix[j][i-1].first,v4-=prefix[j][i-1].second;\\n                ans=max(ans,min(v1+v3,v2+v4));\\n                v1+=record[j][i].first,v2+=record[j][i].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960091,
                "title": "c-100-fast-easy-approach",
                "content": "1. calculate powers of 2 and 5 in factors of each grid[i][j] item in a vectorof pairs of int \\n2. make 2 matrices v and h, v stores vertical prefix sum (for each column seprately)of values of fac and h stores horizontal prefix sum (for each row).\\n3. now in nother loop calculate ans using h and v\\n```\\n#define fo(i,s,e) for(int i=s;i<=e;i++)\\npair<int,int> operator+(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first+b.first,a.second+b.second);\\n  }  \\npair<int,int> operator-(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first-b.first,a.second-b.second);\\n  }  \\nint mx(pair<int,int>a){\\n      return min(a.first,a.second);\\n}\\nclass Solution {\\n    pair<int,int>fact25(int val){\\n        int cnt=0,cnt2=0;\\n        while(val!=0&&val%2==0)\\n        {cnt++;val/=2;}\\n        \\n        while(val!=0&&val%5==0){\\n            cnt2++;val/=5;\\n        }\\n        return make_pair(cnt,cnt2);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>>fac(m+1,vector<pair<int,int>>(n+1,make_pair(0,0))),h,v;\\n        v=h=fac;\\n        fac.clear();\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                auto x=fact25(grid[i-1][j-1]);\\n                v[i][j]=v[i-1][j]+x;\\n                h[i][j]=h[i][j-1]+x;\\n            }\\n        }\\n        \\n        int ans=0;\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                pair<int,int> hl,hr,vu,vd;\\n                hl=h[i][j];\\n                hr=h[i][n]-h[i][j-1];\\n                vu=v[i-1][j];\\n                vd=v[m][j]-v[i][j];\\n                ans=max({ans,mx(vu+hl),mx(vu+hr),mx(vd+hl),mx(vd+hr)});\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define fo(i,s,e) for(int i=s;i<=e;i++)\\npair<int,int> operator+(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first+b.first,a.second+b.second);\\n  }  \\npair<int,int> operator-(pair<int,int>a,pair<int,int>b){\\n      return make_pair(a.first-b.first,a.second-b.second);\\n  }  \\nint mx(pair<int,int>a){\\n      return min(a.first,a.second);\\n}\\nclass Solution {\\n    pair<int,int>fact25(int val){\\n        int cnt=0,cnt2=0;\\n        while(val!=0&&val%2==0)\\n        {cnt++;val/=2;}\\n        \\n        while(val!=0&&val%5==0){\\n            cnt2++;val/=5;\\n        }\\n        return make_pair(cnt,cnt2);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<pair<int,int>>>fac(m+1,vector<pair<int,int>>(n+1,make_pair(0,0))),h,v;\\n        v=h=fac;\\n        fac.clear();\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                auto x=fact25(grid[i-1][j-1]);\\n                v[i][j]=v[i-1][j]+x;\\n                h[i][j]=h[i][j-1]+x;\\n            }\\n        }\\n        \\n        int ans=0;\\n        fo(i,1,m){\\n            fo(j,1,n){\\n                pair<int,int> hl,hr,vu,vd;\\n                hl=h[i][j];\\n                hr=h[i][n]-h[i][j-1];\\n                vu=v[i-1][j];\\n                vd=v[m][j]-v[i][j];\\n                ans=max({ans,mx(vu+hl),mx(vu+hr),mx(vd+hl),mx(vd+hr)});\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960086,
                "title": "c-100-faster-557-ms-100-less-memory-140-6-mb",
                "content": "The hints 1-4 basically summarized what this code does.\\n\\n```cpp\\nstruct s {\\n    int five_cnt;\\n    int two_cnt;\\n    s(int in_f, int in_t) {\\n        five_cnt = in_f;\\n        two_cnt = in_t;\\n    }\\n    s() {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<s>> C, VC, HC;\\n    int tmpFive, tmpTwo;\\n    \\n    void setT(int in_val) {\\n        tmpFive = 0;\\n        tmpTwo = 0;\\n        if (in_val == 0) {\\n            return;\\n        }\\n        while ((in_val % 5) == 0) {\\n            tmpFive++;\\n            in_val /= 5;\\n        }\\n        while ((in_val % 2) == 0) {\\n            tmpTwo++;\\n            in_val /= 2;\\n        }\\n        return;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        C.clear();\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        for (int i = 0; i < row; i++) {\\n            vector<s> tmp;\\n            C.push_back(tmp);\\n            for (int j = 0; j < col; j++) {\\n                setT(grid[i][j]);\\n                C[i].push_back(s(tmpFive, tmpTwo));\\n            }\\n        }\\n        grid.clear();\\n        VC = C;\\n        HC = C;\\n        C.clear();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                HC[i][j].five_cnt += HC[i][j - 1].five_cnt;\\n                HC[i][j].two_cnt += HC[i][j - 1].two_cnt;\\n            }\\n        }\\n        for (int j = 0; j < col; j++) {\\n            for (int i = 1; i < row; i++) {\\n                VC[i][j].five_cnt += VC[i - 1][j].five_cnt;\\n                VC[i][j].two_cnt += VC[i - 1][j].two_cnt;\\n            }\\n        }\\n        int resmaxcnt = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // vertical, then left.\\n                s tmp = VC[i][j];\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt; // correct here.\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                // next, vertical, right.\\n                tmp = VC[i][j];\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt; // correct\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                // next, bottom - left.\\n                // always includes middle in the vertical part.\\n                tmp = VC[row - 1][j];\\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt; // modified.\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt;\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                tmp = VC[row - 1][j]; \\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt;\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt;\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n            }\\n        }\\n        return resmaxcnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct s {\\n    int five_cnt;\\n    int two_cnt;\\n    s(int in_f, int in_t) {\\n        five_cnt = in_f;\\n        two_cnt = in_t;\\n    }\\n    s() {}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<s>> C, VC, HC;\\n    int tmpFive, tmpTwo;\\n    \\n    void setT(int in_val) {\\n        tmpFive = 0;\\n        tmpTwo = 0;\\n        if (in_val == 0) {\\n            return;\\n        }\\n        while ((in_val % 5) == 0) {\\n            tmpFive++;\\n            in_val /= 5;\\n        }\\n        while ((in_val % 2) == 0) {\\n            tmpTwo++;\\n            in_val /= 2;\\n        }\\n        return;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        C.clear();\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        \\n        for (int i = 0; i < row; i++) {\\n            vector<s> tmp;\\n            C.push_back(tmp);\\n            for (int j = 0; j < col; j++) {\\n                setT(grid[i][j]);\\n                C[i].push_back(s(tmpFive, tmpTwo));\\n            }\\n        }\\n        grid.clear();\\n        VC = C;\\n        HC = C;\\n        C.clear();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 1; j < col; j++) {\\n                HC[i][j].five_cnt += HC[i][j - 1].five_cnt;\\n                HC[i][j].two_cnt += HC[i][j - 1].two_cnt;\\n            }\\n        }\\n        for (int j = 0; j < col; j++) {\\n            for (int i = 1; i < row; i++) {\\n                VC[i][j].five_cnt += VC[i - 1][j].five_cnt;\\n                VC[i][j].two_cnt += VC[i - 1][j].two_cnt;\\n            }\\n        }\\n        int resmaxcnt = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // vertical, then left.\\n                s tmp = VC[i][j];\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt; // correct here.\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                // next, vertical, right.\\n                tmp = VC[i][j];\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt; // correct\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                // next, bottom - left.\\n                // always includes middle in the vertical part.\\n                tmp = VC[row - 1][j];\\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt; // modified.\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                if (j - 1 >= 0) {\\n                    tmp.five_cnt += HC[i][j - 1].five_cnt;\\n                    tmp.two_cnt += HC[i][j - 1].two_cnt;\\n                }\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n                \\n                tmp = VC[row - 1][j]; \\n                if (i - 1 >= 0) {\\n                    tmp.five_cnt = VC[row - 1][j].five_cnt - VC[i - 1][j].five_cnt;\\n                    tmp.two_cnt = VC[row - 1][j].two_cnt - VC[i - 1][j].two_cnt;\\n                }\\n                tmp.five_cnt += HC[i][col - 1].five_cnt - HC[i][j].five_cnt;\\n                tmp.two_cnt += HC[i][col - 1].two_cnt - HC[i][j].two_cnt;\\n                resmaxcnt = max(resmaxcnt, min(tmp.five_cnt, tmp.two_cnt));\\n            }\\n        }\\n        return resmaxcnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959952,
                "title": "c-prefix-sum-of-factors-2-and-5-used-3d-array-to-make-implementation-easier",
                "content": "```\\n\\n#define endl (\"\\\\n\")\\n#define pi (3.141592653589)\\n#define mod 1e9+7\\n#define ll long long\\n#define float double\\n#define pb push_back\\n#define pp pair<ll, ll>\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) cc.begin(), c.end()\\n#define mini(a, b, c) min(c, min(a, b))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n#define rep1(i,n) for(int i=1;i<n;i++)\\n\\nclass Solution {\\npublic:\\n    pp solve(ll ele){\\n        int temp = ele;\\n        int twos = 0, fives = 0;\\n        while(temp%2==0){\\n            twos++;\\n            temp/=2;\\n        }\\n        temp = ele;\\n        while(temp%5==0){\\n            fives++;\\n            temp/=5;\\n        }\\n        return {twos, fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<pp>>> dp(n, vector<vector<pp>>(m, vector<pp>(4)));\\n        rep(i, n){\\n            vector<pp> store(m);  //{2, 5}\\n            rep(j, m){\\n                pp it = solve(grid[i][j]);\\n                if(j == 0){\\n                    store[j] = it;\\n                }else{\\n                    store[j] = {it.first+store[j-1].first, it.second+store[j-1].second};\\n                }\\n            }\\n            int t_2 = store[m-1].first, t_5 = store[m-1].second;\\n            rep(j, m){\\n                dp[i][j][0].first = store[j].first;\\n                dp[i][j][0].second = store[j].second;\\n                dp[i][j][1].first = t_2 - (j >= 1 ? store[j-1].first:0);\\n                dp[i][j][1].second = t_5 - (j >= 1 ? store[j-1].second:0);\\n            }\\n        }\\n\\n        rep(j, m){\\n            vector<pp> store(n);  //{2, 5}\\n            rep(i, n){\\n                pp it = solve(grid[i][j]);\\n                if(i == 0){\\n                    store[i] = it;\\n                }else{\\n                    store[i] = {it.first+store[i-1].first, it.second+store[i-1].second};\\n                }\\n            }\\n            int t_2 = store[n-1].first, t_5 = store[n-1].second;\\n            rep(i, n){\\n                dp[i][j][2].first = store[i].first;\\n                dp[i][j][2].second = store[i].second;\\n                dp[i][j][3].first = t_2 - (i >= 1 ? store[i-1].first:0);\\n                dp[i][j][3].second = t_5 - (i >= 1 ? store[i-1].second:0);\\n            }\\n        }\\n        \\n        int res = 0;\\n        rep(i, n){\\n            rep(j, m){\\n                int up_max = min(dp[i][j][2].first, dp[i][j][2].second);\\n                int down_max = min(dp[i][j][3].first, dp[i][j][3].second);\\n                \\n                int left_max = min(dp[i][j][0].first, dp[i][j][0].second);\\n                int right_max = min(dp[i][j][1].first, dp[i][j][1].second);\\n                \\n                pp it = solve(grid[i][j]);\\n                //UP -> RIGHT\\n                ll twos = dp[i][j][2].first+dp[i][j][1].first-it.first;\\n                ll fives = dp[i][j][2].second+dp[i][j][1].second-it.second;\\n                \\n                ll tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //UP -> LEFT\\n                twos = dp[i][j][2].first+dp[i][j][0].first-it.first;\\n                fives = dp[i][j][2].second+dp[i][j][0].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //LEFT -> DOWN\\n                twos = dp[i][j][0].first+dp[i][j][3].first-it.first;\\n                fives = dp[i][j][0].second+dp[i][j][3].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //DOWN -> RIGHT\\n                twos = dp[i][j][3].first+dp[i][j][1].first-it.first;\\n                fives = dp[i][j][3].second+dp[i][j][1].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n\\n#define endl (\"\\\\n\")\\n#define pi (3.141592653589)\\n#define mod 1e9+7\\n#define ll long long\\n#define float double\\n#define pb push_back\\n#define pp pair<ll, ll>\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) cc.begin(), c.end()\\n#define mini(a, b, c) min(c, min(a, b))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\n#define rep1(i,n) for(int i=1;i<n;i++)\\n\\nclass Solution {\\npublic:\\n    pp solve(ll ele){\\n        int temp = ele;\\n        int twos = 0, fives = 0;\\n        while(temp%2==0){\\n            twos++;\\n            temp/=2;\\n        }\\n        temp = ele;\\n        while(temp%5==0){\\n            fives++;\\n            temp/=5;\\n        }\\n        return {twos, fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<vector<pp>>> dp(n, vector<vector<pp>>(m, vector<pp>(4)));\\n        rep(i, n){\\n            vector<pp> store(m);  //{2, 5}\\n            rep(j, m){\\n                pp it = solve(grid[i][j]);\\n                if(j == 0){\\n                    store[j] = it;\\n                }else{\\n                    store[j] = {it.first+store[j-1].first, it.second+store[j-1].second};\\n                }\\n            }\\n            int t_2 = store[m-1].first, t_5 = store[m-1].second;\\n            rep(j, m){\\n                dp[i][j][0].first = store[j].first;\\n                dp[i][j][0].second = store[j].second;\\n                dp[i][j][1].first = t_2 - (j >= 1 ? store[j-1].first:0);\\n                dp[i][j][1].second = t_5 - (j >= 1 ? store[j-1].second:0);\\n            }\\n        }\\n\\n        rep(j, m){\\n            vector<pp> store(n);  //{2, 5}\\n            rep(i, n){\\n                pp it = solve(grid[i][j]);\\n                if(i == 0){\\n                    store[i] = it;\\n                }else{\\n                    store[i] = {it.first+store[i-1].first, it.second+store[i-1].second};\\n                }\\n            }\\n            int t_2 = store[n-1].first, t_5 = store[n-1].second;\\n            rep(i, n){\\n                dp[i][j][2].first = store[i].first;\\n                dp[i][j][2].second = store[i].second;\\n                dp[i][j][3].first = t_2 - (i >= 1 ? store[i-1].first:0);\\n                dp[i][j][3].second = t_5 - (i >= 1 ? store[i-1].second:0);\\n            }\\n        }\\n        \\n        int res = 0;\\n        rep(i, n){\\n            rep(j, m){\\n                int up_max = min(dp[i][j][2].first, dp[i][j][2].second);\\n                int down_max = min(dp[i][j][3].first, dp[i][j][3].second);\\n                \\n                int left_max = min(dp[i][j][0].first, dp[i][j][0].second);\\n                int right_max = min(dp[i][j][1].first, dp[i][j][1].second);\\n                \\n                pp it = solve(grid[i][j]);\\n                //UP -> RIGHT\\n                ll twos = dp[i][j][2].first+dp[i][j][1].first-it.first;\\n                ll fives = dp[i][j][2].second+dp[i][j][1].second-it.second;\\n                \\n                ll tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //UP -> LEFT\\n                twos = dp[i][j][2].first+dp[i][j][0].first-it.first;\\n                fives = dp[i][j][2].second+dp[i][j][0].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //LEFT -> DOWN\\n                twos = dp[i][j][0].first+dp[i][j][3].first-it.first;\\n                fives = dp[i][j][0].second+dp[i][j][3].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n                \\n                //DOWN -> RIGHT\\n                twos = dp[i][j][3].first+dp[i][j][1].first-it.first;\\n                fives = dp[i][j][3].second+dp[i][j][1].second-it.second;\\n                \\n                tu = min(twos, fives);\\n                res = res < tu ? tu:res;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959923,
                "title": "python-iterative-prefix-sum-factor-caching-beats-100-2601-ms",
                "content": "```\\nclass Solution(object):\\n    def maxTrailingZeros(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        factors = {}\\n        for val in range(1, 1001):\\n            num = val\\n            cnt2, cnt5 = 0, 0\\n            while num > 0 and num % 2 == 0: \\n                cnt2 += 1\\n                num = num / 2\\n            while num > 0 and num % 5 == 0: \\n                cnt5 += 1\\n                num = num / 5\\n            factors[val] = (cnt2, cnt5)\\n        row2, row5, col2, col5 = [], [], [], []\\n        for i in range(m + 1): \\n            row2.append([0]*(n + 1))\\n            col2.append([0]*(n + 1))\\n            row5.append([0]*(n + 1))\\n            col5.append([0]*(n + 1))\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                row2[i][j] = cnt2 + row2[i][j - 1]\\n                row5[i][j] = cnt5 + row5[i][j - 1]\\n                col2[i][j] = cnt2 + col2[i - 1][j]\\n                col5[i][j] = cnt5 + col5[i - 1][j]\\n        res = 0\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                top2, top5 = col2[i-1][j], col5[i-1][j]\\n                bottom2, bottom5 = col2[m][j] - col2[i][j], col5[m][j] - col5[i][j]\\n                left2, left5 = row2[i][j-1], row5[i][j-1]\\n                right2, right5 = row2[i][n] - row2[i][j], row5[i][n] - row5[i][j]\\n                res = max(res, min(top2 + left2 + cnt2, top5 + left5 + cnt5), min(top2 + right2 + cnt2, top5 + right5 + cnt5), min(bottom2 + left2 + cnt2, bottom5 + left5 + cnt5), min(bottom2 + right2 + cnt2, bottom5 + right5 + cnt5))\\n        return res\\n                \\n                \\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxTrailingZeros(self, grid):\\n        m = len(grid)\\n        n = len(grid[0])\\n        factors = {}\\n        for val in range(1, 1001):\\n            num = val\\n            cnt2, cnt5 = 0, 0\\n            while num > 0 and num % 2 == 0: \\n                cnt2 += 1\\n                num = num / 2\\n            while num > 0 and num % 5 == 0: \\n                cnt5 += 1\\n                num = num / 5\\n            factors[val] = (cnt2, cnt5)\\n        row2, row5, col2, col5 = [], [], [], []\\n        for i in range(m + 1): \\n            row2.append([0]*(n + 1))\\n            col2.append([0]*(n + 1))\\n            row5.append([0]*(n + 1))\\n            col5.append([0]*(n + 1))\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                row2[i][j] = cnt2 + row2[i][j - 1]\\n                row5[i][j] = cnt5 + row5[i][j - 1]\\n                col2[i][j] = cnt2 + col2[i - 1][j]\\n                col5[i][j] = cnt5 + col5[i - 1][j]\\n        res = 0\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                cnt2, cnt5 = factors[grid[i - 1][j - 1]]\\n                top2, top5 = col2[i-1][j], col5[i-1][j]\\n                bottom2, bottom5 = col2[m][j] - col2[i][j], col5[m][j] - col5[i][j]\\n                left2, left5 = row2[i][j-1], row5[i][j-1]\\n                right2, right5 = row2[i][n] - row2[i][j], row5[i][n] - row5[i][j]\\n                res = max(res, min(top2 + left2 + cnt2, top5 + left5 + cnt5), min(top2 + right2 + cnt2, top5 + right5 + cnt5), min(bottom2 + left2 + cnt2, bottom5 + left5 + cnt5), min(bottom2 + right2 + cnt2, bottom5 + right5 + cnt5))\\n        return res\\n                \\n                \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959808,
                "title": "c-self-explanatory-more-readable-code-prefix-sum",
                "content": "```\\n// Trailing Zeros => Count of 10\\'s in a number => 10 = 2*5 => minimum (sum of 2 exponents, sum of 5 exponents)\\n// Apporach : Prefix Sum of Count of 2\\'s and 5\\'s + Suffix Sum of Count of 2\\'s and 5\\'s | Time - O(4*m*n), Space - O(2*m*n)\\n\\nclass Pair{\\npublic:\\n    int countOfTwo;\\n    int countOfFive;\\n    \\n    Pair(){\\n        countOfTwo = 0;\\n        countOfTwo = 0;\\n    }\\n    \\n    Pair(int two, int five){\\n        countOfTwo = two;\\n        countOfFive = five;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<Pair>> prefix(m, vector<Pair>(n));\\n        vector<vector<Pair>> suffix(m, vector<Pair>(n));\\n        \\n        // Find the Prefix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                prefix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=0){\\n                    prefix[i][j].countOfTwo += prefix[i][j-1].countOfTwo;\\n                    prefix[i][j].countOfFive += prefix[i][j-1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        // Find the Suffix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=n-1; j>=0; j--){\\n                suffix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=n-1){\\n                    suffix[i][j].countOfTwo += suffix[i][j+1].countOfTwo;\\n                    suffix[i][j].countOfFive += suffix[i][j+1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        //                                                        __   __\\n        // Traverse the each valid concerned Path => |__ ,  __| ,  |  ,|  \\n        // and calculate the trailing zeros and then take max of it\\n        // We\\'re traversing each column and then each row\\n        \\n        // First Traverse the concerned Path  of type:|__ ,  __|\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=0; j<m; j++){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n         //                                                        __   __\\n        // Second Traverse the concerned Path  of type:             | , | \\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=m-1; j>=0; j--){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n        // Now return ans\\n        return ans;\\n    }\\nprivate:\\n    Pair findCountTwoAndFive(int num){\\n        int two = 0, five = 0;\\n        while(num%2==0){\\n            two++;\\n            num /= 2;\\n        }\\n                \\n        while(num%5==0){\\n            five++;\\n            num /= 5;\\n        }\\n                \\n        return Pair(two, five);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Trailing Zeros => Count of 10\\'s in a number => 10 = 2*5 => minimum (sum of 2 exponents, sum of 5 exponents)\\n// Apporach : Prefix Sum of Count of 2\\'s and 5\\'s + Suffix Sum of Count of 2\\'s and 5\\'s | Time - O(4*m*n), Space - O(2*m*n)\\n\\nclass Pair{\\npublic:\\n    int countOfTwo;\\n    int countOfFive;\\n    \\n    Pair(){\\n        countOfTwo = 0;\\n        countOfTwo = 0;\\n    }\\n    \\n    Pair(int two, int five){\\n        countOfTwo = two;\\n        countOfFive = five;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<Pair>> prefix(m, vector<Pair>(n));\\n        vector<vector<Pair>> suffix(m, vector<Pair>(n));\\n        \\n        // Find the Prefix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                prefix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=0){\\n                    prefix[i][j].countOfTwo += prefix[i][j-1].countOfTwo;\\n                    prefix[i][j].countOfFive += prefix[i][j-1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        // Find the Suffix Sum of Count of 2\\'s and 5\\'s \\n        for(int i=0; i<m; i++){\\n            for(int j=n-1; j>=0; j--){\\n                suffix[i][j]  = findCountTwoAndFive(grid[i][j]);\\n                \\n                if(j!=n-1){\\n                    suffix[i][j].countOfTwo += suffix[i][j+1].countOfTwo;\\n                    suffix[i][j].countOfFive += suffix[i][j+1].countOfFive;\\n                }\\n            }\\n        }\\n        \\n        //                                                        __   __\\n        // Traverse the each valid concerned Path => |__ ,  __| ,  |  ,|  \\n        // and calculate the trailing zeros and then take max of it\\n        // We\\'re traversing each column and then each row\\n        \\n        // First Traverse the concerned Path  of type:|__ ,  __|\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=0; j<m; j++){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n         //                                                        __   __\\n        // Second Traverse the concerned Path  of type:             | , | \\n        for(int i=0; i<n; i++){\\n            int count2 = 0, count5 = 0;\\n            for(int j=m-1; j>=0; j--){\\n                \\n                ans = max(ans, min(count2 + prefix[j][i].countOfTwo, count5 + prefix[j][i].countOfFive));\\n                ans = max(ans, min(count2 + suffix[j][i].countOfTwo, count5 + suffix[j][i].countOfFive));\\n                \\n                Pair p = findCountTwoAndFive(grid[j][i]);\\n                count2 += p.countOfTwo, count5 += p.countOfFive;\\n            }\\n        }\\n        \\n        // Now return ans\\n        return ans;\\n    }\\nprivate:\\n    Pair findCountTwoAndFive(int num){\\n        int two = 0, five = 0;\\n        while(num%2==0){\\n            two++;\\n            num /= 2;\\n        }\\n                \\n        while(num%5==0){\\n            five++;\\n            num /= 5;\\n        }\\n                \\n        return Pair(two, five);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959722,
                "title": "can-someone-help-me-where-i-m-going-wrong",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m=len(grid[0])\\n        n=len(grid)\\n        def checkZeros(num):\\n            count=0\\n            while num%10 ==0 and num!=0:\\n                count+=1\\n                num//=10\\n            return count\\n        preRow=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        preCol=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        totalRow=[1 for i in range(n)]\\n        totalCol=[1 for i in range(m)]\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                pro*=grid[i][j]\\n                preRow[i][j]=pro\\n            totalRow[i]=pro\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                pro*=grid[j][i]\\n                preCol[j][i]=pro\\n            totalCol[i]=pro\\n        maxx=0\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                maxx=max(maxx,checkZeros(pro*preRow[j][i]))\\n                pro*=grid[j][i]\\n                maxx=max(maxx,checkZeros(pro*(totalRow[j]//preRow[j][i])))\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                maxx=max(maxx,checkZeros(pro*preCol[i][j]))\\n                pro*=grid[i][j]\\n                maxx=max(maxx,checkZeros(pro*(totalCol[j]//preCol[i][j])))\\n        return maxx\\n   \\n```\\nwhy is this code failing for this test case\\n[[534,575,625,84,20,999,35],[208,318,96,380,819,102,669]]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m=len(grid[0])\\n        n=len(grid)\\n        def checkZeros(num):\\n            count=0\\n            while num%10 ==0 and num!=0:\\n                count+=1\\n                num//=10\\n            return count\\n        preRow=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        preCol=[[1 for i in range(len(grid[0]))] for j in range(n)]\\n        totalRow=[1 for i in range(n)]\\n        totalCol=[1 for i in range(m)]\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                pro*=grid[i][j]\\n                preRow[i][j]=pro\\n            totalRow[i]=pro\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                pro*=grid[j][i]\\n                preCol[j][i]=pro\\n            totalCol[i]=pro\\n        maxx=0\\n        for i in range(m):\\n            pro=1\\n            for j in range(n):\\n                maxx=max(maxx,checkZeros(pro*preRow[j][i]))\\n                pro*=grid[j][i]\\n                maxx=max(maxx,checkZeros(pro*(totalRow[j]//preRow[j][i])))\\n        for i in range(n):\\n            pro=1\\n            for j in range(m):\\n                maxx=max(maxx,checkZeros(pro*preCol[i][j]))\\n                pro*=grid[i][j]\\n                maxx=max(maxx,checkZeros(pro*(totalCol[j]//preCol[i][j])))\\n        return maxx\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959632,
                "title": "python3-dp-concise-recursive-19-lines-iterative-beats-100",
                "content": "Starting from any cell[i][j], we go 4 directions top,left, right, down. Go until meeting boundary. Then pick any 2 directions plus cell[i][j] itself to make a \\'cornered line\\', totally 6 combinations: \\'left+cell+top\\', \\'left+cell+down\\', \\'left+cell+right\\', \\'top+cell+right\\', \\'top+cell+down\\', \\'right+cell+down\\'. Calculating scores for these 6 lines and we will know the highest score that passes cell[i][j]. \\nDo the same for all cells and the highest among highest score is the final result. We use 2D prefix sum for 4 directions to achieve O(1) time for each cell.\\n\\nRecursive: 8274ms beats 50%\\n```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        @functools.lru_cache(None)\\n        def dp(i,j,d):\\n            if 0<=i<m and 0<=j<n:\\n                tmp2,tmp5 = dp(i+d[0],j+d[1],d)\\n                return factors(grid[i][j],2)+tmp2,factors(grid[i][j],5)+tmp5\\n            return 0,0\\n        combo = [[a,b] for a,b in combinations([(-1,0),(0,-1),(1,0),(0,1)],2) if a[0]+b[0]!=0 or a[1]+b[1]!=0]\\n        m,n,res=len(grid),len(grid[0]),0\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                for dir1, dir2 in combo:\\n                    d1,d2=dp(i,j,dir1),dp(i,j,dir2)\\n                    res = max(res,min(d1[0]+d2[0]-cur[0],d1[1]+d2[1]-cur[1]))\\n        return res\\n```\\n\\nTo make it even faster\\n\\t1. We don\\'t need to prepare 2D prefix sum for all 4 directions, but only \\'up\\' and \\'left\\'. Because \\'right\\' and \\'down\\' can be calculated using \\'up\\' and \\'left\\'.\\n\\t2. We don\\'t need to go all 6 combinations of 4 directions, but only 4. No need to calculate the 4 \\'straight line\\' combinations, because for each of them there must exists a \\'corner line\\' that completely covers it.\\n\\t3. The function to count factors \\'2\\' and \\'5\\' can be cached and put to global to share across test cases\\n\\nIterative, 4556ms beats 100%\\n```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t@functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        m,n=len(grid),len(grid[0])\\n        up=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        left=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                grid[i][j] = cur\\n                up_prev,left_prev = up[i-1][j], left[i][j-1]\\n                up[i][j] = [up_prev[0]+cur[0],up_prev[1]+cur[1]]\\n                left[i][j] = [left_prev[0]+cur[0],left_prev[1]+cur[1]]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                up1,left1,cur = up[i][j], left[i][j], grid[i][j]\\n                right1 = [left[i][-1][0]-left1[0]+cur[0],left[i][-1][1]-left1[1]+cur[1]]\\n                down1 = [up[-1][j][0]-up1[0]+cur[0],up[-1][j][1]-up1[1]+cur[1]]\\n                a = min(left1[0]+up1[0]-cur[0],left1[1]+up1[1]-cur[1])\\n                b = min(up1[0]+right1[0]-cur[0],up1[1]+right1[1]-cur[1])\\n                c = min(left1[0]+down1[0]-cur[0],left1[1]+down1[1]-cur[1])\\n                d = min(right1[0]+down1[0]-cur[0],right1[1]+down1[1]-cur[1])\\n                res = max(res,a,b,c,d)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        @functools.lru_cache(None)\\n        def dp(i,j,d):\\n            if 0<=i<m and 0<=j<n:\\n                tmp2,tmp5 = dp(i+d[0],j+d[1],d)\\n                return factors(grid[i][j],2)+tmp2,factors(grid[i][j],5)+tmp5\\n            return 0,0\\n        combo = [[a,b] for a,b in combinations([(-1,0),(0,-1),(1,0),(0,1)],2) if a[0]+b[0]!=0 or a[1]+b[1]!=0]\\n        m,n,res=len(grid),len(grid[0]),0\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                for dir1, dir2 in combo:\\n                    d1,d2=dp(i,j,dir1),dp(i,j,dir2)\\n                    res = max(res,min(d1[0]+d2[0]-cur[0],d1[1]+d2[1]-cur[1]))\\n        return res\\n```\n```\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\t\\t@functools.lru_cache(None)\\n        def factors(num,factor):\\n            if num%factor!=0: return 0\\n            return 1+factors(num//factor,factor)\\n        m,n=len(grid),len(grid[0])\\n        up=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        left=[[(0,0) for _ in range(n)]  for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cur = (factors(grid[i][j],2),factors(grid[i][j],5))\\n                grid[i][j] = cur\\n                up_prev,left_prev = up[i-1][j], left[i][j-1]\\n                up[i][j] = [up_prev[0]+cur[0],up_prev[1]+cur[1]]\\n                left[i][j] = [left_prev[0]+cur[0],left_prev[1]+cur[1]]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                up1,left1,cur = up[i][j], left[i][j], grid[i][j]\\n                right1 = [left[i][-1][0]-left1[0]+cur[0],left[i][-1][1]-left1[1]+cur[1]]\\n                down1 = [up[-1][j][0]-up1[0]+cur[0],up[-1][j][1]-up1[1]+cur[1]]\\n                a = min(left1[0]+up1[0]-cur[0],left1[1]+up1[1]-cur[1])\\n                b = min(up1[0]+right1[0]-cur[0],up1[1]+right1[1]-cur[1])\\n                c = min(left1[0]+down1[0]-cur[0],left1[1]+down1[1]-cur[1])\\n                d = min(right1[0]+down1[0]-cur[0],right1[1]+down1[1]-cur[1])\\n                res = max(res,a,b,c,d)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1959465,
                "title": "scala",
                "content": "```\\nimport scala.annotation.tailrec\\nimport scala.math.min\\n\\nobject Solution {\\n  def maxTrailingZeros(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n    val numFactors = grid.map(_.map(x => (computeNumFactors(x, 2), computeNumFactors(x, 5))))\\n    val verticalCumFactors = (0 until n).map(j => (0 until m).view.map(numFactors(_)(j)).scan(0, 0)(_ + _).toIndexedSeq)\\n    (0 until m)\\n      .iterator\\n      .flatMap { i =>\\n        val horizontalCumFactors = numFactors(i).scan(0, 0)(_ + _)\\n        (0 until n)\\n          .iterator\\n          .flatMap { j =>\\n            Iterator(horizontalCumFactors(j + 1) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors(j + 1) + verticalCumFactors(j).last - verticalCumFactors(j)(i + 1),\\n                     horizontalCumFactors.last - horizontalCumFactors(j) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors.last -\\n                       horizontalCumFactors(j) +\\n                       verticalCumFactors(j).last -\\n                       verticalCumFactors(j)(i + 1))\\n          }\\n      }\\n      .map { case (numTwos, numFives) => min(numTwos, numFives) }\\n      .maxOption\\n      .getOrElse(0)\\n  }\\n\\n  @tailrec\\n  private def computeNumFactors(x: Int, factor: Int, count: Int = 0): Int = x match {\\n    case x if x != 0 && x % factor == 0 => computeNumFactors(x / factor, factor, count + 1)\\n    case _ => count\\n  }\\n\\n  private implicit class RichTuple2[+A, +B](x: (A, B)) {\\n    def +[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.plus(x._1, y._1), b1Numeric.plus(x._2, y._2))\\n    }\\n\\n    def -[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.minus(x._1, y._1), b1Numeric.minus(x._2, y._2))\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Prefix Sum"
                ],
                "code": "```\\nimport scala.annotation.tailrec\\nimport scala.math.min\\n\\nobject Solution {\\n  def maxTrailingZeros(grid: Array[Array[Int]]): Int = {\\n    val m = grid.length\\n    val n = grid.headOption.map(_.length).getOrElse(0)\\n    val numFactors = grid.map(_.map(x => (computeNumFactors(x, 2), computeNumFactors(x, 5))))\\n    val verticalCumFactors = (0 until n).map(j => (0 until m).view.map(numFactors(_)(j)).scan(0, 0)(_ + _).toIndexedSeq)\\n    (0 until m)\\n      .iterator\\n      .flatMap { i =>\\n        val horizontalCumFactors = numFactors(i).scan(0, 0)(_ + _)\\n        (0 until n)\\n          .iterator\\n          .flatMap { j =>\\n            Iterator(horizontalCumFactors(j + 1) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors(j + 1) + verticalCumFactors(j).last - verticalCumFactors(j)(i + 1),\\n                     horizontalCumFactors.last - horizontalCumFactors(j) + verticalCumFactors(j)(i),\\n                     horizontalCumFactors.last -\\n                       horizontalCumFactors(j) +\\n                       verticalCumFactors(j).last -\\n                       verticalCumFactors(j)(i + 1))\\n          }\\n      }\\n      .map { case (numTwos, numFives) => min(numTwos, numFives) }\\n      .maxOption\\n      .getOrElse(0)\\n  }\\n\\n  @tailrec\\n  private def computeNumFactors(x: Int, factor: Int, count: Int = 0): Int = x match {\\n    case x if x != 0 && x % factor == 0 => computeNumFactors(x / factor, factor, count + 1)\\n    case _ => count\\n  }\\n\\n  private implicit class RichTuple2[+A, +B](x: (A, B)) {\\n    def +[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.plus(x._1, y._1), b1Numeric.plus(x._2, y._2))\\n    }\\n\\n    def -[A1 >: A, B1 >: B](y: (A1, B1))(implicit a1Numeric: Numeric[A1], b1Numeric: Numeric[B1]): (A1, B1) = {\\n      (a1Numeric.minus(x._1, y._1), b1Numeric.minus(x._2, y._2))\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959403,
                "title": "10-54-test-cases-passed-can-someone-help-figure-out-where-i-m-going-wrong",
                "content": "Hi, I implemented the prefix sum solution but only 10 testcases passed, I am struggling to figure out what is wrong. Can someone help.\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    let ans = 0\\n    let m = grid.length, n=grid[0].length\\n    \\n    const prefixH = new Array(m), prefixV = new Array(m)\\n    for (let i=0; i<m; i++) {\\n        prefixH[i] = new Array(n)\\n        prefixV[i] = new Array(n)\\n        for (let j=0; j<n; j++) {\\n            prefixH[i][j] = [0, 0]\\n            prefixV[i][j] = [0, 0]\\n        }\\n    }\\n    \\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            let value = grid[i][j]\\n            while (value % 2 == 0) {\\n                prefixH[i][j][0] += 1\\n                prefixV[i][j][0] += 1\\n                value = value / 2\\n            }\\n            while (value % 5 == 0) {\\n                prefixH[i][j][1] += 1\\n                prefixV[i][j][1] += 1\\n                value = value / 5\\n            }\\n            if (i > 0) {\\n                prefixH[i][j][0] += prefixH[i-1][j][0]\\n                prefixH[i][j][1] += prefixH[i-1][j][1]\\n            }\\n            if (j > 0) {\\n                prefixV[i][j][0] += prefixV[i][j-1][0]\\n                prefixV[i][j][1] += prefixV[i][j-1][1]\\n            }\\n        }\\n    }\\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            const left = prefixH[i][j]\\n            const up = prefixV[i][j]\\n            const right = [0, 0]\\n            const down = [0, 0]\\n            const center = prefixH[i][j]\\n            \\n            // const lU = [0, 0], lD = [0, 0], rU = [0, 0], rD = [0, 0]\\n            \\n            if (i < m-1) {\\n                down[0] = prefixV[m-1][j][0] - prefixV[i][j][0]\\n                down[1] = prefixV[m-1][j][1] - prefixV[i][j][1]\\n            }\\n            if (i > 0) {\\n                center[0] -= prefixH[i-1][j][0]\\n                center[1] -= prefixH[i-1][j][1]\\n            }\\n            if (j < n-1) {\\n                right[0] = prefixH[i][n-1][0] - prefixH[i][j][0]\\n                right[1] = prefixH[i][n-1][1] - prefixH[i][j][1]\\n            }\\n            const lU = [\\n                left[0]+up[0], left[1]+up[1]\\n            ]\\n            const lD = [\\n                left[0]+down[0], left[1]+down[1]\\n            ]\\n            const rU = [\\n                right[0]+up[0], right[1]+up[1]\\n            ]\\n            const rD = [\\n                right[0]+down[0], right[1]+down[1]\\n            ]\\n            const maxMin = Math.max(\\n                    Math.min(...lU),\\n                    Math.min(...lD),\\n                    Math.min(...rU),\\n                    Math.min(...rD),\\n                    Math.min(...center)\\n            )\\n            // console.log(i, j, lU, lD, rU, rD, center, maxMin)\\n            ans = Math.max(ans, maxMin)\\n        }\\n    }\\n    // console.log(\\'PrefixH\\', prefixH)\\n    // console.log(\\'PrefixV\\', prefixV)\\n    \\n    return ans\\n    \\n};\\n\\n```\\nThe testcase that fails is \\n[[824,709,193,413,701,836,727],[135,844,599,211,140,933,205],[329,68,285,282,301,387,231],[293,210,478,352,946,902,137],[806,900,290,636,589,522,611],[450,568,990,592,992,128,92],[780,653,795,457,980,942,927],[849,901,604,906,912,866,688]]\\nOutput: 5\\nExpected: 6",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maxTrailingZeros = function(grid) {\\n    let ans = 0\\n    let m = grid.length, n=grid[0].length\\n    \\n    const prefixH = new Array(m), prefixV = new Array(m)\\n    for (let i=0; i<m; i++) {\\n        prefixH[i] = new Array(n)\\n        prefixV[i] = new Array(n)\\n        for (let j=0; j<n; j++) {\\n            prefixH[i][j] = [0, 0]\\n            prefixV[i][j] = [0, 0]\\n        }\\n    }\\n    \\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            let value = grid[i][j]\\n            while (value % 2 == 0) {\\n                prefixH[i][j][0] += 1\\n                prefixV[i][j][0] += 1\\n                value = value / 2\\n            }\\n            while (value % 5 == 0) {\\n                prefixH[i][j][1] += 1\\n                prefixV[i][j][1] += 1\\n                value = value / 5\\n            }\\n            if (i > 0) {\\n                prefixH[i][j][0] += prefixH[i-1][j][0]\\n                prefixH[i][j][1] += prefixH[i-1][j][1]\\n            }\\n            if (j > 0) {\\n                prefixV[i][j][0] += prefixV[i][j-1][0]\\n                prefixV[i][j][1] += prefixV[i][j-1][1]\\n            }\\n        }\\n    }\\n    for (let i=0; i<m; i++) {\\n        for (let j=0; j<n; j++) {\\n            const left = prefixH[i][j]\\n            const up = prefixV[i][j]\\n            const right = [0, 0]\\n            const down = [0, 0]\\n            const center = prefixH[i][j]\\n            \\n            // const lU = [0, 0], lD = [0, 0], rU = [0, 0], rD = [0, 0]\\n            \\n            if (i < m-1) {\\n                down[0] = prefixV[m-1][j][0] - prefixV[i][j][0]\\n                down[1] = prefixV[m-1][j][1] - prefixV[i][j][1]\\n            }\\n            if (i > 0) {\\n                center[0] -= prefixH[i-1][j][0]\\n                center[1] -= prefixH[i-1][j][1]\\n            }\\n            if (j < n-1) {\\n                right[0] = prefixH[i][n-1][0] - prefixH[i][j][0]\\n                right[1] = prefixH[i][n-1][1] - prefixH[i][j][1]\\n            }\\n            const lU = [\\n                left[0]+up[0], left[1]+up[1]\\n            ]\\n            const lD = [\\n                left[0]+down[0], left[1]+down[1]\\n            ]\\n            const rU = [\\n                right[0]+up[0], right[1]+up[1]\\n            ]\\n            const rD = [\\n                right[0]+down[0], right[1]+down[1]\\n            ]\\n            const maxMin = Math.max(\\n                    Math.min(...lU),\\n                    Math.min(...lD),\\n                    Math.min(...rU),\\n                    Math.min(...rD),\\n                    Math.min(...center)\\n            )\\n            // console.log(i, j, lU, lD, rU, rD, center, maxMin)\\n            ans = Math.max(ans, maxMin)\\n        }\\n    }\\n    // console.log(\\'PrefixH\\', prefixH)\\n    // console.log(\\'PrefixV\\', prefixV)\\n    \\n    return ans\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958835,
                "title": "clean-java-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] down = new int[m][n][2];\\n        int[][][] up = new int[m][n][2];\\n        int[][][] left = new int[m][n][2];\\n        int[][][] right = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                up[i][j][0] = (i == 0)? two : two + up[i - 1][j][0];\\n                left[i][j][0] = (j == 0)? two : two + left[i][j - 1][0];\\n                up[i][j][1] = (i == 0)? five : five + up[i - 1][j][1];\\n                left[i][j][1] = (j == 0)? five : five + left[i][j - 1][1];\\n            }\\n        }\\n        \\n        for(int i = m - 1; i >= 0; --i) {\\n            for(int j = n - 1; j >= 0; --j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                down[i][j][0] = (i == m - 1)? two : two + down[i + 1][j][0];\\n                right[i][j][0] = (j == n - 1)? two : two + right[i][j + 1][0];\\n                down[i][j][1] = (i == m - 1)? five : five + down[i + 1][j][1];\\n                right[i][j][1] = (j == n - 1)? five : five + right[i][j + 1][1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five = divide(grid[i][j], 5);\\n                \\n                int sol1 = Math.min(up[i][j][0] + right[i][j][0] - two, up[i][j][1] + right[i][j][1] - five);\\n                int sol2 = Math.min(right[i][j][0] + down[i][j][0] - two, right[i][j][1] + down[i][j][1] - five);\\n                int sol3 = Math.min(down[i][j][0] + left[i][j][0] - two, down[i][j][1] + left[i][j][1] - five);\\n                int sol4 = Math.min(left[i][j][0] + up[i][j][0] - two, left[i][j][1] + up[i][j][1] - five);\\n\\n                res = Math.max(res, Math.max(Math.max(sol1, sol2), Math.max(sol3, sol4)));\\n                \\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int divide(int val, int d) {\\n        //System.out.println(val);\\n        int res = 0;\\n        while(val > 0 && val % d == 0) {\\n            ++res;\\n            val /= d;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] down = new int[m][n][2];\\n        int[][][] up = new int[m][n][2];\\n        int[][][] left = new int[m][n][2];\\n        int[][][] right = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                up[i][j][0] = (i == 0)? two : two + up[i - 1][j][0];\\n                left[i][j][0] = (j == 0)? two : two + left[i][j - 1][0];\\n                up[i][j][1] = (i == 0)? five : five + up[i - 1][j][1];\\n                left[i][j][1] = (j == 0)? five : five + left[i][j - 1][1];\\n            }\\n        }\\n        \\n        for(int i = m - 1; i >= 0; --i) {\\n            for(int j = n - 1; j >= 0; --j) {\\n                int two = divide(grid[i][j], 2);\\n                int five =  divide(grid[i][j], 5);\\n                \\n                down[i][j][0] = (i == m - 1)? two : two + down[i + 1][j][0];\\n                right[i][j][0] = (j == n - 1)? two : two + right[i][j + 1][0];\\n                down[i][j][1] = (i == m - 1)? five : five + down[i + 1][j][1];\\n                right[i][j][1] = (j == n - 1)? five : five + right[i][j + 1][1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int two = divide(grid[i][j], 2);\\n                int five = divide(grid[i][j], 5);\\n                \\n                int sol1 = Math.min(up[i][j][0] + right[i][j][0] - two, up[i][j][1] + right[i][j][1] - five);\\n                int sol2 = Math.min(right[i][j][0] + down[i][j][0] - two, right[i][j][1] + down[i][j][1] - five);\\n                int sol3 = Math.min(down[i][j][0] + left[i][j][0] - two, down[i][j][1] + left[i][j][1] - five);\\n                int sol4 = Math.min(left[i][j][0] + up[i][j][0] - two, left[i][j][1] + up[i][j][1] - five);\\n\\n                res = Math.max(res, Math.max(Math.max(sol1, sol2), Math.max(sol3, sol4)));\\n                \\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int divide(int val, int d) {\\n        //System.out.println(val);\\n        int res = 0;\\n        while(val > 0 && val % d == 0) {\\n            ++res;\\n            val /= d;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958827,
                "title": "easy-to-understand-c-code",
                "content": "Using 6 grids to store following values - \\n1. two[i][j] gives greatest exponent of two in factor of grid[i][j]\\n2. th[i][j] gives cumulative sum of all two\\'s factors horizontally, basically sum of two[i][0]...two[i][j]\\n3. tv[i][j] gives cumulative sum of all two\\'s factors vertically, basically sum of two[0][j]...two[i][j]\\n4. 5. 6. same things for five as a factor.\\n\\nThere are 3 important things to note-\\n1. In a product, numberof trailing zeroes = min(exp of 2, exp of 5 in that product)\\n2. Cumulative sum matrices will give the exponent of 2 in product of the left cumulation ( right cumulation can be found by total-leftcumulation)\\n3. Adding more number to a product can only increase trailing zeroes, so we will always calculate factors till the end.\\n\\nLastly, for any random point i,j there are two horizontal paths ((0,j)..(i,j) and (i,j)..(i,n-1))  and two vertical paths, so four cases which are being checked in the final loop\\n\\n```class Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> two(m,vector<int>(n,0));\\n        vector<vector<int>> five(m,vector<int>(n,0));\\n        vector<vector<int>> th(m,vector<int>(n,0));\\n        vector<vector<int>> fh(m,vector<int>(n,0));\\n        vector<vector<int>> tv(m,vector<int>(n,0));\\n        vector<vector<int>> fv(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int tf=0,ff=0, num=grid[i][j];\\n                while(num%2==0){\\n                    num/=2;\\n                    tf++;\\n                }\\n                while(num%5==0){\\n                    num/=5;\\n                    ff++;\\n                }\\n                two[i][j]=tf;\\n                five[i][j]=ff;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                th[i][j]=(j==0?two[i][j]:two[i][j]+th[i][j-1]);\\n                fh[i][j]=(j==0?five[i][j]:five[i][j]+fh[i][j-1]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                tv[j][i]=(j==0?two[j][i]:two[j][i]+tv[j-1][i]);\\n                fv[j][i]=(j==0?five[j][i]:five[j][i]+fv[j-1][i]);\\n            }\\n        }\\n        int maxN=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int p1=min(tv[i][j]+th[i][j]-two[i][j],fv[i][j]+fh[i][j]-five[i][j]);\\n                int p2=min(tv[i][j]+th[i][n-1]-th[i][j],fv[i][j]+fh[i][n-1]-fh[i][j]);\\n                int p3=min(tv[m-1][j]-tv[i][j]+th[i][j],fv[m-1][j]-fv[i][j]+fh[i][j]);\\n                int p4=min(tv[m-1][j]-tv[i][j]+th[i][n-1]-th[i][j]+two[i][j],fv[m-1][j]-fv[i][j]+fh[i][n-1]-fh[i][j]+five[i][j]);\\n                maxN=max(maxN,p1);\\n                maxN=max(maxN,p2);\\n                maxN=max(maxN,p3);\\n                maxN=max(maxN,p4);\\n            }\\n        }\\n        return maxN;\\n    }\\n};```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```class Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> two(m,vector<int>(n,0));\\n        vector<vector<int>> five(m,vector<int>(n,0));\\n        vector<vector<int>> th(m,vector<int>(n,0));\\n        vector<vector<int>> fh(m,vector<int>(n,0));\\n        vector<vector<int>> tv(m,vector<int>(n,0));\\n        vector<vector<int>> fv(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int tf=0,ff=0, num=grid[i][j];\\n                while(num%2==0){\\n                    num/=2;\\n                    tf++;\\n                }\\n                while(num%5==0){\\n                    num/=5;\\n                    ff++;\\n                }\\n                two[i][j]=tf;\\n                five[i][j]=ff;\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                th[i][j]=(j==0?two[i][j]:two[i][j]+th[i][j-1]);\\n                fh[i][j]=(j==0?five[i][j]:five[i][j]+fh[i][j-1]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                tv[j][i]=(j==0?two[j][i]:two[j][i]+tv[j-1][i]);\\n                fv[j][i]=(j==0?five[j][i]:five[j][i]+fv[j-1][i]);\\n            }\\n        }\\n        int maxN=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int p1=min(tv[i][j]+th[i][j]-two[i][j],fv[i][j]+fh[i][j]-five[i][j]);\\n                int p2=min(tv[i][j]+th[i][n-1]-th[i][j],fv[i][j]+fh[i][n-1]-fh[i][j]);\\n                int p3=min(tv[m-1][j]-tv[i][j]+th[i][j],fv[m-1][j]-fv[i][j]+fh[i][j]);\\n                int p4=min(tv[m-1][j]-tv[i][j]+th[i][n-1]-th[i][j]+two[i][j],fv[m-1][j]-fv[i][j]+fh[i][n-1]-fh[i][j]+five[i][j]);\\n                maxN=max(maxN,p1);\\n                maxN=max(maxN,p2);\\n                maxN=max(maxN,p3);\\n                maxN=max(maxN,p4);\\n            }\\n        }\\n        return maxN;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1958726,
                "title": "python-faster-than-100-no-explanation",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        _2s = [[0 for i in range(n)] for i in range(m)]\\n        _5s = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i, j in itertools.product(range(m), range(n)):\\n            _helper1 = grid[i][j]\\n            counter1 = 0\\n            _helper2 = grid[i][j]\\n            counter2 = 0\\n            while _helper1 % 2 == 0:\\n                _helper1 = _helper1 // 2\\n                counter1 += 1\\n            _2s[i][j] = counter1\\n            \\n            while _helper2 % 5 == 0:\\n                _helper2 = _helper2 // 5\\n                counter2 += 1\\n            _5s[i][j] = counter2\\n\\n        \\n        left_right_2s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i in range(m):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n):\\n                left_right_2s[i][j] = curr_2\\n                left_right_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n                 \\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n - 1, -1, -1):\\n                left_right_2s_2[i][j] = curr_2\\n                left_right_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        for j in range(n):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m):\\n                up_down_2s[i][j] = curr_2\\n                up_down_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m - 1, -1, -1):\\n                up_down_2s_2[i][j] = curr_2\\n                up_down_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        res = 0\\n        for i, j in itertools.product(range(m), range(n)):\\n\\n            res = max(res, \\n                      min(up_down_2s[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                     )\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        _2s = [[0 for i in range(n)] for i in range(m)]\\n        _5s = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i, j in itertools.product(range(m), range(n)):\\n            _helper1 = grid[i][j]\\n            counter1 = 0\\n            _helper2 = grid[i][j]\\n            counter2 = 0\\n            while _helper1 % 2 == 0:\\n                _helper1 = _helper1 // 2\\n                counter1 += 1\\n            _2s[i][j] = counter1\\n            \\n            while _helper2 % 5 == 0:\\n                _helper2 = _helper2 // 5\\n                counter2 += 1\\n            _5s[i][j] = counter2\\n\\n        \\n        left_right_2s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_2s_2 = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s = [[0 for i in range(n)] for i in range(m)]\\n        left_right_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s = [[0 for i in range(n)] for i in range(m)]\\n        up_down_5s_2 = [[0 for i in range(n)] for i in range(m)]\\n        \\n        for i in range(m):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n):\\n                left_right_2s[i][j] = curr_2\\n                left_right_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n                 \\n            curr_2 = 0\\n            curr_5 = 0\\n            for j in range(n - 1, -1, -1):\\n                left_right_2s_2[i][j] = curr_2\\n                left_right_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        for j in range(n):\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m):\\n                up_down_2s[i][j] = curr_2\\n                up_down_5s[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n            curr_2 = 0\\n            curr_5 = 0\\n            for i in range(m - 1, -1, -1):\\n                up_down_2s_2[i][j] = curr_2\\n                up_down_5s_2[i][j] = curr_5\\n                curr_2 += _2s[i][j] \\n                curr_5 += _5s[i][j]\\n        \\n        res = 0\\n        for i, j in itertools.product(range(m), range(n)):\\n\\n            res = max(res, \\n                      min(up_down_2s[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s[i][j] + left_right_2s_2[i][j] + _2s[i][j], up_down_5s[i][j] + left_right_5s_2[i][j] + _5s[i][j]),\\n                      min(up_down_2s_2[i][j] + left_right_2s[i][j] + _2s[i][j], up_down_5s_2[i][j] + left_right_5s[i][j] + _5s[i][j]),\\n                     )\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958677,
                "title": "c-prefix-sum-solution-o-n-m",
                "content": "Runtime: 744 ms, faster than 100.00% of C++ online submissions for Maximum Trailing Zeros in a Cornered Path.\\nMemory Usage: 159.2 MB, less than 100.00% of C++ online submissions for Maximum Trailing Zeros in a Cornered Path.\\n\\n\\n```\\nCount the factor of 2 and 5 in numbers and calculate prefix sum row wise and column wise in DP vector.\\nThen loop through DP and for each [row][column] position calculate 4 possible case : \\n\\n1. Left Sum + Up Sum\\n2. Right Sum + Up Sum\\n3. Left Sum + Down Sum\\n4. Right Sum + Down Sum\\n\\nHere DP contains row wise left to right prefix sum and column wise up to down prefix sum.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track  number of 2 and 5 in numbers row wise and column wise => row 0 , column 1 => pair<2,5> count\\n        vector<vector<vector<pair<int,int>>>>dp(m,vector<vector<pair<int,int>>>(n,vector<pair<int,int>>(2,{0,0})));\\n        \\n        // loop through grid and store the prefix sum of 2 and 5 factor count row wise and column wise\\n        int twoC, fiveC,val;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                twoC = 0;\\n                fiveC = 0;\\n                val = grid[i][j];\\n                while(val%5 ==0)\\n                {\\n                    fiveC++;\\n                    val/=5;\\n                }\\n                while(val%2 ==0)\\n                {\\n                    twoC++;\\n                    val/=2;\\n                }\\n                \\n                // row wise prefix sum of factor 2 and 5\\n                if(j > 0)\\n                {\\n                    dp[i][j][0].first += dp[i][j-1][0].first + twoC;\\n                    dp[i][j][0].second += dp[i][j-1][0].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][0].first += twoC;\\n                    dp[i][j][0].second += fiveC;                    \\n                }\\n\\n                // column wise prefix sum of factor 2 and 5\\n                if(i > 0)\\n                {\\n                    dp[i][j][1].first += dp[i-1][j][1].first + twoC;\\n                    dp[i][j][1].second += dp[i-1][j][1].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][1].first += twoC;\\n                    dp[i][j][1].second += fiveC;                    \\n                }\\n            }\\n        }\\n        \\n        // max trailing zeroes\\n        int maxZero = 0;   \\n        \\n        // loop through dp and calculate max trailing zeroes for 4 possible cases\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // left sum + up sum \\n                maxZero = max(maxZero,min(dp[i][j][1].first + (j>0 ? dp[i][j-1][0].first : 0), dp[i][j][1].second + (j>0 ? dp[i][j-1][0].second : 0)));\\n                \\n                // right sum + up sum\\n                maxZero = max(maxZero,min(dp[i][j][1].first + (dp[i][n-1][0].first - dp[i][j][0].first), dp[i][j][1].second + (dp[i][n-1][0].second - dp[i][j][0].second)));\\n                \\n                // left sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + dp[i][j][0].first, (dp[m-1][j][1].second - dp[i][j][1].second) + dp[i][j][0].second));\\n                \\n                // right sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + (dp[i][n-1][0].first - (j>0 ? dp[i][j-1][0].first : 0)), (dp[m-1][j][1].second - dp[i][j][1].second) + (dp[i][n-1][0].second - (j> 0 ? dp[i][j-1][0].second : 0))));\\n\\n            }\\n        }\\n        \\n        \\n        return maxZero;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nCount the factor of 2 and 5 in numbers and calculate prefix sum row wise and column wise in DP vector.\\nThen loop through DP and for each [row][column] position calculate 4 possible case : \\n\\n1. Left Sum + Up Sum\\n2. Right Sum + Up Sum\\n3. Left Sum + Down Sum\\n4. Right Sum + Down Sum\\n\\nHere DP contains row wise left to right prefix sum and column wise up to down prefix sum.\\n```\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track  number of 2 and 5 in numbers row wise and column wise => row 0 , column 1 => pair<2,5> count\\n        vector<vector<vector<pair<int,int>>>>dp(m,vector<vector<pair<int,int>>>(n,vector<pair<int,int>>(2,{0,0})));\\n        \\n        // loop through grid and store the prefix sum of 2 and 5 factor count row wise and column wise\\n        int twoC, fiveC,val;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                twoC = 0;\\n                fiveC = 0;\\n                val = grid[i][j];\\n                while(val%5 ==0)\\n                {\\n                    fiveC++;\\n                    val/=5;\\n                }\\n                while(val%2 ==0)\\n                {\\n                    twoC++;\\n                    val/=2;\\n                }\\n                \\n                // row wise prefix sum of factor 2 and 5\\n                if(j > 0)\\n                {\\n                    dp[i][j][0].first += dp[i][j-1][0].first + twoC;\\n                    dp[i][j][0].second += dp[i][j-1][0].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][0].first += twoC;\\n                    dp[i][j][0].second += fiveC;                    \\n                }\\n\\n                // column wise prefix sum of factor 2 and 5\\n                if(i > 0)\\n                {\\n                    dp[i][j][1].first += dp[i-1][j][1].first + twoC;\\n                    dp[i][j][1].second += dp[i-1][j][1].second + fiveC;\\n                }\\n                else\\n                {\\n                    dp[i][j][1].first += twoC;\\n                    dp[i][j][1].second += fiveC;                    \\n                }\\n            }\\n        }\\n        \\n        // max trailing zeroes\\n        int maxZero = 0;   \\n        \\n        // loop through dp and calculate max trailing zeroes for 4 possible cases\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // left sum + up sum \\n                maxZero = max(maxZero,min(dp[i][j][1].first + (j>0 ? dp[i][j-1][0].first : 0), dp[i][j][1].second + (j>0 ? dp[i][j-1][0].second : 0)));\\n                \\n                // right sum + up sum\\n                maxZero = max(maxZero,min(dp[i][j][1].first + (dp[i][n-1][0].first - dp[i][j][0].first), dp[i][j][1].second + (dp[i][n-1][0].second - dp[i][j][0].second)));\\n                \\n                // left sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + dp[i][j][0].first, (dp[m-1][j][1].second - dp[i][j][1].second) + dp[i][j][0].second));\\n                \\n                // right sum + down sum\\n                maxZero = max(maxZero,min((dp[m-1][j][1].first - dp[i][j][1].first) + (dp[i][n-1][0].first - (j>0 ? dp[i][j-1][0].first : 0)), (dp[m-1][j][1].second - dp[i][j][1].second) + (dp[i][n-1][0].second - (j> 0 ? dp[i][j-1][0].second : 0))));\\n\\n            }\\n        }\\n        \\n        \\n        return maxZero;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958591,
                "title": "java-python3-clear-java-presum-code-beat-100",
                "content": "Convert grid to newGrid by counting the number of factor 2 and factor 5.\\nApply presum algorithm on newGrid with both horizontal and vertical direction.\\nCheck every possible cornered path (Time Complexity: O(m*n)).\\nReturn the max ans.\\n```\\npublic int maxTrailingZeros(int[][] grid) {\\n\\tint m = grid.length, n = grid[0].length;\\n\\t//newGrid[i][j][0] = the number of factor 2, newGrid[i][j][1] = the number of factor 5\\n\\tint[][][] newGrid = new int[m][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 2 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 2;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][0] = count;\\n\\t\\t\\tcount = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 5 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 5;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][1] = count;\\n\\t\\t}\\n\\t}\\n\\t//presum in horizontal direction\\n\\tint[][][] presumCol = new int[m][n+1][2];\\n\\t//presum in vertical direction\\n\\tint[][][] presumRow = new int[m+1][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tpresumCol[i][j+1][0] = presumCol[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumCol[i][j+1][1] = presumCol[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tfor(int j=0; j<n; j++){\\n\\t\\tfor(int i=0; i<m; i++){\\n\\t\\t\\tpresumRow[i+1][j][0] = presumRow[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumRow[i+1][j][1] = presumRow[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t//left and up\\n\\t\\t\\tint t = Math.min(presumCol[i][j][0] + presumRow[i][j][0] + newGrid[i][j][0], presumCol[i][j][1] + presumRow[i][j][1] + newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//left and down\\n\\t\\t\\tt = Math.min(presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0], presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and up\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and down\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0] - newGrid[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1] - newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n\\n**python 3** version:\\n```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tnew_grid = [[[0,0] for _ in range(n)] for _ in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 2 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 2\\n\\t\\t\\tnew_grid[i][j][0] = count\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 5 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 5\\n\\t\\t\\tnew_grid[i][j][1] = count\\n\\tpresum_col, presum_row = [[[0,0] for _ in range(n+1)] for _ in range(m)], [[[0,0] for _ in range(n)] for _ in range(m+1)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tpresum_col[i][j+1][0] = presum_col[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_col[i][j+1][1] = presum_col[i][j][1] + new_grid[i][j][1]\\n\\tfor j in range(n):\\n\\t\\tfor i in range(m):\\n\\t\\t\\tpresum_row[i+1][j][0] = presum_row[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_row[i+1][j][1] = presum_row[i][j][1] + new_grid[i][j][1]\\n\\tans = 0\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\t# left and up\\n\\t\\t\\tt1 = min(presum_col[i][j][0] + presum_row[i][j][0] + new_grid[i][j][0], presum_col[i][j][1] + presum_row[i][j][1] + new_grid[i][j][1])\\n\\t\\t\\t# left and down\\n\\t\\t\\tt2 = min(presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0], presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1])\\n\\t\\t\\t# right and up\\n\\t\\t\\tt3 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[i][j][1])\\n\\t\\t\\t# right and down\\n\\t\\t\\tt4 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0] - new_grid[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1] - new_grid[i][j][1])\\n\\t\\t\\tans = max(ans, t1, t2, t3, t4)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxTrailingZeros(int[][] grid) {\\n\\tint m = grid.length, n = grid[0].length;\\n\\t//newGrid[i][j][0] = the number of factor 2, newGrid[i][j][1] = the number of factor 5\\n\\tint[][][] newGrid = new int[m][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 2 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 2;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][0] = count;\\n\\t\\t\\tcount = 0;\\n\\t\\t\\twhile(grid[i][j] > 0 && grid[i][j] % 5 == 0){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tgrid[i][j] /= 5;\\n\\t\\t\\t}\\n\\t\\t\\tnewGrid[i][j][1] = count;\\n\\t\\t}\\n\\t}\\n\\t//presum in horizontal direction\\n\\tint[][][] presumCol = new int[m][n+1][2];\\n\\t//presum in vertical direction\\n\\tint[][][] presumRow = new int[m+1][n][2];\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\tpresumCol[i][j+1][0] = presumCol[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumCol[i][j+1][1] = presumCol[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tfor(int j=0; j<n; j++){\\n\\t\\tfor(int i=0; i<m; i++){\\n\\t\\t\\tpresumRow[i+1][j][0] = presumRow[i][j][0] + newGrid[i][j][0];\\n\\t\\t\\tpresumRow[i+1][j][1] = presumRow[i][j][1] + newGrid[i][j][1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor(int i=0; i<m; i++){\\n\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t//left and up\\n\\t\\t\\tint t = Math.min(presumCol[i][j][0] + presumRow[i][j][0] + newGrid[i][j][0], presumCol[i][j][1] + presumRow[i][j][1] + newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//left and down\\n\\t\\t\\tt = Math.min(presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0], presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and up\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t\\t//right and down\\n\\t\\t\\tt = Math.min(presumCol[i][n][0] - presumCol[i][j][0] + presumRow[m][j][0] - presumRow[i][j][0] - newGrid[i][j][0], presumCol[i][n][1] - presumCol[i][j][1] + presumRow[m][j][1] - presumRow[i][j][1] - newGrid[i][j][1]);\\n\\t\\t\\tans = Math.max(ans, t);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tnew_grid = [[[0,0] for _ in range(n)] for _ in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 2 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 2\\n\\t\\t\\tnew_grid[i][j][0] = count\\n\\t\\t\\tcount = 0\\n\\t\\t\\twhile grid[i][j] > 0 and grid[i][j] % 5 == 0:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tgrid[i][j] /= 5\\n\\t\\t\\tnew_grid[i][j][1] = count\\n\\tpresum_col, presum_row = [[[0,0] for _ in range(n+1)] for _ in range(m)], [[[0,0] for _ in range(n)] for _ in range(m+1)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tpresum_col[i][j+1][0] = presum_col[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_col[i][j+1][1] = presum_col[i][j][1] + new_grid[i][j][1]\\n\\tfor j in range(n):\\n\\t\\tfor i in range(m):\\n\\t\\t\\tpresum_row[i+1][j][0] = presum_row[i][j][0] + new_grid[i][j][0]\\n\\t\\t\\tpresum_row[i+1][j][1] = presum_row[i][j][1] + new_grid[i][j][1]\\n\\tans = 0\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\t# left and up\\n\\t\\t\\tt1 = min(presum_col[i][j][0] + presum_row[i][j][0] + new_grid[i][j][0], presum_col[i][j][1] + presum_row[i][j][1] + new_grid[i][j][1])\\n\\t\\t\\t# left and down\\n\\t\\t\\tt2 = min(presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0], presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1])\\n\\t\\t\\t# right and up\\n\\t\\t\\tt3 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[i][j][1])\\n\\t\\t\\t# right and down\\n\\t\\t\\tt4 = min(presum_col[i][n][0] - presum_col[i][j][0] + presum_row[m][j][0] - presum_row[i][j][0] - new_grid[i][j][0], presum_col[i][n][1] - presum_col[i][j][1] + presum_row[m][j][1] - presum_row[i][j][1] - new_grid[i][j][1])\\n\\t\\t\\tans = max(ans, t1, t2, t3, t4)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1958502,
                "title": "java-prefix-sum-100-faster-clean-code",
                "content": "Similar to https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5 but convert CPP features into java in a clear way.\\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // prefix matrix counting 2 and 5 \\n        int[][][] h = new int[m+1][n+1][2];\\n        int[][][] v = new int[m+1][n+1][2];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int two = 0;\\n                while (grid[i][j] % 2 == 0) {\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                \\n                int five = 0;\\n                while (grid[i][j] % 5 == 0) {\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                \\n                h[i][j+1][0] = h[i][j][0] + two;\\n                h[i][j+1][1] = h[i][j][1] + five;\\n                v[i+1][j][0] = v[i][j][0] + two;\\n                v[i+1][j][1] = v[i][j][1] + five;\\n                // System.out.printf(Arrays.toString(h[i][j+1]) + Arrays.toString(v[i+1][j]) + \" \");\\n            }\\n            // System.out.println();\\n        }\\n        \\n        // count trailing zeros\\n        int max = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int[] up = v[i+1][j]; // include [i,j]\\n                int[] down = new int[]{v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; // include [i,j]\\n                int[] left = h[i][j]; // exclude [i,j]\\n                int[] right = new int[]{h[i][n][0] - h[i][j+1][0], h[i][n][1] - h[i][j+1][1]}; // exclude [i,j]\\n                \\n                List<Integer> candidates = Arrays.asList(Math.min(up[0] + left[0], up[1] + left[1]),\\n                                                         Math.min(up[0] + right[0], up[1] + right[1]),\\n                                                         Math.min(down[0] + left[0], down[1] + left[1]),\\n                                                         Math.min(down[0] + right[0], down[1] + right[1]));\\n                max = Math.max(max, Collections.max(candidates));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // prefix matrix counting 2 and 5 \\n        int[][][] h = new int[m+1][n+1][2];\\n        int[][][] v = new int[m+1][n+1][2];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int two = 0;\\n                while (grid[i][j] % 2 == 0) {\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                \\n                int five = 0;\\n                while (grid[i][j] % 5 == 0) {\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                \\n                h[i][j+1][0] = h[i][j][0] + two;\\n                h[i][j+1][1] = h[i][j][1] + five;\\n                v[i+1][j][0] = v[i][j][0] + two;\\n                v[i+1][j][1] = v[i][j][1] + five;\\n                // System.out.printf(Arrays.toString(h[i][j+1]) + Arrays.toString(v[i+1][j]) + \" \");\\n            }\\n            // System.out.println();\\n        }\\n        \\n        // count trailing zeros\\n        int max = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int[] up = v[i+1][j]; // include [i,j]\\n                int[] down = new int[]{v[m][j][0] - v[i][j][0], v[m][j][1] - v[i][j][1]}; // include [i,j]\\n                int[] left = h[i][j]; // exclude [i,j]\\n                int[] right = new int[]{h[i][n][0] - h[i][j+1][0], h[i][n][1] - h[i][j+1][1]}; // exclude [i,j]\\n                \\n                List<Integer> candidates = Arrays.asList(Math.min(up[0] + left[0], up[1] + left[1]),\\n                                                         Math.min(up[0] + right[0], up[1] + right[1]),\\n                                                         Math.min(down[0] + left[0], down[1] + left[1]),\\n                                                         Math.min(down[0] + right[0], down[1] + right[1]));\\n                max = Math.max(max, Collections.max(candidates));\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958476,
                "title": "c-faster-than-100-c-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> check(int num){\\n        int a=0,b=0;\\n        while(num%2 == 0){\\n            num = num/2;\\n            a++;\\n        }\\n        while(num%5 == 0){\\n            num = num/5;\\n            b++;\\n        }\\n        return {a,b};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),p1,p2;\\n        vector<vector<vector<int>>> v(m, vector<vector<int>>(n, vector<int>(4,0)));\\n        for(int j=0;j<n;j++){// top to down\\n            for(int i=0;i<m;i++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(i==0){\\n                    p1 = v[i][j][0] = p.first;\\n                    p2 = v[i][j][1] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][0] = p1+p.first;\\n                    p2 = v[i][j][1] = p2+p.second;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){// left to right\\n            for(int j=0;j<n;j++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(j==0){\\n                    p1 = v[i][j][2] = p.first;\\n                    p2 = v[i][j][3] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][2] = p1+p.first;\\n                    p2 = v[i][j][3] = p2+p.second;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a,b;\\n                if(j-1>=0){\\n                    a = v[i][j][0] + v[i][j-1][2];\\n                    b = v[i][j][1] + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n){\\n                    a = v[i][j][0] + (v[i][n-1][2] - v[i][j][2]);\\n                    b = v[i][j][1] + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                ans = max(ans,min(v[i][j][0],v[i][j][1]));\\n                if(i-1 >= 0)\\n                    ans = max(ans,min(v[m-1][j][0]-v[i-1][j][0],v[m-1][j][1]-v[i-1][j][1]));\\n                else\\n                    ans = max(ans,min(v[m-1][j][0],v[m-1][j][1]));\\n                if(j-1>=0 && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j-1>=0){\\n                    a = (v[m-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j+1<n){\\n                    a = (v[m-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> check(int num){\\n        int a=0,b=0;\\n        while(num%2 == 0){\\n            num = num/2;\\n            a++;\\n        }\\n        while(num%5 == 0){\\n            num = num/5;\\n            b++;\\n        }\\n        return {a,b};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),p1,p2;\\n        vector<vector<vector<int>>> v(m, vector<vector<int>>(n, vector<int>(4,0)));\\n        for(int j=0;j<n;j++){// top to down\\n            for(int i=0;i<m;i++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(i==0){\\n                    p1 = v[i][j][0] = p.first;\\n                    p2 = v[i][j][1] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][0] = p1+p.first;\\n                    p2 = v[i][j][1] = p2+p.second;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){// left to right\\n            for(int j=0;j<n;j++){\\n                pair<int,int> p = check(grid[i][j]);\\n                if(j==0){\\n                    p1 = v[i][j][2] = p.first;\\n                    p2 = v[i][j][3] = p.second;\\n                }\\n                else{\\n                    p1 = v[i][j][2] = p1+p.first;\\n                    p2 = v[i][j][3] = p2+p.second;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int a,b;\\n                if(j-1>=0){\\n                    a = v[i][j][0] + v[i][j-1][2];\\n                    b = v[i][j][1] + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n){\\n                    a = v[i][j][0] + (v[i][n-1][2] - v[i][j][2]);\\n                    b = v[i][j][1] + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                ans = max(ans,min(v[i][j][0],v[i][j][1]));\\n                if(i-1 >= 0)\\n                    ans = max(ans,min(v[m-1][j][0]-v[i-1][j][0],v[m-1][j][1]-v[i-1][j][1]));\\n                else\\n                    ans = max(ans,min(v[m-1][j][0],v[m-1][j][1]));\\n                if(j-1>=0 && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j-1>=0){\\n                    a = (v[m-1][j][0]) + v[i][j-1][2];\\n                    b = (v[m-1][j][1]) + v[i][j-1][3];\\n                    ans = max(ans,min(a,b));\\n                }\\n                if(j+1<n && i-1>=0){\\n                    a = (v[m-1][j][0]-v[i-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]-v[i-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n                else if(j+1<n){\\n                    a = (v[m-1][j][0]) + (v[i][n-1][2] - v[i][j][2]);\\n                    b = (v[m-1][j][1]) + (v[i][n-1][3] - v[i][j][3]);\\n                    ans = max(ans,min(a,b));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958456,
                "title": "java-easy-to-read-prefix-sum-100",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int maxZeros = 0;\\n        int[][][] cnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors in the number\\n        int[][][] upcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors above\\n        int[][][] downcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors below\\n        int[][][] leftcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the left\\n        int[][][] rightcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the right\\n        for(int i=0;i<grid.length;i++){\\n            //2,5 factor number,left count aggregation\\n            for(int j=0;j<grid[0].length;j++){\\n                int n=grid[i][j];\\n                while(n%5==0){ //5 factor number\\n                        cnt[i][j][1]++;\\n                        n=n/5;\\n                }\\n                while(n%2==0){ //2 factor number\\n                        cnt[i][j][0]++;\\n                        n=n/2;\\n                } \\n                if(j>0){\\n                    leftcnt[i][j][1]=cnt[i][j-1][1]+leftcnt[i][j-1][1]; \\n                    leftcnt[i][j][0]=cnt[i][j-1][0]+leftcnt[i][j-1][0];\\n                }\\n            }\\n            //right count aggregation\\n            for(int j=grid[0].length-1;j>=0;j--){\\n                if(j<grid[0].length-1){\\n                    rightcnt[i][j][1]=cnt[i][j+1][1]+rightcnt[i][j+1][1]; \\n                    rightcnt[i][j][0]=cnt[i][j+1][0]+rightcnt[i][j+1][0];\\n                }\\n            }\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            //up count aggregation\\n            for(int i=0;i<grid.length;i++){\\n                if(i>0){\\n                    upcnt[i][j][1]=cnt[i-1][j][1]+upcnt[i-1][j][1]; \\n                    upcnt[i][j][0]=cnt[i-1][j][0]+upcnt[i-1][j][0];\\n                }\\n            }\\n            //down count aggregation\\n            for(int i=grid.length-1;i>=0;i--){\\n                if(i<grid.length-1){\\n                    downcnt[i][j][1]=cnt[i+1][j][1]+downcnt[i+1][j][1]; \\n                    downcnt[i][j][0]=cnt[i+1][j][0]+downcnt[i+1][j][0];\\n                }\\n            }\\n        }        \\n        int upleft=0,upright=0,downleft=0,downright=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                //how many zeros are in the product in 4 different cases\\n                upleft = Math.min((upcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                upright = Math.min((upcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                downleft = Math.min((downcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                downright = Math.min((downcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                int zeros = Math.max(Math.max(upleft,upright),Math.max(downleft,downright));\\n                if(zeros>maxZeros) maxZeros = zeros;\\n            }\\n        }\\n        return maxZeros;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int maxZeros = 0;\\n        int[][][] cnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors in the number\\n        int[][][] upcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors above\\n        int[][][] downcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors below\\n        int[][][] leftcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the left\\n        int[][][] rightcnt = new int[grid.length][grid[0].length][2];//record how many 2,5 factors on the right\\n        for(int i=0;i<grid.length;i++){\\n            //2,5 factor number,left count aggregation\\n            for(int j=0;j<grid[0].length;j++){\\n                int n=grid[i][j];\\n                while(n%5==0){ //5 factor number\\n                        cnt[i][j][1]++;\\n                        n=n/5;\\n                }\\n                while(n%2==0){ //2 factor number\\n                        cnt[i][j][0]++;\\n                        n=n/2;\\n                } \\n                if(j>0){\\n                    leftcnt[i][j][1]=cnt[i][j-1][1]+leftcnt[i][j-1][1]; \\n                    leftcnt[i][j][0]=cnt[i][j-1][0]+leftcnt[i][j-1][0];\\n                }\\n            }\\n            //right count aggregation\\n            for(int j=grid[0].length-1;j>=0;j--){\\n                if(j<grid[0].length-1){\\n                    rightcnt[i][j][1]=cnt[i][j+1][1]+rightcnt[i][j+1][1]; \\n                    rightcnt[i][j][0]=cnt[i][j+1][0]+rightcnt[i][j+1][0];\\n                }\\n            }\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            //up count aggregation\\n            for(int i=0;i<grid.length;i++){\\n                if(i>0){\\n                    upcnt[i][j][1]=cnt[i-1][j][1]+upcnt[i-1][j][1]; \\n                    upcnt[i][j][0]=cnt[i-1][j][0]+upcnt[i-1][j][0];\\n                }\\n            }\\n            //down count aggregation\\n            for(int i=grid.length-1;i>=0;i--){\\n                if(i<grid.length-1){\\n                    downcnt[i][j][1]=cnt[i+1][j][1]+downcnt[i+1][j][1]; \\n                    downcnt[i][j][0]=cnt[i+1][j][0]+downcnt[i+1][j][0];\\n                }\\n            }\\n        }        \\n        int upleft=0,upright=0,downleft=0,downright=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                //how many zeros are in the product in 4 different cases\\n                upleft = Math.min((upcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                upright = Math.min((upcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(upcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                downleft = Math.min((downcnt[i][j][0]+leftcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+leftcnt[i][j][1]+cnt[i][j][1]));\\n                downright = Math.min((downcnt[i][j][0]+rightcnt[i][j][0]+cnt[i][j][0]),(downcnt[i][j][1]+rightcnt[i][j][1]+cnt[i][j][1]));\\n                int zeros = Math.max(Math.max(upleft,upright),Math.max(downleft,downright));\\n                if(zeros>maxZeros) maxZeros = zeros;\\n            }\\n        }\\n        return maxZeros;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958455,
                "title": "java-100-prefix-sum",
                "content": "Please upvote if you like the solution:\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] gr = new int[m][n][3];\\n        int[][][] cg = new int[m][n][3];\\n        int[][][] rg = new int[m][n][3];\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                while (grid[i][j]%10==0) {\\n                    grid[i][j] = grid[i][j]/10;\\n                    gr[i][j][0]++;\\n                }\\n                while (grid[i][j]%5==0) {\\n                    grid[i][j] = grid[i][j]/5;\\n                    gr[i][j][1]++;\\n                }\\n                gr[i][j][2] = Integer.numberOfTrailingZeros(grid[i][j]);\\n            }\\n        }\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                if (i==0) {\\n                    cg[i][j][0] = gr[i][j][0];\\n                    cg[i][j][1] = gr[i][j][1];\\n                    cg[i][j][2] = gr[i][j][2];\\n                } else {\\n                    cg[i][j][0] = cg[i-1][j][0]+gr[i][j][0];\\n                    cg[i][j][1] = cg[i-1][j][1]+gr[i][j][1];\\n                    cg[i][j][2] = cg[i-1][j][2]+gr[i][j][2];                    \\n                }\\n                if (j==0) {\\n                    rg[i][j][0] = gr[i][j][0];\\n                    rg[i][j][1] = gr[i][j][1];\\n                    rg[i][j][2] = gr[i][j][2];\\n                } else {\\n                    rg[i][j][0] = rg[i][j-1][0]+gr[i][j][0];\\n                    rg[i][j][1] = rg[i][j-1][1]+gr[i][j][1];\\n                    rg[i][j][2] = rg[i][j-1][2]+gr[i][j][2];                    \\n                }\\n            }\\n        }\\n        int a = 0;\\n        for (int i=0;i<m;i++) {\\n            a = Math.max(a, rg[i][n-1][0]+Math.min(rg[i][n-1][1],rg[i][n-1][2]));\\n        }\\n        for (int j=0;j<n;j++) {\\n            a = Math.max(a, cg[m-1][j][0]+Math.min(cg[m-1][j][1],cg[m-1][j][2]));\\n        }\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                int t1 = rg[i][j][0] + cg[i][j][0] - gr[i][j][0] +\\n                    Math.min(rg[i][j][1]+cg[i][j][1]-gr[i][j][1],\\n                            rg[i][j][2]+cg[i][j][2]-gr[i][j][2]);\\n                a = Math.max(a, t1);\\n\\n                int t2 = rg[i][n-1][0]-rg[i][j][0]+cg[m-1][j][0]-cg[i][j][0]+gr[i][j][0] +\\n                    Math.min(rg[i][n-1][1]-rg[i][j][1]+cg[m-1][j][1]-cg[i][j][1]+gr[i][j][1], \\n                             rg[i][n-1][2]-rg[i][j][2]+cg[m-1][j][2]-cg[i][j][2]+gr[i][j][2]);\\n                a = Math.max(a, t2);\\n\\n                int t3 = rg[i][n-1][0]-rg[i][j][0]+cg[i][j][0] +\\n                    Math.min(rg[i][n-1][1]-rg[i][j][1]+cg[i][j][1], \\n                             rg[i][n-1][2]-rg[i][j][2]+cg[i][j][2]);\\n                a = Math.max(a, t3);\\n                \\n                int t4 = cg[m-1][j][0]-cg[i][j][0]+rg[i][j][0]+\\n                    Math.min(cg[m-1][j][1]-cg[i][j][1]+rg[i][j][1], \\n                             cg[m-1][j][2]-cg[i][j][2]+rg[i][j][2]);\\n                a = Math.max(a, t4);\\n                \\n            }\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] gr = new int[m][n][3];\\n        int[][][] cg = new int[m][n][3];\\n        int[][][] rg = new int[m][n][3];\\n        for (int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                while (grid[i][j]%10==0) {\\n                    grid[i][j] = grid[i][j]/10;\\n                    gr[i][j][0]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1958445,
                "title": "python-3-prefix-sum-of-facotrs-2-and-5-100-time-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/c0a777ef-91ba-42d3-a165-6aaa97534ea7_1650226772.4215481.png)\\n\\n1. Keep count of number of factors 2 and 5 for each element. \\n2. Run prefix sums for factor 2 horizontally and vertically, likewise for factor 5. \\n3. Take each grid[i][j] as the corner, there are be 4 candidate paths: left to corner to top, left to corner to bottom, right to corner to top, right to corner to bottom. Use the prefix sums and the count at [i][j] to find the maximum number of trailing zeros at [i][j].\\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache \\n        def func(v, target):\\n            if v < target or v % target:\\n                return 0, v\\n            c, v = func(v // target, target)\\n            return c + 1, v\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cnt = [[[0] * 2 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cnt[i][j][0], rem = func(grid[i][j], 2)\\n                cnt[i][j][1], _ = func(rem, 5)\\n        \\n        dp_h2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_h5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dp_h2[i][j] = dp_h2[i][j - 1] + cnt[i][j][0]\\n                dp_h5[i][j] = dp_h5[i][j - 1] + cnt[i][j][1]\\n        for j in range(n):\\n            for i in range(m):\\n                dp_v2[i][j] = dp_v2[i - 1][j] + cnt[i][j][0]\\n                dp_v5[i][j] = dp_v5[i - 1][j] + cnt[i][j][1]\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                n2 = cnt[i][j][0]\\n                n5 = cnt[i][j][1]\\n                lt = min(dp_h2[i][j - 1] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[i - 1][j] + n5)\\n                rt = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[i - 1][j] + n5)\\n                lb = min(dp_h2[i][j - 1] + dp_v2[m - 1][j] - dp_v2[i][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                rb = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[m - 1][j] - dp_v2[i][j] + n2,\\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                ans = max(ans, max(lt, rt, lb, rb))\\n        return ans\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache \\n        def func(v, target):\\n            if v < target or v % target:\\n                return 0, v\\n            c, v = func(v // target, target)\\n            return c + 1, v\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        cnt = [[[0] * 2 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                cnt[i][j][0], rem = func(grid[i][j], 2)\\n                cnt[i][j][1], _ = func(rem, 5)\\n        \\n        dp_h2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v2 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_h5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp_v5 = [[0] * (n + 1) for _ in range(m + 1)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                dp_h2[i][j] = dp_h2[i][j - 1] + cnt[i][j][0]\\n                dp_h5[i][j] = dp_h5[i][j - 1] + cnt[i][j][1]\\n        for j in range(n):\\n            for i in range(m):\\n                dp_v2[i][j] = dp_v2[i - 1][j] + cnt[i][j][0]\\n                dp_v5[i][j] = dp_v5[i - 1][j] + cnt[i][j][1]\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                n2 = cnt[i][j][0]\\n                n5 = cnt[i][j][1]\\n                lt = min(dp_h2[i][j - 1] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[i - 1][j] + n5)\\n                rt = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[i - 1][j] + n2, \\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[i - 1][j] + n5)\\n                lb = min(dp_h2[i][j - 1] + dp_v2[m - 1][j] - dp_v2[i][j] + n2, \\n                         dp_h5[i][j - 1] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                rb = min(dp_h2[i][n - 1] - dp_h2[i][j] + dp_v2[m - 1][j] - dp_v2[i][j] + n2,\\n                         dp_h5[i][n - 1] - dp_h5[i][j] + dp_v5[m - 1][j] - dp_v5[i][j] + n5)\\n                ans = max(ans, max(lt, rt, lb, rb))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958310,
                "title": "prefix-solution-need-improvement-for-ending-0-counts-by-mod-2-5",
                "content": "This\\'s what I got in the contest, didn\\'t satisfy the time limitation. We could optimize it by using mod 2 & 5 to reduce time complexity. Good learning experience tho.\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        r, c = len(grid), len(grid[0])\\n        v = [[1 for _ in range(c)] for _ in range(r)]\\n        h = [[1 for _ in range(c)] for _ in range(r)]\\n        \\n        def count_0(n):\\n            res = 0\\n            for ch in str(n)[::-1]:\\n                if ch != \\'0\\':\\n                    break\\n                else:\\n                    res += 1\\n            return res\\n        \\n        for i in range(r):\\n            cur = 1\\n            for j in range(c):\\n                cur *= grid[i][j]\\n                v[i][j] = cur\\n        for j in range(c):\\n            cur = 1\\n            for i in range(r):\\n                cur *= grid[i][j]\\n                h[i][j] = cur\\n        res = 0\\n        for i in range(r):\\n            for j in range(c):\\n                dr = h[i][j] * (v[i][c-1] // v[i][j]) # count cross number in h\\n                dl = (h[i][j] * v[i][j-1]) if (j > 0) else h[i][j] # count cross number in h\\n                ur = (h[r-1][j] // h[i][j]) * (v[i][c-1] // v[i][j]) * grid[i][j] # count cross number deperately\\n                ul = (h[r-1][j] // h[i][j]) * v[i][j] # count cross number in v\\n                res = max(res, count_0(dr), count_0(dl), count_0(ur), count_0(ul))\\n        return res\\n```\\ncompared with answer posted by https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955502/Python-Prefix-Sum-O(m-*-n):\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        r, c = len(grid), len(grid[0])\\n        v = [[1 for _ in range(c)] for _ in range(r)]\\n        h = [[1 for _ in range(c)] for _ in range(r)]\\n        \\n        def count_0(n):\\n            res = 0\\n            for ch in str(n)[::-1]:\\n                if ch != \\'0\\':\\n                    break\\n                else:\\n                    res += 1\\n            return res\\n        \\n        for i in range(r):\\n            cur = 1\\n            for j in range(c):\\n                cur *= grid[i][j]\\n                v[i][j] = cur\\n        for j in range(c):\\n            cur = 1\\n            for i in range(r):\\n                cur *= grid[i][j]\\n                h[i][j] = cur\\n        res = 0\\n        for i in range(r):\\n            for j in range(c):\\n                dr = h[i][j] * (v[i][c-1] // v[i][j]) # count cross number in h\\n                dl = (h[i][j] * v[i][j-1]) if (j > 0) else h[i][j] # count cross number in h\\n                ur = (h[r-1][j] // h[i][j]) * (v[i][c-1] // v[i][j]) * grid[i][j] # count cross number deperately\\n                ul = (h[r-1][j] // h[i][j]) * v[i][j] # count cross number in v\\n                res = max(res, count_0(dr), count_0(dl), count_0(ur), count_0(ul))\\n        return res\\n```\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m, n = len(grid), len(grid[0])\\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                temp= grid[i][j]\\n                while temp % 2 == 0:\\n                    prefixH[i][j + 1][0] += 1\\n                    prefixV[i + 1][j][0] += 1\\n                    temp //= 2\\n                while temp % 5 == 0:\\n                    prefixH[i][j + 1][1] += 1\\n                    prefixV[i + 1][j][1] += 1\\n                    temp //= 5\\n                for k in range(2):\\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\\n        for i in range(m):\\n            for j in range(n):\\n                left = prefixH[i][j]\\n                up = prefixV[i][j]\\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\\n                for k in range(2):\\n                    LU[k] += left[k] + up[k] + center[k]\\n                    LD[k] += left[k] + down[k] + center[k]\\n                    RU[k] += right[k] + up[k] + center[k]\\n                    RD[k] += right[k] + down[k] + center[k]\\n                ans = max(ans,\\n                          min(LU[0], LU[1]),\\n                          min(LD[0], LD[1]),\\n                          min(RU[0], RU[1]),\\n                          min(RD[0], RD[1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958055,
                "title": "python-intuitive-method",
                "content": "A very intuitive method. Once figuring out the logistics, coding should not be too difficult (but a bit lengthy).\\n\\nPre-calc 2s and 5s for all numbers in 0-1000. The number of trailings zeros should be min(2s,5s). \\n\\nCalculate the maximum trailing 0s for each row/column and update the res (no turn).\\nFor each cell, count all the 2s and 5s in 4 directions (top, down, left, right). Calculate the total 0s with 4 combinations (top+left, top+right, down+left, down+right) and update the res (one turn).\\n\\n\\n```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        dic5 = [0]*1001\\n        dic2 = [0]*1001\\n        for i in range(1001):\\n            for j in range(11):\\n                if i%(2**j)!=0:\\n                    break\\n                else:\\n                    dic2[i] = j\\n            for j in range(6):\\n                if i%(5**j)!=0:\\n                    break\\n                else:\\n                    dic5[i] = j\\n        \\n        \\n        n,m = len(grid),len(grid[0])\\n        \\n        vertical = [[[0,0] for i in range(m)] for j in range(n)]\\n        horizon = [[[0,0] for i in range(m)] for j in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                vertical[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                horizon[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                if i>0:\\n                    vertical[i][j][0] += vertical[i-1][j][0]\\n                    vertical[i][j][1] += vertical[i-1][j][1]\\n                if j>0:\\n                    horizon[i][j][0]+=horizon[i][j-1][0]\\n                    horizon[i][j][1] += horizon[i][j-1][1]\\n        \\n        res = 0\\n        for i in range(n):\\n            tmp = min(horizon[i][m-1][0],horizon[i][m-1][1]) # row\\n            res = max(tmp,res)\\n        for i in range(m):\\n            tmp = min(vertical[n-1][i][0],vertical[n-1][i][1]) #column\\n            res = max(tmp,res)\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                tmp = min(horizon[i][j][0]+vertical[i][j][0]-dic2[grid[i][j]],horizon[i][j][1]+vertical[i][j][1]-dic5[grid[i][j]]) # left, top \\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[i][j][0],horizon[i][m-1][1]-horizon[i][j][1]+vertical[i][j][1]) #right, top\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0],horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]) #left, down\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0]+dic2[grid[i][j]],horizon[i][m-1][1]-horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]+dic5[grid[i][j]]) # right, down\\n                res = max(tmp,res)\\n        return res\\n                              \\n```",
                "solutionTags": [],
                "code": "```\\ndef maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        dic5 = [0]*1001\\n        dic2 = [0]*1001\\n        for i in range(1001):\\n            for j in range(11):\\n                if i%(2**j)!=0:\\n                    break\\n                else:\\n                    dic2[i] = j\\n            for j in range(6):\\n                if i%(5**j)!=0:\\n                    break\\n                else:\\n                    dic5[i] = j\\n        \\n        \\n        n,m = len(grid),len(grid[0])\\n        \\n        vertical = [[[0,0] for i in range(m)] for j in range(n)]\\n        horizon = [[[0,0] for i in range(m)] for j in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                vertical[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                horizon[i][j] = [dic2[grid[i][j]],dic5[grid[i][j]]]\\n                if i>0:\\n                    vertical[i][j][0] += vertical[i-1][j][0]\\n                    vertical[i][j][1] += vertical[i-1][j][1]\\n                if j>0:\\n                    horizon[i][j][0]+=horizon[i][j-1][0]\\n                    horizon[i][j][1] += horizon[i][j-1][1]\\n        \\n        res = 0\\n        for i in range(n):\\n            tmp = min(horizon[i][m-1][0],horizon[i][m-1][1]) # row\\n            res = max(tmp,res)\\n        for i in range(m):\\n            tmp = min(vertical[n-1][i][0],vertical[n-1][i][1]) #column\\n            res = max(tmp,res)\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                tmp = min(horizon[i][j][0]+vertical[i][j][0]-dic2[grid[i][j]],horizon[i][j][1]+vertical[i][j][1]-dic5[grid[i][j]]) # left, top \\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[i][j][0],horizon[i][m-1][1]-horizon[i][j][1]+vertical[i][j][1]) #right, top\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0],horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]) #left, down\\n                res = max(tmp,res)\\n                tmp = min(horizon[i][m-1][0]-horizon[i][j][0]+vertical[n-1][j][0]-vertical[i][j][0]+dic2[grid[i][j]],horizon[i][m-1][1]-horizon[i][j][1]+vertical[n-1][j][1]-vertical[i][j][1]+dic5[grid[i][j]]) # right, down\\n                res = max(tmp,res)\\n        return res\\n                              \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1957926,
                "title": "c-pure-greedy-implementation-beats-100",
                "content": "## Pure greedy implementation\\n```\\ntypedef pair<int,int> pii;\\n\\npii operator+(const pii &a, const pii &b) {\\n    return {a.first + b.first, a.second + b.second};\\n}\\n\\npii operator-(const pii &a, const pii &b) {\\n    return {a.first - b.first, a.second - b.second};\\n}\\n\\nclass Solution {\\npublic:\\n    friend pii operator+(const pii &a, const pii &b);\\n    friend pii operator-(const pii &a, const pii &b);\\n    \\n    pii cnt(int n) {\\n        int x = 0, y = 0;\\n        while (n % (int)pow(2, x) == 0) x++;\\n        while (n % (int)pow(5, y) == 0) y++;\\n        return {x-1, y-1};\\n    }\\n     \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pii>> hor(n + 1, vector<pii>(m + 1));\\n        vector<vector<pii>> ver = hor;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii count = cnt(grid[i][j]);\\n                hor[i + 1][j + 1] = hor[i + 1][j] + count;\\n                ver[i + 1][j + 1] = ver[i][j + 1] + count;\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii u = ver[i + 1][j + 1];\\n                pii d = ver[n][j + 1] - ver[i][j + 1];\\n                pii l = hor[i + 1][j];\\n                pii r = hor[i + 1][m] - hor[i + 1][j + 1];\\n                int w = min(u.first + l.first, u.second + l.second);\\n                int x = min(u.first + r.first, u.second + r.second);\\n                int y = min(d.first + l.first, d.second + l.second);\\n                int z = min(d.first + r.first, d.second + r.second);\\n                res = max({res, w, x, y, z});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nU can reduce functions and make code ugly!\\n\\n**Time Complexity:** O(n * m)\\n**Space Complexity:** O(n * m)",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef pair<int,int> pii;\\n\\npii operator+(const pii &a, const pii &b) {\\n    return {a.first + b.first, a.second + b.second};\\n}\\n\\npii operator-(const pii &a, const pii &b) {\\n    return {a.first - b.first, a.second - b.second};\\n}\\n\\nclass Solution {\\npublic:\\n    friend pii operator+(const pii &a, const pii &b);\\n    friend pii operator-(const pii &a, const pii &b);\\n    \\n    pii cnt(int n) {\\n        int x = 0, y = 0;\\n        while (n % (int)pow(2, x) == 0) x++;\\n        while (n % (int)pow(5, y) == 0) y++;\\n        return {x-1, y-1};\\n    }\\n     \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pii>> hor(n + 1, vector<pii>(m + 1));\\n        vector<vector<pii>> ver = hor;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii count = cnt(grid[i][j]);\\n                hor[i + 1][j + 1] = hor[i + 1][j] + count;\\n                ver[i + 1][j + 1] = ver[i][j + 1] + count;\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pii u = ver[i + 1][j + 1];\\n                pii d = ver[n][j + 1] - ver[i][j + 1];\\n                pii l = hor[i + 1][j];\\n                pii r = hor[i + 1][m] - hor[i + 1][j + 1];\\n                int w = min(u.first + l.first, u.second + l.second);\\n                int x = min(u.first + r.first, u.second + r.second);\\n                int y = min(d.first + l.first, d.second + l.second);\\n                int z = min(d.first + r.first, d.second + r.second);\\n                res = max({res, w, x, y, z});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957814,
                "title": "python",
                "content": "todo explain\\n\\n```python\\nclass Solution:\\n     def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n              v1\\n          h1  x   h2\\n              v2\\n        [h2, h5, v2, v5]\\n        \"\"\"\\n\\n        def d2(x: int):\\n            return 0 if x % 2 > 0 else 1 + d2(x//2)\\n\\n        def d5(x: int):\\n            return 0 if x % 5 > 0 else 1 + d5(x // 5)\\n\\n        m, n = len(grid), len(grid[0])\\n        stat = [[[0, 0, 0, 0] for _ in range(n + 2)] for _ in range(m + 2)]\\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                x2, x5 = d2(x), d5(x)\\n                h2, h5, v2, v5 = stat[i + 1][j][0], stat[i + 1][j][1], stat[i][j + 1][2], stat[i][j + 1][3]\\n                stat[i + 1][j + 1] = [h2 + x2, h5 + x5, v2 + x2, v5 + x5]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                h1, h2, v1, v2 = stat[i + 1][j+1][:2], [stat[i + 1][n][0] - stat[i + 1][j][0],\\n                                                      stat[i + 1][n][1] - stat[i + 1][j][1]], \\\\\\n                                 stat[i][j + 1][2:], [stat[m][j + 1][2] - stat[i + 1][j + 1][2],\\n                                                      stat[m][j + 1][3] - stat[i + 1][j + 1][3]]\\n                cand = 0\\n                for (h2, h5), (v2, v5) in product([h1, h2], [v1, v2]):\\n                    max_min = min(h2 + v2, h5 + v5)\\n                    cand = max(cand, max_min)\\n                res = max(res, cand)\\n        return res   \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n     def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n              v1\\n          h1  x   h2\\n              v2\\n        [h2, h5, v2, v5]\\n        \"\"\"\\n\\n        def d2(x: int):\\n            return 0 if x % 2 > 0 else 1 + d2(x//2)\\n\\n        def d5(x: int):\\n            return 0 if x % 5 > 0 else 1 + d5(x // 5)\\n\\n        m, n = len(grid), len(grid[0])\\n        stat = [[[0, 0, 0, 0] for _ in range(n + 2)] for _ in range(m + 2)]\\n        for i in range(m):\\n            for j in range(n):\\n                x = grid[i][j]\\n                x2, x5 = d2(x), d5(x)\\n                h2, h5, v2, v5 = stat[i + 1][j][0], stat[i + 1][j][1], stat[i][j + 1][2], stat[i][j + 1][3]\\n                stat[i + 1][j + 1] = [h2 + x2, h5 + x5, v2 + x2, v5 + x5]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                h1, h2, v1, v2 = stat[i + 1][j+1][:2], [stat[i + 1][n][0] - stat[i + 1][j][0],\\n                                                      stat[i + 1][n][1] - stat[i + 1][j][1]], \\\\\\n                                 stat[i][j + 1][2:], [stat[m][j + 1][2] - stat[i + 1][j + 1][2],\\n                                                      stat[m][j + 1][3] - stat[i + 1][j + 1][3]]\\n                cand = 0\\n                for (h2, h5), (v2, v5) in product([h1, h2], [v1, v2]):\\n                    max_min = min(h2 + v2, h5 + v5)\\n                    cand = max(cand, max_min)\\n                res = max(res, cand)\\n        return res   \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957715,
                "title": "python-solution-not-the-simplest-but-works-within-time-limit",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        #####################################################\\n        # first, compute the highest powers of 2 and 5 for each element\\n        #####################################################\\n        pow25 = [[(0, 0) for i in range(n)] for j in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                k = 0\\n                while grid[i][j] % pow(2,k) == 0:\\n                    k += 1\\n                \\n                l = 0\\n                while grid[i][j] % pow(5,l) == 0:\\n                    l += 1\\n                pow25[i][j] = (k-1, l-1)\\n\\n\\n        #####################################################\\n        # next, compute the sums of pow25 for cell i, j, from up, down, left, right\\n        # up2 - sum of all powers of 2 from top to current cell i,j\\n        # left2 - sum of all powers of 2 from left to current cell i,j\\n        # down2 - sum of all powers of 2 from bottom to current cell i,j\\n        # right2 - sum of all powers of 2 from right to current cell i,j\\n        # up5 - sum of all powers of 5 from top to current cell i,j\\n        # left5 - sum of all powers of 5 from left to current cell i,j\\n        # down5 - sum of all powers of 5 from bottom to current cell i,j\\n        # right5 - sum of all powers of 5 from right to current cell i,\\n        #####################################################\\n        up2 = [[0 for i in range(n)] for j in range(m)]\\n        up5 = [[0 for i in range(n)] for j in range(m)]\\n        down2 = [[0 for i in range(n)] for j in range(m)]\\n        down5 = [[0 for i in range(n)] for j in range(m)]\\n        left2 = [[0 for i in range(n)] for j in range(m)]\\n        left5 = [[0 for i in range(n)] for j in range(m)]\\n        right2 = [[0 for i in range(n)] for j in range(m)]\\n        right5 = [[0 for i in range(n)] for j in range(m)]\\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    up2[i][j] = pow25[i][j][0]\\n                    up5[i][j] = pow25[i][j][1]\\n                else:\\n                    up2[i][j] = up2[i-1][j] + pow25[i][j][0]\\n                    up5[i][j] = up5[i-1][j] + pow25[i][j][1]\\n\\n        for j in range(n):\\n            for i in reversed(range(m)):\\n                if i == m-1:\\n                    down2[i][j] = pow25[i][j][0]\\n                    down5[i][j] = pow25[i][j][1]\\n                else:\\n                    down2[i][j] = down2[i+1][j] + pow25[i][j][0]\\n                    down5[i][j] = down5[i+1][j] + pow25[i][j][1]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left2[i][j] = pow25[i][j][0]\\n                    left5[i][j] = pow25[i][j][1]\\n                else:\\n                    left2[i][j] = left2[i][j-1] + pow25[i][j][0]\\n                    left5[i][j] = left5[i][j-1] + pow25[i][j][1]\\n                \\n        for i in range(m):\\n            for j in reversed(range(n)):\\n                if j == n-1:\\n                    right2[i][j] = pow25[i][j][0]\\n                    right5[i][j] = pow25[i][j][1]\\n                else:\\n                    right2[i][j] = right2[i][j+1] + pow25[i][j][0]\\n                    right5[i][j] = right5[i][j+1] + pow25[i][j][1]\\n\\n        #####################################################\\n        # to avoid double counting when adding up+left, up+right, down+left, down+right\\n        # we remove cell i,j from left2, left5, right2, right5\\n        #####################################################\\n        for i in range(m):\\n            for j in range(n):\\n                left2[i][j] -= pow25[i][j][0]                \\n                left5[i][j] -= pow25[i][j][1]\\n                right2[i][j] -= pow25[i][j][0]                \\n                right5[i][j] -= pow25[i][j][1]\\n\\n\\n        #####################################################\\n        # Finally compute max trailing zeroes\\n        #####################################################\\n        max_trailing_zeroes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                score = max(\\n                    min(up2[i][j] + left2[i][j], up5[i][j] + left5[i][j]),\\n                    min(up2[i][j] + right2[i][j], up5[i][j] + right5[i][j]),\\n                    min(down2[i][j] + left2[i][j], down5[i][j] + left5[i][j]),\\n                    min(down2[i][j] + right2[i][j], down5[i][j] + right5[i][j])\\n                )\\n                if score > max_trailing_zeroes:\\n                    max_trailing_zeroes = score\\n                    \\n        return max_trailing_zeroes\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        #####################################################\\n        # first, compute the highest powers of 2 and 5 for each element\\n        #####################################################\\n        pow25 = [[(0, 0) for i in range(n)] for j in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                k = 0\\n                while grid[i][j] % pow(2,k) == 0:\\n                    k += 1\\n                \\n                l = 0\\n                while grid[i][j] % pow(5,l) == 0:\\n                    l += 1\\n                pow25[i][j] = (k-1, l-1)\\n\\n\\n        #####################################################\\n        # next, compute the sums of pow25 for cell i, j, from up, down, left, right\\n        # up2 - sum of all powers of 2 from top to current cell i,j\\n        # left2 - sum of all powers of 2 from left to current cell i,j\\n        # down2 - sum of all powers of 2 from bottom to current cell i,j\\n        # right2 - sum of all powers of 2 from right to current cell i,j\\n        # up5 - sum of all powers of 5 from top to current cell i,j\\n        # left5 - sum of all powers of 5 from left to current cell i,j\\n        # down5 - sum of all powers of 5 from bottom to current cell i,j\\n        # right5 - sum of all powers of 5 from right to current cell i,\\n        #####################################################\\n        up2 = [[0 for i in range(n)] for j in range(m)]\\n        up5 = [[0 for i in range(n)] for j in range(m)]\\n        down2 = [[0 for i in range(n)] for j in range(m)]\\n        down5 = [[0 for i in range(n)] for j in range(m)]\\n        left2 = [[0 for i in range(n)] for j in range(m)]\\n        left5 = [[0 for i in range(n)] for j in range(m)]\\n        right2 = [[0 for i in range(n)] for j in range(m)]\\n        right5 = [[0 for i in range(n)] for j in range(m)]\\n\\n        for j in range(n):\\n            for i in range(m):\\n                if i == 0:\\n                    up2[i][j] = pow25[i][j][0]\\n                    up5[i][j] = pow25[i][j][1]\\n                else:\\n                    up2[i][j] = up2[i-1][j] + pow25[i][j][0]\\n                    up5[i][j] = up5[i-1][j] + pow25[i][j][1]\\n\\n        for j in range(n):\\n            for i in reversed(range(m)):\\n                if i == m-1:\\n                    down2[i][j] = pow25[i][j][0]\\n                    down5[i][j] = pow25[i][j][1]\\n                else:\\n                    down2[i][j] = down2[i+1][j] + pow25[i][j][0]\\n                    down5[i][j] = down5[i+1][j] + pow25[i][j][1]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if j == 0:\\n                    left2[i][j] = pow25[i][j][0]\\n                    left5[i][j] = pow25[i][j][1]\\n                else:\\n                    left2[i][j] = left2[i][j-1] + pow25[i][j][0]\\n                    left5[i][j] = left5[i][j-1] + pow25[i][j][1]\\n                \\n        for i in range(m):\\n            for j in reversed(range(n)):\\n                if j == n-1:\\n                    right2[i][j] = pow25[i][j][0]\\n                    right5[i][j] = pow25[i][j][1]\\n                else:\\n                    right2[i][j] = right2[i][j+1] + pow25[i][j][0]\\n                    right5[i][j] = right5[i][j+1] + pow25[i][j][1]\\n\\n        #####################################################\\n        # to avoid double counting when adding up+left, up+right, down+left, down+right\\n        # we remove cell i,j from left2, left5, right2, right5\\n        #####################################################\\n        for i in range(m):\\n            for j in range(n):\\n                left2[i][j] -= pow25[i][j][0]                \\n                left5[i][j] -= pow25[i][j][1]\\n                right2[i][j] -= pow25[i][j][0]                \\n                right5[i][j] -= pow25[i][j][1]\\n\\n\\n        #####################################################\\n        # Finally compute max trailing zeroes\\n        #####################################################\\n        max_trailing_zeroes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                score = max(\\n                    min(up2[i][j] + left2[i][j], up5[i][j] + left5[i][j]),\\n                    min(up2[i][j] + right2[i][j], up5[i][j] + right5[i][j]),\\n                    min(down2[i][j] + left2[i][j], down5[i][j] + left5[i][j]),\\n                    min(down2[i][j] + right2[i][j], down5[i][j] + right5[i][j])\\n                )\\n                if score > max_trailing_zeroes:\\n                    max_trailing_zeroes = score\\n                    \\n        return max_trailing_zeroes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957524,
                "title": "java-100-tc-100-sc",
                "content": "Not a good problem, didn\\'t see any algorithem trick. Hoping just because I didn\\'t find it. \\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][][] scoreMatrix = new int[n][m][3];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                scoreMatrix[i][j] = getScore(grid[i][j]);\\n            }\\n        }\\n        \\n        int[][] rowInfo = new int[n][3];\\n        int[][] columnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                rowInfo[i][0]+=scoreMatrix[i][j][0];\\n                columnInfo[j][0]+=scoreMatrix[i][j][0];\\n                rowInfo[i][1]+=scoreMatrix[i][j][1];\\n                columnInfo[j][1]+=scoreMatrix[i][j][1];\\n                rowInfo[i][2]+=scoreMatrix[i][j][2];\\n                columnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        \\n        int[][] curRowInfo = new int[n][3];\\n        int[][] curColumnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int p1 = Math.max(\\n                    getPathScore(curRowInfo[i], curColumnInfo[j], scoreMatrix[i][j]),\\n                    getPathScore(curRowInfo[i], getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int p2 = Math.max(\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), curColumnInfo[j],scoreMatrix[i][j]),\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int curRes = Math.max(p1,p2);\\n                res = Math.max(res, curRes);\\n                \\n                curRowInfo[i][0]+=scoreMatrix[i][j][0];\\n                curColumnInfo[j][0]+=scoreMatrix[i][j][0];\\n                curRowInfo[i][1]+=scoreMatrix[i][j][1];\\n                curColumnInfo[j][1]+=scoreMatrix[i][j][1];\\n                curRowInfo[i][2]+=scoreMatrix[i][j][2];\\n                curColumnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    private int[] getRest(int[] cur, int[] total, int[] value){\\n        int[] res = new int[]{  total[0]-cur[0]-value[0], \\n                              total[1]-cur[1]-value[1], \\n                              total[2]-cur[2]-value[2]    };\\n        return res;\\n    }\\n    \\n    private int getPathScore(int[] path1, int[] path2, int[] cur){\\n        int res = path1[0] + path2[0] + cur[0];\\n        res+= Math.min(path1[1]+path2[1]+cur[1], path1[2]+path2[2]+cur[2]);\\n        return res;\\n    }\\n    \\n    private int[] getScore(int num){\\n        int[] res = new int[3];\\n        while(num%10==0 && num!=0){\\n            num = num/10;\\n            res[0]++;\\n        }\\n        while(num%5==0 && num!=0){\\n            num = num/5;\\n            res[2]++;\\n        }\\n        while(num%2==0 && num!=0){\\n            num = num/2;\\n            res[1]++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][][] scoreMatrix = new int[n][m][3];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                scoreMatrix[i][j] = getScore(grid[i][j]);\\n            }\\n        }\\n        \\n        int[][] rowInfo = new int[n][3];\\n        int[][] columnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                rowInfo[i][0]+=scoreMatrix[i][j][0];\\n                columnInfo[j][0]+=scoreMatrix[i][j][0];\\n                rowInfo[i][1]+=scoreMatrix[i][j][1];\\n                columnInfo[j][1]+=scoreMatrix[i][j][1];\\n                rowInfo[i][2]+=scoreMatrix[i][j][2];\\n                columnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        \\n        int[][] curRowInfo = new int[n][3];\\n        int[][] curColumnInfo = new int[m][3];\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int p1 = Math.max(\\n                    getPathScore(curRowInfo[i], curColumnInfo[j], scoreMatrix[i][j]),\\n                    getPathScore(curRowInfo[i], getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int p2 = Math.max(\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), curColumnInfo[j],scoreMatrix[i][j]),\\n                    getPathScore(getRest(curRowInfo[i], rowInfo[i], scoreMatrix[i][j]), getRest(curColumnInfo[j], columnInfo[j], scoreMatrix[i][j]),scoreMatrix[i][j])\\n                );\\n                \\n                int curRes = Math.max(p1,p2);\\n                res = Math.max(res, curRes);\\n                \\n                curRowInfo[i][0]+=scoreMatrix[i][j][0];\\n                curColumnInfo[j][0]+=scoreMatrix[i][j][0];\\n                curRowInfo[i][1]+=scoreMatrix[i][j][1];\\n                curColumnInfo[j][1]+=scoreMatrix[i][j][1];\\n                curRowInfo[i][2]+=scoreMatrix[i][j][2];\\n                curColumnInfo[j][2]+=scoreMatrix[i][j][2];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    private int[] getRest(int[] cur, int[] total, int[] value){\\n        int[] res = new int[]{  total[0]-cur[0]-value[0], \\n                              total[1]-cur[1]-value[1], \\n                              total[2]-cur[2]-value[2]    };\\n        return res;\\n    }\\n    \\n    private int getPathScore(int[] path1, int[] path2, int[] cur){\\n        int res = path1[0] + path2[0] + cur[0];\\n        res+= Math.min(path1[1]+path2[1]+cur[1], path1[2]+path2[2]+cur[2]);\\n        return res;\\n    }\\n    \\n    private int[] getScore(int num){\\n        int[] res = new int[3];\\n        while(num%10==0 && num!=0){\\n            num = num/10;\\n            res[0]++;\\n        }\\n        while(num%5==0 && num!=0){\\n            num = num/5;\\n            res[2]++;\\n        }\\n        while(num%2==0 && num!=0){\\n            num = num/2;\\n            res[1]++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957421,
                "title": "golang-prefix-sum",
                "content": "```\\nfunc maxTrailingZeros(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tres := 0\\n\\thp := make([][][]int, m)\\n\\tvp := make([][][]int, m)\\n\\tfor i := range hp {\\n\\t\\thp[i] = make([][]int, n)\\n\\t\\tvp[i] = make([][]int, n)\\n\\t\\tfor j := range hp[i] {\\n\\t\\t\\thp[i][j] = make([]int, 2)\\n\\t\\t\\tvp[i][j] = make([]int, 2)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif j == 0 {\\n\\t\\t\\t\\thp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thp[i][j][0] = hp[i][j-1][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = hp[i][j-1][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\tvp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvp[i][j][0] = vp[i-1][j][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = vp[i-1][j][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tres = max(res, min(hp[i][j][0]+vp[i][j][0]-factors(grid[i][j], 2), hp[i][j][1]+vp[i][j][1]-factors(grid[i][j], 5)))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[i][j][0], hp[i][n-1][1]-hp[i][j][1]+vp[i][j][1]))\\n\\t\\t\\tres = max(res, min(vp[m-1][j][0]-vp[i][j][0]+hp[i][j][0], vp[m-1][j][1]-vp[i][j][1]+hp[i][j][1]))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[m-1][j][0]-vp[i][j][0]+factors(grid[i][j], 2), hp[i][n-1][1]-hp[i][j][1]+vp[m-1][j][1]-vp[i][j][1]+factors(grid[i][j], 5)))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\nfunc factors(num, f int) int {\\n\\tif num%f == 0 {\\n\\t\\treturn factors(num/f, f) + 1\\n\\t}\\n\\treturn 0\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc min (a, b int) int {\\n    if a < b {\\n         return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nfunc maxTrailingZeros(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tres := 0\\n\\thp := make([][][]int, m)\\n\\tvp := make([][][]int, m)\\n\\tfor i := range hp {\\n\\t\\thp[i] = make([][]int, n)\\n\\t\\tvp[i] = make([][]int, n)\\n\\t\\tfor j := range hp[i] {\\n\\t\\t\\thp[i][j] = make([]int, 2)\\n\\t\\t\\tvp[i][j] = make([]int, 2)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif j == 0 {\\n\\t\\t\\t\\thp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thp[i][j][0] = hp[i][j-1][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\thp[i][j][1] = hp[i][j-1][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\tvp[i][j][0] = factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = factors(grid[i][j], 5)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvp[i][j][0] = vp[i-1][j][0] + factors(grid[i][j], 2)\\n\\t\\t\\t\\tvp[i][j][1] = vp[i-1][j][1] + factors(grid[i][j], 5)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tres = max(res, min(hp[i][j][0]+vp[i][j][0]-factors(grid[i][j], 2), hp[i][j][1]+vp[i][j][1]-factors(grid[i][j], 5)))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[i][j][0], hp[i][n-1][1]-hp[i][j][1]+vp[i][j][1]))\\n\\t\\t\\tres = max(res, min(vp[m-1][j][0]-vp[i][j][0]+hp[i][j][0], vp[m-1][j][1]-vp[i][j][1]+hp[i][j][1]))\\n\\t\\t\\tres = max(res, min(hp[i][n-1][0]-hp[i][j][0]+vp[m-1][j][0]-vp[i][j][0]+factors(grid[i][j], 2), hp[i][n-1][1]-hp[i][j][1]+vp[m-1][j][1]-vp[i][j][1]+factors(grid[i][j], 5)))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\nfunc factors(num, f int) int {\\n\\tif num%f == 0 {\\n\\t\\treturn factors(num/f, f) + 1\\n\\t}\\n\\treturn 0\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc min (a, b int) int {\\n    if a < b {\\n         return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957375,
                "title": "c-solution-factors-of-2-and-5",
                "content": "\\t  int maxTrailingZeros(vector<vector<int>>& arr) {\\n         \\n        int n = arr.size(), m = arr[0].size(), ans = INT_MIN;\\n        \\n        vector<vector<pair<int, int>> > pref(n, vector<pair<int, int>> (m)), suf(n, vector<pair<int, int>> (m));\\n        \\n        for(int i = 0; i < n; i++) {  // prefix\\n            for(int j = 0; j < m; j++) {\\n                int x = arr[i][j], two = 0, five = 0;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                pref[i][j].first = two;\\n                pref[i][j].second = five;\\n                \\n                if(j > 0) {\\n                    pref[i][j].first += pref[i][j - 1].first;\\n                    pref[i][j].second += pref[i][j - 1].second;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {  // suffix\\n            for(int j = m - 1; j >= 0; j--) {\\n                int x = arr[i][j], two = 0, five = 0;;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                suf[i][j].first = two;\\n                suf[i][j].second = five;\\n                \\n                if(j < m - 1) {\\n                    suf[i][j].first += suf[i][j + 1].first;\\n                    suf[i][j].second += suf[i][j + 1].second;\\n                }\\n            }\\n        }\\n        \\n        \\n        //      |    |\\n        //      |    |\\n        //      |    |\\n        //  ____|    |______  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {  \\n            \\n            int two = 0, five = 0;\\n            for(int row = 0; row < n; row++) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        // _____      ______\\n        //      |    |\\n        //      |    |\\n        //      |    |  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {\\n            \\n            int two = 0, five = 0;\\n            for(int row = n - 1; row >= 0; row--) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t  int maxTrailingZeros(vector<vector<int>>& arr) {\\n         \\n        int n = arr.size(), m = arr[0].size(), ans = INT_MIN;\\n        \\n        vector<vector<pair<int, int>> > pref(n, vector<pair<int, int>> (m)), suf(n, vector<pair<int, int>> (m));\\n        \\n        for(int i = 0; i < n; i++) {  // prefix\\n            for(int j = 0; j < m; j++) {\\n                int x = arr[i][j], two = 0, five = 0;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                pref[i][j].first = two;\\n                pref[i][j].second = five;\\n                \\n                if(j > 0) {\\n                    pref[i][j].first += pref[i][j - 1].first;\\n                    pref[i][j].second += pref[i][j - 1].second;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++) {  // suffix\\n            for(int j = m - 1; j >= 0; j--) {\\n                int x = arr[i][j], two = 0, five = 0;;\\n                \\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                \\n                suf[i][j].first = two;\\n                suf[i][j].second = five;\\n                \\n                if(j < m - 1) {\\n                    suf[i][j].first += suf[i][j + 1].first;\\n                    suf[i][j].second += suf[i][j + 1].second;\\n                }\\n            }\\n        }\\n        \\n        \\n        //      |    |\\n        //      |    |\\n        //      |    |\\n        //  ____|    |______  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {  \\n            \\n            int two = 0, five = 0;\\n            for(int row = 0; row < n; row++) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        // _____      ______\\n        //      |    |\\n        //      |    |\\n        //      |    |  \\n        //\\n        \\n        for(int col = 0; col < m; col++) {\\n            \\n            int two = 0, five = 0;\\n            for(int row = n - 1; row >= 0; row--) {\\n                \\n                ans = max(ans, min(pref[row][col].first + two, pref[row][col].second + five));\\n                ans = max(ans, min(suf[row][col].first + two, suf[row][col].second + five));\\n                \\n                int x = arr[row][col];\\n                while(x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                \\n                while(x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1957257,
                "title": "prefix-sum-of-matrix",
                "content": "credit to https://leetcode.com/votrubac\\n\\nhttps://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5\\n```\\npair<int,int> operator+(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first + p2.first, p1.second + p2.second };}\\npair<int,int> operator-(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first - p2.first, p1.second - p2.second };}\\n\\nint primeFactors(int num, int prime) {\\n    return num % prime ? 0 : 1 + primeFactors(num / prime, prime);\\n}\\n\\nint pairs(pair<int,int>p) {\\n    return min(p.first, p.second);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        //for the calculating the prefix add a col extra horizontally and a row vertically\\n        vector<vector<pair<int,int>>> horizontal(rows, vector<pair<int,int>>(cols+1)), vertical(rows+1, vector<pair<int,int>>(cols));\\n        \\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                //calculate the prime factors count\\n                pair<int,int> f25 = { primeFactors(grid[i][j], 2), primeFactors(grid[i][j], 5)};\\n                //add it horizontally for prefix sum\\n                horizontal[i][j+1] = horizontal[i][j] + f25;\\n                //do the same vertically\\n                vertical[i+1][j] = vertical[i][j] + f25;\\n            }\\n        }\\n        int res=0;\\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                // atmost one turn so, we can have 0/1 turn hence\\n                pair<int,int> v1 = vertical[i][j], v2 = vertical[rows][j] - vertical[i+1][j],\\n                // vertical has not included the turn point\\n                              h1 = horizontal[i][j+1], h2 = horizontal[i][cols] - horizontal[i][j];\\n                // where horizontal has included;\\n                // there are four possible ways of turnings, and we get the max out of them;\\n                res = max({res, pairs(v1+h1), pairs(v1+h2), pairs(v2+h1), pairs(v2+h2)});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npair<int,int> operator+(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first + p2.first, p1.second + p2.second };}\\npair<int,int> operator-(const pair<int,int>&p1, const pair<int,int>&p2) { return { p1.first - p2.first, p1.second - p2.second };}\\n\\nint primeFactors(int num, int prime) {\\n    return num % prime ? 0 : 1 + primeFactors(num / prime, prime);\\n}\\n\\nint pairs(pair<int,int>p) {\\n    return min(p.first, p.second);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        //for the calculating the prefix add a col extra horizontally and a row vertically\\n        vector<vector<pair<int,int>>> horizontal(rows, vector<pair<int,int>>(cols+1)), vertical(rows+1, vector<pair<int,int>>(cols));\\n        \\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                //calculate the prime factors count\\n                pair<int,int> f25 = { primeFactors(grid[i][j], 2), primeFactors(grid[i][j], 5)};\\n                //add it horizontally for prefix sum\\n                horizontal[i][j+1] = horizontal[i][j] + f25;\\n                //do the same vertically\\n                vertical[i+1][j] = vertical[i][j] + f25;\\n            }\\n        }\\n        int res=0;\\n        for(int i = 0; i < rows; i ++) {\\n            for(int j = 0; j < cols; j ++) {\\n                // atmost one turn so, we can have 0/1 turn hence\\n                pair<int,int> v1 = vertical[i][j], v2 = vertical[rows][j] - vertical[i+1][j],\\n                // vertical has not included the turn point\\n                              h1 = horizontal[i][j+1], h2 = horizontal[i][cols] - horizontal[i][j];\\n                // where horizontal has included;\\n                // there are four possible ways of turnings, and we get the max out of them;\\n                res = max({res, pairs(v1+h1), pairs(v1+h2), pairs(v2+h1), pairs(v2+h2)});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957221,
                "title": "python3-prefix-sum-easy-to-understand",
                "content": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        Number of zeros, we can easily find using number of 2, 5\\n        So in prefix sum way, for all 4 directions we need to find the number of 2,5\\n        up, down, left, right\\n        \\n        Now as we find the result, we can find 4 types. \\n        up-right, up-left, down-right, down-left. \\n        We need to subtract the curr-idx we iterating, as thats added 2 times. \\n        Finally number of zeros is only min count of 2,5. That also needed to be accounted. \\n        \"\"\" \\n        @lru_cache(None)\\n        def factors(x):\\n            res = [0,0]\\n            while x%2==0:\\n                res[0]+=1\\n                x//=2\\n            while x%5==0:\\n                res[1]+=1\\n                x//=5\\n            return res\\n        \\n        def sum_factors(x, y):\\n            return [x[0]+y[0], x[1]+y[1]]\\n        \\n        def diff_and_min(x, y):\\n            return min(x[0]-y[0], x[1]-y[1])\\n        \\n        m, n = len(grid), len(grid[0])\\n        zeros = [[None for _ in range(n)] for _ in range(m)]\\n        up, down, left, right =  deepcopy(zeros), deepcopy(zeros), deepcopy(zeros),deepcopy(zeros)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                up[i][j] = factors(grid[i][j]) if i == 0 else sum_factors(up[i-1][j], factors(grid[i][j]))\\n                left[i][j] = factors(grid[i][j]) if j == 0 else sum_factors(left[i][j-1], factors(grid[i][j]))\\n                \\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                down[i][j] = factors(grid[i][j]) if i==m-1 else sum_factors(down[i+1][j], factors(grid[i][j]))\\n                right[i][j] = factors(grid[i][j]) if j==n-1 else sum_factors(right[i][j+1], factors(grid[i][j]))\\n                \\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(\\n                    res,\\n                    diff_and_min(sum_factors(up[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(up[i][j], left[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], left[i][j]), factors(grid[i][j]))\\n                )\\n                \\n        return res\\n```\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        Number of zeros, we can easily find using number of 2, 5\\n        So in prefix sum way, for all 4 directions we need to find the number of 2,5\\n        up, down, left, right\\n        \\n        Now as we find the result, we can find 4 types. \\n        up-right, up-left, down-right, down-left. \\n        We need to subtract the curr-idx we iterating, as thats added 2 times. \\n        Finally number of zeros is only min count of 2,5. That also needed to be accounted. \\n        \"\"\" \\n        @lru_cache(None)\\n        def factors(x):\\n            res = [0,0]\\n            while x%2==0:\\n                res[0]+=1\\n                x//=2\\n            while x%5==0:\\n                res[1]+=1\\n                x//=5\\n            return res\\n        \\n        def sum_factors(x, y):\\n            return [x[0]+y[0], x[1]+y[1]]\\n        \\n        def diff_and_min(x, y):\\n            return min(x[0]-y[0], x[1]-y[1])\\n        \\n        m, n = len(grid), len(grid[0])\\n        zeros = [[None for _ in range(n)] for _ in range(m)]\\n        up, down, left, right =  deepcopy(zeros), deepcopy(zeros), deepcopy(zeros),deepcopy(zeros)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                up[i][j] = factors(grid[i][j]) if i == 0 else sum_factors(up[i-1][j], factors(grid[i][j]))\\n                left[i][j] = factors(grid[i][j]) if j == 0 else sum_factors(left[i][j-1], factors(grid[i][j]))\\n                \\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                down[i][j] = factors(grid[i][j]) if i==m-1 else sum_factors(down[i+1][j], factors(grid[i][j]))\\n                right[i][j] = factors(grid[i][j]) if j==n-1 else sum_factors(right[i][j+1], factors(grid[i][j]))\\n                \\n        \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(\\n                    res,\\n                    diff_and_min(sum_factors(up[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(up[i][j], left[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], right[i][j]), factors(grid[i][j])),\\n                    diff_and_min(sum_factors(down[i][j], left[i][j]), factors(grid[i][j]))\\n                )\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957124,
                "title": "java-prefix-and-suffix-sum-of-factors-of-2-and-5",
                "content": "The solution is inspired by this post: https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/discuss/1955515/Prefix-Sum-of-Factors-2-and-5 \\n\\nSharing commented code for the same for Java.\\n\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int r = grid.length, c= grid[0].length;\\n\\t\\t// the arrays below are used to store the total number of 2 and 5 till any point in grid on horizontal and vertical axis.\\n        int h[][][] = new int[r][c+1][2];\\n        int v[][][] = new int[r+1][c][2];\\n        \\n        v[0][0]=new int[]{0,0};\\n        h[0][0]=new int[]{0,0};\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var count2N5 = getCount25(grid[i][j]);\\n                v[i+1][j] = new int[]{v[i][j][0]+count2N5[0] , v[i][j][1]+count2N5[1]};\\n                h[i][j+1] = new int[]{h[i][j][0]+count2N5[0], h[i][j][1]+count2N5[1]};\\n            }\\n        }\\n        \\n        \\n        // now for each point in the grid, try to figure out all the 4 possibilities.\\n        \\n        // v1 -> top to bottom vertical till point i,j\\n        // v2 -> bottom to top till point i,j\\n        // h1 -> left to right till point i,j-1  (j will be covered by vertical path,  in code we will be picking up for j because h[i][j] represents total till j-1)\\n        // h2 -> right to left till point i,j+1  (j will be covered by vertical path so if we consider right to left, we need to consider till j+1 only)\\n        \\n        // try (v1,h1)  ( v1,h2)    (v2,h1)   (v2,h2)  as points of intersection\\n        var result =0;\\n        \\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var v1 = v[i+1][j];\\n                var h1 = h[i][j]; // not j+1 because we have already picked jth element in vertical paths\\n                var v2 = new int[]{ v[r][j][0] - v[i][j][0], v[r][j][1] - v[i][j][1]};\\n                var h2 = new int[]{ h[i][c][0] - h[i][j+1][0], h[i][c][1]- h[i][j+1][1]}; // j+1 because we started from right and we have already picked jth element in vertical path\\n                \\n                // try all 4 combinations at this point\\n                result=Math.max(result, Math.min(v1[0]+h1[0], v1[1]+h1[1]));\\n                result=Math.max(result, Math.min(v1[0]+h2[0], v1[1]+h2[1]));\\n                result=Math.max(result, Math.min(v2[0]+h1[0], v2[1]+h1[1]));\\n                result=Math.max(result, Math.min(v2[0]+h2[0], v2[1]+h2[1]));\\n\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n    private int[] getCount25(int val){\\n        int count2=0, count5=0;\\n        while(val%2==0 && val!=0){\\n            val/=2;\\n            count2++;\\n        }\\n        while(val%5==0 && val!=0){\\n            val/=5;\\n            count5++;\\n        }\\n        return new int[]{count2, count5};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int r = grid.length, c= grid[0].length;\\n\\t\\t// the arrays below are used to store the total number of 2 and 5 till any point in grid on horizontal and vertical axis.\\n        int h[][][] = new int[r][c+1][2];\\n        int v[][][] = new int[r+1][c][2];\\n        \\n        v[0][0]=new int[]{0,0};\\n        h[0][0]=new int[]{0,0};\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var count2N5 = getCount25(grid[i][j]);\\n                v[i+1][j] = new int[]{v[i][j][0]+count2N5[0] , v[i][j][1]+count2N5[1]};\\n                h[i][j+1] = new int[]{h[i][j][0]+count2N5[0], h[i][j][1]+count2N5[1]};\\n            }\\n        }\\n        \\n        \\n        // now for each point in the grid, try to figure out all the 4 possibilities.\\n        \\n        // v1 -> top to bottom vertical till point i,j\\n        // v2 -> bottom to top till point i,j\\n        // h1 -> left to right till point i,j-1  (j will be covered by vertical path,  in code we will be picking up for j because h[i][j] represents total till j-1)\\n        // h2 -> right to left till point i,j+1  (j will be covered by vertical path so if we consider right to left, we need to consider till j+1 only)\\n        \\n        // try (v1,h1)  ( v1,h2)    (v2,h1)   (v2,h2)  as points of intersection\\n        var result =0;\\n        \\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                var v1 = v[i+1][j];\\n                var h1 = h[i][j]; // not j+1 because we have already picked jth element in vertical paths\\n                var v2 = new int[]{ v[r][j][0] - v[i][j][0], v[r][j][1] - v[i][j][1]};\\n                var h2 = new int[]{ h[i][c][0] - h[i][j+1][0], h[i][c][1]- h[i][j+1][1]}; // j+1 because we started from right and we have already picked jth element in vertical path\\n                \\n                // try all 4 combinations at this point\\n                result=Math.max(result, Math.min(v1[0]+h1[0], v1[1]+h1[1]));\\n                result=Math.max(result, Math.min(v1[0]+h2[0], v1[1]+h2[1]));\\n                result=Math.max(result, Math.min(v2[0]+h1[0], v2[1]+h1[1]));\\n                result=Math.max(result, Math.min(v2[0]+h2[0], v2[1]+h2[1]));\\n\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n    private int[] getCount25(int val){\\n        int count2=0, count5=0;\\n        while(val%2==0 && val!=0){\\n            val/=2;\\n            count2++;\\n        }\\n        while(val%5==0 && val!=0){\\n            val/=5;\\n            count5++;\\n        }\\n        return new int[]{count2, count5};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957027,
                "title": "how-ans-is-8-test-case-43-534-575-625-84-20-999-35-208-318-96-380-819-102-669",
                "content": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }\\n    return count;\\n}\\nint power5(int n)\\n{\\n    int count = 0;\\n    while (n % 5 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 5;\\n    }\\n    return count;\\n}\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> v(n + 2, vector<int>(m + 2));\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            v[i][j] = grid[i - 1][j - 1];\\n        }\\n    }\\n\\n     vector<vector<int>> dp1(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp2(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp3(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp4(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp5(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp6(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp7(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp8(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp9(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp10(n + 2, vector<int>(m + 2));\\n//// counting power of 2 and 5\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            int cost1 = 0, cost2 = 0;\\n            cost1 = power2(v[i][j]);\\n            cost2 = power5(v[i][j]);\\n            dp1[i][j] = cost1;\\n            dp2[i][j] = cost2;\\n        }\\n    }\\n       //right sum for dp3__2 and dp4__5\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = m; j >= 1; j--)\\n        {\\n            dp3[i][j] += dp3[i][j + 1] + dp1[i][j];\\n            dp4[i][j] += dp4[i][j + 1] + dp2[i][j];\\n        }\\n    }\\n         //left sum for dp7__2 and dp8__5\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j <= m; j++)\\n        {\\n            dp7[i][j] += dp7[i][j-1] + dp1[i][j];\\n            dp8[i][j] += dp8[i][j-1] + dp2[i][j];\\n        }\\n    } \\n        //  down sum for dp9_2 and dp10_5\\n         for (int j = 1; j < m + 1; j++)\\n    {\\n        for (int i = n; i >= 1; i--)\\n        {\\n            dp9[i][j] += dp9[i][j + 1] + dp1[i][j];\\n            dp10[i][j] += dp10[i][j + 1] + dp2[i][j];\\n        }\\n    }\\n         //  up sum for dp5_2 and dp10_5\\n         for (int i = 1; i < m + 1; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            dp5[j][i] += dp5[j - 1][i] + dp1[j][i];\\n            dp6[j][i] += dp6[j - 1][i] + dp2[j][i];\\n        }\\n    }\\n    int ans = 0;\\n\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            // right and up sum\\n            ans = max(ans, min(dp3[i][j] + dp5[i][j] - dp1[i][j], dp4[i][j] + dp6[i][j] - dp2[i][j]));\\n            //left and up sum\\n             ans = max(ans, min(dp7[i][j] + dp5[i][j] - dp1[i][j], dp8[i][j] + dp6[i][j] - dp2[i][j]));\\n        }\\n    }\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            //left and down sum\\n            ans = max(ans, min(dp7[i][j] + dp9[i][j] - dp1[i][j], dp8[i][j] + dp10[i][j] - dp2[i][j]));\\n            //right and down sum\\n            ans = max(ans, min(dp3[i][j] + dp9[i][j] - dp1[i][j], dp4[i][j] + dp10[i][j] - dp2[i][j]));\\n        }\\n    }\\n    return ans; \\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1956952,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        def count2and5(num):\\n            c2, c5 = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                c2 += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                c5 += 1\\n            return [c2, c5]\\n\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(n):\\n            for j in range(m):\\n                grid[i][j] = count2and5(grid[i][j])\\n\\n        down = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        up = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        right = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        left = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in range(n):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                down[i][j] = [c2, c5]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in reversed(range(n)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                up[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in range(m):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                right[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in reversed(range(m)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                left[i][j] = [c2, c5]\\n\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if j == m - 1:\\n                    c1_2, c1_5 = down[i][j][0], down[i][j][1]\\n                    c3_2, c3_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c1_2, c1_5 = down[i][j][0] + left[i][j+1][0], down[i][j][1] + left[i][j+1][1]\\n                    c3_2, c3_5 = up[i][j][0] + left[i][j+1][0], up[i][j][1] + left[i][j+1][1]\\n                if j == 0:\\n                    c2_2, c2_5 = down[i][j][0], down[i][j][1]\\n                    c4_2, c4_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c2_2, c2_5 = down[i][j][0] + right[i][j-1][0], down[i][j][1] + right[i][j-1][1]\\n                    c4_2, c4_5 = up[i][j][0] + right[i][j-1][0], up[i][j][1] + right[i][j-1][1]\\n\\n                k1 = min(c1_2, c1_5)\\n                k2 = min(c2_2, c2_5)\\n                k3 = min(c3_2, c3_5)\\n                k4 = min(c4_2, c4_5)\\n\\n                ans = max(ans, max(k1, k2, k3, k4))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        def count2and5(num):\\n            c2, c5 = 0, 0\\n            while num % 2 == 0:\\n                num //= 2\\n                c2 += 1\\n            while num % 5 == 0:\\n                num //= 5\\n                c5 += 1\\n            return [c2, c5]\\n\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(n):\\n            for j in range(m):\\n                grid[i][j] = count2and5(grid[i][j])\\n\\n        down = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        up = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        right = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n        left = [[[0, 0] for _ in range(m)] for _ in range(n)]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in range(n):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                down[i][j] = [c2, c5]\\n\\n        for j in range(m):\\n            c2, c5 = 0, 0\\n            for i in reversed(range(n)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                up[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in range(m):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                right[i][j] = [c2, c5]\\n\\n        for i in range(n):\\n            c2, c5 = 0, 0\\n            for j in reversed(range(m)):\\n                c2 += grid[i][j][0]\\n                c5 += grid[i][j][1]\\n                left[i][j] = [c2, c5]\\n\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if j == m - 1:\\n                    c1_2, c1_5 = down[i][j][0], down[i][j][1]\\n                    c3_2, c3_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c1_2, c1_5 = down[i][j][0] + left[i][j+1][0], down[i][j][1] + left[i][j+1][1]\\n                    c3_2, c3_5 = up[i][j][0] + left[i][j+1][0], up[i][j][1] + left[i][j+1][1]\\n                if j == 0:\\n                    c2_2, c2_5 = down[i][j][0], down[i][j][1]\\n                    c4_2, c4_5 = up[i][j][0], up[i][j][1]\\n                else:\\n                    c2_2, c2_5 = down[i][j][0] + right[i][j-1][0], down[i][j][1] + right[i][j-1][1]\\n                    c4_2, c4_5 = up[i][j][0] + right[i][j-1][0], up[i][j][1] + right[i][j-1][1]\\n\\n                k1 = min(c1_2, c1_5)\\n                k2 = min(c2_2, c2_5)\\n                k3 = min(c3_2, c3_5)\\n                k4 = min(c4_2, c4_5)\\n\\n                ans = max(ans, max(k1, k2, k3, k4))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956941,
                "title": "simple-easy-100-time-100-space-well-explained",
                "content": "There is a corner in the path so I have to take 2 matrix for horizontal and vertical purposes. For optimally checking for power of 10 for each path I have taken use of prefix sum approach. Hope you find it easy to understand. Rest is explained in the code.\\n\\n```\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    \\n    // Power of 10 = min (power of 2, power of 5)\\n    // Because 10 = 2 * 5\\n    \\n    int check(int i, int j, vector<vector<pair<int, int>>>& ver, vector<vector<pair<int, int>>>& hor){\\n        int ans = 0;\\n        int m = ver.size(), n = ver[0].size();\\n        // up - horizontally above current point\\n        // down - horizontally below current point\\n        // left and right are left and right part\\n        // of the path with current point as corner\\n        int up2, up5, down2, down5, left2, left5, right2, right5;\\n        \\n        up2 = ver[i][j].F;\\n        up5 = ver[i][j].S;\\n        if(j > 0){\\n            left2 = hor[i][j-1].F;\\n            left5 = hor[i][j-1].S;\\n        }\\n        else{\\n            left2 = left5 = 0;\\n        }\\n        \\n        if(i > 0){\\n            down2 = ver[m-1][j].F - ver[i-1][j].F;\\n            down5 = ver[m-1][j].S - ver[i-1][j].S;\\n        }\\n        else{\\n            down2 = ver[m-1][j].F;\\n            down5 = ver[m-1][j].S;\\n        }\\n        \\n        right2 = hor[i][n-1].F - hor[i][j].F;\\n        right5 = hor[i][n-1].S - hor[i][j].S;\\n        \\n        // Checking for all 4 possible cases of forming a corner path\\n        // at this corner point and taking the maximum of it\\n        ans = max(ans, min(up2 + left2, up5 + left5));\\n        ans = max(ans, min(up2 + right2, up5 + right5));\\n        ans = max(ans, min(down2 + left2, down5 + left5));\\n        ans = max(ans, min(down2 + right2, down5 + right5));\\n        \\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Defined two matrix\\n        // hor - for presum in horizontal direction\\n        // ver - for presum in vertical direction\\n        vector<vector<pair<int, int>>> hor(m, vector<pair<int, int>> (n)), ver(m, vector<pair<int, int>> (n));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int num2 = 0, num5 = 0;\\n                \\n                while(grid[i][j]%2 == 0){\\n                    num2++;\\n                    grid[i][j] /= 2;\\n                }\\n                \\n                while(grid[i][j]%5 == 0){\\n                    num5++;\\n                    grid[i][j] /= 5;\\n                }\\n                \\n                // each cell = {pow of 2, pow of 5}\\n                hor[i][j].F = ver[i][j].F = num2;\\n                hor[i][j].S = ver[i][j].S = num5;\\n            }\\n        }\\n        \\n        // Precalculation for presum in horizontal direction\\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                hor[i][j].F += hor[i][j-1].F;\\n                hor[i][j].S += hor[i][j-1].S;\\n            }\\n        }\\n        \\n        // Precalculation for presum in vertical direction\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                ver[j][i].F += ver[j-1][i].F;\\n                ver[j][i].S += ver[j-1][i].S;\\n            }\\n        }\\n        \\n        // Now at each point I am considering it as a corner of the path\\n        // and finding the corner with maximum answer\\n        int maxN = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                maxN = max(maxN, check(i, j, ver, hor));\\n            }\\n        }\\n        \\n        return maxN;\\n    }\\n};\\n```\\nUpvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    \\n    // Power of 10 = min (power of 2, power of 5)\\n    // Because 10 = 2 * 5\\n    \\n    int check(int i, int j, vector<vector<pair<int, int>>>& ver, vector<vector<pair<int, int>>>& hor){\\n        int ans = 0;\\n        int m = ver.size(), n = ver[0].size();\\n        // up - horizontally above current point\\n        // down - horizontally below current point\\n        // left and right are left and right part\\n        // of the path with current point as corner\\n        int up2, up5, down2, down5, left2, left5, right2, right5;\\n        \\n        up2 = ver[i][j].F;\\n        up5 = ver[i][j].S;\\n        if(j > 0){\\n            left2 = hor[i][j-1].F;\\n            left5 = hor[i][j-1].S;\\n        }\\n        else{\\n            left2 = left5 = 0;\\n        }\\n        \\n        if(i > 0){\\n            down2 = ver[m-1][j].F - ver[i-1][j].F;\\n            down5 = ver[m-1][j].S - ver[i-1][j].S;\\n        }\\n        else{\\n            down2 = ver[m-1][j].F;\\n            down5 = ver[m-1][j].S;\\n        }\\n        \\n        right2 = hor[i][n-1].F - hor[i][j].F;\\n        right5 = hor[i][n-1].S - hor[i][j].S;\\n        \\n        // Checking for all 4 possible cases of forming a corner path\\n        // at this corner point and taking the maximum of it\\n        ans = max(ans, min(up2 + left2, up5 + left5));\\n        ans = max(ans, min(up2 + right2, up5 + right5));\\n        ans = max(ans, min(down2 + left2, down5 + left5));\\n        ans = max(ans, min(down2 + right2, down5 + right5));\\n        \\n        return ans;\\n    }\\n    \\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Defined two matrix\\n        // hor - for presum in horizontal direction\\n        // ver - for presum in vertical direction\\n        vector<vector<pair<int, int>>> hor(m, vector<pair<int, int>> (n)), ver(m, vector<pair<int, int>> (n));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int num2 = 0, num5 = 0;\\n                \\n                while(grid[i][j]%2 == 0){\\n                    num2++;\\n                    grid[i][j] /= 2;\\n                }\\n                \\n                while(grid[i][j]%5 == 0){\\n                    num5++;\\n                    grid[i][j] /= 5;\\n                }\\n                \\n                // each cell = {pow of 2, pow of 5}\\n                hor[i][j].F = ver[i][j].F = num2;\\n                hor[i][j].S = ver[i][j].S = num5;\\n            }\\n        }\\n        \\n        // Precalculation for presum in horizontal direction\\n        for(int i=0; i<m; i++){\\n            for(int j=1; j<n; j++){\\n                hor[i][j].F += hor[i][j-1].F;\\n                hor[i][j].S += hor[i][j-1].S;\\n            }\\n        }\\n        \\n        // Precalculation for presum in vertical direction\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                ver[j][i].F += ver[j-1][i].F;\\n                ver[j][i].S += ver[j-1][i].S;\\n            }\\n        }\\n        \\n        // Now at each point I am considering it as a corner of the path\\n        // and finding the corner with maximum answer\\n        int maxN = 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                maxN = max(maxN, check(i, j, ver, hor));\\n            }\\n        }\\n        \\n        return maxN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956893,
                "title": "clean-code-prefix-sum-of-factors-2-and-5-c-faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector<vector<int>> pref_row2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_row5(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col5(n,vector<int> (m,0));\\n\\n        vector<vector<int>> store2(n,vector<int> (m,0));\\n        vector<vector<int>> store5(n,vector<int> (m,0));\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int temp=a[i][j];\\n                int five=0;\\n                while(temp%5==0 and temp>0)\\n                {\\n                    temp/=5;\\n                    five++;\\n                }\\n                int two=0;\\n                while(temp%2==0 and temp>0)\\n                {\\n                    temp/=2;\\n                    two++;\\n                }\\n                pref_row2[i][j]=two;\\n                pref_row5[i][j]=five;\\n\\n                pref_col2[i][j]=two;\\n                pref_col5[i][j]=five;\\n\\n                store2[i][j]=two;\\n                store5[i][j]=five;\\n            }\\n        }\\n        for (int i = 1; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                pref_row2[i][j]+=pref_row2[i-1][j];\\n                pref_row5[i][j]+=pref_row5[i-1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 1; j < m; ++j)\\n            {\\n                pref_col2[i][j]+=pref_col2[i][j-1];\\n                pref_col5[i][j]+=pref_col5[i][j-1];\\n            }\\n        }\\n\\n        int ans=0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int two=pref_row2[i][j]+pref_col2[i][j]-store2[i][j];\\n                int five=pref_row5[i][j]+pref_col5[i][j]-store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j];\\n                five=pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j]+store2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j]+store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n            }\\n        }\\n        return ans;\\n     }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector<vector<int>> pref_row2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_row5(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col2(n,vector<int> (m,0));\\n        vector<vector<int>> pref_col5(n,vector<int> (m,0));\\n\\n        vector<vector<int>> store2(n,vector<int> (m,0));\\n        vector<vector<int>> store5(n,vector<int> (m,0));\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int temp=a[i][j];\\n                int five=0;\\n                while(temp%5==0 and temp>0)\\n                {\\n                    temp/=5;\\n                    five++;\\n                }\\n                int two=0;\\n                while(temp%2==0 and temp>0)\\n                {\\n                    temp/=2;\\n                    two++;\\n                }\\n                pref_row2[i][j]=two;\\n                pref_row5[i][j]=five;\\n\\n                pref_col2[i][j]=two;\\n                pref_col5[i][j]=five;\\n\\n                store2[i][j]=two;\\n                store5[i][j]=five;\\n            }\\n        }\\n        for (int i = 1; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                pref_row2[i][j]+=pref_row2[i-1][j];\\n                pref_row5[i][j]+=pref_row5[i-1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 1; j < m; ++j)\\n            {\\n                pref_col2[i][j]+=pref_col2[i][j-1];\\n                pref_col5[i][j]+=pref_col5[i][j-1];\\n            }\\n        }\\n\\n        int ans=0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < m; ++j)\\n            {\\n                int two=pref_row2[i][j]+pref_col2[i][j]-store2[i][j];\\n                int five=pref_row5[i][j]+pref_col5[i][j]-store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j];\\n                five=pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n\\n                two=pref_row2[n-1][j]-pref_row2[i][j]+pref_col2[i][m-1]-pref_col2[i][j]+store2[i][j];\\n                five=pref_row5[n-1][j]-pref_row5[i][j]+pref_col5[i][m-1]-pref_col5[i][j]+store5[i][j];\\n\\n                ans=max(ans,min(two,five));\\n            }\\n        }\\n        return ans;\\n     }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956780,
                "title": "can-anyone-tell-me-where-i-was-wrong-its-show-wrong-ans-on-test-case-37-54",
                "content": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }\\n    return count;\\n}\\nint power5(int n)\\n{\\n    int count = 0;\\n    while (n % 5 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 5;\\n    }\\n    return count;\\n}\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    vector<vector<int>> v(n + 2, vector<int>(m + 2));\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            v[i][j] = grid[i - 1][j - 1];\\n        }\\n    }\\n\\n    vector<vector<int>> dp1(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp2(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp3(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp4(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp5(n + 2, vector<int>(m + 2));\\n     vector<vector<int>> dp6(n + 2, vector<int>(m + 2));\\n\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            int cost1 = 0, cost2 = 0;\\n            cost1 = power2(v[i][j]);\\n            cost2 = power5(v[i][j]);\\n            dp1[i][j] = cost1;\\n            dp2[i][j] = cost2;\\n        }\\n    }\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = m; j >= 1; j--)\\n        {\\n            dp3[i][j] += dp3[i][j + 1] + dp1[i][j];\\n            dp4[i][j] += dp4[i][j + 1] + dp2[i][j];\\n        }\\n    }\\n    for (int i = 1; i < m + 1; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            dp5[j][i] += dp5[j - 1][i] + dp1[j][i];\\n            dp6[j][i] += dp6[j - 1][i] + dp2[j][i];\\n        }\\n    }\\n    int ans = 0;\\n\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        ans = max(ans, min(dp3[i][1] + dp5[i][1] - dp1[i][1], dp4[i][1] + dp6[i][1] - dp2[i][1]));\\n    }\\n    int sum2 = 0, sum5 = 0;\\n    for (int i = 1; i < m + 1; i++)\\n    {\\n        sum2 += dp1[1][i];\\n        sum5 += dp2[1][i];\\n    }\\n    for (int i = 1; i < m + 1; i++)\\n    {\\n        ans = max(ans, min(sum2 - dp3[1][i] + dp5[n][i], sum5 - dp4[1][i] + dp6[n][i]));\\n    }\\n    for (int i = 1; i < n + 1; i++)\\n    {\\n        for (int j = 1; j < m + 1; j++)\\n        {\\n            ans = max(ans, min(dp3[i][j] + dp5[i][j] - dp1[i][j], dp4[i][j] + dp6[i][j] - dp2[i][j]));\\n        }\\n    }\\n    return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {  \\n    int power2(int n)\\n{\\n    int count = 0;\\n    while (n % 2 == 0 && n > 0)\\n    {\\n        count++;\\n        n /= 2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1956752,
                "title": "c-easy-to-understand-beat-100-prefix-sum-of-2-and-5-factors",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vetical2(n+1, vector<int>(m+1, 0));\\n        vector<vector<int>> vetical5 = vetical2;\\n        vector<vector<int>> horizontal2 = vetical2;\\n        vector<vector<int>> horizontal5 = horizontal2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                int x = grid[i - 1][j - 1];\\n                int two = 0, five = 0;\\n                while (x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                while (x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                horizontal2[i][j] = horizontal2[i][j - 1] + two;\\n                vetical2[i][j] = vetical2[i - 1][j] + two;\\n                horizontal5[i][j] = horizontal5[i][j - 1] + five;\\n                vetical5[i][j] = vetical5[i - 1][j] + five;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                //     |\\n                //     |\\n                // ----\\n                res = max(res, min(horizontal2[i][j] + vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][j] + vetical5[i - 1][j]));\\n                // ----\\n                //     |\\n                //     |\\n                res = max(res, min(horizontal2[i][j] + vetical2[n][j] - vetical2[i][j], \\\\\\n                                   horizontal5[i][j] + vetical5[n][j] - vetical5[i][j]));\\n                // |\\n                // |\\n                //  ----\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[i][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[i][j]));\\n                //  ----\\n                // |\\n                // |\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[n][j] - vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[n][j] - vetical5[i - 1][j]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vetical2(n+1, vector<int>(m+1, 0));\\n        vector<vector<int>> vetical5 = vetical2;\\n        vector<vector<int>> horizontal2 = vetical2;\\n        vector<vector<int>> horizontal5 = horizontal2;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                int x = grid[i - 1][j - 1];\\n                int two = 0, five = 0;\\n                while (x % 2 == 0) {\\n                    two++;\\n                    x /= 2;\\n                }\\n                while (x % 5 == 0) {\\n                    five++;\\n                    x /= 5;\\n                }\\n                horizontal2[i][j] = horizontal2[i][j - 1] + two;\\n                vetical2[i][j] = vetical2[i - 1][j] + two;\\n                horizontal5[i][j] = horizontal5[i][j - 1] + five;\\n                vetical5[i][j] = vetical5[i - 1][j] + five;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                //     |\\n                //     |\\n                // ----\\n                res = max(res, min(horizontal2[i][j] + vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][j] + vetical5[i - 1][j]));\\n                // ----\\n                //     |\\n                //     |\\n                res = max(res, min(horizontal2[i][j] + vetical2[n][j] - vetical2[i][j], \\\\\\n                                   horizontal5[i][j] + vetical5[n][j] - vetical5[i][j]));\\n                // |\\n                // |\\n                //  ----\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[i][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[i][j]));\\n                //  ----\\n                // |\\n                // |\\n                res = max(res, min(horizontal2[i][m] - horizontal2[i][j] + vetical2[n][j] - vetical2[i - 1][j], \\\\\\n                                   horizontal5[i][m] - horizontal5[i][j] + vetical5[n][j] - vetical5[i - 1][j]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956749,
                "title": "brute-force-path-search-40-54-passed-before-tle",
                "content": "I know the prefix sum solutions are way faster, but I had fun trying to get this by actually searching paths!\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factor(num):\\n            twos = fives = 0\\n            temp1 = temp2 = num\\n            while temp1 % 2 == 0:\\n                temp1 /= 2\\n                twos += 1\\n            while temp2 % 5 == 0:\\n                temp2 /= 5\\n                fives += 1\\n            return (twos, fives)\\n\\n        R, C = len(grid), len(grid[0])\\n        res = -float(\"inf\")\\n\\n        prune = defaultdict(int)\\n\\n        def helper(pos: Tuple, cur_dir: Tuple, cur_factors, turned):\\n            nonlocal R, C, res\\n\\n            if not (0 <= pos[0] < R and 0 <= pos[1] < C):\\n                return min(cur_factors)\\n            \\n            # Previously reached this state with Higher Factors\\n            prior = prune.get((pos, cur_dir, turned), None)\\n            if prior and prior >= min(cur_factors):\\n                return 0\\n            else:\\n                prune[(pos, cur_dir, turned)] = min(cur_factors)\\n\\n                \\n            f = factor(grid[pos[0]][pos[1]])\\n\\n            new_fac = (\\n                cur_factors[0] + f[0],\\n                cur_factors[1] + f[1],\\n            )\\n\\n            res = 0\\n\\n            # Case A: Explore turning at Pos\\n            if turned == False:\\n\\n                new_dir1 = tuple(reversed(cur_dir))\\n                new_dir2 = tuple([-1 * x for x in new_dir1])\\n\\n                for d in [new_dir1, new_dir2]:\\n                    new_pos = (\\n                        pos[0] + d[0],\\n                        pos[1] + d[1],\\n                    )\\n                    res = max(res, helper(new_pos, d, new_fac, True))\\n\\n            # Case B: No turning at Pos\\n            new_pos = (pos[0] + cur_dir[0], pos[1] + cur_dir[1])\\n\\n            res = max(res, helper(new_pos, cur_dir, new_fac, turned))\\n\\n            return res\\n\\n        ans = 0\\n        for r in range(R):\\n            ans = max(ans, helper((r, 0), (0, 1), (0, 0), False))\\n            ans = max(ans, helper((r, C - 1), (0, -1), (0, 0), False))\\n        for c in range(C):\\n            ans = max(ans, helper((0, c), (1, 0), (0, 0), False))\\n            ans = max(ans, helper((0, R - 1), (-1, 0), (0, 0), False))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @functools.lru_cache(None)\\n        def factor(num):\\n            twos = fives = 0\\n            temp1 = temp2 = num\\n            while temp1 % 2 == 0:\\n                temp1 /= 2\\n                twos += 1\\n            while temp2 % 5 == 0:\\n                temp2 /= 5\\n                fives += 1\\n            return (twos, fives)\\n\\n        R, C = len(grid), len(grid[0])\\n        res = -float(\"inf\")\\n\\n        prune = defaultdict(int)\\n\\n        def helper(pos: Tuple, cur_dir: Tuple, cur_factors, turned):\\n            nonlocal R, C, res\\n\\n            if not (0 <= pos[0] < R and 0 <= pos[1] < C):\\n                return min(cur_factors)\\n            \\n            # Previously reached this state with Higher Factors\\n            prior = prune.get((pos, cur_dir, turned), None)\\n            if prior and prior >= min(cur_factors):\\n                return 0\\n            else:\\n                prune[(pos, cur_dir, turned)] = min(cur_factors)\\n\\n                \\n            f = factor(grid[pos[0]][pos[1]])\\n\\n            new_fac = (\\n                cur_factors[0] + f[0],\\n                cur_factors[1] + f[1],\\n            )\\n\\n            res = 0\\n\\n            # Case A: Explore turning at Pos\\n            if turned == False:\\n\\n                new_dir1 = tuple(reversed(cur_dir))\\n                new_dir2 = tuple([-1 * x for x in new_dir1])\\n\\n                for d in [new_dir1, new_dir2]:\\n                    new_pos = (\\n                        pos[0] + d[0],\\n                        pos[1] + d[1],\\n                    )\\n                    res = max(res, helper(new_pos, d, new_fac, True))\\n\\n            # Case B: No turning at Pos\\n            new_pos = (pos[0] + cur_dir[0], pos[1] + cur_dir[1])\\n\\n            res = max(res, helper(new_pos, cur_dir, new_fac, turned))\\n\\n            return res\\n\\n        ans = 0\\n        for r in range(R):\\n            ans = max(ans, helper((r, 0), (0, 1), (0, 0), False))\\n            ans = max(ans, helper((r, C - 1), (0, -1), (0, 0), False))\\n        for c in range(C):\\n            ans = max(ans, helper((0, c), (1, 0), (0, 0), False))\\n            ans = max(ans, helper((0, R - 1), (-1, 0), (0, 0), False))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956633,
                "title": "python3-math-prefix-sum-solution",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        presum_row_mod_two = [[0] * m for _ in range(n)]\\n        presum_col_mod_two = [[0] * n for _ in range(m)]\\n        presum_row_mod_five = [[0] * m for _ in range(n)]\\n        presum_col_mod_five = [[0] * n for _ in range(m)]\\n        res = 0\\n        for i in range(n):\\n            for j in range(m):\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    presum_row_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_row_mod_two[i][j] += presum_row_mod_two[i][j - 1]\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    presum_row_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_row_mod_five[i][j] += presum_row_mod_five[i][j - 1]\\n        for i in range(m):\\n            for j in range(n):\\n                temp = grid[j][i]\\n                while temp % 2 == 0:\\n                    presum_col_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_col_mod_two[i][j] += presum_col_mod_two[i][j - 1]\\n                temp = grid[j][i]\\n                while temp % 5 == 0:\\n                    presum_col_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_col_mod_five[i][j] += presum_col_mod_five[i][j - 1]\\n        for i in range(n):\\n            for j in range(m):\\n                options = []\\n                options.append(presum_col_mod_two[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_two[j][n - 1] - presum_col_mod_two[j][i])\\n                options.append(presum_row_mod_two[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_two[i][m - 1] - presum_row_mod_two[i][j])\\n                options.append(presum_col_mod_five[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_five[j][n - 1] - presum_col_mod_five[j][i])\\n                options.append(presum_row_mod_five[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_five[i][m - 1] - presum_row_mod_five[i][j])\\n                cnt_two = 0\\n                cnt_five = 0\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    cnt_two += 1\\n                    temp //= 2\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    cnt_five += 1\\n                    temp //= 5\\n                for k in range(4):\\n                    for l in range(k + 1, 4):\\n                        cur = min(options[k] + options[l] + cnt_two, options[k + 4] + options[l + 4] + cnt_five)\\n                        res = max(cur, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        presum_row_mod_two = [[0] * m for _ in range(n)]\\n        presum_col_mod_two = [[0] * n for _ in range(m)]\\n        presum_row_mod_five = [[0] * m for _ in range(n)]\\n        presum_col_mod_five = [[0] * n for _ in range(m)]\\n        res = 0\\n        for i in range(n):\\n            for j in range(m):\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    presum_row_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_row_mod_two[i][j] += presum_row_mod_two[i][j - 1]\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    presum_row_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_row_mod_five[i][j] += presum_row_mod_five[i][j - 1]\\n        for i in range(m):\\n            for j in range(n):\\n                temp = grid[j][i]\\n                while temp % 2 == 0:\\n                    presum_col_mod_two[i][j] += 1\\n                    temp //= 2\\n                if j > 0:\\n                    presum_col_mod_two[i][j] += presum_col_mod_two[i][j - 1]\\n                temp = grid[j][i]\\n                while temp % 5 == 0:\\n                    presum_col_mod_five[i][j] += 1\\n                    temp //= 5\\n                if j > 0:\\n                    presum_col_mod_five[i][j] += presum_col_mod_five[i][j - 1]\\n        for i in range(n):\\n            for j in range(m):\\n                options = []\\n                options.append(presum_col_mod_two[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_two[j][n - 1] - presum_col_mod_two[j][i])\\n                options.append(presum_row_mod_two[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_two[i][m - 1] - presum_row_mod_two[i][j])\\n                options.append(presum_col_mod_five[j][i - 1] if i - 1 >= 0 else 0)\\n                options.append(presum_col_mod_five[j][n - 1] - presum_col_mod_five[j][i])\\n                options.append(presum_row_mod_five[i][j - 1] if j - 1 >= 0 else 0)\\n                options.append(presum_row_mod_five[i][m - 1] - presum_row_mod_five[i][j])\\n                cnt_two = 0\\n                cnt_five = 0\\n                temp = grid[i][j]\\n                while temp % 2 == 0:\\n                    cnt_two += 1\\n                    temp //= 2\\n                temp = grid[i][j]\\n                while temp % 5 == 0:\\n                    cnt_five += 1\\n                    temp //= 5\\n                for k in range(4):\\n                    for l in range(k + 1, 4):\\n                        cur = min(options[k] + options[l] + cnt_two, options[k + 4] + options[l + 4] + cnt_five)\\n                        res = max(cur, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956595,
                "title": "c-beats-100-prefix-sum-in-matrix",
                "content": "```\\n/* \\n    Time: O(n*m)\\n    Space: O(n*m)\\n    Tag: Prefix Sum, Matrix, Implementation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    int factOf5(int num) {\\n        int res = 0;\\n        while (num && num % 5 == 0) {\\n            res++;\\n            num /= 5;\\n        }\\n        return res;\\n    }\\n    int factOf2(int num) {\\n        int res = 0;\\n        while (num && num % 2 == 0) {\\n            res++;\\n            num /= 2;\\n        }\\n        return res;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> fives(n, vector<int>(m));\\n        vector<vector<int>> twos(n, vector<int>(m));\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fives[i][j] = factOf5(grid[i][j]);\\n                twos[i][j] = factOf2(grid[i][j]);\\n            }\\n        }\\n        vector<vector<int>> prefvert5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefvert2(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz2(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefhoriz5[i][j] == 0;\\n                    prefhoriz2[i][j] == 0;\\n                } else {\\n                    prefhoriz5[i][j] = prefhoriz5[i][j - 1] + fives[i - 1][j - 1];\\n                    prefhoriz2[i][j] = prefhoriz2[i][j - 1] + twos[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefvert5[j][i] == 0;\\n                    prefvert2[j][i] == 0;\\n                } else {\\n                    prefvert5[j][i] = prefvert5[j - 1][i] + fives[j - 1][i - 1];\\n                    prefvert2[j][i] = prefvert2[j - 1][i] + twos[j - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int vertdown2 = prefvert2[n][j + 1] - prefvert2[i][j + 1];\\n                int vertdown5 = prefvert5[n][j + 1] - prefvert5[i][j + 1];\\n                int vertup2 = prefvert2[i + 1][j + 1];\\n                int vertup5 = prefvert5[i + 1][j + 1];\\n\\n                int horizleft2 = prefhoriz2[i + 1][j + 1];\\n                int horizleft5 = prefhoriz5[i + 1][j + 1];\\n                int horizRight2 = prefhoriz2[i + 1][m] - prefhoriz2[i + 1][j];\\n                int horizRight5 = prefhoriz5[i + 1][m] - prefhoriz5[i + 1][j];\\n\\n                int res1 = min(horizleft2 + vertup2 - twos[i][j], horizleft5 + vertup5 - fives[i][j]);\\n                int res2 = min(horizleft2 + vertdown2 - twos[i][j], horizleft5 + vertdown5 - fives[i][j]);\\n                int res3 = min(horizRight2 + vertup2 - twos[i][j], horizRight5 + vertup5 - fives[i][j]);\\n                int res4 = min(horizRight2 + vertdown2 - twos[i][j], horizRight5 + vertdown5 - fives[i][j]);\\n                res = max(res, max(res1, max(res2, max(res3, res4))));\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n/* \\n    Time: O(n*m)\\n    Space: O(n*m)\\n    Tag: Prefix Sum, Matrix, Implementation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    int factOf5(int num) {\\n        int res = 0;\\n        while (num && num % 5 == 0) {\\n            res++;\\n            num /= 5;\\n        }\\n        return res;\\n    }\\n    int factOf2(int num) {\\n        int res = 0;\\n        while (num && num % 2 == 0) {\\n            res++;\\n            num /= 2;\\n        }\\n        return res;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> fives(n, vector<int>(m));\\n        vector<vector<int>> twos(n, vector<int>(m));\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fives[i][j] = factOf5(grid[i][j]);\\n                twos[i][j] = factOf2(grid[i][j]);\\n            }\\n        }\\n        vector<vector<int>> prefvert5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefvert2(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz5(n + 1, vector<int>(m + 1));\\n        vector<vector<int>> prefhoriz2(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefhoriz5[i][j] == 0;\\n                    prefhoriz2[i][j] == 0;\\n                } else {\\n                    prefhoriz5[i][j] = prefhoriz5[i][j - 1] + fives[i - 1][j - 1];\\n                    prefhoriz2[i][j] = prefhoriz2[i][j - 1] + twos[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 || j == 0) {\\n                    prefvert5[j][i] == 0;\\n                    prefvert2[j][i] == 0;\\n                } else {\\n                    prefvert5[j][i] = prefvert5[j - 1][i] + fives[j - 1][i - 1];\\n                    prefvert2[j][i] = prefvert2[j - 1][i] + twos[j - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int vertdown2 = prefvert2[n][j + 1] - prefvert2[i][j + 1];\\n                int vertdown5 = prefvert5[n][j + 1] - prefvert5[i][j + 1];\\n                int vertup2 = prefvert2[i + 1][j + 1];\\n                int vertup5 = prefvert5[i + 1][j + 1];\\n\\n                int horizleft2 = prefhoriz2[i + 1][j + 1];\\n                int horizleft5 = prefhoriz5[i + 1][j + 1];\\n                int horizRight2 = prefhoriz2[i + 1][m] - prefhoriz2[i + 1][j];\\n                int horizRight5 = prefhoriz5[i + 1][m] - prefhoriz5[i + 1][j];\\n\\n                int res1 = min(horizleft2 + vertup2 - twos[i][j], horizleft5 + vertup5 - fives[i][j]);\\n                int res2 = min(horizleft2 + vertdown2 - twos[i][j], horizleft5 + vertdown5 - fives[i][j]);\\n                int res3 = min(horizRight2 + vertup2 - twos[i][j], horizRight5 + vertup5 - fives[i][j]);\\n                int res4 = min(horizRight2 + vertdown2 - twos[i][j], horizRight5 + vertdown5 - fives[i][j]);\\n                res = max(res, max(res1, max(res2, max(res3, res4))));\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956478,
                "title": "python-2d-prefix-sum-6-cases",
                "content": "Rather lengthy code...\\n\\n```python\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def count(x, k):\\n            ans = 0\\n            while x % k == 0:\\n                x = x // k\\n                ans += 1\\n            return ans\\n                \\n        R, C = len(grid), len(grid[0])\\n        PREFIX = [[[0, 0, 0, 0] for _ in range(C + 1)] for _ in range(R + 1)]\\n        for r in range(R):\\n            for c in range(C):\\n                #current counts\\n                count2 = count(grid[r][c], 2)\\n                count5 = count(grid[r][c], 5)  \\n                #how many 2\\'s from left\\n                PREFIX[r + 1][c + 1][0] = count2 + PREFIX[r + 1][c][0] \\n                #how many 2\\'s from up\\n                PREFIX[r + 1][c + 1][1] = count2 + PREFIX[r][c + 1][1]\\n                #how many 5\\'s from left\\n                PREFIX[r + 1][c + 1][2] = count5 + PREFIX[r + 1][c][2]\\n                #how many 5\\'s from up\\n                PREFIX[r + 1][c + 1][3] = count5 + PREFIX[r][c + 1][3]\\n                \\n        def left2(r, c):\\n            return PREFIX[r + 1][c][0]\\n        \\n        def right2(r, c):\\n            return PREFIX[r + 1][C][0] - PREFIX[r + 1][c + 1][0]\\n        \\n        def up2(r, c):\\n            return PREFIX[r][c + 1][1]\\n        \\n        def down2(r, c):\\n            return PREFIX[R][c + 1][1] - PREFIX[r + 1][c + 1][1]\\n        \\n        def left5(r, c):\\n            return PREFIX[r + 1][c][2]\\n        \\n        def right5(r, c):\\n            return PREFIX[r + 1][C][2] - PREFIX[r + 1][c + 1][2]\\n        \\n        def up5(r, c):\\n            return PREFIX[r][c + 1][3]\\n        \\n        def down5(r, c):\\n            return PREFIX[R][c + 1][3] - PREFIX[r + 1][c + 1][3]\\n        \\n        ans = 0\\n        for r in range(R):\\n            for c in range(C):\\n                x = grid[r][c]\\n                \\n                #case1\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + right2(r, c)\\n                count5 += left5(r, c) + right5(r, c)\\n                ans1 = min(count2, count5)\\n                \\n                #case2\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += up2(r, c) + down2(r, c)\\n                count5 += up5(r, c) + down5(r, c)\\n                ans2 = min(count2, count5)\\n                \\n                #case 3\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + up2(r, c)\\n                count5 += left5(r, c) + up5(r, c)\\n                ans3 = min(count2, count5)\\n\\n                #case 4\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + up2(r, c)\\n                count5 += right5(r, c) + up5(r, c)\\n                ans4 = min(count2, count5)\\n                \\n                #case 5\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + down2(r, c)\\n                count5 += left5(r, c) + down5(r, c)\\n                ans5 = min(count2, count5)\\n                \\n                #case 6\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + down2(r, c)\\n                count5 += right5(r, c) + down5(r, c)\\n                ans6 = min(count2, count5)\\n            \\n                ans = max(ans, ans1, ans2, ans3, ans4, ans5, ans6)\\n                        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def count(x, k):\\n            ans = 0\\n            while x % k == 0:\\n                x = x // k\\n                ans += 1\\n            return ans\\n                \\n        R, C = len(grid), len(grid[0])\\n        PREFIX = [[[0, 0, 0, 0] for _ in range(C + 1)] for _ in range(R + 1)]\\n        for r in range(R):\\n            for c in range(C):\\n                #current counts\\n                count2 = count(grid[r][c], 2)\\n                count5 = count(grid[r][c], 5)  \\n                #how many 2\\'s from left\\n                PREFIX[r + 1][c + 1][0] = count2 + PREFIX[r + 1][c][0] \\n                #how many 2\\'s from up\\n                PREFIX[r + 1][c + 1][1] = count2 + PREFIX[r][c + 1][1]\\n                #how many 5\\'s from left\\n                PREFIX[r + 1][c + 1][2] = count5 + PREFIX[r + 1][c][2]\\n                #how many 5\\'s from up\\n                PREFIX[r + 1][c + 1][3] = count5 + PREFIX[r][c + 1][3]\\n                \\n        def left2(r, c):\\n            return PREFIX[r + 1][c][0]\\n        \\n        def right2(r, c):\\n            return PREFIX[r + 1][C][0] - PREFIX[r + 1][c + 1][0]\\n        \\n        def up2(r, c):\\n            return PREFIX[r][c + 1][1]\\n        \\n        def down2(r, c):\\n            return PREFIX[R][c + 1][1] - PREFIX[r + 1][c + 1][1]\\n        \\n        def left5(r, c):\\n            return PREFIX[r + 1][c][2]\\n        \\n        def right5(r, c):\\n            return PREFIX[r + 1][C][2] - PREFIX[r + 1][c + 1][2]\\n        \\n        def up5(r, c):\\n            return PREFIX[r][c + 1][3]\\n        \\n        def down5(r, c):\\n            return PREFIX[R][c + 1][3] - PREFIX[r + 1][c + 1][3]\\n        \\n        ans = 0\\n        for r in range(R):\\n            for c in range(C):\\n                x = grid[r][c]\\n                \\n                #case1\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + right2(r, c)\\n                count5 += left5(r, c) + right5(r, c)\\n                ans1 = min(count2, count5)\\n                \\n                #case2\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += up2(r, c) + down2(r, c)\\n                count5 += up5(r, c) + down5(r, c)\\n                ans2 = min(count2, count5)\\n                \\n                #case 3\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + up2(r, c)\\n                count5 += left5(r, c) + up5(r, c)\\n                ans3 = min(count2, count5)\\n\\n                #case 4\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + up2(r, c)\\n                count5 += right5(r, c) + up5(r, c)\\n                ans4 = min(count2, count5)\\n                \\n                #case 5\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += left2(r, c) + down2(r, c)\\n                count5 += left5(r, c) + down5(r, c)\\n                ans5 = min(count2, count5)\\n                \\n                #case 6\\n                count2, count5 = count(x, 2), count(x, 5)\\n                count2 += right2(r, c) + down2(r, c)\\n                count5 += right5(r, c) + down5(r, c)\\n                ans6 = min(count2, count5)\\n            \\n                ans = max(ans, ans1, ans2, ans3, ans4, ans5, ans6)\\n                        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956461,
                "title": "java-prefix-suffix-solution",
                "content": "```\\nclass Solution \\n{\\n    //Hell of an implementation\\n    public int maxTrailingZeros(int[][] grid) \\n    {\\n        int n = grid.length; int m = grid[0].length;\\n        Pair[][] arr = new Pair[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int[] res = find(grid[i][j]);\\n                arr[i][j] = new Pair(res[0], res[1]);\\n            }\\n        }\\n        \\n        Pair[][] pre = new Pair[n][m];\\n        Pair[][] suff = new Pair[n][m];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                    pre[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = pre[i][j-1].x + arr[i][j].x;\\n                    int y1 = pre[i][j-1].y + arr[i][j].y;\\n                    pre[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j == m-1)\\n                    suff[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = suff[i][j+1].x + arr[i][j].x;\\n                    int y1 = suff[i][j+1].y + arr[i][j].y;\\n                    suff[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        int c2 = 0, c5 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int n)\\n    {\\n        int twos = 0, fives = 0;\\n        while(n%2 == 0)\\n        {\\n            twos++;\\n            n/=2;\\n        }\\n        while(n%5 == 0)\\n        {\\n            fives++;\\n            n/=5;\\n        }\\n        return new int[]{twos, fives};\\n    }\\n    \\n    class Pair\\n    {\\n        int x, y;\\n        Pair(int x, int y)\\n        {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\n    //Hell of an implementation\\n    public int maxTrailingZeros(int[][] grid) \\n    {\\n        int n = grid.length; int m = grid[0].length;\\n        Pair[][] arr = new Pair[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int[] res = find(grid[i][j]);\\n                arr[i][j] = new Pair(res[0], res[1]);\\n            }\\n        }\\n        \\n        Pair[][] pre = new Pair[n][m];\\n        Pair[][] suff = new Pair[n][m];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                    pre[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = pre[i][j-1].x + arr[i][j].x;\\n                    int y1 = pre[i][j-1].y + arr[i][j].y;\\n                    pre[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(j == m-1)\\n                    suff[i][j] = new Pair(arr[i][j].x, arr[i][j].y);\\n                else\\n                {\\n                    int x1 = suff[i][j+1].x + arr[i][j].x;\\n                    int y1 = suff[i][j+1].y + arr[i][j].y;\\n                    suff[i][j] = new Pair(x1, y1);\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        int c2 = 0, c5 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            c2 = 0; c5 = 0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                res = Math.max(res, Math.min(c2+pre[i][j].x, c5+pre[i][j].y));\\n                res = Math.max(res, Math.min(c2+suff[i][j].x, c5+suff[i][j].y));\\n                c2 += arr[i][j].x;\\n                c5 += arr[i][j].y;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int[] find(int n)\\n    {\\n        int twos = 0, fives = 0;\\n        while(n%2 == 0)\\n        {\\n            twos++;\\n            n/=2;\\n        }\\n        while(n%5 == 0)\\n        {\\n            fives++;\\n            n/=5;\\n        }\\n        return new int[]{twos, fives};\\n    }\\n    \\n    class Pair\\n    {\\n        int x, y;\\n        Pair(int x, int y)\\n        {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956401,
                "title": "22-lines-python3-solution",
                "content": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def check(grid, row_order=1, col_order=1):\\n            above = [[0, 0] for i in range(len(grid[0]))]\\n            ans = 0\\n            for row in grid[::row_order]:\\n                this_row = [0, 0]\\n                for i, v in enumerate(row[::col_order]):\\n                    c2 = c5 = 0\\n                    while v % 2 == 0:\\n                        c2 += 1\\n                        v /= 2\\n                    while v % 5 == 0:\\n                        c5 += 1\\n                        v /= 5\\n                    this_row[0] += c2\\n                    this_row[1] += c5\\n                    ans = max(ans, min(this_row[0] + above[i][0], this_row[1] + above[i][1]))\\n                    above[i][0] += c2\\n                    above[i][1] += c5\\n            return ans\\n        return max(check(grid, ro, co) for ro in [-1, 1] for co in [-1, 1])\\n        \\n        \\n        \\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        def check(grid, row_order=1, col_order=1):\\n            above = [[0, 0] for i in range(len(grid[0]))]\\n            ans = 0\\n            for row in grid[::row_order]:\\n                this_row = [0, 0]\\n                for i, v in enumerate(row[::col_order]):\\n                    c2 = c5 = 0\\n                    while v % 2 == 0:\\n                        c2 += 1\\n                        v /= 2\\n                    while v % 5 == 0:\\n                        c5 += 1\\n                        v /= 5\\n                    this_row[0] += c2\\n                    this_row[1] += c5\\n                    ans = max(ans, min(this_row[0] + above[i][0], this_row[1] + above[i][1]))\\n                    above[i][0] += c2\\n                    above[i][1] += c5\\n            return ans\\n        return max(check(grid, ro, co) for ro in [-1, 1] for co in [-1, 1])\\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956383,
                "title": "c-4-direction-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        \\n        // horizontal_prefix_fives[i][j]: number of the factor 5 for grid[i][0...j].\\n        // horizontal_suffix_fives[i][j]: number of the factor 5 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_fives(m, vector<int>(n, 0)), horizontal_suffix_fives(m, vector<int>(n, 0));\\n        // horizontal_prefix_twos[i][j]: number of the factor 2 for grid[i][0...j].\\n        // horizontal_suffix_twos[i][j]: number of the factor 2 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_twos(m, vector<int>(n, 0)), horizontal_suffix_twos(m, vector<int>(n, 0));    \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                horizontal_prefix_fives[i][j] = (j > 0 ? horizontal_prefix_fives[i][j - 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_prefix_twos[i][j] = (j > 0 ? horizontal_prefix_twos[i][j - 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n            for (int j = n - 1; j >= 0; --j) {\\n                horizontal_suffix_fives[i][j] = (j < n - 1 ? horizontal_suffix_fives[i][j + 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_suffix_twos[i][j] = (j < n - 1 ? horizontal_suffix_twos[i][j + 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        int max_val = 0;\\n        // vertical_prefix_fives[j]: number of the factor 5 for grid[0...i][j].\\n        // vertical_prefix_twos: number of the factor 2 for grid[0...i][j].\\n        vector<int> vertical_prefix_fives(n), vertical_prefix_twos(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val, \\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + vertical_prefix_fives[j], horizontal_prefix_twos[i][j] + vertical_prefix_twos[j]), \\n                                            std::min(horizontal_suffix_fives[i][j] + vertical_prefix_fives[j],  horizontal_suffix_twos[i][j] + vertical_prefix_twos[j])));\\n                vertical_prefix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_prefix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        \\n        vector<int> veritical_suffix_fives(n), vertical_suffix_twos(n);\\n        for (int i = m - 1; i >= 0; --i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val,\\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + veritical_suffix_fives[j], horizontal_prefix_twos[i][j] + vertical_suffix_twos[j]),\\n                                            std::min(horizontal_suffix_fives[i][j] + veritical_suffix_fives[j],  horizontal_suffix_twos[i][j] + vertical_suffix_twos[j])));\\n                veritical_suffix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_suffix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }   \\n    \\n        return max_val;\\n    }\\n    \\nprivate:\\n    int GetFactorNum(int val, int factor) {\\n        int count = 0;\\n        while (val > 0 && val % factor == 0) {\\n            val /= factor;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        \\n        // horizontal_prefix_fives[i][j]: number of the factor 5 for grid[i][0...j].\\n        // horizontal_suffix_fives[i][j]: number of the factor 5 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_fives(m, vector<int>(n, 0)), horizontal_suffix_fives(m, vector<int>(n, 0));\\n        // horizontal_prefix_twos[i][j]: number of the factor 2 for grid[i][0...j].\\n        // horizontal_suffix_twos[i][j]: number of the factor 2 for grid[i][j...n-1].\\n        vector<vector<int>> horizontal_prefix_twos(m, vector<int>(n, 0)), horizontal_suffix_twos(m, vector<int>(n, 0));    \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                horizontal_prefix_fives[i][j] = (j > 0 ? horizontal_prefix_fives[i][j - 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_prefix_twos[i][j] = (j > 0 ? horizontal_prefix_twos[i][j - 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n            for (int j = n - 1; j >= 0; --j) {\\n                horizontal_suffix_fives[i][j] = (j < n - 1 ? horizontal_suffix_fives[i][j + 1] : 0) + GetFactorNum(grid[i][j], 5);\\n                horizontal_suffix_twos[i][j] = (j < n - 1 ? horizontal_suffix_twos[i][j + 1] : 0) + GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        int max_val = 0;\\n        // vertical_prefix_fives[j]: number of the factor 5 for grid[0...i][j].\\n        // vertical_prefix_twos: number of the factor 2 for grid[0...i][j].\\n        vector<int> vertical_prefix_fives(n), vertical_prefix_twos(n);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val, \\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + vertical_prefix_fives[j], horizontal_prefix_twos[i][j] + vertical_prefix_twos[j]), \\n                                            std::min(horizontal_suffix_fives[i][j] + vertical_prefix_fives[j],  horizontal_suffix_twos[i][j] + vertical_prefix_twos[j])));\\n                vertical_prefix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_prefix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }\\n        \\n        vector<int> veritical_suffix_fives(n), vertical_suffix_twos(n);\\n        for (int i = m - 1; i >= 0; --i) {\\n            for (int j = 0; j < n; ++j) {\\n                max_val = std::max(max_val,\\n                                   std::max(std::min(horizontal_prefix_fives[i][j] + veritical_suffix_fives[j], horizontal_prefix_twos[i][j] + vertical_suffix_twos[j]),\\n                                            std::min(horizontal_suffix_fives[i][j] + veritical_suffix_fives[j],  horizontal_suffix_twos[i][j] + vertical_suffix_twos[j])));\\n                veritical_suffix_fives[j] += GetFactorNum(grid[i][j], 5);\\n                vertical_suffix_twos[j] += GetFactorNum(grid[i][j], 2);\\n            }\\n        }   \\n    \\n        return max_val;\\n    }\\n    \\nprivate:\\n    int GetFactorNum(int val, int factor) {\\n        int count = 0;\\n        while (val > 0 && val % factor == 0) {\\n            val /= factor;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956369,
                "title": "prefix-and-suffix-sum-of-multiple-of-2-and-5-c",
                "content": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pair<int,int>>>p(n,vector<pair<int,int>>(m));\\n        vector<vector<pair<int,int>>>s(n,vector<pair<int,int>>(m));\\n        for(int i=0; i<n; i++)\\n        {\\n            int t=0,f=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                p[i][j] = {t,f};\\n            }\\n            t=0,f=0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                s[i][j] = {t,f};\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int j=0; j<m; j++)\\n        {\\n            int f=0,t=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        for(int j=m-1; j>=0; j--)\\n        {\\n            int f=0,t=0;\\n            for(int i=n-1; i>=0; i--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        return ans;\\n        \\n        return 0;\\n    }",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<pair<int,int>>>p(n,vector<pair<int,int>>(m));\\n        vector<vector<pair<int,int>>>s(n,vector<pair<int,int>>(m));\\n        for(int i=0; i<n; i++)\\n        {\\n            int t=0,f=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                p[i][j] = {t,f};\\n            }\\n            t=0,f=0;\\n            for(int j=m-1; j>=0; j--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                s[i][j] = {t,f};\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int j=0; j<m; j++)\\n        {\\n            int f=0,t=0;\\n            for(int i=0; i<n; i++)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        for(int j=m-1; j>=0; j--)\\n        {\\n            int f=0,t=0;\\n            for(int i=n-1; i>=0; i--)\\n            {\\n                int val = grid[i][j];\\n                while(val%2==0)\\n                {\\n                    t++;\\n                    val/=2;\\n                }\\n                while(val%5==0)\\n                {\\n                    f++;\\n                    val/=5;\\n                }\\n                if(j)\\n                ans = max(ans,min(t+p[i][j-1].first,f+p[i][j-1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n                if(j!=m-1)\\n                ans = max(ans,min(t+s[i][j+1].first,f+s[i][j+1].second));\\n                else\\n                ans = max(ans,min(t,f));\\n            }\\n        }\\n        return ans;\\n        \\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1956253,
                "title": "prefix-sum-of-noof2s-and-noof5s-c-long-implementation-100-time-100-space",
                "content": "![image](https://assets.leetcode.com/users/images/291ab2e1-dcf6-4d3a-a203-3b2bd17561a1_1650178050.3047764.png)\\n\\n#### 1) `Count the noof 2\\'s and 5\\'s in each element of grid.`\\n#### 2) `Now maintain 4 matrices to calculate prefix sum of noof2\\'s and noof5\\'s.`\\n#### 3) `4 matrices are top2,down2,right2 and left2`\\n#### 4) `Now iterate through the Grid and get max of all possible paths like top-right,top-left,top-down..... for each possibility we need to find min(noof2\\'s, noof5\\'s);`\\n#### 5) `Now just store the max of all possible corner points... that is our ans.`\\n\\n#### *I have completed implementation of this just 7 min before the contest\\'s deadline \\uD83D\\uDE01*.\\n#### *And this is my first solution which beat 100% in both time and space complexity*.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    pair<int,int> trailZeros(int N){\\n        int count = 0;\\n        int twos = 0;\\n        int fives = 0;\\n        for (int i = 0; i < 1; i++){\\n          while(N%2==0 || N%5==0){\\n             if(N%2==0){\\n                N=N/2;\\n                twos++;\\n             }\\n             if(N%5==0){\\n                N=N/5;\\n                fives++;\\n             }\\n          }\\n       }\\n       // count=twos<fives?twos:fives;\\n       return {twos,fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        ans=0;\\n        vector<vector<pair<int,int>>> Grid(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                Grid[i][j]=trailZeros(grid[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<pair<int,int>>>top2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>down2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>left2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>right2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=0;j<grid[0].size();j++){\\n                left2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n                right2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=0;i<grid.size();i++){\\n                \\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n                top2[i][j]=temp;\\n            }\\n        }\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=grid.size()-1;i>=0;i--){\\n                down2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;             \\n            }\\n        }\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                pair<int,int> top;\\n                pair<int,int> left;\\n                pair<int,int> down;\\n                pair<int,int> right;\\n                int curr2=0;\\n                int curr5=0;\\n                \\n                curr2=top2[i][j].first;\\n                curr5=top2[i][j].second;\\n                top.first=curr2;\\n                top.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=down2[i][j].first;\\n                curr5=down2[i][j].second;\\n                down.first=curr2;\\n                down.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=left2[i][j].first;\\n                curr5=left2[i][j].second;\\n                left.first=curr2;\\n                left.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=right2[i][j].first;\\n                curr5=right2[i][j].second;\\n                right.first=curr2;\\n                right.second=curr5;\\n                \\n                ans=max(ans,max({min(top.first+down.first,top.second+down.second),min(top.first+right.first,top.second+right.second),min(top.first+left.first,top.second+left.second),min(left.first+right.first+Grid[i][j].first,left.second+right.second+Grid[i][j].second),min(left.first+down.first+Grid[i][j].first,left.second+down.second+Grid[i][j].second),min(down.first+right.first+Grid[i][j].first,down.second+right.second+Grid[i][j].second)}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    pair<int,int> trailZeros(int N){\\n        int count = 0;\\n        int twos = 0;\\n        int fives = 0;\\n        for (int i = 0; i < 1; i++){\\n          while(N%2==0 || N%5==0){\\n             if(N%2==0){\\n                N=N/2;\\n                twos++;\\n             }\\n             if(N%5==0){\\n                N=N/5;\\n                fives++;\\n             }\\n          }\\n       }\\n       // count=twos<fives?twos:fives;\\n       return {twos,fives};\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        ans=0;\\n        vector<vector<pair<int,int>>> Grid(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                Grid[i][j]=trailZeros(grid[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<pair<int,int>>>top2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>down2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>left2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        vector<vector<pair<int,int>>>right2(grid.size(),vector<pair<int,int>>(grid[0].size()));\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=0;j<grid[0].size();j++){\\n                left2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int i=0;i<grid.size();i++){\\n            pair<int,int> temp={0,0};\\n            for(int j=grid[0].size()-1;j>=0;j--){\\n                right2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n            }\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=0;i<grid.size();i++){\\n                \\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;\\n                top2[i][j]=temp;\\n            }\\n        }\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            pair<int,int> temp={0,0};\\n            for(int i=grid.size()-1;i>=0;i--){\\n                down2[i][j]=temp;\\n                temp.first+=Grid[i][j].first;\\n                temp.second+=Grid[i][j].second;             \\n            }\\n        }\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                pair<int,int> top;\\n                pair<int,int> left;\\n                pair<int,int> down;\\n                pair<int,int> right;\\n                int curr2=0;\\n                int curr5=0;\\n                \\n                curr2=top2[i][j].first;\\n                curr5=top2[i][j].second;\\n                top.first=curr2;\\n                top.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=down2[i][j].first;\\n                curr5=down2[i][j].second;\\n                down.first=curr2;\\n                down.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=left2[i][j].first;\\n                curr5=left2[i][j].second;\\n                left.first=curr2;\\n                left.second=curr5;\\n                curr2=0;\\n                curr5=0;\\n                \\n                curr2=right2[i][j].first;\\n                curr5=right2[i][j].second;\\n                right.first=curr2;\\n                right.second=curr5;\\n                \\n                ans=max(ans,max({min(top.first+down.first,top.second+down.second),min(top.first+right.first,top.second+right.second),min(top.first+left.first,top.second+left.second),min(left.first+right.first+Grid[i][j].first,left.second+right.second+Grid[i][j].second),min(left.first+down.first+Grid[i][j].first,left.second+down.second+Grid[i][j].second),min(down.first+right.first+Grid[i][j].first,down.second+right.second+Grid[i][j].second)}));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956246,
                "title": "c-ac-solution-2d-perfix-sum",
                "content": "count factor 2 and 5 for each, ignore other factor\\ncalculate perfix sum in H and V\\n\\ntraverse answer in 2D matrix, try 4 directions top left, top right, bottom left, bottom right\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int p(int num,int k) {\\n        int ret = 0;\\n        \\n        while(num % k == 0) {\\n            num /=k;\\n            ret++;\\n        }\\n        \\n        return ret;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = size(grid);\\n        int n = size(grid[0]);\\n\\n        int p2[m][n];\\n        int p5[m][n];\\n        int h2[m+1][n+1];\\n        int h5[m+1][n+1];\\n        int v2[m+1][n+1];\\n        int v5[m+1][n+1];\\n        \\n        h2[0][0] = 0;\\n        h5[0][0] = 0;\\n        v2[0][0] = 0;\\n        v5[0][0] = 0;\\n\\n        for (int i=0; i<m; i++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[i+1][0] = 0;\\n            h5[i+1][0] = 0;\\n            v2[i+1][0] = 0;\\n            v5[i+1][0] = 0;\\n            for (int j=0; j<n; j++) {\\n                p2[i][j] =  p(grid[i][j], 2);\\n                p5[i][j] =  p(grid[i][j], 5);\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                h2[i+1][j+1] = sum2;\\n                h5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        for (int j=0; j<n; j++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[0][j+1] = 0;\\n            h5[0][j+1] = 0;\\n            v2[0][j+1] = 0;\\n            v5[0][j+1] = 0;\\n            for (int i=0; i<m; i++) {\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                v2[i+1][j+1] = sum2;\\n                v5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        /*\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                cout << p2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << h2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << v2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n        */\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][j]                + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][j]                + v5[m][j+1] - v5[i+1][j+1]) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[m][j+1] - v5[i+1][j+1]) );\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int p(int num,int k) {\\n        int ret = 0;\\n        \\n        while(num % k == 0) {\\n            num /=k;\\n            ret++;\\n        }\\n        \\n        return ret;\\n    }\\n\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = size(grid);\\n        int n = size(grid[0]);\\n\\n        int p2[m][n];\\n        int p5[m][n];\\n        int h2[m+1][n+1];\\n        int h5[m+1][n+1];\\n        int v2[m+1][n+1];\\n        int v5[m+1][n+1];\\n        \\n        h2[0][0] = 0;\\n        h5[0][0] = 0;\\n        v2[0][0] = 0;\\n        v5[0][0] = 0;\\n\\n        for (int i=0; i<m; i++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[i+1][0] = 0;\\n            h5[i+1][0] = 0;\\n            v2[i+1][0] = 0;\\n            v5[i+1][0] = 0;\\n            for (int j=0; j<n; j++) {\\n                p2[i][j] =  p(grid[i][j], 2);\\n                p5[i][j] =  p(grid[i][j], 5);\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                h2[i+1][j+1] = sum2;\\n                h5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        for (int j=0; j<n; j++) {\\n            int sum2 = 0;\\n            int sum5 = 0;\\n            h2[0][j+1] = 0;\\n            h5[0][j+1] = 0;\\n            v2[0][j+1] = 0;\\n            v5[0][j+1] = 0;\\n            for (int i=0; i<m; i++) {\\n                sum2 += p2[i][j];\\n                sum5 += p5[i][j];\\n                v2[i+1][j+1] = sum2;\\n                v5[i+1][j+1] = sum5;\\n            }\\n        }\\n\\n        /*\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                cout << p2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << h2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n\\n        for (int i=0; i<=m; i++) {\\n            for (int j=0; j<=n; j++) {\\n                cout << v2[i][j] <<\" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        cout << \"\\\\n\";\\n        */\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][j]                + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[i][j+1]               , \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[i][j+1]               ) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][j]                + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][j]                + v5[m][j+1] - v5[i+1][j+1]) );\\n                ret = max(ret, min(p2[i][j] + h2[i+1][n] - h2[i+1][j+1] + v2[m][j+1] - v2[i+1][j+1], \\n                                   p5[i][j] + h5[i+1][n] - h5[i+1][j+1] + v5[m][j+1] - v5[i+1][j+1]) );\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1956241,
                "title": "a-straight-forward-implementation-of-factors-2-and-5-and-prefix-sum",
                "content": "1. A good observation: any tailing 0 must come from a factor of 10, which in turn must come from a factor of 2 and a factor of 5.\\n   number of factor of 10 = min(number of factor of 2, number of factor of 5)\\n2. A *cornered path* is literally equal to a *vertical path* and a *horizontal path* jointed at some cell (*i*, *j*).\\n3. This code appears lengthy, but the logic is plain. I deliberatelly put it this way to make it easy to read.\\n\\n```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tvector<vector<int>> five(m, vector<int>(n));\\n\\tvector<vector<int>> two(m, vector<int>(n));\\n\\tvector<vector<int>> row_pre_two(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_two(m + 1, vector<int>(n));\\n\\tvector<vector<int>> row_pre_five(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_five(m + 1, vector<int>(n));\\n\\t\\n\\t// count the number of factors of 2 and 5.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\tint v = grid[i][j];\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 5 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ five[i][j];\\n\\t\\t\\t\\tv /= 5;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ two[i][j];\\n\\t\\t\\t\\tv /= 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in row-base.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\trow_pre_five[i][j + 1] = row_pre_five[i][j] + five[i][j];\\n\\t\\t\\trow_pre_two [i][j + 1] = row_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in column-base.\\n\\tfor (int j = 0; j < n; ++j)\\n\\t\\tfor (int i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tcol_pre_five[i + 1][j] = col_pre_five[i][j] + five[i][j];\\n\\t\\t\\tcol_pre_two [i + 1][j] = col_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\tint ret = 0;\\n\\t\\n\\t// for every cell,\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\t// find how many factor of 5\\'s in n, s, w, e directions.\\n\\t\\t\\tint n_five = col_pre_five[i][j];\\n\\t\\t\\tint s_five = col_pre_five[m][j] - n_five - five[i][j];\\n\\t\\t\\tint w_five = row_pre_five[i][j];\\n\\t\\t\\tint e_five = row_pre_five[i][n] - w_five - five[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 2\\'s in 4 directions.\\n\\t\\t\\tint n_two = col_pre_two[i][j];\\n\\t\\t\\tint s_two = col_pre_two[m][j] - n_two - two[i][j];\\n\\t\\t\\tint w_two = row_pre_two[i][j];\\n\\t\\t\\tint e_two = row_pre_two[i][n] - w_two - two[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 10\\'s in any of the 2 allowable directions jointed in the current (i, j).\\n\\t\\t\\tint nw_ten = min(n_five + w_five + five[i][j], n_two + w_two + two[i][j]);\\n\\t\\t\\tint ne_ten = min(n_five + e_five + five[i][j], n_two + e_two + two[i][j]);\\n\\t\\t\\tint sw_ten = min(s_five + w_five + five[i][j], s_two + w_two + two[i][j]);\\n\\t\\t\\tint se_ten = min(s_five + e_five + five[i][j], s_two + e_two + two[i][j]);\\n\\t\\t\\t\\n\\t\\t\\t// update local max\\n\\t\\t\\tint max_ten = max(max(nw_ten, ne_ten), max(sw_ten, se_ten));\\n\\t\\t\\t\\n\\t\\t\\t// update global max\\n\\t\\t\\tret = max(ret, max_ten);\\n\\t\\t}\\n\\t\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxTrailingZeros(vector<vector<int>>& grid) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tvector<vector<int>> five(m, vector<int>(n));\\n\\tvector<vector<int>> two(m, vector<int>(n));\\n\\tvector<vector<int>> row_pre_two(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_two(m + 1, vector<int>(n));\\n\\tvector<vector<int>> row_pre_five(m, vector<int>(n + 1));\\n\\tvector<vector<int>> col_pre_five(m + 1, vector<int>(n));\\n\\t\\n\\t// count the number of factors of 2 and 5.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\tint v = grid[i][j];\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 5 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ five[i][j];\\n\\t\\t\\t\\tv /= 5;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\twhile (v && v % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t++ two[i][j];\\n\\t\\t\\t\\tv /= 2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in row-base.\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\trow_pre_five[i][j + 1] = row_pre_five[i][j] + five[i][j];\\n\\t\\t\\trow_pre_two [i][j + 1] = row_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\t// calculate prefix-sum in column-base.\\n\\tfor (int j = 0; j < n; ++j)\\n\\t\\tfor (int i = 0; i < m; ++i)\\n\\t\\t{\\n\\t\\t\\tcol_pre_five[i + 1][j] = col_pre_five[i][j] + five[i][j];\\n\\t\\t\\tcol_pre_two [i + 1][j] = col_pre_two [i][j] + two [i][j];\\n\\t\\t}\\n\\t\\n\\tint ret = 0;\\n\\t\\n\\t// for every cell,\\n\\tfor (int i = 0; i < m; ++i)\\n\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t{\\n\\t\\t\\t// find how many factor of 5\\'s in n, s, w, e directions.\\n\\t\\t\\tint n_five = col_pre_five[i][j];\\n\\t\\t\\tint s_five = col_pre_five[m][j] - n_five - five[i][j];\\n\\t\\t\\tint w_five = row_pre_five[i][j];\\n\\t\\t\\tint e_five = row_pre_five[i][n] - w_five - five[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 2\\'s in 4 directions.\\n\\t\\t\\tint n_two = col_pre_two[i][j];\\n\\t\\t\\tint s_two = col_pre_two[m][j] - n_two - two[i][j];\\n\\t\\t\\tint w_two = row_pre_two[i][j];\\n\\t\\t\\tint e_two = row_pre_two[i][n] - w_two - two[i][j];\\n\\t\\t\\t\\n\\t\\t\\t// find how many factor of 10\\'s in any of the 2 allowable directions jointed in the current (i, j).\\n\\t\\t\\tint nw_ten = min(n_five + w_five + five[i][j], n_two + w_two + two[i][j]);\\n\\t\\t\\tint ne_ten = min(n_five + e_five + five[i][j], n_two + e_two + two[i][j]);\\n\\t\\t\\tint sw_ten = min(s_five + w_five + five[i][j], s_two + w_two + two[i][j]);\\n\\t\\t\\tint se_ten = min(s_five + e_five + five[i][j], s_two + e_two + two[i][j]);\\n\\t\\t\\t\\n\\t\\t\\t// update local max\\n\\t\\t\\tint max_ten = max(max(nw_ten, ne_ten), max(sw_ten, se_ten));\\n\\t\\t\\t\\n\\t\\t\\t// update global max\\n\\t\\t\\tret = max(ret, max_ten);\\n\\t\\t}\\n\\t\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956164,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] fromLeft = new int[m + 1][n + 1][2];\\n        int[][][] fromTop = new int[m + 1][n + 1][2];\\n\\n        //prefix sum of 5s and 2s from left\\n        for (int i = 0; i < m; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < n; j++) {\\n                numOf5s += numOfNs(grid[i][j], 5);\\n                numOf2s += numOfNs(grid[i][j], 2);\\n                fromLeft[i + 1][j + 1][0] = numOf5s;\\n                fromLeft[i + 1][j + 1][1] = numOf2s;\\n            }\\n        }\\n        //prefix sum of 5s and 2s from top\\n        for (int i = 0; i < n; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < m; j++) {\\n                numOf5s += numOfNs(grid[j][i], 5);\\n                numOf2s += numOfNs(grid[j][i], 2);\\n                fromTop[j + 1][i + 1][0] = numOf5s;\\n                fromTop[j + 1][i + 1][1] = numOf2s;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                int topLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[i - 1][j][0],\\n                        fromLeft[i][j][1] + fromTop[i - 1][j][1]);\\n                int topRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j][0] + fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j][1] + fromTop[i][j][1]);\\n                int bottomLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][j][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n                int bottomRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j - 1][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j - 1][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n\\n                max = Math.max(max, Math.max(Math.max(topLeft, topRight), Math.max(bottomLeft, bottomRight)));\\n            }\\n        }\\n        return max;\\n    }\\n    //count the number of 5s or 2s \\n    private int numOfNs(int a, int n) {\\n        int count = 0;\\n        while (a % n == 0) {\\n            count++;\\n            a /= n;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] fromLeft = new int[m + 1][n + 1][2];\\n        int[][][] fromTop = new int[m + 1][n + 1][2];\\n\\n        //prefix sum of 5s and 2s from left\\n        for (int i = 0; i < m; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < n; j++) {\\n                numOf5s += numOfNs(grid[i][j], 5);\\n                numOf2s += numOfNs(grid[i][j], 2);\\n                fromLeft[i + 1][j + 1][0] = numOf5s;\\n                fromLeft[i + 1][j + 1][1] = numOf2s;\\n            }\\n        }\\n        //prefix sum of 5s and 2s from top\\n        for (int i = 0; i < n; i++) {\\n            int numOf5s = 0;\\n            int numOf2s = 0;\\n            for (int j = 0; j < m; j++) {\\n                numOf5s += numOfNs(grid[j][i], 5);\\n                numOf2s += numOfNs(grid[j][i], 2);\\n                fromTop[j + 1][i + 1][0] = numOf5s;\\n                fromTop[j + 1][i + 1][1] = numOf2s;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                int topLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[i - 1][j][0],\\n                        fromLeft[i][j][1] + fromTop[i - 1][j][1]);\\n                int topRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j][0] + fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j][1] + fromTop[i][j][1]);\\n                int bottomLeft = Math.min(\\n                        fromLeft[i][j][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][j][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n                int bottomRight = Math.min(\\n                        fromLeft[i][n][0] - fromLeft[i][j - 1][0] + fromTop[m][j][0] - fromTop[i][j][0],\\n                        fromLeft[i][n][1] - fromLeft[i][j - 1][1] + fromTop[m][j][1] - fromTop[i][j][1]);\\n\\n                max = Math.max(max, Math.max(Math.max(topLeft, topRight), Math.max(bottomLeft, bottomRight)));\\n            }\\n        }\\n        return max;\\n    }\\n    //count the number of 5s or 2s \\n    private int numOfNs(int a, int n) {\\n        int count = 0;\\n        while (a % n == 0) {\\n            count++;\\n            a /= n;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956160,
                "title": "java-faster-than-100-less-memory-than-100-o-m-n-space-time-complexity-solution",
                "content": "```\\nclass Solution {\\n    class Point {\\n        int powerOfTwo;\\n        int powerOfFive;\\n        \\n         public Point() {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n        }\\n\\n        public Point(int num) {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n            \\n            while(num%2 == 0) {\\n                powerOfTwo++;\\n                num /= 2;\\n            }\\n            \\n            while(num%5 == 0) {\\n                powerOfFive++;\\n                num /= 5;\\n            }\\n        }\\n        \\n        private Point add(Point point) {\\n            powerOfTwo += point.powerOfTwo;\\n            powerOfFive += point.powerOfFive;\\n            return this;\\n        }\\n        \\n                \\n        private Point subtract(Point point) {\\n            powerOfTwo -= point.powerOfTwo;\\n            powerOfFive -= point.powerOfFive;\\n            return this;\\n        }\\n        \\n        \\n        private int getNumberOfZeros() {\\n            return Math.min(powerOfTwo, powerOfFive);\\n        }\\n    }\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        // Keeps track of power of 2 & 5 per entry in grid\\n        Point[][] values = new Point[grid.length][grid[0].length];\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                values[i][j] = new Point(grid[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per row\\n        // calcH[i][j] => value for row i, col 0 to j\\n        Point[][] calcH = new Point[grid.length][grid[0].length];\\n        for(int i = 0;   i < grid.length; i++) {\\n            calcH[i][0] = values[i][0];\\n            for(int j = 1; j < grid[0].length; j++) {\\n                calcH[i][j] = new Point().add(calcH[i][j-1]).add(values[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per col\\n        Point[][] calcV = new Point[grid.length][grid[0].length];\\n        \\n        for(int j = 0;   j < grid[0].length; j++) {\\n            calcV[0][j] = values[0][j];\\n            for(int i = 1; i < grid.length; i++) {\\n                calcV[i][j] = new Point().add(calcV[i-1][j]).add(values[i][j]);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                // _| => Vertical till i,j And then Horizontal till i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .subtract(values[i][j]) // this has been added twice\\n                               .getNumberOfZeros());\\n                // |_ => Vertical till i,j And then Horizontal beyond i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .getNumberOfZeros());\\n                //   _  Horizontal till i,j And and then vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .getNumberOfZeros());                           \\n                //     _  Horizontal beyond i,j And vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .add(values[i][j])\\n                               .getNumberOfZeros());  \\n\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Point {\\n        int powerOfTwo;\\n        int powerOfFive;\\n        \\n         public Point() {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n        }\\n\\n        public Point(int num) {\\n            powerOfTwo = 0;\\n            powerOfFive = 0;\\n            \\n            while(num%2 == 0) {\\n                powerOfTwo++;\\n                num /= 2;\\n            }\\n            \\n            while(num%5 == 0) {\\n                powerOfFive++;\\n                num /= 5;\\n            }\\n        }\\n        \\n        private Point add(Point point) {\\n            powerOfTwo += point.powerOfTwo;\\n            powerOfFive += point.powerOfFive;\\n            return this;\\n        }\\n        \\n                \\n        private Point subtract(Point point) {\\n            powerOfTwo -= point.powerOfTwo;\\n            powerOfFive -= point.powerOfFive;\\n            return this;\\n        }\\n        \\n        \\n        private int getNumberOfZeros() {\\n            return Math.min(powerOfTwo, powerOfFive);\\n        }\\n    }\\n    \\n    public int maxTrailingZeros(int[][] grid) {\\n        // Keeps track of power of 2 & 5 per entry in grid\\n        Point[][] values = new Point[grid.length][grid[0].length];\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                values[i][j] = new Point(grid[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per row\\n        // calcH[i][j] => value for row i, col 0 to j\\n        Point[][] calcH = new Point[grid.length][grid[0].length];\\n        for(int i = 0;   i < grid.length; i++) {\\n            calcH[i][0] = values[i][0];\\n            for(int j = 1; j < grid[0].length; j++) {\\n                calcH[i][j] = new Point().add(calcH[i][j-1]).add(values[i][j]);\\n            }\\n        }\\n        \\n        // Keeps track of power of 2 & 5 per entry in grid per col\\n        Point[][] calcV = new Point[grid.length][grid[0].length];\\n        \\n        for(int j = 0;   j < grid[0].length; j++) {\\n            calcV[0][j] = values[0][j];\\n            for(int i = 1; i < grid.length; i++) {\\n                calcV[i][j] = new Point().add(calcV[i-1][j]).add(values[i][j]);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                // _| => Vertical till i,j And then Horizontal till i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .subtract(values[i][j]) // this has been added twice\\n                               .getNumberOfZeros());\\n                // |_ => Vertical till i,j And then Horizontal beyond i,j\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[i][j])\\n                               .getNumberOfZeros());\\n                //   _  Horizontal till i,j And and then vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .getNumberOfZeros());                           \\n                //     _  Horizontal beyond i,j And vertical below i,j\\n                //    |\\n                ans = Math.max(ans, new Point().add(calcH[i][grid[0].length-1])\\n                               .subtract(calcH[i][j])\\n                               .add(calcV[grid.length-1][j])\\n                               .subtract(calcV[i][j])\\n                               .add(values[i][j])\\n                               .getNumberOfZeros());  \\n\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956107,
                "title": "prefix-and-suffix-sums",
                "content": "Store all counts of 5s and 2s in a prefix and suffix arrays starting from left, right, up and down and add them while making a transition or if you choose to make no transition. Find max value from all such transitions.\\n```\\nclass Solution {\\n    \\n    int cnt2s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%2 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    \\n    int cnt5s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%5 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=5;\\n        }\\n        return cnt;\\n    }\\n    \\n    int turn(vector<int>& a, vector<int>& b){\\n        return min(a[0]+b[0], a[1]+b[1]);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>>dpl(n, vector<vector<int>>(m, vector<int>(2))),dpr(n, vector<vector<int>>(m, vector<int>(2))),dpu(n, vector<vector<int>>(m, vector<int>(2))),dpd(n, vector<vector<int>>(m, vector<int>(2)));\\n    \\n            \\n        // dpl\\n        for(int i=0;i<n;i++) {\\n            dpl[i][0][0] = cnt2s(grid[i][0]);\\n            dpl[i][0][1] = cnt5s(grid[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dpl[i][j][0] = cnt2s(grid[i][j]) + dpl[i][j-1][0];\\n                dpl[i][j][1] = cnt5s(grid[i][j]) + dpl[i][j-1][1];\\n            }\\n        }\\n\\n        // dpr\\n        for(int i=0;i<n;i++) {\\n            dpr[i][m-1][0] = cnt2s(grid[i][m-1]);\\n            dpr[i][m-1][1] = cnt5s(grid[i][m-1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-2;j>=0;j--){\\n                dpr[i][j][0] = cnt2s(grid[i][j]) + dpr[i][j+1][0];\\n                dpr[i][j][1] = cnt5s(grid[i][j]) + dpr[i][j+1][1];\\n            }\\n        }\\n        \\n        // dpu\\n        for(int j=0;j<m;j++) {\\n            dpu[0][j][0] = cnt2s(grid[0][j]);\\n            dpu[0][j][1] = cnt5s(grid[0][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                dpu[i][j][0] = cnt2s(grid[i][j]) + dpu[i-1][j][0];\\n                dpu[i][j][1] = cnt5s(grid[i][j]) + dpu[i-1][j][1];\\n            }\\n        }\\n        \\n        // dpd\\n        for(int j=0;j<m;j++) {\\n            dpd[n-1][j][0] = cnt2s(grid[n-1][j]);\\n            dpd[n-1][j][1] = cnt5s(grid[n-1][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=n-2;i>=0;i--){\\n                dpd[i][j][0] = cnt2s(grid[i][j]) + dpd[i+1][j][0];\\n                dpd[i][j][1] = cnt5s(grid[i][j]) + dpd[i+1][j][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // l - r\\n                // l - u\\n                // l - d\\n                // u - d \\n                // u - r\\n                // r - d\\n                \\n                if(j+1 < m) ans = max(ans, turn(dpl[i][j], dpr[i][j+1]));\\n                if(i-1 >= 0)ans = max(ans, turn(dpl[i][j], dpu[i-1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpl[i][j], dpd[i+1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpu[i][j], dpd[i+1][j]));\\n                if(j+1 < m) ans = max(ans, turn(dpu[i][j], dpr[i][j+1]));\\n                if(i+1 < n) ans = max(ans, turn(dpr[i][j], dpd[i+1][j]));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int cnt2s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%2 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    \\n    int cnt5s(int n){\\n        int cnt = 0;\\n        while(n>0){\\n            if(n%5 == 0) cnt++;\\n            else return cnt;\\n            \\n            n/=5;\\n        }\\n        return cnt;\\n    }\\n    \\n    int turn(vector<int>& a, vector<int>& b){\\n        return min(a[0]+b[0], a[1]+b[1]);\\n    }\\n    \\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>>dpl(n, vector<vector<int>>(m, vector<int>(2))),dpr(n, vector<vector<int>>(m, vector<int>(2))),dpu(n, vector<vector<int>>(m, vector<int>(2))),dpd(n, vector<vector<int>>(m, vector<int>(2)));\\n    \\n            \\n        // dpl\\n        for(int i=0;i<n;i++) {\\n            dpl[i][0][0] = cnt2s(grid[i][0]);\\n            dpl[i][0][1] = cnt5s(grid[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dpl[i][j][0] = cnt2s(grid[i][j]) + dpl[i][j-1][0];\\n                dpl[i][j][1] = cnt5s(grid[i][j]) + dpl[i][j-1][1];\\n            }\\n        }\\n\\n        // dpr\\n        for(int i=0;i<n;i++) {\\n            dpr[i][m-1][0] = cnt2s(grid[i][m-1]);\\n            dpr[i][m-1][1] = cnt5s(grid[i][m-1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-2;j>=0;j--){\\n                dpr[i][j][0] = cnt2s(grid[i][j]) + dpr[i][j+1][0];\\n                dpr[i][j][1] = cnt5s(grid[i][j]) + dpr[i][j+1][1];\\n            }\\n        }\\n        \\n        // dpu\\n        for(int j=0;j<m;j++) {\\n            dpu[0][j][0] = cnt2s(grid[0][j]);\\n            dpu[0][j][1] = cnt5s(grid[0][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                dpu[i][j][0] = cnt2s(grid[i][j]) + dpu[i-1][j][0];\\n                dpu[i][j][1] = cnt5s(grid[i][j]) + dpu[i-1][j][1];\\n            }\\n        }\\n        \\n        // dpd\\n        for(int j=0;j<m;j++) {\\n            dpd[n-1][j][0] = cnt2s(grid[n-1][j]);\\n            dpd[n-1][j][1] = cnt5s(grid[n-1][j]);\\n        }\\n        for(int j=0;j<m;j++){\\n            for(int i=n-2;i>=0;i--){\\n                dpd[i][j][0] = cnt2s(grid[i][j]) + dpd[i+1][j][0];\\n                dpd[i][j][1] = cnt5s(grid[i][j]) + dpd[i+1][j][1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // l - r\\n                // l - u\\n                // l - d\\n                // u - d \\n                // u - r\\n                // r - d\\n                \\n                if(j+1 < m) ans = max(ans, turn(dpl[i][j], dpr[i][j+1]));\\n                if(i-1 >= 0)ans = max(ans, turn(dpl[i][j], dpu[i-1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpl[i][j], dpd[i+1][j]));\\n                if(i+1 < n) ans = max(ans, turn(dpu[i][j], dpd[i+1][j]));\\n                if(j+1 < m) ans = max(ans, turn(dpu[i][j], dpr[i][j+1]));\\n                if(i+1 < n) ans = max(ans, turn(dpr[i][j], dpd[i+1][j]));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956079,
                "title": "can-anyone-find-mistake-in-my-code-please",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<pair<int,int>>> v(m, vector<pair<int,int>>(n,{0,0})), h(m, vector<pair<int,int>>(n,{0,0}));\\n        \\n        for (int i = 0; i < m; i++) {\\n            int c5 = 0, c2 = 0;\\n            for (int j = 0; j < n; j++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                h[i][j] = {c2,c5};\\n                //cout << h[i][j].first << \"-\" << h[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            int c5 = 0, c2 = 0;\\n            for (int i = 0; i < m; i++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                v[i][j] = {c2,c5};\\n                //cout << v[i][j].first << \"-\" << v[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        int ma = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int l0 = 0, \\n                    r0 = min (h[i][n-1].first-h[i][j].first, h[i][n-1].second-h[i][j].second), \\n                    u0 = min (v[i][j].first, v[i][j].second), \\n                    d0 = min (v[m-1][j].first, v[m-1][j].second);\\n                \\n                if (i != 0) d0 = min (v[m-1][j].first-v[i-1][j].first, v[m-1][j].second-v[i-1][j].second);\\n                \\n                if (j > 0) l0 = min (h[i][j-1].first, h[i][j-1].second);\\n                \\n                int tma = max(max(u0+l0, u0+r0),max(d0+l0, d0+r0));\\n                //cout << tma << endl;\\n                ma = max(ma, tma);\\n            }\\n        }\\n        \\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<pair<int,int>>> v(m, vector<pair<int,int>>(n,{0,0})), h(m, vector<pair<int,int>>(n,{0,0}));\\n        \\n        for (int i = 0; i < m; i++) {\\n            int c5 = 0, c2 = 0;\\n            for (int j = 0; j < n; j++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                h[i][j] = {c2,c5};\\n                //cout << h[i][j].first << \"-\" << h[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            int c5 = 0, c2 = 0;\\n            for (int i = 0; i < m; i++) {\\n                int val = grid[i][j];\\n                while(val%5 == 0) {\\n                    val /= 5;\\n                    c5++;\\n                }\\n                \\n                while(val%2 == 0) {\\n                    val /= 2;\\n                    c2++;\\n                }\\n                \\n                v[i][j] = {c2,c5};\\n                //cout << v[i][j].first << \"-\" << v[i][j].second << \" \";\\n            }\\n            \\n            //cout << endl;\\n        }\\n        \\n        int ma = 0;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int l0 = 0, \\n                    r0 = min (h[i][n-1].first-h[i][j].first, h[i][n-1].second-h[i][j].second), \\n                    u0 = min (v[i][j].first, v[i][j].second), \\n                    d0 = min (v[m-1][j].first, v[m-1][j].second);\\n                \\n                if (i != 0) d0 = min (v[m-1][j].first-v[i-1][j].first, v[m-1][j].second-v[i-1][j].second);\\n                \\n                if (j > 0) l0 = min (h[i][j-1].first, h[i][j-1].second);\\n                \\n                int tma = max(max(u0+l0, u0+r0),max(d0+l0, d0+r0));\\n                //cout << tma << endl;\\n                ma = max(ma, tma);\\n            }\\n        }\\n        \\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1956077,
                "title": "c-o-m-n-time-space",
                "content": "```\\nstruct ten{\\n    int two, five;\\n    ten( int t, int f){\\n        two=t;\\n        five=f;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int max_ten=0, m=grid.size(), n=grid[0].size();\\n        ten init=ten( 0, 0);\\n        vector<vector<ten>> up( m, vector<ten> (n, init) ), down( m, vector<ten> (n, init) ),\\n            left( m, vector<ten> (n, init) ), right( m, vector<ten> (n, init) );\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            // from left \\n            left[i][0]=calculateTen( grid[i][0], init);\\n            for( int j=1; j<grid[0].size(); j++){// left \\n                left[i][j]=calculateTen( grid[i][j], left[i][j-1]);\\n            }\\n            // from right \\n            right[i][n-1]=calculateTen( grid[i][n-1], init);\\n            for( int j=n-2; -1<j; j--){\\n                right[i][j]=calculateTen( grid[i][j], right[i][j+1]);\\n            }\\n        }\\n        \\n        for( int j=0; j<grid[0].size(); j++){\\n            // from up \\n            up[0][j]=calculateTen( grid[0][j], init);\\n            for( int i=1; i<grid.size(); i++){\\n                up[i][j]=calculateTen( grid[i][j], up[i-1][j]);\\n            }\\n            // from down \\n            down[m-1][j]=calculateTen( grid[m-1][j], init);\\n            for( int i=m-2; -1<i; i--){\\n                down[i][j]=calculateTen( grid[i][j], down[i+1][j]);\\n            }\\n        }\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            for( int j=0; j<grid[0].size(); j++){\\n                calMaxTen( up[i][j], i+1<m?down[i+1][j]:init, max_ten);\\n                calMaxTen( up[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( up[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( down[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( down[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( left[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n            }\\n        }\\n        \\n        return max_ten;\\n    }\\n    \\nprotected:\\n    ten calculateTen( int num, ten t){\\n        for( ; num%2==0; num=num/2, t.two++){}\\n        for( ; num%5==0; num=num/5, t.five++){}\\n        return t;\\n    }\\n    \\n    void calMaxTen( ten t1, ten t2, int & max_ten){\\n        int two=t1.two+t2.two, five=t1.five+t2.five, \\n            t=two<five?two:five;\\n        if(max_ten<t)\\n            max_ten=t;\\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ten{\\n    int two, five;\\n    ten( int t, int f){\\n        two=t;\\n        five=f;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int max_ten=0, m=grid.size(), n=grid[0].size();\\n        ten init=ten( 0, 0);\\n        vector<vector<ten>> up( m, vector<ten> (n, init) ), down( m, vector<ten> (n, init) ),\\n            left( m, vector<ten> (n, init) ), right( m, vector<ten> (n, init) );\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            // from left \\n            left[i][0]=calculateTen( grid[i][0], init);\\n            for( int j=1; j<grid[0].size(); j++){// left \\n                left[i][j]=calculateTen( grid[i][j], left[i][j-1]);\\n            }\\n            // from right \\n            right[i][n-1]=calculateTen( grid[i][n-1], init);\\n            for( int j=n-2; -1<j; j--){\\n                right[i][j]=calculateTen( grid[i][j], right[i][j+1]);\\n            }\\n        }\\n        \\n        for( int j=0; j<grid[0].size(); j++){\\n            // from up \\n            up[0][j]=calculateTen( grid[0][j], init);\\n            for( int i=1; i<grid.size(); i++){\\n                up[i][j]=calculateTen( grid[i][j], up[i-1][j]);\\n            }\\n            // from down \\n            down[m-1][j]=calculateTen( grid[m-1][j], init);\\n            for( int i=m-2; -1<i; i--){\\n                down[i][j]=calculateTen( grid[i][j], down[i+1][j]);\\n            }\\n        }\\n        \\n        for( int i=0; i<grid.size(); i++){\\n            for( int j=0; j<grid[0].size(); j++){\\n                calMaxTen( up[i][j], i+1<m?down[i+1][j]:init, max_ten);\\n                calMaxTen( up[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( up[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( down[i][j], 0<j?left[i][j-1]:init, max_ten);\\n                calMaxTen( down[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n                calMaxTen( left[i][j], j+1<n?right[i][j+1]:init, max_ten);\\n            }\\n        }\\n        \\n        return max_ten;\\n    }\\n    \\nprotected:\\n    ten calculateTen( int num, ten t){\\n        for( ; num%2==0; num=num/2, t.two++){}\\n        for( ; num%5==0; num=num/5, t.five++){}\\n        return t;\\n    }\\n    \\n    void calMaxTen( ten t1, ten t2, int & max_ten){\\n        int two=t1.two+t2.two, five=t1.five+t2.five, \\n            t=two<five?two:five;\\n        if(max_ten<t)\\n            max_ten=t;\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956072,
                "title": "prefix-sum-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        /*\\n            \\u524D\\u7F00\\u548C\\n        */\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] hP = new int[m][n][2]; // \\u6700\\u540E\\u7684 2 \\u4F4D\\u6570\\u7EC4\\u4EE3\\u8868 [\\u591A\\u5C11\\u4E2A 5, \\u591A\\u5C11\\u4E2A 2]\\n        int[][][] vP = new int[m][n][2];\\n        int res = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                 // \\u6C34\\u5E73\\n                if (j == 0) {\\n                    hP[i][j][0] = countFive(grid[i][j]);\\n                    hP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    hP[i][j][0] = hP[i][j-1][0] + countFive(grid[i][j]);\\n                    hP[i][j][1] = hP[i][j-1][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        for (int j=0; j<n; j++) {\\n            for (int i=0; i<m; i++) {\\n                 // \\u5782\\u76F4\\n                if (i == 0) {\\n                    vP[i][j][0] = countFive(grid[i][j]);\\n                    vP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    vP[i][j][0] = vP[i-1][j][0] + countFive(grid[i][j]);\\n                    vP[i][j][1] = vP[i-1][j][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                res = Math.max(res, Math.min(hP[i][j][0] - countFive(grid[i][j]) + vP[i][j][0], hP[i][j][1] - countTwo(grid[i][j]) + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[i][j][0], hP[i][n-1][1] - hP[i][j][1] + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0], hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0] + countFive(grid[i][j]), hP[i][n-1][1] - hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1] + countTwo(grid[i][j])));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int countFive(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 5 == 0) {\\n            val = val / 5;\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    private int countTwo(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 2 == 0) {\\n            val = val / 2;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        /*\\n            \\u524D\\u7F00\\u548C\\n        */\\n        int m = grid.length, n = grid[0].length;\\n        int[][][] hP = new int[m][n][2]; // \\u6700\\u540E\\u7684 2 \\u4F4D\\u6570\\u7EC4\\u4EE3\\u8868 [\\u591A\\u5C11\\u4E2A 5, \\u591A\\u5C11\\u4E2A 2]\\n        int[][][] vP = new int[m][n][2];\\n        int res = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                 // \\u6C34\\u5E73\\n                if (j == 0) {\\n                    hP[i][j][0] = countFive(grid[i][j]);\\n                    hP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    hP[i][j][0] = hP[i][j-1][0] + countFive(grid[i][j]);\\n                    hP[i][j][1] = hP[i][j-1][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        for (int j=0; j<n; j++) {\\n            for (int i=0; i<m; i++) {\\n                 // \\u5782\\u76F4\\n                if (i == 0) {\\n                    vP[i][j][0] = countFive(grid[i][j]);\\n                    vP[i][j][1] = countTwo(grid[i][j]);\\n                } else {\\n                    vP[i][j][0] = vP[i-1][j][0] + countFive(grid[i][j]);\\n                    vP[i][j][1] = vP[i-1][j][1] + countTwo(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                res = Math.max(res, Math.min(hP[i][j][0] - countFive(grid[i][j]) + vP[i][j][0], hP[i][j][1] - countTwo(grid[i][j]) + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[i][j][0], hP[i][n-1][1] - hP[i][j][1] + vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0], hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1]));\\n                res = Math.max(res, Math.min(hP[i][n-1][0] - hP[i][j][0] + vP[m-1][j][0] - vP[i][j][0] + countFive(grid[i][j]), hP[i][n-1][1] - hP[i][j][1] + vP[m-1][j][1] - vP[i][j][1] + countTwo(grid[i][j])));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int countFive(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 5 == 0) {\\n            val = val / 5;\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    private int countTwo(int val) {\\n        int res = 0;\\n        while (val != 0 && val % 2 == 0) {\\n            val = val / 2;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955993,
                "title": "c-prefix-sum-find-the-largest-2-directions-for-each-cell",
                "content": "**Thought process :**\\n* The way to form a trailing zero is by a 2 multiply by 5.\\n\\t* So the number of trailing zeros in a straight line is min(# of 2 in a straight line, # of 5 in a straight line).\\n* Since we only allow 1 turn, we can alternatively count the number of 2s and 5s for 4 directions for each cell, and choose the biggest 2 directions (C 4 to 2) to represent the maximum number of trailing zeros for this cell.\\n* Go through every cell and find the maximum number of each cell.\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> fh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 5\\n        vector<vector<int>> fv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 5\\n        vector<vector<int>> sh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 2\\n        vector<vector<int>> sv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 2\\n        vector<vector<int>> f(m, vector<int>(n, 0));  // Number of 5 for each cell\\n        vector<vector<int>> s(m, vector<int>(n, 0));  // Number of 2 for each cell\\n        // [4 Directions] 0 : up, 1 : right, 2 : down, 3 : left\\n        vector<vector<vector<int>>> d(m*n, vector<vector<int>>(4, vector<int>(2,0)));\\n        \\n\\t\\t// Prefix sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] % 5 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 5 == 0) {\\n                        f[i][j]++;\\n                        temp /= 5;\\n                    }\\n                }\\n                if (grid[i][j] % 2 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 2 == 0) {\\n                        s[i][j]++;\\n                        temp /= 2;\\n                    }\\n                }\\n                if (j > 0) {\\n                    fh[i][j] = fh[i][j-1] + f[i][j];\\n                    sh[i][j] = sh[i][j-1] + s[i][j];\\n                }\\n                else {\\n                    fh[i][j] = f[i][j];\\n                    sh[i][j] = s[i][j];\\n                }\\n                if (i > 0) {\\n                    fv[i][j] = fv[i-1][j] + f[i][j];\\n                    sv[i][j] = sv[i-1][j] + s[i][j];\\n                }\\n                else {\\n                    fv[i][j] = f[i][j];\\n                    sv[i][j] = s[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Form the number of 2s and 5s for 4 directions of each cell\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    int fc = 0, sc = 0;\\n                    \\n                    if (k == 0) {\\n                        if (i > 0) {\\n                            fc = fv[i-1][j];\\n                            sc = sv[i-1][j];\\n                        }\\n                    }\\n                    else if (k == 1) {\\n                        fc = fh[i][n-1] - fh[i][j];\\n                        sc = sh[i][n-1] - sh[i][j];\\n                    }\\n                    else if (k == 2) {\\n                        fc = fv[m-1][j] - fv[i][j];\\n                        sc = sv[m-1][j] - sv[i][j];\\n                    }\\n                    else {\\n                        if (j > 0) {\\n                            fc = fh[i][j-1];\\n                            sc = sh[i][j-1];\\n                        }\\n                    }\\n                    d[i*n+j][k][0] = fc;\\n                    d[i*n+j][k][1] = sc;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// Go through each cell and possible combinations of every 2 directions\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    for (int l = k+1; l < 4; l++) {\\n                        int cur = min(d[i*n+j][k][0] + d[i*n+j][l][0] + f[i][j], d[i*n+j][k][1] + d[i*n+j][l][1] + s[i][j]);\\n                        ans = max(ans, cur);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> fh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 5\\n        vector<vector<int>> fv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 5\\n        vector<vector<int>> sh(m, vector<int>(n, 0));  // Prefix sum of horizontal direction for 2\\n        vector<vector<int>> sv(m, vector<int>(n, 0));  // Prefix sum of vertical direction for 2\\n        vector<vector<int>> f(m, vector<int>(n, 0));  // Number of 5 for each cell\\n        vector<vector<int>> s(m, vector<int>(n, 0));  // Number of 2 for each cell\\n        // [4 Directions] 0 : up, 1 : right, 2 : down, 3 : left\\n        vector<vector<vector<int>>> d(m*n, vector<vector<int>>(4, vector<int>(2,0)));\\n        \\n\\t\\t// Prefix sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] % 5 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 5 == 0) {\\n                        f[i][j]++;\\n                        temp /= 5;\\n                    }\\n                }\\n                if (grid[i][j] % 2 == 0) {\\n                    int temp = grid[i][j];\\n                    while (temp % 2 == 0) {\\n                        s[i][j]++;\\n                        temp /= 2;\\n                    }\\n                }\\n                if (j > 0) {\\n                    fh[i][j] = fh[i][j-1] + f[i][j];\\n                    sh[i][j] = sh[i][j-1] + s[i][j];\\n                }\\n                else {\\n                    fh[i][j] = f[i][j];\\n                    sh[i][j] = s[i][j];\\n                }\\n                if (i > 0) {\\n                    fv[i][j] = fv[i-1][j] + f[i][j];\\n                    sv[i][j] = sv[i-1][j] + s[i][j];\\n                }\\n                else {\\n                    fv[i][j] = f[i][j];\\n                    sv[i][j] = s[i][j];\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Form the number of 2s and 5s for 4 directions of each cell\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    int fc = 0, sc = 0;\\n                    \\n                    if (k == 0) {\\n                        if (i > 0) {\\n                            fc = fv[i-1][j];\\n                            sc = sv[i-1][j];\\n                        }\\n                    }\\n                    else if (k == 1) {\\n                        fc = fh[i][n-1] - fh[i][j];\\n                        sc = sh[i][n-1] - sh[i][j];\\n                    }\\n                    else if (k == 2) {\\n                        fc = fv[m-1][j] - fv[i][j];\\n                        sc = sv[m-1][j] - sv[i][j];\\n                    }\\n                    else {\\n                        if (j > 0) {\\n                            fc = fh[i][j-1];\\n                            sc = sh[i][j-1];\\n                        }\\n                    }\\n                    d[i*n+j][k][0] = fc;\\n                    d[i*n+j][k][1] = sc;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// Go through each cell and possible combinations of every 2 directions\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < 4; k++) {\\n                    for (int l = k+1; l < 4; l++) {\\n                        int cur = min(d[i*n+j][k][0] + d[i*n+j][l][0] + f[i][j], d[i*n+j][k][1] + d[i*n+j][l][1] + s[i][j]);\\n                        ans = max(ans, cur);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955959,
                "title": "java-prefix-sum-with-clear-explanation-and-code",
                "content": "**How to get trailing zeros of a number** :\\nWe need to find power of 10 i.e. power of (2\\\\*5) i.e. minimum of `(power of 2, power of 5)`\\nWe need to find power of 2 and 5 for each grid[i][j] that divides it(i.e. remainder = 0), then minimum of power of 2 and 5 is the number of trailing zeros\\nexample:\\n```\\n1200 = 2^4*5^2*3\\n```\\nthere are two trailing zeros because minimum power of 2 and 5 is 2\\n\\n**How to calculate trailling zeros of a turn**\\nTurn consists of two directions: horizontal and vertical, for every cell there are 4 options:\\n1. horizontal left and vertical up\\n2. horizontal left and vertical down\\n3. horizontal right and vertical up\\n4. horizontal right and vertical down\\n\\nif we keep prefix sum of horizontal and vertical rows we can easily calculate these 4 cases.\\nWe also need to make sure we are not counting power of one cell more than once while summing power of horizontal and vertical because current cell is common for both directions. \\nTherefore, in code below **horizontal directions are kept inclusive** and **vertical directions are kept exlusive**\\nThe comments in code shows what would have been the calculations if it\\'s not been exlusive for vertical directions\\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][][] h = new int[n+1][m+1][2]; \\n        \\n        /*\\n        direction:\\n        ---o\\n        \\n        horSum from col h1 to h2 in ith row = h[i][h1+1]-h[i][h2]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                h[i][j+1][0] = h[i][j][0] + power(grid[i][j], 2);\\n                h[i][j+1][1] = h[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        int[][][] v = new int[n+1][m+1][2]; \\n        /*\\n        direction:\\n        |\\n        |\\n        o\\n        verSum from row v1 to v2 in jth col = v[v1+1][j]-v[v2][j]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                v[i+1][j][0] = v[i][j][0] + power(grid[i][j], 2);\\n                v[i+1][j][1] = v[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i ++) {\\n            for(int j = 0; j < m; j ++) {\\n                int l2 = h[i][j+1][0],              l5 = h[i][j+1][1];\\n                int r2 = h[i][m][0]-h[i][j][0],     r5 = h[i][m][1]-h[i][j][1];\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tu and d directions are calculated exlusively of current cell\\n\\t\\t\\t\\ti.e. if we include current cell we would have u2 = v[i+1][j][0], d2 = v[n][j][0]-v[i][j][0]\\n\\t\\t\\t\\tbut we have to exlude cell (i,j) from up and down calculations because it was included in left and right calculations therefore it should be as following\\n\\t\\t\\t\\t*/\\n                int u2 = v[i][j][0],                u5 = v[i][j][1];\\n                int d2 = v[n][j][0]-v[i+1][j][0],   d5 = v[n][j][1]-v[i+1][j][1];\\n                \\n                int lu2 = l2+u2;\\n                int lu5 = l5+u5;\\n                int ld2 = l2+d2;\\n                int ld5 = l5+d5;\\n                int ru2 = r2+u2;\\n                int ru5 = r5+u5;\\n                int rd2 = r2+d2;\\n                int rd5 = r5+d5;\\n                \\n                res = Math.max(res, Math.min(lu2,lu5));\\n                res = Math.max(res, Math.min(ld2,ld5));\\n                res = Math.max(res, Math.min(ru2,ru5));\\n                res = Math.max(res, Math.min(rd2,rd5));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int power(int num, int x) {\\n        int p = x;\\n        int c = 0;\\n        while(num%p == 0) {\\n            p = p*x;\\n            c ++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n1200 = 2^4*5^2*3\\n```\n```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][][] h = new int[n+1][m+1][2]; \\n        \\n        /*\\n        direction:\\n        ---o\\n        \\n        horSum from col h1 to h2 in ith row = h[i][h1+1]-h[i][h2]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                h[i][j+1][0] = h[i][j][0] + power(grid[i][j], 2);\\n                h[i][j+1][1] = h[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        int[][][] v = new int[n+1][m+1][2]; \\n        /*\\n        direction:\\n        |\\n        |\\n        o\\n        verSum from row v1 to v2 in jth col = v[v1+1][j]-v[v2][j]\\n        */\\n        for(int i = 0; i < n; i ++) {\\n             for(int j = 0; j < m; j ++) {\\n                v[i+1][j][0] = v[i][j][0] + power(grid[i][j], 2);\\n                v[i+1][j][1] = v[i][j][1] + power(grid[i][j], 5);\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i ++) {\\n            for(int j = 0; j < m; j ++) {\\n                int l2 = h[i][j+1][0],              l5 = h[i][j+1][1];\\n                int r2 = h[i][m][0]-h[i][j][0],     r5 = h[i][m][1]-h[i][j][1];\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tu and d directions are calculated exlusively of current cell\\n\\t\\t\\t\\ti.e. if we include current cell we would have u2 = v[i+1][j][0], d2 = v[n][j][0]-v[i][j][0]\\n\\t\\t\\t\\tbut we have to exlude cell (i,j) from up and down calculations because it was included in left and right calculations therefore it should be as following\\n\\t\\t\\t\\t*/\\n                int u2 = v[i][j][0],                u5 = v[i][j][1];\\n                int d2 = v[n][j][0]-v[i+1][j][0],   d5 = v[n][j][1]-v[i+1][j][1];\\n                \\n                int lu2 = l2+u2;\\n                int lu5 = l5+u5;\\n                int ld2 = l2+d2;\\n                int ld5 = l5+d5;\\n                int ru2 = r2+u2;\\n                int ru5 = r5+u5;\\n                int rd2 = r2+d2;\\n                int rd5 = r5+d5;\\n                \\n                res = Math.max(res, Math.min(lu2,lu5));\\n                res = Math.max(res, Math.min(ld2,ld5));\\n                res = Math.max(res, Math.min(ru2,ru5));\\n                res = Math.max(res, Math.min(rd2,rd5));\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int power(int num, int x) {\\n        int p = x;\\n        int c = 0;\\n        while(num%p == 0) {\\n            p = p*x;\\n            c ++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955929,
                "title": "java-not-concise-but-beats-100-solution",
                "content": "Idea is straightforward, just need to calculate the number of factor 2 and 5. But the code is, hmmm, not very simple.\\n\\n```\\n    /*\\n    Runtime: 148 ms, faster than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n    Memory Usage: 83.5 MB, less than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n     */\\n    public int maxTrailingZeros(int[][] grid) {\\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[grid.length][grid[0].length][2];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n\\n        // prefix[i][j][0] is the number of factor 2 from left\\n        // prefix[i][j][1] is the number of factor 5 from left\\n        // prefix[i][j][2] is the number of factor 2 from right\\n        // prefix[i][j][3] is the number of factor 5 from right\\n        // prefix[i][j][4] is the number of factor 2 from top\\n        // prefix[i][j][5] is the number of factor 5 from top\\n        // prefix[i][j][6] is the number of factor 2 from bottom\\n        // prefix[i][j][7] is the number of factor 5 from bottom\\n        int[][][] prefix = new int[grid.length][grid[0].length][8];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (j == 0) {\\n                    prefix[i][j][0] = twoAndFives[i][j][0];\\n                    prefix[i][j][1] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][0] = prefix[i][j-1][0] + twoAndFives[i][j][0];\\n                    prefix[i][j][1] = prefix[i][j-1][1] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == 0) {\\n                    prefix[i][j][4] = twoAndFives[i][j][0];\\n                    prefix[i][j][5] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][4] = prefix[i-1][j][4] + twoAndFives[i][j][0];\\n                    prefix[i][j][5] = prefix[i-1][j][5] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[0].length - 1; j >= 0; j--) {\\n                if (j == grid[0].length - 1) {\\n                    prefix[i][j][2] = twoAndFives[i][j][0];\\n                    prefix[i][j][3] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][2] = prefix[i][j+1][2] + twoAndFives[i][j][0];\\n                    prefix[i][j][3] = prefix[i][j+1][3] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == grid.length - 1) {\\n                    prefix[i][j][6] = twoAndFives[i][j][0];\\n                    prefix[i][j][7] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][6] = prefix[i+1][j][6] + twoAndFives[i][j][0];\\n                    prefix[i][j][7] = prefix[i+1][j][7] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\n    /*\\n    Runtime: 148 ms, faster than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n    Memory Usage: 83.5 MB, less than 100.00% of Java online submissions for Maximum Trailing Zeros in a Cornered Path.\\n     */\\n    public int maxTrailingZeros(int[][] grid) {\\n        // twoAndFives[i][j][0] is the number of factor 2 of grid[i][j]\\n        // twoAndFives[i][j][1] is the number of factor 5 of grid[i][j]\\n        int[][][] twoAndFives = new int[grid.length][grid[0].length][2];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int num = grid[i][j];\\n                int twos = 0;\\n                int fives = 0;\\n                while (num % 2 == 0) {\\n                    num /= 2;\\n                    twos++;\\n                }\\n                while (num % 5 == 0) {\\n                    num /= 5;\\n                    fives++;\\n                }\\n                twoAndFives[i][j] = new int[] {twos, fives};\\n            }\\n        }\\n\\n        // prefix[i][j][0] is the number of factor 2 from left\\n        // prefix[i][j][1] is the number of factor 5 from left\\n        // prefix[i][j][2] is the number of factor 2 from right\\n        // prefix[i][j][3] is the number of factor 5 from right\\n        // prefix[i][j][4] is the number of factor 2 from top\\n        // prefix[i][j][5] is the number of factor 5 from top\\n        // prefix[i][j][6] is the number of factor 2 from bottom\\n        // prefix[i][j][7] is the number of factor 5 from bottom\\n        int[][][] prefix = new int[grid.length][grid[0].length][8];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (j == 0) {\\n                    prefix[i][j][0] = twoAndFives[i][j][0];\\n                    prefix[i][j][1] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][0] = prefix[i][j-1][0] + twoAndFives[i][j][0];\\n                    prefix[i][j][1] = prefix[i][j-1][1] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == 0) {\\n                    prefix[i][j][4] = twoAndFives[i][j][0];\\n                    prefix[i][j][5] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][4] = prefix[i-1][j][4] + twoAndFives[i][j][0];\\n                    prefix[i][j][5] = prefix[i-1][j][5] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[0].length - 1; j >= 0; j--) {\\n                if (j == grid[0].length - 1) {\\n                    prefix[i][j][2] = twoAndFives[i][j][0];\\n                    prefix[i][j][3] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][2] = prefix[i][j+1][2] + twoAndFives[i][j][0];\\n                    prefix[i][j][3] = prefix[i][j+1][3] + twoAndFives[i][j][1];\\n                }\\n\\n                if (i == grid.length - 1) {\\n                    prefix[i][j][6] = twoAndFives[i][j][0];\\n                    prefix[i][j][7] = twoAndFives[i][j][1];\\n                } else {\\n                    prefix[i][j][6] = prefix[i+1][j][6] + twoAndFives[i][j][0];\\n                    prefix[i][j][7] = prefix[i+1][j][7] + twoAndFives[i][j][1];\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][0] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][1] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][4] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][5] - twoAndFives[i][j][1]));\\n                max = Math.max(max, Math.min(prefix[i][j][2] + prefix[i][j][6] - twoAndFives[i][j][0], prefix[i][j][3] + prefix[i][j][7] - twoAndFives[i][j][1]));\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955915,
                "title": "c-presum-factor-2-and-5-brute-force-beats-100-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<pair<int, int>>> fact(m, vector<pair<int, int>>(n, {0,0})); // grid[i][j] -> 2, 5\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int two = 0;\\n                int five = 0;\\n                int num = grid[i][j];\\n                while(num % 2 == 0){\\n                    num /= 2;\\n                    two++;\\n                }\\n                num = grid[i][j];\\n                while(num % 5 == 0){\\n                    num /= 5;\\n                    five++;\\n                }\\n                fact[i][j] = {two, five};\\n            }\\n        }\\n        \\n        \\n        // \\u6BCF\\u4E2A\\u70B9\\u6709\\u6A2A\\u5411\\u3001\\u7EB5\\u5411\\u524D\\u7F00\\u548C\\uFF0C first\\u6A2A\\u5411,second\\u7EB5\\u5411\\n        // presum2[i][j]: \\u7B2Ci\\u884C\\uFF0C[0....j-1]\\u7684fact\\'s 2\\u7684\\u548C\\n        vector<vector<pair<int, int>>> presum2(m+1, vector<pair<int, int>>(n+1, {0, 0})), \\n        presum5(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j <= n; j++){\\n                presum2[i][j].first = presum2[i][j-1].first + fact[i][j-1].first;\\n                presum5[i][j].first = presum5[i][j-1].first + fact[i][j-1].second;\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++){\\n            for(int i = 1; i <= m; i++){\\n                presum2[i][j].second = presum2[i-1][j].second + fact[i-1][j].first;\\n                presum5[i][j].second = presum5[i-1][j].second + fact[i-1][j].second;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                // lf + up\\n                ans = max(ans, min(presum2[i][j+1].first + presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first + presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // rt + up\\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][n].first - presum5[i][j].first  +  presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // lf + down\\n                ans = max(ans, min(presum2[i][j+1].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n                // down + rt                         \\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                 presum5[i][n].first - presum5[i][j].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n\\t\\t\\t\\t//  vertical and horizon\\n                ans = max(ans, max(min(presum2[i][n].first, presum5[i][n].first),\\n                                   min(presum2[m][j].second, presum5[m][j].second)));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<pair<int, int>>> fact(m, vector<pair<int, int>>(n, {0,0})); // grid[i][j] -> 2, 5\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int two = 0;\\n                int five = 0;\\n                int num = grid[i][j];\\n                while(num % 2 == 0){\\n                    num /= 2;\\n                    two++;\\n                }\\n                num = grid[i][j];\\n                while(num % 5 == 0){\\n                    num /= 5;\\n                    five++;\\n                }\\n                fact[i][j] = {two, five};\\n            }\\n        }\\n        \\n        \\n        // \\u6BCF\\u4E2A\\u70B9\\u6709\\u6A2A\\u5411\\u3001\\u7EB5\\u5411\\u524D\\u7F00\\u548C\\uFF0C first\\u6A2A\\u5411,second\\u7EB5\\u5411\\n        // presum2[i][j]: \\u7B2Ci\\u884C\\uFF0C[0....j-1]\\u7684fact\\'s 2\\u7684\\u548C\\n        vector<vector<pair<int, int>>> presum2(m+1, vector<pair<int, int>>(n+1, {0, 0})), \\n        presum5(m+1, vector<pair<int, int>>(n+1, {0, 0}));\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j <= n; j++){\\n                presum2[i][j].first = presum2[i][j-1].first + fact[i][j-1].first;\\n                presum5[i][j].first = presum5[i][j-1].first + fact[i][j-1].second;\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++){\\n            for(int i = 1; i <= m; i++){\\n                presum2[i][j].second = presum2[i-1][j].second + fact[i-1][j].first;\\n                presum5[i][j].second = presum5[i-1][j].second + fact[i-1][j].second;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                // lf + up\\n                ans = max(ans, min(presum2[i][j+1].first + presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first + presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // rt + up\\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[i+1][j].second - fact[i][j].first,\\n                                   presum5[i][n].first - presum5[i][j].first  +  presum5[i+1][j].second - fact[i][j].second));\\n                \\n                // lf + down\\n                ans = max(ans, min(presum2[i][j+1].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                   presum5[i][j+1].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n                // down + rt                         \\n                ans = max(ans, min(presum2[i][n].first - presum2[i][j].first  +  presum2[m][j].second - presum2[i][j].second - fact[i][j].first,\\n                                 presum5[i][n].first - presum5[i][j].first  +  presum5[m][j].second - presum5[i][j].second - fact[i][j].second));\\n                \\n\\t\\t\\t\\t//  vertical and horizon\\n                ans = max(ans, max(min(presum2[i][n].first, presum5[i][n].first),\\n                                   min(presum2[m][j].second, presum5[m][j].second)));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955842,
                "title": "clean-java-solution-count-2-and-5-prime-factors-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] productGoingRight = new int[m][n][2];\\n        int[][][] productGoingLeft = new int[m][n][2];\\n        int[][][] productGoingUp = new int[m][n][2];\\n        int[][][] productGoingDown = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0, k = n-1; j < n; j++, k--) {\\n                int[] prevLeft = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                productGoingLeft[i][j][0] = prevLeft[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingLeft[i][j][1] = prevLeft[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevRight = (k+1 < n ? productGoingRight[i][k+1] : new int[]{0,0});\\n                productGoingRight[i][k][0] = prevRight[0] + countPrimeFactor(grid[i][k],2);\\n                productGoingRight[i][k][1] = prevRight[1] + countPrimeFactor(grid[i][k],5);\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++) {\\n            for(int i = 0, k = m-1; i < m; i++, k--) {\\n                int[] prevUp = (i-1 >= 0 ? productGoingUp[i-1][j] : new int[]{0,0});\\n                productGoingUp[i][j][0] = prevUp[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingUp[i][j][1] = prevUp[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevDown = (k+1 < m ? productGoingDown[k+1][j] : new int[]{0,0});\\n                productGoingDown[k][j][0] = prevDown[0] + countPrimeFactor(grid[k][j],2);\\n                productGoingDown[k][j][1] = prevDown[1] + countPrimeFactor(grid[k][j],5);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int[] right = (j+1 < n ? productGoingRight[i][j+1] : new int[]{0,0});\\n                int[] left = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                int[] up = productGoingUp[i][j];\\n                int[] down = productGoingDown[i][j];\\n                \\n                ans = Math.max(ans,Math.min(up[0]+right[0],up[1]+right[1]));\\n                ans = Math.max(ans,Math.min(up[0]+left[0],up[1]+left[1]));\\n                ans = Math.max(ans,Math.min(down[0]+right[0],down[1]+right[1]));\\n                ans = Math.max(ans,Math.min(down[0]+left[0],down[1]+left[1]));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int countPrimeFactor(int n, int prime) {\\n        int c = 0;\\n        while(n % prime == 0) {\\n            c++;\\n            n /= prime;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][][] productGoingRight = new int[m][n][2];\\n        int[][][] productGoingLeft = new int[m][n][2];\\n        int[][][] productGoingUp = new int[m][n][2];\\n        int[][][] productGoingDown = new int[m][n][2];\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0, k = n-1; j < n; j++, k--) {\\n                int[] prevLeft = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                productGoingLeft[i][j][0] = prevLeft[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingLeft[i][j][1] = prevLeft[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevRight = (k+1 < n ? productGoingRight[i][k+1] : new int[]{0,0});\\n                productGoingRight[i][k][0] = prevRight[0] + countPrimeFactor(grid[i][k],2);\\n                productGoingRight[i][k][1] = prevRight[1] + countPrimeFactor(grid[i][k],5);\\n            }\\n        }\\n        \\n        for(int j = 0; j < n; j++) {\\n            for(int i = 0, k = m-1; i < m; i++, k--) {\\n                int[] prevUp = (i-1 >= 0 ? productGoingUp[i-1][j] : new int[]{0,0});\\n                productGoingUp[i][j][0] = prevUp[0] + countPrimeFactor(grid[i][j],2);\\n                productGoingUp[i][j][1] = prevUp[1] + countPrimeFactor(grid[i][j],5);\\n                \\n                int[] prevDown = (k+1 < m ? productGoingDown[k+1][j] : new int[]{0,0});\\n                productGoingDown[k][j][0] = prevDown[0] + countPrimeFactor(grid[k][j],2);\\n                productGoingDown[k][j][1] = prevDown[1] + countPrimeFactor(grid[k][j],5);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int[] right = (j+1 < n ? productGoingRight[i][j+1] : new int[]{0,0});\\n                int[] left = (j-1 >= 0 ? productGoingLeft[i][j-1] : new int[]{0,0});\\n                int[] up = productGoingUp[i][j];\\n                int[] down = productGoingDown[i][j];\\n                \\n                ans = Math.max(ans,Math.min(up[0]+right[0],up[1]+right[1]));\\n                ans = Math.max(ans,Math.min(up[0]+left[0],up[1]+left[1]));\\n                ans = Math.max(ans,Math.min(down[0]+right[0],down[1]+right[1]));\\n                ans = Math.max(ans,Math.min(down[0]+left[0],down[1]+left[1]));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int countPrimeFactor(int n, int prime) {\\n        int c = 0;\\n        while(n % prime == 0) {\\n            c++;\\n            n /= prime;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955813,
                "title": "java-tried-my-best-to-give-this-shortest-code",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][][] ver = new int[row + 1][col + 1][2];\\n        int[][][] hir = new int[row + 1][col + 1][2];\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                assign(hir[i][j], hir[i][j - 1], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        for (int j = 1; j <= col; j++) {\\n            for (int i = 1; i <= row; i++) {\\n                assign(ver[i][j], ver[i - 1][j], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                max = Math.max(max, helper(i, 0, i, j - 1, i, j, row, j, ver, hir, grid[i - 1][j - 1])); \\n                max = Math.max(max, helper(i, 0, i, j - 1, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, i, j, row, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n            } \\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int helper(int row1, int col1, int row2, int col2, int row3, int col3, int row4, int col4, int[][][] ver, int[][][] hir, int turn){\\n        int[] sumArr = new int[2];\\n        int[] count = count(turn);\\n        for (int i = 0; i < 2; i++) {\\n            sumArr[i] = count[i] + hir[row2][col2][i] - hir[row1][col1][i] + ver[row4][col4][i] - ver[row3][col3][i];\\n        }\\n        return Math.min(sumArr[0], sumArr[1]);\\n    }\\n    \\n    private int[] count(int num) {\\n        int[] ret = new int[2];\\n        while (num % 5 == 0) {\\n            ret[1]++;\\n            num /= 5;\\n        }\\n        while (num % 2 == 0) {\\n            ret[0]++;\\n            num /= 2;\\n        }\\n        return ret;\\n    }\\n    \\n    \\n    private void assign(int[] cur, int[] pre, int[] carry) {\\n        cur[0] = pre[0] + carry[0];\\n        cur[1] = pre[1] + carry[1];\\n    }\\n}\\n```\\n\\nHope it helps",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][][] ver = new int[row + 1][col + 1][2];\\n        int[][][] hir = new int[row + 1][col + 1][2];\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                assign(hir[i][j], hir[i][j - 1], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        for (int j = 1; j <= col; j++) {\\n            for (int i = 1; i <= row; i++) {\\n                assign(ver[i][j], ver[i - 1][j], count(grid[i - 1][j - 1]));\\n            }\\n        }\\n        \\n        int max = 0;\\n        for (int i = 1; i <= row; i++) {\\n            for (int j = 1; j <= col; j++) {\\n                max = Math.max(max, helper(i, 0, i, j - 1, i, j, row, j, ver, hir, grid[i - 1][j - 1])); \\n                max = Math.max(max, helper(i, 0, i, j - 1, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, i, j, row, j, ver, hir, grid[i - 1][j - 1]));\\n                max = Math.max(max, helper(i, j, i, col, 0, j, i - 1, j, ver, hir, grid[i - 1][j - 1]));\\n            } \\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int helper(int row1, int col1, int row2, int col2, int row3, int col3, int row4, int col4, int[][][] ver, int[][][] hir, int turn){\\n        int[] sumArr = new int[2];\\n        int[] count = count(turn);\\n        for (int i = 0; i < 2; i++) {\\n            sumArr[i] = count[i] + hir[row2][col2][i] - hir[row1][col1][i] + ver[row4][col4][i] - ver[row3][col3][i];\\n        }\\n        return Math.min(sumArr[0], sumArr[1]);\\n    }\\n    \\n    private int[] count(int num) {\\n        int[] ret = new int[2];\\n        while (num % 5 == 0) {\\n            ret[1]++;\\n            num /= 5;\\n        }\\n        while (num % 2 == 0) {\\n            ret[0]++;\\n            num /= 2;\\n        }\\n        return ret;\\n    }\\n    \\n    \\n    private void assign(int[] cur, int[] pre, int[] carry) {\\n        cur[0] = pre[0] + carry[0];\\n        cur[1] = pre[1] + carry[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955780,
                "title": "c-accumulated-2-5-10-from-4-directions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();       \\n        int l = grid[0].size();\\n      \\n        vector<vector<int>> c(r * l, vector<int>());\\n        vector<vector<int>> up(r * l, vector<int>()), down(r * l, vector<int>()), left(r * l, vector<int>()), right (r * l, vector<int>());\\n \\n        for (int i = 0; i < r; i++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                if (c[ind].size() == 0)\\n                {\\n                    c[ind] = helper(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = 0; j < l; j++)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    left[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = l - 1; j >= 0; j--)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    right[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = 0 ; i < r; i++ )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i *l + j][2];\\n                    up[i * l + j] = {count2, count5, count10};   \\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = r -1 ; i >= 0; i-- )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    down[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        int ret = 0;\\n        for (int i = 0; i < r; i ++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                {\\n                    int a2 = left[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = left[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    vector<int> helper(int inp)\\n    {  \\n        int count5 = 0, count2 = 0, count10 = 0;\\n\\n        int input = inp;\\n        while(input != 0 && input % 10 == 0)\\n        {\\n            count10++;\\n            input = input / 10;\\n        }\\n\\n\\n        input = inp;\\n        while (input != 0  && input % 2 == 0)\\n        {\\n            count2 ++;\\n            input = input / 2;\\n        }\\n\\n        input = inp;\\n        while (input != 0  && input % 5 == 0)\\n        {\\n            count5++;\\n            input = input / 5;\\n        }\\n\\n        count5 -= count10;\\n        count2 -= count10;\\n\\n        return {count2, count5, count10};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        \\n        int r = grid.size();       \\n        int l = grid[0].size();\\n      \\n        vector<vector<int>> c(r * l, vector<int>());\\n        vector<vector<int>> up(r * l, vector<int>()), down(r * l, vector<int>()), left(r * l, vector<int>()), right (r * l, vector<int>());\\n \\n        for (int i = 0; i < r; i++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                if (c[ind].size() == 0)\\n                {\\n                    c[ind] = helper(grid[i][j]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = 0; j < l; j++)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    left[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < r; i++ )\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for (int j = l - 1; j >= 0; j--)\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    right[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = 0 ; i < r; i++ )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i *l + j][2];\\n                    up[i * l + j] = {count2, count5, count10};   \\n            }\\n        }\\n        \\n        for (int j = 0; j < l; j++)\\n        {\\n            int count5 = 0, count2 = 0, count10 = 0;\\n            for(int i = r -1 ; i >= 0; i-- )\\n            {\\n                    count5 += c[i * l + j][1];\\n                    count2 += c[i * l + j][0];\\n                    count10 += c[i * l + j][2];\\n                    down[i * l + j] = {count2, count5, count10};\\n            }\\n        }\\n        \\n        int ret = 0;\\n        for (int i = 0; i < r; i ++)\\n        {\\n            for (int j = 0; j < l; j++)\\n            {\\n                int ind = i * l + j;\\n                {\\n                    int a2 = left[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = left[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = left[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = left[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + up[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + up[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + up[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n                \\n                {\\n                    int a2 = right[ind][0] + down[ind][0] - c[ind][0];\\n                    int a5 = right[ind][1] + down[ind][1] - c[ind][1];\\n                    int a10 = right[ind][2] + down[ind][2] - c[ind][2];\\n                    \\n                    ret = max(ret, min(a2, a5) + a10);\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    vector<int> helper(int inp)\\n    {  \\n        int count5 = 0, count2 = 0, count10 = 0;\\n\\n        int input = inp;\\n        while(input != 0 && input % 10 == 0)\\n        {\\n            count10++;\\n            input = input / 10;\\n        }\\n\\n\\n        input = inp;\\n        while (input != 0  && input % 2 == 0)\\n        {\\n            count2 ++;\\n            input = input / 2;\\n        }\\n\\n        input = inp;\\n        while (input != 0  && input % 5 == 0)\\n        {\\n            count5++;\\n            input = input / 5;\\n        }\\n\\n        count5 -= count10;\\n        count2 -= count10;\\n\\n        return {count2, count5, count10};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955769,
                "title": "java-neat-code-presum-for-2-and-5",
                "content": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] up = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] down = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] left = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] right = new int[grid.length+2][2+grid[0].length][2];\\n        int[] digits = {2, 5};\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n               for (int k = 0; k < digits.length; k++ ){\\n                int d = getDigitNum(grid[i][j], digits[k]);\\n                up[i + 1][j + 1][k] = up[i][j + 1][k] + d;\\n                left[i + 1][j + 1][k] = left[i + 1][j][k] + d;\\n               }\\n            }\\n        }\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[i].length - 1; j >= 0; j--) {\\n                for (int k = 0; k < digits.length; k++ ){\\n                  int d = getDigitNum(grid[i][j], digits[k]);\\n                  down[i + 1][j + 1][k] = down[i + 2][j + 1][k] + d;\\n                  right[i + 1][j + 1][k] = right[i + 1][j + 2][k] + d;\\n                }      \\n          }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= grid.length; i++) {\\n            for (int j = 1; j <= grid[0].length; j++) {\\n                ans = Math.max(Math.min(up[i][j][0] + left[i][j - 1][0], up[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(up[i][j][0] + right[i][j + 1][0], up[i][j][1] + right[i][j + 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + left[i][j - 1][0], down[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + right[i][j + 1][0], down[i][j][1] + right[i][j + 1][1]), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    int getDigitNum(int num, int d) {\\n        int ans = 0;\\n        while (num > 0 && num % d == 0) {\\n            num /= d;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTrailingZeros(int[][] grid) {\\n        int[][][] up = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] down = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] left = new int[grid.length+2][2+grid[0].length][2];\\n        int[][][] right = new int[grid.length+2][2+grid[0].length][2];\\n        int[] digits = {2, 5};\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n               for (int k = 0; k < digits.length; k++ ){\\n                int d = getDigitNum(grid[i][j], digits[k]);\\n                up[i + 1][j + 1][k] = up[i][j + 1][k] + d;\\n                left[i + 1][j + 1][k] = left[i + 1][j][k] + d;\\n               }\\n            }\\n        }\\n        for (int i = grid.length - 1; i >= 0; i--) {\\n            for (int j = grid[i].length - 1; j >= 0; j--) {\\n                for (int k = 0; k < digits.length; k++ ){\\n                  int d = getDigitNum(grid[i][j], digits[k]);\\n                  down[i + 1][j + 1][k] = down[i + 2][j + 1][k] + d;\\n                  right[i + 1][j + 1][k] = right[i + 1][j + 2][k] + d;\\n                }      \\n          }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= grid.length; i++) {\\n            for (int j = 1; j <= grid[0].length; j++) {\\n                ans = Math.max(Math.min(up[i][j][0] + left[i][j - 1][0], up[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(up[i][j][0] + right[i][j + 1][0], up[i][j][1] + right[i][j + 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + left[i][j - 1][0], down[i][j][1] + left[i][j - 1][1]), ans);\\n                ans = Math.max(Math.min(down[i][j][0] + right[i][j + 1][0], down[i][j][1] + right[i][j + 1][1]), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    int getDigitNum(int num, int d) {\\n        int ans = 0;\\n        while (num > 0 && num % d == 0) {\\n            num /= d;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955763,
                "title": "c-prefix-sum-no-of-zero-min-2s-5s-in-path",
                "content": "This problem needs patience and its too frustrating. \\n**Idea:** Max no. of zeros in a path is min(no. of 5, no. of 2).\\nCreate two prefix sum:\\n* **row**: stores no. of five and two from **0 to jth** col for each **ith** row\\n*  **row2**: stores no. of five and two from **j to m-1** col for each **ith** row\\n\\nThen to find max no. zero in each col, we will need to traverse each col twice, \\n1. from top to bottom\\n1. from bottom to top, keeping the record of no. of five and two\\n\\nwhile traversing each col, at every index `i` in jth col, we will have two option, either turn left or right. For both the cases we have calculated our prefix sum.\\nNow take the sum of two\\'s and five\\'s of prefix sum (one at a time, either row or row2) and curr five\\'s and two\\'s while traversing `jth` col, find max no. of zeros\\n```\\nclass Solution {\\npublic:\\n    void count(int n,int &five,int &two){\\n        while(n%5==0 && n){\\n            five++; n=n/5;\\n        }\\n        while(n%2==0 && n){\\n            two++; n=n/2;\\n        }\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<pair<int,int>>> row(n,vector<pair<int,int>>(m));\\n         vector<vector<pair<int,int>>> row2(n,vector<pair<int,int>>(m));\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = m-1;j>=0;--j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row[i][j] = {five,two};  // no. of 5 and 2 from jth col to m-1 col for ith row\\n            }\\n        }\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = 0;j<m;++j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row2[i][j] = {five,two};  // no. of 5 and 2 from 0th col to jth col for ith row\\n            }\\n        }\\n\\n        int re = 0;\\n        for(int j = 0;j<m;++j){  // traverse each col from top to bottom\\n            int five=0,two=0;\\n            for(int i = 0;i<n;++i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n\\t\\t\\t\\t// consider both situations and find max no. of zero\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        for(int j = 0;j<m;++j){  // traverse each col from bottom to top\\n            int five=0,two=0;\\n            for(int i = n-1;i>=0;--i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```\\n**Time: O(m*n)**\\nupvote if it helps",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void count(int n,int &five,int &two){\\n        while(n%5==0 && n){\\n            five++; n=n/5;\\n        }\\n        while(n%2==0 && n){\\n            two++; n=n/2;\\n        }\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<pair<int,int>>> row(n,vector<pair<int,int>>(m));\\n         vector<vector<pair<int,int>>> row2(n,vector<pair<int,int>>(m));\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = m-1;j>=0;--j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row[i][j] = {five,two};  // no. of 5 and 2 from jth col to m-1 col for ith row\\n            }\\n        }\\n        for(int i = 0; i<nums.size();++i){\\n            int five=0,two=0;\\n            for(int j = 0;j<m;++j){\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                row2[i][j] = {five,two};  // no. of 5 and 2 from 0th col to jth col for ith row\\n            }\\n        }\\n\\n        int re = 0;\\n        for(int j = 0;j<m;++j){  // traverse each col from top to bottom\\n            int five=0,two=0;\\n            for(int i = 0;i<n;++i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n\\t\\t\\t\\t// consider both situations and find max no. of zero\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        for(int j = 0;j<m;++j){  // traverse each col from bottom to top\\n            int five=0,two=0;\\n            for(int i = n-1;i>=0;--i){\\n                int x=five,y=two; // this does\\'nt include curr number (no. of five and two) as it will get repeat by prefix sum\\n                if(nums[i][j]%10==0 || nums[i][j]%5==0 || nums[i][j]%2==0) count(nums[i][j],five,two);\\n                int t1 = x+row[i][j].first,t2=y+row[i][j].second;\\n                re = max(re,min(t1,t2));\\n                t1 = x+row2[i][j].first,t2=y+row2[i][j].second;\\n                re = max(re,min(t1,t2));\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955704,
                "title": "c-solution-using-prefix-sum-for-4-directions",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    pair<int,int> get(int n)\\n    {\\n        pair<int,int> result={0,0};\\n        while(n%5==0) result.first++, n/=5;\\n        while(n%2==0) result.second++,n/=2;\\n        return result;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int result=0,m=grid.size(),n=grid[0].size();\\n        pair<int,int> total[m][n][4];\\n        memset(total,0,sizeof(total));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[i][n-j-1]);\\n                if(j==0)\\n                {\\n                    total[i][j][0]=c1;\\n                    total[i][n-j-1][2]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][0]={total[i][j-1][0].first+c1.first,total[i][j-1][0].second+c1.second};\\n                    total[i][n-j-1][2]={total[i][n-j][2].first+c2.first,total[i][n-j][2].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[m-i-1][j]);\\n                if(i==0)\\n                {\\n                    total[i][j][1]=c1;\\n                    total[m-i-1][j][3]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][1]={total[i-1][j][1].first+c1.first,total[i-1][j][1].second+c1.second};\\n                    total[m-i-1][j][3]={total[m-i][j][3].first+c2.first,total[m-i][j][3].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int a=0;a<3;a++)\\n                {\\n                    for(int b=a+1;b<4;b++)\\n                    {\\n                        pair<int,int> t=get(grid[i][j]);\\n                        result=max(result,min(total[i][j][a].first+total[i][j][b].first-t.first,total[i][j][a].second+total[i][j][b].second-t.second));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    pair<int,int> get(int n)\\n    {\\n        pair<int,int> result={0,0};\\n        while(n%5==0) result.first++, n/=5;\\n        while(n%2==0) result.second++,n/=2;\\n        return result;\\n    }\\n    int maxTrailingZeros(vector<vector<int>>& grid) \\n    {\\n        int result=0,m=grid.size(),n=grid[0].size();\\n        pair<int,int> total[m][n][4];\\n        memset(total,0,sizeof(total));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[i][n-j-1]);\\n                if(j==0)\\n                {\\n                    total[i][j][0]=c1;\\n                    total[i][n-j-1][2]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][0]={total[i][j-1][0].first+c1.first,total[i][j-1][0].second+c1.second};\\n                    total[i][n-j-1][2]={total[i][n-j][2].first+c2.first,total[i][n-j][2].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                pair<int,int> c1=get(grid[i][j]),c2=get(grid[m-i-1][j]);\\n                if(i==0)\\n                {\\n                    total[i][j][1]=c1;\\n                    total[m-i-1][j][3]=c2;\\n                }\\n                else\\n                {\\n                    total[i][j][1]={total[i-1][j][1].first+c1.first,total[i-1][j][1].second+c1.second};\\n                    total[m-i-1][j][3]={total[m-i][j][3].first+c2.first,total[m-i][j][3].second+c2.second};\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int a=0;a<3;a++)\\n                {\\n                    for(int b=a+1;b<4;b++)\\n                    {\\n                        pair<int,int> t=get(grid[i][j]);\\n                        result=max(result,min(total[i][j][a].first+total[i][j][b].first-t.first,total[i][j][a].second+total[i][j][b].second-t.second));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955693,
                "title": "try-to-apply-dfs-to-search-qualified-path-but-failed",
                "content": "* General Idea: I plan to apply dfs starting from each cell to search the qualified path. For each path, I\\'ll the visiting flag and the number of turns in corner cases. For the non-visited cell in each path, I\\'ll compute the product of this path and update the max counting of trailing zeros so far. Then, I apply dfs to search its neighbors within the range of the grid.\\n\\nThe idea looks pretty simple but couldn\\'t get correct answer. Anyone has some suggestionns? Thanks in advance.\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        self.visited = [[set()]*len(grid[0]) for _ in range(len(grid))]\\n        self.dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n        self.cnt_tz = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                self.dfs(grid, i, j, grid[i][j], 0, \"\") # apply dfs\\n        return self.cnt_tz\\n    \\n    def dfs(self, grid, i, j, path_product, n_turn, pre_dirs):\\n        #terminal cases:\\n        if (i, j) in self.visited[i][j]:\\n            return\\n        if n_turn > 2:\\n            return\\n        #general cases:\\n        # update the flag for visiting\\n        m, n = len(grid), len(grid[0])\\n        self.visited[i][j].add((i, j))\\n        # compute the path product and update the max trailing zeros\\n        path_product *= grid[i][j]\\n        print(i, j, grid[i][j], path_product)\\n        self.cnt_tz = max(self.cnt_tz, self.count_trailing_zeros(path_product))\\n        # apply dfs to search on neighbors\\n        for dx, dy in self.dirs:\\n            x, y = dx + i, dy + j\\n            if 0<=x<m and 0<=y<n:\\n                if (abs(y-j)>0 and abs(x-i)==0):\\n                    cur_dirs = \\'v\\'\\n                if (abs(y-j)==0 and abs(x-i)>0):\\n                    cur_dirs = \\'h\\'\\n                if pre_dirs != cur_dirs:\\n                    n_turn += 1\\n                self.dfs(grid, x, y, path_product, n_turn, cur_dirs)\\n            else:\\n                return\\n\\n    def count_trailing_zeros(self, path_product):\\n        cnt = 0\\n        for char in str(path_product)[::-1]:\\n            if int(char) == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        self.visited = [[set()]*len(grid[0]) for _ in range(len(grid))]\\n        self.dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n        self.cnt_tz = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                self.dfs(grid, i, j, grid[i][j], 0, \"\") # apply dfs\\n        return self.cnt_tz\\n    \\n    def dfs(self, grid, i, j, path_product, n_turn, pre_dirs):\\n        #terminal cases:\\n        if (i, j) in self.visited[i][j]:\\n            return\\n        if n_turn > 2:\\n            return\\n        #general cases:\\n        # update the flag for visiting\\n        m, n = len(grid), len(grid[0])\\n        self.visited[i][j].add((i, j))\\n        # compute the path product and update the max trailing zeros\\n        path_product *= grid[i][j]\\n        print(i, j, grid[i][j], path_product)\\n        self.cnt_tz = max(self.cnt_tz, self.count_trailing_zeros(path_product))\\n        # apply dfs to search on neighbors\\n        for dx, dy in self.dirs:\\n            x, y = dx + i, dy + j\\n            if 0<=x<m and 0<=y<n:\\n                if (abs(y-j)>0 and abs(x-i)==0):\\n                    cur_dirs = \\'v\\'\\n                if (abs(y-j)==0 and abs(x-i)>0):\\n                    cur_dirs = \\'h\\'\\n                if pre_dirs != cur_dirs:\\n                    n_turn += 1\\n                self.dfs(grid, x, y, path_product, n_turn, cur_dirs)\\n            else:\\n                return\\n\\n    def count_trailing_zeros(self, path_product):\\n        cnt = 0\\n        for char in str(path_product)[::-1]:\\n            if int(char) == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955684,
                "title": "just-finished-writing-my-novel-please-take-a-look",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        //dp?\\n        vector<vector<pair<int, int>>> dp(grid.size(), vector<pair<int, int>>(grid[0].size()));\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int two = 0, five = 0;\\n                while(grid[i][j] % 2 == 0){\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                while(grid[i][j] % 5 == 0){\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                dp[i][j] = make_pair(two, five);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> up(dp.size() + 1, vector<pair<int, int>>(dp[0].size()));\\n        vector<vector<pair<int, int>>> left(dp.size(), vector<pair<int, int>>(dp[0].size() + 1));\\n        up[0][0].first = 0, up[0][0].second = 0;\\n        left[0][0].first = 0, left[0][0].second = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            int curtwo = 0, curfive = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                left[i][j + 1].first = curtwo;\\n                left[i][j + 1].second = curfive;\\n            }\\n        }\\n        for(int j = 0; j < dp[0].size(); j++){\\n            int curtwo = 0, curfive = 0;\\n            for(int i = 0; i < dp.size(); i++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                up[i + 1][j].first = curtwo, up[i + 1][j].second = curfive;\\n            }\\n        }\\n        vector<pair<int, int>> rowsum, colsum;\\n        for(int i = 0; i < dp.size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                t += dp[i][j].first;\\n                f += dp[i][j].second;\\n            }\\n            rowsum.push_back(make_pair(t, f));\\n        }\\n        for(int i = 0; i < dp[0].size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp.size(); j++){\\n                t += dp[j][i].first, f += dp[j][i].second;\\n            }\\n            colsum.push_back(make_pair(t, f));\\n        }\\n        int res = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int up2 = up[i][j].first, up5 = up[i][j].second, left2 = left[i][j].first, left5 = left[i][j].second;\\n                int down2 = colsum[j].first - up2 - dp[i][j].first;\\n                int down5 = colsum[j].second - up5 - dp[i][j].second;\\n                int right2 = rowsum[i].first - left[i][j + 1].first, right5 = rowsum[i].second - left[i][j + 1].second;\\n                int q2 = min(up2 + left2 + dp[i][j].first, up5 + left5 + dp[i][j].second), q4 = min(right2 + down2 + dp[i][j].first, right5 + down5 + dp[i][j].second), q1 = min(up2 + right2 + dp[i][j].first, up5 + right5 + dp[i][j].second), q3 = min(left2 + down2 + dp[i][j].first, left5 + down5 + dp[i][j].second);\\n                \\n                res = max({res, q1, q2, q3, q4});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n        //dp?\\n        vector<vector<pair<int, int>>> dp(grid.size(), vector<pair<int, int>>(grid[0].size()));\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int two = 0, five = 0;\\n                while(grid[i][j] % 2 == 0){\\n                    grid[i][j] /= 2;\\n                    two++;\\n                }\\n                while(grid[i][j] % 5 == 0){\\n                    grid[i][j] /= 5;\\n                    five++;\\n                }\\n                dp[i][j] = make_pair(two, five);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> up(dp.size() + 1, vector<pair<int, int>>(dp[0].size()));\\n        vector<vector<pair<int, int>>> left(dp.size(), vector<pair<int, int>>(dp[0].size() + 1));\\n        up[0][0].first = 0, up[0][0].second = 0;\\n        left[0][0].first = 0, left[0][0].second = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            int curtwo = 0, curfive = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                left[i][j + 1].first = curtwo;\\n                left[i][j + 1].second = curfive;\\n            }\\n        }\\n        for(int j = 0; j < dp[0].size(); j++){\\n            int curtwo = 0, curfive = 0;\\n            for(int i = 0; i < dp.size(); i++){\\n                curtwo += dp[i][j].first, curfive += dp[i][j].second;\\n                up[i + 1][j].first = curtwo, up[i + 1][j].second = curfive;\\n            }\\n        }\\n        vector<pair<int, int>> rowsum, colsum;\\n        for(int i = 0; i < dp.size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp[i].size(); j++){\\n                t += dp[i][j].first;\\n                f += dp[i][j].second;\\n            }\\n            rowsum.push_back(make_pair(t, f));\\n        }\\n        for(int i = 0; i < dp[0].size(); i++){\\n            int t = 0, f = 0;\\n            for(int j = 0; j < dp.size(); j++){\\n                t += dp[j][i].first, f += dp[j][i].second;\\n            }\\n            colsum.push_back(make_pair(t, f));\\n        }\\n        int res = 0;\\n        for(int i = 0; i < dp.size(); i++){\\n            for(int j = 0; j < dp[i].size(); j++){\\n                int up2 = up[i][j].first, up5 = up[i][j].second, left2 = left[i][j].first, left5 = left[i][j].second;\\n                int down2 = colsum[j].first - up2 - dp[i][j].first;\\n                int down5 = colsum[j].second - up5 - dp[i][j].second;\\n                int right2 = rowsum[i].first - left[i][j + 1].first, right5 = rowsum[i].second - left[i][j + 1].second;\\n                int q2 = min(up2 + left2 + dp[i][j].first, up5 + left5 + dp[i][j].second), q4 = min(right2 + down2 + dp[i][j].first, right5 + down5 + dp[i][j].second), q1 = min(up2 + right2 + dp[i][j].first, up5 + right5 + dp[i][j].second), q3 = min(left2 + down2 + dp[i][j].first, left5 + down5 + dp[i][j].second);\\n                \\n                res = max({res, q1, q2, q3, q4});\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955675,
                "title": "c-faster-than-100",
                "content": "Not optimized, did it for the weekly contest.\\nCreated left/right/up/down m x n matrices to track the number of 2\\'s and 5\\'s at each direction for each point in the matrix...\\nThen scan the matrix and pick the the max of 2\\'s and 5\\'s that each point can see from the six possible directions (left-right, left-up, up-right, ....) and then compare the number with the max seen so far...\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(); int n = grid[0].size();\\n    vector<vector<int>> left2 (m, vector<int> (n, 0));  vector<vector<int>> left5 (m, vector<int> (n, 0));\\n    vector<vector<int>> right2 (m, vector<int> (n, 0)); vector<vector<int>> right5 (m, vector<int> (n, 0));\\n    vector<vector<int>> up2 (m, vector<int> (n, 0));    vector<vector<int>> up5 (m, vector<int> (n, 0));\\n    vector<vector<int>> down2 (m, vector<int> (n, 0));  vector<vector<int>> down5 (m, vector<int> (n, 0));\\n    vector<vector<int>> grid2 (m, vector<int> (n, 0));  vector<vector<int>> grid5 (m, vector<int> (n, 0));\\n        \\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++) {\\n            int two = 0; int temp = grid[i][j];\\n            while(temp % 2 == 0) {two++; temp /= 2;}\\n            \\n            int five = 0; temp = grid[i][j];\\n            while(temp % 5 == 0) {five++; temp /= 5;}\\n            \\n            grid2[i][j] = two; grid5[i][j] = five;\\n            \\n            left2[i][j] =   up2[i][j]   = two;\\n            if(j > 0)       left2[i][j] += left2[i][j-1];\\n            if(i > 0)       up2[i][j]   += up2[i-1][j];\\n            \\n            left5[i][j] =   up5[i][j]   = five;\\n            if(j > 0)       left5[i][j] += left5[i][j-1];\\n            if(i > 0)       up5[i][j]   += up5[i-1][j];\\n        }\\n        \\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            right2[i][j] =  down2[i][j]  = grid2[i][j];\\n            if(j < n-1)     right2[i][j] += right2[i][j+1];\\n            if(i < m-1)     down2[i][j]  += down2[i+1][j];\\n            \\n            right5[i][j] =  down5[i][j]  = grid5[i][j];\\n            if(j < n-1)     right5[i][j] += right5[i][j+1];\\n            if(i < m-1)     down5[i][j]  += down5[i+1][j];\\n        }\\n        \\n    int result = INT_MIN;\\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            result = max(min(left2[i][j] + up2[i][j] - grid2[i][j], left5[i][j] + up5[i][j] - grid5[i][j]), result);        //left+up\\n            result = max(min(left2[i][j] + right2[i][j] - grid2[i][j], left5[i][j] + right5[i][j] - grid5[i][j]), result);  //left+right\\n            result = max(min(up2[i][j] + right2[i][j] - grid2[i][j], up5[i][j] + right5[i][j] - grid5[i][j]), result);      //up+right\\n            result = max(min(up2[i][j] + down2[i][j] - grid2[i][j], up5[i][j] + down5[i][j] - grid5[i][j]), result);        //up+down\\n            result = max(min(right2[i][j] + down2[i][j] - grid2[i][j], right5[i][j] + down5[i][j] - grid5[i][j]), result);  //right+down\\n            result = max(min(left2[i][j] + down2[i][j] - grid2[i][j], left5[i][j] + down5[i][j] - grid5[i][j]), result);    //left+down\\n        }  \\n    return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& grid) {\\n    int m = grid.size(); int n = grid[0].size();\\n    vector<vector<int>> left2 (m, vector<int> (n, 0));  vector<vector<int>> left5 (m, vector<int> (n, 0));\\n    vector<vector<int>> right2 (m, vector<int> (n, 0)); vector<vector<int>> right5 (m, vector<int> (n, 0));\\n    vector<vector<int>> up2 (m, vector<int> (n, 0));    vector<vector<int>> up5 (m, vector<int> (n, 0));\\n    vector<vector<int>> down2 (m, vector<int> (n, 0));  vector<vector<int>> down5 (m, vector<int> (n, 0));\\n    vector<vector<int>> grid2 (m, vector<int> (n, 0));  vector<vector<int>> grid5 (m, vector<int> (n, 0));\\n        \\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++) {\\n            int two = 0; int temp = grid[i][j];\\n            while(temp % 2 == 0) {two++; temp /= 2;}\\n            \\n            int five = 0; temp = grid[i][j];\\n            while(temp % 5 == 0) {five++; temp /= 5;}\\n            \\n            grid2[i][j] = two; grid5[i][j] = five;\\n            \\n            left2[i][j] =   up2[i][j]   = two;\\n            if(j > 0)       left2[i][j] += left2[i][j-1];\\n            if(i > 0)       up2[i][j]   += up2[i-1][j];\\n            \\n            left5[i][j] =   up5[i][j]   = five;\\n            if(j > 0)       left5[i][j] += left5[i][j-1];\\n            if(i > 0)       up5[i][j]   += up5[i-1][j];\\n        }\\n        \\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            right2[i][j] =  down2[i][j]  = grid2[i][j];\\n            if(j < n-1)     right2[i][j] += right2[i][j+1];\\n            if(i < m-1)     down2[i][j]  += down2[i+1][j];\\n            \\n            right5[i][j] =  down5[i][j]  = grid5[i][j];\\n            if(j < n-1)     right5[i][j] += right5[i][j+1];\\n            if(i < m-1)     down5[i][j]  += down5[i+1][j];\\n        }\\n        \\n    int result = INT_MIN;\\n    for(int i = m-1; i >= 0; i--)\\n        for(int j = n-1; j >= 0; j--) {\\n            result = max(min(left2[i][j] + up2[i][j] - grid2[i][j], left5[i][j] + up5[i][j] - grid5[i][j]), result);        //left+up\\n            result = max(min(left2[i][j] + right2[i][j] - grid2[i][j], left5[i][j] + right5[i][j] - grid5[i][j]), result);  //left+right\\n            result = max(min(up2[i][j] + right2[i][j] - grid2[i][j], up5[i][j] + right5[i][j] - grid5[i][j]), result);      //up+right\\n            result = max(min(up2[i][j] + down2[i][j] - grid2[i][j], up5[i][j] + down5[i][j] - grid5[i][j]), result);        //up+down\\n            result = max(min(right2[i][j] + down2[i][j] - grid2[i][j], right5[i][j] + down5[i][j] - grid5[i][j]), result);  //right+down\\n            result = max(min(left2[i][j] + down2[i][j] - grid2[i][j], left5[i][j] + down5[i][j] - grid5[i][j]), result);    //left+down\\n        }  \\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955659,
                "title": "c-o-m-n-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int MaxTrailingZeros(int[][] grid)\\n    {\\n        int M = grid.Length; // total rows\\n        int N = grid[0].Length; // total columns\\n        // Create 8 memory grids\\n        int[,] twosUp = new int[M, N];\\n        int[,] twosDown = new int[M, N];\\n        int[,] twosLeft = new int[M, N];\\n        int[,] twosRight = new int[M, N];\\n        \\n        int[,] fivesUp = new int[M, N];\\n        int[,] fivesDown = new int[M, N];\\n        int[,] fivesLeft = new int[M, N];\\n        int[,] fivesRight = new int[M, N];\\n\\n        // Fill twosUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosUp[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosDown[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosLeft[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosRight[i, j] = twosCt;\\n            }\\n        }\\n\\n        // Fill fivesUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesUp[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesDown[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesLeft[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesRight[i, j] = fivesCt;\\n            }\\n        }\\n\\n        // traverse the grid, at each cell get the min of the 2s ct and 5s ct in any 2 right angle directions\\n        int max = 0;\\n        for (int i = 0; i < M; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                int option1twos = twosUp[i,j] + twosRight[i,j] - Get2FactorCtFrom(grid[i][j]);\\n                int option1fives = fivesUp[i, j] + fivesRight[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option1twos, option1fives));\\n\\n                int option2twos = twosUp[i, j] + twosLeft[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option2fives = fivesUp[i, j] + fivesLeft[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option2twos, option2fives));\\n\\n                int option3twos = twosLeft[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option3fives = fivesLeft[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option3twos, option3fives));\\n\\n                int option4twos = twosRight[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option4fives = fivesRight[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option4twos, option4fives));\\n\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int Get2FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 2 == 0)\\n        {\\n            result++;\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    private int Get5FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 5 == 0)\\n        {\\n            result++;\\n            n /= 5;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxTrailingZeros(int[][] grid)\\n    {\\n        int M = grid.Length; // total rows\\n        int N = grid[0].Length; // total columns\\n        // Create 8 memory grids\\n        int[,] twosUp = new int[M, N];\\n        int[,] twosDown = new int[M, N];\\n        int[,] twosLeft = new int[M, N];\\n        int[,] twosRight = new int[M, N];\\n        \\n        int[,] fivesUp = new int[M, N];\\n        int[,] fivesDown = new int[M, N];\\n        int[,] fivesLeft = new int[M, N];\\n        int[,] fivesRight = new int[M, N];\\n\\n        // Fill twosUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosUp[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int twosCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosDown[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosLeft[i, j] = twosCt;\\n            }\\n        }\\n        // Fill twosRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int twosCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                twosCt += Get2FactorCtFrom(grid[i][j]);\\n                twosRight[i, j] = twosCt;\\n            }\\n        }\\n\\n        // Fill fivesUp\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = 0; i < M; i++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesUp[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesDown\\n        for (int j = 0; j < N; j++)\\n        {\\n            int fivesCt = 0;\\n            for (int i = M - 1; i >= 0; i--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesDown[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesLeft \\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = 0; j < N; j++)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesLeft[i, j] = fivesCt;\\n            }\\n        }\\n        // Fill fivesRight\\n        for (int i = 0; i < M; i++)\\n        {\\n            int fivesCt = 0;\\n            for (int j = N - 1; j >= 0; j--)\\n            {\\n                fivesCt += Get5FactorCtFrom(grid[i][j]);\\n                fivesRight[i, j] = fivesCt;\\n            }\\n        }\\n\\n        // traverse the grid, at each cell get the min of the 2s ct and 5s ct in any 2 right angle directions\\n        int max = 0;\\n        for (int i = 0; i < M; i++)\\n        {\\n            for (int j = 0; j < N; j++)\\n            {\\n                int option1twos = twosUp[i,j] + twosRight[i,j] - Get2FactorCtFrom(grid[i][j]);\\n                int option1fives = fivesUp[i, j] + fivesRight[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option1twos, option1fives));\\n\\n                int option2twos = twosUp[i, j] + twosLeft[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option2fives = fivesUp[i, j] + fivesLeft[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option2twos, option2fives));\\n\\n                int option3twos = twosLeft[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option3fives = fivesLeft[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option3twos, option3fives));\\n\\n                int option4twos = twosRight[i, j] + twosDown[i, j] - Get2FactorCtFrom(grid[i][j]);\\n                int option4fives = fivesRight[i, j] + fivesDown[i, j] - Get5FactorCtFrom(grid[i][j]);\\n                max = Math.Max(max, Math.Min(option4twos, option4fives));\\n\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int Get2FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 2 == 0)\\n        {\\n            result++;\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    private int Get5FactorCtFrom(int n)\\n    {\\n        int result = 0;\\n        while (n % 5 == 0)\\n        {\\n            result++;\\n            n /= 5;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955635,
                "title": "java-beat-100-straightforward-prefix-sum-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\t// Get the number of twos\\n\\t\\t//     the number of fives\\n\\t\\tpublic int[] getTwoFive(int n) {\\n\\t\\t\\tint twos = 0;\\n\\t\\t\\tint tmp = n;\\n\\n\\t\\t\\twhile(tmp > 0 && tmp % 2 == 0) {\\n\\t\\t\\t\\ttwos++;\\n\\t\\t\\t\\ttmp /= 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint fives = 0;\\n\\t\\t\\ttmp = n;\\n\\n\\t\\t\\twhile(tmp > 0 && tmp % 5 == 0) {\\n\\t\\t\\t\\tfives++;\\n\\t\\t\\t\\ttmp /= 5;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new int[]{twos, fives};\\n\\t\\t}\\n\\n\\t\\tpublic int maxTrailingZeros(int[][] grid) {\\n\\t\\t\\tint R = grid.length;\\n\\t\\t\\tint C = grid[0].length;\\n\\n\\t\\t\\tint[][][] twoFiveGrid = new int[R][C][2];\\n\\n\\t\\t\\t// Save the number of twos and fives\\n\\t\\t\\t// twoFiveGrid[i][j][0] : twos\\n\\t\\t\\t// twoFiveGrid[i][j][1] : fives\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\t\\tint[] twoFive = getTwoFive(grid[i][j]);\\n\\t\\t\\t\\t\\ttwoFiveGrid[i][j][0] = twoFive[0];\\n\\t\\t\\t\\t\\ttwoFiveGrid[i][j][1] = twoFive[1];   \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// prefix array from top to bottom.\\n\\t\\t\\tint[][][] downFix = new int[R][C][2];\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tdownFix[0][j][0] = twoFiveGrid[0][j][0];\\n\\t\\t\\t\\tdownFix[0][j][1] = twoFiveGrid[0][j][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tfor(int i=1; i<R; ++i) {\\n\\t\\t\\t\\t\\tdownFix[i][j][0] = downFix[i-1][j][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tdownFix[i][j][1] = downFix[i-1][j][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// prefix array from bottom to top.\\n\\t\\t\\tint[][][] upFix = new int[R][C][2];\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tupFix[R-1][j][0] = twoFiveGrid[R-1][j][0];\\n\\t\\t\\t\\tupFix[R-1][j][1] = twoFiveGrid[R-1][j][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\t\\t\\t\\tfor(int i=R-2; i>=0; --i) {\\n\\t\\t\\t\\t\\tupFix[i][j][0] += upFix[i+1][j][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tupFix[i][j][1] += upFix[i+1][j][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// prefix array from left to right.\\n\\t\\t\\tint[][][] lFix = new int[R][C][2];\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tlFix[i][0][0] = twoFiveGrid[i][0][0];\\n\\t\\t\\t\\tlFix[i][0][1] = twoFiveGrid[i][0][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=1; j<C; ++j) {\\n\\t\\t\\t\\t\\tlFix[i][j][0] = lFix[i][j-1][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tlFix[i][j][1] = lFix[i][j-1][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// prefix array from right to left.\\n\\t\\t\\tint[][][] rFix = new int[R][C][2];\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\trFix[i][C-1][0] = twoFiveGrid[i][C-1][0];\\n\\t\\t\\t\\trFix[i][C-1][1] = twoFiveGrid[i][C-1][1];   \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=C-2; j>=0; --j) {\\n\\t\\t\\t\\t\\trFix[i][j][0] = rFix[i][j+1][0] + twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\trFix[i][j][1] = rFix[i][j+1][1] + twoFiveGrid[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=0; i<R; ++i) {\\n\\t\\t\\t\\tfor(int j=0; j<C; ++j) {\\n\\n\\t\\t\\t\\t\\t// \\u3134 case\\n\\t\\t\\t\\t\\tint two = downFix[i][j][0] + rFix[i][j][0];\\n\\t\\t\\t\\t\\tint five = downFix[i][j][1] + rFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\n\\n\\t\\t\\t\\t\\t// \\u250C case\\n\\t\\t\\t\\t\\ttwo = upFix[i][j][0] + rFix[i][j][0];\\n\\t\\t\\t\\t\\tfive = upFix[i][j][1] + rFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\n\\n\\t\\t\\t\\t\\t// \\u3131 case\\n\\t\\t\\t\\t\\ttwo = upFix[i][j][0] + lFix[i][j][0];\\n\\t\\t\\t\\t\\tfive = upFix[i][j][1] + lFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\n\\n\\t\\t\\t\\t\\t// \\u2518 case\\n\\t\\t\\t\\t\\ttwo = downFix[i][j][0] + lFix[i][j][0];\\n\\t\\t\\t\\t\\tfive = downFix[i][j][1] + lFix[i][j][1];\\n\\t\\t\\t\\t\\ttwo -= twoFiveGrid[i][j][0];\\n\\t\\t\\t\\t\\tfive -= twoFiveGrid[i][j][1];\\n\\n\\t\\t\\t\\t\\tres = Math.max(res, Math.min(two, five));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t// Get the number of twos\\n\\t\\t//     the number of fives\\n\\t\\tpublic int[] getTwoFive(int n) {\\n\\t\\t\\tint twos = 0;\\n\\t\\t\\tint tmp = n;\\n\\n\\t\\t\\twhile(tmp > 0 && tmp % 2 == 0) {\\n\\t\\t\\t\\ttwos++;\\n\\t\\t\\t\\ttmp /= 2;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1955634,
                "title": "java-prefix-sum-solution-count-5s-2s",
                "content": "Basically I find the sum of 2s and 5s from top to bottom, and from left to right and create prefix matrices.\\nThen find best possible solution at each index picking one of the 4, up down left or right and always include the current index\\n\\n```\\nclass Solution {\\n    \\n    Map<Integer, Integer> findTwoCache;\\n    Map<Integer, Integer> findFiveCache;\\n    public int maxTrailingZeros(int[][] grid) {\\n        findTwoCache = new HashMap<>();\\n        findFiveCache = new HashMap<>();\\n        int n= grid.length;\\n        int m = grid[0].length;\\n        int[][][] fromTop = new int[n][m][2];\\n        \\n        for (int i = 0; i < m;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j = 0;j < n;j++){\\n                int currVal = grid[j][i];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromTop[j][i][0] = countTwo;\\n                fromTop[j][i][1] = countFive;\\n            }\\n        }\\n        \\n        int[][][] fromLeft = new int[n][m][2];\\n        \\n\\n        for (int i = 0;i < n;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j =0;j < m;j++){\\n                int currVal = grid[i][j];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromLeft[i][j][0] = countTwo;\\n                fromLeft[i][j][1] = countFive;\\n            }\\n        }\\n\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < n;i++){\\n            for (int j =0;j < m;j++){\\n\\n                // in each index we have 4 options, we can pick 2\\n                int currVal = grid[i][j];\\n                int currTwo = find(currVal, 2);\\n                int currFive = find(currVal, 5);\\n                \\n                int upTwo = 0;\\n                int upFive = 0;\\n                \\n                if (i - 1 >= 0){\\n                     upTwo = fromTop[i-1][j][0];\\n                 upFive = fromTop[i-1][j][1];\\n                }\\n                \\n                // down is basically the very bottom value - our current value\\n                int downTwo = fromTop[n-1][j][0] - fromTop[i][j][0];\\n                int downFive = fromTop[n-1][j][1] - fromTop[i][j][1];\\n                \\n                // left is just current from left - currentVal\\n                int leftTwo = 0;\\n                int leftFive = 0;\\n                if (j > 0){\\n                     leftTwo = fromLeft[i][j-1][0];\\n                    leftFive = fromLeft[i][j-1][1];\\n                }\\n                \\n                // right is very right - our current value and all left\\n                int rightTwo = fromLeft[i][m-1][0] - fromLeft[i][j][0];\\n                int rightFive = fromLeft[i][m-1][1] - fromLeft[i][j][1];\\n                \\n\\n                \\n                List<int[]> arr = new ArrayList<>();\\n                \\n                arr.add(new int[]{upTwo, upFive});\\n                arr.add(new int[]{downTwo, downFive});\\n                arr.add(new int[]{leftTwo, leftFive});\\n                arr.add(new int[]{rightTwo, rightFive});\\n                \\n                for (int a = 0; a < arr.size();a++){\\n                    for (int b = a+1;b < arr.size();b++){\\n                        int sumTwo = arr.get(a)[0] + arr.get(b)[0] + currTwo;\\n                        int sumFive = arr.get(a)[1] + arr.get(b)[1] + currFive;\\n                        int ans = Math.min(sumTwo, sumFive);\\n\\n                        max = Math.max(max, ans);\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n    \\n    public int find(int val, int divide){\\n        if (divide == 2){\\n            if (findTwoCache.containsKey(val)) return findTwoCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 2 == 0){\\n                val /= 2;\\n                res++;\\n            }\\n            findTwoCache.put(save, res);\\n            return res;\\n        }\\n        else {\\n            if (findFiveCache.containsKey(val)) return findFiveCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 5 == 0){\\n                val /= 5;\\n                res++;\\n            }\\n            findFiveCache.put(save, res);\\n            return res;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, Integer> findTwoCache;\\n    Map<Integer, Integer> findFiveCache;\\n    public int maxTrailingZeros(int[][] grid) {\\n        findTwoCache = new HashMap<>();\\n        findFiveCache = new HashMap<>();\\n        int n= grid.length;\\n        int m = grid[0].length;\\n        int[][][] fromTop = new int[n][m][2];\\n        \\n        for (int i = 0; i < m;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j = 0;j < n;j++){\\n                int currVal = grid[j][i];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromTop[j][i][0] = countTwo;\\n                fromTop[j][i][1] = countFive;\\n            }\\n        }\\n        \\n        int[][][] fromLeft = new int[n][m][2];\\n        \\n\\n        for (int i = 0;i < n;i++){\\n            int countTwo = 0;\\n            int countFive = 0;\\n            for (int j =0;j < m;j++){\\n                int currVal = grid[i][j];\\n                countTwo += find(currVal, 2);\\n                countFive += find(currVal, 5);\\n                fromLeft[i][j][0] = countTwo;\\n                fromLeft[i][j][1] = countFive;\\n            }\\n        }\\n\\n        \\n        int max = 0;\\n        \\n        for (int i = 0; i < n;i++){\\n            for (int j =0;j < m;j++){\\n\\n                // in each index we have 4 options, we can pick 2\\n                int currVal = grid[i][j];\\n                int currTwo = find(currVal, 2);\\n                int currFive = find(currVal, 5);\\n                \\n                int upTwo = 0;\\n                int upFive = 0;\\n                \\n                if (i - 1 >= 0){\\n                     upTwo = fromTop[i-1][j][0];\\n                 upFive = fromTop[i-1][j][1];\\n                }\\n                \\n                // down is basically the very bottom value - our current value\\n                int downTwo = fromTop[n-1][j][0] - fromTop[i][j][0];\\n                int downFive = fromTop[n-1][j][1] - fromTop[i][j][1];\\n                \\n                // left is just current from left - currentVal\\n                int leftTwo = 0;\\n                int leftFive = 0;\\n                if (j > 0){\\n                     leftTwo = fromLeft[i][j-1][0];\\n                    leftFive = fromLeft[i][j-1][1];\\n                }\\n                \\n                // right is very right - our current value and all left\\n                int rightTwo = fromLeft[i][m-1][0] - fromLeft[i][j][0];\\n                int rightFive = fromLeft[i][m-1][1] - fromLeft[i][j][1];\\n                \\n\\n                \\n                List<int[]> arr = new ArrayList<>();\\n                \\n                arr.add(new int[]{upTwo, upFive});\\n                arr.add(new int[]{downTwo, downFive});\\n                arr.add(new int[]{leftTwo, leftFive});\\n                arr.add(new int[]{rightTwo, rightFive});\\n                \\n                for (int a = 0; a < arr.size();a++){\\n                    for (int b = a+1;b < arr.size();b++){\\n                        int sumTwo = arr.get(a)[0] + arr.get(b)[0] + currTwo;\\n                        int sumFive = arr.get(a)[1] + arr.get(b)[1] + currFive;\\n                        int ans = Math.min(sumTwo, sumFive);\\n\\n                        max = Math.max(max, ans);\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n    \\n    public int find(int val, int divide){\\n        if (divide == 2){\\n            if (findTwoCache.containsKey(val)) return findTwoCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 2 == 0){\\n                val /= 2;\\n                res++;\\n            }\\n            findTwoCache.put(save, res);\\n            return res;\\n        }\\n        else {\\n            if (findFiveCache.containsKey(val)) return findFiveCache.get(val);\\n            int res = 0;\\n            int save = val;\\n            \\n            while (val > 0 && val % 5 == 0){\\n                val /= 5;\\n                res++;\\n            }\\n            findFiveCache.put(save, res);\\n            return res;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955633,
                "title": "c-prefix-sum-for-4-directions-o-m-n-solution",
                "content": "Number of trailing zeroes = minimum ( 2s, 5s) in prime factorisation of that number.\\n**Steps**:\\n1. Convert the given array into pair ```{x,y} ``` where x = 2s, y = 5s\\n2. make prefix sum for all four directions.\\n3. Now iterate over all indices assuming that current index is the corner of our cornered path.\\n4. Compute the anser for all four directions and take maximum of those.\\n\\nThank You for reading :)\\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int n = g.size(),m = g[0].size();\\n        auto a = process(g);\\n        //prefix sums\\n        auto lef = Left(a);\\n        auto rig = Right(a);\\n        auto top = Top(a);\\n        auto bot = Bottom(a);\\n    \\n        int ans = 0;\\n        \\n        // If (i,j) is the corner of the cornered path\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                //for an corner we have four differnt possiblilities\\n                ans = max ({ ans,\\n                           compute(a[i][j],lef[i][j],top[i][j]),\\n                           compute(a[i][j],lef[i][j],bot[i][j]),\\n                           compute(a[i][j],rig[i][j],top[i][j]),\\n                           compute(a[i][j],rig[i][j],bot[i][j])\\n                          });\\n            }\\n        }\\n        return ans;\\n    }\\n    //returns anser for a corner in cornerd path\\n    int compute(pair<int,int>& a,pair<int,int>& b,pair<int,int>& c){\\n        pair<int,int> res;\\n        res.first = a.first + b.first + c.first;\\n        res.second = a.second + b.second + c.second;\\n        //returns minimum because number of zeroes is min of {2s,5s}\\n        return min(res.first,res.second);\\n    }\\n    \\n    //Prefix sum from left to right\\n    vector<vector<pair<int,int>>> Left(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            //left to right\\n            for(int j = 1;j<m;j++){\\n                res[i][j]= add(res[i][j-1],a[i][j-1]);\\n            }\\n        }\\n        return res;\\n    }\\n     //Prefix sum from right to left\\n    vector<vector<pair<int,int>>> Right(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            // right to left\\n            pair<int,int> t = {0,0};\\n            for(int j = m-2;j>=0;j--){\\n                t = add(t,a[i][j+1]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Top(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            //top to bottom\\n            for(int i = 1;i<n;i++){\\n                res[i][j]= add(res[i-1][j],a[i-1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Bottom(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            pair<int,int> t = {0,0};\\n            for(int i = n-2;i>=0;i--){\\n                t = add(t,a[i+1][j]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    } \\n    \\n    //return {a,b} where a is highest pow of 2, b of 5\\n    vector<vector<pair<int,int>>> process(vector<vector<int>>& g){\\n        vector<vector<pair<int,int>>> res(g.size());\\n        for(int i =0;i<g.size();i++){\\n            for(int j = 0;j<g[0].size();j++){\\n                int num = g[i][j];\\n                int x = highestPow(2,num);\\n                int y = highestPow(5,num);\\n                res[i].push_back({x,y});\\n            }\\n        }\\n        return res;\\n    }\\n    //pow of a in b\\n    int highestPow(int a,int b){\\n        if(b%a) return 0;\\n        return 1 + highestPow(a,b/a);\\n    }\\n    \\n\\n    pair<int,int> add(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = a.first + b.first;\\n        res.second = a.second + b.second;\\n        return res;\\n    }\\n    pair<int,int> Max(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = max(a.first ,b.first);\\n        res.second = max(a.second , b.second);\\n        return res;\\n    }\\n    \\n    void debug(vector<vector<pair<int,int>>>& a){\\n        for(int i =0;i<a.size();i++){\\n            for(int j =0;j<a[0].size();j++){\\n                cout<<a[i][j].first<<\",\"<<a[i][j].second<<\"  \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```{x,y} ```\n```\\nclass Solution {\\npublic:\\n    int maxTrailingZeros(vector<vector<int>>& g) {\\n        int n = g.size(),m = g[0].size();\\n        auto a = process(g);\\n        //prefix sums\\n        auto lef = Left(a);\\n        auto rig = Right(a);\\n        auto top = Top(a);\\n        auto bot = Bottom(a);\\n    \\n        int ans = 0;\\n        \\n        // If (i,j) is the corner of the cornered path\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                //for an corner we have four differnt possiblilities\\n                ans = max ({ ans,\\n                           compute(a[i][j],lef[i][j],top[i][j]),\\n                           compute(a[i][j],lef[i][j],bot[i][j]),\\n                           compute(a[i][j],rig[i][j],top[i][j]),\\n                           compute(a[i][j],rig[i][j],bot[i][j])\\n                          });\\n            }\\n        }\\n        return ans;\\n    }\\n    //returns anser for a corner in cornerd path\\n    int compute(pair<int,int>& a,pair<int,int>& b,pair<int,int>& c){\\n        pair<int,int> res;\\n        res.first = a.first + b.first + c.first;\\n        res.second = a.second + b.second + c.second;\\n        //returns minimum because number of zeroes is min of {2s,5s}\\n        return min(res.first,res.second);\\n    }\\n    \\n    //Prefix sum from left to right\\n    vector<vector<pair<int,int>>> Left(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            //left to right\\n            for(int j = 1;j<m;j++){\\n                res[i][j]= add(res[i][j-1],a[i][j-1]);\\n            }\\n        }\\n        return res;\\n    }\\n     //Prefix sum from right to left\\n    vector<vector<pair<int,int>>> Right(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int i =0;i<n;i++){\\n            // right to left\\n            pair<int,int> t = {0,0};\\n            for(int j = m-2;j>=0;j--){\\n                t = add(t,a[i][j+1]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Top(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            //top to bottom\\n            for(int i = 1;i<n;i++){\\n                res[i][j]= add(res[i-1][j],a[i-1][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<pair<int,int>>> Bottom(vector<vector<pair<int,int>>>& a){\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<pair<int,int>>> res(n,vector<pair<int,int>>(m,{0,0}));\\n        for(int j =0;j<m;j++){\\n            pair<int,int> t = {0,0};\\n            for(int i = n-2;i>=0;i--){\\n                t = add(t,a[i+1][j]);\\n                res[i][j] = t;\\n            }\\n        }\\n        return res;\\n    } \\n    \\n    //return {a,b} where a is highest pow of 2, b of 5\\n    vector<vector<pair<int,int>>> process(vector<vector<int>>& g){\\n        vector<vector<pair<int,int>>> res(g.size());\\n        for(int i =0;i<g.size();i++){\\n            for(int j = 0;j<g[0].size();j++){\\n                int num = g[i][j];\\n                int x = highestPow(2,num);\\n                int y = highestPow(5,num);\\n                res[i].push_back({x,y});\\n            }\\n        }\\n        return res;\\n    }\\n    //pow of a in b\\n    int highestPow(int a,int b){\\n        if(b%a) return 0;\\n        return 1 + highestPow(a,b/a);\\n    }\\n    \\n\\n    pair<int,int> add(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = a.first + b.first;\\n        res.second = a.second + b.second;\\n        return res;\\n    }\\n    pair<int,int> Max(pair<int,int>& a,pair<int,int>& b){\\n        pair<int,int> res;\\n        res.first = max(a.first ,b.first);\\n        res.second = max(a.second , b.second);\\n        return res;\\n    }\\n    \\n    void debug(vector<vector<pair<int,int>>>& a){\\n        for(int i =0;i<a.size();i++){\\n            for(int j =0;j<a[0].size();j++){\\n                cout<<a[i][j].first<<\",\"<<a[i][j].second<<\"  \";\\n            }\\n            cout<<endl;\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955629,
                "title": "simple-kotlin-solution-prefix-sum",
                "content": "1. Create helper arrays with counts of factors 2 and 5 in the corner of the grid (0,0), (x, y)\\n2. Loop through all cells and assume it is our turning point, checking how many zeros we can have with different path configurations\\n3. return max\\n\\nThe tricky part here is to correctly code all the math. I was getting WA during the contest because of incorrect formulas. Creating helper functions fixed all issues, but it was too late).\\n\\n```kotlin\\nclass Solution {\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        \\n        // twos[x][y] = count of factors of 2 in a grid from (0,0) to (x-1, y-1) \\n        val twos = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        // twos[x][y] = count of factors of 5 in a grid from (0,0) to (x-1, y-1) \\n        val fives = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        \\n        // populate counts\\n        for (x in 1..m) {\\n            for (y in 1..n) {\\n                twos[x][y] = twos[x-1][y] + (twos[x][y-1] - twos[x-1][y-1]) + countFactors(grid[x-1][y-1], 2)\\n                fives[x][y] = fives[x-1][y] + (fives[x][y-1] - fives[x-1][y-1]) + countFactors(grid[x-1][y-1], 5)\\n            }\\n        }\\n        \\n        var result = 0\\n        \\n        for (x in 1..m) {\\n           for (y in 1..n) {\\n                // top-left corners \\n                var t = twos[x][y] - twos[x-1][y-1]\\n                var f = fives[x][y] - fives[x-1][y-1]\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // top-right corners\\n                t = topRight(twos, x, y) - topRight(twos, x-1, y+1)\\n                f = topRight(fives, x, y) - topRight(fives, x-1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-left corners\\n                t = bottomLeft(twos, x, y) - bottomLeft(twos, x+1, y-1)\\n                f = bottomLeft(fives, x, y) - bottomLeft(fives, x+1, y-1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-right corners\\n                t = bottomRight(twos, x, y) - bottomRight(twos, x+1, y+1)\\n                f = bottomRight(fives, x, y) - bottomRight(fives, x+1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n           } \\n        }\\n        \\n        return result\\n    }\\n    \\n    // returns count in a top-right rectangle (x, y)\\n    private fun topRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[x][n] - a[x][y-1]\\n    }\\n    \\n    // returns count in a bottom-left rectangle (x, y)\\n    private fun bottomLeft(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][y] - a[x-1][y]\\n    }\\n    \\n    // returns count in a bottom-right rectangle (x, y)\\n    private fun bottomRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][n] - a[m][y-1] - a[x-1][n] + a[x-1][y-1]\\n    }\\n    \\n    private fun countFactors(x: Int, prime: Int): Int {\\n        var v = x\\n        var result = 0\\n        while (v > 0 && v % prime == 0) {\\n            result++\\n            v /= prime\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\\n        val m = grid.size\\n        val n = grid[0].size\\n        \\n        // twos[x][y] = count of factors of 2 in a grid from (0,0) to (x-1, y-1) \\n        val twos = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        // twos[x][y] = count of factors of 5 in a grid from (0,0) to (x-1, y-1) \\n        val fives = Array(m+1) {\\n            IntArray(n+1)\\n        }\\n        \\n        // populate counts\\n        for (x in 1..m) {\\n            for (y in 1..n) {\\n                twos[x][y] = twos[x-1][y] + (twos[x][y-1] - twos[x-1][y-1]) + countFactors(grid[x-1][y-1], 2)\\n                fives[x][y] = fives[x-1][y] + (fives[x][y-1] - fives[x-1][y-1]) + countFactors(grid[x-1][y-1], 5)\\n            }\\n        }\\n        \\n        var result = 0\\n        \\n        for (x in 1..m) {\\n           for (y in 1..n) {\\n                // top-left corners \\n                var t = twos[x][y] - twos[x-1][y-1]\\n                var f = fives[x][y] - fives[x-1][y-1]\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // top-right corners\\n                t = topRight(twos, x, y) - topRight(twos, x-1, y+1)\\n                f = topRight(fives, x, y) - topRight(fives, x-1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-left corners\\n                t = bottomLeft(twos, x, y) - bottomLeft(twos, x+1, y-1)\\n                f = bottomLeft(fives, x, y) - bottomLeft(fives, x+1, y-1)\\n                result = maxOf(result, minOf(t, f))\\n                \\n                // bottom-right corners\\n                t = bottomRight(twos, x, y) - bottomRight(twos, x+1, y+1)\\n                f = bottomRight(fives, x, y) - bottomRight(fives, x+1, y+1)\\n                result = maxOf(result, minOf(t, f))\\n           } \\n        }\\n        \\n        return result\\n    }\\n    \\n    // returns count in a top-right rectangle (x, y)\\n    private fun topRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[x][n] - a[x][y-1]\\n    }\\n    \\n    // returns count in a bottom-left rectangle (x, y)\\n    private fun bottomLeft(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][y] - a[x-1][y]\\n    }\\n    \\n    // returns count in a bottom-right rectangle (x, y)\\n    private fun bottomRight(a: Array<IntArray>, x: Int, y: Int): Int {\\n        val m = a.size-1\\n        val n = a[0].size-1\\n        return a[m][n] - a[m][y-1] - a[x-1][n] + a[x-1][y-1]\\n    }\\n    \\n    private fun countFactors(x: Int, prime: Int): Int {\\n        var v = x\\n        var result = 0\\n        while (v > 0 && v % prime == 0) {\\n            result++\\n            v /= prime\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955610,
                "title": "python-prefix-sum-pre-compute-factors-of-2-and-5-beats-100-time",
                "content": "One trick is to notice that each entry is bound to be between 1 and 1000 so we can just pre-compute and lookup (seem to save significant amount of time):\\n\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        d = {}\\n        for i in range(1, 1001):\\n            n_2 = 0\\n            curr = i\\n            while curr % 2 == 0:\\n                curr //= 2\\n                n_2 += 1\\n            n_5 = 0\\n            curr = i\\n            while curr % 5 == 0:\\n                curr //= 5\\n                n_5 += 1\\n            d[i] = (n_2, n_5)\\n            \\n        grid_25 = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                grid_25[i][j] = d[grid[i][j]]\\n        \\n        # print(grid_25)\\n        grid_row_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            n_2 = 0\\n            n_5 = 0\\n            for j in range(n):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_row_sum[i][j] = (n_2, n_5)\\n                \\n        grid_col_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for j in range(n):\\n            n_2 = 0\\n            n_5 = 0\\n            for i in range(m):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_col_sum[i][j] = (n_2, n_5)\\n        \\n        # rows_c = rows.copy()\\n        # cols_c = cols.copy()\\n        # print(grid_row_sum)\\n        # print(grid_col_sum)\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # there are 4 options:\\n                a0 = min(grid_row_sum[i][j][0] + grid_col_sum[i][j][0] - grid_25[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[i][j][1] - grid_25[i][j][1])\\n                a1 = min(grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1])\\n                a2 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[i][j][1])\\n                a3 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0] + grid_25[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1] + grid_25[i][j][1])\\n                # print(a0, a1, a2, a3)\\n                ans = max(a0, a1, a2, a3, ans)\\n                # print(ans)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        d = {}\\n        for i in range(1, 1001):\\n            n_2 = 0\\n            curr = i\\n            while curr % 2 == 0:\\n                curr //= 2\\n                n_2 += 1\\n            n_5 = 0\\n            curr = i\\n            while curr % 5 == 0:\\n                curr //= 5\\n                n_5 += 1\\n            d[i] = (n_2, n_5)\\n            \\n        grid_25 = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                grid_25[i][j] = d[grid[i][j]]\\n        \\n        # print(grid_25)\\n        grid_row_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            n_2 = 0\\n            n_5 = 0\\n            for j in range(n):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_row_sum[i][j] = (n_2, n_5)\\n                \\n        grid_col_sum = [[0 for _ in range(n)] for _ in range(m)]\\n        for j in range(n):\\n            n_2 = 0\\n            n_5 = 0\\n            for i in range(m):\\n                x, y = grid_25[i][j]\\n                n_2 += x\\n                n_5 += y\\n                grid_col_sum[i][j] = (n_2, n_5)\\n        \\n        # rows_c = rows.copy()\\n        # cols_c = cols.copy()\\n        # print(grid_row_sum)\\n        # print(grid_col_sum)\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # there are 4 options:\\n                a0 = min(grid_row_sum[i][j][0] + grid_col_sum[i][j][0] - grid_25[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[i][j][1] - grid_25[i][j][1])\\n                a1 = min(grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0], \\n                         grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1])\\n                a2 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[i][j][1])\\n                a3 = min(grid_row_sum[i][-1][0] - grid_row_sum[i][j][0] + grid_col_sum[-1][j][0] - grid_col_sum[i][j][0] + grid_25[i][j][0], \\n                         grid_row_sum[i][-1][1] - grid_row_sum[i][j][1] + grid_col_sum[-1][j][1] - grid_col_sum[i][j][1] + grid_25[i][j][1])\\n                # print(a0, a1, a2, a3)\\n                ans = max(a0, a1, a2, a3, ans)\\n                # print(ans)\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564619,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            },
            {
                "id": 1992342,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            },
            {
                "id": 1844333,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            },
            {
                "id": 1764055,
                "content": [
                    {
                        "username": "a13r1",
                        "content": "![image](https://assets.leetcode.com/users/images/a5780313-467a-43eb-9732-d681f806ef71_1650170050.8714461.gif)\\n"
                    },
                    {
                        "username": "datle2802",
                        "content": "the fact that this is the only and most upvoted comment ;D"
                    },
                    {
                        "username": "archiegertsman",
                        "content": "I found LeetCode to be picky about runtime for this problem. My code was only accepted after I vectorized a computation in Python3. Imho, this problem should be categorized as \"hard\"."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Skip this Question to avoid wasting time!!"
                    },
                    {
                        "username": "aryonbe",
                        "content": "At first sight, this problem seems very difficult!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Nodes Equal to Average of Subtree",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>the number of nodes where the value of the node is equal to the <strong>average</strong> of the values in its <strong>subtree</strong></em>.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>The <strong>average</strong> of <code>n</code> elements is the <strong>sum</strong> of the <code>n</code> elements divided by <code>n</code> and <strong>rounded down</strong> to the nearest integer.</li>\n\t<li>A <strong>subtree</strong> of <code>root</code> is a tree consisting of <code>root</code> and all of its descendants.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png\" style=\"width: 300px; height: 212px;\" />\n<pre>\n<strong>Input:</strong> root = [4,8,5,0,1,null,6]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> \nFor the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\nFor the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\nFor the node with value 0: The average of its subtree is 0 / 1 = 0.\nFor the node with value 1: The average of its subtree is 1 / 1 = 1.\nFor the node with value 6: The average of its subtree is 6 / 1 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png\" style=\"width: 80px; height: 76px;\" />\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> For the node with value 1: The average of its subtree is 1 / 1 = 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017720,
                "title": "easy-c-code-optimization-from-o-n-2-to-o-n",
                "content": "Solving by brute force,\\n\\nWe iterate to each and every node by using any traversal (preorder, postorder, inorder). I used preorder. \\nFrom each and every node we calculate sum of its subtree nodes and also maintain a cnt variable to store the no. of nodes, so that we can calculate average.\\nIf average is equal to value of the root, we increment the ans.\\n**Time complexity : O(n^2)**\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sum(TreeNode* root, int& cnt){\\n        if(root==NULL) return 0;\\n        cnt++;\\n        int left = sum(root->left,cnt);\\n        int right = sum(root->right,cnt);\\n        return (root->val + left + right);\\n    }\\n    void solve(TreeNode* root){\\n        if(root==NULL) return;\\n        int cnt = 0;\\n        int avg = (sum(root,cnt))/cnt;\\n        if(avg==root->val) ans++;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        ans = 0;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Optimization: **\\n\\nBefore we calculated the sum for every sub tree.\\nHere we do a postorder traversal, we will calculate the sum of nodes in left sub tree and cnt of nodes in left subtree , as well as for right subtree and use this to root.\\n**Time complexity: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    pair<int,int> solve(TreeNode* root){\\n        if(root==NULL) return {0,0};\\n        \\n        auto left = solve(root->left);\\n        int l_sum = left.first; // sum of nodes present in left sub tree\\n        int l_cnt = left.second; // no. of nodes present in left sub tree\\n        \\n        auto right = solve(root->right);\\n        int r_sum = right.first; // sum of nodes present in right sub tree\\n        int r_cnt = right.second; // no. of nodes present in left sub tree\\n        \\n        int sum = root->val + l_sum + r_sum;\\n        int cnt = l_cnt + r_cnt + 1;\\n        \\n        if(root->val == sum/cnt) ans++;\\n        return {sum,cnt};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int sum(TreeNode* root, int& cnt){\\n        if(root==NULL) return 0;\\n        cnt++;\\n        int left = sum(root->left,cnt);\\n        int right = sum(root->right,cnt);\\n        return (root->val + left + right);\\n    }\\n    void solve(TreeNode* root){\\n        if(root==NULL) return;\\n        int cnt = 0;\\n        int avg = (sum(root,cnt))/cnt;\\n        if(avg==root->val) ans++;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        ans = 0;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    pair<int,int> solve(TreeNode* root){\\n        if(root==NULL) return {0,0};\\n        \\n        auto left = solve(root->left);\\n        int l_sum = left.first; // sum of nodes present in left sub tree\\n        int l_cnt = left.second; // no. of nodes present in left sub tree\\n        \\n        auto right = solve(root->right);\\n        int r_sum = right.first; // sum of nodes present in right sub tree\\n        int r_cnt = right.second; // no. of nodes present in left sub tree\\n        \\n        int sum = root->val + l_sum + r_sum;\\n        int cnt = l_cnt + r_cnt + 1;\\n        \\n        if(root->val == sum/cnt) ans++;\\n        return {sum,cnt};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017827,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int averageOfSubtree(TreeNode root) {\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private int[] dfs(TreeNode node) {\\n        if(node == null) {\\n            return new int[] {0,0};\\n        }\\n        \\n        int[] left = dfs(node.left);\\n        int[] right = dfs(node.right);\\n        \\n        int currSum = left[0] + right[0] + node.val;\\n        int currCount = left[1] + right[1] + 1;\\n        \\n        if(currSum / currCount == node.val) {\\n            res++;\\n        }\\n            \\n        return new int[] {currSum, currCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int averageOfSubtree(TreeNode root) {\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private int[] dfs(TreeNode node) {\\n        if(node == null) {\\n            return new int[] {0,0};\\n        }\\n        \\n        int[] left = dfs(node.left);\\n        int[] right = dfs(node.right);\\n        \\n        int currSum = left[0] + right[0] + node.val;\\n        int currCount = left[1] + right[1] + 1;\\n        \\n        if(currSum / currCount == node.val) {\\n            res++;\\n        }\\n            \\n        return new int[] {currSum, currCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017808,
                "title": "sum-count-match",
                "content": "Our `dfs` function returns the sum and count of nodes, and the number of matching nodes.\\n\\n**C++**\\n```cpp\\narray<int, 3> dfs(TreeNode* n) {\\n    if (n == nullptr)\\n        return {0, 0, 0};\\n    auto p1 = dfs(n->left), p2 = dfs(n->right);\\n    int sum = p1[0] + p2[0] + n->val, count = 1 + p1[1] + p2[1];\\n    return {sum, count, p1[2] + p2[2] + (n->val == sum / count)};\\n}\\nint averageOfSubtree(TreeNode* root) {\\n    return dfs(root)[2];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\narray<int, 3> dfs(TreeNode* n) {\\n    if (n == nullptr)\\n        return {0, 0, 0};\\n    auto p1 = dfs(n->left), p2 = dfs(n->right);\\n    int sum = p1[0] + p2[0] + n->val, count = 1 + p1[1] + p2[1];\\n    return {sum, count, p1[2] + p2[2] + (n->val == sum / count)};\\n}\\nint averageOfSubtree(TreeNode* root) {\\n    return dfs(root)[2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018178,
                "title": "c-solution-o-n-100-00-faster",
                "content": "So I am calling at every node and asking total sum and total number of node including that node itself so every subtree will return total sum of tree and total number of node. gobal variable will keep updating.\\n```\\nint count=0;\\npair<int,int> valueSum(TreeNode* root){\\n\\tif(root==NULL) return {0,0};\\n\\tauto left=valueSum(root->left);\\n\\tauto right=valueSum(root->right);\\n\\tint sum=(left.first+right.first+root->val);\\n\\tint n=(left.second+right.second+1);        \\n\\tcount+=((sum/n)==root->val);\\n\\treturn {sum,n};\\n}\\nint averageOfSubtree(TreeNode* root) {\\n\\tauto p1=valueSum(root);\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint count=0;\\npair<int,int> valueSum(TreeNode* root){\\n\\tif(root==NULL) return {0,0};\\n\\tauto left=valueSum(root->left);\\n\\tauto right=valueSum(root->right);\\n\\tint sum=(left.first+right.first+root->val);\\n\\tint n=(left.second+right.second+1);        \\n\\tcount+=((sum/n)==root->val);\\n\\treturn {sum,n};\\n}\\nint averageOfSubtree(TreeNode* root) {\\n\\tauto p1=valueSum(root);\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018060,
                "title": "python-dfs-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n\\t\\t\\n        def traverse(node):\\n            nonlocal result\\n            \\n            if not node:\\n                return 0, 0\\n            \\n            left_sum, left_count = traverse(node.left)\\n            right_sum, right_count = traverse(node.right)\\n            \\n            s = node.val + left_sum + right_sum\\n            c = 1 + left_count + right_count\\n            \\n            if s // c == node.val:\\n                result += 1\\n            \\n            return s, c\\n        \\n        traverse(root)\\n        \\n        return result\\n            \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        result = 0\\n\\t\\t\\n        def traverse(node):\\n            nonlocal result\\n            \\n            if not node:\\n                return 0, 0\\n            \\n            left_sum, left_count = traverse(node.left)\\n            right_sum, right_count = traverse(node.right)\\n            \\n            s = node.val + left_sum + right_sum\\n            c = 1 + left_count + right_count\\n            \\n            if s // c == node.val:\\n                result += 1\\n            \\n            return s, c\\n        \\n        traverse(root)\\n        \\n        return result\\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2017837,
                "title": "cpp-short-and-simple-o-n-time-dfs-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> func(TreeNode* root,int &ans){\\n        if(!root)return {0,0};\\n        auto p1=func(root->left,ans);\\n        auto p2=func(root->right,ans);\\n        int avg=(root->val+p1.first+p2.first)/(p1.second+p2.second+1);\\n        if(avg==root->val)ans++;\\n        return {root->val+p1.first+p2.first,p1.second+p2.second+1};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> func(TreeNode* root,int &ans){\\n        if(!root)return {0,0};\\n        auto p1=func(root->left,ans);\\n        auto p2=func(root->right,ans);\\n        int avg=(root->val+p1.first+p2.first)/(p1.second+p2.second+1);\\n        if(avg==root->val)ans++;\\n        return {root->val+p1.first+p2.first,p1.second+p2.second+1};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017942,
                "title": "java-postorder-suffix-sum",
                "content": "* Do **postorder** traversal (Left - Right - Root)\\n* `root` will contain sum of its subtree + `root.val`\\n* If root original val == `root.val / count`, then increment answer\\n* return pair of **root.val** (sum of its subtree) and **count** (number of nodes in it subtree)\\n```\\nclass Solution {\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        ans = 0;\\n        solve(root, 0);\\n        return ans;\\n    }\\n\\n    int ans = 0;\\n\\n    private int[] solve(TreeNode root, int count) {\\n        if (root == null) {\\n            return new int[] { 0, 0 };\\n        }\\n        int left[] = solve(root.left, count);\\n        int right[] = solve(root.right, count);\\n        int temp = root.val;\\n        root.val += (left[0] + right[0]);\\n        count = (left[1] + right[1]) + 1;\\n        if (temp == (root.val / count))  ans++; \\n        return new int[] { root.val, count };\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        ans = 0;\\n        solve(root, 0);\\n        return ans;\\n    }\\n\\n    int ans = 0;\\n\\n    private int[] solve(TreeNode root, int count) {\\n        if (root == null) {\\n            return new int[] { 0, 0 };\\n        }\\n        int left[] = solve(root.left, count);\\n        int right[] = solve(root.right, count);\\n        int temp = root.val;\\n        root.val += (left[0] + right[0]);\\n        count = (left[1] + right[1]) + 1;\\n        if (temp == (root.val / count))  ans++; \\n        return new int[] { root.val, count };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018587,
                "title": "javascript-clean-solution",
                "content": "```\\nvar averageOfSubtree = function (root) {\\n    let ans = 0;\\n    function dfs(node) {\\n        if (node === null) return [0, 0];\\n        let [leftSum, leftCount] = dfs(node.left);\\n        let [rightSum, rightCount] = dfs(node.right);\\n\\n        let sum = leftSum + rightSum + node.val;\\n        let count = leftCount + rightCount + 1;\\n        if (Math.floor(sum / count) === node.val) ans++;\\n        return [sum, count];\\n    }\\n\\n    dfs(root);\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar averageOfSubtree = function (root) {\\n    let ans = 0;\\n    function dfs(node) {\\n        if (node === null) return [0, 0];\\n        let [leftSum, leftCount] = dfs(node.left);\\n        let [rightSum, rightCount] = dfs(node.right);\\n\\n        let sum = leftSum + rightSum + node.val;\\n        let count = leftCount + rightCount + 1;\\n        if (Math.floor(sum / count) === node.val) ans++;\\n        return [sum, count];\\n    }\\n\\n    dfs(root);\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018581,
                "title": "c-solution-simple-recursion",
                "content": "\\n```\\nclass Solution {\\npublic:    \\n    int count(TreeNode* root)\\n    {\\n        //if tree is empty\\n        if(root==NULL) return 0;\\n        \\n        //if tree has single node/leaf node\\n        if(root->left==NULL && root->right==NULL) return 1;    \\n        \\n        return 1 + count(root->left) + count(root->right);\\n    }\\n    \\n    \\n    int sum(TreeNode* root)\\n    {\\n        //if tree is empty\\n        if(root==NULL) return 0;\\n        \\n        return root->val + sum(root->left) +  sum(root->right);\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        //if tree is empty\\n        if(root==NULL) return 0;\\n        \\n        //if tree has single node/leaf node\\n        if(root->left==NULL && root->right==NULL) return 1;\\n        \\n        //return value or Boolean condition(1 or 0) + rec(root->left) + rec(root->right)\\n        return (sum(root)/count(root)==root->val) + averageOfSubtree(root->left) + averageOfSubtree(root->right);\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int count(TreeNode* root)\\n    {\\n        //if tree is empty\\n        if(root==NULL) return 0;\\n        \\n        //if tree has single node/leaf node\\n        if(root->left==NULL && root->right==NULL) return 1;    \\n        \\n        return 1 + count(root->left) + count(root->right);\\n    }\\n    \\n    \\n    int sum(TreeNode* root)\\n    {\\n        //if tree is empty\\n        if(root==NULL) return 0;\\n        \\n        return root->val + sum(root->left) +  sum(root->right);\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        //if tree is empty\\n        if(root==NULL) return 0;\\n        \\n        //if tree has single node/leaf node\\n        if(root->left==NULL && root->right==NULL) return 1;\\n        \\n        //return value or Boolean condition(1 or 0) + rec(root->left) + rec(root->right)\\n        return (sum(root)/count(root)==root->val) + averageOfSubtree(root->left) + averageOfSubtree(root->right);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018193,
                "title": "python-dfs-preorder-traversal",
                "content": "Our goal is to iterate each and every node by using any kind of traversal technique (preorder, postorder, inorder). (I have used preorder here), \\n\\nFor every node, we calculate the sum of its subtree nodes and keep a variable to store the no. of nodes, \\nso that we can calculate average by total sum/ total nodes.\\n\\nIf our average is equal to value of the root, we increment the count.\\n\\nVideo explanation: https://youtu.be/y_3TlyzIRbk\\n\\nCode:\\n\\n\\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        \\n        def calculate_average(root):\\n            if root:\\n                self.summ+=root.val\\n                self.nodecount+=1\\n                calculate_average(root.left)\\n                calculate_average(root.right)\\n        \\n        \\n        def calculate_for_each_node(root):\\n            if root:\\n                self.summ = 0\\n                self.nodecount = 0\\n                calculate_average(root)\\n                if ((self.summ)//(self.nodecount)) == root.val:\\n                    self.count+=1 \\n                calculate_for_each_node(root.left)\\n                calculate_for_each_node(root.right)\\n                \\n                \\n        self.count = 0\\n        calculate_for_each_node(root)       \\n        return self.count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        \\n        def calculate_average(root):\\n            if root:\\n                self.summ+=root.val\\n                self.nodecount+=1\\n                calculate_average(root.left)\\n                calculate_average(root.right)\\n        \\n        \\n        def calculate_for_each_node(root):\\n            if root:\\n                self.summ = 0\\n                self.nodecount = 0\\n                calculate_average(root)\\n                if ((self.summ)//(self.nodecount)) == root.val:\\n                    self.count+=1 \\n                calculate_for_each_node(root.left)\\n                calculate_for_each_node(root.right)\\n                \\n                \\n        self.count = 0\\n        calculate_for_each_node(root)       \\n        return self.count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017874,
                "title": "o-n-time-c-java",
                "content": "Get **Sum** and **Count** from left and right subtree **Upfront for O(N) total time**.\\n# C++\\n    int averageOfSubtree(TreeNode* root) {\\n        int cnt=0;\\n        helper(root,cnt);\\n        return cnt;\\n    }\\n    \\n    pair<int,int> helper(TreeNode* root,int &cnt){\\n        if(!root) return {0,0};\\n        pair<int,int> l= helper(root->left,cnt);   //sum and count of nodes in left subtree with single call\\n        pair<int,int> r= helper(root->right,cnt);  //sum and count of nodes in right subtree with single call\\n        int sum= l.first+r.first+root->val;        //compute new sum \\n        int count= l.second+r.second+1;            //compute new count of nodes\\n        if(sum/count==root->val) cnt++;            //check if it is candidate or not\\n        return {sum,count}; \\n    }\\n\\t\\n# Java\\n    //user defined data-type\\n\\tclass data{\\n        int first,second;\\n        data(int x,int y){  first=x;  second=y; }\\n    }\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        int[] cnt= new int[1];\\n        helper(root,cnt);\\n        return cnt[0];\\n    }\\n    \\n    data helper(TreeNode root,int[] cnt){\\n        if(root==null) return new data(0,0);\\n        data l= helper(root.left,cnt);   //sum and count of nodes in left subtree with single call\\n        data r= helper(root.right,cnt);  //sum and count of nodes in right subtree with single call\\n        int sum= l.first+r.first+root.val;   //get sum of subtree\\n        int count= l.second+r.second+1;      //get count of nodes in this subtree\\n        if(sum/count==root.val) cnt[0]++;    //check if it is candidate or not\\n        return new data(sum,count); \\n    }\\n\\t\\n**Time** - O(N)\\n**Space** - O(1) ignoring Recursion space",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "Get **Sum** and **Count** from left and right subtree **Upfront for O(N) total time**.\\n# C++\\n    int averageOfSubtree(TreeNode* root) {\\n        int cnt=0;\\n        helper(root,cnt);\\n        return cnt;\\n    }\\n    \\n    pair<int,int> helper(TreeNode* root,int &cnt){\\n        if(!root) return {0,0};\\n        pair<int,int> l= helper(root->left,cnt);   //sum and count of nodes in left subtree with single call\\n        pair<int,int> r= helper(root->right,cnt);  //sum and count of nodes in right subtree with single call\\n        int sum= l.first+r.first+root->val;        //compute new sum \\n        int count= l.second+r.second+1;            //compute new count of nodes\\n        if(sum/count==root->val) cnt++;            //check if it is candidate or not\\n        return {sum,count}; \\n    }\\n\\t\\n# Java\\n    //user defined data-type\\n\\tclass data{\\n        int first,second;\\n        data(int x,int y){  first=x;  second=y; }\\n    }\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        int[] cnt= new int[1];\\n        helper(root,cnt);\\n        return cnt[0];\\n    }\\n    \\n    data helper(TreeNode root,int[] cnt){\\n        if(root==null) return new data(0,0);\\n        data l= helper(root.left,cnt);   //sum and count of nodes in left subtree with single call\\n        data r= helper(root.right,cnt);  //sum and count of nodes in right subtree with single call\\n        int sum= l.first+r.first+root.val;   //get sum of subtree\\n        int count= l.second+r.second+1;      //get count of nodes in this subtree\\n        if(sum/count==root.val) cnt[0]++;    //check if it is candidate or not\\n        return new data(sum,count); \\n    }\\n\\t\\n**Time** - O(N)\\n**Space** - O(1) ignoring Recursion space",
                "codeTag": "Java"
            },
            {
                "id": 3363316,
                "title": "use-pair",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n\\n    pair<int, int> f(TreeNode* root) {\\n        if(!root)return {0, 0};\\n        auto lsum = f(root->left);\\n        auto rsum = f(root->right);\\n\\n        int sum = (lsum.first + rsum.first + root->val);\\n        int c = lsum.second + rsum.second + 1;\\n        int avg = sum / c;\\n        if(avg == root->val)cnt++;\\n        return {sum, c};\\n    }\\n\\n    int averageOfSubtree(TreeNode* root) {\\n        f(root);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n\\n    pair<int, int> f(TreeNode* root) {\\n        if(!root)return {0, 0};\\n        auto lsum = f(root->left);\\n        auto rsum = f(root->right);\\n\\n        int sum = (lsum.first + rsum.first + root->val);\\n        int c = lsum.second + rsum.second + 1;\\n        int avg = sum / c;\\n        if(avg == root->val)cnt++;\\n        return {sum, c};\\n    }\\n\\n    int averageOfSubtree(TreeNode* root) {\\n        f(root);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018431,
                "title": "java-readable-code-100-00-faster",
                "content": "```\\nclass Solution {\\n    \\n    public class NodeInfo{\\n        int sum;\\n        int size;\\n        public NodeInfo(int sum , int size){\\n            this.sum = sum;\\n            this.size = size;\\n        }\\n    }\\n    \\n    int ans = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) \\n    {\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    public NodeInfo dfs(TreeNode node){\\n        if(node == null)\\n            return new NodeInfo(0,0);\\n        \\n        NodeInfo left = dfs(node.left);\\n        NodeInfo right = dfs(node.right);\\n        \\n        int currentSum = node.val + left.sum + right.sum;\\n        int currentSize = 1 + left.size + right.size;\\n        \\n        if(currentSum / currentSize == node.val)\\n            ans++;\\n        \\n        return new NodeInfo(currentSum , currentSize);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class NodeInfo{\\n        int sum;\\n        int size;\\n        public NodeInfo(int sum , int size){\\n            this.sum = sum;\\n            this.size = size;\\n        }\\n    }\\n    \\n    int ans = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) \\n    {\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    public NodeInfo dfs(TreeNode node){\\n        if(node == null)\\n            return new NodeInfo(0,0);\\n        \\n        NodeInfo left = dfs(node.left);\\n        NodeInfo right = dfs(node.right);\\n        \\n        int currentSum = node.val + left.sum + right.sum;\\n        int currentSize = 1 + left.size + right.size;\\n        \\n        if(currentSum / currentSize == node.val)\\n            ans++;\\n        \\n        return new NodeInfo(currentSum , currentSize);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674508,
                "title": "c-dfs-easy-approach",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int s(TreeNode* root,int &v){\\n        if(root==NULL)return 0;\\n        v++;\\n        return root->val + s(root->right,v) + s(root->left,v);\\n    }\\n    int ct=0;\\n    int averageOfSubtree(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        int v=0;\\n        int x = s(root,v);\\n        if(root->val == (x/v))ct++;\\n        averageOfSubtree(root->right);\\n        averageOfSubtree(root->left);\\n        return ct;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/b31c622c-b9dc-4241-abd2-48060e7f92a1_1687541613.9294002.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int s(TreeNode* root,int &v){\\n        if(root==NULL)return 0;\\n        v++;\\n        return root->val + s(root->right,v) + s(root->left,v);\\n    }\\n    int ct=0;\\n    int averageOfSubtree(TreeNode* root) {\\n        if(root==NULL)return 0;\\n        int v=0;\\n        int x = s(root,v);\\n        if(root->val == (x/v))ct++;\\n        averageOfSubtree(root->right);\\n        averageOfSubtree(root->left);\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019246,
                "title": "easy-c-o-n-fast",
                "content": "**The naive approach is to iterate over the tree using any traversal and checking for each node the average of subtree.**\\n\\n**The Optimal approach will be bottom up approach and returning count and sum of nodes in subtree using pair c++**\\n\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> iterate(TreeNode *root,int &ans)\\n    {\\n        if(!root)return {0,0};\\n\\t\\t\\n        pair<int,int>left=iterate(root->left,ans);\\n        pair<int,int>right=iterate(root->right,ans);\\n\\t\\t\\n        int count=left.first+right.first+1;\\n        int sum=left.second+right.second+root->val;\\n\\t\\t\\n        if(root->val==sum/count){\\n            ans=ans+1;\\n        }\\n\\t\\t\\n        return {count,sum};\\n\\n    }\\n\\t\\n    int averageOfSubtree(TreeNode* root) \\n\\t{\\n        int ans=0; \\n        iterate(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> iterate(TreeNode *root,int &ans)\\n    {\\n        if(!root)return {0,0};\\n\\t\\t\\n        pair<int,int>left=iterate(root->left,ans);\\n        pair<int,int>right=iterate(root->right,ans);\\n\\t\\t\\n        int count=left.first+right.first+1;\\n        int sum=left.second+right.second+root->val;\\n\\t\\t\\n        if(root->val==sum/count){\\n            ans=ans+1;\\n        }\\n\\t\\t\\n        return {count,sum};\\n\\n    }\\n\\t\\n    int averageOfSubtree(TreeNode* root) \\n\\t{\\n        int ans=0; \\n        iterate(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018987,
                "title": "c-easy-solution-explanation-with-comments-using-bfs",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    // this function will calculate the sum for the current element subtree\\n    void average(TreeNode* node, int& ans)\\n    {\\n        int sum=0;                       // it will calculate the subtree sum for current node#\\n        int cnt=0;                       // it will store the number of values that are present in subtree\\n        \\n        // pushing current node to the queue\\n        queue<TreeNode*> q;\\n        q.push(node);\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            \\n            // iterating over q size\\n            for(int i=0;i<s;i++)\\n            {\\n                // extracting the queue\\'s front element\\n                TreeNode* nod = q.front();\\n                q.pop();\\n                \\n                // after taking the elemets , add that val into the sum and incraese the value\\'s cnt by 1\\n                sum += nod->val;\\n                cnt++;\\n                \\n                // check for current node left and right\\n                if(nod->left)\\n                    q.push(nod->left);\\n                if(nod->right)\\n                    q.push(nod->right);\\n            }\\n        }\\n        if(sum/cnt==node->val)\\n            ans++;\\n    }\\n    \\n    // this function will make sure to iterate all the nodes\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        // we have to traversal all the given tree and for each node we have to traverse it\\'s own subtree\\n        // so we can use both BFS & DFS here \\n        // so we will solve this problem by using BFS \\n        \\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            // extracting the size of the queue\\n            int s = q.size();\\n            \\n            // now check for the elements that avaliable in queue\\n            for(int i=0;i<s;i++)\\n            {\\n                // taking out the front element\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                // call the function for current node and calculate its avg\\n                average(node,ans);\\n                \\n                // after counting the avg\\'s chech there is left or right available \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // this function will calculate the sum for the current element subtree\\n    void average(TreeNode* node, int& ans)\\n    {\\n        int sum=0;                       // it will calculate the subtree sum for current node#\\n        int cnt=0;                       // it will store the number of values that are present in subtree\\n        \\n        // pushing current node to the queue\\n        queue<TreeNode*> q;\\n        q.push(node);\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            \\n            // iterating over q size\\n            for(int i=0;i<s;i++)\\n            {\\n                // extracting the queue\\'s front element\\n                TreeNode* nod = q.front();\\n                q.pop();\\n                \\n                // after taking the elemets , add that val into the sum and incraese the value\\'s cnt by 1\\n                sum += nod->val;\\n                cnt++;\\n                \\n                // check for current node left and right\\n                if(nod->left)\\n                    q.push(nod->left);\\n                if(nod->right)\\n                    q.push(nod->right);\\n            }\\n        }\\n        if(sum/cnt==node->val)\\n            ans++;\\n    }\\n    \\n    // this function will make sure to iterate all the nodes\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        // we have to traversal all the given tree and for each node we have to traverse it\\'s own subtree\\n        // so we can use both BFS & DFS here \\n        // so we will solve this problem by using BFS \\n        \\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            // extracting the size of the queue\\n            int s = q.size();\\n            \\n            // now check for the elements that avaliable in queue\\n            for(int i=0;i<s;i++)\\n            {\\n                // taking out the front element\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                // call the function for current node and calculate its avg\\n                average(node,ans);\\n                \\n                // after counting the avg\\'s chech there is left or right available \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017794,
                "title": "python3-post-order-dfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        def fn(node): \\n            nonlocal ans\\n            if not node: return 0, 0 \\n            ls, ln = fn(node.left)\\n            rs, rn = fn(node.right)\\n            s = node.val + ls + rs\\n            n = 1 + ln + rn\\n            if s//n == node.val: ans += 1\\n            return s, n\\n        \\n        ans = 0 \\n        fn(root)\\n        return ans \\n```\\n\\nAdded iterative implementation \\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        mp = {None: (0, 0)}\\n        node, stack = root, []\\n        prev = None\\n        while node or stack: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack[-1]\\n                if node.right and node.right != prev: node = node.right\\n                else: \\n                    stack.pop()\\n                    ls, lc = mp[node.left]\\n                    rs, rc = mp[node.right]\\n                    sm, cnt = ls + node.val + rs, lc + 1 + rc\\n                    mp[node] = (sm, cnt)\\n                    if sm//cnt == node.val: ans += 1\\n                    prev = node \\n                    node = None\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        def fn(node): \\n            nonlocal ans\\n            if not node: return 0, 0 \\n            ls, ln = fn(node.left)\\n            rs, rn = fn(node.right)\\n            s = node.val + ls + rs\\n            n = 1 + ln + rn\\n            if s//n == node.val: ans += 1\\n            return s, n\\n        \\n        ans = 0 \\n        fn(root)\\n        return ans \\n```\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        mp = {None: (0, 0)}\\n        node, stack = root, []\\n        prev = None\\n        while node or stack: \\n            if node: \\n                stack.append(node)\\n                node = node.left \\n            else: \\n                node = stack[-1]\\n                if node.right and node.right != prev: node = node.right\\n                else: \\n                    stack.pop()\\n                    ls, lc = mp[node.left]\\n                    rs, rc = mp[node.right]\\n                    sm, cnt = ls + node.val + rs, lc + 1 + rc\\n                    mp[node] = (sm, cnt)\\n                    if sm//cnt == node.val: ans += 1\\n                    prev = node \\n                    node = None\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017756,
                "title": "post-order-traversal-c-recursion-o-n",
                "content": "Each call will return sum of it\\'s right and left subtree along with its node count, then the root will will handle the remaining calculations.\\n```\\nclass Solution {\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int count = 0;\\n        pot(root,count);\\n        return count;\\n    }\\n    \\n    vector<int> pot(TreeNode* root, int &count){\\n        if(root == NULL) return {0,0};\\n        \\n        vector<int> av1 = pot(root->left,count);\\n        vector<int> av2 = pot(root->right,count);\\n        \\n        if((av1[0]+av2[0]+root->val)/(av1[1]+av2[1]+1) == root->val)\\n            count++;\\n        \\n        return {av1[0]+av2[0]+root->val,av1[1]+av2[1]+1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int count = 0;\\n        pot(root,count);\\n        return count;\\n    }\\n    \\n    vector<int> pot(TreeNode* root, int &count){\\n        if(root == NULL) return {0,0};\\n        \\n        vector<int> av1 = pot(root->left,count);\\n        vector<int> av2 = pot(root->right,count);\\n        \\n        if((av1[0]+av2[0]+root->val)/(av1[1]+av2[1]+1) == root->val)\\n            count++;\\n        \\n        return {av1[0]+av2[0]+root->val,av1[1]+av2[1]+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105609,
                "title": "explanation-which-you-are-searching-for",
                "content": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.cnt=0\\n        def dfs(node):\\n            if not node:return [0,0]\\n            \\n            x,cntx=dfs(node.left)\\n            y,cnty=dfs(node.right)\\n            if node.val==(x+y+node.val)//(cntx+cnty+1):\\n                self.cnt+=1\\n            return [node.val+x+y,cntx+cnty+1]\\n            \\n        dfs(root)\\n        return self.cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.cnt=0\\n        def dfs(node):\\n            if not node:return [0,0]\\n            \\n            x,cntx=dfs(node.left)\\n            y,cnty=dfs(node.right)\\n            if node.val==(x+y+node.val)//(cntx+cnty+1):\\n                self.cnt+=1\\n            return [node.val+x+y,cntx+cnty+1]\\n            \\n        dfs(root)\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018451,
                "title": "c-dfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n       \\n        pair<int,int> path(TreeNode* root)\\n\\t\\t//this function is used to calculate the sum of subtree and the number of nodes in subtree\\n        {\\n            if(!root)return {0,0};\\n            pair<int,int> lh=path(root->left);\\n            pair<int,int> rh=path(root->right);\\n            return {root->val+lh.first+rh.first,1+lh.second+rh.second};\\n            //root->val+lh.first+rh.first --->sum of subtree\\n            //1+lh.second+rh.second---->number of nodes;\\n        }\\n    \\n        void inorder(TreeNode* root,int &cnt){\\n            if(!root)return;\\n            pair<int,int> x=path(root);//pair of sum and count of nodes\\n            if(root->val==(x.first/x.second))//(x.first/x.second)-->calculating avg\\n            {cnt++;}//if avg==root->val then increment the count\\n            inorder(root->left,cnt);\\n            inorder(root->right,cnt);\\n            return;\\n            \\n        }\\n    \\n        int averageOfSubtree(TreeNode* root) {\\n        if(!root)return 0;\\n        int cnt=0;\\n        inorder(root,cnt);\\n            return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       \\n        pair<int,int> path(TreeNode* root)\\n\\t\\t//this function is used to calculate the sum of subtree and the number of nodes in subtree\\n        {\\n            if(!root)return {0,0};\\n            pair<int,int> lh=path(root->left);\\n            pair<int,int> rh=path(root->right);\\n            return {root->val+lh.first+rh.first,1+lh.second+rh.second};\\n            //root->val+lh.first+rh.first --->sum of subtree\\n            //1+lh.second+rh.second---->number of nodes;\\n        }\\n    \\n        void inorder(TreeNode* root,int &cnt){\\n            if(!root)return;\\n            pair<int,int> x=path(root);//pair of sum and count of nodes\\n            if(root->val==(x.first/x.second))//(x.first/x.second)-->calculating avg\\n            {cnt++;}//if avg==root->val then increment the count\\n            inorder(root->left,cnt);\\n            inorder(root->right,cnt);\\n            return;\\n            \\n        }\\n    \\n        int averageOfSubtree(TreeNode* root) {\\n        if(!root)return 0;\\n        int cnt=0;\\n        inorder(root,cnt);\\n            return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017957,
                "title": "c-2-approaches-bfs-dfs-easy-to-understand",
                "content": "**Please upvote it you find this solution helpful:)**\\n**Approach-1: Use Level Order traversal / BFS**\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    //use level order traversal and check whether average of the subtree is equal to the node value, if it is increase the res by 1.\\n    void help(TreeNode* node, int &res)\\n    {\\n        int sum=0, cnt=0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* nod = q.front();\\n                q.pop();\\n                sum += nod->val;\\n                cnt++;\\n                if(nod->left) q.push(nod->left);\\n                if(nod->right) q.push(nod->right);\\n            }\\n        }\\n        if(sum/cnt == node->val) //if average equals to the node value increase res by 1.\\n            res++;\\n    }\\n    \\n    //use level order traversal and calling the function help for each node\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        int res=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                help(node, res);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        return res;       \\n    }\\n};\\n```\\n\\n**Approach-2: Use DFS**\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(TreeNode* node, int &cnt) \\n    {\\n        if (!node)\\n            return {0, 0};\\n\\n        auto left_subtree = dfs(node->left, cnt);\\n        auto right_subtree = dfs(node->right, cnt);\\n\\n        int sum = left_subtree.first + right_subtree.first + node->val;\\n        int count = 1 + left_subtree.second + right_subtree.second;\\n\\n        if(sum/count == node->val)\\n            cnt++; //if average equals to node value, increase the count\\n\\n        return {sum, count};\\n    }\\n\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        int cnt=0;\\n        dfs(root, cnt);\\n        return cnt;\\n    }     \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //use level order traversal and check whether average of the subtree is equal to the node value, if it is increase the res by 1.\\n    void help(TreeNode* node, int &res)\\n    {\\n        int sum=0, cnt=0;\\n        \\n        queue<TreeNode*> q;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* nod = q.front();\\n                q.pop();\\n                sum += nod->val;\\n                cnt++;\\n                if(nod->left) q.push(nod->left);\\n                if(nod->right) q.push(nod->right);\\n            }\\n        }\\n        if(sum/cnt == node->val) //if average equals to the node value increase res by 1.\\n            res++;\\n    }\\n    \\n    //use level order traversal and calling the function help for each node\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        int res=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                help(node, res);\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n        return res;       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(TreeNode* node, int &cnt) \\n    {\\n        if (!node)\\n            return {0, 0};\\n\\n        auto left_subtree = dfs(node->left, cnt);\\n        auto right_subtree = dfs(node->right, cnt);\\n\\n        int sum = left_subtree.first + right_subtree.first + node->val;\\n        int count = 1 + left_subtree.second + right_subtree.second;\\n\\n        if(sum/count == node->val)\\n            cnt++; //if average equals to node value, increase the count\\n\\n        return {sum, count};\\n    }\\n\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        int cnt=0;\\n        dfs(root, cnt);\\n        return cnt;\\n    }     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205202,
                "title": "o-n-solution-simple-easy-to-understand-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root, int &cnt){\\n        if(root==NULL){\\n            return make_pair(0,0);\\n        }\\n        pair<int,int> left = solve(root->left, cnt);\\n        pair<int,int> right = solve(root->right, cnt);\\n        \\n        pair<int,int>ans;\\n        ans.first = root->val + left.first + right.first;\\n        ans.second = left.second + right.second + 1;\\n        int num = ans.first / ans.second;\\n        if(num==root->val) cnt++;\\n        return ans;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int cnt=0;\\n        pair<int,int>p = solve(root,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root, int &cnt){\\n        if(root==NULL){\\n            return make_pair(0,0);\\n        }\\n        pair<int,int> left = solve(root->left, cnt);\\n        pair<int,int> right = solve(root->right, cnt);\\n        \\n        pair<int,int>ans;\\n        ans.first = root->val + left.first + right.first;\\n        ans.second = left.second + right.second + 1;\\n        int num = ans.first / ans.second;\\n        if(num==root->val) cnt++;\\n        return ans;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int cnt=0;\\n        pair<int,int>p = solve(root,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097437,
                "title": "java-c-100-solution-using-depth-first-search-count-nodes-equal-to-average-of-subtree",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    pair<int,int> solve(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return {0,0};\\n        auto left = solve(root->left);\\n        auto right = solve(root->right);\\n        int sum = left.first + right.first + root->val;\\n        int nodes = left.second + right.second + 1;\\n        if(sum/nodes == root->val)\\n            cnt++;\\n        return {sum,nodes};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return cnt;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int cnt = 0;\\n    int[] solve(TreeNode root)\\n    {\\n        if(root == null)\\n            return new int[]{0,0};\\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        int sum = left[0] + right[0] + root.val;\\n        int nodes = left[1] + right[1] + 1;\\n        if(sum/nodes == root.val)\\n            cnt++;\\n        return new  int[]{sum, nodes};\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        solve(root);\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    pair<int,int> solve(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return {0,0};\\n        auto left = solve(root->left);\\n        auto right = solve(root->right);\\n        int sum = left.first + right.first + root->val;\\n        int nodes = left.second + right.second + 1;\\n        if(sum/nodes == root->val)\\n            cnt++;\\n        return {sum,nodes};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return cnt;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int cnt = 0;\\n    int[] solve(TreeNode root)\\n    {\\n        if(root == null)\\n            return new int[]{0,0};\\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        int sum = left[0] + right[0] + root.val;\\n        int nodes = left[1] + right[1] + 1;\\n        if(sum/nodes == root.val)\\n            cnt++;\\n        return new  int[]{sum, nodes};\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        solve(root);\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033016,
                "title": "easiest-java-solution-ever-brute-force-approach-and-better-pair-approach-2-approaches",
                "content": "# Intuition\\n- **The Brute Approach is very Intuitive.**\\n- **For every node we get the sum of it\\'s left substree + sum of it\\'s right subtree + value of itself divided by total numbe rof nodes.**\\n\\n# Approach\\n**Brute Force Approach**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static int numOfNodes(TreeNode node){\\n\\n        if(node == null){\\n            return 0;\\n        }\\n\\n        return numOfNodes(node.left) + numOfNodes(node.right) + 1;\\n\\n    }\\n\\n    public static int getSum(TreeNode node){\\n\\n        if(node == null){\\n            return 0;\\n        }\\n\\n        return getSum(node.left) + getSum(node.right) + node.val;\\n\\n    }\\n\\n    public static void helper(TreeNode node){\\n\\n        if(node == null){\\n            return;\\n        }\\n\\n        int sum = getSum(node.left) + getSum(node.right) + node.val;\\n        int n = numOfNodes(node.left) + numOfNodes(node.right) + 1;\\n\\n        if(n!=0 && (node.val == (sum/n))){\\n            ans++;\\n        }\\n\\n        helper(node.left);\\n        helper(node.right);\\n\\n    }\\n\\n    public static int ans;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n\\n        ans = 0;\\n        \\n        helper(root);\\n\\n        return ans;\\n\\n    }\\n\\n}\\n```\\n\\n\\n# Intuition\\n- **Creating a new class Pair.**\\n- **This will allow us to get the sum of the substree as well as the number of nodes simultaneously.**\\n\\n# Approach\\n**Better Pair Approach**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Pair{\\n\\n    int sum;\\n\\n    int nodes;\\n\\n    Pair(int sum, int nodes){\\n        this.sum = sum;\\n        this.nodes = nodes;\\n    }\\n\\n}\\n\\nclass Solution {\\n\\n    public static Pair helper(TreeNode node){\\n\\n        if(node == null){\\n            return new Pair(0, 0);\\n        }\\n\\n        Pair left = helper(node.left);\\n\\n        Pair right = helper(node.right);\\n\\n        int totalSum = left.sum + right.sum + node.val;\\n\\n        int num = left.nodes + right.nodes + 1;\\n\\n        if(num != 0 && (totalSum/num) == node.val){\\n            ans++;\\n        }\\n\\n        return new Pair(totalSum, num);\\n\\n    }\\n\\n    public static int ans;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        \\n        ans = 0;\\n\\n        helper(root);\\n\\n        return ans;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static int numOfNodes(TreeNode node){\\n\\n        if(node == null){\\n            return 0;\\n        }\\n\\n        return numOfNodes(node.left) + numOfNodes(node.right) + 1;\\n\\n    }\\n\\n    public static int getSum(TreeNode node){\\n\\n        if(node == null){\\n            return 0;\\n        }\\n\\n        return getSum(node.left) + getSum(node.right) + node.val;\\n\\n    }\\n\\n    public static void helper(TreeNode node){\\n\\n        if(node == null){\\n            return;\\n        }\\n\\n        int sum = getSum(node.left) + getSum(node.right) + node.val;\\n        int n = numOfNodes(node.left) + numOfNodes(node.right) + 1;\\n\\n        if(n!=0 && (node.val == (sum/n))){\\n            ans++;\\n        }\\n\\n        helper(node.left);\\n        helper(node.right);\\n\\n    }\\n\\n    public static int ans;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n\\n        ans = 0;\\n        \\n        helper(root);\\n\\n        return ans;\\n\\n    }\\n\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Pair{\\n\\n    int sum;\\n\\n    int nodes;\\n\\n    Pair(int sum, int nodes){\\n        this.sum = sum;\\n        this.nodes = nodes;\\n    }\\n\\n}\\n\\nclass Solution {\\n\\n    public static Pair helper(TreeNode node){\\n\\n        if(node == null){\\n            return new Pair(0, 0);\\n        }\\n\\n        Pair left = helper(node.left);\\n\\n        Pair right = helper(node.right);\\n\\n        int totalSum = left.sum + right.sum + node.val;\\n\\n        int num = left.nodes + right.nodes + 1;\\n\\n        if(num != 0 && (totalSum/num) == node.val){\\n            ans++;\\n        }\\n\\n        return new Pair(totalSum, num);\\n\\n    }\\n\\n    public static int ans;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        \\n        ans = 0;\\n\\n        helper(root);\\n\\n        return ans;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906543,
                "title": "bhagvadgeeta-solution-which-is-a-raambaan-panacea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI dont have any particular thoughts about this problem\\nIt just came from my heart and eternal source of Lord krishna\\nGod is carrying my chariot\\nYou know who I am.\\nMost importantly you know who he is.\\nDo you understand?\\nGOD IS CARRYING MY CHARIOT\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is that \\nFirst you traverse til the leftmost node and then rightmost node\\nand return the sum of subnodes in 0th index and number of nodes in 1st index\\n\\nWhen you completed both the traversals you add the 0th index of both the list and find the average of the sum of subnodes per number of subnodes which should be equal to the value of the root\\nif it does then we will increment the counter (ctr) \\nAt the end we will return the counter(ctr)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.ctr=0\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def recur(root):\\n            if root is None:\\n                return [0,0]\\n            list1=recur(root.left)\\n            list2=recur(root.right)\\n            sub_node_sum=list1[0]+list2[0]+root.val\\n            sub_node_count=list1[1]+list2[1]+1\\n            if((int(sub_node_sum/sub_node_count))==root.val):\\n                print(root.val)\\n                self.ctr+=1\\n            return [sub_node_sum,sub_node_count]\\n        recur(root)\\n        return self.ctr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.ctr=0\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def recur(root):\\n            if root is None:\\n                return [0,0]\\n            list1=recur(root.left)\\n            list2=recur(root.right)\\n            sub_node_sum=list1[0]+list2[0]+root.val\\n            sub_node_count=list1[1]+list2[1]+1\\n            if((int(sub_node_sum/sub_node_count))==root.val):\\n                print(root.val)\\n                self.ctr+=1\\n            return [sub_node_sum,sub_node_count]\\n        recur(root)\\n        return self.ctr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020880,
                "title": "decorated-python",
                "content": "Using a decorator that turns a function evaluating a single node into a function that sums that evaluation over the whole subtree, and uses caching for overall O(n) time.\\n```\\ndef subtree(f):\\n    @cache\\n    def g(root):\\n        return f(root) + g(root.left) + g(root.right) if root else 0\\n    return g\\n\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n\\n        @subtree\\n        def sum(root):\\n            return root.val\\n\\n        @subtree\\n        def number(root):\\n            return 1\\n\\n        @subtree\\n        def equals_average(root):\\n            return root.val == sum(root) // number(root)\\n        \\n        return equals_average(root)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef subtree(f):\\n    @cache\\n    def g(root):\\n        return f(root) + g(root.left) + g(root.right) if root else 0\\n    return g\\n\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n\\n        @subtree\\n        def sum(root):\\n            return root.val\\n\\n        @subtree\\n        def number(root):\\n            return 1\\n\\n        @subtree\\n        def equals_average(root):\\n            return root.val == sum(root) // number(root)\\n        \\n        return equals_average(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018752,
                "title": "java-clean-dfs",
                "content": "```java\\nprivate int averageEqualsValueNodes = 0;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        sumAndCount(root);\\n        return averageEqualsValueNodes;\\n    }\\n\\n\\n    private SumAndCount sumAndCount(TreeNode node) {\\n        if (node == null) return new SumAndCount(0, 0);\\n\\n        SumAndCount left = sumAndCount(node.left);\\n        SumAndCount right = sumAndCount(node.right);\\n\\n        int sum = left.sum() + right.sum() + node.val;\\n        int count = left.count() + right.count() + 1;\\n\\n        if (sum / count == node.val)\\n            averageEqualsValueNodes++;\\n\\n        return new SumAndCount(sum, count);\\n    }\\n\\n    private record SumAndCount(int sum, int count) {}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nprivate int averageEqualsValueNodes = 0;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        sumAndCount(root);\\n        return averageEqualsValueNodes;\\n    }\\n\\n\\n    private SumAndCount sumAndCount(TreeNode node) {\\n        if (node == null) return new SumAndCount(0, 0);\\n\\n        SumAndCount left = sumAndCount(node.left);\\n        SumAndCount right = sumAndCount(node.right);\\n\\n        int sum = left.sum() + right.sum() + node.val;\\n        int count = left.count() + right.count() + 1;\\n\\n        if (sum / count == node.val)\\n            averageEqualsValueNodes++;\\n\\n        return new SumAndCount(sum, count);\\n    }\\n\\n    private record SumAndCount(int sum, int count) {}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017873,
                "title": "java-using-helper-function",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\tstatic int count = 0;\\n\\n\\tpublic static int averageOfSubtree(TreeNode root) {\\n\\t\\tcount = 0;\\n\\t\\thelper(root);\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic static int helper(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint left = helper(root.left);\\n\\t\\tint right = helper(root.right);\\n\\n\\t\\tint sum = root.val;\\n\\t\\tif (root.left != null) {\\n\\t\\t\\tsum += root.left.val;\\n\\t\\t}\\n\\t\\tif (root.right != null) {\\n\\t\\t\\tsum += root.right.val;\\n\\t\\t}\\n\\t\\tif (sum / (left + right + 1) == root.val) {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\troot.val = sum;\\n\\t\\treturn left + right + 1;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\tstatic int count = 0;\\n\\n\\tpublic static int averageOfSubtree(TreeNode root) {\\n\\t\\tcount = 0;\\n\\t\\thelper(root);\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic static int helper(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint left = helper(root.left);\\n\\t\\tint right = helper(root.right);\\n\\n\\t\\tint sum = root.val;\\n\\t\\tif (root.left != null) {\\n\\t\\t\\tsum += root.left.val;\\n\\t\\t}\\n\\t\\tif (root.right != null) {\\n\\t\\t\\tsum += root.right.val;\\n\\t\\t}\\n\\t\\tif (sum / (left + right + 1) == root.val) {\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\troot.val = sum;\\n\\t\\treturn left + right + 1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017709,
                "title": "easy-c-using-pair-reuse-the-sum-and-count-of-subtrees",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int ans = 0;\\n    \\n    pair<int,int> getAverageSubTree(TreeNode* root, int currSum, int count)\\n    {\\n        if(root == NULL) return {0,0};\\n        \\n        pair<int,int> left = getAverageSubTree(root -> left, currSum, count);\\n        pair<int,int> right = getAverageSubTree(root -> right, currSum, count);\\n        \\n        currSum += root -> val + left.first + right.first;\\n        count += left.second + right.second + 1;\\n        \\n        if((currSum/count) == root -> val) ans++;\\n        return {currSum, count};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) \\n    {\\n         getAverageSubTree(root, 0, 0);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int ans = 0;\\n    \\n    pair<int,int> getAverageSubTree(TreeNode* root, int currSum, int count)\\n    {\\n        if(root == NULL) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3910153,
                "title": "simplest-dfs-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    int getKey;\\n    int getValue;\\n    public Pair(int a,int b){\\n        this.getKey=a;\\n        this.getValue=b;\\n    }\\n}\\nclass Solution {\\n    int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        solve(root);\\n        return count;\\n    }\\n    public Pair solve(TreeNode root){\\n        if(root==null) {\\n            Pair p = new Pair(0,0);\\n            return p;\\n        }\\n        Pair left1 = solve(root.left);\\n        Pair right1 = solve(root.right);\\n        int n= left1.getValue+right1.getValue+1;\\n        int sum=root.val+left1.getKey+right1.getKey;\\n        int avg = sum/n;\\n        if(avg==root.val) count++;\\n        return new Pair(sum,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    int getKey;\\n    int getValue;\\n    public Pair(int a,int b){\\n        this.getKey=a;\\n        this.getValue=b;\\n    }\\n}\\nclass Solution {\\n    int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        solve(root);\\n        return count;\\n    }\\n    public Pair solve(TreeNode root){\\n        if(root==null) {\\n            Pair p = new Pair(0,0);\\n            return p;\\n        }\\n        Pair left1 = solve(root.left);\\n        Pair right1 = solve(root.right);\\n        int n= left1.getValue+right1.getValue+1;\\n        int sum=root.val+left1.getKey+right1.getKey;\\n        int avg = sum/n;\\n        if(avg==root.val) count++;\\n        return new Pair(sum,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041152,
                "title": "java-easy-approach-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Pair{\\n    int f,s;\\n    Pair(int f, int s){\\n        this.f = f;\\n        this.s = s;\\n    }\\n}\\n\\nclass Solution {\\n\\n    int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        count = 0;\\n        isAverageBT(root);\\n        return count;\\n    }\\n\\n    public Pair isAverageBT(TreeNode root){\\n        if(root==null){\\n            return new Pair(0,0);\\n        }\\n        Pair left = isAverageBT(root.left);\\n        Pair right = isAverageBT(root.right);\\n        int sum = root.val + left.f + right.f;\\n        int number = 1 + left.s + right.s;\\n        if(sum/number == root.val){\\n            count++;\\n        } \\n        return new Pair(sum,number);\\n    }\\n\\n}\\n```\\n\\nPlease Upvote the solution.",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Pair{\\n    int f,s;\\n    Pair(int f, int s){\\n        this.f = f;\\n        this.s = s;\\n    }\\n}\\n\\nclass Solution {\\n\\n    int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        count = 0;\\n        isAverageBT(root);\\n        return count;\\n    }\\n\\n    public Pair isAverageBT(TreeNode root){\\n        if(root==null){\\n            return new Pair(0,0);\\n        }\\n        Pair left = isAverageBT(root.left);\\n        Pair right = isAverageBT(root.right);\\n        int sum = root.val + left.f + right.f;\\n        int number = 1 + left.s + right.s;\\n        if(sum/number == root.val){\\n            count++;\\n        } \\n        return new Pair(sum,number);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997532,
                "title": "c-dfs-easiest-approach-no-extra-computation",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    int dfs(TreeNode* root, int &sum, int &count){\\n        if(root == NULL){\\n            sum = 0, count = 0;\\n            return 0;\\n        }\\n\\n        int sum1 = 0, count1 = 0, sum2 = 0, count2 = 0;\\n        int ans1 = dfs(root->left, sum1, count1);\\n        int ans2 = dfs(root->right, sum2, count2);\\n\\n        int ans = ans1+ans2;\\n        sum = sum1+sum2+root->val;\\n        count = count1+count2+1;\\n        int avg = (sum/(double)count);\\n\\n        if(avg == root->val)\\n            ans++;\\n\\n        return ans;\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int sum, count;\\n\\n        return dfs(root, sum, count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    int dfs(TreeNode* root, int &sum, int &count){\\n        if(root == NULL){\\n            sum = 0, count = 0;\\n            return 0;\\n        }\\n\\n        int sum1 = 0, count1 = 0, sum2 = 0, count2 = 0;\\n        int ans1 = dfs(root->left, sum1, count1);\\n        int ans2 = dfs(root->right, sum2, count2);\\n\\n        int ans = ans1+ans2;\\n        sum = sum1+sum2+root->val;\\n        count = count1+count2+1;\\n        int avg = (sum/(double)count);\\n\\n        if(avg == root->val)\\n            ans++;\\n\\n        return ans;\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int sum, count;\\n\\n        return dfs(root, sum, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689509,
                "title": "java-1ms-beats-99-runtime-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn general, average of values = (sum of all values / total no of values).\\nIn order to find the average of subtree for a certain TreeNode, we need to find the sum of all nodes in its left subtree, sum of all nodes in its right subtree, and the total number of nodes in both left and right subtree. This information will be enough to check the condition for the given node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create a function that returns an array with 2 integers in it.\\nint[ ] arr = {`sum of all nodes in subtree`, `number of nodes in subtree`}\\nFor every TreeNode we also check the condition whether the value of the node is equal to the average of the values in its subtree. If the condition is true, we increment the `ans` variable, which was initialised to 0.\\n\\n# Code\\n```\\nclass Solution {\\n    int ans = 0;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        subtreeSum(root);\\n        return ans;\\n    }\\n\\n    // function to calculate sum of all nodes in subtree\\n    private int[] subtreeSum(TreeNode root){\\n        // base condition\\n        if(root == null)\\n            return new int[]{0, 0};\\n\\n        // for leaf nodes\\n        if(root.left == null && root.right == null){ \\n            ans++;\\n            return new int[]{root.val, 1};\\n        }\\n\\n        int[] leftSum = subtreeSum(root.left);\\n        int[] rightSum = subtreeSum(root.right);\\n        if((leftSum[0] + rightSum[0] + root.val) / (leftSum[1] + rightSum[1] + 1) == root.val)\\n            ans++;\\n\\n        return new int[] {(leftSum[0] + rightSum[0] + root.val), (leftSum[1] + rightSum[1] + 1)};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        subtreeSum(root);\\n        return ans;\\n    }\\n\\n    // function to calculate sum of all nodes in subtree\\n    private int[] subtreeSum(TreeNode root){\\n        // base condition\\n        if(root == null)\\n            return new int[]{0, 0};\\n\\n        // for leaf nodes\\n        if(root.left == null && root.right == null){ \\n            ans++;\\n            return new int[]{root.val, 1};\\n        }\\n\\n        int[] leftSum = subtreeSum(root.left);\\n        int[] rightSum = subtreeSum(root.right);\\n        if((leftSum[0] + rightSum[0] + root.val) / (leftSum[1] + rightSum[1] + 1) == root.val)\\n            ans++;\\n\\n        return new int[] {(leftSum[0] + rightSum[0] + root.val), (leftSum[1] + rightSum[1] + 1)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288478,
                "title": "c-o-n-easy-and-fast",
                "content": "\\n\\n\\nclass Solution {\\n\\npublic:\\n\\n    int ans =0;\\n\\t\\n    pair<int,int> solve(TreeNode* root){\\n\\t\\n        if(!root) return {0,0};\\n\\t\\t\\n        auto lh = solve(root->left);\\n        auto rh = solve(root->right);\\n        \\n        int sum = lh.first +  rh.first + root->val;\\n        int n = lh.second + rh.second + 1;\\n        \\n        if(sum / n == root->val)ans++;\\n        \\n        return {sum,n};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int ans =0;\\n\\t\\n    pair<int,int> solve(TreeNode* root){\\n\\t\\n        if(!root) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2106015,
                "title": "postorder-dfs-python",
                "content": "```\\nclass Solution(object):\\n    def averageOfSubtree(self, root):\\n        self.count = 0\\n        def dfs(root):\\n            if root is None: return 0, 0 \\n            \\n            leftSum, leftCount = dfs(root.left)\\n            rightSum, rightCount = dfs(root.right)\\n            \\n            current_sum = root.val + leftSum + rightSum\\n            current_count = 1 + leftCount + rightCount\\n            \\n            if root.val == current_sum/current_count:\\n                self.count += 1\\n            return current_sum, current_count\\n        dfs(root)\\n        return self.count\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def averageOfSubtree(self, root):\\n        self.count = 0\\n        def dfs(root):\\n            if root is None: return 0, 0 \\n            \\n            leftSum, leftCount = dfs(root.left)\\n            rightSum, rightCount = dfs(root.right)\\n            \\n            current_sum = root.val + leftSum + rightSum\\n            current_count = 1 + leftCount + rightCount\\n            \\n            if root.val == current_sum/current_count:\\n                self.count += 1\\n            return current_sum, current_count\\n        dfs(root)\\n        return self.count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018674,
                "title": "javascript-dfs-post-order-recursive-solution-and-bfs-iterative-solution",
                "content": "Here I would like to share the DFS approach first, BFS approach (*not so elegant but intuitive and can be considered as brute force*) will follow after. Please upvote if it is helpful :)\\nThe idea is to traverse through the tree and do something at the node (via a ```traverse(node)``` function + checking the average of the subtree). Hence carrying out a post-order depth-first traversal seems to be logically here (as we have to traverse all before comparing the average).\\nHowever, we need to specifying the output of the recursive function, as we need to use the sum of all nodes in the subtree (left and right each) as well as the nodes count, we have to return it for further usage. Finally using closures concept, we can put this ```traverse(node)``` function inside our main function and set ```count``` to track whenever a node (and its subtree) satisfy the required condition.\\nBelow is the implementation of DFS approach.\\n```\\nvar averageOfSubtree = function(root) {\\n    let count = 0;\\n    \\n    function traverse(node) {\\n        if (node === null) {\\n            return [0, 0];\\n        }\\n\\n        let [sumLeft, countLeft] = traverse(node.left);\\n        let [sumRight, countRight] = traverse(node.right);\\n\\n        if (Math.floor((sumLeft + sumRight + node.val) / (countLeft + countRight + 1)) === node.val) {\\n            count++;\\n        }\\n\\n        return [sumLeft + sumRight + node.val, countLeft + countRight + 1];\\n    }\\n    \\n    traverse(root);\\n    \\n    return count;\\n};\\n```\\n\\nFor BFS, it is intuitive that we want to traverse through the tree, going to all nodes level by level, at each node, we will determine if it is a ```valid``` node satisfying the required condition. \\nHence, we can use BFS two times, one is to just traverse the tree, and the other is to traverse the subtree of the node being traversed and checking the condition.\\nBelow is the BFS approach implementation. This algorithm is not optimal but it offers another perspective and fun view for dealing with trees :)\\n```\\nvar averageOfSubtree = function(root) {\\n    let count = 0;\\n\\t\\n    let queue = [];\\n    if (root === null) return 0;\\n    queue.push(root);\\n    while (queue.length) {\\n        let node = queue.shift();\\n        if (isValid(node)) {\\n            count++;\\n        }\\n        if (node.left !== null) {\\n            queue.push(node.left);\\n        }\\n        if (node.right !== null) {\\n            queue.push(node.right);\\n        }\\n    }\\n    return count;\\n};\\n\\nvar isValid = function(node) {\\n    let sum = 0;\\n    let count = 0;\\n\\t\\n\\tlet queue = [];\\n    if (node === null) return false;\\n    queue.push(node);\\n    \\n    while (queue.length) {\\n        let node = queue.shift();\\n        sum += node.val;\\n        count++;\\n        if (node.left !== null) {\\n            queue.push(node.left);\\n        }\\n        if (node.right !== null) {\\n            queue.push(node.right);\\n        }\\n    }\\n    if (Math.floor(sum / count) === node.val) return true;\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```traverse(node)```\n```traverse(node)```\n```count```\n```\\nvar averageOfSubtree = function(root) {\\n    let count = 0;\\n    \\n    function traverse(node) {\\n        if (node === null) {\\n            return [0, 0];\\n        }\\n\\n        let [sumLeft, countLeft] = traverse(node.left);\\n        let [sumRight, countRight] = traverse(node.right);\\n\\n        if (Math.floor((sumLeft + sumRight + node.val) / (countLeft + countRight + 1)) === node.val) {\\n            count++;\\n        }\\n\\n        return [sumLeft + sumRight + node.val, countLeft + countRight + 1];\\n    }\\n    \\n    traverse(root);\\n    \\n    return count;\\n};\\n```\n```valid```\n```\\nvar averageOfSubtree = function(root) {\\n    let count = 0;\\n\\t\\n    let queue = [];\\n    if (root === null) return 0;\\n    queue.push(root);\\n    while (queue.length) {\\n        let node = queue.shift();\\n        if (isValid(node)) {\\n            count++;\\n        }\\n        if (node.left !== null) {\\n            queue.push(node.left);\\n        }\\n        if (node.right !== null) {\\n            queue.push(node.right);\\n        }\\n    }\\n    return count;\\n};\\n\\nvar isValid = function(node) {\\n    let sum = 0;\\n    let count = 0;\\n\\t\\n\\tlet queue = [];\\n    if (node === null) return false;\\n    queue.push(node);\\n    \\n    while (queue.length) {\\n        let node = queue.shift();\\n        sum += node.val;\\n        count++;\\n        if (node.left !== null) {\\n            queue.push(node.left);\\n        }\\n        if (node.right !== null) {\\n            queue.push(node.right);\\n        }\\n    }\\n    if (Math.floor(sum / count) === node.val) return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018514,
                "title": "python-dfs-no-global-variable",
                "content": "for each node, we want his left and right subtree sum, number of nodes in that subtree, and number of \"good\" nodes in that subtree. once we have that information, we can calculate the result for the root and simply return it.\\nour result is the sum of good nodes on left, good nodes on right, and +1 if the current node is also a good node.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node): \\n            if not node:\\n                return 0, 0, 0\\n            \\n            #give me sum, count and num of good nodes in the subtree\\n            ls, lc, rl = dfs(node.left) \\n            rs, rc, rr = dfs(node.right)\\n            \\n            res = 0\\n            if (ls + rs + node.val) // (lc + rc + 1) == node.val:\\n                res += 1\\n\\t\\t\\t\\t\\n            return ls + rs + node.val, lc + rc + 1, res + rl + rr\\n        return dfs(root)[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node): \\n            if not node:\\n                return 0, 0, 0\\n            \\n            #give me sum, count and num of good nodes in the subtree\\n            ls, lc, rl = dfs(node.left) \\n            rs, rc, rr = dfs(node.right)\\n            \\n            res = 0\\n            if (ls + rs + node.val) // (lc + rc + 1) == node.val:\\n                res += 1\\n\\t\\t\\t\\t\\n            return ls + rs + node.val, lc + rc + 1, res + rl + rr\\n        return dfs(root)[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017985,
                "title": "python-straightforward-recursion",
                "content": "```\\nclass Solution:\\n    \\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.count = 0\\n        def recursion(node):\\n            if node == None:\\n                return [0, 0]\\n            val = node.val\\n            left = recursion(node.left)\\n            right = recursion(node.right)\\n            left_val, left_num = left[0], left[1]\\n            right_val, right_num = right[0], right[1]\\n            val += left_val\\n            val += right_val\\n            if node.val == val // (left_num + right_num + 1):\\n                self.count += 1\\n            return [val, left_num + right_num + 1]\\n        recursion(root)\\n        return self.count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.count = 0\\n        def recursion(node):\\n            if node == None:\\n                return [0, 0]\\n            val = node.val\\n            left = recursion(node.left)\\n            right = recursion(node.right)\\n            left_val, left_num = left[0], left[1]\\n            right_val, right_num = right[0], right[1]\\n            val += left_val\\n            val += right_val\\n            if node.val == val // (left_num + right_num + 1):\\n                self.count += 1\\n            return [val, left_num + right_num + 1]\\n        recursion(root)\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017754,
                "title": "c-solution-using-pair-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int>find(TreeNode*root,int&sum)\\n    {\\n        if(root==NULL)\\n        {\\n            //first sum of subtree\\n            // second size of subtree\\n            return {0,0};\\n        }\\n        auto left=find(root->left,sum);\\n        auto right=find(root->right,sum);\\n        int sum_of_subtree=root->val+left.first+right.first;\\n        int size_of_subtree=1+left.second+right.second;\\n        if((sum_of_subtree)/(size_of_subtree)==root->val)\\n        {\\n            sum++;\\n        }\\n        return {sum_of_subtree,size_of_subtree};\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        int sum=0;\\n        find(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int>find(TreeNode*root,int&sum)\\n    {\\n        if(root==NULL)\\n        {\\n            //first sum of subtree\\n            // second size of subtree\\n            return {0,0};\\n        }\\n        auto left=find(root->left,sum);\\n        auto right=find(root->right,sum);\\n        int sum_of_subtree=root->val+left.first+right.first;\\n        int size_of_subtree=1+left.second+right.second;\\n        if((sum_of_subtree)/(size_of_subtree)==root->val)\\n        {\\n            sum++;\\n        }\\n        return {sum_of_subtree,size_of_subtree};\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        int sum=0;\\n        find(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017429,
                "title": "simple-solution-using-pair-int-int",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint x=0;\\n    pair<int,int> count(TreeNode* root){\\n        if(root==NULL){return {0,0};}\\n        pair<int,int> lans=count(root->left);\\n        pair<int,int> rans=count(root->right);\\n        pair<int,int> ans;\\n        ans.first=lans.first+rans.first+root->val;\\n        ans.second=lans.second+rans.second+1;\\n        if(ans.first/ans.second==root->val){x++;}\\n        return ans;\\n    }\\n\\n    int averageOfSubtree(TreeNode* root) {\\n        count(root);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint x=0;\\n    pair<int,int> count(TreeNode* root){\\n        if(root==NULL){return {0,0};}\\n        pair<int,int> lans=count(root->left);\\n        pair<int,int> rans=count(root->right);\\n        pair<int,int> ans;\\n        ans.first=lans.first+rans.first+root->val;\\n        ans.second=lans.second+rans.second+1;\\n        if(ans.first/ans.second==root->val){x++;}\\n        return ans;\\n    }\\n\\n    int averageOfSubtree(TreeNode* root) {\\n        count(root);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765892,
                "title": "3-solutions-brute-optimal-self-explanatory-intuitive-comments-c-clean-code",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey There! It\\'s Easy Just Take A Look At The Code And Comments Within It! You\\'ll Get It.\\n\\nStill Got Doubts! Feel Free To Comment, I Will Definitely Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- All Accepted\\n\\n# Complexity\\n- Time complexity: Mentioned in the code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Mentioned in the code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nApproach 1 :- Using Brute Force (DFS)\\n```\\n// Require to store the resultant count of the nodes\\nint nodesCount = 0;\\n\\n// #1 Method helper\\nvoid calculateCountAndSum(Node* root, int& tCount, int& tSum) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return;\\n\\n    tCount += 1; tSum += root->val;\\n\\n    calculateCountAndSum(root->left, tCount, tSum);\\n    calculateCountAndSum(root->right, tCount, tSum);\\n}\\n\\n// #1 Method to find the specified number of nodes using dfs - O(N*N) & O(H)\\nint averageOfSubtree(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    int tCount = 0; // Require to store the count of nodes\\n    int tSum   = 0; // Require to store the sum of nodes\\n\\n    // Calculate the count and the sum for the current node\\n    calculateCountAndSum(root, tCount, tSum);\\n\\n    // If the average of the subtree is equal to the current node \\n    if(tSum / tCount == root->val)\\n        nodesCount++;\\n\\n    averageOfSubtree(root->left);\\n    averageOfSubtree(root->right);\\n\\n    return nodesCount;\\n}\\n```\\nApproach 2 :- Using DFS With Map\\n```\\n// #2 Method helper\\nint buildFreqMap(Node* root, unordered_map<Node*, int>& freq) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    // Recursively find the count of nodes from the left and the right subtree\\n    int lCount = buildFreqMap(root->left, freq);   \\n    int rCount = buildFreqMap(root->right, freq);\\n\\n    // Map the count of nodes and than return it\\n    return freq[root] = lCount + 1 + rCount;\\n}\\n\\n// #2 Method helper\\nint checkForAverage(Node* root, unordered_map<Node*, int>& freq, int& nodesCount) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    // Recursively find the sum of nodes from the left and the right subtree\\n    int lSum = checkForAverage(root->left, freq, nodesCount);\\n    int rSum = checkForAverage(root->right, freq, nodesCount);\\n\\n    // Calculate and store the total sum\\n    int tSum = lSum + root->val + rSum;\\n\\n    // If the average of the subtree is equal to the current node \\n    if(tSum / freq[root] == root->val)\\n        nodesCount++;\\n\\n    return tSum;\\n}\\n\\n// #2 Method to find the specified number of nodes using dfs with map - O(N) & O(N)\\nint averageOfSubtree(Node* root) {\\n    // Require to map the nodes with their descendants count\\n    unordered_map<Node*, int> freq;\\n\\n    buildFreqMap(root, freq);\\n\\n    // Require to store the resultant count of the nodes\\n    int nodesCount = 0;\\n\\n    checkForAverage(root, freq, nodesCount);\\n\\n    return nodesCount;\\n}\\n```\\nApproach 3 :- Using DFS Only\\n```\\n// #3 Method helper\\nvector<int> checkForAverage(Node* root, vector<int>& tmp, int& nodesCount) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return {0, 0};\\n\\n    // Recursively find and store the sum and the count of the descendants from both the subtrees\\n    vector<int> vec1 = checkForAverage(root->left, tmp, nodesCount);\\n    vector<int> vec2 = checkForAverage(root->right, tmp, nodesCount);\\n\\n    // Calculate and store the total sum and the total count of the nodes\\n    int tSum   = vec1[0] + root->val + vec2[0];\\n    int tCount = vec1[1] + 1 + vec2[1];\\n\\n    // If the average of the subtree is equal to the current node \\n    if(tSum / tCount == root->val)\\n        nodesCount++;\\n\\n    // Return the total sum and the total count of the nodes\\n    return {tSum, tCount};\\n}\\n\\n// #3 Method to find the specified number of nodes using dfs - O(N) & O(H)\\nint averageOfSubtree(Node* root) {\\n    // Require to store the sum and the count of the descendants respectively \\n    vector<int> tmp(2, 0);\\n\\n    // Require to store the resultant count of the nodes\\n    int nodesCount = 0; \\n\\n    checkForAverage(root, tmp, nodesCount);\\n\\n    return nodesCount;\\n}\\n// Note: Can also use : pair<int, int> : instead of vector\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Require to store the resultant count of the nodes\\nint nodesCount = 0;\\n\\n// #1 Method helper\\nvoid calculateCountAndSum(Node* root, int& tCount, int& tSum) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return;\\n\\n    tCount += 1; tSum += root->val;\\n\\n    calculateCountAndSum(root->left, tCount, tSum);\\n    calculateCountAndSum(root->right, tCount, tSum);\\n}\\n\\n// #1 Method to find the specified number of nodes using dfs - O(N*N) & O(H)\\nint averageOfSubtree(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    int tCount = 0; // Require to store the count of nodes\\n    int tSum   = 0; // Require to store the sum of nodes\\n\\n    // Calculate the count and the sum for the current node\\n    calculateCountAndSum(root, tCount, tSum);\\n\\n    // If the average of the subtree is equal to the current node \\n    if(tSum / tCount == root->val)\\n        nodesCount++;\\n\\n    averageOfSubtree(root->left);\\n    averageOfSubtree(root->right);\\n\\n    return nodesCount;\\n}\\n```\n```\\n// #2 Method helper\\nint buildFreqMap(Node* root, unordered_map<Node*, int>& freq) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    // Recursively find the count of nodes from the left and the right subtree\\n    int lCount = buildFreqMap(root->left, freq);   \\n    int rCount = buildFreqMap(root->right, freq);\\n\\n    // Map the count of nodes and than return it\\n    return freq[root] = lCount + 1 + rCount;\\n}\\n\\n// #2 Method helper\\nint checkForAverage(Node* root, unordered_map<Node*, int>& freq, int& nodesCount) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    // Recursively find the sum of nodes from the left and the right subtree\\n    int lSum = checkForAverage(root->left, freq, nodesCount);\\n    int rSum = checkForAverage(root->right, freq, nodesCount);\\n\\n    // Calculate and store the total sum\\n    int tSum = lSum + root->val + rSum;\\n\\n    // If the average of the subtree is equal to the current node \\n    if(tSum / freq[root] == root->val)\\n        nodesCount++;\\n\\n    return tSum;\\n}\\n\\n// #2 Method to find the specified number of nodes using dfs with map - O(N) & O(N)\\nint averageOfSubtree(Node* root) {\\n    // Require to map the nodes with their descendants count\\n    unordered_map<Node*, int> freq;\\n\\n    buildFreqMap(root, freq);\\n\\n    // Require to store the resultant count of the nodes\\n    int nodesCount = 0;\\n\\n    checkForAverage(root, freq, nodesCount);\\n\\n    return nodesCount;\\n}\\n```\n```\\n// #3 Method helper\\nvector<int> checkForAverage(Node* root, vector<int>& tmp, int& nodesCount) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return {0, 0};\\n\\n    // Recursively find and store the sum and the count of the descendants from both the subtrees\\n    vector<int> vec1 = checkForAverage(root->left, tmp, nodesCount);\\n    vector<int> vec2 = checkForAverage(root->right, tmp, nodesCount);\\n\\n    // Calculate and store the total sum and the total count of the nodes\\n    int tSum   = vec1[0] + root->val + vec2[0];\\n    int tCount = vec1[1] + 1 + vec2[1];\\n\\n    // If the average of the subtree is equal to the current node \\n    if(tSum / tCount == root->val)\\n        nodesCount++;\\n\\n    // Return the total sum and the total count of the nodes\\n    return {tSum, tCount};\\n}\\n\\n// #3 Method to find the specified number of nodes using dfs - O(N) & O(H)\\nint averageOfSubtree(Node* root) {\\n    // Require to store the sum and the count of the descendants respectively \\n    vector<int> tmp(2, 0);\\n\\n    // Require to store the resultant count of the nodes\\n    int nodesCount = 0; \\n\\n    checkForAverage(root, tmp, nodesCount);\\n\\n    return nodesCount;\\n}\\n// Note: Can also use : pair<int, int> : instead of vector\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3437334,
                "title": "brute-force-approach-java",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum=0;\\n    int count =0;\\n    int level=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        average(root);\\n        return level;\\n    }\\n    public void preorder(TreeNode root)\\n    {\\n        if(root==null)\\n        return ;\\n\\n        sum += root.val;\\n        count++;\\n\\n\\n        preorder(root.left);\\n        preorder(root.right);\\n    }\\n    public void average(TreeNode root)\\n    {\\n         if(root==null)\\n         return;\\n\\n         preorder(root);\\n         if(sum/count==root.val)\\n         level++;\\n\\n         sum=0;\\n        count=0;\\n\\n         average(root.left);\\n         average(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum=0;\\n    int count =0;\\n    int level=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        average(root);\\n        return level;\\n    }\\n    public void preorder(TreeNode root)\\n    {\\n        if(root==null)\\n        return ;\\n\\n        sum += root.val;\\n        count++;\\n\\n\\n        preorder(root.left);\\n        preorder(root.right);\\n    }\\n    public void average(TreeNode root)\\n    {\\n         if(root==null)\\n         return;\\n\\n         preorder(root);\\n         if(sum/count==root.val)\\n         level++;\\n\\n         sum=0;\\n        count=0;\\n\\n         average(root.left);\\n         average(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177546,
                "title": "c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int ans=0;\\n    pair<int,int> solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n        {\\n            pair<int,int>p;\\n            \\n            return {0,0};\\n        }\\n        \\n        pair<int,int> left=solve(root->left);\\n        pair<int,int> right=solve(root->right);\\n        \\n        int s=left.first+right.first+root->val;\\n        int a=left.second+right.second+1;\\n        \\n        if(round(s/a)==root->val)\\n        {\\n            ans++;\\n        }\\n        \\n        pair<int,int>p1;\\n        \\n        \\n        return {s,a};\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        solve(root);\\n        \\n        return ans;\\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int ans=0;\\n    pair<int,int> solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n        {\\n            pair<int,int>p;\\n            \\n            return {0,0};\\n        }\\n        \\n        pair<int,int> left=solve(root->left);\\n        pair<int,int> right=solve(root->right);\\n        \\n        int s=left.first+right.first+root->val;\\n        int a=left.second+right.second+1;\\n        \\n        if(round(s/a)==root->val)\\n        {\\n            ans++;\\n        }\\n        \\n        pair<int,int>p1;\\n        \\n        \\n        return {s,a};\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        solve(root);\\n        \\n        return ans;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063445,
                "title": "easy-soln-well-explained",
                "content": "# Please upvote if you found helpful\\uD83D\\uDE0A\\n***#ReviseWithArsh #6Companies30Days Challenge 2023\\nChellenge Company 3: Adobe\\nQ9. Count  nodes equal to average of Subtree***\\n\\n# Complexity\\n- Time complexity:O(n)\\n- Space complexity:O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int dfs(TreeNode* root, int &sum, int &count){\\n    // Base case: if root is null, return 0 for both sum and count\\n    if(root==NULL){\\n            sum=0,count=0;\\n            return 0;\\n    }\\n    // Initialize variables to store sum and count of left and right subtrees\\n    int sum1 = 0, count1 = 0, sum2 = 0, count2 = 0;\\n    int ans1 = dfs(root->left, sum1, count1); // Recursively calculate sum and count of left subtree\\n    int ans2 = dfs(root->right, sum2, count2); // Recursively calculate sum and count of right subtree\\n\\n    int ans = ans1+ans2; // Initialize ans as the total number of subtrees with equal average\\n    sum = sum1+sum2+root->val; // Calculate sum of current subtree\\n    count = count1+count2+1; // Calculate count of current subtree\\n    int avg = (sum/(double)count); // Calculate average of current subtree\\n\\n    // Check if current root\\'s value is equal to the average of the subtree\\n    if(avg == root->val)\\n        ans++;\\n\\n    return ans;\\n}\\n\\n    public:\\n        int averageOfSubtree(TreeNode* root) {\\n        int sum, count;\\n        return dfs(root, sum, count);\\n        }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int dfs(TreeNode* root, int &sum, int &count){\\n    // Base case: if root is null, return 0 for both sum and count\\n    if(root==NULL){\\n            sum=0,count=0;\\n            return 0;\\n    }\\n    // Initialize variables to store sum and count of left and right subtrees\\n    int sum1 = 0, count1 = 0, sum2 = 0, count2 = 0;\\n    int ans1 = dfs(root->left, sum1, count1); // Recursively calculate sum and count of left subtree\\n    int ans2 = dfs(root->right, sum2, count2); // Recursively calculate sum and count of right subtree\\n\\n    int ans = ans1+ans2; // Initialize ans as the total number of subtrees with equal average\\n    sum = sum1+sum2+root->val; // Calculate sum of current subtree\\n    count = count1+count2+1; // Calculate count of current subtree\\n    int avg = (sum/(double)count); // Calculate average of current subtree\\n\\n    // Check if current root\\'s value is equal to the average of the subtree\\n    if(avg == root->val)\\n        ans++;\\n\\n    return ans;\\n}\\n\\n    public:\\n        int averageOfSubtree(TreeNode* root) {\\n        int sum, count;\\n        return dfs(root, sum, count);\\n        }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053827,
                "title": "easy-approach-using-pair-dfs-o-n",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    pair<int,int>solve(TreeNode*root){\\n        if(root==NULL)return {0,0};\\n\\n        pair<int,int>left=solve(root->left);\\n        int left_sum=left.first;\\n        int left_size=left.second;\\n\\n        pair<int,int>right=solve(root->right);\\n        int right_sum=right.first;\\n        int right_size=right.second;\\n\\n        int sum=left_sum+right_sum+root->val;\\n        if(sum/(1+left_size+right_size)==root->val){\\n            ans++;\\n        }\\n        return {sum,(1+left_size+right_size)};\\n\\n\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    pair<int,int>solve(TreeNode*root){\\n        if(root==NULL)return {0,0};\\n\\n        pair<int,int>left=solve(root->left);\\n        int left_sum=left.first;\\n        int left_size=left.second;\\n\\n        pair<int,int>right=solve(root->right);\\n        int right_sum=right.first;\\n        int right_size=right.second;\\n\\n        int sum=left_sum+right_sum+root->val;\\n        if(sum/(1+left_size+right_size)==root->val){\\n            ans++;\\n        }\\n        return {sum,(1+left_size+right_size)};\\n\\n\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902985,
                "title": "simple-clean-code-with-description-c",
                "content": "\\n# Approach\\n We want to use dfs to traverse the tree and while traversing we want to know the average at the each node and when we backtrack we will use the averages of already calculated averages of the children of the node and use them to calculate the average of the root node.\\n\\n We carry forward the values sum and the no of nodes with the help of value pair to help us calulate the average and to compare the average is equal to value of the root. If it is equal we increase the count by 1.\\n\\n# Complexity\\n- Time complexity:\\n Time complexity of this approach(D.F.S) is O(n) where n is the number of nodes in the given tree.\\n\\n    Upvote if you find it helpful.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint count = 0;\\n    int averageOfSubtree(TreeNode* root) {\\n        average(root);\\n        return count;\\n    }\\nint avg,sum,no_of_nodes;\\n   pair<int,int> average(TreeNode* root){\\n       if (root == NULL){\\n           return make_pair(0, 0);\\n       }\\n        pair<int,int> left = average(root->left);\\n        pair<int,int> right = average(root->right);\\n        sum = (left.first + right.first + root->val);\\n        no_of_nodes = (left.second + right.second + 1);\\n        avg = sum/(no_of_nodes);\\n        if (root->val == avg){\\n            count++;\\n       }\\n       return make_pair(sum, no_of_nodes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint count = 0;\\n    int averageOfSubtree(TreeNode* root) {\\n        average(root);\\n        return count;\\n    }\\nint avg,sum,no_of_nodes;\\n   pair<int,int> average(TreeNode* root){\\n       if (root == NULL){\\n           return make_pair(0, 0);\\n       }\\n        pair<int,int> left = average(root->left);\\n        pair<int,int> right = average(root->right);\\n        sum = (left.first + right.first + root->val);\\n        no_of_nodes = (left.second + right.second + 1);\\n        avg = sum/(no_of_nodes);\\n        if (root->val == avg){\\n            count++;\\n       }\\n       return make_pair(sum, no_of_nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717774,
                "title": "c-easy-to-understand-solution",
                "content": "**I have made 2 extra function apart from main fxn**\\n1. to get the average of an subtree by passing root\\n2. to get the number of nodes who have avg value = their root value \\n```\\n\\nclass Solution {\\npublic:\\n    void avgof(TreeNode* root, int &sum, int &cnt){\\n        if(root == NULL) {\\n            return;\\n        }\\n        sum = sum + root->val;\\n        cnt++;\\n        avgof(root->left, sum, cnt);\\n        avgof(root->right, sum, cnt);\\n        \\n    }\\n    void task(TreeNode* root,int &sum, int &cnt, int &ans ){\\n        if(root == NULL)return;\\n        sum =0;\\n        cnt =0;;\\n        avgof(root, sum, cnt);\\n        int k = sum / cnt;\\n        if(k == root->val)ans++; \\n        task(root->left, sum, cnt, ans);\\n        task(root->right, sum, cnt, ans);\\n\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int sum, cnt, ans = 0;\\n        task(root, sum, cnt, ans);\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    void avgof(TreeNode* root, int &sum, int &cnt){\\n        if(root == NULL) {\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2672436,
                "title": "simple-recursion",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count=0;\\n    int countnodes(TreeNode* root)\\n    {\\n        if(!root)\\n            return 0;\\n        else{\\n             return countnodes(root->left)+countnodes(root->right)+1;\\n        }\\n    }\\n    int findSum(TreeNode* root)\\n    {\\n        if(!root)\\n            return 0;\\n        return findSum(root->left)+findSum(root->right)+root->val;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        if(!root)   \\n            return 0;\\n        if((findSum(root)/countnodes(root))==root->val)\\n             count++;\\n         averageOfSubtree(root->left);\\n         averageOfSubtree(root->right);\\n           \\n        return count;\\n            \\n             \\n        }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int count=0;\\n    int countnodes(TreeNode* root)\\n    {\\n        if(!root)\\n            return 0;\\n        else{\\n             return countnodes(root->left)+countnodes(root->right)+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2669052,
                "title": "c-easy-recursive-solution",
                "content": "See more in my GitHub repo [LeetCode](http://github.com/SahilK-027/LeetCode).\\n\\n**Recuirsive Solution**\\nWe will use pair<pair<sum,number>,avg> to store ans...And keep a count\\nFor any node with avg == root->val count++\\n```\\nclass Solution {\\nprivate:\\n    pair<pair<int,int>,int> solve(TreeNode* root, int& count){\\n        //Base case\\n        if(root == NULL){\\n            pair<int,int> a = make_pair(0,0);\\n            pair<pair<int,int>,int> p = make_pair(a,0);\\n            return p;\\n        }\\n        // Recursive Call\\n        pair<pair<int,int>,int> leftAns = solve(root->left,count);\\n        pair<pair<int,int>,int> rightAns = solve(root->right,count);\\n        \\n        int sum = leftAns.first.first + rightAns.first.first + root->val;\\n        int n = 1 + leftAns.first.second + rightAns.first.second;\\n        int avg = sum / n;\\n        if(avg == root->val){\\n            count = count+1;\\n        }\\n        \\n        pair<pair<int,int>,int> ans;\\n        ans.first.first = sum;\\n        ans.first.second = n;\\n        ans.second = avg;\\n        return ans;\\n        \\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int count = 0; \\n        pair<pair<int,int>,int> ans = solve(root,count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    pair<pair<int,int>,int> solve(TreeNode* root, int& count){\\n        //Base case\\n        if(root == NULL){\\n            pair<int,int> a = make_pair(0,0);\\n            pair<pair<int,int>,int> p = make_pair(a,0);\\n            return p;\\n        }\\n        // Recursive Call\\n        pair<pair<int,int>,int> leftAns = solve(root->left,count);\\n        pair<pair<int,int>,int> rightAns = solve(root->right,count);\\n        \\n        int sum = leftAns.first.first + rightAns.first.first + root->val;\\n        int n = 1 + leftAns.first.second + rightAns.first.second;\\n        int avg = sum / n;\\n        if(avg == root->val){\\n            count = count+1;\\n        }\\n        \\n        pair<pair<int,int>,int> ans;\\n        ans.first.first = sum;\\n        ans.first.second = n;\\n        ans.second = avg;\\n        return ans;\\n        \\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int count = 0; \\n        pair<pair<int,int>,int> ans = solve(root,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643391,
                "title": "c-easy-understanding-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void findSum(TreeNode* root, int &totalSum, int &count)\\n    {\\n        if(root == NULL)    \\n            return;\\n        \\n        totalSum += root->val;\\n        count++;\\n        \\n        findSum(root->left, totalSum, count);\\n        findSum(root->right, totalSum, count);\\n    }\\n    \\n    \\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        if(root == NULL) \\n            return 0;\\n        int countNodes = 0;\\n        int totalSum = 0;\\n        int count = 0;\\n        findSum(root, totalSum, count);\\n        int avg = totalSum/count;\\n        if(avg == root->val)    \\n            countNodes++;\\n        return countNodes + averageOfSubtree(root->left) + averageOfSubtree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSum(TreeNode* root, int &totalSum, int &count)\\n    {\\n        if(root == NULL)    \\n            return;\\n        \\n        totalSum += root->val;\\n        count++;\\n        \\n        findSum(root->left, totalSum, count);\\n        findSum(root->right, totalSum, count);\\n    }\\n    \\n    \\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        if(root == NULL) \\n            return 0;\\n        int countNodes = 0;\\n        int totalSum = 0;\\n        int count = 0;\\n        findSum(root, totalSum, count);\\n        int avg = totalSum/count;\\n        if(avg == root->val)    \\n            countNodes++;\\n        return countNodes + averageOfSubtree(root->left) + averageOfSubtree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469227,
                "title": "c-easy-fully-commented",
                "content": "```\\n  int cnt=0;\\n    //pair of sum of subtree,numbr of nodes in the subtree is being used here\\n    pair<int,int> slv(TreeNode*root)\\n    {\\n        // if root is null then sum and nmbr of nodes .. both are 0\\n        if(!root)\\n            return {0,0};\\n        //get data from left subtree\\n        pair<int,int>l=slv(root->left);\\n        //get data from right subtree\\n        pair<int,int>r=slv(root->right);\\n        //calculate nmbr of nodes from left and right subtrees data \\n        int n=l.second+r.second+1;\\n        //calculate the sum of the complete subtree i.e root+left tree + right tree\\n        int sum=l.first+r.first+root->val;\\n        //if root\\'s value is equal to avg then increase count\\n        if(root->val==sum/n)\\n          cnt++;\\n        //return the sum and the nmbr of nodes calculated \\n        return {sum,n};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n       slv(root);\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n  int cnt=0;\\n    //pair of sum of subtree,numbr of nodes in the subtree is being used here\\n    pair<int,int> slv(TreeNode*root)\\n    {\\n        // if root is null then sum and nmbr of nodes .. both are 0\\n        if(!root)\\n            return {0,0};\\n        //get data from left subtree\\n        pair<int,int>l=slv(root->left);\\n        //get data from right subtree\\n        pair<int,int>r=slv(root->right);\\n        //calculate nmbr of nodes from left and right subtrees data \\n        int n=l.second+r.second+1;\\n        //calculate the sum of the complete subtree i.e root+left tree + right tree\\n        int sum=l.first+r.first+root->val;\\n        //if root\\'s value is equal to avg then increase count\\n        if(root->val==sum/n)\\n          cnt++;\\n        //return the sum and the nmbr of nodes calculated \\n        return {sum,n};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n       slv(root);\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2398431,
                "title": "python-simple-recursive-solution",
                "content": "**Time Complexity:** `O(n)` (We need to visit all n nodes)\\n**Space Complexity:** `O(n)` In the worst case the tree will look like a damn linked list and our recursion stack will grow to n frames by the time we reach the leaf node.\\n\\n## Solution\\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.matchCount = 0\\n        \\n        self.explore(root)\\n        \\n        return self.matchCount\\n    \\n    def explore(self, root):\\n        if root is None:\\n            return 0, 0\\n        \\n        ls, lc = self.explore(root.left)\\n        rs, rc = self.explore(root.right)\\n        \\n        childTotal = ls + rs + root.val\\n        childCount = lc + rc + 1\\n        \\n        if childCount != 0 and root.val == childTotal // childCount:\\n            self.matchCount += 1\\n        \\n        return childTotal, childCount\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.matchCount = 0\\n        \\n        self.explore(root)\\n        \\n        return self.matchCount\\n    \\n    def explore(self, root):\\n        if root is None:\\n            return 0, 0\\n        \\n        ls, lc = self.explore(root.left)\\n        rs, rc = self.explore(root.right)\\n        \\n        childTotal = ls + rs + root.val\\n        childCount = lc + rc + 1\\n        \\n        if childCount != 0 and root.val == childTotal // childCount:\\n            self.matchCount += 1\\n        \\n        return childTotal, childCount\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393746,
                "title": "simple-c-using-basic-recursive-functions",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t#Vote if u like\\u2764\\uFE0F\\n\\t\\tTo_Do:\\n\\t\\t\\t1.For this question we need to have sum , no.of nodes in subtree than need to find the average \\n\\t\\t\\t2.Than we need to check the value of the root and the average if same increment the count\\n\\t\\t\\t\\n\\t\\tProcess:\\n\\t\\t\\t1. Need to create a function by which we can get the sum of the nodes under it \\n\\t\\t\\t2. Need to create a function so we can get the count of nodes \\n\\t\\t\\t3. Than need to traverse the tree and find the average by using the above funtions\\n\\t\\t\\t\\n\\t     Code:\\t\\n\\t\\t \\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint SumofNode(TreeNode *root) //Funtion to get Sum\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(root == NULL) return 0; //Tree empty return 0;\\n\\t\\t\\t\\t\\tint left = SumofNode(root -> left); //Left subtree will give ans to parent\\n\\t\\t\\t\\t\\tint right = SumofNode(root -> right); // Right subtree will give ans to parent\\n\\t\\t\\t\\t\\treturn left + right + root -> val; //We need to add root val also\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint CountofNode(TreeNode *root)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(root == NULL) return 0; //Tree empty return 0;\\n\\t\\t\\t\\t\\tint left = CountofNode(root -> left);//Left subtree will give ans to parent\\n\\t\\t\\t\\t\\tint right = CountofNode(root -> right);// Right subtree will give ans to parent\\n\\t\\t\\t\\t\\treturn left + right + 1;//We need to count  root also\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid fun(TreeNode *root , vector<pair<int , int>>&m)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(root == NULL) return; //Tree empty return \\n\\t\\t\\t\\t\\tint x = SumofNode(root); //Sum of root\\n\\t\\t\\t\\t\\tint y = CountofNode(root); //no.of roots\\n\\t\\t\\t\\t\\tm.push_back({root -> val , (x * 1.0 / y)}); //Storing in vector\\n\\t\\t\\t\\t\\tfun(root -> left , m); //Passing the left root\\n\\t\\t\\t\\t\\tfun(root -> right , m);//PAssing the right root\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint averageOfSubtree(TreeNode* root) {\\n\\t\\t\\t\\t\\tif(root == NULL) return 0; //Tree empty return 0;\\n\\t\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\t\\tvector<pair<int , int>> m; //list to store the values\\n\\t\\t\\t\\t\\tfun(root , m);//Calling the function to get the values to vector\\n\\t\\t\\t\\t\\tfor(auto p: m)// Checking the root val and avg val if same increment count\\n\\t\\t\\t\\t\\t\\tif(p.first == p.second) count++;\\n\\t\\t\\t\\t\\treturn count;//Return count\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-Yash:)\\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint SumofNode(TreeNode *root) //Funtion to get Sum\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(root == NULL) return 0; //Tree empty return 0;\\n\\t\\t\\t\\t\\tint left = SumofNode(root -> left); //Left subtree will give ans to parent\\n\\t\\t\\t\\t\\tint right = SumofNode(root -> right); // Right subtree will give ans to parent\\n\\t\\t\\t\\t\\treturn left + right + root -> val; //We need to add root val also\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2172811,
                "title": "c-o-n-faster-than-98-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int count=0;\\n    pair<int,int> average(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            pair<int,int> p=make_pair(0,0);\\n            return p;\\n        }\\n        \\n        pair<int,int> left=average(root->left);\\n        pair<int,int> right=average(root->right);\\n        \\n        int sum=left.first+right.first+root->val;\\n        int num=left.second+right.second+1;\\n        \\n        if(sum/num==root->val)\\n            count++;\\n        pair<int,int> ans;\\n        ans.first=sum;\\n        ans.second=num;\\n        return ans;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        average(root);\\n        return count;\\n    }\\n};``",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int count=0;\\n    pair<int,int> average(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            pair<int,int> p=make_pair(0,0);\\n            return p;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2018797,
                "title": "java-bfs-dfs-easy",
                "content": "```\\nclass Solution {\\n    int c =0;\\n      int temp =0;\\n    public int averageOfSubtree(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int count =0;\\n        int sum =0;\\n        while(!q.isEmpty()){\\n            temp = 0;\\n            c=0;\\n            sum =0;\\n            TreeNode node = q.poll();\\n            if(node.left!=null)q.offer(node.left);\\n            if(node.right!=null)q.offer(node.right);\\n            solve(node);\\n            sum+=temp;\\n            if(sum/c == node.val)count++;\\n            \\n        }\\n        return count;\\n    }\\n    public void solve(TreeNode node){\\n        if(node==null) return;\\n        solve(node.left);\\n        temp+=node.val;\\n        c = c+1;\\n        solve(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int c =0;\\n      int temp =0;\\n    public int averageOfSubtree(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int count =0;\\n        int sum =0;\\n        while(!q.isEmpty()){\\n            temp = 0;\\n            c=0;\\n            sum =0;\\n            TreeNode node = q.poll();\\n            if(node.left!=null)q.offer(node.left);\\n            if(node.right!=null)q.offer(node.right);\\n            solve(node);\\n            sum+=temp;\\n            if(sum/c == node.val)count++;\\n            \\n        }\\n        return count;\\n    }\\n    public void solve(TreeNode node){\\n        if(node==null) return;\\n        solve(node.left);\\n        temp+=node.val;\\n        c = c+1;\\n        solve(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018783,
                "title": "easy-to-understand-using-level-order-and-inorder",
                "content": "```\\nvoid sum(TreeNode* root,int &x,int &s){\\n        if(!root) return;\\n        sum(root->left,x,s);\\n        x++;\\n        s+=root->val;\\n        sum(root->right,x,s);\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto node=q.front();\\n            q.pop();\\n            int x=0;\\n            int s=0;\\n            sum(node,x,s);\\n            if(s/x==node->val) ans++;\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvoid sum(TreeNode* root,int &x,int &s){\\n        if(!root) return;\\n        sum(root->left,x,s);\\n        x++;\\n        s+=root->val;\\n        sum(root->right,x,s);\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto node=q.front();\\n            q.pop();\\n            int x=0;\\n            int s=0;\\n            sum(node,x,s);\\n            if(s/x==node->val) ans++;\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2018307,
                "title": "python-iterative-postorder-bottom-up-13-lines",
                "content": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        d = {None: (0, 0)} # key: (sum, n_node) of the node\\n        stack = [(0, root)]\\n        while stack:\\n            seen, node = stack.pop()\\n            if not node: continue\\n            if not seen:\\n                stack += [(1, node), (0, node.right), (0, node.left)]\\n            else:\\n                d[node] = (node.val + d[node.left][0] + d[node.right][0], 1 + d[node.left][1] + d[node.right][1])\\n                if d[node][1] != 0 and node.val == d[node][0] // d[node][1]:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        d = {None: (0, 0)} # key: (sum, n_node) of the node\\n        stack = [(0, root)]\\n        while stack:\\n            seen, node = stack.pop()\\n            if not node: continue\\n            if not seen:\\n                stack += [(1, node), (0, node.right), (0, node.left)]\\n            else:\\n                d[node] = (node.val + d[node.left][0] + d[node.right][0], 1 + d[node.left][1] + d[node.right][1])\\n                if d[node][1] != 0 and node.val == d[node][0] // d[node][1]:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017888,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        dfs(root);\\n        return count;\\n    }\\n    \\n    public int[] dfs(TreeNode root){\\n        if(root==null)\\n            return new int[]{0,0};\\n        int[] l=dfs(root.left);\\n        int[] r=dfs(root.right);\\n        \\n        int avg=Math.round((l[0]+r[0]+root.val)/(l[1]+r[1]+1));\\n        if(avg==root.val)\\n            count++;\\n        \\n        return new int[]{l[0]+r[0]+root.val,l[1]+r[1]+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        dfs(root);\\n        return count;\\n    }\\n    \\n    public int[] dfs(TreeNode root){\\n        if(root==null)\\n            return new int[]{0,0};\\n        int[] l=dfs(root.left);\\n        int[] r=dfs(root.right);\\n        \\n        int avg=Math.round((l[0]+r[0]+root.val)/(l[1]+r[1]+1));\\n        if(avg==root.val)\\n            count++;\\n        \\n        return new int[]{l[0]+r[0]+root.val,l[1]+r[1]+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017813,
                "title": "easy-java-dfs-traversal",
                "content": "```\\nclass Solution {\\n    private int answer;\\n    public int averageOfSubtree(TreeNode root) {\\n        this.answer = 0;\\n        getAverage(root);\\n        return answer;\\n    }\\n    \\n    private NodeDetails getAverage(TreeNode root) {\\n        if (root == null) {\\n            return new NodeDetails(0, 0);\\n        }\\n        \\n        // Populate left and right tree\\n        NodeDetails left = getAverage(root.left);\\n        NodeDetails right = getAverage(root.right);\\n        \\n        int count = 1;\\n        int sum = root.val;\\n        \\n        // Use left and right tree to pupulate current Node\\n        count += left.count;\\n        sum += left.sum;\\n\\n        count += right.count;\\n        sum += right.sum;\\n        \\n        // Check Average\\n        if (root.val == sum/count) {\\n            answer++;\\n        }\\n        \\n        return new NodeDetails(count, sum);\\n    }\\n}\\n\\nclass NodeDetails {\\n    int count;\\n    int sum;\\n    \\n    public NodeDetails(int count, int sum) {\\n        this.count = count;\\n        this.sum = sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int answer;\\n    public int averageOfSubtree(TreeNode root) {\\n        this.answer = 0;\\n        getAverage(root);\\n        return answer;\\n    }\\n    \\n    private NodeDetails getAverage(TreeNode root) {\\n        if (root == null) {\\n            return new NodeDetails(0, 0);\\n        }\\n        \\n        // Populate left and right tree\\n        NodeDetails left = getAverage(root.left);\\n        NodeDetails right = getAverage(root.right);\\n        \\n        int count = 1;\\n        int sum = root.val;\\n        \\n        // Use left and right tree to pupulate current Node\\n        count += left.count;\\n        sum += left.sum;\\n\\n        count += right.count;\\n        sum += right.sum;\\n        \\n        // Check Average\\n        if (root.val == sum/count) {\\n            answer++;\\n        }\\n        \\n        return new NodeDetails(count, sum);\\n    }\\n}\\n\\nclass NodeDetails {\\n    int count;\\n    int sum;\\n    \\n    public NodeDetails(int count, int sum) {\\n        this.count = count;\\n        this.sum = sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017811,
                "title": "recursion-pair",
                "content": "faith:\\n* left call will give me sum as well as count of nodes\\n* right call will give me sum as well as count of nodes \\n* check for required condition including current node \\n* return {requires sum,left call nodes+right call nodes+1(node itself)} \\n*  base case too easy to handle\\n\\t\\n\\n```\\n class Solution {\\npublic: \\n    int c; \\n\\t// pair<sum,count of nodes>\\n    pair<int,int> solve(TreeNode* root){\\n        if(!root) return {0,0}; \\n        auto [lsum,lnc]=solve(root->left);\\n        auto [rsum,rnc]=solve(root->right);  \\n        if((lsum+rsum+root->val)/(lnc+rnc+1)==root->val)\\n            c++;\\n        return {lsum+rsum+root->val,lnc+rnc+1};\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        c=0;\\n        solve(root);\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic: \\n    int c; \\n\\t// pair<sum,count of nodes>\\n    pair<int,int> solve(TreeNode* root){\\n        if(!root) return {0,0}; \\n        auto [lsum,lnc]=solve(root->left);\\n        auto [rsum,rnc]=solve(root->right);  \\n        if((lsum+rsum+root->val)/(lnc+rnc+1)==root->val)\\n            c++;\\n        return {lsum+rsum+root->val,lnc+rnc+1};\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        c=0;\\n        solve(root);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017741,
                "title": "o-n-solution-using-hashmap-c",
                "content": "The idea is to store the Size and the sum of that subtree in a map linked to the root node.\\nFurther if the size/ sum of a node is equal to its value, then increase the final count.\\n```\\nclass Solution {\\nprivate:\\n    //Map of size and sum\\n    map<TreeNode *,pair<int,int>> hm;\\n    int ans=0;\\n    void sumTree(TreeNode* root){\\n        if(root == NULL){\\n            hm[root] = {0,0};\\n        }\\n        if(root->left){\\n        sumTree(root->left);\\n        }\\n        if(root->right){\\n        sumTree(root->right);\\n        }\\n        int sum = hm[root->left].second + root->val + hm[root->right].second;\\n        int size = 1 + hm[root->left].first + hm[root->right].first;\\n        if(sum/size == root->val)\\n            ans++;\\n        hm[root] = {size,sum};\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        sumTree(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    //Map of size and sum\\n    map<TreeNode *,pair<int,int>> hm;\\n    int ans=0;\\n    void sumTree(TreeNode* root){\\n        if(root == NULL){\\n            hm[root] = {0,0};\\n        }\\n        if(root->left){\\n        sumTree(root->left);\\n        }\\n        if(root->right){\\n        sumTree(root->right);\\n        }\\n        int sum = hm[root->left].second + root->val + hm[root->right].second;\\n        int size = 1 + hm[root->left].first + hm[root->right].first;\\n        if(sum/size == root->val)\\n            ans++;\\n        hm[root] = {size,sum};\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        sumTree(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846481,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int noOfNodes(TreeNode* node){\\n        if(node == NULL){\\n            return 0;\\n        }\\n        \\n        return 1 + noOfNodes(node -> left) + noOfNodes(node -> right);\\n    }\\n    \\n    int pathsum(TreeNode* node){\\n        if(node == NULL){\\n            return 0;\\n        }\\n        int lh = pathsum(node -> left);\\n        int rh = pathsum(node -> right);\\n        \\n        return (node -> val) + (lh+rh);\\n    }\\n    \\n    void solve(TreeNode* &node, int &sum){\\n        \\n        if(node == NULL) return;\\n        \\n        if(pathsum(node) / noOfNodes(node) == (node -> val)){\\n            cout<<node -> val << \" \";\\n            sum++;\\n        }\\n        \\n        solve(node -> left, sum);\\n        solve(node -> right, sum);\\n        \\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        int sum = 0;\\n        solve(root, sum);\\n        return sum;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int noOfNodes(TreeNode* node){\\n        if(node == NULL){\\n            return 0;\\n        }\\n        \\n        return 1 + noOfNodes(node -> left) + noOfNodes(node -> right);\\n    }\\n    \\n    int pathsum(TreeNode* node){\\n        if(node == NULL){\\n            return 0;\\n        }\\n        int lh = pathsum(node -> left);\\n        int rh = pathsum(node -> right);\\n        \\n        return (node -> val) + (lh+rh);\\n    }\\n    \\n    void solve(TreeNode* &node, int &sum){\\n        \\n        if(node == NULL) return;\\n        \\n        if(pathsum(node) / noOfNodes(node) == (node -> val)){\\n            cout<<node -> val << \" \";\\n            sum++;\\n        }\\n        \\n        solve(node -> left, sum);\\n        solve(node -> right, sum);\\n        \\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        int sum = 0;\\n        solve(root, sum);\\n        return sum;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3286573,
                "title": "simple-python3-solution",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.res = []\\n        def trav(root):\\n            if not root:\\n                return None\\n            temp = dfs(root,[])\\n            if root.val == sum(temp)//len(temp):\\n                self.res.append(root.val)\\n\\n            if root.left:\\n                trav(root.left)\\n            \\n            if root.right:\\n                trav(root.right)\\n\\n\\n        def dfs(root,final):\\n            if not root:\\n                return None\\n            \\n            final.append(root.val)\\n\\n            if root.left:\\n                dfs(root.left,final)\\n            \\n            if root.right:\\n                dfs(root.right,final)\\n            \\n            return final\\n        \\n        trav(root)\\n        return len(self.res)\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.res = []\\n        def trav(root):\\n            if not root:\\n                return None\\n            temp = dfs(root,[])\\n            if root.val == sum(temp)//len(temp):\\n                self.res.append(root.val)\\n\\n            if root.left:\\n                trav(root.left)\\n            \\n            if root.right:\\n                trav(root.right)\\n\\n\\n        def dfs(root,final):\\n            if not root:\\n                return None\\n            \\n            final.append(root.val)\\n\\n            if root.left:\\n                dfs(root.left,final)\\n            \\n            if root.right:\\n                dfs(root.right,final)\\n            \\n            return final\\n        \\n        trav(root)\\n        return len(self.res)\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204428,
                "title": "c-solution-using-recursion-simple-o-n-time-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int, int> averageOfSubtreeHelper(TreeNode* root, int& ans) {\\n        \\n        // Base  Case\\n        if(root == NULL) {\\n            return {0,0};\\n        }\\n        \\n        // Recursive Case\\n        \\n        // Calling the left and right subtree to get the total sum of all the nodes present in the left and right subtree and the number of nodes present.\\n        pair<int, int>leftSubtree = averageOfSubtreeHelper(root->left, ans);\\n        pair<int, int>rightSubtree = averageOfSubtreeHelper(root->right, ans);\\n        \\n        // Calculating the totalSum and totalNodes including the left, right subtree and the current node.\\n        int totalSum = leftSubtree.first + rightSubtree.first + root->val;\\n        int totalNodes = leftSubtree.second + rightSubtree.second + 1;\\n        \\n        // Checking if the node satisfy the given condition or not.\\n        if(totalSum / totalNodes == root->val) {\\n            ans++;\\n        }\\n        \\n        // Returning the totalSum and totalNodes.\\n        return {totalSum, totalNodes};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans = 0;\\n        averageOfSubtreeHelper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> averageOfSubtreeHelper(TreeNode* root, int& ans) {\\n        \\n        // Base  Case\\n        if(root == NULL) {\\n            return {0,0};\\n        }\\n        \\n        // Recursive Case\\n        \\n        // Calling the left and right subtree to get the total sum of all the nodes present in the left and right subtree and the number of nodes present.\\n        pair<int, int>leftSubtree = averageOfSubtreeHelper(root->left, ans);\\n        pair<int, int>rightSubtree = averageOfSubtreeHelper(root->right, ans);\\n        \\n        // Calculating the totalSum and totalNodes including the left, right subtree and the current node.\\n        int totalSum = leftSubtree.first + rightSubtree.first + root->val;\\n        int totalNodes = leftSubtree.second + rightSubtree.second + 1;\\n        \\n        // Checking if the node satisfy the given condition or not.\\n        if(totalSum / totalNodes == root->val) {\\n            ans++;\\n        }\\n        \\n        // Returning the totalSum and totalNodes.\\n        return {totalSum, totalNodes};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans = 0;\\n        averageOfSubtreeHelper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049351,
                "title": "easy-simple-c-solution-dfs",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root, int nodes, int& ans){  // sum, no of nodes\\n        if (root==NULL){\\n            return {0,0};\\n        }\\n        pair<int,int> left= solve(root->left,nodes,ans);\\n        pair<int,int> right= solve(root->right,nodes,ans);\\n        int avg= (left.first+right.first+root->val)/(left.second+right.second+1);\\n        if (avg == root->val)ans++;\\n        return {left.first+right.first+root->val,left.second+right.second+1};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        if (root==NULL)return 0;\\n        int ans=0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root, int nodes, int& ans){  // sum, no of nodes\\n        if (root==NULL){\\n            return {0,0};\\n        }\\n        pair<int,int> left= solve(root->left,nodes,ans);\\n        pair<int,int> right= solve(root->right,nodes,ans);\\n        int avg= (left.first+right.first+root->val)/(left.second+right.second+1);\\n        if (avg == root->val)ans++;\\n        return {left.first+right.first+root->val,left.second+right.second+1};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        if (root==NULL)return 0;\\n        int ans=0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030502,
                "title": "c-easy-to-understand-concise-solution-with-explanation-and-intuition",
                "content": "# Intuition\\n\\nIn this by first looking into the question we can see that we have to add the nodes and take average of them , we think of building our answer from bottom top and we use DFS for this \\n\\n# Approach\\n\\nFirst what this function will do is to go deep left into the tree and start building answer . Here I have used pair as a return type reason for this is first element in pair will store the sum of the subtrees and second will store the count of the nodes which will be used to calculate averages . \\n\\nOn reaching deep left leaf where it has no descendents it will return {0,0} because there is no subtree so sum will be 0 and there are nodes so second element in pair will also be 0 .\\n\\nRest you can see the code then you will understand better Hope it helps !!\\n\\n# Complexity\\n- Time complexity:\\nO(N) - for Number of Nodes\\n\\n- Space complexity:\\nO(H) - Height of tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public: int count=0;\\n    public: pair<int,int> avrNodes(TreeNode* root){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        pair<int,int> left=func(root->left);\\n        pair<int,int> right=func(root->right);\\n        if((root->val+left.first+right.first)/(left.second+right.second+1)==root->val){\\n            count++;\\n        }\\n        return {root->val+left.first+right.first,left.second+1+right.second}; // while returning 1 is added for the parent node during function calls and other two are for left and right subtree .\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        avrNodes(root);\\n        return count;\\n    }\\n};\\n```\\n\\nGuys Please upvote it really motivates me please guys one upvote!!!  Please !!!.\\nIf you have any doubts please feel free to ask .\\n![download.jpg](https://assets.leetcode.com/users/images/d95a271c-8557-4fd5-9d13-f6c4132ea8de_1673607225.2370918.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public: int count=0;\\n    public: pair<int,int> avrNodes(TreeNode* root){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        pair<int,int> left=func(root->left);\\n        pair<int,int> right=func(root->right);\\n        if((root->val+left.first+right.first)/(left.second+right.second+1)==root->val){\\n            count++;\\n        }\\n        return {root->val+left.first+right.first,left.second+1+right.second}; // while returning 1 is added for the parent node during function calls and other two are for left and right subtree .\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        avrNodes(root);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970257,
                "title": "very-simple-c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int sumsub(TreeNode* root,int &c)\\n    {\\n        if(root==NULL)return 0;\\n        else\\n        {\\n            c++;\\n        }\\n        return root->val+sumsub(root->left,c)+sumsub(root->right,c);\\n    }\\n    int helper(TreeNode* root)\\n    {   int c=0;\\n        int sum=sumsub(root,c);\\n        if(sum/c==root->val)return 1;\\n        return 0;\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        if(root==NULL)return 0;\\n        if(helper(root)==1)\\n        {\\n            ans+=1;\\n        }\\n        averageOfSubtree(root->left);\\n        averageOfSubtree(root->right);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int sumsub(TreeNode* root,int &c)\\n    {\\n        if(root==NULL)return 0;\\n        else\\n        {\\n            c++;\\n        }\\n        return root->val+sumsub(root->left,c)+sumsub(root->right,c);\\n    }\\n    int helper(TreeNode* root)\\n    {   int c=0;\\n        int sum=sumsub(root,c);\\n        if(sum/c==root->val)return 1;\\n        return 0;\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        if(root==NULL)return 0;\\n        if(helper(root)==1)\\n        {\\n            ans+=1;\\n        }\\n        averageOfSubtree(root->left);\\n        averageOfSubtree(root->right);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880085,
                "title": "simple-dfs-solution-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum(TreeNode* r){\\n        if(r==NULL){\\n            return 0;\\n        }\\n        int lsum=sum(r->left);\\n        int rsum=sum(r->right);\\n        return r->val+lsum+rsum;\\n    }\\n    int no(TreeNode* r){\\n        if(r==NULL){\\n            return 0;\\n        }\\n        int lno=no(r->left);\\n        int rno=no(r->right);\\n        return 1+lno+rno;\\n    }\\n    int averageOfSubtree(TreeNode* r) {\\n        if(r==NULL){\\n            return 0;\\n        }\\n        cout<<(r->val)<<\" \"<<sum(r)<<\" \"<<no(r)<<endl;\\n        int lc=  averageOfSubtree(r->left);\\n        int rc= averageOfSubtree(r->right);\\n        if((r->val)==((sum(r))/no(r))){\\n            return 1+rc+lc;\\n        }\\n        return 0+rc+lc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum(TreeNode* r){\\n        if(r==NULL){\\n            return 0;\\n        }\\n        int lsum=sum(r->left);\\n        int rsum=sum(r->right);\\n        return r->val+lsum+rsum;\\n    }\\n    int no(TreeNode* r){\\n        if(r==NULL){\\n            return 0;\\n        }\\n        int lno=no(r->left);\\n        int rno=no(r->right);\\n        return 1+lno+rno;\\n    }\\n    int averageOfSubtree(TreeNode* r) {\\n        if(r==NULL){\\n            return 0;\\n        }\\n        cout<<(r->val)<<\" \"<<sum(r)<<\" \"<<no(r)<<endl;\\n        int lc=  averageOfSubtree(r->left);\\n        int rc= averageOfSubtree(r->right);\\n        if((r->val)==((sum(r))/no(r))){\\n            return 1+rc+lc;\\n        }\\n        return 0+rc+lc;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2876165,
                "title": "java-dfs-1-pass-using-pair-class",
                "content": "```\\nclass Solution {\\n\\n    class Pair {\\n        int sum;\\n        int count;\\n\\n        public Pair(int sum, int count) {\\n            this.sum = sum;\\n            this.count = count;\\n        }\\n    }\\n\\n    int res;\\n    public Pair averageOfSubtree_helper(TreeNode root) {\\n        if (root == null) {\\n            return new Pair(0, 0);\\n        }\\n\\n        Pair left = averageOfSubtree_helper(root.left);\\n        Pair right = averageOfSubtree_helper(root.right);\\n\\n        int sum = left.sum + right.sum + root.val;\\n        int count = left.count + right.count + 1;\\n\\n        if (sum / count == root.val) {\\n            res++;\\n        }\\n\\n        return new Pair(sum, count);\\n    }\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        res = 0;\\n        averageOfSubtree_helper(root);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Pair {\\n        int sum;\\n        int count;\\n\\n        public Pair(int sum, int count) {\\n            this.sum = sum;\\n            this.count = count;\\n        }\\n    }\\n\\n    int res;\\n    public Pair averageOfSubtree_helper(TreeNode root) {\\n        if (root == null) {\\n            return new Pair(0, 0);\\n        }\\n\\n        Pair left = averageOfSubtree_helper(root.left);\\n        Pair right = averageOfSubtree_helper(root.right);\\n\\n        int sum = left.sum + right.sum + root.val;\\n        int count = left.count + right.count + 1;\\n\\n        if (sum / count == root.val) {\\n            res++;\\n        }\\n\\n        return new Pair(sum, count);\\n    }\\n\\n    public int averageOfSubtree(TreeNode root) {\\n        res = 0;\\n        averageOfSubtree_helper(root);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873900,
                "title": "easy-code-with-explanation",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n//what if we manage to calculate the sum of every subtree and number of nodes in that subtree ..then we got our answer but since counting nodes from nichhe to upper and the sum of subtree in 1 func not possible so i created 2 func diff for each operation and thus solved and also store the node val to be compared at last\\nvector<int>sum,cnt,curr_node;\\nint func(TreeNode*root)\\n{\\n    if(root==NULL)\\n     return 0;\\n    int left_sum=func(root->left);\\n    int right_sum=func(root->right);\\n    int total_sum=left_sum+right_sum+root->val;\\n    sum.push_back(total_sum);\\n     //cout<<total_sum<<endl;\\n     return total_sum;\\n}\\nint func_countnodes(TreeNode*root)\\n{\\n   if(root==NULL)\\n     return 0;\\n    int left_ctr=func_countnodes(root->left);\\n    int right_ctr=func_countnodes(root->right);\\n    int total_ctr=left_ctr+right_ctr+1;\\n    curr_node.push_back(root->val);\\n    cnt.push_back(total_ctr);\\n    return total_ctr;\\n}\\n    int averageOfSubtree(TreeNode* root) {\\n        //for calculating the sum\\n        func(root);\\n       // for calculating the node\\n        func_countnodes(root);\\n      //since the traversal is same thus the sum and number of nodes are correctly placed i.e index is same \\n      int ans=0;\\n      //cout<<sum.size()<<\" \"<<cnt.size()<<\" \"<<curr_node.size()<<endl;\\n      for(int i=0;i<sum.size();i++)\\n      {\\n          if(sum[i]/cnt[i]==curr_node[i])\\n          ans++;\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n//what if we manage to calculate the sum of every subtree and number of nodes in that subtree ..then we got our answer but since counting nodes from nichhe to upper and the sum of subtree in 1 func not possible so i created 2 func diff for each operation and thus solved and also store the node val to be compared at last\\nvector<int>sum,cnt,curr_node;\\nint func(TreeNode*root)\\n{\\n    if(root==NULL)\\n     return 0;\\n    int left_sum=func(root->left);\\n    int right_sum=func(root->right);\\n    int total_sum=left_sum+right_sum+root->val;\\n    sum.push_back(total_sum);\\n     //cout<<total_sum<<endl;\\n     return total_sum;\\n}\\nint func_countnodes(TreeNode*root)\\n{\\n   if(root==NULL)\\n     return 0;\\n    int left_ctr=func_countnodes(root->left);\\n    int right_ctr=func_countnodes(root->right);\\n    int total_ctr=left_ctr+right_ctr+1;\\n    curr_node.push_back(root->val);\\n    cnt.push_back(total_ctr);\\n    return total_ctr;\\n}\\n    int averageOfSubtree(TreeNode* root) {\\n        //for calculating the sum\\n        func(root);\\n       // for calculating the node\\n        func_countnodes(root);\\n      //since the traversal is same thus the sum and number of nodes are correctly placed i.e index is same \\n      int ans=0;\\n      //cout<<sum.size()<<\" \"<<cnt.size()<<\" \"<<curr_node.size()<<endl;\\n      for(int i=0;i<sum.size();i++)\\n      {\\n          if(sum[i]/cnt[i]==curr_node[i])\\n          ans++;\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2837149,
                "title": "traversals",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    \\npublic:\\n    void io(TreeNode* r, vector<TreeNode*> &v)\\n    {\\n        if(!r)\\n            return;\\n        io(r->left,v);\\n        v.push_back(r);\\n        io(r->right,v);\\n    }\\n    \\n    void ios(TreeNode* r,int &s,int &c)\\n    {\\n        if(!r)\\n            return;\\n        \\n        ios(r->left,s,c);\\n        s+=r->val;\\n        c+=1;\\n        ios(r->right,s,c);\\n        \\n    }\\n    int averageOfSubtree(TreeNode* r) {\\n        \\n        int s,c;\\n        \\n        vector<TreeNode*> v;\\n        io(r,v);\\n        int res = 0;\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            s=c=0;\\n            ios(v[i],s,c);\\n            if(v[i]->val == int(s/c))\\n                res++;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    \\npublic:\\n    void io(TreeNode* r, vector<TreeNode*> &v)\\n    {\\n        if(!r)\\n            return;\\n        io(r->left,v);\\n        v.push_back(r);\\n        io(r->right,v);\\n    }\\n    \\n    void ios(TreeNode* r,int &s,int &c)\\n    {\\n        if(!r)\\n            return;\\n        \\n        ios(r->left,s,c);\\n        s+=r->val;\\n        c+=1;\\n        ios(r->right,s,c);\\n        \\n    }\\n    int averageOfSubtree(TreeNode* r) {\\n        \\n        int s,c;\\n        \\n        vector<TreeNode*> v;\\n        io(r,v);\\n        int res = 0;\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            s=c=0;\\n            ios(v[i],s,c);\\n            if(v[i]->val == int(s/c))\\n                res++;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810979,
                "title": "fast-recursion-solution-with-notes-by-java-javascript",
                "content": "**java**\\n![image](https://assets.leetcode.com/users/images/3fb5d04d-9c49-4c61-8518-151fd1a13403_1668347151.616631.png)\\n```\\nclass Solution {\\n    \\n    int res = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        node t = new node(0,0);\\n        counting(root);\\n        return res;\\n    }\\n    \\n    // recursion method : \\n    private node counting(TreeNode root){\\n        \\n        // base case :\\n        if(root.left == null && root.right == null){\\n            node temp = new node(root.val,1);\\n            res++;\\n            return temp;\\n        }\\n        node tempLeft = new node(0,0);\\n        node tempRight = new node(0,0);\\n        \\n        // first check left :\\n        if(root.left != null){\\n            tempLeft = counting(root.left);\\n        }\\n        \\n        // check right :\\n        if(root.right != null){\\n            tempRight = counting(root.right);\\n        }\\n        \\n        // sum = values of nodes :\\n        int sum = tempLeft.sum + tempRight.sum + root.val;\\n        // count = number of nodes :\\n        int count = tempLeft.count + tempRight.count + 1;\\n        \\n        if(sum/count == root.val) res++;\\n        \\n        // return the node :\\n        node temp = new node(sum,count);\\n        return temp;\\n    }\\n        \\n}\\n\\nclass node{\\n    int sum = 0;\\n    int count = 0;\\n    \\n    node(int s, int c){\\n        sum = s;\\n        count = c;\\n    }\\n}\\n```\\n\\n**Javascript**\\n![image](https://assets.leetcode.com/users/images/b71dd70a-e898-4cc2-9ab3-849948723982_1668347194.1284957.png)\\n```\\nvar averageOfSubtree = function(root) {\\n    let res = 0;\\n    \\n    // recursion method : \\n    var counting = function(node){\\n        \\n        // base case :\\n        if(!node.left && !node.right){\\n            let tempArr = [node.val,1];\\n            res++;\\n            return tempArr;\\n        }\\n        \\n        let tempLeft = [0,0];\\n        let tempRight = [0,0];\\n        \\n        // check left :\\n        if(node.left){\\n            tempLeft = counting(node.left);\\n        }\\n        \\n        // check right :\\n        if(node.right){\\n            tempRight = counting(node.right);\\n        }\\n        \\n        // sum = values of nodes :\\n        let sum = tempLeft[0] + tempRight[0] + node.val;\\n        // count = number of nodes :\\n        let count = tempLeft[1] + tempRight[1] + 1;\\n        \\n        if(Math.floor(sum/count) == node.val) res++;\\n        \\n        // return array :\\n        let temp = [sum,count];\\n        return temp;\\n    }\\n    \\n    \\n    counting(root);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        node t = new node(0,0);\\n        counting(root);\\n        return res;\\n    }\\n    \\n    // recursion method : \\n    private node counting(TreeNode root){\\n        \\n        // base case :\\n        if(root.left == null && root.right == null){\\n            node temp = new node(root.val,1);\\n            res++;\\n            return temp;\\n        }\\n        node tempLeft = new node(0,0);\\n        node tempRight = new node(0,0);\\n        \\n        // first check left :\\n        if(root.left != null){\\n            tempLeft = counting(root.left);\\n        }\\n        \\n        // check right :\\n        if(root.right != null){\\n            tempRight = counting(root.right);\\n        }\\n        \\n        // sum = values of nodes :\\n        int sum = tempLeft.sum + tempRight.sum + root.val;\\n        // count = number of nodes :\\n        int count = tempLeft.count + tempRight.count + 1;\\n        \\n        if(sum/count == root.val) res++;\\n        \\n        // return the node :\\n        node temp = new node(sum,count);\\n        return temp;\\n    }\\n        \\n}\\n\\nclass node{\\n    int sum = 0;\\n    int count = 0;\\n    \\n    node(int s, int c){\\n        sum = s;\\n        count = c;\\n    }\\n}\\n```\n```\\nvar averageOfSubtree = function(root) {\\n    let res = 0;\\n    \\n    // recursion method : \\n    var counting = function(node){\\n        \\n        // base case :\\n        if(!node.left && !node.right){\\n            let tempArr = [node.val,1];\\n            res++;\\n            return tempArr;\\n        }\\n        \\n        let tempLeft = [0,0];\\n        let tempRight = [0,0];\\n        \\n        // check left :\\n        if(node.left){\\n            tempLeft = counting(node.left);\\n        }\\n        \\n        // check right :\\n        if(node.right){\\n            tempRight = counting(node.right);\\n        }\\n        \\n        // sum = values of nodes :\\n        let sum = tempLeft[0] + tempRight[0] + node.val;\\n        // count = number of nodes :\\n        let count = tempLeft[1] + tempRight[1] + 1;\\n        \\n        if(Math.floor(sum/count) == node.val) res++;\\n        \\n        // return array :\\n        let temp = [sum,count];\\n        return temp;\\n    }\\n    \\n    \\n    counting(root);\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726395,
                "title": "java-iterative-recursive-new-class-o-n",
                "content": "**We Can Approach This Problem In Following 4 Dimensions**\\n*Iterative Approach : \\nTime Complexity : O(n)\\nSpace Complexity : O(n) + O(n)*\\n```\\nclass Solution {\\n    \\n    public static boolean isLeaf(TreeNode root){\\n        return root!=null && root.left==null && root.right==null;\\n    }\\n    \\n    public static int fun(TreeNode root){\\n        int count = 0 , sum = 0;\\n        if(root == null) return count;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode temp = stack.pop();\\n            count++;\\n            sum += temp.val;\\n            if(temp.right != null) stack.push(temp.right);\\n            if(temp.left != null) stack.push(temp.left);\\n        }\\n        return sum/count;\\n        \\n    }\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        int count = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode temp = stack.pop();\\n            if(fun(temp) == temp.val) count++;\\n            if(temp.right != null) stack.push(temp.right);\\n            if(temp.left != null) stack.push(temp.left);\\n        }\\n        return count;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(n)\\n}\\n```\\n*Iterative Approach With Space Optimisation : \\nTime Complexity : O(n)\\nSpace Complexity : O(n)*\\n```\\nclass Solution {\\n    public static int count , sum;\\n    public static void fun(TreeNode root){\\n        if(root == null) return;\\n        count++;\\n        sum += root.val;\\n        fun(root.left);\\n        fun(root.right);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        int ans = 0;\\n        if(root == null) return ans;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode temp = stack.pop();\\n            sum = 0;\\n            count = 0;\\n            fun(temp);\\n            ans += (temp.val == sum/count) ? 1 : 0;\\n            if(temp.right != null) stack.push(temp.right);\\n            if(temp.left != null) stack.push(temp.left);\\n        }\\n        return ans;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(n)\\n}\\n```\\n*Recursive Approach : \\nTime Complexity : O(n)\\nSpace Complexity : O(1)*\\n```\\nclass Solution {\\n    public static int count , sum;\\n    public static void fun(TreeNode root){\\n        if(root == null) return;\\n        count++;\\n        sum += root.val;\\n        fun(root.left);\\n        fun(root.right);\\n    }\\n    public static int ans;\\n    public static void helper(TreeNode root){\\n        if(root == null) return;\\n        count = 0;\\n        sum = 0;\\n        fun(root);\\n        if(root.val == sum/count) ans++;\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        ans = 0;\\n        helper(root);\\n        return ans;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(1)\\n}\\n```\\n*Most Optimised Approach : \\nTime Complexity : O(n)\\nSpace Complexity : O(1)*\\n```\\nclass get_node_info{\\n    int sum;\\n    int count;\\n    get_node_info(int sum,int count){\\n        this.sum = sum;\\n        this.count = count;\\n    }\\n}\\nclass Solution {\\n    public static int ans = 0;\\n    public static get_node_info fun(TreeNode root){\\n        if(root == null) return new get_node_info(0,0);\\n        get_node_info left_query = fun(root.left);\\n        get_node_info right_query = fun(root.right);\\n        \\n        int current_sum = left_query.sum + root.val + right_query.sum;\\n        int current_count = left_query.count + 1 + right_query.count;\\n        if(root.val == current_sum/current_count) ans++;\\n\\t\\t\\n        return new get_node_info(current_sum,current_count);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        ans = 0;\\n        fun(root);\\n        return ans;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(1)\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static boolean isLeaf(TreeNode root){\\n        return root!=null && root.left==null && root.right==null;\\n    }\\n    \\n    public static int fun(TreeNode root){\\n        int count = 0 , sum = 0;\\n        if(root == null) return count;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode temp = stack.pop();\\n            count++;\\n            sum += temp.val;\\n            if(temp.right != null) stack.push(temp.right);\\n            if(temp.left != null) stack.push(temp.left);\\n        }\\n        return sum/count;\\n        \\n    }\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        int count = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode temp = stack.pop();\\n            if(fun(temp) == temp.val) count++;\\n            if(temp.right != null) stack.push(temp.right);\\n            if(temp.left != null) stack.push(temp.left);\\n        }\\n        return count;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(n)\\n}\\n```\n```\\nclass Solution {\\n    public static int count , sum;\\n    public static void fun(TreeNode root){\\n        if(root == null) return;\\n        count++;\\n        sum += root.val;\\n        fun(root.left);\\n        fun(root.right);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        int ans = 0;\\n        if(root == null) return ans;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode temp = stack.pop();\\n            sum = 0;\\n            count = 0;\\n            fun(temp);\\n            ans += (temp.val == sum/count) ? 1 : 0;\\n            if(temp.right != null) stack.push(temp.right);\\n            if(temp.left != null) stack.push(temp.left);\\n        }\\n        return ans;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(n)\\n}\\n```\n```\\nclass Solution {\\n    public static int count , sum;\\n    public static void fun(TreeNode root){\\n        if(root == null) return;\\n        count++;\\n        sum += root.val;\\n        fun(root.left);\\n        fun(root.right);\\n    }\\n    public static int ans;\\n    public static void helper(TreeNode root){\\n        if(root == null) return;\\n        count = 0;\\n        sum = 0;\\n        fun(root);\\n        if(root.val == sum/count) ans++;\\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        ans = 0;\\n        helper(root);\\n        return ans;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(1)\\n}\\n```\n```\\nclass get_node_info{\\n    int sum;\\n    int count;\\n    get_node_info(int sum,int count){\\n        this.sum = sum;\\n        this.count = count;\\n    }\\n}\\nclass Solution {\\n    public static int ans = 0;\\n    public static get_node_info fun(TreeNode root){\\n        if(root == null) return new get_node_info(0,0);\\n        get_node_info left_query = fun(root.left);\\n        get_node_info right_query = fun(root.right);\\n        \\n        int current_sum = left_query.sum + root.val + right_query.sum;\\n        int current_count = left_query.count + 1 + right_query.count;\\n        if(root.val == current_sum/current_count) ans++;\\n\\t\\t\\n        return new get_node_info(current_sum,current_count);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        ans = 0;\\n        fun(root);\\n        return ans;\\n    }\\n    // Time Complexity : O(n)\\n    // Space Complexity : O(1)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705604,
                "title": "count-nodes-equal-to-average-of-subtree-c-depth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    pair<int,int>solve(TreeNode* root,int &count){\\n       if(root==NULL){\\n           return {0,0};\\n       }\\n       pair<int,int>left=solve(root->left,count);\\n       pair<int,int>right=solve(root->right,count);\\n\\n       int sum=left.first+right.first+root->val;\\n       int cnt=left.second+right.second+1;\\n       if(sum/cnt==root->val){\\n           count++;\\n       }\\n       return {sum,cnt};\\n   }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int count=0;\\n        solve(root,count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    pair<int,int>solve(TreeNode* root,int &count){\\n       if(root==NULL){\\n           return {0,0};\\n       }\\n       pair<int,int>left=solve(root->left,count);\\n       pair<int,int>right=solve(root->right,count);\\n\\n       int sum=left.first+right.first+root->val;\\n       int cnt=left.second+right.second+1;\\n       if(sum/cnt==root->val){\\n           count++;\\n       }\\n       return {sum,cnt};\\n   }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int count=0;\\n        solve(root,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703052,
                "title": "easy-c-code-o-n-time-complexity",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum(TreeNode*root){\\n        if(root==NULL) return 0;\\n        int right = sum(root->right);\\n        int left = sum(root->left);\\n        return (left+right)+root->val;\\n    }\\n    int cnt(TreeNode*root){\\n        if(root==NULL) return 0;\\n        int left = cnt(root->left);\\n        int right = cnt(root->right);\\n        return (left+right)+1;\\n    }\\n    void traversal(TreeNode*root,int &n){\\n        if(root==NULL) return;\\n        if(sum(root)/cnt(root)==root->val) n = n+1;\\n        traversal(root->right,n);\\n         traversal(root->left,n);\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n      int ans = 0;\\n      traversal(root,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int sum(TreeNode*root){\\n        if(root==NULL) return 0;\\n        int right = sum(root->right);\\n        int left = sum(root->left);\\n        return (left+right)+root->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2664160,
                "title": "i-m-fucking-genius-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimilar to height of BT\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will keep track of average and sum of nodes upto that point at each node\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass C {\\n    public:\\n    int avg, count;\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    C solve(TreeNode* root) {\\n        if(!root) return {0,0};\\n        C lavg = solve(root -> left);\\n        C ravg = solve(root -> right);\\n\\n        int avgerage = lavg.avg + ravg.avg + root -> val;\\n        int count = lavg.count + ravg.count + 1;\\n\\n        if(avgerage / count == root -> val) ans++;\\n\\n        return {avgerage, count};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        C c = solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass C {\\n    public:\\n    int avg, count;\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    C solve(TreeNode* root) {\\n        if(!root) return {0,0};\\n        C lavg = solve(root -> left);\\n        C ravg = solve(root -> right);\\n\\n        int avgerage = lavg.avg + ravg.avg + root -> val;\\n        int count = lavg.count + ravg.count + 1;\\n\\n        if(avgerage / count == root -> val) ans++;\\n\\n        return {avgerage, count};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        C c = solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661264,
                "title": "16ms-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int x = 0;\\n    pair<int,int> solve(TreeNode* root){\\n        if(root==NULL)return {0,0};\\n        pair<int,int> p1 = solve(root->left);\\n        pair<int,int> p2 = solve(root->right);\\n        int x1 = p1.first+p2.first+root->val;\\n        int y = p1.second+p2.second+1;\\n        if(root->val == (x1/y)){\\n            x++;\\n        }\\n        return {x1,y};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        x = 0;\\n        solve(root);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x = 0;\\n    pair<int,int> solve(TreeNode* root){\\n        if(root==NULL)return {0,0};\\n        pair<int,int> p1 = solve(root->left);\\n        pair<int,int> p2 = solve(root->right);\\n        int x1 = p1.first+p2.first+root->val;\\n        int y = p1.second+p2.second+1;\\n        if(root->val == (x1/y)){\\n            x++;\\n        }\\n        return {x1,y};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        x = 0;\\n        solve(root);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639916,
                "title": "easy-c-simultaneous-dfs-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    bool isLeaf(TreeNode* root){\\n        if(!root->left && !root->right) return true;\\n        return false;\\n    }\\n    \\n    pair<int, int> f(TreeNode* root){  // recursive function of pair type to find sum as well as count the nodes\\n        if(isLeaf(root)){\\n            ans++;\\n            return {root->val, 1};\\n        }\\n        \\n        pair<int, int> f1, f2;\\n        \\n        if(root->left != NULL) f1 = f(root->left);\\n        else f1 = {0, 0};\\n        \\n        if(root->right != NULL) f2 = f(root->right);\\n        else f2 = {0, 0};\\n        \\n        int sum = f1.first + f2.first + root->val;\\n        int cnt = f1.second + f2.second + 1;\\n        if((sum / cnt) == root->val) ans++;\\n        return {sum, cnt};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        auto res = f(root);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    bool isLeaf(TreeNode* root){\\n        if(!root->left && !root->right) return true;\\n        return false;\\n    }\\n    \\n    pair<int, int> f(TreeNode* root){  // recursive function of pair type to find sum as well as count the nodes\\n        if(isLeaf(root)){\\n            ans++;\\n            return {root->val, 1};\\n        }\\n        \\n        pair<int, int> f1, f2;\\n        \\n        if(root->left != NULL) f1 = f(root->left);\\n        else f1 = {0, 0};\\n        \\n        if(root->right != NULL) f2 = f(root->right);\\n        else f2 = {0, 0};\\n        \\n        int sum = f1.first + f2.first + root->val;\\n        int cnt = f1.second + f2.second + 1;\\n        if((sum / cnt) == root->val) ans++;\\n        return {sum, cnt};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        auto res = f(root);\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573521,
                "title": "fastest-ruby-solution-using-simple-dfs",
                "content": "```\\ndef average_of_subtree(root)\\n    @count = 0\\n    dfs root\\n    @count\\nend\\n\\ndef dfs root\\n    return [0, 0] unless root\\n\\n    left_count, left_sum = dfs root.left\\n    right_count, right_sum = dfs root.right\\n\\n    subtree_sum = left_sum + right_sum + root.val\\n    subtree_count = left_count + right_count + 1\\n\\n    @count += 1 if root.val == subtree_sum / subtree_count\\n    [subtree_count, subtree_sum]\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef average_of_subtree(root)\\n    @count = 0\\n    dfs root\\n    @count\\nend\\n\\ndef dfs root\\n    return [0, 0] unless root\\n\\n    left_count, left_sum = dfs root.left\\n    right_count, right_sum = dfs root.right\\n\\n    subtree_sum = left_sum + right_sum + root.val\\n    subtree_count = left_count + right_count + 1\\n\\n    @count += 1 if root.val == subtree_sum / subtree_count\\n    [subtree_count, subtree_sum]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2531357,
                "title": "c-dfs-easy-solution",
                "content": "\\'\\'\\'\\n   \\n    class Solution {\\n    public:\\n   \\n\\t //Time Complexity : O(n) Space Complexity : Recursive Stack space \\n    class Nodes{\\n        public:\\n        int sum;   // Sum of subtree\\n        int subtree;  // Number of nodes in subtree \\n        int count;  // Count of nodes with sum = average of subtree\\n    };\\n    \\n    Nodes helper(TreeNode* root){\\n        //Base Case \\n        if(root==NULL){\\n            Nodes ans;\\n            ans.sum=0;\\n            ans.subtree=0;\\n            ans.count=0;\\n            return ans;\\n        }\\n        \\n        //Recursive Calls \\n        Nodes smallAns1=helper(root->left);\\n        Nodes smallAns2=helper(root->right);\\n        \\n        Nodes ans;\\n        ans.sum=smallAns1.sum+smallAns2.sum+root->val;\\n        ans.subtree=smallAns1.subtree+smallAns2.subtree+1;\\n        ans.count=smallAns1.count+smallAns2.count;\\n        \\n        if(root->val==ans.sum/ans.subtree){\\n            ans.count++;\\n        }\\n        return ans;\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        Nodes ans=helper(root);\\n        return ans.count;\\n    }  \\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n   \\n\\t //Time Complexity : O(n) Space Complexity : Recursive Stack space \\n    class Nodes{\\n        public:\\n        int sum;   // Sum of subtree\\n        int subtree;  // Number of nodes in subtree \\n        int count;  // Count of nodes with sum = average of subtree\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2525832,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    unordered_map<TreeNode*, int> mp;\\n    int countNode(TreeNode* root){\\n        if(root==0)\\n            return 0;\\n        // if(root->left==NULL and root->right==NULL)\\n        //     return 1;\\n        \\n        if(mp.find(root)!=mp.end())\\n            return mp[root];\\n        \\n        return mp[root]=1+countNode(root->left)+countNode(root->right);\\n    }\\n    int helper(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        int l=helper(root->left);\\n        int countL=countNode(root->left);\\n        int r=helper(root->right);\\n        int countR=countNode(root->right);\\n        \\n        int total=countL+countR+1;\\n        // cout<<\"rootval: \"<<root->val<<\" count: \"<<total<<\" countL: \"<<l<<\" countR: \"<<r<<\"\\\\n\";\\n        \\n        int avg=(l+r+root->val)/total;\\n        \\n        if(avg==root->val)\\n            count+=1;\\n        return l+r+root->val;\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        helper(root);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    unordered_map<TreeNode*, int> mp;\\n    int countNode(TreeNode* root){\\n        if(root==0)\\n            return 0;\\n        // if(root->left==NULL and root->right==NULL)\\n        //     return 1;\\n        \\n        if(mp.find(root)!=mp.end())\\n            return mp[root];\\n        \\n        return mp[root]=1+countNode(root->left)+countNode(root->right);\\n    }\\n    int helper(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        int l=helper(root->left);\\n        int countL=countNode(root->left);\\n        int r=helper(root->right);\\n        int countR=countNode(root->right);\\n        \\n        int total=countL+countR+1;\\n        // cout<<\"rootval: \"<<root->val<<\" count: \"<<total<<\" countL: \"<<l<<\" countR: \"<<r<<\"\\\\n\";\\n        \\n        int avg=(l+r+root->val)/total;\\n        \\n        if(avg==root->val)\\n            count+=1;\\n        return l+r+root->val;\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        helper(root);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2525234,
                "title": "simple-recursive-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    pair<int, int> helper(TreeNode *root, int &count)\\n    {\\n        if(root == NULL)\\n        {\\n            return {0,0};\\n        }\\n        pair<int, int> l = helper(root -> left, count);\\n        pair<int, int> r = helper(root -> right, count);\\n        \\n        int no_of_nodes = l.first + r.first + 1;\\n        int sum = l.second + r.second + root -> val;\\n        if(sum/no_of_nodes == root -> val)\\n            count++;\\n        \\n        return {no_of_nodes, sum};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int count = 0;\\n        helper(root, count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    pair<int, int> helper(TreeNode *root, int &count)\\n    {\\n        if(root == NULL)\\n        {\\n            return {0,0};\\n        }\\n        pair<int, int> l = helper(root -> left, count);\\n        pair<int, int> r = helper(root -> right, count);\\n        \\n        int no_of_nodes = l.first + r.first + 1;\\n        int sum = l.second + r.second + root -> val;\\n        if(sum/no_of_nodes == root -> val)\\n            count++;\\n        \\n        return {no_of_nodes, sum};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int count = 0;\\n        helper(root, count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519364,
                "title": "python-clear-dfs-solution",
                "content": "This is a typical DFS Problem, since we want to know something about the subtrees.\\n\\nSince we need the informations about the subtree before we make a decision at the current node, we immediately recursively call the dfs function (after checking there is a subtree). This brings us deeper into the tree.\\n\\nI opted to not use and embedded function with non-locals, since I personally feel like non-locals are hard to grasp/not a good style.\\n\\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        _, _, result = dfs(root)\\n        return result\\n\\ndef dfs(node):\\n    \\n    # root is none therefore we have no sum with and below it\\n    # as well as no valid nodes and now nodes with the condition\\n    if node is None:\\n        return 0, 0, 0\\n    \\n    # go deeper\\n    left_sum, left_amount, left_number = dfs(node.left)\\n    right_sum, right_amount, right_number = dfs(node.right)\\n    \\n    # now we need to compute the new number of nodes that\\n    # met the cindition\\n    number = left_number + right_number\\n    \\n    # calculate the new amount of nodes\\n    new_amount = left_amount + right_amount + 1\\n    \\n    # calculate the new tree sum\\n    new_sum = left_sum + right_sum + node.val\\n    \\n    # check whether our average is equal to our value\\n    if new_sum//new_amount == node.val:\\n        number += 1\\n    \\n    return new_sum, new_amount, number\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        _, _, result = dfs(root)\\n        return result\\n\\ndef dfs(node):\\n    \\n    # root is none therefore we have no sum with and below it\\n    # as well as no valid nodes and now nodes with the condition\\n    if node is None:\\n        return 0, 0, 0\\n    \\n    # go deeper\\n    left_sum, left_amount, left_number = dfs(node.left)\\n    right_sum, right_amount, right_number = dfs(node.right)\\n    \\n    # now we need to compute the new number of nodes that\\n    # met the cindition\\n    number = left_number + right_number\\n    \\n    # calculate the new amount of nodes\\n    new_amount = left_amount + right_amount + 1\\n    \\n    # calculate the new tree sum\\n    new_sum = left_sum + right_sum + node.val\\n    \\n    # check whether our average is equal to our value\\n    if new_sum//new_amount == node.val:\\n        number += 1\\n    \\n    return new_sum, new_amount, number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501660,
                "title": "java-simple-data-holder-without-global-variables-faster-than-98-99",
                "content": "![image](https://assets.leetcode.com/users/images/d9d3122c-57c3-408f-acc9-d03978c893be_1661800653.702938.png)\\n\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n  public int averageOfSubtree(TreeNode root) {\\n    return accumulateTree(root).getTotalEqualsToAvg();\\n  }\\n  \\n  private Data accumulateTree(TreeNode n) {\\n    if (n == null) {\\n      return Data.EMPTY;\\n    }\\n\\n    return accumulateTree(n.left)\\n        .combine(accumulateTree(n.right))\\n        .addValue(n.val);   \\n  }\\n  \\n  static final class Data {\\n    static final Data EMPTY = new Data(0, 0, 0);\\n\\n    private final int sum;\\n    private final int count;\\n    private final int totalEqualsToAvg;\\n\\n    Data(int sum, int count, int totalEqualsToAvg) {\\n      this.sum = sum;\\n      this.count = count;\\n      this.totalEqualsToAvg = totalEqualsToAvg;\\n    }\\n\\n    Data combine(Data other) {\\n      return new Data(\\n          sum + other.sum,\\n          count + other.count,\\n          totalEqualsToAvg + other.totalEqualsToAvg\\n      );\\n    }\\n\\n    Data addValue(int val) {\\n      int newCnt = count + 1;\\n      int newSum = sum + val;\\n      int newTotalEqualsToAvg = totalEqualsToAvg;\\n\\n      int avg = newSum / newCnt;\\n\\n      if (avg == val) {\\n        newTotalEqualsToAvg++;\\n      }\\n\\n      return new Data(newSum, newCnt, newTotalEqualsToAvg);\\n    }\\n\\n    int getTotalEqualsToAvg() {\\n      return totalEqualsToAvg;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n  public int averageOfSubtree(TreeNode root) {\\n    return accumulateTree(root).getTotalEqualsToAvg();\\n  }\\n  \\n  private Data accumulateTree(TreeNode n) {\\n    if (n == null) {\\n      return Data.EMPTY;\\n    }\\n\\n    return accumulateTree(n.left)\\n        .combine(accumulateTree(n.right))\\n        .addValue(n.val);   \\n  }\\n  \\n  static final class Data {\\n    static final Data EMPTY = new Data(0, 0, 0);\\n\\n    private final int sum;\\n    private final int count;\\n    private final int totalEqualsToAvg;\\n\\n    Data(int sum, int count, int totalEqualsToAvg) {\\n      this.sum = sum;\\n      this.count = count;\\n      this.totalEqualsToAvg = totalEqualsToAvg;\\n    }\\n\\n    Data combine(Data other) {\\n      return new Data(\\n          sum + other.sum,\\n          count + other.count,\\n          totalEqualsToAvg + other.totalEqualsToAvg\\n      );\\n    }\\n\\n    Data addValue(int val) {\\n      int newCnt = count + 1;\\n      int newSum = sum + val;\\n      int newTotalEqualsToAvg = totalEqualsToAvg;\\n\\n      int avg = newSum / newCnt;\\n\\n      if (avg == val) {\\n        newTotalEqualsToAvg++;\\n      }\\n\\n      return new Data(newSum, newCnt, newTotalEqualsToAvg);\\n    }\\n\\n    int getTotalEqualsToAvg() {\\n      return totalEqualsToAvg;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469878,
                "title": "java-solution-recursion",
                "content": "Working with subtrees recursively.\\n- Finds recursively sum of left subtree\\'s values, then does the same for right subtree.\\n- Finds recursively number of left subtree\\'s nodes, then does the same for right subtree.\\n- Calculate the average and compare with node\\'s value. If equal, then add to global count.\\n```\\nclass Solution {\\n    static int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        count = 0;\\n        traverseToCount(root);\\n        return count;\\n    }\\n    \\n    private void traverseToCount(TreeNode root) {\\n        if (root == null) return;\\n\\n        int sumLeft = traverseToFindSum(root.left);\\n        int sumRight = traverseToFindSum(root.right);\\n        int countLeft = traverseToFindNum(root.left);\\n        int countRight = traverseToFindNum(root.right);\\n\\n        int avg = (sumLeft + sumRight + root.val) / (countLeft + countRight + 1);\\n        if (avg == root.val) {\\n            count++;\\n        }\\n\\n        traverseToCount(root.left);\\n        traverseToCount(root.right);\\n    }\\n    \\n    private int traverseToFindSum(TreeNode root) {\\n        if (root == null) return 0;\\n\\n        return root.val + traverseToFindSum(root.left) + traverseToFindSum(root.right);\\n    }\\n\\n    private int traverseToFindNum(TreeNode root) {\\n        if (root == null) return 0;\\n\\n        return 1 + traverseToFindNum(root.left) + traverseToFindNum(root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        count = 0;\\n        traverseToCount(root);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2423075,
                "title": "c-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        if (!root)\\n            return 0;\\n        \\n        int res = 0;\\n        \\n        res += averageOfSubtree(root->left);\\n        if (root->val == average(root))\\n            res++;\\n        res += averageOfSubtree(root->right);\\n        \\n        return res;\\n    }\\nprivate:\\n    int average(TreeNode* root)\\n    {\\n        std::pair<int, int> count;\\n        counting(root, count);\\n        return count.first / count.second;\\n    }\\n    \\n    void counting(TreeNode* root, std::pair<int, int>& res)\\n    {\\n        if (!root)\\n            return;\\n        \\n        counting(root->left, res);\\n        res.first += root->val;\\n        res.second++;\\n        counting(root->right, res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        if (!root)\\n            return 0;\\n        \\n        int res = 0;\\n        \\n        res += averageOfSubtree(root->left);\\n        if (root->val == average(root))\\n            res++;\\n        res += averageOfSubtree(root->right);\\n        \\n        return res;\\n    }\\nprivate:\\n    int average(TreeNode* root)\\n    {\\n        std::pair<int, int> count;\\n        counting(root, count);\\n        return count.first / count.second;\\n    }\\n    \\n    void counting(TreeNode* root, std::pair<int, int>& res)\\n    {\\n        if (!root)\\n            return;\\n        \\n        counting(root->left, res);\\n        res.first += root->val;\\n        res.second++;\\n        counting(root->right, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414499,
                "title": "easy-c-dfs-count-nodes-equal-to-average-of-subtree",
                "content": "we can maintain a pair at each node which contain the * {sum of nodes of  subtree,number of nodes at each subtree}*\\n```\\nclass Solution {\\npublic:\\n    int count=0;\\n    pair<int,int> helper(TreeNode* root){\\n        if(!root)return pair{0,0};\\n        pair<int,int> l=helper(root->left);\\n        pair<int,int> r=helper(root->right);\\n        if((l.first+r.first+root->val)/(l.second+r.second+1)==root->val)count++;\\n        return pair{l.first+r.first+root->val,l.second+r.second+1};\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        if(!root)return 0;\\n        helper(root);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    pair<int,int> helper(TreeNode* root){\\n        if(!root)return pair{0,0};\\n        pair<int,int> l=helper(root->left);\\n        pair<int,int> r=helper(root->right);\\n        if((l.first+r.first+root->val)/(l.second+r.second+1)==root->val)count++;\\n        return pair{l.first+r.first+root->val,l.second+r.second+1};\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        if(!root)return 0;\\n        helper(root);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404195,
                "title": "0ms-o-n-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int averageOfSubtree(TreeNode root) {\\n        // 0 -> stores count\\n        int[] count = new int[1];\\n        findAverage(root, count);\\n        return count[0];\\n    }\\n    \\n    public Pair findAverage(TreeNode root, int[] c) {\\n        if(root == null) return null;\\n        Pair left = findAverage(root.left, c);\\n        Pair right = findAverage(root.right, c);\\n        int sum = 0, count = 0;\\n        \\n        if(left == null && right == null) {\\n                c[0]++;\\n                return new Pair(root.val, 1);\\n        } else if(left != null && right != null) {\\n            sum += left.sum + right.sum + root.val;\\n            count += left.count + right.count + 1;\\n            if(root.val == (sum/count)) {\\n                c[0]++;\\n            }\\n            return new Pair(sum, count);\\n        } else {\\n            sum += root.val;\\n            count += 1;\\n            if(left == null) {\\n                sum += right.sum;\\n                count += right.count;\\n            } else {\\n                sum += left.sum;\\n                count += left.count;\\n            }\\n             if(root.val == (sum/count)) {\\n                c[0]++;\\n            }\\n            return new Pair(sum, count);\\n        }\\n    }\\n    \\n    class Pair {\\n        int sum;\\n        int count;\\n        \\n        Pair(int s, int c) {\\n            this.sum = s;\\n            this.count = c;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int averageOfSubtree(TreeNode root) {\\n        // 0 -> stores count\\n        int[] count = new int[1];\\n        findAverage(root, count);\\n        return count[0];\\n    }\\n    \\n    public Pair findAverage(TreeNode root, int[] c) {\\n        if(root == null) return null;\\n        Pair left = findAverage(root.left, c);\\n        Pair right = findAverage(root.right, c);\\n        int sum = 0, count = 0;\\n        \\n        if(left == null && right == null) {\\n                c[0]++;\\n                return new Pair(root.val, 1);\\n        } else if(left != null && right != null) {\\n            sum += left.sum + right.sum + root.val;\\n            count += left.count + right.count + 1;\\n            if(root.val == (sum/count)) {\\n                c[0]++;\\n            }\\n            return new Pair(sum, count);\\n        } else {\\n            sum += root.val;\\n            count += 1;\\n            if(left == null) {\\n                sum += right.sum;\\n                count += right.count;\\n            } else {\\n                sum += left.sum;\\n                count += left.count;\\n            }\\n             if(root.val == (sum/count)) {\\n                c[0]++;\\n            }\\n            return new Pair(sum, count);\\n        }\\n    }\\n    \\n    class Pair {\\n        int sum;\\n        int count;\\n        \\n        Pair(int s, int c) {\\n            this.sum = s;\\n            this.count = c;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377476,
                "title": "easy-python-dfs-o-n-solution-p",
                "content": "```\\nres = [0]\\n        \\n        def dfs(root):\\n            if not root:\\n                return [0,0]\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            size = 1+left[0]+right[0]\\n            maxsum = root.val+left[1]+right[1]\\n            if maxsum//size == root.val:\\n                res[0]+=1\\n            return [size,maxsum]\\n        dfs(root)\\n        return res[0]",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nres = [0]\\n        \\n        def dfs(root):\\n            if not root:\\n                return [0,0]\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            size = 1+left[0]+right[0]\\n            maxsum = root.val+left[1]+right[1]\\n            if maxsum//size == root.val:\\n                res[0]+=1\\n            return [size,maxsum]\\n        dfs(root)\\n        return res[0]",
                "codeTag": "Python3"
            },
            {
                "id": 2376969,
                "title": "python-sum-and-count-from-each-node-dfs",
                "content": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.count = 0\\n        def dfs(root):\\n\\t\\t\\t# if node is None, sum and count will be 0, 0\\n            if not root:\\n                return 0, 0\\n            \\n            if not root.left and not root.right:\\n                self.count += 1\\n                return root.val, 1\\n            \\n\\t\\t\\t# Sum of nodes in subtree, and count of nodes\\n            left, nl = dfs(root.left)\\n            right, nr = dfs(root.right)\\n            \\n            if (left + right + root.val) // (nl + nr + 1)   == root.val:\\n                self.count += 1\\n            return left + right + root.val, (nl + nr + 1)\\n        dfs(root)\\n        return self.count\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.count = 0\\n        def dfs(root):\\n\\t\\t\\t# if node is None, sum and count will be 0, 0\\n            if not root:\\n                return 0, 0\\n            \\n            if not root.left and not root.right:\\n                self.count += 1\\n                return root.val, 1\\n            \\n\\t\\t\\t# Sum of nodes in subtree, and count of nodes\\n            left, nl = dfs(root.left)\\n            right, nr = dfs(root.right)\\n            \\n            if (left + right + root.val) // (nl + nr + 1)   == root.val:\\n                self.count += 1\\n            return left + right + root.val, (nl + nr + 1)\\n        dfs(root)\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372131,
                "title": "c-recursive-solution-o-n",
                "content": "* Here ```no``` is for total no of nodes \\n* ```ans``` is for total no of nodes whose avg is equal to avg of subtree\\n* ```sum``` is sum of it subtree\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass avg{\\n    public:\\n    int no;\\n    int ans;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    avg helper(TreeNode* root){\\n        avg a1;\\n        if(root==NULL){\\n            a1.no=0;\\n            a1.ans=0;\\n            a1.sum=0;\\n            return a1;\\n        }\\n        avg left=helper(root->left);\\n        avg right=helper(root->right);\\n        a1.no=1+left.no+right.no; //6\\n        a1.sum=root->val+left.sum+right.sum; //24\\n        int avg=(a1.sum)/(double)(a1.no);\\n        a1.ans=left.ans+right.ans;\\n        if(avg==root->val)\\n            a1.ans+=1;\\n        return a1;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        return helper(root).ans;\\n    }\\n};\\n```\\nI hope U got\\nUpvote if u find it helpful",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```no```\n```ans```\n```sum```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass avg{\\n    public:\\n    int no;\\n    int ans;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    avg helper(TreeNode* root){\\n        avg a1;\\n        if(root==NULL){\\n            a1.no=0;\\n            a1.ans=0;\\n            a1.sum=0;\\n            return a1;\\n        }\\n        avg left=helper(root->left);\\n        avg right=helper(root->right);\\n        a1.no=1+left.no+right.no; //6\\n        a1.sum=root->val+left.sum+right.sum; //24\\n        int avg=(a1.sum)/(double)(a1.no);\\n        a1.ans=left.ans+right.ans;\\n        if(avg==root->val)\\n            a1.ans+=1;\\n        return a1;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        return helper(root).ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369811,
                "title": "c-recursive-o-n-solution-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\t\\n\\t// Returns {sum of values in its subtree, no.of nodes in its subtree}\\n    pair<int,int> helper(TreeNode *root){\\n        if(root == NULL){\\n            return {0, 0};\\n        }\\n\\t\\t\\n\\t\\t// Moving to left and right subtrees\\n        pair<int,int> lst = helper(root->left);\\n        pair<int,int> rst = helper(root->right);\\n\\t\\t\\n\\t\\t// Find sum and no.of nodes by adding left and right subtree values\\n        int sum = root->val + lst.first + rst.first;\\n        int n = 1 + lst.second + rst.second;\\n\\t\\t\\n        if(sum/n == root->val){\\n            ans++;\\n        }\\n        return {sum, n};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\t\\n\\t// Returns {sum of values in its subtree, no.of nodes in its subtree}\\n    pair<int,int> helper(TreeNode *root){\\n        if(root == NULL){\\n            return {0, 0};\\n        }\\n\\t\\t\\n\\t\\t// Moving to left and right subtrees\\n        pair<int,int> lst = helper(root->left);\\n        pair<int,int> rst = helper(root->right);\\n\\t\\t\\n\\t\\t// Find sum and no.of nodes by adding left and right subtree values\\n        int sum = root->val + lst.first + rst.first;\\n        int n = 1 + lst.second + rst.second;\\n\\t\\t\\n        if(sum/n == root->val){\\n            ans++;\\n        }\\n        return {sum, n};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2354308,
                "title": "java-simple-recursion-clean-code",
                "content": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        countSum(root);\\n        return res;\\n    }\\n     \\n    public Pair<Integer, Integer> countSum(TreeNode root) {\\n        \\n        if(root == null) return new Pair<>(0, 0);\\n        \\n        final Pair<Integer, Integer> left = countSum(root.left);\\n        final Pair<Integer, Integer> right = countSum(root.right);\\n        \\n        final int totalSum = root.val + left.getKey() + right.getKey();\\n        final int totalCount = 1 + left.getValue() + right.getValue();\\n        \\n        if (root.val == totalSum/totalCount) res++;\\n        \\n        return new Pair<>(totalSum, totalCount);\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    int res = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        countSum(root);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2353349,
                "title": "for-a-beginner-by-a-beginner-simple-c-solution",
                "content": "**If this solution helps you in any way then please consider upvoting**\\n\\nstep 1 - make a pair whose .first will store the sum of nodes\\' values below it and .second will store the no of nodes below this node including it.\\nOne of the ways of translating it to code is given below be calms and first try it by yourself as you got the approach, even then if you can\\'t figure it out the you can see the solution :) **HAPPY LEARNING** \\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int averageOfSubtree(TreeNode* root) {\\n        if(!root) return ans;\\n        helper(root, {0,0});\\n        return ans;\\n        \\n    }\\n    pair<int,int> helper(TreeNode*root, pair<int,int>pr){   //here n is the number of nodes\\n        // pair<int,int> p = {0,0};\\n        if(!root) return {0,0};\\n        \\n        auto l = helper(root->left, pr);\\n        auto r = helper(root->right, pr);\\n        \\n        if((l.first+r.first + root->val)/(l.second + r.second +1) == root->val) ans++;\\n        return {l.first + r.first+root->val, r.second+ l.second+1};\\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int averageOfSubtree(TreeNode* root) {\\n        if(!root) return ans;\\n        helper(root, {0,0});\\n        return ans;\\n        \\n    }\\n    pair<int,int> helper(TreeNode*root, pair<int,int>pr){   //here n is the number of nodes\\n        // pair<int,int> p = {0,0};\\n        if(!root) return {0,0};\\n        \\n        auto l = helper(root->left, pr);\\n        auto r = helper(root->right, pr);\\n        \\n        if((l.first+r.first + root->val)/(l.second + r.second +1) == root->val) ans++;\\n        return {l.first + r.first+root->val, r.second+ l.second+1};\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339281,
                "title": "simple-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* root,int &ans){\\n        int sum=0;\\n        if(root)    sum=(root->val*1000)+1;\\n        \\n        if(root->left)  sum+=dfs(root->left, ans);\\n        if(root->right) sum+=dfs(root->right, ans);\\n        \\n        if((sum/1000)/((sum%1000)==0?1000:(sum%1000))==root->val)    ans++;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* root,int &ans){\\n        int sum=0;\\n        if(root)    sum=(root->val*1000)+1;\\n        \\n        if(root->left)  sum+=dfs(root->left, ans);\\n        if(root->right) sum+=dfs(root->right, ans);\\n        \\n        if((sum/1000)/((sum%1000)==0?1000:(sum%1000))==root->val)    ans++;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330209,
                "title": "c-simple-solution-post-order-modification",
                "content": "**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n```\\nclass Solution {\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        calculate(root,ans);\\n        return ans;\\n    }\\n    \\n    vector<int> calculate(TreeNode* root, int & ans ){\\n        if(!root)  return {0,0};\\n        vector<int> left = calculate(root->left,ans);\\n        vector<int> right = calculate(root->right,ans);\\n        int sum,count;\\n        sum = left[0]+right[0]+root->val;\\n        count = left[1]+right[1]+1;\\n        if(sum/count==root->val) ans++;\\n        \\n        return {sum,count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        int ans=0;\\n        calculate(root,ans);\\n        return ans;\\n    }\\n    \\n    vector<int> calculate(TreeNode* root, int & ans ){\\n        if(!root)  return {0,0};\\n        vector<int> left = calculate(root->left,ans);\\n        vector<int> right = calculate(root->right,ans);\\n        int sum,count;\\n        sum = left[0]+right[0]+root->val;\\n        count = left[1]+right[1]+1;\\n        if(sum/count==root->val) ans++;\\n        \\n        return {sum,count};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300041,
                "title": "java-runtime-1ms-time-o-n-space-o-log-n",
                "content": "```\\nclass Solution {\\n    private int count = 0 ;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        if (root == null) {\\n            return count ;\\n        }\\n        \\n        PostOrder(root) ;\\n        return count ;\\n    }\\n    \\n    public int[] PostOrder (TreeNode root) {\\n        if (root == null) {\\n            return new int[] {0,0} ;\\n        }\\n        \\n        int[] left = PostOrder(root.left) ;\\n        int[] right = PostOrder(root.right) ;\\n        \\n        int totalSum = left[0] + right[0] + root.val ;\\n        int nodeCount = left[1] + right[1] + 1 ;\\n        int avg = totalSum/nodeCount ;\\n        \\n        if (avg == root.val) {\\n            count++ ;\\n        }\\n        \\n        return new int[] {totalSum, nodeCount} ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int count = 0 ;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        if (root == null) {\\n            return count ;\\n        }\\n        \\n        PostOrder(root) ;\\n        return count ;\\n    }\\n    \\n    public int[] PostOrder (TreeNode root) {\\n        if (root == null) {\\n            return new int[] {0,0} ;\\n        }\\n        \\n        int[] left = PostOrder(root.left) ;\\n        int[] right = PostOrder(root.right) ;\\n        \\n        int totalSum = left[0] + right[0] + root.val ;\\n        int nodeCount = left[1] + right[1] + 1 ;\\n        int avg = totalSum/nodeCount ;\\n        \\n        if (avg == root.val) {\\n            count++ ;\\n        }\\n        \\n        return new int[] {totalSum, nodeCount} ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290143,
                "title": "c-o-n-dfs-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int ans=0;\\n    vector<int> helper(TreeNode* node)\\n    {\\n        if(!node)\\n            return {0, 0};\\n        \\n        int currSum=node->val;\\n        int currN=1;\\n        \\n        vector<int> left=helper(node->left);\\n        vector<int> right=helper(node->right);\\n        \\n        currSum+=left[0]+right[0];\\n        currN+=left[1]+right[1];\\n        \\n        int avg=currSum/currN;\\n        if(avg==node->val)\\n            ans++;\\n        \\n        return {currSum, currN};\\n    }\\n    \\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        ans=0;\\n        vector<int> v=helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int ans=0;\\n    vector<int> helper(TreeNode* node)\\n    {\\n        if(!node)\\n            return {0, 0};\\n        \\n        int currSum=node->val;\\n        int currN=1;\\n        \\n        vector<int> left=helper(node->left);\\n        vector<int> right=helper(node->right);\\n        \\n        currSum+=left[0]+right[0];\\n        currN+=left[1]+right[1];\\n        \\n        int avg=currSum/currN;\\n        if(avg==node->val)\\n            ans++;\\n        \\n        return {currSum, currN};\\n    }\\n    \\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        ans=0;\\n        vector<int> v=helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288239,
                "title": "python-simple-recursion-with-explanation-beats-95",
                "content": "```\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.output=0 #count number of nodes with values same as average\\n        \\n        def recur(root):\\n            if root:\\n                left_count,left_s=recur(root.left) #getting number of nodes and sum of left sub tree\\n                right_count,right_s=recur(root.right) #getting number of nodes and sum of right sub tree\\n\\n                avg=(left_s+right_s+root.val)//(left_count+right_count+1) #calculating the average\\n                if root.val==avg:\\n                    self.output+=1\\n                \\n                return left_count+right_count+1,left_s+right_s+root.val #returning the sum and count of the given subtree. \\n            return 0,0 # if root is none then return sum=0 and count=0\\n        \\n        recur(root) #calling the function\\n        return self.output\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.output=0 #count number of nodes with values same as average\\n        \\n        def recur(root):\\n            if root:\\n                left_count,left_s=recur(root.left) #getting number of nodes and sum of left sub tree\\n                right_count,right_s=recur(root.right) #getting number of nodes and sum of right sub tree\\n\\n                avg=(left_s+right_s+root.val)//(left_count+right_count+1) #calculating the average\\n                if root.val==avg:\\n                    self.output+=1\\n                \\n                return left_count+right_count+1,left_s+right_s+root.val #returning the sum and count of the given subtree. \\n            return 0,0 # if root is none then return sum=0 and count=0\\n        \\n        recur(root) #calling the function\\n        return self.output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2256009,
                "title": "python-recursive-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        # Global counter that will count the Nodes that \\n        # satisfies the necessary condition.\\n        self.resultCnt = 0;\\n\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.averageIsEqualNodeValue(node=root)\\n        return self.resultCnt\\n\\n    # A recursive function to traverse the binary tree\\n    # It returns a Tuple of 2 integers: the first integer represents sum of Node\\n    # values under the given TreeNode. The second integer represents total number\\n    # of nodes that exist under the given TreeNode.\\n    def averageIsEqualNodeValue(self, node: Optional[TreeNode]) -> Tuple[int, int]:\\n        l_value = (0, 0)\\n        r_value = (0, 0)\\n        if (node.left):\\n            # If a TreeNode has a left branch traverse down recursively\\n            l_value = self.averageIsEqualNodeValue(node.left)\\n\\n        if (node.right):\\n            # If a TreeNode has a right branch traverse down recursively\\n            r_value = self.averageIsEqualNodeValue(node.right)\\n\\n        # Check the condition to be satisfied.\\n        # Convert the result of the floating point division to int to round \\n        # down\\n        if (int((node.val + l_value[0] + r_value[0]) / (1 + l_value[1] + r_value[1])) == node.val):\\n            # Increase the global counter\\n            self.resultCnt += 1\\n\\n        # Return the Tuple[int, int]\\n        return (l_value[0] + r_value[0] + node.val, l_value[1] + r_value[1] + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        # Global counter that will count the Nodes that \\n        # satisfies the necessary condition.\\n        self.resultCnt = 0;\\n\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.averageIsEqualNodeValue(node=root)\\n        return self.resultCnt\\n\\n    # A recursive function to traverse the binary tree\\n    # It returns a Tuple of 2 integers: the first integer represents sum of Node\\n    # values under the given TreeNode. The second integer represents total number\\n    # of nodes that exist under the given TreeNode.\\n    def averageIsEqualNodeValue(self, node: Optional[TreeNode]) -> Tuple[int, int]:\\n        l_value = (0, 0)\\n        r_value = (0, 0)\\n        if (node.left):\\n            # If a TreeNode has a left branch traverse down recursively\\n            l_value = self.averageIsEqualNodeValue(node.left)\\n\\n        if (node.right):\\n            # If a TreeNode has a right branch traverse down recursively\\n            r_value = self.averageIsEqualNodeValue(node.right)\\n\\n        # Check the condition to be satisfied.\\n        # Convert the result of the floating point division to int to round \\n        # down\\n        if (int((node.val + l_value[0] + r_value[0]) / (1 + l_value[1] + r_value[1])) == node.val):\\n            # Increase the global counter\\n            self.resultCnt += 1\\n\\n        # Return the Tuple[int, int]\\n        return (l_value[0] + r_value[0] + node.val, l_value[1] + r_value[1] + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220154,
                "title": "python-dfs-o-n-complexity",
                "content": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        count = [0]\\n        def dfs(node):\\n            if not node:\\n                return [0,0]\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            summ = left[0] + right[0] + node.val\\n            numnodes = left[1] + right[1] + 1\\n            if summ//numnodes == node.val:\\n                count[0] +=1\\n            return [summ, numnodes]\\n        dfs(root)\\n        \\n        return count[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        count = [0]\\n        def dfs(node):\\n            if not node:\\n                return [0,0]\\n            left = dfs(node.left)\\n            right = dfs(node.right)\\n            summ = left[0] + right[0] + node.val\\n            numnodes = left[1] + right[1] + 1\\n            if summ//numnodes == node.val:\\n                count[0] +=1\\n            return [summ, numnodes]\\n        dfs(root)\\n        \\n        return count[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211325,
                "title": "c-solution-2-degree-dfs-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void sum_trav(TreeNode *root, int *sum, int *counter)\\n    {\\n        if(root == NULL) return;\\n        \\n        *counter += 1;\\n        *sum += root->val;\\n        sum_trav(root->left, sum, counter);\\n        sum_trav(root->right, sum, counter);\\n    }\\n    \\n    void recur_tree(TreeNode *root, int *count)\\n    {\\n        if(root == NULL) return;\\n        \\n        float avg = 0;\\n        int sum = 0;\\n        int counter = 0;\\n        \\n        sum_trav(root, &sum, &counter);\\n        \\n        avg = (sum)/(counter);\\n        \\n        if(root->val == round(avg))\\n        {\\n            *count += 1;\\n        }\\n        \\n        recur_tree(root->left, count);\\n        recur_tree(root->right, count);\\n        \\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        int count = 0;\\n        \\n        recur_tree(root, &count);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void sum_trav(TreeNode *root, int *sum, int *counter)\\n    {\\n        if(root == NULL) return;\\n        \\n        *counter += 1;\\n        *sum += root->val;\\n        sum_trav(root->left, sum, counter);\\n        sum_trav(root->right, sum, counter);\\n    }\\n    \\n    void recur_tree(TreeNode *root, int *count)\\n    {\\n        if(root == NULL) return;\\n        \\n        float avg = 0;\\n        int sum = 0;\\n        int counter = 0;\\n        \\n        sum_trav(root, &sum, &counter);\\n        \\n        avg = (sum)/(counter);\\n        \\n        if(root->val == round(avg))\\n        {\\n            *count += 1;\\n        }\\n        \\n        recur_tree(root->left, count);\\n        recur_tree(root->right, count);\\n        \\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        int count = 0;\\n        \\n        recur_tree(root, &count);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194728,
                "title": "c-code-using-post-order-traversal-easy-solution",
                "content": "```\\nclass Solution {\\n    int total=0;\\n    pair<int,int> count(TreeNode *root)\\n    {\\n\\t//Base condition to check leaf node and they will retun a pair(0,0) signifies sum and height of subtree as zero \\n        if (root==NULL)\\n        {\\n            return {0,0};\\n        }\\n        // We created a pair of which 1st integer represents size of subtree and second value represents sum of subtree.\\n        pair<int,int> left=count(root->left);\\n        pair<int,int> right=count(root->right);\\n        //The above is post order traversal technique\\n        \\n\\t\\t\\n\\t\\t//we added 1 to include the parent node\\n        int temp=1+left.first+right.first;\\n        int s=left.second+right.second+root->val;\\n\\t\\t\\n\\t\\t//Checking condition that if height and sum of subtree is equal then increment our answer\\n        if (s/temp==root->val)\\n        {\\n            total++;\\n        }\\n        \\n        return {temp,s};\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        count(root);\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int total=0;\\n    pair<int,int> count(TreeNode *root)\\n    {\\n\\t//Base condition to check leaf node and they will retun a pair(0,0) signifies sum and height of subtree as zero \\n        if (root==NULL)\\n        {\\n            return {0,0};\\n        }\\n        // We created a pair of which 1st integer represents size of subtree and second value represents sum of subtree.\\n        pair<int,int> left=count(root->left);\\n        pair<int,int> right=count(root->right);\\n        //The above is post order traversal technique\\n        \\n\\t\\t\\n\\t\\t//we added 1 to include the parent node\\n        int temp=1+left.first+right.first;\\n        int s=left.second+right.second+root->val;\\n\\t\\t\\n\\t\\t//Checking condition that if height and sum of subtree is equal then increment our answer\\n        if (s/temp==root->val)\\n        {\\n            total++;\\n        }\\n        \\n        return {temp,s};\\n    }\\npublic:\\n    int averageOfSubtree(TreeNode* root) {\\n        count(root);\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193480,
                "title": "python-dfs-classic-post-order-traversal",
                "content": "Simple Post order DFS. Leaf nodes always increment the total global count of nodes == avg of subtree.\\nWe just need to keep track of the current subtree sum and the subtree num nodes. When the current node val == subtree avg. Increment the answer\\n\\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        # return (numNodes, cursum)\\n        _, _, ans = self.recurse(root)\\n        #O(n)time #O(logn)space \\n        return ans\\n    \\n    def recurse(self, node):\\n        if not node:\\n            return (0,0,0)\\n        \\n        if not node.left and not node.right:\\n            # leaf node\\n            return (1, node.val, 1)\\n        lcount, lsum, lans = self.recurse(node.left)\\n        rcount, rsum, rans = self.recurse(node.right)\\n        \\n        cursum = lsum + rsum + node.val\\n        curcount = lcount + rcount + 1\\n        curans = lans + rans\\n        if node.val == (floor(cursum/curcount)):\\n            curans+=1\\n        \\n        return (curcount, cursum, curans)\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        # return (numNodes, cursum)\\n        _, _, ans = self.recurse(root)\\n        #O(n)time #O(logn)space \\n        return ans\\n    \\n    def recurse(self, node):\\n        if not node:\\n            return (0,0,0)\\n        \\n        if not node.left and not node.right:\\n            # leaf node\\n            return (1, node.val, 1)\\n        lcount, lsum, lans = self.recurse(node.left)\\n        rcount, rsum, rans = self.recurse(node.right)\\n        \\n        cursum = lsum + rsum + node.val\\n        curcount = lcount + rcount + 1\\n        curans = lans + rans\\n        if node.val == (floor(cursum/curcount)):\\n            curans+=1\\n        \\n        return (curcount, cursum, curans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170197,
                "title": "python-dfs-very-easy-to-understand-do-not-click",
                "content": "CODE:\\n\\n```\\n\\t\\tdef helper(root):\\n            nonlocal c\\n            if not root: return (0,0)\\n            l,r=helper(root.left),helper(root.right)\\n            tempSum=l[0]+r[0]+root.val\\n            tempCount=l[1]+r[1]+1\\n            if tempSum//tempCount==root.val: c+=1    \\n            return (tempSum,tempCount)   \\n        c=0\\n        helper(root)\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tdef helper(root):\\n            nonlocal c\\n            if not root: return (0,0)\\n            l,r=helper(root.left),helper(root.right)\\n            tempSum=l[0]+r[0]+root.val\\n            tempCount=l[1]+r[1]+1\\n            if tempSum//tempCount==root.val: c+=1    \\n            return (tempSum,tempCount)   \\n        c=0\\n        helper(root)\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2166411,
                "title": "python-recursive-faster-than-91",
                "content": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.output = 0\\n        \\n        def recurse(root):\\n            if not root:\\n                return 0, 0\\n\\n            left_sum, left_num = recurse(root.left)\\n            right_sum, right_num = recurse(root.right)\\n            \\n            total_sum = root.val + left_sum + right_sum\\n            num_sub = 1 + left_num + right_num\\n            \\n            if total_sum // num_sub == root.val:\\n                self.output += 1\\n                \\n            return total_sum, num_sub\\n        \\n        recurse(root)\\n        \\n        return self.output",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.output = 0\\n        \\n        def recurse(root):\\n            if not root:\\n                return 0, 0\\n\\n            left_sum, left_num = recurse(root.left)\\n            right_sum, right_num = recurse(root.right)\\n            \\n            total_sum = root.val + left_sum + right_sum\\n            num_sub = 1 + left_num + right_num\\n            \\n            if total_sum // num_sub == root.val:\\n                self.output += 1\\n                \\n            return total_sum, num_sub\\n        \\n        recurse(root)\\n        \\n        return self.output",
                "codeTag": "Java"
            },
            {
                "id": 2162504,
                "title": "1ms-java-code",
                "content": "class Solution {\\n    int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        count=0;\\n        int[] temp = dfs(root);\\n        return count;\\n        \\n    }\\n    \\n    public int[] dfs(TreeNode head){\\n        if(head==null){\\n            return new int[]{0,0};\\n        }\\n        int[] l = dfs(head.left);\\n        int[] r = dfs(head.right);\\n        \\n        l[0] = l[0] + head.val + r[0];\\n        l[1] = l[1] + 1 + r[1];\\n        if(head.val==(l[0]/l[1])){\\n            count++;\\n        }\\n        return l;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int count;\\n    public int averageOfSubtree(TreeNode root) {\\n        count=0;\\n        int[] temp = dfs(root);\\n        return count;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2158456,
                "title": "javascript",
                "content": "```\\nvar averageOfSubtree = function(root) {\\n    let counter = 0;\\n    recur(root)\\n    return counter;\\n    \\n    \\n    // use array to store sum and count at each recursions\\n    function recur(root) {\\n        // base case [sum, count] = [0, 0]\\n        if (!root) return [0, 0]\\n        \\n        const left = recur(root.left)\\n        const right = recur(root.right)\\n        const sum = root.val + left[0] + right[0]\\n        const count = 1 + left[1] + right[1]\\n        \\n        if (Math.floor(sum/count) === root.val) counter++\\n        return [sum, count]\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar averageOfSubtree = function(root) {\\n    let counter = 0;\\n    recur(root)\\n    return counter;\\n    \\n    \\n    // use array to store sum and count at each recursions\\n    function recur(root) {\\n        // base case [sum, count] = [0, 0]\\n        if (!root) return [0, 0]\\n        \\n        const left = recur(root.left)\\n        const right = recur(root.right)\\n        const sum = root.val + left[0] + right[0]\\n        const count = 1 + left[1] + right[1]\\n        \\n        if (Math.floor(sum/count) === root.val) counter++\\n        return [sum, count]\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2143559,
                "title": "java-tc-o-n-sc-o-1-single-postorder-traversal-using-array-as-tuple",
                "content": "```\\nlass Solution {\\n\\t// Returned array 0th index will stores\\t: SubtreeSum[Including Root\\'s Value]\\n\\t// Returned array 1st index will stores\\t: Total Number of nodes in Subtree[Root Counted]\\n\\t// Returned array 2nd index will stores\\t: Number of required nodes[Actually Stores what Problem Statement want]\\n\\t//\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  in the current Subtree\\n\\tprivate int[] utility(TreeNode root) {\\n\\t\\tif(root             == null) return new int[]{0, 0, 0};\\n\\t\\tint[] lp            = utility(root.left);\\n\\t\\tint[] rp            = utility(root.right);\\n\\t\\tint totNodes        = 1 + lp[1] + rp[1];\\n\\t\\tint subtreeSum      = root.val + lp[0] + rp[0];\\n\\t\\tint ansCnt          = lp[2] + rp[2];\\n\\t\\tint[] tuple         = new int[]{subtreeSum, totNodes, ansCnt};\\n\\t\\tint avg             = subtreeSum / totNodes;\\n\\t\\tif(avg              == root.val) tuple[2] += 1;\\n\\t\\treturn tuple;\\n\\t}\\n\\n\\tpublic int averageOfSubtree(TreeNode root) {\\n\\t\\treturn utility(root)[2];\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlass Solution {\\n\\t// Returned array 0th index will stores\\t: SubtreeSum[Including Root\\'s Value]\\n\\t// Returned array 1st index will stores\\t: Total Number of nodes in Subtree[Root Counted]\\n\\t// Returned array 2nd index will stores\\t: Number of required nodes[Actually Stores what Problem Statement want]\\n\\t//\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  in the current Subtree\\n\\tprivate int[] utility(TreeNode root) {\\n\\t\\tif(root             == null) return new int[]{0, 0, 0};\\n\\t\\tint[] lp            = utility(root.left);\\n\\t\\tint[] rp            = utility(root.right);\\n\\t\\tint totNodes        = 1 + lp[1] + rp[1];\\n\\t\\tint subtreeSum      = root.val + lp[0] + rp[0];\\n\\t\\tint ansCnt          = lp[2] + rp[2];\\n\\t\\tint[] tuple         = new int[]{subtreeSum, totNodes, ansCnt};\\n\\t\\tint avg             = subtreeSum / totNodes;\\n\\t\\tif(avg              == root.val) tuple[2] += 1;\\n\\t\\treturn tuple;\\n\\t}\\n\\n\\tpublic int averageOfSubtree(TreeNode root) {\\n\\t\\treturn utility(root)[2];\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2143316,
                "title": "beginner-friendly-solution-with-explanation",
                "content": "Initially the problems looks hard,until you come across the idea that you need to return multiple values from the recursion that you will use for travesering the tree.\\nWe need two thing to calculate the average of the subtree at a particular Node.\\n1. The sum of left subtree and right subtree. (Nominator)\\n2. The number of nodes in left and right subtree.(Denominator)\\n\\nNow that you know what values you need to calculate if the average is equal to root value (i.e Nominator &  Denominator).We can add the logic in the dfs traversal.\\n\\n```\\npublic int averageOfSubtree(TreeNode root) {\\n        int[] noOfNodes = new int[1]; // passing by reference\\n        noOfNodes[0] = 0;\\n        avgSubtree(root, noOfNodes);\\n        return noOfNodes[0];\\n        \\n    }\\n    public Pair avgSubtree(TreeNode root,int[] noOfNodes){\\n        if(root == null) return new Pair(0,0); // Base case -> return sum as 0 and count of nodes as 0\\n        Pair left = avgSubtree(root.left,noOfNodes);\\n        Pair right = avgSubtree(root.right,noOfNodes);\\n\\t\\t\\n        int nominator = left.val+right.val+root.val; \\n        int denominator = left.nodeCount+right.nodeCount+1;\\n\\t\\t\\n        if(nominator/denominator == root.val) noOfNodes[0]+=1; // checking if valid average.\\n\\t\\t\\n        return new Pair(nominator,denominator);\\n    }\\n}\\n\\n// Rather then user defined Data type we can simply user a Integer arr like *return new int[]{0,0}* as well,using this for more clean code.\\n\\nclass Pair{\\n    int val;\\n    int nodeCount;\\n    Pair(int val,int nodeCount){\\n        this.val = val;\\n        this.nodeCount = nodeCount;\\n    }\\n```\\nPlease upvote if you like the explanation.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic int averageOfSubtree(TreeNode root) {\\n        int[] noOfNodes = new int[1]; // passing by reference\\n        noOfNodes[0] = 0;\\n        avgSubtree(root, noOfNodes);\\n        return noOfNodes[0];\\n        \\n    }\\n    public Pair avgSubtree(TreeNode root,int[] noOfNodes){\\n        if(root == null) return new Pair(0,0); // Base case -> return sum as 0 and count of nodes as 0\\n        Pair left = avgSubtree(root.left,noOfNodes);\\n        Pair right = avgSubtree(root.right,noOfNodes);\\n\\t\\t\\n        int nominator = left.val+right.val+root.val; \\n        int denominator = left.nodeCount+right.nodeCount+1;\\n\\t\\t\\n        if(nominator/denominator == root.val) noOfNodes[0]+=1; // checking if valid average.\\n\\t\\t\\n        return new Pair(nominator,denominator);\\n    }\\n}\\n\\n// Rather then user defined Data type we can simply user a Integer arr like *return new int[]{0,0}* as well,using this for more clean code.\\n\\nclass Pair{\\n    int val;\\n    int nodeCount;\\n    Pair(int val,int nodeCount){\\n        this.val = val;\\n        this.nodeCount = nodeCount;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141337,
                "title": "dfs-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n        \\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n        \\n        int sum = root -> val + l.first + r.first;\\n        int n = l.second + r.second + 1;\\n        \\n        if(sum / n == root -> val) ans++;\\n        \\n        return {sum, n};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n        \\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n        \\n        int sum = root -> val + l.first + r.first;\\n        int n = l.second + r.second + 1;\\n        \\n        if(sum / n == root -> val) ans++;\\n        \\n        return {sum, n};\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137882,
                "title": "python-easy-peasy",
                "content": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def f(r):   \\n            if not r:return 0,0\\n            nonlocal ans\\n            a,aa=f(r.left)\\n            b,bb=f(r.right)\\n            if (a+b+r.val)//(aa+bb+1)==r.val:\\n                ans+=1\\n            return a+b+r.val,aa+bb+1\\n        ans=0\\n        f(root)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def f(r):   \\n            if not r:return 0,0\\n            nonlocal ans\\n            a,aa=f(r.left)\\n            b,bb=f(r.right)\\n            if (a+b+r.val)//(aa+bb+1)==r.val:\\n                ans+=1\\n            return a+b+r.val,aa+bb+1\\n        ans=0\\n        f(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128483,
                "title": "c-o-n-2-to-o-n-optimization",
                "content": "**Brute force: O(N^2) Solution**\\n- Applying DFS to traverse through all the nodes. O(N)\\n- Calculating the sum and number of all the nodes(below it) at every node. O(N) per node.\\n- Checking is sum/number == value at that node. If yes, we\\'ll increase the count. (Global variable here, can be passed in the function as well)\\n```\\n\\tint count = 0;\\n    int div = 1;   //To keep a count of numbe of nodes below each node (including that root as well).\\n    int solve(TreeNode* root)\\n    {\\n        int a1=0,a2=0;\\n        if(root->left)\\n        {\\n            div++;\\n            a1 = solve(root->left);\\n        }\\n        if(root->right)\\n        {\\n            div++;\\n            a2 = solve(root->right);\\n        }\\n        int sum = (root->val + a1 + a2);\\n        return sum;\\n    }\\n    // DFS to reach each node\\n    void eachNode(TreeNode* root)\\n    {\\n        int x = solve(root);\\n        x = x/div;\\n        if(x==root->val)  //checking main condition\\n        {\\n            count++;  //increasing count.\\n        }\\n        if(root->left)\\n        {\\n            div=1;  //resetting the counter for number of nodes.\\n            eachNode(root->left);\\n        }\\n        if(root->right)\\n        {\\n            div=1; //resetting the counter for number of nodes.\\n            eachNode(root->right);\\n        }\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        eachNode(root);\\n        return count;\\n    }\\n```\\n\\n**Optimized: O(N) Solution**\\n- Using DFS to traverse through all the nodes of the tree. O(N)\\n- Keeping in account the sum and number of nodes (as a pair) at each node.\\n- Using sum and number of node variables to check for the main condition: if(sum/number == root->val) count++;\\n```\\n\\tint count=0;\\n    pair<int,int> solve(TreeNode* root)\\n    {\\n        if(!root)\\n\\t\\t\\treturn {0,0};\\n\\t\\tint sum=0,n;\\n        auto leftSide = solve(root->left);\\n        auto rightSide = solve(root->right);\\n        \\n\\t\\tsum = root->val + leftSide.first + rightSide.first; //stores sum at that particular node\\n        n = leftSide.second + rightSide.second + 1; // stores number of nodes(below) at that particular nodes/\\n        \\n\\t\\tcount+=(sum/n==root->val); //main condition check\\n        return {sum,n};\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        auto x = solve(root);\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n\\tint count = 0;\\n    int div = 1;   //To keep a count of numbe of nodes below each node (including that root as well).\\n    int solve(TreeNode* root)\\n    {\\n        int a1=0,a2=0;\\n        if(root->left)\\n        {\\n            div++;\\n            a1 = solve(root->left);\\n        }\\n        if(root->right)\\n        {\\n            div++;\\n            a2 = solve(root->right);\\n        }\\n        int sum = (root->val + a1 + a2);\\n        return sum;\\n    }\\n    // DFS to reach each node\\n    void eachNode(TreeNode* root)\\n    {\\n        int x = solve(root);\\n        x = x/div;\\n        if(x==root->val)  //checking main condition\\n        {\\n            count++;  //increasing count.\\n        }\\n        if(root->left)\\n        {\\n            div=1;  //resetting the counter for number of nodes.\\n            eachNode(root->left);\\n        }\\n        if(root->right)\\n        {\\n            div=1; //resetting the counter for number of nodes.\\n            eachNode(root->right);\\n        }\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        eachNode(root);\\n        return count;\\n    }\\n```\n```\\n\\tint count=0;\\n    pair<int,int> solve(TreeNode* root)\\n    {\\n        if(!root)\\n\\t\\t\\treturn {0,0};\\n\\t\\tint sum=0,n;\\n        auto leftSide = solve(root->left);\\n        auto rightSide = solve(root->right);\\n        \\n\\t\\tsum = root->val + leftSide.first + rightSide.first; //stores sum at that particular node\\n        n = leftSide.second + rightSide.second + 1; // stores number of nodes(below) at that particular nodes/\\n        \\n\\t\\tcount+=(sum/n==root->val); //main condition check\\n        return {sum,n};\\n    }\\n    int averageOfSubtree(TreeNode* root) \\n    {\\n        auto x = solve(root);\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123201,
                "title": "easy-c-postorder-traversal-soln-plz-see-it-once",
                "content": "\\n  ****Think in order of postorder traversal(this question is application of postorder)******\\n \\n     class Solution {\\n    public:\\n        #define pii pair<int,int>\\n    \\n    pii solve(TreeNode* root ,int &count)\\n    {\\n        if(root==NULL)\\n            return {0,0};\\n        \\n        pii p1,p2;\\n        p1=solve(root->left ,count);\\n        p2=solve(root->right ,count);\\n        \\n        int x=p1.first+p2.first+root->val;\\n        int y=p1.second+p2.second+1;\\n        \\n        if(root->val==x/y)\\n            count++;\\n        \\n        return {x,y};\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        int count=0;\\n        solve(root,count);\\n        return count;\\n    }\\n  };",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        #define pii pair<int,int>\\n    \\n    pii solve(TreeNode* root ,int &count)\\n    {\\n        if(root==NULL)\\n            return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2094694,
                "title": "python-clean-postorder-traversal",
                "content": "```\\nfrom typing import Optional, Tuple\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.cnt = 0\\n\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def postorder(rt: Optional[TreeNode]) -> Tuple[int, int]:\\n            \"\"\"\\n            :param rt:\\n            :return: (sum of values of all the nodes in tree rooted at rt, number of nodes in tree rooted at rt)\\n            \"\"\"\\n            if rt is None:\\n                return 0, 0\\n\\n            (left_sum, left_nodes), (right_sum, right_nodes) = postorder(rt.left), postorder(rt.right)\\n\\n            val = rt.val\\n\\n            sum_ = left_sum + val + right_sum  # \"sum\" is python defined keyword, so using \"sum_\"\\n            nodes = left_nodes + 1 + right_nodes\\n\\n            if sum_ // nodes == val:\\n                self.cnt += 1\\n\\n            return sum_, nodes\\n\\n        postorder(root)\\n\\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom typing import Optional, Tuple\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.cnt = 0\\n\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def postorder(rt: Optional[TreeNode]) -> Tuple[int, int]:\\n            \"\"\"\\n            :param rt:\\n            :return: (sum of values of all the nodes in tree rooted at rt, number of nodes in tree rooted at rt)\\n            \"\"\"\\n            if rt is None:\\n                return 0, 0\\n\\n            (left_sum, left_nodes), (right_sum, right_nodes) = postorder(rt.left), postorder(rt.right)\\n\\n            val = rt.val\\n\\n            sum_ = left_sum + val + right_sum  # \"sum\" is python defined keyword, so using \"sum_\"\\n            nodes = left_nodes + 1 + right_nodes\\n\\n            if sum_ // nodes == val:\\n                self.cnt += 1\\n\\n            return sum_, nodes\\n\\n        postorder(root)\\n\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092065,
                "title": "java-dfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Integer count = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        sumAverage(root);\\n        \\n        return count;\\n    }\\n    \\n    private Pair<Integer, Integer> sumAverage(TreeNode node) {\\n        if (node == null) {\\n            return new Pair<>(0, 0);\\n        }\\n        \\n        Pair<Integer, Integer> left = sumAverage(node.left);\\n        Pair<Integer, Integer> right = sumAverage(node.right);\\n        \\n        Integer newKey = node.val + left.getKey() + right.getKey();\\n        Integer newValue = 1 + left.getValue() + right.getValue();\\n        \\n        if (newKey / newValue == node.val) {\\n            count++;\\n        }\\n        \\n        return new Pair(newKey, newValue);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Integer count = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        sumAverage(root);\\n        \\n        return count;\\n    }\\n    \\n    private Pair<Integer, Integer> sumAverage(TreeNode node) {\\n        if (node == null) {\\n            return new Pair<>(0, 0);\\n        }\\n        \\n        Pair<Integer, Integer> left = sumAverage(node.left);\\n        Pair<Integer, Integer> right = sumAverage(node.right);\\n        \\n        Integer newKey = node.val + left.getKey() + right.getKey();\\n        Integer newValue = 1 + left.getValue() + right.getValue();\\n        \\n        if (newKey / newValue == node.val) {\\n            count++;\\n        }\\n        \\n        return new Pair(newKey, newValue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091790,
                "title": "java-using-sum-and-count-easy",
                "content": "```\\nclass Solution {\\n    public int averageOfSubtree(TreeNode root) {\\n        if(root==null) return 0;\\n        int ans=0;\\n        if(root.val==sum(root)/count(root)) ans++;\\n        ans+=averageOfSubtree(root.left);\\n        ans+=averageOfSubtree(root.right);\\n        return ans;\\n    }\\n    public int sum(TreeNode root){\\n        if(root==null) return 0;\\n        return sum(root.left)+sum(root.right)+root.val;\\n    }\\n    public int count(TreeNode root){\\n        if(root==null) return 0;\\n        return count(root.right)+count(root.left)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int averageOfSubtree(TreeNode root) {\\n        if(root==null) return 0;\\n        int ans=0;\\n        if(root.val==sum(root)/count(root)) ans++;\\n        ans+=averageOfSubtree(root.left);\\n        ans+=averageOfSubtree(root.right);\\n        return ans;\\n    }\\n    public int sum(TreeNode root){\\n        if(root==null) return 0;\\n        return sum(root.left)+sum(root.right)+root.val;\\n    }\\n    public int count(TreeNode root){\\n        if(root==null) return 0;\\n        return count(root.right)+count(root.left)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077440,
                "title": "java-recursive-explained-beats-100",
                "content": "We can solve it traversing tree DFS recursively. For each node we count number of nodes and their sum in subtree where this node is a root. Then we add 1 and current node value and push it to the caller. Base case if when node is null, then we return all values 0. \\nTo avoid using global variable for result we can add it to the return array for each node. For each node we\\'ll return the number of such equal to average nodes in the subtree where current node is root. \\n\\nO(n) runtime - visit each node once\\nO(n) space - on average it\\'s O(logn) for balanced tree but it\\'s O(n) for skewed ones.\\n\\n```\\n    public int averageOfSubtree(TreeNode root) {\\n        return helper(root)[2];\\n    }\\n    \\n    int[] helper(TreeNode n) {\\n        if (n == null) {\\n            return new int[] {0,0,0};\\n        }\\n        //count starts with 1 for current node itself, sum starts with current node\\'s value\\n        int count = 1, sum = n.val, res = 0;\\n        if (n.left != null) {\\n            int[] l = helper(n.left);\\n            count += l[0];\\n            sum += l[1];\\n            res+= l[2];\\n        }\\n        if (n.right != null) {\\n            int[] r = helper(n.right);\\n            count += r[0];\\n            sum += r[1];\\n            res += r[2];\\n        }\\n\\t\\t//check if current node is equal to average\\n        if (n.val == sum / count) {\\n            res++;\\n        }\\n        return new int[] {count, sum, res};\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public int averageOfSubtree(TreeNode root) {\\n        return helper(root)[2];\\n    }\\n    \\n    int[] helper(TreeNode n) {\\n        if (n == null) {\\n            return new int[] {0,0,0};\\n        }\\n        //count starts with 1 for current node itself, sum starts with current node\\'s value\\n        int count = 1, sum = n.val, res = 0;\\n        if (n.left != null) {\\n            int[] l = helper(n.left);\\n            count += l[0];\\n            sum += l[1];\\n            res+= l[2];\\n        }\\n        if (n.right != null) {\\n            int[] r = helper(n.right);\\n            count += r[0];\\n            sum += r[1];\\n            res += r[2];\\n        }\\n\\t\\t//check if current node is equal to average\\n        if (n.val == sum / count) {\\n            res++;\\n        }\\n        return new int[] {count, sum, res};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2073778,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int size(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        return 1 + size(root -> right) + size(root -> left);\\n    }\\n    \\n    int sum(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        return root -> val + sum(root -> right) + sum(root -> left);\\n    }\\n    \\n    int averageOfNode(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        return sum(root) / size(root);\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        if (root -> val == averageOfNode(root)) {\\n            return 1 + averageOfSubtree(root -> left) + averageOfSubtree(root -> right);\\n        }\\n        return averageOfSubtree(root -> left) + averageOfSubtree(root -> right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int size(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        return 1 + size(root -> right) + size(root -> left);\\n    }\\n    \\n    int sum(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        return root -> val + sum(root -> right) + sum(root -> left);\\n    }\\n    \\n    int averageOfNode(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        return sum(root) / size(root);\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        if (root -> val == averageOfNode(root)) {\\n            return 1 + averageOfSubtree(root -> left) + averageOfSubtree(root -> right);\\n        }\\n        return averageOfSubtree(root -> left) + averageOfSubtree(root -> right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068774,
                "title": "recursive-python-solution",
                "content": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        #[sum, no_nodes, curr_res]\\n        def rec(node = root):\\n            \\n            if not node:\\n                return [0,0,0]\\n            \\n            if not node.left and not node.right:\\n                return [node.val, 1, 1]\\n            \\n            else:\\n                x = rec(node.left)\\n                y = rec(node.right)\\n                curr_sum = x[0]+y[0]+node.val\\n                curr_n = x[1]+y[1]+1\\n                curr_res = x[2]+y[2]\\n                \\n                if curr_sum//curr_n == node.val:\\n                    return [curr_sum, curr_n, curr_res+1]\\n                \\n                return [curr_sum, curr_n, curr_res]\\n        \\n        return rec()[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        \\n        #[sum, no_nodes, curr_res]\\n        def rec(node = root):\\n            \\n            if not node:\\n                return [0,0,0]\\n            \\n            if not node.left and not node.right:\\n                return [node.val, 1, 1]\\n            \\n            else:\\n                x = rec(node.left)\\n                y = rec(node.right)\\n                curr_sum = x[0]+y[0]+node.val\\n                curr_n = x[1]+y[1]+1\\n                curr_res = x[2]+y[2]\\n                \\n                if curr_sum//curr_n == node.val:\\n                    return [curr_sum, curr_n, curr_res+1]\\n                \\n                return [curr_sum, curr_n, curr_res]\\n        \\n        return rec()[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062595,
                "title": "c-single-traversal-dfs",
                "content": "```\\n int cnt=0;\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int>temp={0,0};\\n            return temp;\\n        }\\n        \\n        pair<int,int> left = helper(root->left);\\n        pair<int,int> right = helper(root->right);\\n        if((root->val+left.first+right.first)/(1+left.second+right.second)==root->val){\\n            cnt++;\\n        }\\n        pair<int,int> t = {root->val+left.first+right.first,1+left.second+right.second};\\n        return t;\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        helper(root);\\n        return cnt;\\n    }",
                "solutionTags": [],
                "code": "```\\n int cnt=0;\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int>temp={0,0};\\n            return temp;\\n        }\\n        \\n        pair<int,int> left = helper(root->left);\\n        pair<int,int> right = helper(root->right);\\n        if((root->val+left.first+right.first)/(1+left.second+right.second)==root->val){\\n            cnt++;\\n        }\\n        pair<int,int> t = {root->val+left.first+right.first,1+left.second+right.second};\\n        return t;\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        helper(root);\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2061025,
                "title": "c-solution",
                "content": "Complexity\\n- Time: O(n)\\n- Space: O(n) in worst for the skewed tree\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    \\n    public int res = 0;\\n    \\n    public int AverageOfSubtree(TreeNode root) {\\n    \\n        if(root == null)\\n            return 0;\\n        \\n        dfs(root);\\n        return res;\\n    }\\n        \\n    private int[] dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return new int[2];\\n        \\n        var left = dfs(root.left);\\n        var right = dfs(root.right);\\n        \\n        int sum = left[0] + right[0] + root.val;\\n        int cnt = left[1] + right[1] + 1;\\n        \\n        if(root.val == sum / cnt)\\n            res++;\\n        \\n        return new int[2]{sum, cnt};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int res = 0;\\n    \\n    public int AverageOfSubtree(TreeNode root) {\\n    \\n        if(root == null)\\n            return 0;\\n        \\n        dfs(root);\\n        return res;\\n    }\\n        \\n    private int[] dfs(TreeNode root)\\n    {\\n        if(root == null)\\n            return new int[2];\\n        \\n        var left = dfs(root.left);\\n        var right = dfs(root.right);\\n        \\n        int sum = left[0] + right[0] + root.val;\\n        int cnt = left[1] + right[1] + 1;\\n        \\n        if(root.val == sum / cnt)\\n            res++;\\n        \\n        return new int[2]{sum, cnt};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060562,
                "title": "c-easy-understandable-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int sum(TreeNode* root){\\n        if(root == NULL) return 0;\\n        return root->val + sum(root->left) + sum(root->right);\\n    }\\n    int count(TreeNode* root,int num){\\n        if(root == NULL) return 0;\\n        if(root){\\n            return count(root->left,num) + count(root->right,num) + 1;\\n        }\\n        return 0;\\n    }\\npublic:\\n    int nodeSum = 0;\\n    int averageOfSubtree(TreeNode* root) {\\n        if(root){\\n            if(sum(root)/count(root,0) == root->val){\\n                nodeSum++;\\n            }\\n            averageOfSubtree(root->left);\\n            averageOfSubtree(root->right);\\n        }\\n        return nodeSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int sum(TreeNode* root){\\n        if(root == NULL) return 0;\\n        return root->val + sum(root->left) + sum(root->right);\\n    }\\n    int count(TreeNode* root,int num){\\n        if(root == NULL) return 0;\\n        if(root){\\n            return count(root->left,num) + count(root->right,num) + 1;\\n        }\\n        return 0;\\n    }\\npublic:\\n    int nodeSum = 0;\\n    int averageOfSubtree(TreeNode* root) {\\n        if(root){\\n            if(sum(root)/count(root,0) == root->val){\\n                nodeSum++;\\n            }\\n            averageOfSubtree(root->left);\\n            averageOfSubtree(root->right);\\n        }\\n        return nodeSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056878,
                "title": "c-recursion",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int& n, int& ans) {\\n        if(!root)\\n            return 0;\\n        int sum=0, n1=0, n2=0;\\n        \\n        sum += solve(root->left, n1, ans);\\n        sum += solve(root->right, n2, ans);\\n        sum += root->val;\\n        n=n1+n2+1;\\n        int avg=sum/n;\\n        if(avg==root->val)\\n            ans++;\\n        return sum;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int n=0, ans=0;\\n        solve(root, n, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(TreeNode* root, int& n, int& ans) {\\n        if(!root)\\n            return 0;\\n        int sum=0, n1=0, n2=0;\\n        \\n        sum += solve(root->left, n1, ans);\\n        sum += solve(root->right, n2, ans);\\n        sum += root->val;\\n        n=n1+n2+1;\\n        int avg=sum/n;\\n        if(avg==root->val)\\n            ans++;\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2038066,
                "title": "simply-save-sum-and-count-in-pair",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int count=0;\\n        int sum = 0;\\n        Pair(int sum, int count) {\\n            this.sum = sum;\\n            this.count = count;\\n        }\\n    }\\n    public Pair solve(TreeNode node, int[] ans){\\n        if (node == null) {\\n            return new Pair(0,0);\\n        }\\n        Pair left = solve(node.left, ans);\\n        Pair right = solve (node.right, ans);\\n        int sum = left.sum + right.sum + node.val;\\n        int c = left.count + right.count + 1;\\n        if (sum / c == node.val) ans[0]++;\\n        return new Pair(sum, c);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        int[] ans = new int[1];\\n        solve (root, ans);\\n        return ans[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int count=0;\\n        int sum = 0;\\n        Pair(int sum, int count) {\\n            this.sum = sum;\\n            this.count = count;\\n        }\\n    }\\n    public Pair solve(TreeNode node, int[] ans){\\n        if (node == null) {\\n            return new Pair(0,0);\\n        }\\n        Pair left = solve(node.left, ans);\\n        Pair right = solve (node.right, ans);\\n        int sum = left.sum + right.sum + node.val;\\n        int c = left.count + right.count + 1;\\n        if (sum / c == node.val) ans[0]++;\\n        return new Pair(sum, c);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        int[] ans = new int[1];\\n        solve (root, ans);\\n        return ans[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033870,
                "title": "c-optimized-o-n-solution-7ms-beats-87-27-simple-postorder-traversal",
                "content": "Simple solution using postorder traversal. \\nTraverse the left and right subtrees then add the sum from both subtrees to current node value and calculate average.\\n\\n\\n```/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root,int& n,int& res){\\n        if(!root){\\n            return 0;\\n        }\\n        int sum=0,n1=0,n2=0;\\n        \\n        sum+=helper(root->left,n1,res);\\n        sum+=helper(root->right,n2,res);\\n        sum+=root->val;\\n        n=n1+n2+1;\\n        int avg = sum/n;\\n        // cout<<avg<<\" \"<<n<<endl;\\n        if(avg==root->val){\\n            res++;\\n        }\\n        return sum;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int n=0,res=0;\\n        helper(root,n,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(TreeNode* root,int& n,int& res){\\n        if(!root){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2031744,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int avg(TreeNode *root, int &sum)\\n    {\\n        if(root == NULL) return 0;\\n        else\\n        {\\n            sum += root->val;\\n            avg(root->left,sum);\\n            avg(root->right, sum);\\n        }\\n        return sum;\\n    }\\n    \\n    int numNodes(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        return 1 + numNodes(root->left) + numNodes(root->right);\\n    }\\n   \\n    int averageOfSubtree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int ans = 0;\\n        int cnt = 0;\\n        int sum = 0;\\n        cnt += avg(root,sum)/numNodes(root);\\n        if(cnt == root->val) ans++;\\n        return ans + averageOfSubtree(root->left) + averageOfSubtree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int avg(TreeNode *root, int &sum)\\n    {\\n        if(root == NULL) return 0;\\n        else\\n        {\\n            sum += root->val;\\n            avg(root->left,sum);\\n            avg(root->right, sum);\\n        }\\n        return sum;\\n    }\\n    \\n    int numNodes(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        return 1 + numNodes(root->left) + numNodes(root->right);\\n    }\\n   \\n    int averageOfSubtree(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int ans = 0;\\n        int cnt = 0;\\n        int sum = 0;\\n        cnt += avg(root,sum)/numNodes(root);\\n        if(cnt == root->val) ans++;\\n        return ans + averageOfSubtree(root->left) + averageOfSubtree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026935,
                "title": "simple-traversal-o-n",
                "content": "/**\\n * To solve such type of problem we need to think of recursive approch i.e solve for left and right child and then we will solve for the node hence a postorder(because we are interested in subtree hence child first then node) kind of traversal. Now we need two things sum and value hence we will return two values and if we end up with something like this.\\n \\n *     class Solution {\\n\\t\\t\\tprivate:\\n\\t\\t\\t\\tint ans;\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tpair<int,int> fun(TreeNode* root){\\n\\t\\t\\t\\tif(!root) return {0,0};\\n\\t\\t\\t\\tpair<int,int> left,right;\\n\\t\\t\\t\\tleft = fun(root->left);\\n\\t\\t\\t\\tright = fun(root->right);\\n\\n\\t\\t\\t\\tint left_sum = left.first+root->val+right.first;\\n\\t\\t\\t\\tint right_sum = left.second+1+right.second;\\n\\t\\t\\t\\tif((left_sum/right_sum)==root->val){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn { left_sum, right_sum};\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\tint averageOfSubtree(TreeNode* root) {\\n\\t\\t\\t\\tans=0;\\n\\t\\t\\t\\tfun(root);\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tprivate:\\n\\t\\t\\t\\tint ans;\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tpair<int,int> fun(TreeNode* root){\\n\\t\\t\\t\\tif(!root) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2024264,
                "title": "python3-two-detailed-solutions",
                "content": "Passing all values recursively.\\n\\n```python\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node):\\n            if not node:\\n                return (0,0,0)\\n            left, right = dfs(node.left), dfs(node.right)\\n            subtree_sum = left[0]+right[0]+node.val\\n            nodes_in_subtree = left[1]+right[1]+1\\n            nodes_eq_to_avg = left[2]+right[2]+(subtree_sum//nodes_in_subtree == node.val)\\n            return (subtree_sum, nodes_in_subtree, nodes_eq_to_avg)\\n        return dfs(root)[2]\\n```\\n\\nAnd another using nonlocal variables and OOP because why not\\n\\n```python\\nclass DFStuple:\\n    \\n    def __init__(self, sum=0, count=0):\\n        self.sum = sum\\n        self.count = count\\n        \\n    def getFloorAverage(self):\\n        return self.sum//self.count\\n\\nclass Solution:\\n        \\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        def dfs(node=root):\\n            nonlocal res\\n            if not node:\\n                return DFStuple()\\n            left, right = dfs(node.left), dfs(node.right)\\n            cur = DFStuple(left.sum+right.sum+node.val, left.count+right.count+1)\\n            res += cur.getFloorAverage() == node.val\\n            return cur\\n        dfs()\\n        return res\\n```\\n\\nAlternatively, for the solution above you could use a `namedtuple` but you don\\'t have the flexibility of implementing the `getFloorAverage` method (not that it matters much anyway). Read Elements of Programming Interviews if you\\'re not familiar with this, it\\'s a nice shortcut along with everything else in the collections module.\\n\\nYou could also use dfs using a stack if you felt like it. I did not.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node):\\n            if not node:\\n                return (0,0,0)\\n            left, right = dfs(node.left), dfs(node.right)\\n            subtree_sum = left[0]+right[0]+node.val\\n            nodes_in_subtree = left[1]+right[1]+1\\n            nodes_eq_to_avg = left[2]+right[2]+(subtree_sum//nodes_in_subtree == node.val)\\n            return (subtree_sum, nodes_in_subtree, nodes_eq_to_avg)\\n        return dfs(root)[2]\\n```\n```python\\nclass DFStuple:\\n    \\n    def __init__(self, sum=0, count=0):\\n        self.sum = sum\\n        self.count = count\\n        \\n    def getFloorAverage(self):\\n        return self.sum//self.count\\n\\nclass Solution:\\n        \\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        def dfs(node=root):\\n            nonlocal res\\n            if not node:\\n                return DFStuple()\\n            left, right = dfs(node.left), dfs(node.right)\\n            cur = DFStuple(left.sum+right.sum+node.val, left.count+right.count+1)\\n            res += cur.getFloorAverage() == node.val\\n            return cur\\n        dfs()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024133,
                "title": "easy-python-solution-o-n-faster-than-96-most-readable",
                "content": "![image](https://assets.leetcode.com/users/images/dae3910d-aa5a-4d6e-9066-0e02b169cc30_1652144825.204072.png)\\n\\nExplanation after the code block below!\\n\\n```\\ndef averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n\\tcount = 0\\n\\n\\tdef check(root):\\n\\t\\tnonlocal count\\n\\t\\tif root:\\n\\t\\t\\tcheck(root.left)\\n\\t\\t\\tcheck(root.right)\\n\\n\\t\\t\\troot.total, root.nodes = root.val, 1\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\troot.total += root.left.total\\n\\t\\t\\t\\troot.nodes += root.left.nodes\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\troot.total += root.right.total\\n\\t\\t\\t\\troot.nodes += root.right.nodes\\n\\n\\t\\t\\tif root.val == int(root.total / root.nodes):\\n\\t\\t\\t\\tcount += 1\\n\\n\\tcheck(root)\\n\\n\\treturn count\\n```\\n\\nWhen first tackling this problem I immediately thought of using a recursive method since it was a binary tree and the problem description itself very strongly suggests the use of recursion. The hints provided also suggested to use recursion, confirming my hunch. However, I quickly realized that I would need a way to cache my results from lower in the recursion tree or else I would have to use an O(n^2) solution!\\n\\nI first thought about using a hash map, with each node\\'s values as the key. However I quickly abandoned this idea because I couldn\\'t confirm if all node values were unique and using a hash map would complicate the implementation. I then thought about storing results as the node\\'s own property, this was the approach I ended up going with.\\n\\nIf we define the average of a subtree as follows:\\nAverage of a subtree = subtree total sum of subtree node values / subtree total number of nodes\\nsubtree total sum of values = root value + left subtree total sum + right subtree total sum\\nsubtree total number of nodes = root number of nodes (1) + left subtree total number of nodes + right subtree total number of nodes\\n\\nWith the definition above, we actually already have our recursive solution! Now for the implementation!\\n\\nBased on our definition above, it would seem that we have to process our left and right subtrees before we process the root node. This sounds a lot like a post-order depth first search!\\n```\\ndef postOrderDfs(root):\\n\\tif root:\\n\\t\\tpostOrderDfs(root.left)\\n\\t\\tprostOderDfs(root.right)\\n\\t\\tprocess(root)\\n```\\nThis forms the basis of my solution. I will focus on the helper function ```check(root)``` as that is most of the solution. \\nWe use `nonlocal` to reference the variable `count` which we have initialized in the higher scope. \\n``` nonlocal count ```\\n\\nWe then check if the root is not None! This forms the basis of our base case as the left and right nodes of the leaf nodes are None. After checking that the root is not None, then since we are doing post-order DFS we then have to process the left and right subtrees first.\\n```\\nif root:\\n\\tcheck(root.left)\\n\\tcheck(root.right)\\n```\\nWe then have to process the root node and find the average\\n```\\nroot.total, root.nodes = root.val, 1   # based on our definition above\\n\\n# add the number of nodes and sum of values of the left and right subtree to the root\\n\\nif root.left: \\n\\troot.total += root.left.total\\n\\troot.nodes += root.left.nodes\\n\\nif root.right:\\n\\troot.total += root.right.total\\n\\troot.nodes += root.right.nodes\\n\\n# we can then calculate the average. \\n# Keep in mind that we have to round down to the nearest integer as per the problem description. \\n# Using int() allows us to do that simply. \\n\\nif root.val == int(root.total / root.nodes):\\n\\tcount += 1\\n```\\n\\nTime and space complexity:\\nWe process each node once. So this solution is of O(n) time complexity.\\nFor each node we add 2 store 2 additional properties. So this has a O(2n) = O(n) space complexity.\\n\\nThanks for reading! Please let me know if I can make any improvements to my solution!\\n\\np.s. I think \"check\" was probably a bad name for the function but I couldn\\'t really come up with a name that was short enough. Please help me with naming it if you can!\\n\\np.p.s I think you could\\'ve also refactored the logic to process the root node to a seperate function if you really wanted to but it probabaly won\\'t increase readability by too much.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n\\tcount = 0\\n\\n\\tdef check(root):\\n\\t\\tnonlocal count\\n\\t\\tif root:\\n\\t\\t\\tcheck(root.left)\\n\\t\\t\\tcheck(root.right)\\n\\n\\t\\t\\troot.total, root.nodes = root.val, 1\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\troot.total += root.left.total\\n\\t\\t\\t\\troot.nodes += root.left.nodes\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\troot.total += root.right.total\\n\\t\\t\\t\\troot.nodes += root.right.nodes\\n\\n\\t\\t\\tif root.val == int(root.total / root.nodes):\\n\\t\\t\\t\\tcount += 1\\n\\n\\tcheck(root)\\n\\n\\treturn count\\n```\n```\\ndef postOrderDfs(root):\\n\\tif root:\\n\\t\\tpostOrderDfs(root.left)\\n\\t\\tprostOderDfs(root.right)\\n\\t\\tprocess(root)\\n```\n```check(root)```\n``` nonlocal count ```\n```\\nif root:\\n\\tcheck(root.left)\\n\\tcheck(root.right)\\n```\n```\\nroot.total, root.nodes = root.val, 1   # based on our definition above\\n\\n# add the number of nodes and sum of values of the left and right subtree to the root\\n\\nif root.left: \\n\\troot.total += root.left.total\\n\\troot.nodes += root.left.nodes\\n\\nif root.right:\\n\\troot.total += root.right.total\\n\\troot.nodes += root.right.nodes\\n\\n# we can then calculate the average. \\n# Keep in mind that we have to round down to the nearest integer as per the problem description. \\n# Using int() allows us to do that simply. \\n\\nif root.val == int(root.total / root.nodes):\\n\\tcount += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2022185,
                "title": "recursive-solution-with-global-var-93-speed",
                "content": "![image](https://assets.leetcode.com/users/images/fec56334-adb5-4c07-be47-dbddee855001_1652090788.343869.png)\\n```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        count = 0\\n\\n        def traverse(node: TreeNode) -> tuple:\\n            nonlocal count\\n            if not node:\\n                return 0, 0\\n            sum_left, count_left = traverse(node.left)\\n            sum_right, count_right = traverse(node.right)\\n            sum_total = sum_left + sum_right + node.val\\n            count_total = count_left + count_right + 1\\n            count += node.val == sum_total // count_total\\n            return sum_total, count_total\\n\\n        traverse(root)\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        count = 0\\n\\n        def traverse(node: TreeNode) -> tuple:\\n            nonlocal count\\n            if not node:\\n                return 0, 0\\n            sum_left, count_left = traverse(node.left)\\n            sum_right, count_right = traverse(node.right)\\n            sum_total = sum_left + sum_right + node.val\\n            count_total = count_left + count_right + 1\\n            count += node.val == sum_total // count_total\\n            return sum_total, count_total\\n\\n        traverse(root)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021729,
                "title": "java-dfs-elegant-and-concise-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int ans;\\n    public int averageOfSubtree(TreeNode root) {\\n        this.ans = 0;\\n        \\n        find(root);\\n        return this.ans;\\n    }\\n    \\n    private int[] find(TreeNode root){\\n        if(root == null){\\n            return new int[]{0, 0};\\n        }\\n        \\n        int[] left = find(root.left);\\n        int[] right = find(root.right);\\n        \\n        int[] rootArr = new int[]{left[0]+right[0] + root.val , left[1] + right[1] + 1};\\n        \\n        if(rootArr[0]/rootArr[1] == root.val){\\n            this.ans++;\\n        }\\n        \\n        return rootArr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int ans;\\n    public int averageOfSubtree(TreeNode root) {\\n        this.ans = 0;\\n        \\n        find(root);\\n        return this.ans;\\n    }\\n    \\n    private int[] find(TreeNode root){\\n        if(root == null){\\n            return new int[]{0, 0};\\n        }\\n        \\n        int[] left = find(root.left);\\n        int[] right = find(root.right);\\n        \\n        int[] rootArr = new int[]{left[0]+right[0] + root.val , left[1] + right[1] + 1};\\n        \\n        if(rootArr[0]/rootArr[1] == root.val){\\n            this.ans++;\\n        }\\n        \\n        return rootArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020277,
                "title": "c-o-n-no-global-variable-dfs",
                "content": "```\\n    public int AverageOfSubtree(TreeNode root)\\n    {\\n        return Dfs(root)[0];\\n    }\\n    private int[] Dfs(TreeNode node)\\n    {\\n        if (node == null)\\n            return new int[] { 0, 0, 0 };\\n\\n        int[] left = Dfs(node.left);\\n        int[] right = Dfs(node.right);\\n\\n        int nodesSum = left[1] + right[1] + node.val;\\n        int nodesCount = left[2] + right[2] + 1;\\n        int equalCount = left[0] + right[0];\\n        if (nodesSum / nodesCount == node.val)\\n            equalCount++;\\n\\n        return new int[] { equalCount, nodesSum, nodesCount };\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n    public int AverageOfSubtree(TreeNode root)\\n    {\\n        return Dfs(root)[0];\\n    }\\n    private int[] Dfs(TreeNode node)\\n    {\\n        if (node == null)\\n            return new int[] { 0, 0, 0 };\\n\\n        int[] left = Dfs(node.left);\\n        int[] right = Dfs(node.right);\\n\\n        int nodesSum = left[1] + right[1] + node.val;\\n        int nodesCount = left[2] + right[2] + 1;\\n        int equalCount = left[0] + right[0];\\n        if (nodesSum / nodesCount == node.val)\\n            equalCount++;\\n\\n        return new int[] { equalCount, nodesSum, nodesCount };\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020235,
                "title": "easy-approach-for-begginers",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum (TreeNode *root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int s =0;\\n        s+= root->val;\\n       int a = sum(root->left);\\n       int b = sum(root->right);\\n        return s+a+b;\\n    }\\n    int nodes(TreeNode * root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int m =0;\\n        if(root){\\n            m+=1;\\n        }\\n       int  a= nodes(root->right);\\n    int b =   nodes(root->left);\\n        return m+a+b;\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int count =0;\\n        if(root==NULL){\\n            return 0;\\n        }\\n        if(root){\\n            if(sum(root)/nodes(root)== root->val){\\n                count ++;\\n            }\\n        }\\n       int a = averageOfSubtree(root->right);\\n           int b = averageOfSubtree(root->left);\\nreturn count+ a+b;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int sum (TreeNode *root){\\n        if(root==NULL){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2019824,
                "title": "c-clean-and-easy-solution-dfs",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n     int find(TreeNode *root,int &n)\\n     {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int sum = root->val;\\n        n++;\\n        sum += find(root->left,n);\\n        sum += find(root->right,n);\\n        \\n        return sum;\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return 0;\\n        \\n        if(root->left == NULL && root->right == NULL)\\n            return 1;\\n        \\n        int count = 0;\\n        int no_nodes = 0;\\n        \\n        if(find(root,no_nodes)/(no_nodes) == root->val)\\n            count++;\\n        \\n        count += averageOfSubtree(root->left);\\n        count += averageOfSubtree(root->right);\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n     int find(TreeNode *root,int &n)\\n     {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int sum = root->val;\\n        n++;\\n        sum += find(root->left,n);\\n        sum += find(root->right,n);\\n        \\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2019763,
                "title": "js-dfs-solution",
                "content": "```\\nconst averageOfSubtree = function(root) {\\n    let res = 0;\\n    const dfs = (node) => {\\n        if(!node) return [0, 0];\\n        const [sumLeft, countLeft] = dfs(node.left);\\n        const [sumRight, countRight] = dfs(node.right);\\n        const sum = node.val + sumLeft + sumRight;\\n        let count = 1 + countLeft + countRight;\\n        const avg = Math.floor(sum / count);\\n        if(node.val == avg) res++;\\n        return [sum, count];\\n    }\\n    dfs(root);\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst averageOfSubtree = function(root) {\\n    let res = 0;\\n    const dfs = (node) => {\\n        if(!node) return [0, 0];\\n        const [sumLeft, countLeft] = dfs(node.left);\\n        const [sumRight, countRight] = dfs(node.right);\\n        const sum = node.val + sumLeft + sumRight;\\n        let count = 1 + countLeft + countRight;\\n        const avg = Math.floor(sum / count);\\n        if(node.val == avg) res++;\\n        return [sum, count];\\n    }\\n    dfs(root);\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2018984,
                "title": "easy-c-solution-o-n-post-order-traversal-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,array<int,3>> mp;\\n    int averageOfSubtree(TreeNode* root) {\\n        post(root);\\n        int cnt=0;\\n        for(pair<TreeNode*,array<int,3>> p : mp) cnt+=p.second[1]/p.second[0] == p.second[2];\\n        return cnt;\\n    }\\n    void post(TreeNode* root) {\\n         if(!root) return;\\n         post(root->left);\\n         post(root->right);\\n         mp[root]={1,root->val,root->val};\\n         if(root->left) {\\n             mp[root][0]+=mp[root->left][0];\\n             mp[root][1]+=mp[root->left][1];\\n         }\\n         if(root->right) {\\n             mp[root][0]+=mp[root->right][0];\\n             mp[root][1]+=mp[root->right][1];\\n         }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,array<int,3>> mp;\\n    int averageOfSubtree(TreeNode* root) {\\n        post(root);\\n        int cnt=0;\\n        for(pair<TreeNode*,array<int,3>> p : mp) cnt+=p.second[1]/p.second[0] == p.second[2];\\n        return cnt;\\n    }\\n    void post(TreeNode* root) {\\n         if(!root) return;\\n         post(root->left);\\n         post(root->right);\\n         mp[root]={1,root->val,root->val};\\n         if(root->left) {\\n             mp[root][0]+=mp[root->left][0];\\n             mp[root][1]+=mp[root->left][1];\\n         }\\n         if(root->right) {\\n             mp[root][0]+=mp[root->right][0];\\n             mp[root][1]+=mp[root->right][1];\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018418,
                "title": "java-recursion",
                "content": "\\n    class pair{\\n    int sum;\\n    int c;\\n    pair(int sum1,int c1){\\n        sum=sum1;\\n        c=c1;\\n    }\\n}\\n    \\n    class Solution {\\n    int z=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        f(root);\\n        return z;\\n    }\\n    public pair f(TreeNode root){\\n        if(root==null)return new pair(0,0);\\n        pair l=f(root.left);\\n        pair r=f(root.right);\\n        int sum=l.sum+r.sum+root.val;\\n        int count=l.c+r.c+1;\\n        if(sum/count==root.val)z++;\\n        return new pair(sum,count);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int z=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        f(root);\\n        return z;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2018237,
                "title": "easy-c-code-7-ms-faster-than-100-00",
                "content": "```\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int cnt;\\n    pair<int,int> call(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0};\\n        \\n        auto l=call(root->left);\\n        auto r=call(root->right);\\n        \\n        int sm=root->val,div=1;\\n        sm+=root->val+l.first+r.first;\\n        div+=l.second+r.second+1;\\n        \\n        if((sm)/div == root->val) cnt++;\\n       \\n        return {sm,div};\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        cnt=0;\\n        call(root);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int cnt;\\n    pair<int,int> call(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0};\\n        \\n        auto l=call(root->left);\\n        auto r=call(root->right);\\n        \\n        int sm=root->val,div=1;\\n        sm+=root->val+l.first+r.first;\\n        div+=l.second+r.second+1;\\n        \\n        if((sm)/div == root->val) cnt++;\\n       \\n        return {sm,div};\\n        \\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        cnt=0;\\n        call(root);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018208,
                "title": "java-solution-one-pass",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        dfs(root,new int[1]);\\n        return count;\\n    }\\n    public int dfs(TreeNode root,int[]size){\\n        if(root==null){\\n            return 0;\\n        }\\n        int []temp=new int[1];\\n        temp[0]++;\\n        int val=root.val+dfs(root.left,temp)+dfs(root.right,temp);\\n        size[0]=size[0]+temp[0];\\n        if(val/temp[0]==root.val){\\n            count++;\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    public int averageOfSubtree(TreeNode root) {\\n        dfs(root,new int[1]);\\n        return count;\\n    }\\n    public int dfs(TreeNode root,int[]size){\\n        if(root==null){\\n            return 0;\\n        }\\n        int []temp=new int[1];\\n        temp[0]++;\\n        int val=root.val+dfs(root.left,temp)+dfs(root.right,temp);\\n        size[0]=size[0]+temp[0];\\n        if(val/temp[0]==root.val){\\n            count++;\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018182,
                "title": "postorder-traversal-deceiving-best-solution-readable-code",
                "content": "First Intution was to get all the averages in hashset then on final tree traversal find out the nodes, that that too is inefficienct solution with exponential complexity.\\nusing pair class is good option, you can argue that this can be solved by just returning the integer array of length 2, but there is something known as code readability\\uD83D\\uDE0A\\n```\\nclass Solution {\\n    static int count = 0;\\n    static class Pair{\\n        int sum;\\n        int nodes;\\n        Pair(int sum,int nodes){\\n            this.nodes = nodes;\\n            this.sum = sum;\\n        }\\n    }\\n    static Pair postOrder(TreeNode root){\\n        if(root == null) return new Pair(0,0);\\n        \\n        Pair left = postOrder(root.left);\\n        Pair right = postOrder(root.right);\\n        \\n        int totalSum = left.sum + right.sum + root.val;\\n        int descendants = (left.nodes + right.nodes + 1);\\n        int average = totalSum/descendants;\\n        \\n        if(average == root.val) count++;\\n        return new Pair(totalSum,descendants);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        count = 0;\\n        postOrder(root);\\n        return count;        \\n    }\\n}\\n```\\nHappy LeetCoding\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    static int count = 0;\\n    static class Pair{\\n        int sum;\\n        int nodes;\\n        Pair(int sum,int nodes){\\n            this.nodes = nodes;\\n            this.sum = sum;\\n        }\\n    }\\n    static Pair postOrder(TreeNode root){\\n        if(root == null) return new Pair(0,0);\\n        \\n        Pair left = postOrder(root.left);\\n        Pair right = postOrder(root.right);\\n        \\n        int totalSum = left.sum + right.sum + root.val;\\n        int descendants = (left.nodes + right.nodes + 1);\\n        int average = totalSum/descendants;\\n        \\n        if(average == root.val) count++;\\n        return new Pair(totalSum,descendants);\\n    }\\n    public int averageOfSubtree(TreeNode root) {\\n        count = 0;\\n        postOrder(root);\\n        return count;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018176,
                "title": "rust-optimized-o-n-solution",
                "content": "**Time Complexity O(n)**\\nWe use a postorder traversal method to calculate the sum and number of nodes in the left subtree, then we do the same for right subtree.\\nWe increment the node count by 1 for the current node and add the sum and node count for both subtrees together to calculate the avg.\\nIf the avg is equal to the current node\\'s value we increment the `count` var by 1\\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl TreeNode{\\n    pub fn count_nodes_equal_to_avg(&self)-> i32{\\n        fn avg(node: &TreeNode, count: &mut i32) -> (i32, i32) {\\n            \\n            let mut sum = node.val;\\n            let mut nodes = 1; // increment node count by 1\\n            \\n            if let Some(ref left) = node.left{\\n                let left = left.borrow();\\n                let (sub_sum, sub_nodes) = avg(&left, count);\\n                \\n                sum += sub_sum;\\n                nodes += sub_nodes;\\n            }\\n            \\n            if let Some(ref right) = node.right{\\n                let right = right.borrow();\\n                let (sub_sum, sub_nodes) = avg(&right, count);\\n                \\n                sum += sub_sum;\\n                nodes += sub_nodes;\\n            }\\n            \\n\\t\\t\\t// check if the avg is equal to the node\\'s value\\n            if sum/nodes == node.val{\\n                *count +=1; // if so, increment global count by 1\\n            }\\n            \\n            (sum, nodes)\\n        }\\n        \\n        let mut count = 0;\\n        let _ = avg(self, &mut count);\\n        count\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn average_of_subtree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        if let Some(node) = root{\\n            node.borrow().count_nodes_equal_to_avg()\\n        }else{\\n            0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl TreeNode{\\n    pub fn count_nodes_equal_to_avg(&self)-> i32{\\n        fn avg(node: &TreeNode, count: &mut i32) -> (i32, i32) {\\n            \\n            let mut sum = node.val;\\n            let mut nodes = 1; // increment node count by 1\\n            \\n            if let Some(ref left) = node.left{\\n                let left = left.borrow();\\n                let (sub_sum, sub_nodes) = avg(&left, count);\\n                \\n                sum += sub_sum;\\n                nodes += sub_nodes;\\n            }\\n            \\n            if let Some(ref right) = node.right{\\n                let right = right.borrow();\\n                let (sub_sum, sub_nodes) = avg(&right, count);\\n                \\n                sum += sub_sum;\\n                nodes += sub_nodes;\\n            }\\n            \\n\\t\\t\\t// check if the avg is equal to the node\\'s value\\n            if sum/nodes == node.val{\\n                *count +=1; // if so, increment global count by 1\\n            }\\n            \\n            (sum, nodes)\\n        }\\n        \\n        let mut count = 0;\\n        let _ = avg(self, &mut count);\\n        count\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn average_of_subtree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        if let Some(node) = root{\\n            node.borrow().count_nodes_equal_to_avg()\\n        }else{\\n            0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018090,
                "title": "java-1ms-simplest-recursive-easy-postorder-traversal",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        solve(root);\\n        return result;\\n    }\\n    \\n    private int[] solve(TreeNode root){\\n        if(root == null) return new int[]{0, 0};\\n        int nodes = 1;\\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        \\n        int sum = left[0] + right[0] + root.val;\\n        nodes += left[1] + right[1];\\n        \\n        if(Math.round(sum / nodes) == root.val) result++;\\n        return new int[]{sum, nodes};\\n    }\\n    \\n}\\n\\n```\\n\\n-------------------------------------\\nauthor : [@bharathkalyans](https://leetcode.com/bharathkalyans/)\\nlinkedin : [@bharathkalyans](https://www.linkedin.com/in/bharathkalyans/)\\ntwitter : [@bharathkalyans](https://twitter.com/bharathkalyans)\\ngithub : [@bharathkalyans](https://github.com/bharathkalyans/)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    \\n    public int averageOfSubtree(TreeNode root) {\\n        solve(root);\\n        return result;\\n    }\\n    \\n    private int[] solve(TreeNode root){\\n        if(root == null) return new int[]{0, 0};\\n        int nodes = 1;\\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        \\n        int sum = left[0] + right[0] + root.val;\\n        nodes += left[1] + right[1];\\n        \\n        if(Math.round(sum / nodes) == root.val) result++;\\n        return new int[]{sum, nodes};\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018078,
                "title": "java-dfs-recursion",
                "content": "```java\\npublic int averageOfSubtree(TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null && root.right == null) return 1;\\n        return (root.val == average(root) ? 1 : 0) \\n            + averageOfSubtree(root.left) \\n            + averageOfSubtree(root.right);\\n    }\\n    \\n    private int average(TreeNode root) {\\n        int numNodes = 0;\\n        int sum = 0;\\n        Stack<TreeNode> nodes = new Stack<>();\\n        nodes.push(root);\\n        while (!nodes.isEmpty()) {\\n            TreeNode node = nodes.pop();\\n            numNodes++;\\n            sum += node.val;\\n            if (node.left != null) {\\n                nodes.push(node.left);\\n            }\\n            if (node.right != null) {\\n                nodes.push(node.right);\\n            }\\n        }\\n        return sum / numNodes;\\n    }\\n```\\nFeedback is appreciated!",
                "solutionTags": [],
                "code": "```java\\npublic int averageOfSubtree(TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null && root.right == null) return 1;\\n        return (root.val == average(root) ? 1 : 0) \\n            + averageOfSubtree(root.left) \\n            + averageOfSubtree(root.right);\\n    }\\n    \\n    private int average(TreeNode root) {\\n        int numNodes = 0;\\n        int sum = 0;\\n        Stack<TreeNode> nodes = new Stack<>();\\n        nodes.push(root);\\n        while (!nodes.isEmpty()) {\\n            TreeNode node = nodes.pop();\\n            numNodes++;\\n            sum += node.val;\\n            if (node.left != null) {\\n                nodes.push(node.left);\\n            }\\n            if (node.right != null) {\\n                nodes.push(node.right);\\n            }\\n        }\\n        return sum / numNodes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018065,
                "title": "very-easy-and-understandable-solution-cpp-pair-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n     int ans = 0;\\n    pair<int,int> solve(TreeNode* root){\\n        if(root==NULL) return {0,0};\\n        \\n        auto left = solve(root->left);\\n        int l_sum = left.first; // sum of nodes present in left sub tree\\n        int l_cnt = left.second; // no. of nodes present in left sub tree\\n        \\n        auto right = solve(root->right);\\n        int r_sum = right.first; // sum of nodes present in right sub tree\\n        int r_cnt = right.second; // no. of nodes present in left sub tree\\n        \\n        int sum = root->val+l_sum+r_sum;\\n        int cnt = l_cnt+r_cnt+1;\\n        \\n        if(root->val == sum/cnt) ans++;\\n        return {sum,cnt};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n     int ans = 0;\\n    pair<int,int> solve(TreeNode* root){\\n        if(root==NULL) return {0,0};\\n        \\n        auto left = solve(root->left);\\n        int l_sum = left.first; // sum of nodes present in left sub tree\\n        int l_cnt = left.second; // no. of nodes present in left sub tree\\n        \\n        auto right = solve(root->right);\\n        int r_sum = right.first; // sum of nodes present in right sub tree\\n        int r_cnt = right.second; // no. of nodes present in left sub tree\\n        \\n        int sum = root->val+l_sum+r_sum;\\n        int cnt = l_cnt+r_cnt+1;\\n        \\n        if(root->val == sum/cnt) ans++;\\n        return {sum,cnt};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018037,
                "title": "c-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    map<TreeNode*, int> mp;\\n    \\n    int help(TreeNode* root){\\n         if (root == NULL)    \\n        return 0;\\n  \\n    int currSum = root->val +\\n      help(root->left)\\n      + help(root->right);\\n    mp[root]=currSum;\\n    return currSum;\\n        \\n    }\\n    \\n    void countnode(TreeNode* root){\\n         if(root == nullptr) return ;\\n           count++;\\n         countnode(root->left);\\n         countnode(root->right);\\n  \\n     \\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n          help(root);  \\n          int ans = 0;\\n          for(auto i : mp){\\n              TreeNode* t = i.first;\\n              countnode(t);\\n              if((i.second / count) == i.first->val) ans++;\\n              count = 0;\\n          }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int count = 0;\\n    map<TreeNode*, int> mp;\\n    \\n    int help(TreeNode* root){\\n         if (root == NULL)    \\n        return 0;\\n  \\n    int currSum = root->val +\\n      help(root->left)\\n      + help(root->right);\\n    mp[root]=currSum;\\n    return currSum;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2018035,
                "title": "video-solution",
                "content": "https://www.youtube.com/watch?v=kVWus9fljrU\\n\\nProblem 1 - 00:00\\nProblem 2 - 02:50\\nProblem 3 - 08:47\\nProblem 4 - 17:49 \\nComment for appreciation or need for improvement.\\nThank You",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=kVWus9fljrU\\n\\nProblem 1 - 00:00\\nProblem 2 - 02:50\\nProblem 3 - 08:47\\nProblem 4 - 17:49 \\nComment for appreciation or need for improvement.\\nThank You",
                "codeTag": "Unknown"
            },
            {
                "id": 2018028,
                "title": "c-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int result = 0;\\n    \\n    pair <int, int> dfs(TreeNode* cur) {\\n        pair <int, int> sub = {0, 0};\\n        if (cur->left) {\\n            pair <int, int> temp = dfs(cur->left);\\n            sub.first += temp.first;\\n            sub.second += temp.second;\\n        }\\n        \\n        if (cur->right) {\\n            pair <int, int> temp = dfs(cur->right);\\n            sub.first += temp.first;\\n            sub.second += temp.second;\\n        }\\n        \\n        sub.first += 1;\\n        sub.second += (cur->val);\\n        if (sub.second / sub.first == (cur->val)) result++;\\n        return sub;\\n    }\\n    \\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        dfs(root);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int result = 0;\\n    \\n    pair <int, int> dfs(TreeNode* cur) {\\n        pair <int, int> sub = {0, 0};\\n        if (cur->left) {\\n            pair <int, int> temp = dfs(cur->left);\\n            sub.first += temp.first;\\n            sub.second += temp.second;\\n        }\\n        \\n        if (cur->right) {\\n            pair <int, int> temp = dfs(cur->right);\\n            sub.first += temp.first;\\n            sub.second += temp.second;\\n        }\\n        \\n        sub.first += 1;\\n        sub.second += (cur->val);\\n        if (sub.second / sub.first == (cur->val)) result++;\\n        return sub;\\n    }\\n    \\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        dfs(root);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017948,
                "title": "c-solution-using-dfs-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    struct avgSubtree{\\n      int sum,size;  \\n    };\\n    avgSubtree solve(TreeNode* root, int& cnt)\\n    {\\n        if(!root) return {0,0};\\n        avgSubtree left = solve(root->left,cnt);\\n        avgSubtree right = solve(root->right,cnt);\\n        int avg = (root->val+left.sum+right.sum)/(1+left.size+right.size);\\n        if(avg == root->val) cnt++;\\n        return {root->val+left.sum+right.sum,1+left.size+right.size};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int cnt = 0;\\n        solve(root,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    struct avgSubtree{\\n      int sum,size;  \\n    };\\n    avgSubtree solve(TreeNode* root, int& cnt)\\n    {\\n        if(!root) return {0,0};\\n        avgSubtree left = solve(root->left,cnt);\\n        avgSubtree right = solve(root->right,cnt);\\n        int avg = (root->val+left.sum+right.sum)/(1+left.size+right.size);\\n        if(avg == root->val) cnt++;\\n        return {root->val+left.sum+right.sum,1+left.size+right.size};\\n    }\\n    int averageOfSubtree(TreeNode* root) {\\n        int cnt = 0;\\n        solve(root,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017870,
                "title": "simple-c-code-level-wise-dfs",
                "content": "We will perform a level by level traversal and on each node we\\'ll perform a DFS to find out its descendant\\'s sum and number of nodes.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int count;\\n    \\n    void solve(TreeNode* root, int &n, int &sum){\\n        if(root==NULL){\\n            return;\\n        }\\n        \\n        sum+=root->val;\\n        n+=1;    \\n        \\n        solve(root->left,n,sum);\\n        solve(root->right,n,sum);\\n        \\n    }\\n    \\npublic:\\n    Solution(){\\n        count = 0;\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            auto node = q.front();\\n            \\n            q.pop();\\n            \\n            int n=0;\\n            int sum=0;\\n        \\n            solve(node,n,sum);  \\n            \\n            int avg = sum/n;\\n            if(avg==node->val) count++;\\n            \\n            if(node->left!=NULL){\\n                q.push(node->left);\\n            }\\n            if(node->right!=NULL){\\n                q.push(node->right);\\n            }\\n              \\n        }\\n        \\n        return count;             \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int count;\\n    \\n    void solve(TreeNode* root, int &n, int &sum){\\n        if(root==NULL){\\n            return;\\n        }\\n        \\n        sum+=root->val;\\n        n+=1;    \\n        \\n        solve(root->left,n,sum);\\n        solve(root->right,n,sum);\\n        \\n    }\\n    \\npublic:\\n    Solution(){\\n        count = 0;\\n    }\\n    \\n    int averageOfSubtree(TreeNode* root) {\\n        \\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            \\n            auto node = q.front();\\n            \\n            q.pop();\\n            \\n            int n=0;\\n            int sum=0;\\n        \\n            solve(node,n,sum);  \\n            \\n            int avg = sum/n;\\n            if(avg==node->val) count++;\\n            \\n            if(node->left!=NULL){\\n                q.push(node->left);\\n            }\\n            if(node->right!=NULL){\\n                q.push(node->right);\\n            }\\n              \\n        }\\n        \\n        return count;             \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1762354,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            },
            {
                "id": 1837825,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            },
            {
                "id": 1758610,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            },
            {
                "id": 1718072,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            },
            {
                "id": 1576726,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            },
            {
                "id": 1953694,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            },
            {
                "id": 1940586,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            },
            {
                "id": 1930315,
                "content": [
                    {
                        "username": "amkrsh",
                        "content": "jai shree ram"
                    },
                    {
                        "username": "aarush_badkur30",
                        "content": "jai jai shree ram "
                    },
                    {
                        "username": "Ganes123",
                        "content": "jai jai shree Ram\\n"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "ram ram ji\\n"
                    },
                    {
                        "username": "ayushkumar_26",
                        "content": "Has anyone felt that the statement \"rounded down to the nearest integer.\" is misleading as in the test cases, the answers are accepted with rounded it to the integer value of the average not to its nearest integer !?"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Store in a pair the sum and the count and Simultaneously do average and check if avg==root->val."
                    },
                    {
                        "username": "Zarubov",
                        "content": "Could somebody explain me Wrong Answer result? Average is: (0 + 0 + 0) / 3 = 0\\n\\nroot = [0,0,0]\\nOutput\\n0\\nExpected\\n3"
                    },
                    {
                        "username": "AJordanek",
                        "content": "You should return number of nodes, not sum of their values"
                    },
                    {
                        "username": "chickooo",
                        "content": "the tree is in the form:\n```\n              0\n          /       \\\n       0 \n    /     \\\n 0\n```\nso the answer is\n     - (0/1) == 0\n     - (0/2) == 0\n     - (0/3) == 0\n\ntherefore count is 3"
                    },
                    {
                        "username": "shubhamcantcode",
                        "content": "all 3 nodes satisfy the criteria, average for all 3 is 0, number of nodes satisfying requirement : 3"
                    },
                    {
                        "username": "ythgad7",
                        "content": "Did anyone encountered Error while opening leetcode during first 15 minutes of contest?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Kuch nahi bhai Recursion has becoming daily meal ...\\nstarting days it was like magic and after few days I feel magician in me\\uD83D\\uDE0A\\nAlways remember  :  \"Ek case  solve karo bas, baaki  sab recursion sambhal lega\"\\uD83D\\uDE0E\\uD83E\\uDD1E"
                    },
                    {
                        "username": "LV-off",
                        "content": "Even though description says \"Round Off\", it doesn\\'t accept rounded value. It got accepted when compared grounded value;"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\\n\\nOne approach would be to use `Post Order Traversal` of the Tree. In postorder traversal, the left and the right nodes are visited before visiting the node."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of People That Can Be Seen in a Grid",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Replace Elements in an Array",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array <code>nums</code> that consists of <code>n</code> <strong>distinct</strong> positive integers. Apply <code>m</code> operations to this array, where in the <code>i<sup>th</sup></code> operation you replace the number <code>operations[i][0]</code> with <code>operations[i][1]</code>.</p>\n\n<p>It is guaranteed that in the <code>i<sup>th</sup></code> operation:</p>\n\n<ul>\n\t<li><code>operations[i][0]</code> <strong>exists</strong> in <code>nums</code>.</li>\n\t<li><code>operations[i][1]</code> does <strong>not</strong> exist in <code>nums</code>.</li>\n</ul>\n\n<p>Return <em>the array obtained after applying all the operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]\n<strong>Output:</strong> [3,2,7,1]\n<strong>Explanation:</strong> We perform the following operations on nums:\n- Replace the number 1 with 3. nums becomes [<u><strong>3</strong></u>,2,4,6].\n- Replace the number 4 with 7. nums becomes [3,2,<u><strong>7</strong></u>,6].\n- Replace the number 6 with 1. nums becomes [3,2,7,<u><strong>1</strong></u>].\nWe return the final array [3,2,7,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2], operations = [[1,3],[2,1],[3,2]]\n<strong>Output:</strong> [2,1]\n<strong>Explanation:</strong> We perform the following operations to nums:\n- Replace the number 1 with 3. nums becomes [<u><strong>3</strong></u>,2].\n- Replace the number 2 with 1. nums becomes [3,<u><strong>1</strong></u>].\n- Replace the number 3 with 2. nums becomes [<u><strong>2</strong></u>,1].\nWe return the array [2,1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == operations.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li>All the values of <code>nums</code> are <strong>distinct</strong>.</li>\n\t<li><code>operations[i].length == 2</code></li>\n\t<li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>operations[i][0]</code> will exist in <code>nums</code> when applying the <code>i<sup>th</sup></code> operation.</li>\n\t<li><code>operations[i][1]</code> will not exist in <code>nums</code> when applying the <code>i<sup>th</sup></code> operation.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2111979,
                "title": "linear-2-pass-intution",
                "content": "**Intuition**\\n    We need record the `index w.r.t to every original value` , for `updating the new values values later in operations at its index stored`.\\n\\t**Why??** We can only change the array if we have access to its index. For getting the access so that we can change its place with new value, we need to store index.\\n    **How??** We will use a data structure which stores key-value pair i.e **MAP**.\\n    \\n**Algorithm**:\\n + We will simply create a array where we will store the index corresponding to its index.\\n + While doing operations , we will just have to access the index of original we stored and replace the new value to its index and update that index correspoding to that new value.\\n\\n# C++\\n     vector<int> arrayChange(vector<int>& A, vector<vector<int>>& op) {\\n        unordered_map<int,int> store;\\n        for(int i=0;i<A.size();i++) store[A[i]]=i;\\n        for(auto i:op){\\n            A[store[i[0]]]= i[1];           //replace value to its index\\n            store[i[1]]= store[i[0]];       //update new value with its index\\n        }\\n        return A;\\n    } \\n\\t\\n# Java\\n    public int[] arrayChange(int[] A, int[][] op) {\\n        HashMap<Integer,Integer> store= new HashMap<>();\\n        for(int i=0;i<A.length;i++) store.put(A[i],i);\\n        for(var i:op){\\n            A[store.get(i[0])]= i[1];              //replace value to its index\\n            store.put(i[1],store.get(i[0]));       //update new value with its index\\n        }\\n        return A;\\n    }\\nTime - O(N)\\nSpace- O(count of unqiue values)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Intuition**\\n    We need record the `index w.r.t to every original value` , for `updating the new values values later in operations at its index stored`.\\n\\t**Why??** We can only change the array if we have access to its index. For getting the access so that we can change its place with new value, we need to store index.\\n    **How??** We will use a data structure which stores key-value pair i.e **MAP**.\\n    \\n**Algorithm**:\\n + We will simply create a array where we will store the index corresponding to its index.\\n + While doing operations , we will just have to access the index of original we stored and replace the new value to its index and update that index correspoding to that new value.\\n\\n# C++\\n     vector<int> arrayChange(vector<int>& A, vector<vector<int>>& op) {\\n        unordered_map<int,int> store;\\n        for(int i=0;i<A.size();i++) store[A[i]]=i;\\n        for(auto i:op){\\n            A[store[i[0]]]= i[1];           //replace value to its index\\n            store[i[1]]= store[i[0]];       //update new value with its index\\n        }\\n        return A;\\n    } \\n\\t\\n# Java\\n    public int[] arrayChange(int[] A, int[][] op) {\\n        HashMap<Integer,Integer> store= new HashMap<>();\\n        for(int i=0;i<A.length;i++) store.put(A[i],i);\\n        for(var i:op){\\n            A[store.get(i[0])]= i[1];              //replace value to its index\\n            store.put(i[1],store.get(i[0]));       //update new value with its index\\n        }\\n        return A;\\n    }\\nTime - O(N)\\nSpace- O(count of unqiue values)",
                "codeTag": "Unknown"
            },
            {
                "id": 2112285,
                "title": "python-simple-map-approach",
                "content": "The core logic for this is the reversed iteration to construct the final replacements list.The reversed iteration helps to link the last replacement.\\n\\nThere can be chain of `operations` which will replace the same index in the array.\\neg:\\n> **operations = [[1,2], [2,3], [3,4]], nums = [1, 7, 9, 10]**\\n\\nIf you consider this example, the chain of operations are: `1-> 2 -> 3 -> 4`. So by transitive property we only care only about this replacement: `1->4`. The reversed iteration helps me to connect this link in `O(1)` with `replacements[x] = replacements.get(y, y)` logic. If I start from first, I would need a `O(n)` search.\\n\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n            replacements = {}\\n            for x, y in reversed(operations):\\n                replacements[x] = replacements.get(y, y)\\n            for idx, val in enumerate(nums):\\n                if val in replacements:\\n                    nums[idx] = replacements[val]\\n            return nums\\n```\\n\\n**Time - O(n)**\\n**Space - O(n)** - space for storing positions of each element in input `nums`\\n\\n---\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n            replacements = {}\\n            for x, y in reversed(operations):\\n                replacements[x] = replacements.get(y, y)\\n            for idx, val in enumerate(nums):\\n                if val in replacements:\\n                    nums[idx] = replacements[val]\\n            return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112664,
                "title": "global-array-fastest-so-far",
                "content": "Instead of a hashmap, we can use a global array. Based on the problem definition, we do not even need to initialize it, and clean-up between test cases.\\n\\nIt\\'s accepted within 347 ms, which is faster than any contest submission.\\n\\n**C++**\\n```cpp\\nint m[1000001];\\nclass Solution {\\npublic:\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n    for (int i = 0; i < nums.size(); ++i)\\n        m[nums[i]] = i;\\n    for (auto &op : operations) {\\n        nums[m[op[0]]] = op[1];\\n        m[op[1]] = m[op[0]];\\n    }\\n    return nums;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint m[1000001];\\nclass Solution {\\npublic:\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n    for (int i = 0; i < nums.size(); ++i)\\n        m[nums[i]] = i;\\n    for (auto &op : operations) {\\n        nums[m[op[0]]] = op[1];\\n        m[op[1]] = m[op[0]];\\n    }\\n    return nums;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112012,
                "title": "map-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]]=i;\\n        for(int i=0;i<operations.size();i++){\\n            int pos=mp[operations[i][0]];\\n            nums[pos]=operations[i][1];\\n            mp[operations[i][1]]=pos;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]]=i;\\n        for(int i=0;i<operations.size();i++){\\n            int pos=mp[operations[i][0]];\\n            nums[pos]=operations[i][1];\\n            mp[operations[i][1]]=pos;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111896,
                "title": "like-really-is-this-the-third-problem",
                "content": "It is an easy problem . Idk why leetcode set it at number 3.\\nHave a look at the code !\\n**Time Complexity : O(n)\\nSpace Complexity : O(n) (hashmap)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        unordered_map<int,int> hm;     //****store index of element in map\\n        for(int i =0;i<nums.size();i++){\\n            \\n            hm[nums[i]] = i;   //** use map to find the index \\n        }\\n        \\n        for(int i =0;i<operations.size();i++){\\n            \\n            \\n            int a  = operations[i][0];\\n            int b = operations[i][1];\\n            \\n            nums[hm[a]] = b;\\n            \\n            hm[b] = hm[a];  //**also store the changed element in hashmap\\n            \\n            \\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        unordered_map<int,int> hm;     //****store index of element in map\\n        for(int i =0;i<nums.size();i++){\\n            \\n            hm[nums[i]] = i;   //** use map to find the index \\n        }\\n        \\n        for(int i =0;i<operations.size();i++){\\n            \\n            \\n            int a  = operations[i][0];\\n            int b = operations[i][1];\\n            \\n            nums[hm[a]] = b;\\n            \\n            hm[b] = hm[a];  //**also store the changed element in hashmap\\n            \\n            \\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112136,
                "title": "simple-java-solution-using-map",
                "content": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> valIndexMap = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            valIndexMap.put(nums[i],i);\\n        }\\n        for(int [] operation: operations){\\n            int index = valIndexMap.get(operation[0]);\\n            nums[index] = operation[1];\\n            valIndexMap.remove(operation[0]);\\n            valIndexMap.put(nums[index], index);\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> valIndexMap = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            valIndexMap.put(nums[i],i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111989,
                "title": "short-unordered-map-solution-c",
                "content": "```\\nunordered_map<int,int> mp;\\n    \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        for(int i=0 ; i < nums.size() ; i++) mp[nums[i]] = i; //Save position of each value\\n        for(vector<int> a : operations) mp[a[1]] = mp[a[0]] , mp[a[0]] = -1; \\n\\t\\t// When a-> b we give position of a to b, mark that a is not in the array anymore\\n        for(auto i : mp)\\n            if(i.second >= 0) // If value is in array\\n                nums[i.second] = i.first;\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nunordered_map<int,int> mp;\\n    \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        for(int i=0 ; i < nums.size() ; i++) mp[nums[i]] = i; //Save position of each value\\n        for(vector<int> a : operations) mp[a[1]] = mp[a[0]] , mp[a[0]] = -1; \\n\\t\\t// When a-> b we give position of a to b, mark that a is not in the array anymore\\n        for(auto i : mp)\\n            if(i.second >= 0) // If value is in array\\n                nums[i.second] = i.first;\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112134,
                "title": "java-c-simplest-third-problem-ever",
                "content": "\\n\\nWe have to just perform operations in the sequence that they have given\\n\\n**JAVA SOLUTION**\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int arr[]:operations){\\n            int idx=map.get(arr[0]);\\n            nums[idx]=arr[1];\\n            map.remove(arr[0]);\\n            map.put(arr[1],idx);\\n        }\\n        return nums;\\n    }\\n}\\n```\\n\\n**C++ SOLUTION**\\n```\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int,int> ma;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            ma[nums[i]]=i;\\n        }\\n        \\n        for(auto arr:operations){\\n            int idx=ma[arr[0]];\\n            nums[idx]=arr[1];\\n            ma.erase(arr[0]);\\n            ma[arr[1]]=idx;\\n        }\\n        return nums;\\n    }\\n```\\n\\t\\nFeel free to comment if you have any doubt,\\n**Upvote the solution if you Like it**\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int arr[]:operations){\\n            int idx=map.get(arr[0]);\\n            nums[idx]=arr[1];\\n            map.remove(arr[0]);\\n            map.put(arr[1],idx);\\n        }\\n        return nums;\\n    }\\n}\\n```\n```\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int,int> ma;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            ma[nums[i]]=i;\\n        }\\n        \\n        for(auto arr:operations){\\n            int idx=ma[arr[0]];\\n            nums[idx]=arr[1];\\n            ma.erase(arr[0]);\\n            ma[arr[1]]=idx;\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112106,
                "title": "python-two-solutions-with-explanation",
                "content": "**Solution 1: Index mapping**\\nWe buid a hashmap that contains {value: index} key pairs. Based on the index looked up from that hashmap, for each operation, we update both the replaced value in nums, and the {updated num: index} key-value pair in the hashmap\\nTotal runtime: `O(len(nums))` to build the hashmap + `O(len(operations))` to update the output array => `O(max(len(nums), len(operations))`\\n```\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        dic = {num: i for i, num in enumerate(nums)}\\n        for s, e in operations:\\n            i = dic[s]\\n            nums[i] = e\\n            dic[e] = i\\n            del dic[s]\\n        return nums\\n```\\n**Solution 2: Swap mapping**\\nLet say we have the following operations: a -> b, b -> c, c -> d, we know that in the end a will be transformed to d\\nSo we want to build a hashmap that contains a -> d key-value pair\\nWe can do this by traversing the operations backward and with this line `swaps[s] = swaps[e] if e in swaps else e`, the dictionary will be updated each iteration. Example:\\nIteration 1: {c -> d}\\nIteration 2: {c -> d, b -> d}\\nIteration 3: {c -> d, b -> d, a -> d}\\nTotal runtime: `O(len(operations))` to build the hashmap + `O(len(nums))` to update the output array => `O(max(len(operations), len(nums))`\\n```\\ndef arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n\\tswaps = {}\\n\\tfor s, e in reversed(operations):\\n\\t\\tswaps[s] = swaps[e] if e in swaps else e\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif num in swaps:\\n\\t\\t\\tnums[i] = swaps[num]\\n\\treturn nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        dic = {num: i for i, num in enumerate(nums)}\\n        for s, e in operations:\\n            i = dic[s]\\n            nums[i] = e\\n            dic[e] = i\\n            del dic[s]\\n        return nums\\n```\n```\\ndef arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n\\tswaps = {}\\n\\tfor s, e in reversed(operations):\\n\\t\\tswaps[s] = swaps[e] if e in swaps else e\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif num in swaps:\\n\\t\\t\\tnums[i] = swaps[num]\\n\\treturn nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2113084,
                "title": "java-python-3-o-m-n-codes-using-hashmap-dict-w-brief-explanation-and-analysis",
                "content": "Since the elements in `nums` are always distinct, we can use `HashMap/dict` to store (value, index) and update the corresponding values during traversal of `operations`.\\n```java\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> valIdx = new HashMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            valIdx.put(nums[i], i);\\n        }\\n        for (int[] op : operations) {\\n            nums[valIdx.get(op[0])] = op[1];\\n            valIdx.put(op[1], valIdx.remove(op[0]));\\n        }\\n        return nums;\\n    }\\n```\\n```python\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        val_idx = {val : idx for idx, val in enumerate(nums)}\\n        for a, b in operations:\\n            nums[val_idx[a]] = b\\n            val_idx[b] = val_idx.pop(a)\\n        return nums \\n```\\n\\n**Analysis:**\\n\\nTime: `O(m + n)`, space: `O(n)`, where `n = nums.length, m = operations.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> valIdx = new HashMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            valIdx.put(nums[i], i);\\n        }\\n        for (int[] op : operations) {\\n            nums[valIdx.get(op[0])] = op[1];\\n            valIdx.put(op[1], valIdx.remove(op[0]));\\n        }\\n        return nums;\\n    }\\n```\n```python\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        val_idx = {val : idx for idx, val in enumerate(nums)}\\n        for a, b in operations:\\n            nums[val_idx[a]] = b\\n            val_idx[b] = val_idx.pop(a)\\n        return nums \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3329148,
                "title": "best-c-solution-ever-hash-table-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolved using Array + Hash Table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(N), Unordered map space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space Complexity : O(N), unordered map space.\\n\\n    Solved using Array + Hash Table.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = nums.size(), m = operations.size();\\n        unordered_map<int, int> map;\\n        for(int i=0; i<n; i++){\\n            map[nums[i]] = i;\\n        }\\n        for(int i=0; i<m; i++){\\n            int position = map[operations[i][0]];\\n            nums[position] = operations[i][1];\\n            map[operations[i][1]] = position;\\n        }\\n        return nums;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space Complexity : O(N), unordered map space.\\n\\n    Solved using Array + Hash Table.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = nums.size(), m = operations.size();\\n        unordered_map<int, int> map;\\n        for(int i=0; i<n; i++){\\n            map[nums[i]] = i;\\n        }\\n        for(int i=0; i<m; i++){\\n            int position = map[operations[i][0]];\\n            nums[position] = operations[i][1];\\n            map[operations[i][1]] = position;\\n        }\\n        return nums;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112645,
                "title": "easy-to-understand-c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int ind=m[operations[i][0]];\\n            m.erase(operations[i][0]);\\n           nums[ind]=operations[i][1];\\n            m[operations[i][1]]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int ind=m[operations[i][0]];\\n            m.erase(operations[i][0]);\\n           nums[ind]=operations[i][1];\\n            m[operations[i][1]]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777124,
                "title": "c-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need record the index w.r.t to every original value , for updating the new values values later in operations at its index stored.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will simply create a array where we will store the index corresponding to its index.\\n- While doing operations , we will just have to access the index of original we stored and replace the new value to its index and update that index correspoding to that new value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> m;\\n        for(int i=0; i<nums.size(); i++) {\\n            m[nums[i]] = i;\\n        }\\n        for(int i=0; i<operations.size(); i++) {\\n            nums[m[operations[i][0]]] = operations[i][1];\\n            m[operations[i][1]] = m[operations[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(count of unqiue values)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> m;\\n        for(int i=0; i<nums.size(); i++) {\\n            m[nums[i]] = i;\\n        }\\n        for(int i=0; i<operations.size(); i++) {\\n            nums[m[operations[i][0]]] = operations[i][1];\\n            m[operations[i][1]] = m[operations[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112363,
                "title": "cpp-hash-map-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& v, vector<vector<int>>& ops) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<v.size();i++)mp[v[i]]=i;\\n        for(auto vv:ops){\\n            v[mp[vv[0]]]=vv[1];\\n            mp[vv[1]]=mp[vv[0]];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& v, vector<vector<int>>& ops) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<v.size();i++)mp[v[i]]=i;\\n        for(auto vv:ops){\\n            v[mp[vv[0]]]=vv[1];\\n            mp[vv[1]]=mp[vv[0]];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111882,
                "title": "map-solution",
                "content": "We need to store index of distinct values of nums array in a map. \\nWhile running through the operations get the index of current element and at that index add the new element. Aslo note we need to remove the previous value index pair and add the new value index pair.\\n\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++) map.put(nums[i],i);\\n        for(int[] op: operations) {\\n            nums[map.get(op[0])] = op[1];\\n            map.put(op[1],map.get(op[0]));\\n            map.remove(op[0]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++) map.put(nums[i],i);\\n        for(int[] op: operations) {\\n            nums[map.get(op[0])] = op[1];\\n            map.put(op[1],map.get(op[0]));\\n            map.remove(op[0]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118714,
                "title": "c-use-hashmap-easy-solution-with-comments",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        //store index of each number of nums into the hashmap mp\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]] = i;\\n        \\n        //iterate over operations\\n        for(auto it:operations)\\n        {\\n            //replace it[0] with it[1] in nums and reset the index of it[1] with it[0]\\n            nums[mp[it[0]]] = it[1];\\n            mp[it[1]] = mp[it[0]];\\n        }\\n        return nums;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        //store index of each number of nums into the hashmap mp\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]] = i;\\n        \\n        //iterate over operations\\n        for(auto it:operations)\\n        {\\n            //replace it[0] with it[1] in nums and reset the index of it[1] with it[0]\\n            nums[mp[it[0]]] = it[1];\\n            mp[it[1]] = mp[it[0]];\\n        }\\n        return nums;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112204,
                "title": "hashmap-damn-easy",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        \\n        // as we would need to search the element in nums, according to operations \\n        // we can use hashmap as search = 0(1) \\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i], i);\\n        }\\n        \\n        for(int i=0;i<operations.length;i++)\\n        {\\n            int index = map.get(operations[i][0]);\\n            nums[index] = operations[i][1];\\n            \\n            // modify the map\\n            map.remove(operations[i][0]);\\n            map.put(nums[index], index);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        \\n        // as we would need to search the element in nums, according to operations \\n        // we can use hashmap as search = 0(1) \\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i], i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111883,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        d = {} \\n        for i,num in enumerate(nums):\\n            d[num] = i #Save index of all elements in dictionary for O(1) lookup\\n        \\n        for x,r in operations:\\n            where = d[x] # Find location of operation from dictionary\\n            nums[where] = r # Complete the operation (Change number)\\n            del d[x]   # Update dictionary\\n            d[r] = where # Update dictionary\\n            \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        d = {} \\n        for i,num in enumerate(nums):\\n            d[num] = i #Save index of all elements in dictionary for O(1) lookup\\n        \\n        for x,r in operations:\\n            where = d[x] # Find location of operation from dictionary\\n            nums[where] = r # Complete the operation (Change number)\\n            del d[x]   # Update dictionary\\n            d[r] = where # Update dictionary\\n            \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121070,
                "title": "easy-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\n    let map = new Map()\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        let num = nums[i]\\n        map.set(num, i)\\n    }\\n    \\n    for(let op of operations){\\n        let key = op[0]\\n        let value = op[1]\\n\\n        // if key exists\\n        if(map.has(key)){\\n            const idx = map.get(key)\\n            map.set(value, idx)\\n            map.delete(key)\\n        }\\n    }\\n    \\n    for(let [key, idx] of map){\\n        nums[idx] = key\\n    }\\n    \\n    return nums\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\n    let map = new Map()\\n    \\n    for(let i = 0; i < nums.length; i++){\\n        let num = nums[i]\\n        map.set(num, i)\\n    }\\n    \\n    for(let op of operations){\\n        let key = op[0]\\n        let value = op[1]\\n\\n        // if key exists\\n        if(map.has(key)){\\n            const idx = map.get(key)\\n            map.set(value, idx)\\n            map.delete(key)\\n        }\\n    }\\n    \\n    for(let [key, idx] of map){\\n        nums[idx] = key\\n    }\\n    \\n    return nums\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112638,
                "title": "4-liner-hash-map-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n\\t\\t\\tunordered_map<int,int> mp; \\n\\t\\t\\tfor(int i = 0;i < nums.size();i++) \\n\\t\\t\\t\\tmp[nums[i]] = i;\\n\\t\\t\\tfor(int i = 0;i < operations.size();i++) \\n\\t\\t\\t\\tnums[mp[operations[i][0]]] = operations[i][1], mp[operations[i][1]] = mp[operations[i][0]];\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\t};\\n\\t\\n**Time Complexity :** *O(n)*\\n**Space Complexity :** *O(n)*",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n\\t\\t\\tunordered_map<int,int> mp; \\n\\t\\t\\tfor(int i = 0;i < nums.size();i++) \\n\\t\\t\\t\\tmp[nums[i]] = i;\\n\\t\\t\\tfor(int i = 0;i < operations.size();i++) \\n\\t\\t\\t\\tnums[mp[operations[i][0]]] = operations[i][1], mp[operations[i][1]] = mp[operations[i][0]];\\n\\t\\t\\treturn nums;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2112154,
                "title": "straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& o) {\\n        unordered_map<int,int> parent;\\n        unordered_map<int,int> cha;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cha[nums[i]]=nums[i];\\n            parent[nums[i]]=nums[i];\\n        }\\n        for(int i=0;i<o.size();i++)\\n        {\\n            int a=o[i][0];\\n            int b=o[i][1];\\n         \\n                int pt=parent[a];\\n                cha[pt]=b;\\n                parent[b]=pt;\\n\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]=cha[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& o) {\\n        unordered_map<int,int> parent;\\n        unordered_map<int,int> cha;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cha[nums[i]]=nums[i];\\n            parent[nums[i]]=nums[i];\\n        }\\n        for(int i=0;i<o.size();i++)\\n        {\\n            int a=o[i][0];\\n            int b=o[i][1];\\n         \\n                int pt=parent[a];\\n                cha[pt]=b;\\n                parent[b]=pt;\\n\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]=cha[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111870,
                "title": "c-easy-map-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<size(nums);++i) mpp[nums[i]] = i; // store all the element\\'s current index in the map\\n        for(int i=0;i<size(operations);++i){\\n            int a = operations[i][0];\\n            int b = operations[i][1];\\n            int idx = mpp[a];\\n            nums[idx] = b;\\n            mpp[b] = idx; /* dont forget to update the updated element\\'s index in the map otherwise it will \\n                             store the previous index history  or for new element it will give 0  */\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<size(nums);++i) mpp[nums[i]] = i; // store all the element\\'s current index in the map\\n        for(int i=0;i<size(operations);++i){\\n            int a = operations[i][0];\\n            int b = operations[i][1];\\n            int idx = mpp[a];\\n            nums[idx] = b;\\n            mpp[b] = idx; /* dont forget to update the updated element\\'s index in the map otherwise it will \\n                             store the previous index history  or for new element it will give 0  */\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682495,
                "title": "c-solution-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& ops) \\n    {\\n         map<int,int>mp;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n           mp[nums[i]]=i;\\n         }       \\n         for(int i=0;i<ops.size();i++)\\n         {\\n            int currele=ops[i][0];\\n            int newele=ops[i][1];\\n            nums[mp[currele]]=newele;\\n            mp[newele]=mp[currele];\\n         }\\n         return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& ops) \\n    {\\n         map<int,int>mp;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n           mp[nums[i]]=i;\\n         }       \\n         for(int i=0;i<ops.size();i++)\\n         {\\n            int currele=ops[i][0];\\n            int newele=ops[i][1];\\n            nums[mp[currele]]=newele;\\n            mp[newele]=mp[currele];\\n         }\\n         return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682494,
                "title": "c-solution-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(int i=0;i<op.size();i++)\\n        {\\n            nums[mp[op[i][0]]]=op[i][1];\\n            mp[op[i][1]]=mp[op[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(int i=0;i<op.size();i++)\\n        {\\n            nums[mp[op[i][0]]]=op[i][1];\\n            mp[op[i][1]]=mp[op[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576037,
                "title": "java-easy-single-iteration-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] opt) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i=0;i<opt.length;i++){\\n            int oldNum=opt[i][0];\\n            int newNum=opt[i][1];\\n            \\n            if(map.containsKey(oldNum)){\\n                int index=map.get(oldNum);\\n                nums[index]=newNum;\\n                \\n                map.put(newNum,index);\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] opt) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i=0;i<opt.length;i++){\\n            int oldNum=opt[i][0];\\n            int newNum=opt[i][1];\\n            \\n            if(map.containsKey(oldNum)){\\n                int index=map.get(oldNum);\\n                nums[index]=newNum;\\n                \\n                map.put(newNum,index);\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295211,
                "title": "c-99-88-97-43-321ms-116-8mb-o-n-m-o-v-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int n=nums.size(),mp[1000001]={};//v id\\n        vector <int> rt(n),tmp(n+op.size());\\n        for(int i=0;i<n;++i){\\n            mp[nums[i]]=i+1;\\n            tmp.push_back(nums[i]);\\n        }\\n        for(int i=0;i<op.size();++i){\\n            mp[op[i][1]]=mp[op[i][0]];\\n            mp[op[i][0]]=0;\\n            tmp.push_back(op[i][1]);\\n        }\\n        for(int i=0;i<tmp.size();++i)\\n            if(mp[tmp[i]])\\n                rt[mp[tmp[i]]-1]=tmp[i];\\n        return rt;\\n    }\\n};\\n```\\n1.the range of nums[i] is small (<1e6) -> use array instead of STL map.\\n2.the number of map-used is less than n+m,we don\\'t need to iterator 1e6 of all number.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int n=nums.size(),mp[1000001]={};//v id\\n        vector <int> rt(n),tmp(n+op.size());\\n        for(int i=0;i<n;++i){\\n            mp[nums[i]]=i+1;\\n            tmp.push_back(nums[i]);\\n        }\\n        for(int i=0;i<op.size();++i){\\n            mp[op[i][1]]=mp[op[i][0]];\\n            mp[op[i][0]]=0;\\n            tmp.push_back(op[i][1]);\\n        }\\n        for(int i=0;i<tmp.size();++i)\\n            if(mp[tmp[i]])\\n                rt[mp[tmp[i]]-1]=tmp[i];\\n        return rt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120221,
                "title": "simple-fast-java-and-kotlin-solution-faster-than-100",
                "content": "Java code:\\n```\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        var hashMap = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            hashMap.put( nums[i],i);\\n        }\\n        for (int[] i : operations) {\\n            var index = hashMap.get(i[0]);\\n            nums[index] = i[1];\\n            hashMap.remove(i[0]);\\n            hashMap.put(i[1], index);\\n        }\\n        return nums;\\n    }\\n```\\n\\nKotlin code:\\n```\\n    fun arrayChange(nums: IntArray, operations: Array<IntArray>): IntArray {\\n        val hashMap = HashMap<Int, Int>()\\n        for (i in nums.indices) hashMap[nums[i]] = i\\n        for (i in operations) {\\n            val index = hashMap[i[0]]\\n            nums[index!!] = i[1]\\n            hashMap.remove(i[0])\\n            hashMap[i[1]] = index\\n        }\\n        return nums\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        var hashMap = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            hashMap.put( nums[i],i);\\n        }\\n        for (int[] i : operations) {\\n            var index = hashMap.get(i[0]);\\n            nums[index] = i[1];\\n            hashMap.remove(i[0]);\\n            hashMap.put(i[1], index);\\n        }\\n        return nums;\\n    }\\n```\n```\\n    fun arrayChange(nums: IntArray, operations: Array<IntArray>): IntArray {\\n        val hashMap = HashMap<Int, Int>()\\n        for (i in nums.indices) hashMap[nums[i]] = i\\n        for (i in operations) {\\n            val index = hashMap[i[0]]\\n            nums[index!!] = i[1]\\n            hashMap.remove(i[0])\\n            hashMap[i[1]] = index\\n        }\\n        return nums\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117678,
                "title": "c-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=i;\\n            \\n        }\\n        \\n        for(int i=0;i<operations.size();i++){\\n            if(mp.find(operations[i][0])!=mp.end()){\\n                int t=mp[operations[i][0]];\\n                nums[t]=operations[i][1];\\n                \\n                mp[operations[i][1]]=t;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=i;\\n            \\n        }\\n        \\n        for(int i=0;i<operations.size();i++){\\n            if(mp.find(operations[i][0])!=mp.end()){\\n                int t=mp[operations[i][0]];\\n                nums[t]=operations[i][1];\\n                \\n                mp[operations[i][1]]=t;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114523,
                "title": "replacing-elements-in-array-hashmap-faster",
                "content": "Hi,\\n\\nI solved this problem using Map, here are the following steps:\\n\\t1.First itrate throught the given array and store their index values,\\n\\t2.Itrate through the replace function,\\n\\t3.Get the key from map and change the key to new key\\n\\t4.Create a new array -> paste the elements in resultant array\\n\\t5.Return the new array\\n\\nKindly upvote if its helpful,\\n\\n```\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n    \\tHashMap<Integer, List<Integer>> map = new HashMap();\\n    \\tfor(int i=0; i<nums.length; i++){\\n    \\t\\tList<Integer> list = new ArrayList<Integer>();\\n    \\t\\tif(map.containsKey(nums[i]))\\n    \\t\\t{\\n    \\t\\t\\tlist = map.get(nums[i]);\\n    \\t\\t}\\n    \\t\\tlist.add(i);\\n    \\t\\tmap.put(nums[i], list);\\n    \\t}\\n    \\tint ops = operations.length;\\n    \\tfor(int i=0; i<ops; i++){\\n    \\t\\tif(map.containsKey(operations[i][0])){\\n    \\t\\t\\tList<Integer> list = map.get(operations[i][0]);\\n    \\t\\t\\tmap.remove(operations[i][0]);\\n    \\t\\t\\tmap.put(operations[i][1], list);\\n    \\t\\t}\\n    \\t}\\n    \\tint res[] = new int[nums.length];\\n    \\tmap.forEach((k,v) ->{\\n    \\t\\tList<Integer> list = v;\\n    \\t\\tfor(int i:list)\\n    \\t\\t\\tres[i] = k;\\n    \\t});\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nI solved this problem using Map, here are the following steps:\\n\\t1.First itrate throught the given array and store their index values,\\n\\t2.Itrate through the replace function,\\n\\t3.Get the key from map and change the key to new key\\n\\t4.Create a new array -> paste the elements in resultant array\\n\\t5.Return the new array\\n\\nKindly upvote if its helpful,\\n\\n```\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n    \\tHashMap<Integer, List<Integer>> map = new HashMap();\\n    \\tfor(int i=0; i<nums.length; i++){\\n    \\t\\tList<Integer> list = new ArrayList<Integer>();\\n    \\t\\tif(map.containsKey(nums[i]))\\n    \\t\\t{\\n    \\t\\t\\tlist = map.get(nums[i]);\\n    \\t\\t}\\n    \\t\\tlist.add(i);\\n    \\t\\tmap.put(nums[i], list);\\n    \\t}\\n    \\tint ops = operations.length;\\n    \\tfor(int i=0; i<ops; i++){\\n    \\t\\tif(map.containsKey(operations[i][0])){\\n    \\t\\t\\tList<Integer> list = map.get(operations[i][0]);\\n    \\t\\t\\tmap.remove(operations[i][0]);\\n    \\t\\t\\tmap.put(operations[i][1], list);\\n    \\t\\t}\\n    \\t}\\n    \\tint res[] = new int[nums.length];\\n    \\tmap.forEach((k,v) ->{\\n    \\t\\tList<Integer> list = v;\\n    \\t\\tfor(int i:list)\\n    \\t\\t\\tres[i] = k;\\n    \\t});\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2112575,
                "title": "java-hashmap-with-explanation",
                "content": "### Steps\\n1. build a map: <value, index>\\n2. for each operation <from, to>:\\n2.1. replace the `A[i] = to`  where i = map.get(from)\\n3. update the map\\n\\n### Complexity\\ntime: `O(n + m)` where n is size of A, m is number of operations\\nspace: `O(n)`\\n\\n---\\n### Java\\n```java\\npublic int[] arrayChange(int[] A, int[][] operations) {\\n\\tint n = A.length;\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap.put(A[i], i);\\n\\t}\\n\\n\\tfor (int[] op : operations) {\\n\\t\\tint from = op[0], to = op[1];\\n\\t\\tA[map.get(from)] = to;\\n\\t\\tmap.put(to, map.get(from));\\n\\t}\\n\\n\\treturn A;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int[] arrayChange(int[] A, int[][] operations) {\\n\\tint n = A.length;\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap.put(A[i], i);\\n\\t}\\n\\n\\tfor (int[] op : operations) {\\n\\t\\tint from = op[0], to = op[1];\\n\\t\\tA[map.get(from)] = to;\\n\\t\\tmap.put(to, map.get(from));\\n\\t}\\n\\n\\treturn A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112366,
                "title": "intuitive-c-approach-with-detailed-explanation",
                "content": "Upon looking at the problem statement, we must note what information is given to us.\\nGiven that : \\n1. **nums[n]** is the array on which the transformations must be performed\\n2. **operations[m][2]** array contains the transformations to be performed\\n\\nIt is clear that we must take at least O(m) steps to traverse the operations array in the correct order as shuffling the order could result in wrong answer (NOTE: Example Testcase 2)\\n\\n## Approach 1 : Linear Search (TLE)\\n\\nIntuitively, we could create an algorithm that does exactly what the problem statement mentions, i.e.,\\n1. Iterate through the operations matrix one row at a time\\n2. In each iteration, determine the index at which the operations[i][0] element is stored through some searching algorithm and update its value to be that stored in operations[i][1]\\n\\n```\\nclass Solution {\\nprivate:\\n    int linSearch(vector<int> &arr, int n)\\n    {\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(arr[i] == n)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int ind = 0;\\n        for(int i=0; i<op.size(); i++)\\n        {\\n            int ind = linSearch(nums, op[i][0]);\\n            nums[ind] = op[i][1];\\n        }\\n        return nums;\\n\\t}\\n};\\n```\\n\\nNote that: this approach can be further optimised by using the std::find() method\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int ind = 0;\\n        for(int i=0; i<op.size(); i++)\\n        {\\n            *find(nums.begin(), nums.end(), op[i][0]) = op[i][1];\\n        }\\n        return nums;\\n\\t}\\n};\\n```\\n\\nHere, Time Complexity : **O(m\\\\*n)**\\n\\n# Approach 2 : Using HashMap to maintain index-element pairs (AC)\\n\\nNow, we can further infer from the problem that, the primary process taking place in the problem is searching. This is because : \\n* As mentioned before, the operations[][] matrix must be traversed in the exact given order, and hence no optimisations can take place there.\\n* Replacing an element with another element is a process that takes O(1) time and hence does not require any optimisation.\\n* Thus, the only part of the problem that we can still optimise is the time taken to search for an element in the nums[] array.\\n\\nThis can be achieved by using a hashmap to reduce searching time from O(n) to O(1)\\n\\n```\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map <int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]] = i;\\n        \\n        for(int i=0; i<op.size(); i++)\\n        {\\n            int ind = mp[op[i][0]];\\n            nums[ind] = op[i][1];\\n            mp.erase(op[i][0]);\\n            mp[op[i][1]] = ind;\\n        }\\n        return nums;\\n\\t}\\n};\\n```\\n\\nThis approach has the Time Complexity : **O(m)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int linSearch(vector<int> &arr, int n)\\n    {\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            if(arr[i] == n)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int ind = 0;\\n        for(int i=0; i<op.size(); i++)\\n        {\\n            int ind = linSearch(nums, op[i][0]);\\n            nums[ind] = op[i][1];\\n        }\\n        return nums;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int ind = 0;\\n        for(int i=0; i<op.size(); i++)\\n        {\\n            *find(nums.begin(), nums.end(), op[i][0]) = op[i][1];\\n        }\\n        return nums;\\n\\t}\\n};\\n```\n```\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map <int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]] = i;\\n        \\n        for(int i=0; i<op.size(); i++)\\n        {\\n            int ind = mp[op[i][0]];\\n            nums[ind] = op[i][1];\\n            mp.erase(op[i][0]);\\n            mp[op[i][1]] = ind;\\n        }\\n        return nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112197,
                "title": "easy-python3-solution-using-map",
                "content": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        seen = {}\\n        for i in range(len(nums)):\\n            seen[nums[i]] =  i\\n        print(seen)\\n        for i in range(len(operations)):\\n            idx = seen.get(operations[i][0])\\n            \\n            nums[idx] = operations[i][1]\\n            seen.pop(operations[i][0])\\n            seen[operations[i][1]] = idx\\n        return nums\\n                \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        seen = {}\\n        for i in range(len(nums)):\\n            seen[nums[i]] =  i\\n        print(seen)\\n        for i in range(len(operations)):\\n            idx = seen.get(operations[i][0])\\n            \\n            nums[idx] = operations[i][1]\\n            seen.pop(operations[i][0])\\n            seen[operations[i][1]] = idx\\n        return nums\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112105,
                "title": "java-o-n-hashmap",
                "content": "Please upvote if you like\\nsimple approach is that we have to iterate from the back and check if the current operation is update or not if it is updated the update the operation value. remove the previous entry\\n\\n\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        for(int i=operations.length-1 ; i>=0 ;i--){\\n            if(map.containsKey(operations[i][1])){\\n                map.put(operations[i][0],map.get(operations[i][1]));\\n                map.remove(operations[i][1]);\\n            }\\n            else\\n                map.put(operations[i][0],operations[i][1]);\\n        }\\n        for(int i=0 ; i<nums.length ;i++){\\n            if(map.containsKey(nums[i])){\\n                nums[i]=map.get(nums[i]);\\n            }\\n        }\\n        return nums;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        for(int i=operations.length-1 ; i>=0 ;i--){\\n            if(map.containsKey(operations[i][1])){\\n                map.put(operations[i][0],map.get(operations[i][1]));\\n                map.remove(operations[i][1]);\\n            }\\n            else\\n                map.put(operations[i][0],operations[i][1]);\\n        }\\n        for(int i=0 ; i<nums.length ;i++){\\n            if(map.containsKey(nums[i])){\\n                nums[i]=map.get(nums[i]);\\n            }\\n        }\\n        return nums;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112098,
                "title": "c-easy-solution-using-map",
                "content": "class Solution {\\npublic:\\n    \\n\\tvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& q) {\\n        int n = nums.size();\\n        unordered_map<int,int>m;\\n        vector<int>c(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            m[nums[i]] = i;\\n        }\\n        for(int i=0;i<q.size();i++){\\n            c[m[q[i][0]]] = q[i][1];\\n            m[q[i][1]] = m[q[i][0]];  //updating the new value index in map\\n        }\\n        return c;\\n    }\\n};\\n// Plz Upvote if you like !!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& q) {\\n        int n = nums.size();\\n        unordered_map<int,int>m;\\n        vector<int>c(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            m[nums[i]] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111983,
                "title": "c-solution-using-mapand-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) \\n    {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(auto &it:op)\\n        {\\n            if(mp.find(it[0])!=mp.end())\\n            {\\n                auto t=mp.find(it[0]);\\n                 mp[it[1]]=t->second;\\n                mp.erase(t);\\n            }\\n        }\\n        vector<pair<int,int>>v;\\n        for(auto &[a,b]:mp)\\n        {\\n            v.push_back({b,a});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>ans;\\n        for(auto &it:v)\\n        {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) \\n    {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(auto &it:op)\\n        {\\n            if(mp.find(it[0])!=mp.end())\\n            {\\n                auto t=mp.find(it[0]);\\n                 mp[it[1]]=t->second;\\n                mp.erase(t);\\n            }\\n        }\\n        vector<pair<int,int>>v;\\n        for(auto &[a,b]:mp)\\n        {\\n            v.push_back({b,a});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int>ans;\\n        for(auto &it:v)\\n        {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111911,
                "title": "with-comment-s-c-using-mapping-of-value-index",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        // create mp to store nums value with their index\\n        map<int,int> mp;\\n        // insert nums array to map\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]] = i;\\n        }\\n        // update nums array\\n        // by mp[it[0]] we get index where to update value\\n        // at that index we will put it[1] --> UPDATED VALUE\\n        // then we will insert that updated value to map\\n        for(auto it : operations){\\n            nums[mp[it[0]]] = it[1];\\n            mp[nums[mp[it[0]]]] = mp[it[0]];\\n        }\\n        return nums;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        // create mp to store nums value with their index\\n        map<int,int> mp;\\n        // insert nums array to map\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]] = i;\\n        }\\n        // update nums array\\n        // by mp[it[0]] we get index where to update value\\n        // at that index we will put it[1] --> UPDATED VALUE\\n        // then we will insert that updated value to map\\n        for(auto it : operations){\\n            nums[mp[it[0]]] = it[1];\\n            mp[nums[mp[it[0]]]] = mp[it[0]];\\n        }\\n        return nums;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111863,
                "title": "easy-map-solution-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tfor(int i=0;i<size(nums);i++) mp[nums[i]] = i;\\n\\t\\t\\tfor(auto val:operations){\\n\\t\\t\\t\\tint ind = mp[val[0]];\\n\\t\\t\\t\\tmp.erase(val[0]);\\n\\t\\t\\t\\tmp[val[1]] = ind;\\n\\t\\t\\t}\\n\\t\\t\\tvector<int>res(size(nums));\\n\\t\\t\\tfor(auto [val,i]:mp) res[i] = val;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tfor(int i=0;i<size(nums);i++) mp[nums[i]] = i;\\n\\t\\t\\tfor(auto val:operations){\\n\\t\\t\\t\\tint ind = mp[val[0]];\\n\\t\\t\\t\\tmp.erase(val[0]);\\n\\t\\t\\t\\tmp[val[1]] = ind;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3988918,
                "title": "java-code-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] ops) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }\\n        for (int i[]:ops){\\n            int idx=hm.remove(i[0]);\\n            hm.put(i[1],idx);\\n        }\\n        for (int i:hm.keySet()){\\n            nums[hm.get(i)]=i;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] ops) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }\\n        for (int i[]:ops){\\n            int idx=hm.remove(i[0]);\\n            hm.put(i[1],idx);\\n        }\\n        for (int i:hm.keySet()){\\n            nums[hm.get(i)]=i;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956174,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& a) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n           mp[nums[i]]=i;\\n        }\\n        for(int i=0;i<a.size();i++){\\n            int ind;\\n            if(mp.find(a[i][0])!=mp.end()){\\n                ind=mp[a[i][0]];\\n              nums[ind]=a[i][1];\\n             \\n            }\\n            mp[a[i][1]]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& a) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n           mp[nums[i]]=i;\\n        }\\n        for(int i=0;i<a.size();i++){\\n            int ind;\\n            if(mp.find(a[i][0])!=mp.end()){\\n                ind=mp[a[i][0]];\\n              nums[ind]=a[i][1];\\n             \\n            }\\n            mp[a[i][1]]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712594,
                "title": "c-easy-to-understand-self-explanatory-code-map",
                "content": "\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=i;\\n        }   \\n        for(int i=0;i<operations.size();i++){\\n            auto it=mp.find(operations[i][0]);\\n            if(it==mp.end()) continue;\\n            // cout<<it->first<<\" \"<<it->second<<endl;\\n            nums[it->second]=operations[i][1];\\n            mp[operations[i][1]]=it->second;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=i;\\n        }   \\n        for(int i=0;i<operations.size();i++){\\n            auto it=mp.find(operations[i][0]);\\n            if(it==mp.end()) continue;\\n            // cout<<it->first<<\" \"<<it->second<<endl;\\n            nums[it->second]=operations[i][1];\\n            mp[operations[i][1]]=it->second;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3691595,
                "title": "o-n-space-o-n-time-solution-using-a-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n    index_map = defaultdict(int)\\n    for i, n in enumerate(nums):\\n      index_map[n] = i\\n    \\n    for op in operations:\\n      n1, n2 = op\\n      nums[index_map[n1]] = n2\\n      index_map[n2] = index_map[n1]\\n    \\n    return nums\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n    index_map = defaultdict(int)\\n    for i, n in enumerate(nums):\\n      index_map[n] = i\\n    \\n    for op in operations:\\n      n1, n2 = op\\n      nums[index_map[n1]] = n2\\n      index_map[n2] = index_map[n1]\\n    \\n    return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430743,
                "title": "javascripts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\n    operations.forEach(operation => {\\n        nums[nums.indexOf(operation[0])] = operation[1];\\n    })\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\n    operations.forEach(operation => {\\n        nums[nums.indexOf(operation[0])] = operation[1];\\n    })\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196931,
                "title": "crisp-n-clear-o-n-javascript-memory-70-72-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar arrayChange = function(nums, operations) {\\n\\tconst config = (function() {\\n\\t\\tconst config = {};\\n\\t\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\t\\tconfig[nums[index]] = index;\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\n\\tconst resolveOperations = (function() {\\n\\t\\tconst config = {};\\n\\t\\tconst reverseConfig = {};\\n\\t\\tfor (let index = 0; index < operations.length; index++) {\\n\\t\\t\\tif (reverseConfig[operations[index][0]] !== undefined) {\\n\\t\\t\\t\\tconst store = reverseConfig[operations[index][0]];\\n\\t\\t\\t\\tconfig[reverseConfig[operations[index][0]]] = operations[index][1];\\n\\t\\t\\t\\treverseConfig[operations[index][1]] = store;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconfig[operations[index][0]] = operations[index][1];\\n\\t\\t\\t\\treverseConfig[operations[index][1]] = operations[index][0];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\n\\tfor (const toBeReplaced in resolveOperations) {\\n\\t\\tconst toBeReplacedWith = resolveOperations[toBeReplaced];\\n\\t\\tconst temp = config[toBeReplaced];\\n\\t\\tnums[temp] = toBeReplacedWith;\\n\\t}\\n\\treturn nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayChange = function(nums, operations) {\\n\\tconst config = (function() {\\n\\t\\tconst config = {};\\n\\t\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\t\\tconfig[nums[index]] = index;\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\n\\tconst resolveOperations = (function() {\\n\\t\\tconst config = {};\\n\\t\\tconst reverseConfig = {};\\n\\t\\tfor (let index = 0; index < operations.length; index++) {\\n\\t\\t\\tif (reverseConfig[operations[index][0]] !== undefined) {\\n\\t\\t\\t\\tconst store = reverseConfig[operations[index][0]];\\n\\t\\t\\t\\tconfig[reverseConfig[operations[index][0]]] = operations[index][1];\\n\\t\\t\\t\\treverseConfig[operations[index][1]] = store;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconfig[operations[index][0]] = operations[index][1];\\n\\t\\t\\t\\treverseConfig[operations[index][1]] = operations[index][0];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\n\\tfor (const toBeReplaced in resolveOperations) {\\n\\t\\tconst toBeReplacedWith = resolveOperations[toBeReplaced];\\n\\t\\tconst temp = config[toBeReplaced];\\n\\t\\tnums[temp] = toBeReplacedWith;\\n\\t}\\n\\treturn nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2856391,
                "title": "simulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> m;\\n        for(int i=0; i<nums.size(); i++) m[nums[i]] = i;\\n        \\n        for(auto op : operations) {\\n            int idx = m[op[0]];\\n            m.erase(op[0]);\\n            m[op[1]] = idx;\\n        }\\n        \\n        vector<int> ans(nums.size());\\n        for(auto i : m) ans[i.second] = i.first;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> m;\\n        for(int i=0; i<nums.size(); i++) m[nums[i]] = i;\\n        \\n        for(auto op : operations) {\\n            int idx = m[op[0]];\\n            m.erase(op[0]);\\n            m[op[1]] = idx;\\n        }\\n        \\n        vector<int> ans(nums.size());\\n        for(auto i : m) ans[i.second] = i.first;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744282,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   unordered_map<int,int> mp;\\n    \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        for(int i=0 ; i < nums.size() ; i++) mp[nums[i]] = i; \\n        for(vector<int> a : operations) mp[a[1]] = mp[a[0]] , mp[a[0]] = -1; \\n        for(auto i : mp)\\n            if(i.second >= 0) \\n                nums[i.second] = i.first;\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   unordered_map<int,int> mp;\\n    \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        for(int i=0 ; i < nums.size() ; i++) mp[nums[i]] = i; \\n        for(vector<int> a : operations) mp[a[1]] = mp[a[0]] , mp[a[0]] = -1; \\n        for(auto i : mp)\\n            if(i.second >= 0) \\n                nums[i.second] = i.first;\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583995,
                "title": "java-solution",
                "content": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> hmp=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hmp.put(nums[i],i);\\n            \\n        }\\n        for(int j=0;j<operations.length;j++){\\n            int oldVal=operations[j][0];\\n            int newVal=operations[j][1];\\n            if(hmp.containsKey(oldVal)){\\n                int index=hmp.get(oldVal);\\n                nums[index]=newVal;\\n                hmp.put(newVal,index);\\n            }\\n        }\\n        \\n      return nums;  \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> hmp=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hmp.put(nums[i],i);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2546483,
                "title": "javascript-hashmap",
                "content": "```\\nvar arrayChange = function(nums, operations) {\\n    const map = {};\\n    nums.map((val, i) => map[val] = i);\\n    for (let [i, val] of operations) {\\n        nums[map[i]] = val;\\n        map[val] = map[i];\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrayChange = function(nums, operations) {\\n    const map = {};\\n    nums.map((val, i) => map[val] = i);\\n    for (let [i, val] of operations) {\\n        nums[map[i]] = val;\\n        map[val] = map[i];\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387005,
                "title": "simplest-solution",
                "content": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        \\n        dic = {}\\n        \\n        for i in range(len(nums)):\\n            dic[nums[i]] = i\\n            \\n        \\n        for i, j  in  operations:\\n            nums[dic[i]] = j\\n            dic[j] = dic.pop(i)\\n            \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        \\n        dic = {}\\n        \\n        for i in range(len(nums)):\\n            dic[nums[i]] = i\\n            \\n        \\n        for i, j  in  operations:\\n            nums[dic[i]] = j\\n            dic[j] = dic.pop(i)\\n            \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281871,
                "title": "hashmap-easy-solution-c-easy-to-understand",
                "content": "Think of using a data-structure to store the positions of numbers in nums array. So we can use hash-map here. And replace the number at that position using positions from our map. Also keep updating your map as you proceed.\\n\\n```\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < nums.size(); i++)\\n            mp[nums[i]] = i;\\n        for(int i = 0; i < operations.size(); i++) {\\n            nums[mp[operations[i][0]]] = operations[i][1];\\n            mp[operations[i][1]] = mp[operations[i][0]];\\n            mp.erase(operations[i][0]);\\n        }\\n        return nums;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Think of using a data-structure to store the positions of numbers in nums array. So we can use hash-map here. And replace the number at that position using positions from our map. Also keep updating your map as you proceed.\\n\\n```\\nvector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < nums.size(); i++)\\n            mp[nums[i]] = i;\\n        for(int i = 0; i < operations.size(); i++) {\\n            nums[mp[operations[i][0]]] = operations[i][1];\\n            mp[operations[i][1]] = mp[operations[i][0]];\\n            mp.erase(operations[i][0]);\\n        }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2192942,
                "title": "slow-map-solution",
                "content": "programming isnt about optimising everything, it\\'s about finding a code that works\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int, int> m;\\n        for (int i = 0; i < nums.size(); i++) {\\n            m[nums[i]] = i;\\n        }\\n        for (auto i : operations){\\n            nums[m[i[0]]] = i[1];\\n            m[i[1]] = m[i[0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int, int> m;\\n        for (int i = 0; i < nums.size(); i++) {\\n            m[nums[i]] = i;\\n        }\\n        for (auto i : operations){\\n            nums[m[i[0]]] = i[1];\\n            m[i[1]] = m[i[0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177256,
                "title": "easy-and-simple-c",
                "content": "class Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]=i;\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int index=m[operations[i][0]];\\n            nums[index]=operations[i][1];\\n            m.erase(operations[i][0]);\\n            m[operations[i][1]]=index;\\n        }\\n         return nums;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]=i;\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int index=m[operations[i][0]];\\n            nums[index]=operations[i][1];\\n            m.erase(operations[i][0]);\\n            m[operations[i][1]]=index;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2176312,
                "title": "c-using-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        map<int, int> myMap;\\n        int tempIndex;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            myMap[nums[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < operations.size(); i++)\\n        {\\n            tempIndex = myMap[operations[i][0]];\\n        \\n            nums[tempIndex] = operations[i][1];\\n            \\n            myMap.erase(operations[i][0]);\\n            myMap[operations[i][1]] = tempIndex;\\n        }\\n   \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        map<int, int> myMap;\\n        int tempIndex;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            myMap[nums[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < operations.size(); i++)\\n        {\\n            tempIndex = myMap[operations[i][0]];\\n        \\n            nums[tempIndex] = operations[i][1];\\n            \\n            myMap.erase(operations[i][0]);\\n            myMap[operations[i][1]] = tempIndex;\\n        }\\n   \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174297,
                "title": "kotlin-very-concise-solution-o-n",
                "content": "```\\nclass Solution {\\n    fun arrayChange(nums: IntArray, operations: Array<IntArray>): IntArray {\\n        val replaces = hashMapOf<Int, Int>()\\n        for ((from, to) in operations.reversed()) {\\n            replaces[from] = replaces[to] ?: to\\n        }\\n        return nums.map { replaces[it] ?: it }.toIntArray()        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun arrayChange(nums: IntArray, operations: Array<IntArray>): IntArray {\\n        val replaces = hashMapOf<Int, Int>()\\n        for ((from, to) in operations.reversed()) {\\n            replaces[from] = replaces[to] ?: to\\n        }\\n        return nums.map { replaces[it] ?: it }.toIntArray()        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161980,
                "title": "java-hashmap-difficulty-should-be-easy",
                "content": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i=0; i<nums.length; i++) map.put(nums[i], i);\\n            \\n        for (int[] operation : operations) {\\n            int index = map.remove(operation[0]);\\n            map.put(operation[1], index);\\n        }\\n        \\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            nums[entry.getValue()] = entry.getKey();\\n        }\\n        \\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        \\n        final Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i=0; i<nums.length; i++) map.put(nums[i], i);\\n            \\n        for (int[] operation : operations) {\\n            int index = map.remove(operation[0]);\\n            map.put(operation[1], index);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2148372,
                "title": "unordered-map-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        int mm = operations.size();\\n        int n = nums.size();\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++)\\n        {\\n            m[nums[i]] = i;\\n        }\\n        for(int i=0; i<mm; i++)\\n        {\\n            nums[m[operations[i][0]]] = operations[i][1];\\n            \\n            m[operations[i][1]] = m[operations[i][0]];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        int mm = operations.size();\\n        int n = nums.size();\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++)\\n        {\\n            m[nums[i]] = i;\\n        }\\n        for(int i=0; i<mm; i++)\\n        {\\n            nums[m[operations[i][0]]] = operations[i][1];\\n            \\n            m[operations[i][1]] = m[operations[i][0]];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126180,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = nums.size();\\n        unordered_map<int,int> um;\\n        for(int i = 0; i < n; i++)\\n        {\\n            um[nums[i]] = i;\\n        }\\n        for(int i = 0; i < operations.size(); i++)\\n        {\\n            int fst = operations[i][0];\\n            int snd = operations[i][1];\\n            int idx = um[fst];\\n            um.erase(fst);\\n            um[snd] = idx;\\n            nums[idx] = snd;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = nums.size();\\n        unordered_map<int,int> um;\\n        for(int i = 0; i < n; i++)\\n        {\\n            um[nums[i]] = i;\\n        }\\n        for(int i = 0; i < operations.size(); i++)\\n        {\\n            int fst = operations[i][0];\\n            int snd = operations[i][1];\\n            int idx = um[fst];\\n            um.erase(fst);\\n            um[snd] = idx;\\n            nums[idx] = snd;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121953,
                "title": "scala-functional-immutable-solution-using-two-hashmaps",
                "content": "The `idxToNum` map is necessary because Scala is more efficient at making smart copies of `Map` than `Array`. Using `nums` directly will cause the last test case to fail the memory constraint.\\n\\n```\\n  def arrayChange(nums: Array[Int], operations: Array[Array[Int]]): Array[Int] =\\n    operations\\n      .foldLeft(nums.indices.zip(nums).toMap, nums.zipWithIndex.toMap) {\\n        case ((idxToNum, numToIdx), Array(prev, curr)) =>\\n          (idxToNum.updated(numToIdx(prev), curr), numToIdx.removed(prev).updated(curr, numToIdx(prev)))\\n      }\\n      ._1\\n      .toArray\\n      .sortBy { case (idx, _) => idx }\\n      .map { case (_, num) => num }\\n```",
                "solutionTags": [],
                "code": "```\\n  def arrayChange(nums: Array[Int], operations: Array[Array[Int]]): Array[Int] =\\n    operations\\n      .foldLeft(nums.indices.zip(nums).toMap, nums.zipWithIndex.toMap) {\\n        case ((idxToNum, numToIdx), Array(prev, curr)) =>\\n          (idxToNum.updated(numToIdx(prev), curr), numToIdx.removed(prev).updated(curr, numToIdx(prev)))\\n      }\\n      ._1\\n      .toArray\\n      .sortBy { case (idx, _) => idx }\\n      .map { case (_, num) => num }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2117915,
                "title": "python-linear-traversal-using-dictionary",
                "content": "\\nSimple Linear Traversal using Dictionary  Python Solution\\n\\n    def arrayChange(self, nums: List[int], op: List[List[int]]) -> List[int]:\\n        temp={}\\n        for i in range(len(nums)):\\n            temp[nums[i]]=i        #Creating dictionary with indices as value to num[i]=i\\n        for i in range(len(op)):\\n            if op[i][0] not in temp:\\n                temp[op[i][0]]=temp[op[i][1]]  ##if that replaced key is not there first add to the temp dict for  later use for it\\'s index\\n            nums[temp[op[i][0]]]=op[i][1]     ##Updating nums val by getting index from temp dictionary\\n            temp[op[i][1]]=temp[op[i][0]]   ##After updating that new replaced value index is updated with index of previous one\\n        return nums",
                "solutionTags": [],
                "code": "\\nSimple Linear Traversal using Dictionary  Python Solution\\n\\n    def arrayChange(self, nums: List[int], op: List[List[int]]) -> List[int]:\\n        temp={}\\n        for i in range(len(nums)):\\n            temp[nums[i]]=i        #Creating dictionary with indices as value to num[i]=i\\n        for i in range(len(op)):\\n            if op[i][0] not in temp:\\n                temp[op[i][0]]=temp[op[i][1]]  ##if that replaced key is not there first add to the temp dict for  later use for it\\'s index\\n            nums[temp[op[i][0]]]=op[i][1]     ##Updating nums val by getting index from temp dictionary\\n            temp[op[i][1]]=temp[op[i][0]]   ##After updating that new replaced value index is updated with index of previous one\\n        return nums",
                "codeTag": "Python3"
            },
            {
                "id": 2116089,
                "title": "python-hashmap",
                "content": "Algorithm: Track Indecies\\n1.  Build map -> {num: idx}\\n2.  Update map with replaced value\\n3.  Update input array (nums)\\n\\nSpace: O(n) | Time: O(n)\\n\\nCorrections and suggestions are welcomed.\\n\\n```\\nclass Solution:\\n   \\n   def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        numsMap = {} # {num: idx}\\n        for i in range(len(nums)):\\n            numsMap[nums[i]] = i\\n        \\n        for target, newValue in operations:\\n            idx = numsMap[target]\\n            nums[idx] = newValue\\n            numsMap[newValue] = idx\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n   \\n   def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        numsMap = {} # {num: idx}\\n        for i in range(len(nums)):\\n            numsMap[nums[i]] = i\\n        \\n        for target, newValue in operations:\\n            idx = numsMap[target]\\n            nums[idx] = newValue\\n            numsMap[newValue] = idx\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116015,
                "title": "c-super-smooth-solution-using-hashmap",
                "content": "**Please do upvote if you like the solution:)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> mpp;    //store index of nums array elements \\n        \\n        //hash nums\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = i;\\n        \\n        //start operations\\n        for(auto it: operations){\\n            int a = it[0];\\n            int b = it[1];\\n            \\n            //we have to change a->b\\n            nums[mpp[a]] = b;   //go to index of a in nums and store b there\\n            mpp[b] = mpp[a];    //index of this element will be same as previously stored element\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> mpp;    //store index of nums array elements \\n        \\n        //hash nums\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = i;\\n        \\n        //start operations\\n        for(auto it: operations){\\n            int a = it[0];\\n            int b = it[1];\\n            \\n            //we have to change a->b\\n            nums[mpp[a]] = b;   //go to index of a in nums and store b there\\n            mpp[b] = mpp[a];    //index of this element will be same as previously stored element\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114800,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map=new HashMap();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],i);\\n        }\\n        for(int[] arr:operations)\\n        {\\n            int index1=map.get(arr[0]);\\n            map.put(arr[1],index1);\\n            nums[index1]=arr[1];\\n        }\\n        return nums;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map=new HashMap();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],i);\\n        }\\n        for(int[] arr:operations)\\n        {\\n            int index1=map.get(arr[0]);\\n            map.put(arr[1],index1);\\n            nums[index1]=arr[1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114219,
                "title": "java-solution-using-map",
                "content": "Note that the key challenge is to find the value and avoid modifying the value we newly replaced. e.g nums=[1,2], operations = [[1,2],[2,3]], after first replace, we have nums = [2,2], subsequent operation [2,3] shoud result in nums=[2,3] instead of [3,2].\\n\\nThe immediate idea is a brute-force solution to\\n\\nUse an array with the same size of nums to mark the visited position\\nFor each operation, replace the value and mark visited position\\nTime Complexiy is O(n^2). It would exceed time limit and seem too easy for an medium question.\\n\\nHow can we do better?\\n\\nTo remove the extra loop of finding the index-to-value each time, we need an O(1) solution. With this in mind, HashMap is the ideal candidate. We first construct a value-to-position map. For each iteration, we get the index from the map, replace the value and update the map\\n\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i = 0; i < operations.length;i++){\\n            int oldVal = operations[i][0];\\n            int newVal = operations[i][1];\\n            int idx = map.get(oldVal);\\n            nums[idx] = newVal;\\n            map.remove(oldVal);\\n            map.put(newVal,idx);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i = 0; i < operations.length;i++){\\n            int oldVal = operations[i][0];\\n            int newVal = operations[i][1];\\n            int idx = map.get(oldVal);\\n            nums[idx] = newVal;\\n            map.remove(oldVal);\\n            map.put(newVal,idx);\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114140,
                "title": "short-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& arr, vector<vector<int>>& brr) {\\n        map<int,int>mp;\\n        int m=brr.size();\\n        for(int i=m-1;i>=0;i--){\\n            if(mp.find(brr[i][1])!=mp.end()){\\n                mp[brr[i][0]]=mp[brr[i][1]];\\n            }\\n            else{\\n                mp[brr[i][0]]=brr[i][1]; \\n            }\\n           \\n        }\\n        for(int i=0;i<arr.size();i++){\\n            if(mp[arr[i]]){\\n                arr[i]=mp[arr[i]];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& arr, vector<vector<int>>& brr) {\\n        map<int,int>mp;\\n        int m=brr.size();\\n        for(int i=m-1;i>=0;i--){\\n            if(mp.find(brr[i][1])!=mp.end()){\\n                mp[brr[i][0]]=mp[brr[i][1]];\\n            }\\n            else{\\n                mp[brr[i][0]]=brr[i][1]; \\n            }\\n           \\n        }\\n        for(int i=0;i<arr.size();i++){\\n            if(mp[arr[i]]){\\n                arr[i]=mp[arr[i]];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113837,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& ops) {\\n        map<int,int> mpp;\\n        for(int i=0;i<nums.size();i++){\\n            mpp[nums[i]]=i;\\n        }\\n        int s = ops.size();\\n        for(int i=0;i<s;i++){\\n            int pos = mpp[ops[i][0]];\\n            nums[pos] = ops[i][1];\\n            mpp.erase(ops[i][0]);\\n            mpp[ops[i][1]]=pos;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& ops) {\\n        map<int,int> mpp;\\n        for(int i=0;i<nums.size();i++){\\n            mpp[nums[i]]=i;\\n        }\\n        int s = ops.size();\\n        for(int i=0;i<s;i++){\\n            int pos = mpp[ops[i][0]];\\n            nums[pos] = ops[i][1];\\n            mpp.erase(ops[i][0]);\\n            mpp[ops[i][1]]=pos;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113740,
                "title": "video-solution-with-harder-version",
                "content": "[Video Link](https://www.youtube.com/watch?v=eMW3FlXDzmg)",
                "solutionTags": [],
                "code": "[Video Link](https://www.youtube.com/watch?v=eMW3FlXDzmg)",
                "codeTag": "Unknown"
            },
            {
                "id": 2113526,
                "title": "easiest-qn-of-the-contest",
                "content": "Just keep the store the indexes in a vector and keep swapping!!!!\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        vector<int> v(1000001);\\n        int n = nums.size();\\n        for(int i = 0;i<n;i++)v[nums[i]] = i;\\n        \\n        int m= operations.size();\\n        for(int i = 0;i<m;i++){\\n            int x = v[operations[i][0]];\\n            nums[x] = operations[i][1];\\n            v[operations[i][1]] = v[operations[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        vector<int> v(1000001);\\n        int n = nums.size();\\n        for(int i = 0;i<n;i++)v[nums[i]] = i;\\n        \\n        int m= operations.size();\\n        for(int i = 0;i<m;i++){\\n            int x = v[operations[i][0]];\\n            nums[x] = operations[i][1];\\n            v[operations[i][1]] = v[operations[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112968,
                "title": "simple-java-solution-map",
                "content": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++) {\\n            map.put(nums[i],i);\\n        }\\n        for(int[] op:operations) {\\n            nums[map.get(op[0])]=op[1];\\n            map.put(op[1],map.get(op[0]));\\n        }\\n        return nums;\\n                    \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++) {\\n            map.put(nums[i],i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2112953,
                "title": "python-easy-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n            \\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        \\n        dictionary = {}\\n        \\n\\t\\t# Initialize a dictionary with keys as nums[index] and values as index\\n        for i in range(len(nums)):\\n            dictionary[nums[i]] = i\\n            \\n\\t\\t#  Find the index of to-be-replaced , replace the element in nums and update its key in dictionary\\n        for i in operations:\\n            nums[dictionary[i[0]]] = i[1]\\n            dictionary[i[1]] = dictionary.pop(i[0])\\n       \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n            \\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        \\n        dictionary = {}\\n        \\n\\t\\t# Initialize a dictionary with keys as nums[index] and values as index\\n        for i in range(len(nums)):\\n            dictionary[nums[i]] = i\\n            \\n\\t\\t#  Find the index of to-be-replaced , replace the element in nums and update its key in dictionary\\n        for i in operations:\\n            nums[dictionary[i[0]]] = i[1]\\n            dictionary[i[1]] = dictionary.pop(i[0])\\n       \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112947,
                "title": "python-solution-with-dictionary",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        hash = defaultdict(int)\\n        for i in range(n):\\n            hash[nums[i]] = i\\n            \\n        op_len = len(operations)\\n        for i in range(op_len):\\n            hash[operations[i][1]] = hash[operations[i][0]]\\n            del hash[operations[i][0]]\\n        \\n        return [k for k,v in sorted(hash.items(), key = lambda x : x[1])]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        hash = defaultdict(int)\\n        for i in range(n):\\n            hash[nums[i]] = i\\n            \\n        op_len = len(operations)\\n        for i in range(op_len):\\n            hash[operations[i][1]] = hash[operations[i][0]]\\n            del hash[operations[i][0]]\\n        \\n        return [k for k,v in sorted(hash.items(), key = lambda x : x[1])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112766,
                "title": "c-short-linear-solution-100-fast",
                "content": "We are using array of size 10^6 (maximum range of a[i] as per contraints). \\n*  First of all we are storing the position of each element ( they are unique )\\n*  After each operation we find position of first element in operation using array m and change element in a on that position with second element of operation\\n*  store the position of new element in m \\n```\\n    vector<int> arrayChange(vector<int> a, vector<vector<int>>& op) {\\n        int n = a.size();\\n        \\n        int m[1000007];\\n        for(int i = 0; i < n; i++){\\n            m[a[i]] = i;\\n        }\\n        for(auto i: op){\\n            int x = i[0], y = i[1];\\n            int pos = m[x];\\n            a[pos] = y;\\n            m[y] = pos;\\n        }\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\n    vector<int> arrayChange(vector<int> a, vector<vector<int>>& op) {\\n        int n = a.size();\\n        \\n        int m[1000007];\\n        for(int i = 0; i < n; i++){\\n            m[a[i]] = i;\\n        }\\n        for(auto i: op){\\n            int x = i[0], y = i[1];\\n            int pos = m[x];\\n            a[pos] = y;\\n            m[y] = pos;\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112698,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Unordered Map***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[nums[i]] = i;\\n        }\\n        \\n        int m = operations.size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int old = operations[i][0];\\n            \\n            int new1 = operations[i][1];\\n            \\n            int idx = mp[old];\\n            \\n            nums[idx] = new1;\\n            \\n            mp[new1] = idx;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[nums[i]] = i;\\n        }\\n        \\n        int m = operations.size();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int old = operations[i][0];\\n            \\n            int new1 = operations[i][1];\\n            \\n            int idx = mp[old];\\n            \\n            nums[idx] = new1;\\n            \\n            mp[new1] = idx;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112694,
                "title": "easy-solution-java",
                "content": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        for ( int i = 0; i < nums.length; ++i ) {\\n            mp.put(nums[i], i);\\n        }\\n        \\n        for ( int i = 0; i < operations.length; ++i ) {\\n            nums[mp.get(operations[i][0])] = operations[i][1];\\n            mp.put(operations[i][1], mp.get(operations[i][0]));\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        for ( int i = 0; i < nums.length; ++i ) {\\n            mp.put(nums[i], i);\\n        }\\n        \\n        for ( int i = 0; i < operations.length; ++i ) {\\n            nums[mp.get(operations[i][0])] = operations[i][1];\\n            mp.put(operations[i][1], mp.get(operations[i][0]));\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112633,
                "title": "easy-to-understand-c-hashmap",
                "content": "```\\n        map < int , int > m;\\n        int n = nums.size();\\n        vector < int > ans(n);\\n        for ( int i = 0 ; i < n ; i++ ) {\\n            m[nums[i]] = i;\\n        }\\n        for ( int i = 0 ; i < n ; i++ ) ans[i] = nums[i];\\n        for ( int i = 0 ; i < operations.size() ; i++ ) {\\n            int idx = m[operations[i][0]];\\n            ans[m[operations[i][0]]] = operations[i][1];\\n            m[operations[i][1]] = idx;\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        map < int , int > m;\\n        int n = nums.size();\\n        vector < int > ans(n);\\n        for ( int i = 0 ; i < n ; i++ ) {\\n            m[nums[i]] = i;\\n        }\\n        for ( int i = 0 ; i < n ; i++ ) ans[i] = nums[i];\\n        for ( int i = 0 ; i < operations.size() ; i++ ) {\\n            int idx = m[operations[i][0]];\\n            ans[m[operations[i][0]]] = operations[i][1];\\n            m[operations[i][1]] = idx;\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112537,
                "title": "python-easy-understanding",
                "content": "Here we can also do this by using Brute Force approach but the problem with that is that we will have to find the index of our value again and again and thats gonna take a lot of our time .\\n\\nSo since we know every value in ur nums array is unique so we can just create a dictionary to store the particular values index once and then at the end just sort the dictionary and return the corresponding key values in a new updated list . \\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            d[nums[i]]=i\\n        #print(d)\\n            \\n        for i in operations:\\n            #print(i[1],i[0])\\n            d[i[1]]=d[i[0]]\\n            del d[i[0]]\\n            \\n        #print(d)\\n        d1 = sorted([(value, key) for (key, value) in d.items()])\\n        #print(d1)\\n        l=[]\\n        for i in range(len(d1)):\\n            l.append(d1[i][1])\\n        \\n        return l\\n```\\nIf u understood the code then plz..........UPVOTE.............Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            d[nums[i]]=i\\n        #print(d)\\n            \\n        for i in operations:\\n            #print(i[1],i[0])\\n            d[i[1]]=d[i[0]]\\n            del d[i[0]]\\n            \\n        #print(d)\\n        d1 = sorted([(value, key) for (key, value) in d.items()])\\n        #print(d1)\\n        l=[]\\n        for i in range(len(d1)):\\n            l.append(d1[i][1])\\n        \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112379,
                "title": "c-easy-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& a, vector<vector<int>>& operations) {\\n        int m = (operations).size();\\n        unordered_map <int, int> idx;\\n        for (int i = 0; i < a.size(); ++i) {\\n          idx[a[i]] = i;\\n        }\\n        for (int i = 0; i < m; ++i) {\\n          int x = operations[i][0];\\n          int y = operations[i][1];\\n          a[idx[x]] = y;\\n          idx[y] = idx[x];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& a, vector<vector<int>>& operations) {\\n        int m = (operations).size();\\n        unordered_map <int, int> idx;\\n        for (int i = 0; i < a.size(); ++i) {\\n          idx[a[i]] = i;\\n        }\\n        for (int i = 0; i < m; ++i) {\\n          int x = operations[i][0];\\n          int y = operations[i][1];\\n          a[idx[x]] = y;\\n          idx[y] = idx[x];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112343,
                "title": "c-using-map-stl-short-and-easy",
                "content": "**Please upvote if you find helpful!**\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int>mp;\\n        int n=nums.size(), m=operations.size();\\n        for(int i=0; i<n; i++)\\n            mp[nums[i]] = i;\\n        for(int i=0; i<m; i++)\\n        {\\n            int x = mp[operations[i][0]];\\n            nums[x] = operations[i][1];\\n            mp.erase(operations[i][0]);\\n            mp[operations[i][1]] = x;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int>mp;\\n        int n=nums.size(), m=operations.size();\\n        for(int i=0; i<n; i++)\\n            mp[nums[i]] = i;\\n        for(int i=0; i<m; i++)\\n        {\\n            int x = mp[operations[i][0]];\\n            nums[x] = operations[i][1];\\n            mp.erase(operations[i][0]);\\n            mp[operations[i][1]] = x;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112316,
                "title": "rust-simple-hashmap-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn array_change(mut nums: Vec<i32>, operations: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut map = HashMap::new();\\n        \\n        for i in 0..nums.len(){\\n            map.insert(nums[i], i);\\n        }\\n        \\n        for v in operations{\\n            let old = v[0];\\n            let new = v[1];\\n            \\n            let i = map.remove(&old).unwrap();\\n            map.insert(new, i);\\n            nums[i] = new;\\n        }\\n        \\n        nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn array_change(mut nums: Vec<i32>, operations: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut map = HashMap::new();\\n        \\n        for i in 0..nums.len(){\\n            map.insert(nums[i], i);\\n        }\\n        \\n        for v in operations{\\n            let old = v[0];\\n            let new = v[1];\\n            \\n            let i = map.remove(&old).unwrap();\\n            map.insert(new, i);\\n            nums[i] = new;\\n        }\\n        \\n        nums\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112288,
                "title": "two-solutions-lengthy-concise-with-comments-c",
                "content": "***1st Approach-***\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, pair<int, int>> mp; //   val -> {idx, val}\\n        int i = 0;\\n        for(int num : nums){\\n            mp[num] = {i++, num};\\n        }\\n        for(auto &p : operations){  //apply operations one by one and erase, store new value/candidate\\n            int idx =  mp[p[0]].first;\\n            int val =  mp[p[0]].second;\\n            mp.erase(mp.find(p[0]));\\n            mp[p[1]] = {idx, p[1]};\\n        }\\n        for(auto &m : mp){   //restore nums array\\n            int idx =  m.second.first;\\n            int val =  m.second.second;\\n            nums[idx] = val;\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n***2nd Approach-***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> mp; //val -> idx\\n        int idx = 0;\\n        for(int num : nums){\\n            mp[num] = idx++;\\n        }\\n        for(vector<int> &op : operations){\\n            nums[mp[op[0]]] = op[1]; //nums[idx] = new_val;\\n            mp[op[1]] = mp[op[0]]; //mp[new_val] = idx;\\n            mp.erase(op[0]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, pair<int, int>> mp; //   val -> {idx, val}\\n        int i = 0;\\n        for(int num : nums){\\n            mp[num] = {i++, num};\\n        }\\n        for(auto &p : operations){  //apply operations one by one and erase, store new value/candidate\\n            int idx =  mp[p[0]].first;\\n            int val =  mp[p[0]].second;\\n            mp.erase(mp.find(p[0]));\\n            mp[p[1]] = {idx, p[1]};\\n        }\\n        for(auto &m : mp){   //restore nums array\\n            int idx =  m.second.first;\\n            int val =  m.second.second;\\n            nums[idx] = val;\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> mp; //val -> idx\\n        int idx = 0;\\n        for(int num : nums){\\n            mp[num] = idx++;\\n        }\\n        for(vector<int> &op : operations){\\n            nums[mp[op[0]]] = op[1]; //nums[idx] = new_val;\\n            mp[op[1]] = mp[op[0]]; //mp[new_val] = idx;\\n            mp.erase(op[0]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112284,
                "title": "easy-problem-done-by-unordered-map",
                "content": "This problem should be consider easy .\\nIt is already given in the question that the elements are distinct so just store the index of every distinct element in the unordered map then in every iteration in operations vector find the index of operations[i][0] present in the nums vector from map and change its value to operations[i][1] at that index.\\nAnd after this store this value too in the map so that in future if we get this element then we have its index in the map. And also remove the previously stored element in the array from the map so that there will be no conflict.\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        unordered_map<int,int> map;\\n        for(int i = 0; i < nums.size(); i++)\\n            map[nums[i]] = i;\\n        \\n        for(int i = 0; i < operations.size(); i++)\\n        {\\n            int u = operations[i][0];\\n            int v = operations[i][1];\\n            int index = map[u];\\n            map.erase(u);\\n            nums[index] = v;\\n            map[v] = index;\\n        }\\n        return nums;\\n    }\\n};\\n```\\nLinear Time Complexity",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        unordered_map<int,int> map;\\n        for(int i = 0; i < nums.size(); i++)\\n            map[nums[i]] = i;\\n        \\n        for(int i = 0; i < operations.size(); i++)\\n        {\\n            int u = operations[i][0];\\n            int v = operations[i][1];\\n            int index = map[u];\\n            map.erase(u);\\n            nums[index] = v;\\n            map[v] = index;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112263,
                "title": "c-dictionaray-to-store-unique-number-and-their-indexes-in-array",
                "content": "Idea here is to avoid searching the number to replace in linear time.\\nFor that we can have a Dictionary to store key as unique number and value as their corresponding indexes in the array.\\n\\nfirst we will store all the numbers and their indexes.\\nthen from operations one by one, first we will remove the number we have to replace, and will be pick that number to replace. Also store the index of that number to replace in start itself.\\n\\n```\\n public int[] ArrayChange(int[] nums, int[][] operations) {\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++){\\n            map.Add(nums[i], i);\\n        }\\n        \\n        for(int i = 0; i < operations.Length; i++){\\n            int index = map[operations[i][0]];\\n            map.Remove(operations[i][0]);\\n            nums[index] = operations[i][1];\\n            map.Add(operations[i][1], index);\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n public int[] ArrayChange(int[] nums, int[][] operations) {\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length; i++){\\n            map.Add(nums[i], i);\\n        }\\n        \\n        for(int i = 0; i < operations.Length; i++){\\n            int index = map[operations[i][0]];\\n            map.Remove(operations[i][0]);\\n            nums[index] = operations[i][1];\\n            map.Add(operations[i][1], index);\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112252,
                "title": "c-hash-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int>index;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)index[nums[i]]=i;\\n        for(int i=0;i<op.size();i++){\\n            int ind = index[op[i][0]];\\n            index.erase(op[i][0]);\\n            nums[ind] = op[i][1];\\n            index[op[i][1]]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int>index;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)index[nums[i]]=i;\\n        for(int i=0;i<op.size();i++){\\n            int ind = index[op[i][0]];\\n            index.erase(op[i][0]);\\n            nums[ind] = op[i][1];\\n            index[op[i][1]]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112245,
                "title": "really-easy-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int> mpp;\\n        int i = 0;\\n        for(auto &x:nums)\\n        {\\n            mpp[x] = i++;\\n        }\\n        \\n        for(auto &x:op)\\n        {\\n            nums[mpp[x[0]]] = x[1];\\n            mpp[x[1]] = mpp[x[0]]; \\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int> mpp;\\n        int i = 0;\\n        for(auto &x:nums)\\n        {\\n            mpp[x] = i++;\\n        }\\n        \\n        for(auto &x:op)\\n        {\\n            nums[mpp[x[0]]] = x[1];\\n            mpp[x[1]] = mpp[x[0]]; \\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112195,
                "title": "python-o-n-m-solution",
                "content": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        pos = {}\\n        for i in range(len(nums)):\\n            pos[nums[i]] = i\\n            \\n        for i,j in operations:\\n            index = pos[i]\\n            nums[index] = j\\n            pos[j] = index\\n            pos.pop(i)\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        pos = {}\\n        for i in range(len(nums)):\\n            pos[nums[i]] = i\\n            \\n        for i,j in operations:\\n            index = pos[i]\\n            nums[index] = j\\n            pos[j] = index\\n            pos.pop(i)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112120,
                "title": "c-easy-map-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = operations.size();\\n        map<int,int> m;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            m[nums[i]] = i;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            auto it = m.find(operations[i][0]);\\n            auto t = it->second;\\n            m.erase(it);\\n            m[operations[i][1]] = t;\\n        }\\n        \\n        for(auto it : m){\\n            nums[it.second] = it.first;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = operations.size();\\n        map<int,int> m;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            m[nums[i]] = i;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            auto it = m.find(operations[i][0]);\\n            auto t = it->second;\\n            m.erase(it);\\n            m[operations[i][1]] = t;\\n        }\\n        \\n        for(auto it : m){\\n            nums[it.second] = it.first;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112062,
                "title": "c-stl-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int, int> mp; // value | index\\n        for(int i = 0; i < nums.size(); i++) {\\n            mp[nums[i]] = i;\\n        }\\n        for(auto it: operations) {\\n            int value = it[0];\\n            int changeTo = it[1];\\n            auto node = mp.extract(value);\\n            node.key() = changeTo;\\n            mp.insert(move(node));\\n        }\\n        for(auto it: mp) {\\n            nums[it.second] = it.first;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int, int> mp; // value | index\\n        for(int i = 0; i < nums.size(); i++) {\\n            mp[nums[i]] = i;\\n        }\\n        for(auto it: operations) {\\n            int value = it[0];\\n            int changeTo = it[1];\\n            auto node = mp.extract(value);\\n            node.key() = changeTo;\\n            mp.insert(move(node));\\n        }\\n        for(auto it: mp) {\\n            nums[it.second] = it.first;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112047,
                "title": "c-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int n=nums.size();\\n         vector<int>ans=nums;\\n        map<int,int>mp;\\n        int j=0;\\n        for(auto x:nums)\\n            mp[x]=j++;\\n        for(auto x:op)\\n        {\\n            int idx=mp[x[0]];\\n            mp.erase(x[0]);\\n            mp[x[1]]=idx;\\n            ans[idx]=x[1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        int n=nums.size();\\n         vector<int>ans=nums;\\n        map<int,int>mp;\\n        int j=0;\\n        for(auto x:nums)\\n            mp[x]=j++;\\n        for(auto x:op)\\n        {\\n            int idx=mp[x[0]];\\n            mp.erase(x[0]);\\n            mp[x[1]]=idx;\\n            ans[idx]=x[1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111990,
                "title": "hashmap-for-index-c",
                "content": "\\nOkay, so this question is simple but a little bit different from ideal hashmap questions.\\nHere we have to make an hashmap which will store the key value pair as = {element,index}.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = nums.size();\\n        unordered_map<int,int> hm;\\n\\t\\t//Mapping the element with its index\\n        for(int i=0;i<n;i++){\\n                hm[nums[i]] = i;\\n        }\\n        \\n        int toreplace,replacer;\\n        for(auto it:operations){\\n\\t\\t\\n\\t\\t//While Replacing, we just store the previous elements index at the current one and delete the previous element\\n            toreplace = it[0];\\n            replacer = it[1];\\n            hm[replacer] = hm[toreplace];\\n            hm.erase(toreplace);\\n        }\\n        vector<int> ans(n,0);\\n\\t\\t\\n\\t\\t//Iterate through our hashmap and store element at the required index\\n        for(auto it:hm){\\n            int index = it.second;\\n            ans[index] = it.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        int n = nums.size();\\n        unordered_map<int,int> hm;\\n\\t\\t//Mapping the element with its index\\n        for(int i=0;i<n;i++){\\n                hm[nums[i]] = i;\\n        }\\n        \\n        int toreplace,replacer;\\n        for(auto it:operations){\\n\\t\\t\\n\\t\\t//While Replacing, we just store the previous elements index at the current one and delete the previous element\\n            toreplace = it[0];\\n            replacer = it[1];\\n            hm[replacer] = hm[toreplace];\\n            hm.erase(toreplace);\\n        }\\n        vector<int> ans(n,0);\\n\\t\\t\\n\\t\\t//Iterate through our hashmap and store element at the required index\\n        for(auto it:hm){\\n            int index = it.second;\\n            ans[index] = it.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111958,
                "title": "java-easy-to-understand-using-hashmap",
                "content": "In first iteration  map the value with their index\\nAnd in another iteration we will manipulate the array using map\\n\\n\\n```\\npublic int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map =new HashMap<>();\\n        for(int i =0;i<nums.length;i++){\\n            map.put(nums[i],i); // map the value with ther index\\n            \\n        }\\n        for(int[] arr : operations){\\n            nums[map.get(arr[0])] = arr[1];\\n            \\n            map.put(arr[1],map.get(arr[0])); // add the new value in the map \\n            map.remove(arr[0]); // remove the value that has been replaced\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> map =new HashMap<>();\\n        for(int i =0;i<nums.length;i++){\\n            map.put(nums[i],i); // map the value with ther index\\n            \\n        }\\n        for(int[] arr : operations){\\n            nums[map.get(arr[0])] = arr[1];\\n            \\n            map.put(arr[1],map.get(arr[0])); // add the new value in the map \\n            map.remove(arr[0]); // remove the value that has been replaced\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111914,
                "title": "java-easy-implementation",
                "content": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer , Integer> m = new HashMap <> (); \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            m.put(nums[i],i);\\n        }\\n        \\n        for(int []a: operations)\\n        {\\n            if(m.containsKey(a[0]))\\n            {\\n                nums[m.get(a[0])]= a[1];\\n                m.put(a[1],m.get(a[0]));\\n                m.remove(a[0]);\\n            }\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer , Integer> m = new HashMap <> (); \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            m.put(nums[i],i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111901,
                "title": "java-map-number-to-index",
                "content": "**The number will keep unique after each operation.**\\n\\nSo we **can map number to index**, and update key with each operation.\\n\\nTime: O(N+M)\\nSpace: O(N+M)\\n\\n```\\nclass Solution {\\n  public int[] arrayChange(int[] nums, int[][] operations) {\\n    final int n = nums.length;\\n    // number ==> index\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n      map.put(nums[i], i);\\n    }\\n\\n    for (int[] op : operations) {\\n      // remove old key pair and update with new key pair\\n      map.put(op[1], map.remove(op[0]));\\n    }\\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n      nums[entry.getValue()] = entry.getKey();\\n    }\\n\\n    return nums;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[] arrayChange(int[] nums, int[][] operations) {\\n    final int n = nums.length;\\n    // number ==> index\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n      map.put(nums[i], i);\\n    }\\n\\n    for (int[] op : operations) {\\n      // remove old key pair and update with new key pair\\n      map.put(op[1], map.remove(op[0]));\\n    }\\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n      nums[entry.getValue()] = entry.getKey();\\n    }\\n\\n    return nums;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111881,
                "title": "c-linear-time-two-hashmaps-faster-than-100-with-explanation",
                "content": "So we can solve this problem by using two hashmaps.\\nOne hashmap acts like the original hashmap.\\nThe other hashmap acts like a middleware hashmap.\\nIf the value exists in the middleware hashmap we know that we are chaining the values and this current key is not important. We can remove/erase operations[i][0] from the middleware and insert the operations[i][1] as the middleware key and in the future look for a possible new operation. However, if the key is not in the middleware hashmap, it means that is an original number and we should insert it to original hashmap to replace the value of it with the final outcome.\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& ops) {\\n\\t\\t// create two hashmaps\\n        unordered_map<int,int> mpOrg;\\n        unordered_map<int,int> mpMid;\\n\\t\\t// iterate to update the hashmap values\\n        for (int i = 0;i<ops.size();i++){\\n\\t\\t\\t// if the value exists in the hashmap, it means the value is not important and \\n\\t\\t\\t// is just part of a chain of operations, so update the values accordingly\\n            if (mpMid.find(ops[i][0])!=mpMid.end()){\\n                mpMid[ops[i][1]] = mpMid[ops[i][0]];\\n                mpMid.erase(ops[i][0]);\\n                mpOrg[mpMid[ops[i][1]]] = ops[i][1];\\n                continue;\\n            }\\n\\t\\t\\t// otherwise, we know that the ops[i][0] is just an original value and \\n\\t\\t\\t// is going to be replaced eventually with a chain of operations\\n\\t\\t\\tmpOrg[ops[i][0]] = ops[i][1];\\n\\t\\t\\tmpMid[ops[i][1]] = ops[i][0];\\n        }\\n\\t\\t// finally replace the values using the original hashmap\\n        for (int i = 0;i<nums.size();i++){\\n            if (mpOrg.find(nums[i])!=mpOrg.end()){\\n                nums[i] = mpOrg[nums[i]];\\n            }\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& ops) {\\n\\t\\t// create two hashmaps\\n        unordered_map<int,int> mpOrg;\\n        unordered_map<int,int> mpMid;\\n\\t\\t// iterate to update the hashmap values\\n        for (int i = 0;i<ops.size();i++){\\n\\t\\t\\t// if the value exists in the hashmap, it means the value is not important and \\n\\t\\t\\t// is just part of a chain of operations, so update the values accordingly\\n            if (mpMid.find(ops[i][0])!=mpMid.end()){\\n                mpMid[ops[i][1]] = mpMid[ops[i][0]];\\n                mpMid.erase(ops[i][0]);\\n                mpOrg[mpMid[ops[i][1]]] = ops[i][1];\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2111875,
                "title": "java-simple-and-straightforward",
                "content": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            hm.put(nums[i], i);\\n        }\\n        \\n        for(int[] o: operations){\\n            int idx = hm.get(o[0]);\\n            nums[idx] = o[1];\\n            hm.put(nums[idx], idx);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0; i<nums.length; i++){\\n            hm.put(nums[i], i);\\n        }\\n        \\n        for(int[] o: operations){\\n            int idx = hm.get(o[0]);\\n            nums[idx] = o[1];\\n            hm.put(nums[idx], idx);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095213,
                "title": "python3-solution-with-using-hashmap",
                "content": "# Code\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        d = {}\\n\\n        for idx, num in enumerate(nums):\\n            d[num] = idx\\n        \\n        for src, dst in operations:\\n            idx = d[src]\\n            nums[idx] = dst\\n            d[dst] = idx\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        d = {}\\n\\n        for idx, num in enumerate(nums):\\n            d[num] = idx\\n        \\n        for src, dst in operations:\\n            idx = d[src]\\n            nums[idx] = dst\\n            d[dst] = idx\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090783,
                "title": "c-time-o-m-n-space-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Have a dictionary to store the num to index in nums\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m + n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m + n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ArrayChange(int[] nums, int[][] operations) \\n    {   \\n        Dictionary<int, int> map = new (); // num -> index in nums\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            map[nums[i]] = i;\\n        }\\n\\n        foreach(int[] p in operations)\\n        {\\n            nums[map[p[0]]] = p[1];\\n            map[p[1]] = map[p[0]];\\n            // no need to remove map[p[0]] actually, so we can save some time\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ArrayChange(int[] nums, int[][] operations) \\n    {   \\n        Dictionary<int, int> map = new (); // num -> index in nums\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            map[nums[i]] = i;\\n        }\\n\\n        foreach(int[] p in operations)\\n        {\\n            nums[map[p[0]]] = p[1];\\n            map[p[1]] = map[p[0]];\\n            // no need to remove map[p[0]] actually, so we can save some time\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081086,
                "title": "javascript-for-of-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function (nums, operations) {\\n    for (let name in operations) {\\n        nums[nums.indexOf(operations[name][0])] = operations[name][1]\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function (nums, operations) {\\n    for (let name in operations) {\\n        nums[nums.indexOf(operations[name][0])] = operations[name][1]\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073718,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n        \\n       int find(vector<int>& nums, int i){\\n               for(int j=0; j<nums.size(); j++){\\n                       if(i==nums[j]){\\n                               return j;\\n                       }\\n               }\\n               return 0;\\n       } \\n        \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& oper) {\\n        \\n            for(int i=0; i<oper.size();i++){\\n                    int num = oper[i][0];\\n                    nums[find(nums,num)]=oper[i][1];\\n            }\\n            return nums;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n       int find(vector<int>& nums, int i){\\n               for(int j=0; j<nums.size(); j++){\\n                       if(i==nums[j]){\\n                               return j;\\n                       }\\n               }\\n               return 0;\\n       } \\n        \\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& oper) {\\n        \\n            for(int i=0; i<oper.size();i++){\\n                    int num = oper[i][0];\\n                    nums[find(nums,num)]=oper[i][1];\\n            }\\n            return nums;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062492,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n       map<int,int>mp;\\n       for (int i=0;i<nums.size();i++)\\n       {\\n           mp[nums[i]]=i;\\n       }    \\n       for (int i=0;i<operations.size();i++)\\n       {\\n           int ind=mp[operations[i][0]];\\n           nums[ind]=operations[i][1];\\n           mp[operations[i][1]]=ind;\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n       map<int,int>mp;\\n       for (int i=0;i<nums.size();i++)\\n       {\\n           mp[nums[i]]=i;\\n       }    \\n       for (int i=0;i<operations.size();i++)\\n       {\\n           int ind=mp[operations[i][0]];\\n           nums[ind]=operations[i][1];\\n           mp[operations[i][1]]=ind;\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058281,
                "title": "c-simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<nums.size(); i++) mp[nums[i]] = i;\\n        for(auto i:operations) {\\n            auto first = i[0];\\n            auto second = i[1];\\n            // if(find(nums.begin(), nums.end(), first) != nums.end())\\n            //     replace(nums.begin(), nums.end(), first, second);\\n            nums[mp[first]] = second;\\n            mp[second] = mp[first];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<nums.size(); i++) mp[nums[i]] = i;\\n        for(auto i:operations) {\\n            auto first = i[0];\\n            auto second = i[1];\\n            // if(find(nums.begin(), nums.end(), first) != nums.end())\\n            //     replace(nums.begin(), nums.end(), first, second);\\n            nums[mp[first]] = second;\\n            mp[second] = mp[first];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038909,
                "title": "full-explanation-with-approach-and-comments-hashing-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWE HAVE TO TRAVERSE operation ARRAY , AND FOR EVERY INDEX OF operation WE HAVE TO FIND operation[i][0] IN nums ARRAY THEN REPLACE nums[i] WITH operation[i][1]\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n/*\\n\\nWE HAVE TO TRAVERSE operation ARRAY , AND FOR EVERY INDEX OF operation WE HAVE TO FIND operation[i][0] IN nums ARRAY THEN REPLACE nums[i] WITH operation[i][1]\\n*/\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        int n=nums.size();\\n        \\n        //MAP TO STORE INDEX OF EACH ELEMENT \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            \\n            mp[nums[i]]=i;\\n        }\\n\\n        for(auto it:operations){\\n            \\n            //Find operation[i][0] in the map\\n            auto itt=mp.find(it[0]);\\n            if(itt!=mp.end()) {\\n                \\n                //Replace nums[i] with operation[i][1]\\n                nums[itt->second]=it[1];\\n\\n                //Update number in the map\\n                mp[it[1]]=itt->second;\\n                \\n            };\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n/*\\n\\nWE HAVE TO TRAVERSE operation ARRAY , AND FOR EVERY INDEX OF operation WE HAVE TO FIND operation[i][0] IN nums ARRAY THEN REPLACE nums[i] WITH operation[i][1]\\n*/\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        int n=nums.size();\\n        \\n        //MAP TO STORE INDEX OF EACH ELEMENT \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            \\n            mp[nums[i]]=i;\\n        }\\n\\n        for(auto it:operations){\\n            \\n            //Find operation[i][0] in the map\\n            auto itt=mp.find(it[0]);\\n            if(itt!=mp.end()) {\\n                \\n                //Replace nums[i] with operation[i][1]\\n                nums[itt->second]=it[1];\\n\\n                //Update number in the map\\n                mp[it[1]]=itt->second;\\n                \\n            };\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007219,
                "title": "c-easy-map-approach-just-store-the-index-in-map-and-update-as-ask-as-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& oper) {\\n       unordered_map<int,int>mp;\\n\\n       //stroning the mapping correpsondint to digit\\n       for(int i=0;i<nums.size();i++)\\n             mp[nums[i]]=i;\\n\\n        for(auto &it:oper)\\n        {\\n          //just find the index according to value\\n           \\n            //update the value at that index in nums\\n            nums[mp[it[0]]]=it[1];\\n            //not also update the mapping in map\\n            mp[it[1]]=mp[it[0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& oper) {\\n       unordered_map<int,int>mp;\\n\\n       //stroning the mapping correpsondint to digit\\n       for(int i=0;i<nums.size();i++)\\n             mp[nums[i]]=i;\\n\\n        for(auto &it:oper)\\n        {\\n          //just find the index according to value\\n           \\n            //update the value at that index in nums\\n            nums[mp[it[0]]]=it[1];\\n            //not also update the mapping in map\\n            mp[it[1]]=mp[it[0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991089,
                "title": "using-hashmaps",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        for(int i = 0 ; i < nums.length ; i++)\\n        {\\n            map.put(nums[i] , i);\\n        }\\n        for(int[] i : operations)\\n        {\\n            int popval = i[0];\\n            int pushval = i[1];\\n            int pos = map.get(popval);\\n            map.remove(popval);\\n            map.put(pushval , pos);\\n            nums[pos] = pushval;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        for(int i = 0 ; i < nums.length ; i++)\\n        {\\n            map.put(nums[i] , i);\\n        }\\n        for(int[] i : operations)\\n        {\\n            int popval = i[0];\\n            int pushval = i[1];\\n            int pos = map.get(popval);\\n            map.remove(popval);\\n            map.put(pushval , pos);\\n            nums[pos] = pushval;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981615,
                "title": "python-map-solution-with-explanation",
                "content": "# Intuition\\nIf we were to look up the number in the array for each replacement, we would have a complexity of $$O(N) * O(M)$$, where $$M = |operations|$$ and $$N = |nums|$$.\\nBut we could instead make the search of these numbers $$O(1)$$ through a map (we look up the index by the number). Then, making the change for every replacement in order is easy, since we could follow this approach:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each replacement (old --> new):\\n- Find the index of $$old$$ in the map\\n- Add the tuple $$<new, indexOf[old]>$$ to the map\\n- Delete the key $$old$$ from the map\\n\\nThen, we can easily convert the map to an array.\\n[This is all assuming that the nums array has distinct values, and that the replacements preserve the uniqueness of these values]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe traverse the nums array once to generate the map --> $$O(N)$$\\nWe traverse the operations array to apply the operations --> $$O(M)$$ * O(1) [since each operation takes constant time to be recorded in a map]\\nWe then traverse the map to repopulate the array --> $$O(N)$$\\n\\n**Thus, time complexity is: $$O(max(N, M))$$** \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe only just need an additional map with at most N+1 keys (the +1 is because we could have a new number introduced in the replacements but it\\'s just a detail)\\n\\n**Thus, space complexity is: $$O(N)$$**\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        inverseArray = {}\\n\\n        for i in range(len(nums)):\\n            inverseArray[nums[i]] = i\\n\\n        for old, new in operations:\\n            inverseArray[new] = inverseArray[old]\\n            del inverseArray[old]\\n        \\n        for key in inverseArray.keys():\\n            nums[inverseArray[key]] = key\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        inverseArray = {}\\n\\n        for i in range(len(nums)):\\n            inverseArray[nums[i]] = i\\n\\n        for old, new in operations:\\n            inverseArray[new] = inverseArray[old]\\n            del inverseArray[old]\\n        \\n        for key in inverseArray.keys():\\n            nums[inverseArray[key]] = key\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968365,
                "title": "hashmap-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n\\n        // Step 1: Populate the HashMap with initial indices of values in the \\'nums\\' array.\\n        for (int i = 0; i < nums.length; i++) {\\n            hm.put(nums[i], i);\\n        }\\n\\n        // Step 2: Iterate through the \\'operations\\' array and perform replacements.\\n        for (int i = 0; i < operations.length; i++) {\\n            int oper1 = operations[i][0]; // Value to be replaced\\n            int oper2 = operations[i][1]; // Replacement value\\n\\n            // Find the index of \\'oper1\\' in the \\'nums\\' array using the HashMap.\\n            int indexToReplace = hm.get(oper1);\\n\\n            // Replace the value at \\'indexToReplace\\' with \\'oper2\\'.\\n            nums[indexToReplace] = oper2;\\n\\n            // Update the HashMap to reflect the new index of \\'oper2\\'.\\n            hm.put(oper2, indexToReplace);\\n        }\\n\\n        // Return the modified \\'nums\\' array after all operations.\\n        return nums;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n\\n        // Step 1: Populate the HashMap with initial indices of values in the \\'nums\\' array.\\n        for (int i = 0; i < nums.length; i++) {\\n            hm.put(nums[i], i);\\n        }\\n\\n        // Step 2: Iterate through the \\'operations\\' array and perform replacements.\\n        for (int i = 0; i < operations.length; i++) {\\n            int oper1 = operations[i][0]; // Value to be replaced\\n            int oper2 = operations[i][1]; // Replacement value\\n\\n            // Find the index of \\'oper1\\' in the \\'nums\\' array using the HashMap.\\n            int indexToReplace = hm.get(oper1);\\n\\n            // Replace the value at \\'indexToReplace\\' with \\'oper2\\'.\\n            nums[indexToReplace] = oper2;\\n\\n            // Update the HashMap to reflect the new index of \\'oper2\\'.\\n            hm.put(oper2, indexToReplace);\\n        }\\n\\n        // Return the modified \\'nums\\' array after all operations.\\n        return nums;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958377,
                "title": "6-lines-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]] = i;\\n        for(auto i:operations)\\n        {\\n            nums[mp[i[0]]]=i[1];\\n            mp[i[1]]=mp[i[0]];\\n        }\\n        return nums;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]] = i;\\n        for(auto i:operations)\\n        {\\n            nums[mp[i[0]]]=i[1];\\n            mp[i[1]]=mp[i[0]];\\n        }\\n        return nums;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951378,
                "title": "search-item-approach",
                "content": "# Intuition\\nthis is a very easy problem based on the constraints we know that the value and index always exist so we need only find the value we want to repalce with the new one is coming from.\\n\\n# Approach\\n- Search the value \\n- Return the index of the given value\\n- Replace the array[i] with the new value\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function (nums, operations) {\\n\\n    const search = (term) => {\\n        let start = 0\\n        let index = -1\\n        while (start < nums.length) {\\n            if (nums[start] === term) {\\n                index = start\\n                break\\n            }\\n            start++\\n        }\\n        return index\\n    }\\n    const replace = (value, newValue) => {\\n        const index = search(value)\\n        nums[index] = newValue\\n    }\\n\\n    for (const op of operations) {\\n        const [prevValue, value] = op\\n        replace(prevValue, value)\\n    }\\n\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function (nums, operations) {\\n\\n    const search = (term) => {\\n        let start = 0\\n        let index = -1\\n        while (start < nums.length) {\\n            if (nums[start] === term) {\\n                index = start\\n                break\\n            }\\n            start++\\n        }\\n        return index\\n    }\\n    const replace = (value, newValue) => {\\n        const index = search(value)\\n        nums[index] = newValue\\n    }\\n\\n    for (const op of operations) {\\n        const [prevValue, value] = op\\n        replace(prevValue, value)\\n    }\\n\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936504,
                "title": "by-prodonik-python",
                "content": "# Intuition\\nThere was some ways to get this problem done, you just try to understand )\\n# Approach\\nI just went by the logic came up to my mind first, it doen\\'t take that much memory but runs slow as well.\\n# Complexity\\n- Time complexity:\\nThis code really sux, and its logic also very simple!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], mine: List[List[int]]) -> List[int]:\\n        for i in range(len(mine)):\\n            nums[nums.index(mine[i][0])] = mine[i][1]\\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], mine: List[List[int]]) -> List[int]:\\n        for i in range(len(mine)):\\n            nums[nums.index(mine[i][0])] = mine[i][1]\\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924435,
                "title": "python-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        dict_help = {}\\n        \\n        # Create a dictionary to map values to their indices in the \\'nums\\' array\\n        for i in range(len(nums)):\\n            dict_help[nums[i]] = i\\n            \\n        for j in range(len(operations)):\\n            if operations[j][0] in dict_help:\\n                # Get the original value and index\\n                original_value = operations[j][0]\\n                original_index = dict_help[original_value]\\n                \\n                # Delete the original value from the dictionary\\n                del dict_help[original_value]\\n                \\n                # Update the value at the original index in the \\'nums\\' array\\n                nums[original_index] = operations[j][1]\\n                \\n                # Update the dictionary with the new value-index pair\\n                dict_help[operations[j][1]] = original_index\\n        \\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        dict_help = {}\\n        \\n        # Create a dictionary to map values to their indices in the \\'nums\\' array\\n        for i in range(len(nums)):\\n            dict_help[nums[i]] = i\\n            \\n        for j in range(len(operations)):\\n            if operations[j][0] in dict_help:\\n                # Get the original value and index\\n                original_value = operations[j][0]\\n                original_index = dict_help[original_value]\\n                \\n                # Delete the original value from the dictionary\\n                del dict_help[original_value]\\n                \\n                # Update the value at the original index in the \\'nums\\' array\\n                nums[original_index] = operations[j][1]\\n                \\n                # Update the dictionary with the new value-index pair\\n                dict_help[operations[j][1]] = original_index\\n        \\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918401,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> arrayChange(List<int> nums, List<List<int>> operations) {\\n      for (var op in operations) {\\n          final numToFind = op.first;\\n          final numToReplace = op.last;\\n          final idx = nums.indexOf(numToFind);\\n          nums[idx] = numToReplace;\\n      }\\n\\n      return nums;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> arrayChange(List<int> nums, List<List<int>> operations) {\\n      for (var op in operations) {\\n          final numToFind = op.first;\\n          final numToReplace = op.last;\\n          final idx = nums.indexOf(numToFind);\\n          nums[idx] = numToReplace;\\n      }\\n\\n      return nums;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912837,
                "title": "c-17-feature",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought of an O(M.N) solution first, which will not pass.\\nSimply finding each element and replacing it.\\n\\nThen I understood I somehow had to maintain the positions of my elements, so I thought of a map arrangement, where I could use either the key/value to store the positions.\\n\\nDid a bit of research and found a cool C++17 feature, I recommend googling it out. \\n\\nstd::extract()\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Store all numbers in a map with keys are values in array and values as positions.\\n2) Now iterate over operations and modify the key using your new weapon. :P\\n3) Store it again in another map, but this time the indices as keys.\\n4) Push back all the values into an array from the second map.\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> mp ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            mp[nums[i]] = i ;\\n        }\\n        for(auto v : operations){\\n            int a = v[0], b = v[1] ;\\n            auto nodeHandler = mp.extract(a) ;\\n            nodeHandler.key() = b ;\\n            mp.insert(move(nodeHandler)) ;\\n        }\\n        map<int, int> mp2 ;\\n        for(auto item : mp){\\n            mp2[item.second] = item.first ;\\n        }\\n        vector<int> ans ;\\n        for(auto item : mp2){\\n            ans.push_back(item.second) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, int> mp ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            mp[nums[i]] = i ;\\n        }\\n        for(auto v : operations){\\n            int a = v[0], b = v[1] ;\\n            auto nodeHandler = mp.extract(a) ;\\n            nodeHandler.key() = b ;\\n            mp.insert(move(nodeHandler)) ;\\n        }\\n        map<int, int> mp2 ;\\n        for(auto item : mp){\\n            mp2[item.second] = item.first ;\\n        }\\n        vector<int> ans ;\\n        for(auto item : mp2){\\n            ans.push_back(item.second) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904694,
                "title": "c-solution-easy-to-understand-o-n-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(int j=0;j<operations.size();j++)\\n        {\\n            auto it=mp.find(operations[j][0]);\\n            if(it!=mp.end())\\n            {\\n                int ind=it->second;\\n                nums[ind]=operations[j][1];\\n                mp[nums[ind]]=ind;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(int j=0;j<operations.size();j++)\\n        {\\n            auto it=mp.find(operations[j][0]);\\n            if(it!=mp.end())\\n            {\\n                int ind=it->second;\\n                nums[ind]=operations[j][1];\\n                mp[nums[ind]]=ind;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903394,
                "title": "unordered-map-simple-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int ind=mp[operations[i][0]];\\n            int withChange=operations[i][1];\\n            nums[ind]=withChange;\\n            mp.erase(nums[ind]);\\n            mp[withChange]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int ind=mp[operations[i][0]];\\n            int withChange=operations[i][1];\\n            nums[ind]=withChange;\\n            mp.erase(nums[ind]);\\n            mp[withChange]=ind;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898173,
                "title": "hashmap-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n       HashMap<Integer,Integer> map1=new HashMap<>();\\n       for(int j=0;j<nums.length;j++)\\n       {\\n           map1.put(nums[j],j);\\n       }\\n\\n       for(int j=0;j<operations.length;j++)\\n       {\\n\\n           int key=operations[j][0];\\n           int value=operations[j][1];\\n           if(map1.containsKey(key))\\n           {\\n               nums[map1.get(key)]=value;\\n               map1.put(value,map1.get(key));\\n               map1.remove(key);\\n           }\\n       }\\n       return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n       HashMap<Integer,Integer> map1=new HashMap<>();\\n       for(int j=0;j<nums.length;j++)\\n       {\\n           map1.put(nums[j],j);\\n       }\\n\\n       for(int j=0;j<operations.length;j++)\\n       {\\n\\n           int key=operations[j][0];\\n           int value=operations[j][1];\\n           if(map1.containsKey(key))\\n           {\\n               nums[map1.get(key)]=value;\\n               map1.put(value,map1.get(key));\\n               map1.remove(key);\\n           }\\n       }\\n       return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884262,
                "title": "replace-elements-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hm.put(nums[i],i);\\n        }\\n        for(int i=0;i<operations.length;i++)\\n        {\\n            nums[hm.get(operations[i][0])] = operations[i][1];\\n            hm.put(operations[i][1],hm.get(operations[i][0])); \\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hm.put(nums[i],i);\\n        }\\n        for(int i=0;i<operations.length;i++)\\n        {\\n            nums[hm.get(operations[i][0])] = operations[i][1];\\n            hm.put(operations[i][1],hm.get(operations[i][0])); \\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833653,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        // for(int i=0;i<op.size();i++){\\n        //     auto it=find(nums.begin(),nums.end(),op[i][0]);\\n        //     if(it!= nums.end() && \\n        //     find(nums.begin(),nums.end(),op[i][1])== nums.end()){\\n        //           *it=op[i][1];\\n        //       }\\n        // }\\n\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n       for(auto op : operations){\\n        nums[m[op[0]]] = op[1];\\n        m[op[1]] = m[op[0]];\\n      }\\n        return nums;\\n\\n    //     int n=nums.size();\\n    //     vector<int>ans(n);\\n    //     unordered_map<int, int>mp;\\n    //     for(auto i=0; i<nums.size(); i++)\\n    //         mp[nums[i]]=i;\\n        \\n    //     for(auto i:op)\\n    //     {\\n    //         int index = mp[i[0]];\\n    //         mp[i[1]]=index;\\n    //         mp.erase(i[0]);\\n    //     }\\n    //     for(auto [k,v]:mp)\\n    //         ans[v]=k;\\n    \\n    //     return ans;\\n    // }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        // for(int i=0;i<op.size();i++){\\n        //     auto it=find(nums.begin(),nums.end(),op[i][0]);\\n        //     if(it!= nums.end() && \\n        //     find(nums.begin(),nums.end(),op[i][1])== nums.end()){\\n        //           *it=op[i][1];\\n        //       }\\n        // }\\n\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n       for(auto op : operations){\\n        nums[m[op[0]]] = op[1];\\n        m[op[1]] = m[op[0]];\\n      }\\n        return nums;\\n\\n    //     int n=nums.size();\\n    //     vector<int>ans(n);\\n    //     unordered_map<int, int>mp;\\n    //     for(auto i=0; i<nums.size(); i++)\\n    //         mp[nums[i]]=i;\\n        \\n    //     for(auto i:op)\\n    //     {\\n    //         int index = mp[i[0]];\\n    //         mp[i[1]]=index;\\n    //         mp.erase(i[0]);\\n    //     }\\n    //     for(auto [k,v]:mp)\\n    //         ans[v]=k;\\n    \\n    //     return ans;\\n    // }\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3829834,
                "title": "100-beats",
                "content": "# Code\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], o: List[List[int]]) -> List[int]:\\n        d = {}\\n        for i in range(len(nums)):\\n            d[nums[i]] = i\\n        for i in o:\\n            a = i[1]\\n            b = d[i[0]]\\n            nums[d[i[0]]],i[1]= i[1],nums[d[i[0]]]\\n            d[a] = b\\n            del d[i[0]]\\n        return nums\\n                \\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], o: List[List[int]]) -> List[int]:\\n        d = {}\\n        for i in range(len(nums)):\\n            d[nums[i]] = i\\n        for i in o:\\n            a = i[1]\\n            b = d[i[0]]\\n            nums[d[i[0]]],i[1]= i[1],nums[d[i[0]]]\\n            d[a] = b\\n            del d[i[0]]\\n        return nums\\n                \\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827632,
                "title": "simple-logic-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n            hash = {n:i for i, n in enumerate(nums)}\\n            for i in operations:\\n                hash[i[1]] = hash[i[0]]\\n                nums[hash[i[0]]] = i[1]\\n            \\n            return nums\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n            hash = {n:i for i, n in enumerate(nums)}\\n            for i in operations:\\n                hash[i[1]] = hash[i[0]]\\n                nums[hash[i[0]]] = i[1]\\n            \\n            return nums\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826521,
                "title": "use-a-hash-map-o-n-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the elements are distinct, one can simply hash each elements index and go from there.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a hash map!\\nHopefully the code is self-explanatory.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int> nums, vector<vector<int>>& operations) {\\n        std::unordered_map<int, int> m;\\n        for(int i = 0; i < nums.size(); ++i){\\n            m[nums[i]] = i;\\n        }\\n        for(const auto& op : operations){\\n            const int a = op[0], b = op[1];\\n            const int index = m[a];\\n            nums[index] = b;\\n            m.erase(a);\\n            m[b] = index;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int> nums, vector<vector<int>>& operations) {\\n        std::unordered_map<int, int> m;\\n        for(int i = 0; i < nums.size(); ++i){\\n            m[nums[i]] = i;\\n        }\\n        for(const auto& op : operations){\\n            const int a = op[0], b = op[1];\\n            const int index = m[a];\\n            nums[index] = b;\\n            m.erase(a);\\n            m[b] = index;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820628,
                "title": "simple-javascript-solution-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain two maps, indexToValue and valueToIndex. Fill them at the start and perform operations as they come\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\n    const indToVal = {}\\n    const valToInd = {}\\n    for(let i =0; i< nums.length; i++){\\n        indToVal[i] = nums[i];\\n        valToInd[nums[i]] = i;\\n    }\\n    for(let j = 0; j<operations.length; j++){\\n        let temp = valToInd[operations[j][0]];\\n        indToVal[valToInd[operations[j][0]]] = operations[j][1];\\n        delete valToInd[operations[j][0]]\\n        valToInd[operations[j][1]] = temp\\n    }\\n    return Object.values(indToVal)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\n    const indToVal = {}\\n    const valToInd = {}\\n    for(let i =0; i< nums.length; i++){\\n        indToVal[i] = nums[i];\\n        valToInd[nums[i]] = i;\\n    }\\n    for(let j = 0; j<operations.length; j++){\\n        let temp = valToInd[operations[j][0]];\\n        indToVal[valToInd[operations[j][0]]] = operations[j][1];\\n        delete valToInd[operations[j][0]]\\n        valToInd[operations[j][1]] = temp\\n    }\\n    return Object.values(indToVal)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745371,
                "title": "slow-but-easy-to-understand-solution-for-a-medium-rated-problem",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        for (int[] op: operations) {\\n            int index= map.get(op[0]);\\n            map.put(op[1], index);\\n            nums[index] = op[1];\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], i);\\n        }\\n\\n        for (int[] op: operations) {\\n            int index= map.get(op[0]);\\n            map.put(op[1], index);\\n            nums[index] = op[1];\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742010,
                "title": "simple-and-easy-solution-o-n-time-and-space",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp.insert({nums[i],i});\\n        }\\n        for(int i=0;i<operations.size();i++){\\n            int a = operations[i][0];\\n            int b = operations[i][1];\\n            int index = mp[a];\\n            int ele = nums[index];\\n            nums[index] = b;\\n            mp.erase(ele);\\n            mp.insert({b,index});\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp.insert({nums[i],i});\\n        }\\n        for(int i=0;i<operations.size();i++){\\n            int a = operations[i][0];\\n            int b = operations[i][1];\\n            int index = mp[a];\\n            int ele = nums[index];\\n            nums[index] = b;\\n            mp.erase(ele);\\n            mp.insert({b,index});\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738850,
                "title": "typescript-solution-beats-speed-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfunction arrayChange(nums: number[], operations: number[][]): number[] {\\n    const d: any | null = {};\\n    for(let i=0; i<nums.length; i++)\\n        d[nums[i]] = i;\\n    \\n    for(const operation of operations) {\\n        const [u, v] =  [...operation];\\n        d[v] = d[u];\\n        d[u] = null;\\n    }\\n    let result: number[] = nums.map(each =>0);\\n    let k: string;\\n    let v: any= 0; \\n    for([k, v] of Object.entries(d)) {\\n        if (v != null)\\n            result[v] = Number(k);\\n    }   \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction arrayChange(nums: number[], operations: number[][]): number[] {\\n    const d: any | null = {};\\n    for(let i=0; i<nums.length; i++)\\n        d[nums[i]] = i;\\n    \\n    for(const operation of operations) {\\n        const [u, v] =  [...operation];\\n        d[v] = d[u];\\n        d[u] = null;\\n    }\\n    let result: number[] = nums.map(each =>0);\\n    let k: string;\\n    let v: any= 0; \\n    for([k, v] of Object.entries(d)) {\\n        if (v != null)\\n            result[v] = Number(k);\\n    }   \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734316,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n      unordered_map<int, int> index;\\n      for (int i = 0; i < nums.size(); i++)\\n        index[nums[i]] = i;\\n      for (auto& op : operations) {\\n        nums[index[op[0]]] = op[1];\\n        index[op[1]] = index[op[0]];\\n      }\\n      return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n      unordered_map<int, int> index;\\n      for (int i = 0; i < nums.size(); i++)\\n        index[nums[i]] = i;\\n      for (auto& op : operations) {\\n        nums[index[op[0]]] = op[1];\\n        index[op[1]] = index[op[0]];\\n      }\\n      return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722165,
                "title": "masum-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        unordered_map<int,int>umap;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            umap[nums[i]]=i;\\n        }\\n\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int pos=umap[operations[i][0]];\\n            nums[pos]=operations[i][1];\\n            umap[operations[i][1]]=pos;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        unordered_map<int,int>umap;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            umap[nums[i]]=i;\\n        }\\n\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            int pos=umap[operations[i][0]];\\n            nums[pos]=operations[i][1];\\n            umap[operations[i][1]]=pos;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698297,
                "title": "c-brute-optimized-hashmaps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& o) \\n    {\\n        // int  n=nums.size();\\n        // for(auto it:o)\\n        // {\\n        //     int num1=it[0];\\n        //     int num2=it[1];\\n        //     for(int i=0;i<n;i++)\\n        //     {\\n        //         if(nums[i]==num1)\\n        //         {\\n        //             nums[i]=num2;\\n        //             break;\\n        //         }\\n        //     }\\n        // }\\n        // return nums;\\n\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)m[nums[i]]=i;\\n\\n        for(auto it:o)\\n        {\\n            int num1=it[0];\\n            int num2=it[1];\\n\\n            nums[m[num1]]=num2;\\n            m[num2]=m[num1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& o) \\n    {\\n        // int  n=nums.size();\\n        // for(auto it:o)\\n        // {\\n        //     int num1=it[0];\\n        //     int num2=it[1];\\n        //     for(int i=0;i<n;i++)\\n        //     {\\n        //         if(nums[i]==num1)\\n        //         {\\n        //             nums[i]=num2;\\n        //             break;\\n        //         }\\n        //     }\\n        // }\\n        // return nums;\\n\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)m[nums[i]]=i;\\n\\n        for(auto it:o)\\n        {\\n            int num1=it[0];\\n            int num2=it[1];\\n\\n            nums[m[num1]]=num2;\\n            m[num2]=m[num1];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686750,
                "title": "intuitive-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=i;\\n        }\\n\\n        for(auto itr:operations){\\n           nums[mp[itr[0]]]=itr[1];\\n           mp[itr[1]]=mp[itr[0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=i;\\n        }\\n\\n        for(auto itr:operations){\\n           nums[mp[itr[0]]]=itr[1];\\n           mp[itr[1]]=mp[itr[0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683507,
                "title": "java-easy-hashmap-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer , Integer> hm = new HashMap<>();\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++) hm.put(nums[i] , i);\\n\\n        int m = operations.length;\\n        for(int i = 0; i < m; i++)\\n        {\\n            int index = hm.get(operations[i][0]);\\n            hm.remove(operations[i][0]);    //to reduce space occupancy\\n            nums[index] = operations[i][1];\\n            hm.put(nums[index] , index);    //to update new value of nums at that index to use it accordingly for operations\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer , Integer> hm = new HashMap<>();\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++) hm.put(nums[i] , i);\\n\\n        int m = operations.length;\\n        for(int i = 0; i < m; i++)\\n        {\\n            int index = hm.get(operations[i][0]);\\n            hm.remove(operations[i][0]);    //to reduce space occupancy\\n            nums[index] = operations[i][1];\\n            hm.put(nums[index] , index);    //to update new value of nums at that index to use it accordingly for operations\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677795,
                "title": "simple-python-solution-dictionary-78",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        lookup = {}\\n        for i,val in enumerate(nums):\\n            lookup[val] = i\\n        answer = nums\\n        for i,j in operations:\\n            index = lookup[i]\\n            answer[index] = j\\n            lookup.pop(i)\\n            lookup[j] = index\\n        return answer        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        lookup = {}\\n        for i,val in enumerate(nums):\\n            lookup[val] = i\\n        answer = nums\\n        for i,j in operations:\\n            index = lookup[i]\\n            answer[index] = j\\n            lookup.pop(i)\\n            lookup[j] = index\\n        return answer        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676217,
                "title": "5-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i = 0;i<nums.size();i++)mp[nums[i]] = i;\\n        for(auto it:operations){\\n            nums[mp[it[0]]] = it[1];\\n            mp[it[1]] = mp[it[0]];\\n            mp.erase(it[0]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>mp;\\n        for(int i = 0;i<nums.size();i++)mp[nums[i]] = i;\\n        for(auto it:operations){\\n            nums[mp[it[0]]] = it[1];\\n            mp[it[1]] = mp[it[0]];\\n            mp.erase(it[0]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656543,
                "title": "java-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        Map<Integer,Integer> hm=new LinkedHashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(nums[i],i);\\n        }\\n        int a=0;\\n        for(int[] op:operations){\\n            if(hm.containsKey(op[0])){\\n                int ind=hm.get(op[0]);\\n                hm.remove(op[0]);\\n                hm.put(op[1],ind);\\n            }\\n        }\\n        for(int k:hm.keySet()) res[hm.get(k)]=k;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        Map<Integer,Integer> hm=new LinkedHashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm.put(nums[i],i);\\n        }\\n        int a=0;\\n        for(int[] op:operations){\\n            if(hm.containsKey(op[0])){\\n                int ind=hm.get(op[0]);\\n                hm.remove(op[0]);\\n                hm.put(op[1],ind);\\n            }\\n        }\\n        for(int k:hm.keySet()) res[hm.get(k)]=k;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651236,
                "title": "easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse hash map to keep the elements index and use it to update.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially store the elements and its index in the map.\\nNow from the operations array, Find the element in the mp and its corresponding index. Now store the index and delete the element from the map. Update the map with the new element with the stored index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]] = i;\\n        }\\n        for(auto x:operations){\\n            auto it = mp.find(x[0]);\\n            int k = it->second;\\n            mp.erase(it);\\n            mp[x[1]] = k;\\n        }\\n        vector<int> ans(n);\\n        for(auto x:mp){\\n            ans[x.second] = x.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]] = i;\\n        }\\n        for(auto x:operations){\\n            auto it = mp.find(x[0]);\\n            int k = it->second;\\n            mp.erase(it);\\n            mp[x[1]] = k;\\n        }\\n        vector<int> ans(n);\\n        for(auto x:mp){\\n            ans[x.second] = x.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642580,
                "title": "using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }\\n        for(int i=0;i<operations.length;i++){\\n        int l=hm.get(operations[i][0]);\\n          hm.remove(operations[i][0]);\\n          hm.put(operations[i][1],l);  \\n        }\\n        int[]ans=new int[nums.length];\\n        for(Map.Entry<Integer,Integer>m:hm.entrySet()){\\n            ans[m.getValue()]=m.getKey();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }\\n        for(int i=0;i<operations.length;i++){\\n        int l=hm.get(operations[i][0]);\\n          hm.remove(operations[i][0]);\\n          hm.put(operations[i][1],l);  \\n        }\\n        int[]ans=new int[nums.length];\\n        for(Map.Entry<Integer,Integer>m:hm.entrySet()){\\n            ans[m.getValue()]=m.getKey();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638162,
                "title": "fastest-way",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        vector<int> hash(1000001);\\n        \\n        for(int i=0; i<size(nums); i++)\\n        {\\n            hash[nums[i]] = i;\\n        }\\n\\n\\n        for(auto i:op)\\n        {\\n            nums[hash[i[0]]] = i[1];\\n            hash[i[1]] = hash[i[0]];\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return nums;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/efc3f555-d172-4f73-ba89-8af9b6f5c806_1686763586.0788023.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        vector<int> hash(1000001);\\n        \\n        for(int i=0; i<size(nums); i++)\\n        {\\n            hash[nums[i]] = i;\\n        }\\n\\n\\n        for(auto i:op)\\n        {\\n            nums[hash[i[0]]] = i[1];\\n            hash[i[1]] = hash[i[0]];\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633784,
                "title": "simple-solution",
                "content": "# Intuition\\nIt\\'s simple, first of all, we fill the Hashmap with values and indexes from the array. Then we look for them.\\n\\n# Code\\n```\\nclass Solution {\\n\\nfun arrayChange(nums: IntArray, operations: Array<IntArray>): IntArray {\\n\\n    val memory = HashMap<Int,Int>()\\n\\n    // fill memory\\n    nums.forEachIndexed{value: Int, key: Int -> memory[key] = value }\\n\\n    //change values in\\n    operations.forEach { ints ->\\n\\n        val key = ints[0]\\n        memory[key]?.let { nums.set(it,ints[1]) }\\n\\n        memory.remove(key)?.let {\\n            memory.put(ints[1], it)\\n        }\\n\\n    }\\n    \\n    return nums\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\nfun arrayChange(nums: IntArray, operations: Array<IntArray>): IntArray {\\n\\n    val memory = HashMap<Int,Int>()\\n\\n    // fill memory\\n    nums.forEachIndexed{value: Int, key: Int -> memory[key] = value }\\n\\n    //change values in\\n    operations.forEach { ints ->\\n\\n        val key = ints[0]\\n        memory[key]?.let { nums.set(it,ints[1]) }\\n\\n        memory.remove(key)?.let {\\n            memory.put(ints[1], it)\\n        }\\n\\n    }\\n    \\n    return nums\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615224,
                "title": "java",
                "content": "```\\nclass Solution {\\n        public int[] arrayChange(int[] nums, int[][] operations) {\\n            HashMap<Integer, Integer> mapa = new HashMap<>();\\n            for (int i =0; i < nums.length; i++){\\n                mapa.put(nums[i], i);\\n            }\\n\\n            for (int i =0; i < operations.length; i++){\\n                int idx = mapa.get(operations[i][0]);\\n                mapa.remove(operations[i][0]);\\n                mapa.put(operations[i][1], idx);\\n            }\\n            for (int x : mapa.keySet()){\\n                nums[mapa.get(x)] = x;\\n            }\\n            return nums;\\n        }\\n    }\\n\\t``",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] arrayChange(int[] nums, int[][] operations) {\\n            HashMap<Integer, Integer> mapa = new HashMap<>();\\n            for (int i =0; i < nums.length; i++){\\n                mapa.put(nums[i], i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3605341,
                "title": "c-short-crisp-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n        for(int i=0;i<op.size();i++){\\n            if(m.find(op[i][0])!=m.end()){\\n                nums[m[op[i][0]]]=op[i][1];\\n                m[op[i][1]]=m[op[i][0]];\\n            }\\n        }\\n        return nums;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& op) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]=i;\\n        }\\n        for(int i=0;i<op.size();i++){\\n            if(m.find(op[i][0])!=m.end()){\\n                nums[m[op[i][0]]]=op[i][1];\\n                m[op[i][1]]=m[op[i][0]];\\n            }\\n        }\\n        return nums;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602562,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        mapping = {}\\n\\n        for i,x in enumerate(nums):\\n            mapping[x] = i\\n        \\n        for x in operations:\\n            nums[mapping[x[0]]] = x[1]\\n            mapping[x[1]] = mapping[x[0]]\\n            del mapping[x[0]]\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n        mapping = {}\\n\\n        for i,x in enumerate(nums):\\n            mapping[x] = i\\n        \\n        for x in operations:\\n            nums[mapping[x[0]]] = x[1]\\n            mapping[x[1]] = mapping[x[0]]\\n            del mapping[x[0]]\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584014,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        unordered_map<int,int> mp;\\n        int i,n,m;\\n        n=nums.size();\\n        m=operations.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n\\n        for(i=0;i<m;i++)\\n        {\\n            nums[mp[operations[i][0]]]=operations[i][1];\\n            mp[operations[i][1]]=mp[operations[i][0]];\\n        }    \\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) \\n    {\\n        unordered_map<int,int> mp;\\n        int i,n,m;\\n        n=nums.size();\\n        m=operations.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            mp[nums[i]]=i;\\n        }\\n\\n        for(i=0;i<m;i++)\\n        {\\n            nums[mp[operations[i][0]]]=operations[i][1];\\n            mp[operations[i][1]]=mp[operations[i][0]];\\n        }    \\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556574,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n                HashMap<Integer,Integer> hm = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }\\n        for (int i=0;i<operations.length;i++){\\n            int temp = hm.get(operations[i][0]);\\n            nums[temp] = operations[i][1];\\n            hm.remove(operations[i][0]);\\n            hm.put(operations[i][1],temp);\\n        }\\n        return nums;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n                HashMap<Integer,Integer> hm = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            hm.put(nums[i],i);\\n        }\\n        for (int i=0;i<operations.length;i++){\\n            int temp = hm.get(operations[i][0]);\\n            nums[temp] = operations[i][1];\\n            hm.remove(operations[i][0]);\\n            hm.put(operations[i][1],temp);\\n        }\\n        return nums;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552422,
                "title": "c-hashtable-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& arr) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<nums.size();i++) map[nums[i]]=i;\\n        for(int i=0;i<arr.size();i++){\\n            if(map.find(arr[i][0]) != map.end()) {\\n                nums[map[arr[i][0]]]=arr[i][1];\\n                int index=map[arr[i][0]];\\n                map.erase(arr[i][0]);\\n                map[arr[i][1]]=index;\\n            }\\n        }\\n        for(auto x:map){\\n            nums[x.second]=x.first;\\n        } \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& arr) {\\n        unordered_map<int,int>map;\\n        for(int i=0;i<nums.size();i++) map[nums[i]]=i;\\n        for(int i=0;i<arr.size();i++){\\n            if(map.find(arr[i][0]) != map.end()) {\\n                nums[map[arr[i][0]]]=arr[i][1];\\n                int index=map[arr[i][0]];\\n                map.erase(arr[i][0]);\\n                map[arr[i][1]]=index;\\n            }\\n        }\\n        for(auto x:map){\\n            nums[x.second]=x.first;\\n        } \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547639,
                "title": "c-2-sol-o-n-time-o-n-space",
                "content": "\\n# 2 map\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        /*\\n            like merge interval\\n            merge operations first than apply to nums.\\n        */\\n\\n        unordered_map<int,int> lookup;\\n        unordered_map<int,int> reverse_lookup;\\n        \\n        for(const auto &o:operations){\\n            if(reverse_lookup.count(o[0])){\\n                int index = reverse_lookup[o[0]];\\n                reverse_lookup.erase(o[0]);\\n                \\n                lookup[index] = o[1];\\n                reverse_lookup[o[1]] = index;\\n            }else{\\n                lookup[o[0]] = o[1];\\n                reverse_lookup[o[1]] = o[0];\\n            }\\n        }\\n\\n        for(auto &i:nums)\\n            i= lookup.count(i)?lookup[i]:i;\\n\\n        return nums;\\n    }\\n};\\n```\\n\\n# 1 map\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n\\n        unordered_map<int,int> reverse_lookup;\\n        for(int i{};i<nums.size();i++)\\n            reverse_lookup[nums[i]]=i;\\n        \\n        for(const auto &o:operations){\\n            int updated_index = reverse_lookup[o[0]];\\n            \\n            nums[ updated_index ] = o[1];\\n\\n            reverse_lookup[o[1]] = updated_index;\\n            reverse_lookup.erase(o[0]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        \\n        /*\\n            like merge interval\\n            merge operations first than apply to nums.\\n        */\\n\\n        unordered_map<int,int> lookup;\\n        unordered_map<int,int> reverse_lookup;\\n        \\n        for(const auto &o:operations){\\n            if(reverse_lookup.count(o[0])){\\n                int index = reverse_lookup[o[0]];\\n                reverse_lookup.erase(o[0]);\\n                \\n                lookup[index] = o[1];\\n                reverse_lookup[o[1]] = index;\\n            }else{\\n                lookup[o[0]] = o[1];\\n                reverse_lookup[o[1]] = o[0];\\n            }\\n        }\\n\\n        for(auto &i:nums)\\n            i= lookup.count(i)?lookup[i]:i;\\n\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n\\n        unordered_map<int,int> reverse_lookup;\\n        for(int i{};i<nums.size();i++)\\n            reverse_lookup[nums[i]]=i;\\n        \\n        for(const auto &o:operations){\\n            int updated_index = reverse_lookup[o[0]];\\n            \\n            nums[ updated_index ] = o[1];\\n\\n            reverse_lookup[o[1]] = updated_index;\\n            reverse_lookup.erase(o[0]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543280,
                "title": "simply-explained",
                "content": "# Approach\\n1) Build a hashmap from nums with key=nums[i], value=i\\n2) Perform operation 1 by 1, we need a map in order to quickly find operation[i][FROM,] number\\n3) Restore the original order of numbers from the Map by sorting by value\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(2n)$$\\n\\n# Code\\n```\\n/**\\nvar arrayChange = function(nums, operations) {\\n    const map = new Map();\\n    // since nums contain distinct numbers we build a map with key=number, value=i\\n    for(let i=0;i<nums.length;i++) map.set(nums[i],i);\\n\\n    // perform a replacement\\n    for(const [from,to] of operations){\\n        if(map.has(from)){\\n            // we can not change a key in a map, so we rather add new one\\n            map.set(to, map.get(from))\\n\\n            // and delete old one\\n            map.delete(from);\\n        }\\n    }\\n\\n    // we need to restore an original order, by sorting map by val,\\n    // but we rather just create a spare js array and set all indexes\\n    // it will take O(N)\\n    const result=[];\\n    for(let [key,val] of map.entries())\\n        result[val]=key;\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\nvar arrayChange = function(nums, operations) {\\n    const map = new Map();\\n    // since nums contain distinct numbers we build a map with key=number, value=i\\n    for(let i=0;i<nums.length;i++) map.set(nums[i],i);\\n\\n    // perform a replacement\\n    for(const [from,to] of operations){\\n        if(map.has(from)){\\n            // we can not change a key in a map, so we rather add new one\\n            map.set(to, map.get(from))\\n\\n            // and delete old one\\n            map.delete(from);\\n        }\\n    }\\n\\n    // we need to restore an original order, by sorting map by val,\\n    // but we rather just create a spare js array and set all indexes\\n    // it will take O(N)\\n    const result=[];\\n    for(let [key,val] of map.entries())\\n        result[val]=key;\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523378,
                "title": "use-of-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int , int>  m  ; \\n        // Insertion  in the map   \\n    \\n        for  ( int i  = 0  ;   i < nums.size( )  ; i++ ){\\n\\n            m.insert({nums[i]  , i  })  ; \\n        }\\n\\n        for  (int  i = 0   ;  i < operations.size() ;i++ ){\\n            if (  m.find(operations[i][0]) != m.end() ){\\n                auto it  = m[operations[i][0]]  ; \\n                m.erase(operations[i][0])  ; \\n\\n                nums[it]  = operations[i][1]  ; \\n                m.insert({operations[i][1]  ,  it })  ;  \\n\\n                \\n            }\\n        }\\n\\n\\n        return nums    ;  \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        map<int , int>  m  ; \\n        // Insertion  in the map   \\n    \\n        for  ( int i  = 0  ;   i < nums.size( )  ; i++ ){\\n\\n            m.insert({nums[i]  , i  })  ; \\n        }\\n\\n        for  (int  i = 0   ;  i < operations.size() ;i++ ){\\n            if (  m.find(operations[i][0]) != m.end() ){\\n                auto it  = m[operations[i][0]]  ; \\n                m.erase(operations[i][0])  ; \\n\\n                nums[it]  = operations[i][1]  ; \\n                m.insert({operations[i][1]  ,  it })  ;  \\n\\n                \\n            }\\n        }\\n\\n\\n        return nums    ;  \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509015,
                "title": "most-most-simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       O(max(m,n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(auto it:operations)\\n        {\\n            int index=m[it[0]];\\n            nums[index]=it[1];\\n            m[it[1]]=index;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(auto it:operations)\\n        {\\n            int index=m[it[0]];\\n            nums[index]=it[1];\\n            m[it[1]]=index;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453017,
                "title": "java-hash-table-implementation-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int[] arrayChange(int[] nums, int[][] opt) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i=0;i<opt.length;i++){\\n            int oldNum=opt[i][0];\\n            int newNum=opt[i][1];\\n            \\n            if(map.containsKey(oldNum)){\\n                int index=map.get(oldNum);\\n                nums[index]=newNum;\\n                \\n                map.put(newNum,index);\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n     public int[] arrayChange(int[] nums, int[][] opt) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i=0;i<opt.length;i++){\\n            int oldNum=opt[i][0];\\n            int newNum=opt[i][1];\\n            \\n            if(map.containsKey(oldNum)){\\n                int index=map.get(oldNum);\\n                nums[index]=newNum;\\n                \\n                map.put(newNum,index);\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450358,
                "title": "c-easiest-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>index;\\n        for(int i=0; i<nums.size(); i++)index[nums[i]]=i;\\n        for(int i=0; i<operations.size();i++){\\n            nums[index[operations[i][0]]]=operations[i][1];\\n            index[operations[i][1]]=index[operations[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int,int>index;\\n        for(int i=0; i<nums.size(); i++)index[nums[i]]=i;\\n        for(int i=0; i<operations.size();i++){\\n            nums[index[operations[i][0]]]=operations[i][1];\\n            index[operations[i][1]]=index[operations[i][0]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449830,
                "title": "c-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, pair<int, int>>m;\\n        for(int i=0; i<nums.size(); i++){\\n            m.insert({nums[i], make_pair(i, nums[i])});\\n        }\\n\\n        for(int i=0; i<operations.size(); i++){\\n            pair<int, int> p = m[operations[i][0]];\\n            p.second = operations[i][1];\\n            m.erase(operations[i][0]);\\n            m.insert({operations[i][1], p});\\n        }\\n\\n        for(auto it = m.begin(); it != m.end(); it++){\\n            pair<int, int> p = it->second;\\n            nums[p.first] = p.second;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arrayChange(vector<int>& nums, vector<vector<int>>& operations) {\\n        unordered_map<int, pair<int, int>>m;\\n        for(int i=0; i<nums.size(); i++){\\n            m.insert({nums[i], make_pair(i, nums[i])});\\n        }\\n\\n        for(int i=0; i<operations.size(); i++){\\n            pair<int, int> p = m[operations[i][0]];\\n            p.second = operations[i][1];\\n            m.erase(operations[i][0]);\\n            m.insert({operations[i][1], p});\\n        }\\n\\n        for(auto it = m.begin(); it != m.end(); it++){\\n            pair<int, int> p = it->second;\\n            nums[p.first] = p.second;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437048,
                "title": "hashmap-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        mp.put(nums[i],i);\\n    }\\n\\n    for(int i=0;i<operations.length;i++){\\n    int index=mp.get(operations[i][0]);\\n    nums[index]=operations[i][1];\\n    mp.remove(operations[i][0]);\\n    mp.put(operations[i][1],index);\\n    }\\n\\n    return nums;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    for(int i=0;i<nums.length;i++){\\n        mp.put(nums[i],i);\\n    }\\n\\n    for(int i=0;i<operations.length;i++){\\n    int index=mp.get(operations[i][0]);\\n    nums[index]=operations[i][1];\\n    mp.remove(operations[i][0]);\\n    mp.put(operations[i][1],index);\\n    }\\n\\n    return nums;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436204,
                "title": "c-solution-using-hashmap",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] ArrayChange(int[] nums, int[][] operations) {\\n        Dictionary<int, int> map = new Dictionary<int, int>();\\n        for(int i = 0; i < nums.Length; i++) {\\n            map.Add(nums[i], i);\\n        }\\n\\n        foreach(int[] op in operations) {\\n            int index = map[op[0]];\\n            nums[index] = op[1];\\n            map.Remove(op[0]);\\n            map.Add(op[1], index);\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ArrayChange(int[] nums, int[][] operations) {\\n        Dictionary<int, int> map = new Dictionary<int, int>();\\n        for(int i = 0; i < nums.Length; i++) {\\n            map.Add(nums[i], i);\\n        }\\n\\n        foreach(int[] op in operations) {\\n            int index = map[op[0]];\\n            nums[index] = op[1];\\n            map.Remove(op[0]);\\n            map.Add(op[1], index);\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432720,
                "title": "short-java-solution-using-hashmap",
                "content": "```class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer,Integer>();\\n        for(int i = 0; i < nums.length; i++) map.put(nums[i],i);\\n        for(int i = 0; i < operations.length; i++){\\n            nums[map.get(operations[i][0])] = operations[i][1];\\n            map.put(operations[i][1], map.get(operations[i][0]));\\n        }\\n        return nums; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] arrayChange(int[] nums, int[][] operations) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer,Integer>();\\n        for(int i = 0; i < nums.length; i++) map.put(nums[i],i);\\n        for(int i = 0; i < operations.length; i++){\\n            nums[map.get(operations[i][0])] = operations[i][1];\\n            map.put(operations[i][1], map.get(operations[i][0]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3430712,
                "title": "2-lines-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\noperations.map(op=>{\\n    nums[nums.indexOf(op[0])]=op[1]\\n})\\nreturn (nums)  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} operations\\n * @return {number[]}\\n */\\nvar arrayChange = function(nums, operations) {\\noperations.map(op=>{\\n    nums[nums.indexOf(op[0])]=op[1]\\n})\\nreturn (nums)  \\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1941479,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "Prompt doesn\\'t make any sense...  why when nums = [1,2] and operations = [[1,3],[2,1],[3,2]], the expected answer is [2,1] instead of [3,1]?  Am I the only one that thinks the problem is poorly explained"
                    },
                    {
                        "username": "leet_yeet",
                        "content": "[@mycoolhairison](/mycoolhairison) Why not continue down the path?\\nFourth operation turn [3,1] into [3,3] etc??"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "We are replacing elements of the array nums.  In the first operation we replace 1 with 3, after which nums = [3,2].  In the second operation we replace 2 with 1, after which nums = [3,1].  In the third operation we replace 3 with 2, after which nums = [2,1]."
                    },
                    {
                        "username": "space_invader",
                        "content": "HashMap ?"
                    },
                    {
                        "username": "ansh21006",
                        "content": "basically u have to updates the numbers\\n"
                    },
                    {
                        "username": "Grishound",
                        "content": "Yeah I did it using that."
                    },
                    {
                        "username": "saran19",
                        "content": "`operations[i][1]` will not exist in nums when applying the ith operation.\\nI overlooked this and solved using Map+LinkedList."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this... is a medium problem ? "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "yes\\n"
                    },
                    {
                        "username": "emg1930",
                        "content": "yeah I think this should be a easy one"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "How on earth should I use hashmap here ,find fn under linear fn is not passed ?"
                    },
                    {
                        "username": "MMeadow",
                        "content": "Why doesn\\'t my linear complexity pass?\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "Can someone explain what we have to do? I am unable to make out anything"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we have to replace the vector nums element if the operations[i][0] value if found with operations[i][1]"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bhai we know operation[i][0] definately exist in nums and we have to update nums value to operation[i][1] okay toh kuch esa socho ki ye task ho jaye "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "d=dict()\\n        c=0\\n        for i in nums:\\n            d[i]=c\\n            c+=1\\n        for i in operations:\\n            if i[0] in d:\\n                nums[d[i[0]]]=i[1]\\n                d[i[1]]=d[i[0]]\\n                del d[i[0]]\\n        return nums\\n"
                    },
                    {
                        "username": "MarioGranda",
                        "content": "Hello! Sure, you just have to pick each subarray from the array \"operations\" (this is of the form [number_1, number_2]) and transform  number_1 -> number_2 wherever there is a number_1 in the \"nums\" array. "
                    }
                ]
            },
            {
                "id": 1790779,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "Prompt doesn\\'t make any sense...  why when nums = [1,2] and operations = [[1,3],[2,1],[3,2]], the expected answer is [2,1] instead of [3,1]?  Am I the only one that thinks the problem is poorly explained"
                    },
                    {
                        "username": "leet_yeet",
                        "content": "[@mycoolhairison](/mycoolhairison) Why not continue down the path?\\nFourth operation turn [3,1] into [3,3] etc??"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "We are replacing elements of the array nums.  In the first operation we replace 1 with 3, after which nums = [3,2].  In the second operation we replace 2 with 1, after which nums = [3,1].  In the third operation we replace 3 with 2, after which nums = [2,1]."
                    },
                    {
                        "username": "space_invader",
                        "content": "HashMap ?"
                    },
                    {
                        "username": "ansh21006",
                        "content": "basically u have to updates the numbers\\n"
                    },
                    {
                        "username": "Grishound",
                        "content": "Yeah I did it using that."
                    },
                    {
                        "username": "saran19",
                        "content": "`operations[i][1]` will not exist in nums when applying the ith operation.\\nI overlooked this and solved using Map+LinkedList."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this... is a medium problem ? "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "yes\\n"
                    },
                    {
                        "username": "emg1930",
                        "content": "yeah I think this should be a easy one"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "How on earth should I use hashmap here ,find fn under linear fn is not passed ?"
                    },
                    {
                        "username": "MMeadow",
                        "content": "Why doesn\\'t my linear complexity pass?\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "Can someone explain what we have to do? I am unable to make out anything"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we have to replace the vector nums element if the operations[i][0] value if found with operations[i][1]"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bhai we know operation[i][0] definately exist in nums and we have to update nums value to operation[i][1] okay toh kuch esa socho ki ye task ho jaye "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "d=dict()\\n        c=0\\n        for i in nums:\\n            d[i]=c\\n            c+=1\\n        for i in operations:\\n            if i[0] in d:\\n                nums[d[i[0]]]=i[1]\\n                d[i[1]]=d[i[0]]\\n                del d[i[0]]\\n        return nums\\n"
                    },
                    {
                        "username": "MarioGranda",
                        "content": "Hello! Sure, you just have to pick each subarray from the array \"operations\" (this is of the form [number_1, number_2]) and transform  number_1 -> number_2 wherever there is a number_1 in the \"nums\" array. "
                    }
                ]
            },
            {
                "id": 2065564,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "Prompt doesn\\'t make any sense...  why when nums = [1,2] and operations = [[1,3],[2,1],[3,2]], the expected answer is [2,1] instead of [3,1]?  Am I the only one that thinks the problem is poorly explained"
                    },
                    {
                        "username": "leet_yeet",
                        "content": "[@mycoolhairison](/mycoolhairison) Why not continue down the path?\\nFourth operation turn [3,1] into [3,3] etc??"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "We are replacing elements of the array nums.  In the first operation we replace 1 with 3, after which nums = [3,2].  In the second operation we replace 2 with 1, after which nums = [3,1].  In the third operation we replace 3 with 2, after which nums = [2,1]."
                    },
                    {
                        "username": "space_invader",
                        "content": "HashMap ?"
                    },
                    {
                        "username": "ansh21006",
                        "content": "basically u have to updates the numbers\\n"
                    },
                    {
                        "username": "Grishound",
                        "content": "Yeah I did it using that."
                    },
                    {
                        "username": "saran19",
                        "content": "`operations[i][1]` will not exist in nums when applying the ith operation.\\nI overlooked this and solved using Map+LinkedList."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this... is a medium problem ? "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "yes\\n"
                    },
                    {
                        "username": "emg1930",
                        "content": "yeah I think this should be a easy one"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "How on earth should I use hashmap here ,find fn under linear fn is not passed ?"
                    },
                    {
                        "username": "MMeadow",
                        "content": "Why doesn\\'t my linear complexity pass?\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "Can someone explain what we have to do? I am unable to make out anything"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we have to replace the vector nums element if the operations[i][0] value if found with operations[i][1]"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bhai we know operation[i][0] definately exist in nums and we have to update nums value to operation[i][1] okay toh kuch esa socho ki ye task ho jaye "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "d=dict()\\n        c=0\\n        for i in nums:\\n            d[i]=c\\n            c+=1\\n        for i in operations:\\n            if i[0] in d:\\n                nums[d[i[0]]]=i[1]\\n                d[i[1]]=d[i[0]]\\n                del d[i[0]]\\n        return nums\\n"
                    },
                    {
                        "username": "MarioGranda",
                        "content": "Hello! Sure, you just have to pick each subarray from the array \"operations\" (this is of the form [number_1, number_2]) and transform  number_1 -> number_2 wherever there is a number_1 in the \"nums\" array. "
                    }
                ]
            },
            {
                "id": 2012213,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "Prompt doesn\\'t make any sense...  why when nums = [1,2] and operations = [[1,3],[2,1],[3,2]], the expected answer is [2,1] instead of [3,1]?  Am I the only one that thinks the problem is poorly explained"
                    },
                    {
                        "username": "leet_yeet",
                        "content": "[@mycoolhairison](/mycoolhairison) Why not continue down the path?\\nFourth operation turn [3,1] into [3,3] etc??"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "We are replacing elements of the array nums.  In the first operation we replace 1 with 3, after which nums = [3,2].  In the second operation we replace 2 with 1, after which nums = [3,1].  In the third operation we replace 3 with 2, after which nums = [2,1]."
                    },
                    {
                        "username": "space_invader",
                        "content": "HashMap ?"
                    },
                    {
                        "username": "ansh21006",
                        "content": "basically u have to updates the numbers\\n"
                    },
                    {
                        "username": "Grishound",
                        "content": "Yeah I did it using that."
                    },
                    {
                        "username": "saran19",
                        "content": "`operations[i][1]` will not exist in nums when applying the ith operation.\\nI overlooked this and solved using Map+LinkedList."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this... is a medium problem ? "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "yes\\n"
                    },
                    {
                        "username": "emg1930",
                        "content": "yeah I think this should be a easy one"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "How on earth should I use hashmap here ,find fn under linear fn is not passed ?"
                    },
                    {
                        "username": "MMeadow",
                        "content": "Why doesn\\'t my linear complexity pass?\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "Can someone explain what we have to do? I am unable to make out anything"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we have to replace the vector nums element if the operations[i][0] value if found with operations[i][1]"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bhai we know operation[i][0] definately exist in nums and we have to update nums value to operation[i][1] okay toh kuch esa socho ki ye task ho jaye "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "d=dict()\\n        c=0\\n        for i in nums:\\n            d[i]=c\\n            c+=1\\n        for i in operations:\\n            if i[0] in d:\\n                nums[d[i[0]]]=i[1]\\n                d[i[1]]=d[i[0]]\\n                del d[i[0]]\\n        return nums\\n"
                    },
                    {
                        "username": "MarioGranda",
                        "content": "Hello! Sure, you just have to pick each subarray from the array \"operations\" (this is of the form [number_1, number_2]) and transform  number_1 -> number_2 wherever there is a number_1 in the \"nums\" array. "
                    }
                ]
            },
            {
                "id": 1843010,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "Prompt doesn\\'t make any sense...  why when nums = [1,2] and operations = [[1,3],[2,1],[3,2]], the expected answer is [2,1] instead of [3,1]?  Am I the only one that thinks the problem is poorly explained"
                    },
                    {
                        "username": "leet_yeet",
                        "content": "[@mycoolhairison](/mycoolhairison) Why not continue down the path?\\nFourth operation turn [3,1] into [3,3] etc??"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "We are replacing elements of the array nums.  In the first operation we replace 1 with 3, after which nums = [3,2].  In the second operation we replace 2 with 1, after which nums = [3,1].  In the third operation we replace 3 with 2, after which nums = [2,1]."
                    },
                    {
                        "username": "space_invader",
                        "content": "HashMap ?"
                    },
                    {
                        "username": "ansh21006",
                        "content": "basically u have to updates the numbers\\n"
                    },
                    {
                        "username": "Grishound",
                        "content": "Yeah I did it using that."
                    },
                    {
                        "username": "saran19",
                        "content": "`operations[i][1]` will not exist in nums when applying the ith operation.\\nI overlooked this and solved using Map+LinkedList."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this... is a medium problem ? "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "yes\\n"
                    },
                    {
                        "username": "emg1930",
                        "content": "yeah I think this should be a easy one"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "How on earth should I use hashmap here ,find fn under linear fn is not passed ?"
                    },
                    {
                        "username": "MMeadow",
                        "content": "Why doesn\\'t my linear complexity pass?\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "Can someone explain what we have to do? I am unable to make out anything"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we have to replace the vector nums element if the operations[i][0] value if found with operations[i][1]"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bhai we know operation[i][0] definately exist in nums and we have to update nums value to operation[i][1] okay toh kuch esa socho ki ye task ho jaye "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "d=dict()\\n        c=0\\n        for i in nums:\\n            d[i]=c\\n            c+=1\\n        for i in operations:\\n            if i[0] in d:\\n                nums[d[i[0]]]=i[1]\\n                d[i[1]]=d[i[0]]\\n                del d[i[0]]\\n        return nums\\n"
                    },
                    {
                        "username": "MarioGranda",
                        "content": "Hello! Sure, you just have to pick each subarray from the array \"operations\" (this is of the form [number_1, number_2]) and transform  number_1 -> number_2 wherever there is a number_1 in the \"nums\" array. "
                    }
                ]
            },
            {
                "id": 1795334,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "Prompt doesn\\'t make any sense...  why when nums = [1,2] and operations = [[1,3],[2,1],[3,2]], the expected answer is [2,1] instead of [3,1]?  Am I the only one that thinks the problem is poorly explained"
                    },
                    {
                        "username": "leet_yeet",
                        "content": "[@mycoolhairison](/mycoolhairison) Why not continue down the path?\\nFourth operation turn [3,1] into [3,3] etc??"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "We are replacing elements of the array nums.  In the first operation we replace 1 with 3, after which nums = [3,2].  In the second operation we replace 2 with 1, after which nums = [3,1].  In the third operation we replace 3 with 2, after which nums = [2,1]."
                    },
                    {
                        "username": "space_invader",
                        "content": "HashMap ?"
                    },
                    {
                        "username": "ansh21006",
                        "content": "basically u have to updates the numbers\\n"
                    },
                    {
                        "username": "Grishound",
                        "content": "Yeah I did it using that."
                    },
                    {
                        "username": "saran19",
                        "content": "`operations[i][1]` will not exist in nums when applying the ith operation.\\nI overlooked this and solved using Map+LinkedList."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this... is a medium problem ? "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "yes\\n"
                    },
                    {
                        "username": "emg1930",
                        "content": "yeah I think this should be a easy one"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "How on earth should I use hashmap here ,find fn under linear fn is not passed ?"
                    },
                    {
                        "username": "MMeadow",
                        "content": "Why doesn\\'t my linear complexity pass?\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "Can someone explain what we have to do? I am unable to make out anything"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we have to replace the vector nums element if the operations[i][0] value if found with operations[i][1]"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bhai we know operation[i][0] definately exist in nums and we have to update nums value to operation[i][1] okay toh kuch esa socho ki ye task ho jaye "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "d=dict()\\n        c=0\\n        for i in nums:\\n            d[i]=c\\n            c+=1\\n        for i in operations:\\n            if i[0] in d:\\n                nums[d[i[0]]]=i[1]\\n                d[i[1]]=d[i[0]]\\n                del d[i[0]]\\n        return nums\\n"
                    },
                    {
                        "username": "MarioGranda",
                        "content": "Hello! Sure, you just have to pick each subarray from the array \"operations\" (this is of the form [number_1, number_2]) and transform  number_1 -> number_2 wherever there is a number_1 in the \"nums\" array. "
                    }
                ]
            },
            {
                "id": 1715228,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "Prompt doesn\\'t make any sense...  why when nums = [1,2] and operations = [[1,3],[2,1],[3,2]], the expected answer is [2,1] instead of [3,1]?  Am I the only one that thinks the problem is poorly explained"
                    },
                    {
                        "username": "leet_yeet",
                        "content": "[@mycoolhairison](/mycoolhairison) Why not continue down the path?\\nFourth operation turn [3,1] into [3,3] etc??"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "We are replacing elements of the array nums.  In the first operation we replace 1 with 3, after which nums = [3,2].  In the second operation we replace 2 with 1, after which nums = [3,1].  In the third operation we replace 3 with 2, after which nums = [2,1]."
                    },
                    {
                        "username": "space_invader",
                        "content": "HashMap ?"
                    },
                    {
                        "username": "ansh21006",
                        "content": "basically u have to updates the numbers\\n"
                    },
                    {
                        "username": "Grishound",
                        "content": "Yeah I did it using that."
                    },
                    {
                        "username": "saran19",
                        "content": "`operations[i][1]` will not exist in nums when applying the ith operation.\\nI overlooked this and solved using Map+LinkedList."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this... is a medium problem ? "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "yes\\n"
                    },
                    {
                        "username": "emg1930",
                        "content": "yeah I think this should be a easy one"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "How on earth should I use hashmap here ,find fn under linear fn is not passed ?"
                    },
                    {
                        "username": "MMeadow",
                        "content": "Why doesn\\'t my linear complexity pass?\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "Can someone explain what we have to do? I am unable to make out anything"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we have to replace the vector nums element if the operations[i][0] value if found with operations[i][1]"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bhai we know operation[i][0] definately exist in nums and we have to update nums value to operation[i][1] okay toh kuch esa socho ki ye task ho jaye "
                    },
                    {
                        "username": "Bhukya_Nikhil_25",
                        "content": "d=dict()\\n        c=0\\n        for i in nums:\\n            d[i]=c\\n            c+=1\\n        for i in operations:\\n            if i[0] in d:\\n                nums[d[i[0]]]=i[1]\\n                d[i[1]]=d[i[0]]\\n                del d[i[0]]\\n        return nums\\n"
                    },
                    {
                        "username": "MarioGranda",
                        "content": "Hello! Sure, you just have to pick each subarray from the array \"operations\" (this is of the form [number_1, number_2]) and transform  number_1 -> number_2 wherever there is a number_1 in the \"nums\" array. "
                    }
                ]
            }
        ]
    }
]