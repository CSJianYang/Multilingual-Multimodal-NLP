[
    {
        "title": "Largest Subarray Length K",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Biggest Window Between Visits",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1570318,
                "content": [
                    {
                        "username": "avibobby90",
                        "content": "\\nwith cte as(\\nselect user_id,\\ndatediff(dd,visit_date,convert(date,isnull(Lead(visit_date) over(partition by user_id order by visit_date),\\'2021-1-1\\'))) as diff\\nfrom uservisits)\\n\\nselect user_id,max(diff) as biggest_window\\nfrom cte\\ngroup by user_id\\norder by user_id\\n"
                    },
                    {
                        "username": "funnydman",
                        "content": "it passed without order by"
                    },
                    {
                        "username": "heygayu",
                        "content": "The Output and Expected is exactly the same when I run the below. \\n\\n\\nSELECT c.user_id, c.window AS \\'biggest_window\\'\\nFROM\\n(SELECT b.user_id, b.window, DENSE_RANK () OVER (PARTITION BY b.user_id ORDER BY b.window DESC) AS \\'rank\\'\\nFROM\\n(SELECT a.user_id, DATEDIFF(a.date_after, a.visit_date) as \\'window\\'\\nFROM\\n(SELECT u.user_id, u.visit_date, COALESCE (LEAD (u.visit_date) OVER (PARTITION BY u.user_id ORDER BY u.visit_date ASC), \\'2021-01-01\\') as \\'date_after\\'\\nFROM UserVisits AS u\\nORDER BY u.visit_date ASC) AS a) AS b) AS c\\nWHERE c.rank = 1\\n\\nHowever, it throws back a results as \\'Wrong Answer\\'"
                    },
                    {
                        "username": "aerlang0420",
                        "content": "WITH helper AS (\n        SELECT *, RANK() OVER(PARTITION BY user_id ORDER BY visit_date) AS rnk\n        FROM UserVisits),\n helper1 AS (\n        SELECT h1.user_id, DATEDIFF(IFNULL(h2.visit_date, '2021-1-1'), h1.visit_date) AS diff\n        FROM helper AS h1\n        LEFT JOIN helper AS h2\n        ON h1.user_id = h2.user_id AND h1.rnk = h2.rnk-1\n    )\n\nSELECT DISTINCT user_id, MAX(diff) AS biggest_window\nFROM helper1\nGROUP BY user_id;"
                    },
                    {
                        "username": "jessicachen1168",
                        "content": "---subsquery with window function\\n\\nselect user_id, max(date1) as biggest_window\\nfrom \\n(\\nselect *, datediff(ifnull(lead(visit_date,1)over(partition by user_id order by visit_date),\\'2021-1-1\\'),visit_date)as date1\\nfrom UserVisits\\n) temp\\ngroup by user_id;"
                    }
                ]
            },
            {
                "id": 1948953,
                "content": [
                    {
                        "username": "avibobby90",
                        "content": "\\nwith cte as(\\nselect user_id,\\ndatediff(dd,visit_date,convert(date,isnull(Lead(visit_date) over(partition by user_id order by visit_date),\\'2021-1-1\\'))) as diff\\nfrom uservisits)\\n\\nselect user_id,max(diff) as biggest_window\\nfrom cte\\ngroup by user_id\\norder by user_id\\n"
                    },
                    {
                        "username": "funnydman",
                        "content": "it passed without order by"
                    },
                    {
                        "username": "heygayu",
                        "content": "The Output and Expected is exactly the same when I run the below. \\n\\n\\nSELECT c.user_id, c.window AS \\'biggest_window\\'\\nFROM\\n(SELECT b.user_id, b.window, DENSE_RANK () OVER (PARTITION BY b.user_id ORDER BY b.window DESC) AS \\'rank\\'\\nFROM\\n(SELECT a.user_id, DATEDIFF(a.date_after, a.visit_date) as \\'window\\'\\nFROM\\n(SELECT u.user_id, u.visit_date, COALESCE (LEAD (u.visit_date) OVER (PARTITION BY u.user_id ORDER BY u.visit_date ASC), \\'2021-01-01\\') as \\'date_after\\'\\nFROM UserVisits AS u\\nORDER BY u.visit_date ASC) AS a) AS b) AS c\\nWHERE c.rank = 1\\n\\nHowever, it throws back a results as \\'Wrong Answer\\'"
                    },
                    {
                        "username": "aerlang0420",
                        "content": "WITH helper AS (\n        SELECT *, RANK() OVER(PARTITION BY user_id ORDER BY visit_date) AS rnk\n        FROM UserVisits),\n helper1 AS (\n        SELECT h1.user_id, DATEDIFF(IFNULL(h2.visit_date, '2021-1-1'), h1.visit_date) AS diff\n        FROM helper AS h1\n        LEFT JOIN helper AS h2\n        ON h1.user_id = h2.user_id AND h1.rnk = h2.rnk-1\n    )\n\nSELECT DISTINCT user_id, MAX(diff) AS biggest_window\nFROM helper1\nGROUP BY user_id;"
                    },
                    {
                        "username": "jessicachen1168",
                        "content": "---subsquery with window function\\n\\nselect user_id, max(date1) as biggest_window\\nfrom \\n(\\nselect *, datediff(ifnull(lead(visit_date,1)over(partition by user_id order by visit_date),\\'2021-1-1\\'),visit_date)as date1\\nfrom UserVisits\\n) temp\\ngroup by user_id;"
                    }
                ]
            },
            {
                "id": 1857253,
                "content": [
                    {
                        "username": "avibobby90",
                        "content": "\\nwith cte as(\\nselect user_id,\\ndatediff(dd,visit_date,convert(date,isnull(Lead(visit_date) over(partition by user_id order by visit_date),\\'2021-1-1\\'))) as diff\\nfrom uservisits)\\n\\nselect user_id,max(diff) as biggest_window\\nfrom cte\\ngroup by user_id\\norder by user_id\\n"
                    },
                    {
                        "username": "funnydman",
                        "content": "it passed without order by"
                    },
                    {
                        "username": "heygayu",
                        "content": "The Output and Expected is exactly the same when I run the below. \\n\\n\\nSELECT c.user_id, c.window AS \\'biggest_window\\'\\nFROM\\n(SELECT b.user_id, b.window, DENSE_RANK () OVER (PARTITION BY b.user_id ORDER BY b.window DESC) AS \\'rank\\'\\nFROM\\n(SELECT a.user_id, DATEDIFF(a.date_after, a.visit_date) as \\'window\\'\\nFROM\\n(SELECT u.user_id, u.visit_date, COALESCE (LEAD (u.visit_date) OVER (PARTITION BY u.user_id ORDER BY u.visit_date ASC), \\'2021-01-01\\') as \\'date_after\\'\\nFROM UserVisits AS u\\nORDER BY u.visit_date ASC) AS a) AS b) AS c\\nWHERE c.rank = 1\\n\\nHowever, it throws back a results as \\'Wrong Answer\\'"
                    },
                    {
                        "username": "aerlang0420",
                        "content": "WITH helper AS (\n        SELECT *, RANK() OVER(PARTITION BY user_id ORDER BY visit_date) AS rnk\n        FROM UserVisits),\n helper1 AS (\n        SELECT h1.user_id, DATEDIFF(IFNULL(h2.visit_date, '2021-1-1'), h1.visit_date) AS diff\n        FROM helper AS h1\n        LEFT JOIN helper AS h2\n        ON h1.user_id = h2.user_id AND h1.rnk = h2.rnk-1\n    )\n\nSELECT DISTINCT user_id, MAX(diff) AS biggest_window\nFROM helper1\nGROUP BY user_id;"
                    },
                    {
                        "username": "jessicachen1168",
                        "content": "---subsquery with window function\\n\\nselect user_id, max(date1) as biggest_window\\nfrom \\n(\\nselect *, datediff(ifnull(lead(visit_date,1)over(partition by user_id order by visit_date),\\'2021-1-1\\'),visit_date)as date1\\nfrom UserVisits\\n) temp\\ngroup by user_id;"
                    }
                ]
            },
            {
                "id": 1709040,
                "content": [
                    {
                        "username": "avibobby90",
                        "content": "\\nwith cte as(\\nselect user_id,\\ndatediff(dd,visit_date,convert(date,isnull(Lead(visit_date) over(partition by user_id order by visit_date),\\'2021-1-1\\'))) as diff\\nfrom uservisits)\\n\\nselect user_id,max(diff) as biggest_window\\nfrom cte\\ngroup by user_id\\norder by user_id\\n"
                    },
                    {
                        "username": "funnydman",
                        "content": "it passed without order by"
                    },
                    {
                        "username": "heygayu",
                        "content": "The Output and Expected is exactly the same when I run the below. \\n\\n\\nSELECT c.user_id, c.window AS \\'biggest_window\\'\\nFROM\\n(SELECT b.user_id, b.window, DENSE_RANK () OVER (PARTITION BY b.user_id ORDER BY b.window DESC) AS \\'rank\\'\\nFROM\\n(SELECT a.user_id, DATEDIFF(a.date_after, a.visit_date) as \\'window\\'\\nFROM\\n(SELECT u.user_id, u.visit_date, COALESCE (LEAD (u.visit_date) OVER (PARTITION BY u.user_id ORDER BY u.visit_date ASC), \\'2021-01-01\\') as \\'date_after\\'\\nFROM UserVisits AS u\\nORDER BY u.visit_date ASC) AS a) AS b) AS c\\nWHERE c.rank = 1\\n\\nHowever, it throws back a results as \\'Wrong Answer\\'"
                    },
                    {
                        "username": "aerlang0420",
                        "content": "WITH helper AS (\n        SELECT *, RANK() OVER(PARTITION BY user_id ORDER BY visit_date) AS rnk\n        FROM UserVisits),\n helper1 AS (\n        SELECT h1.user_id, DATEDIFF(IFNULL(h2.visit_date, '2021-1-1'), h1.visit_date) AS diff\n        FROM helper AS h1\n        LEFT JOIN helper AS h2\n        ON h1.user_id = h2.user_id AND h1.rnk = h2.rnk-1\n    )\n\nSELECT DISTINCT user_id, MAX(diff) AS biggest_window\nFROM helper1\nGROUP BY user_id;"
                    },
                    {
                        "username": "jessicachen1168",
                        "content": "---subsquery with window function\\n\\nselect user_id, max(date1) as biggest_window\\nfrom \\n(\\nselect *, datediff(ifnull(lead(visit_date,1)over(partition by user_id order by visit_date),\\'2021-1-1\\'),visit_date)as date1\\nfrom UserVisits\\n) temp\\ngroup by user_id;"
                    }
                ]
            },
            {
                "id": 1702486,
                "content": [
                    {
                        "username": "avibobby90",
                        "content": "\\nwith cte as(\\nselect user_id,\\ndatediff(dd,visit_date,convert(date,isnull(Lead(visit_date) over(partition by user_id order by visit_date),\\'2021-1-1\\'))) as diff\\nfrom uservisits)\\n\\nselect user_id,max(diff) as biggest_window\\nfrom cte\\ngroup by user_id\\norder by user_id\\n"
                    },
                    {
                        "username": "funnydman",
                        "content": "it passed without order by"
                    },
                    {
                        "username": "heygayu",
                        "content": "The Output and Expected is exactly the same when I run the below. \\n\\n\\nSELECT c.user_id, c.window AS \\'biggest_window\\'\\nFROM\\n(SELECT b.user_id, b.window, DENSE_RANK () OVER (PARTITION BY b.user_id ORDER BY b.window DESC) AS \\'rank\\'\\nFROM\\n(SELECT a.user_id, DATEDIFF(a.date_after, a.visit_date) as \\'window\\'\\nFROM\\n(SELECT u.user_id, u.visit_date, COALESCE (LEAD (u.visit_date) OVER (PARTITION BY u.user_id ORDER BY u.visit_date ASC), \\'2021-01-01\\') as \\'date_after\\'\\nFROM UserVisits AS u\\nORDER BY u.visit_date ASC) AS a) AS b) AS c\\nWHERE c.rank = 1\\n\\nHowever, it throws back a results as \\'Wrong Answer\\'"
                    },
                    {
                        "username": "aerlang0420",
                        "content": "WITH helper AS (\n        SELECT *, RANK() OVER(PARTITION BY user_id ORDER BY visit_date) AS rnk\n        FROM UserVisits),\n helper1 AS (\n        SELECT h1.user_id, DATEDIFF(IFNULL(h2.visit_date, '2021-1-1'), h1.visit_date) AS diff\n        FROM helper AS h1\n        LEFT JOIN helper AS h2\n        ON h1.user_id = h2.user_id AND h1.rnk = h2.rnk-1\n    )\n\nSELECT DISTINCT user_id, MAX(diff) AS biggest_window\nFROM helper1\nGROUP BY user_id;"
                    },
                    {
                        "username": "jessicachen1168",
                        "content": "---subsquery with window function\\n\\nselect user_id, max(date1) as biggest_window\\nfrom \\n(\\nselect *, datediff(ifnull(lead(visit_date,1)over(partition by user_id order by visit_date),\\'2021-1-1\\'),visit_date)as date1\\nfrom UserVisits\\n) temp\\ngroup by user_id;"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Units on a Truck",
        "question_content": "<p>You are assigned to put some amount of boxes onto <strong>one truck</strong>. You are given a 2D array <code>boxTypes</code>, where <code>boxTypes[i] = [numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub>]</code>:</p>\n\n<ul>\n\t<li><code>numberOfBoxes<sub>i</sub></code> is the number of boxes of type <code>i</code>.</li>\n\t<li><code>numberOfUnitsPerBox<sub>i</sub></code><sub> </sub>is the number of units in each box of the type <code>i</code>.</li>\n</ul>\n\n<p>You are also given an integer <code>truckSize</code>, which is the <strong>maximum</strong> number of <strong>boxes</strong> that can be put on the truck. You can choose any boxes to put on the truck as long as the number&nbsp;of boxes does not exceed <code>truckSize</code>.</p>\n\n<p>Return <em>the <strong>maximum</strong> total number of <strong>units</strong> that can be put on the truck.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\n<strong>Output:</strong> 91\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxTypes.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>1 &lt;= truckSize &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 999125,
                "title": "java-python-3-sort-by-the-units-then-apply-greedy-algorithm",
                "content": "<ins>**Method 1: Sort reversely**</ins>\\n\\n```java\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n     // Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]); // b[1] - a[1] may cause int overflow, credit to @Zudas.\\n        Arrays.sort(boxTypes, (a, b) -> Integer.compare(b[1], a[1]));\\n        int boxes = 0;\\n        for (int[] box : boxTypes) {\\n            if (truckSize >= box[0]) {\\n                boxes += box[0] * box[1];\\n                truckSize -= box[0];\\n            }else {\\n                boxes += truckSize * box[1];\\n                return boxes;\\n            }\\n        }\\n        return boxes;\\n    }\\n```\\n```python\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: -x[1])\\n        boxes = 0\\n        for box, units in boxTypes:\\n            if truckSize > box:\\n                truckSize -= box\\n                boxes += box * units\\n            else:\\n                boxes += truckSize * units\\n                return boxes\\n        return boxes\\n```\\n\\n**Analysis:**\\nTime: O(nlogn), space: ~~O(logn)  - java quicksort~~ O(n) - both java 7+ and Python 3 use timsort for this specific case.\\n\\n[Java 7 uses Dual-Pivot Quicksort for primitives and TimSort for objects.](https://stackoverflow.com/questions/4018332/is-java-7-using-tim-sort-for-the-method-arrays-sort) -- credit to **@deepdiver**.\\n\\n----\\n\\n<ins>**Method 2: Counting sort**</ins>\\n\\n```java\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        int[] count = new int[1001];\\n        for (int[] box : boxTypes) {\\n            count[box[1]] += box[0];\\n        }\\n        int boxes = 0;\\n        for (int units = 1000; units > 0; --units) {\\n            if (count[units] > 0) {\\n                int fitIn = Math.min(count[units], truckSize);\\n                boxes += units * fitIn;\\n                truckSize -= fitIn;\\n                if (truckSize == 0) {\\n                    return boxes;\\n                }\\n            }\\n        }\\n        return boxes;\\n    }\\n```\\n\\n```python\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxes, cur_units, cnt = 0, 1000, Counter()\\n        for box, units in boxTypes:\\n            cnt[units] += box\\n        while cur_units > 0:\\n            if cnt[cur_units] > 0:\\n                fit_in = min(truckSize, cnt[cur_units])    \\n                boxes += fit_in * cur_units\\n                truckSize -= fit_in\\n                if truckSize == 0:\\n                    return boxes\\n            cur_units -= 1\\n        return boxes\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = boxTypes.length`.\\n\\n----\\n\\n\\n# **Q & A**\\n\\n**Q1**: What does this param mean? `key=lambda x: -x[1]`\\n\\n**A1**: It is a small anonymous function, called lambda function, used to sort `boxTypes`. \\nSyntax is as follows:\\n```\\nlambda arguments : expression\\n```\\nAccordingly, `x`, variable representing any box type, is the only argument; `-x[1]` is the expression of the function.\\n\\nkey is from the individual items of `boxTypes`, `x`; And we sort them according to the value at index `1` of `x` (which is numberOfUnitsPerBox<sub>i</sub>) reversely (`-x[1]`).\\n\\n**Q2**:  Why greedy algorithm works with this problem and why we don\\'t need to use knapsack dp? how do we know when a problem is knapsack or when it is greedy?\\n\\n**A2**: In this problem, it says \"You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize.\" That means **we do NOT need to treat the boxes of same box type as inseparable. E.g., if necessary to get optimal solution, we can choose `1, 2, ..., or i` boxes from a certain type, when we put boxes onto the truck**. Therefore, we should put the type of boxes with the most units in order to achieve maximum units. \\n\\nIf the problem changes the rule to \"If you choose a box type, you must choose all of the boxes of this type\", it is same as the Knapsack problem and we have to use DP to solve it.\\n\\nIn Knapsack problem, different items have different weights and there is a total weight limit, and we **can NOT break items into \\n pieces to get optimal solution**. Therefore, there is no way to apply greedy algorithm. Of couse, if we are allowed to break the items into arbitrary units of weight, it is same as this truck problem and we can apply greedy algorithm.\\n\\nStrictly speaking, when using greedy algorithm to solve a problem, we need to justify its correctness by proving its: 1) **Greedy choice property** and 2)**optimal substructure property.** You can refer my proof in [881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/discuss/156855/) for reference.\\n\\nTypically, Knapsack problem often arises in resource allocation where the decision makers have to choose from a set of **non-divisible** objects, projects or tasks under a fixed budget or time constraint, respectively.\\n\\n**Q3**: `Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);` can anyone explain what this means?\\n\\n**@Zudas** provides the following excellent answer.\\n**A3**: This means we\\'re **sorting** our array `boxTypes` based on **descending** values of **column 1**(`0 indexed`).\\n\\n```text\\nLet boxTypes be\\n[[1,  4],\\n [22, 9],  \\n [13, 2],\\n [9,  1]]\\nThen After sorting\\n[[22, 9],\\n [1,  4]\\n [13, 2], \\n [9,  1]]\\n```\\nYou can **Google** more about `Comparators` or `2-D Array Sorting`.\\n**Note**: It\\'s always better to use `Integer.compare(b[1], a[1])` instead of `b[1] - a[1]` cause **latter** might `overflow`.\\n\\n**End of Q & A**",
                "solutionTags": [],
                "code": "```java\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n     // Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]); // b[1] - a[1] may cause int overflow, credit to @Zudas.\\n        Arrays.sort(boxTypes, (a, b) -> Integer.compare(b[1], a[1]));\\n        int boxes = 0;\\n        for (int[] box : boxTypes) {\\n            if (truckSize >= box[0]) {\\n                boxes += box[0] * box[1];\\n                truckSize -= box[0];\\n            }else {\\n                boxes += truckSize * box[1];\\n                return boxes;\\n            }\\n        }\\n        return boxes;\\n    }\\n```\n```python\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: -x[1])\\n        boxes = 0\\n        for box, units in boxTypes:\\n            if truckSize > box:\\n                truckSize -= box\\n                boxes += box * units\\n            else:\\n                boxes += truckSize * units\\n                return boxes\\n        return boxes\\n```\n```java\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        int[] count = new int[1001];\\n        for (int[] box : boxTypes) {\\n            count[box[1]] += box[0];\\n        }\\n        int boxes = 0;\\n        for (int units = 1000; units > 0; --units) {\\n            if (count[units] > 0) {\\n                int fitIn = Math.min(count[units], truckSize);\\n                boxes += units * fitIn;\\n                truckSize -= fitIn;\\n                if (truckSize == 0) {\\n                    return boxes;\\n                }\\n            }\\n        }\\n        return boxes;\\n    }\\n```\n```python\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxes, cur_units, cnt = 0, 1000, Counter()\\n        for box, units in boxTypes:\\n            cnt[units] += box\\n        while cur_units > 0:\\n            if cnt[cur_units] > 0:\\n                fit_in = min(truckSize, cnt[cur_units])    \\n                boxes += fit_in * cur_units\\n                truckSize -= fit_in\\n                if truckSize == 0:\\n                    return boxes\\n            cur_units -= 1\\n        return boxes\\n```\n```\\nlambda arguments : expression\\n```\n```text\\nLet boxTypes be\\n[[1,  4],\\n [22, 9],  \\n [13, 2],\\n [9,  1]]\\nThen After sorting\\n[[22, 9],\\n [1,  4]\\n [13, 2], \\n [9,  1]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1001160,
                "title": "c-greedy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool myfunction(vector<int>& a, vector<int>& b){\\n        return a[1] > b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\t    //custom sort (in increasing order of numberOfUnitsPerBox as we have to return  maximum total number of units )\\n        sort(boxTypes.begin(),boxTypes.end(),myfunction);\\n\\t\\t//greedily pick boxes till capacity is full\\n        int ans=0;\\n        for(auto box: boxTypes){\\n            int x=min(box[0],truckSize);  //choose minimum boxes from available boxes and capacity left\\n            ans+=(x*box[1]);  //adding units in ans\\n            truckSize-=x;  //reduce the capacity\\n            if(!truckSize) break;  //capacity full\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool myfunction(vector<int>& a, vector<int>& b){\\n        return a[1] > b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\t    //custom sort (in increasing order of numberOfUnitsPerBox as we have to return  maximum total number of units )\\n        sort(boxTypes.begin(),boxTypes.end(),myfunction);\\n\\t\\t//greedily pick boxes till capacity is full\\n        int ans=0;\\n        for(auto box: boxTypes){\\n            int x=min(box[0],truckSize);  //choose minimum boxes from available boxes and capacity left\\n            ans+=(x*box[1]);  //adding units in ans\\n            truckSize-=x;  //reduce the capacity\\n            if(!truckSize) break;  //capacity full\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000343,
                "title": "counting-bucket-sort-o-n-faster-than-100",
                "content": "**Intuition:**\\n\\nThe constraint that \"boxes per unit\" will be max 1000 allows us to use 1000 buckets to sort by boxes per unit.\\nIe.,  we can create an array where the indices represent 0 boxes per unit, 1 boxes per unit, 2 boxes per unit, 3 boxes per unit, ... 1000 boxes per unit. And the buckets[i] will represent the number of boxes at each index. \\n\\n**Algorithm:**\\n\\n1. take the given data and sort it into the 1000 buckets. this is O(n) because we loop over the given data once.\\n2. loop over the buckets backwards- so that we start at a higher boxes per unit to get as many units as possible. in each iteration:\\n\\t* \\tcheck if the current bucket has any values (isn\\'t -1). \\n\\t* \\tif the bucket has a value, check if the truck has space enough for all the boxes. if yes, load up all units.\\n\\t* \\tif the truck hasn\\'t enough space, load up only the units you can.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        vector<int> buckets(1001, -1);\\n        int space_remaining_boxes = truckSize;\\n        int units_loaded = 0;\\n        for (int i = 0; i < boxTypes.size(); ++i) {\\n            if (buckets[ boxTypes[i][1] ] == -1) {\\n                buckets[ boxTypes[i][1] ] = boxTypes[i][0];\\n            } else { // already has a value\\n                buckets[ boxTypes[i][1] ] += boxTypes[i][0];\\n            }\\n            \\n            // optimization idea: when populating, track the highest and lowest boxesperunit for use as indices below\\n        }\\n        \\n        for (int i = 1000; i >= 0; --i) {\\n            if (buckets[i] == -1) continue;\\n            \\n            if (buckets[i] > space_remaining_boxes) { // case:not enough space on truck. eg., we have 2 box but truck space 1.\\n                units_loaded += space_remaining_boxes*i;\\n                return units_loaded;\\n            } else {\\n                units_loaded += buckets[i]*i; // i is 10units/box. buckets[i] is 2 boxes. total units is 20.\\n                space_remaining_boxes -= buckets[i]; // space_remaining is in units of boxes.\\n            }\\n            \\n        }\\n        return units_loaded;\\n    }\\n};\\n```\\n\\nTime: O(n)\\nspace: O(1000). we create an array of 1000 buckets.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        vector<int> buckets(1001, -1);\\n        int space_remaining_boxes = truckSize;\\n        int units_loaded = 0;\\n        for (int i = 0; i < boxTypes.size(); ++i) {\\n            if (buckets[ boxTypes[i][1] ] == -1) {\\n                buckets[ boxTypes[i][1] ] = boxTypes[i][0];\\n            } else { // already has a value\\n                buckets[ boxTypes[i][1] ] += boxTypes[i][0];\\n            }\\n            \\n            // optimization idea: when populating, track the highest and lowest boxesperunit for use as indices below\\n        }\\n        \\n        for (int i = 1000; i >= 0; --i) {\\n            if (buckets[i] == -1) continue;\\n            \\n            if (buckets[i] > space_remaining_boxes) { // case:not enough space on truck. eg., we have 2 box but truck space 1.\\n                units_loaded += space_remaining_boxes*i;\\n                return units_loaded;\\n            } else {\\n                units_loaded += buckets[i]*i; // i is 10units/box. buckets[i] is 2 boxes. total units is 20.\\n                space_remaining_boxes -= buckets[i]; // space_remaining is in units of boxes.\\n            }\\n            \\n        }\\n        return units_loaded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272564,
                "title": "short-easy-solution-w-explanation-greedily-select-max-units-box-ratio",
                "content": "\\u2714\\uFE0F ***Solution (Sort & Choose Greedily)***\\n\\nWe can easiliy observe that it will **always be better to choose the box with maximum number of units** in it so that the overall number of units that can be put on truck is maximized.\\n\\nThus, we will sort the given *`boxTypes`* array based on number of units in each box. Then we greedily keep choosing the boxes starting from the first one from the sorted array till we fill the whole truck.\\n\\n**C++**\\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tsort(begin(boxTypes), end(boxTypes), [](auto& a, auto& b){ return a[1] > b[1];}); // sort by number of units / box\\n\\tint maxUnits = 0;\\n\\tfor(auto& box : boxTypes) {\\n\\t\\tif(truckSize <= 0) break;                    // keep choosing greedily till you run out of truckSize \\n\\t\\tmaxUnits += min(truckSize, box[0]) * box[1]; // add (no of box * units) in that box\\n\\t\\ttruckSize -= box[0];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\tboxTypes.sort(key=lambda a:-a[1])\\n\\tmax_units = 0\\n\\tfor box in boxTypes:\\n\\t\\tif truckSize < 0 : break\\n\\t\\tmax_units += min(truckSize, box[0]) * box[1]\\n\\t\\ttruckSize -= box[0]\\n\\treturn max_units\\n```\\n\\n***Time Complexity :*** **`O(NlogN)`**, where *`N`* is the number of elements in *`boxTypes`*\\n***Space Complexity :*** **`O(1)`**, we are always using constant amount of space (ignoring the space required by the sort algorithm)\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Similar to Counting sort)***\\n\\nThe given constraints for `numberOfUnitsPerBox` are small enough that we can use an approach similar to counting sort to reduce the time complexity to `O(N)`.\\n\\nHere, we can declare an array *`freq`* of size=1000 (which is maximum number of units per box) where *`freq[i]`* will denote the number of boxes that can hold *`i`* number of units. We can iterate through the given *`boxTypes`* array and populate the `freq` array. Then we can iterate over the `freq` array and greedily choose starting from `i=1000 ` till we run out of *`truckSize`* or pick all available boxes.\\n\\n**C++**\\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tint freq[1001]{0}, maxUnits = 0;   // freq[i] = number of boxes that can hold i units\\n\\tfor(auto& box : boxTypes) freq[box[1]] += box[0];\\n\\t// greedily choose starting from max units till either truckSize runs out or you choose all boxes\\n\\tfor(int units = 1000; truckSize > 0 && ~units; --units) { \\n\\t\\tmaxUnits += min(truckSize, freq[units]) * units;\\n\\t\\ttruckSize -= freq[units];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n    freq, max_units = [0]*1001, 0\\n    for box in boxTypes:\\n        freq[box[1]] += box[0]\\n    for units in range(1000,0,-1):\\n        if truckSize < 0: break\\n        max_units += min(truckSize, freq[units]) * units\\n        truckSize -= freq[units]\\n    return max_units\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tsort(begin(boxTypes), end(boxTypes), [](auto& a, auto& b){ return a[1] > b[1];}); // sort by number of units / box\\n\\tint maxUnits = 0;\\n\\tfor(auto& box : boxTypes) {\\n\\t\\tif(truckSize <= 0) break;                    // keep choosing greedily till you run out of truckSize \\n\\t\\tmaxUnits += min(truckSize, box[0]) * box[1]; // add (no of box * units) in that box\\n\\t\\ttruckSize -= box[0];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\tboxTypes.sort(key=lambda a:-a[1])\\n\\tmax_units = 0\\n\\tfor box in boxTypes:\\n\\t\\tif truckSize < 0 : break\\n\\t\\tmax_units += min(truckSize, box[0]) * box[1]\\n\\t\\ttruckSize -= box[0]\\n\\treturn max_units\\n```\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tint freq[1001]{0}, maxUnits = 0;   // freq[i] = number of boxes that can hold i units\\n\\tfor(auto& box : boxTypes) freq[box[1]] += box[0];\\n\\t// greedily choose starting from max units till either truckSize runs out or you choose all boxes\\n\\tfor(int units = 1000; truckSize > 0 && ~units; --units) { \\n\\t\\tmaxUnits += min(truckSize, freq[units]) * units;\\n\\t\\ttruckSize -= freq[units];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n    freq, max_units = [0]*1001, 0\\n    for box in boxTypes:\\n        freq[box[1]] += box[0]\\n    for units in range(1000,0,-1):\\n        if truckSize < 0: break\\n        max_units += min(truckSize, freq[units]) * units\\n        truckSize -= freq[units]\\n    return max_units\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2221148,
                "title": "why-not-dp-let-s-make-it-clear",
                "content": "**First thought**\\n\\nIf someone would have solved dp questions earlier, then the first things that comes to mind after looking at the question structure is to apply dp.\\nIt seems similar to **fractional-knapsack** as well as **0-1 knapsack**.\\n\\nThanks to [@priyavratuniyal09](https://leetcode.com/priyavratuniyal09/) and [@Gaurav_Kungwani_](https://leetcode.com/Gaurav_Kungwani_/) for pointing it out!\\n\\n**Why dp is unncessary here?**\\n\\nThis is simply because, when you apply dp, then there is **different cost** associated on the choice of each type of element.\\nBut, here no matter what you can pick any element and the cost you have to pay for that is **only 1**. That is upon picking 1 box, the truckSize reduces by 1 only.\\n\\nIt is not like, on picking a box will cost you 5 spaces(big size) in truck, while other will cost only 1 space(small size).\\n\\n**Approach**\\n\\nSo, apply greedy instead after sorting it in descending order to maximize the chances of the units you gain.\\n\\nI hope I have made all your doubts clear. If there is any further query, do not shy to comment!\\n\\nPlease consider **upvoting** if you like to see more posts like this.\\n\\nThanks everyone.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int ans = 0;\\n        \\n        sort(begin(boxTypes), end(boxTypes), [&](const vector<int>& v1, const vector<int>& v2){return v1[1] > v2[1];});\\n            \\n        for(auto box: boxTypes)\\n            ans += min(truckSize, box[0]) * box[1], truckSize -= min(truckSize, box[0]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int ans = 0;\\n        \\n        sort(begin(boxTypes), end(boxTypes), [&](const vector<int>& v1, const vector<int>& v2){return v1[1] > v2[1];});\\n            \\n        for(auto box: boxTypes)\\n            ans += min(truckSize, box[0]) * box[1], truckSize -= min(truckSize, box[0]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271374,
                "title": "js-python-java-c-simple-sort-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we simply need to prioritize the more valuable boxes first. To do this, we should **sort** the boxtypes array (**B**) in descending order by the number of units per box (**B[i][1]**).\\n\\nThen we can iterate through **B** and at each step, we should add as many of the **boxes** as we can, until we reach the truck size (**T**). We should add the number of **boxes** added multiplied by the units per box to our answer (**ans**), and decrease **T** by the same number of **boxes**.\\n\\nOnce the truck is full (**T == 0**), or once the iteration is done, we should **return ans**.\\n\\n - _**Time Complexity: O(N log N)** where **N** is the length of **B**, for the sort_\\n - _**Space Complexity: O(1)** to **O(N)** depending on the sort algorithm used_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar maximumUnits = function(B, T) {\\n    B.sort((a,b) => b[1] - a[1])\\n    let ans = 0\\n    for (let i = 0; T && i < B.length; i++) {\\n        let count = Math.min(B[i][0], T)\\n        ans += count * B[i][1], T -= count\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def maximumUnits(self, B: List[List[int]], T: int) -> int:\\n        B.sort(key=lambda x: x[1], reverse=True)\\n        ans = 0\\n        for b,n in B:\\n            boxes = min(b, T)\\n            ans += boxes * n\\n            T -= boxes\\n            if T == 0: return ans\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int maximumUnits(int[][] B, int T) {\\n        Arrays.sort(B, (a,b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for (int[] b : B) {\\n            int count = Math.min(b[0], T);\\n            ans += count * b[1];\\n            T -= count;\\n\\t\\t\\tif (T == 0) return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& B, int T) {\\n        sort(B.begin(), B.end(), [](auto& a, auto& b) { return b[1] < a[1];});\\n        int ans = 0;\\n        for (auto& b : B) {\\n            int count = min(b[0], T);\\n            ans += count * b[1], T -= count;\\n\\t\\t\\tif (!T) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maximumUnits = function(B, T) {\\n    B.sort((a,b) => b[1] - a[1])\\n    let ans = 0\\n    for (let i = 0; T && i < B.length; i++) {\\n        let count = Math.min(B[i][0], T)\\n        ans += count * B[i][1], T -= count\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def maximumUnits(self, B: List[List[int]], T: int) -> int:\\n        B.sort(key=lambda x: x[1], reverse=True)\\n        ans = 0\\n        for b,n in B:\\n            boxes = min(b, T)\\n            ans += boxes * n\\n            T -= boxes\\n            if T == 0: return ans\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int maximumUnits(int[][] B, int T) {\\n        Arrays.sort(B, (a,b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for (int[] b : B) {\\n            int count = Math.min(b[0], T);\\n            ans += count * b[1];\\n            T -= count;\\n\\t\\t\\tif (T == 0) return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& B, int T) {\\n        sort(B.begin(), B.end(), [](auto& a, auto& b) { return b[1] < a[1];});\\n        int ans = 0;\\n        for (auto& b : B) {\\n            int count = min(b[0], T);\\n            ans += count * b[1], T -= count;\\n\\t\\t\\tif (!T) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220452,
                "title": "python-c-simple-and-intuitive-greedy-explanation",
                "content": "Be sure to upvote if you thought this solution was helpful!\\n\\nJoin our discord to ask questions and be part of an interview prep community!\\n**https://discord.gg/m9MRe9ZR**\\n\\n**Intuition**\\nEach box takes the same amount of space on the truck. To maximize the total units on the truck, we want to prioritize boxes with more units in them. Let\\'s put the boxes with the most units first. This suggests a greedy solution.\\n\\n**Implementation**\\n1. Sort `boxTypes` so that boxes with the most units appear first.\\n2. Iterate through the boxes in sorted order.\\n3. Instead of counting down one by one how many boxes to take, we can calculate how many boxes of the current type to take by taking `min(truckSize, numberOfBoxes)`.  This is because the truck can fit at most `truckSize` more boxes, but we have `numberOfBoxes` left.\\n4. Decrease the remaining `truckSize` by subtracting the number of boxes we included.\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        # Sort boxes so that boxes with the most units appear first\\n        boxTypes.sort(key=lambda box: box[1], reverse=True)\\n        \\n        totalUnits = 0\\n        for numberOfBoxes, unitsPerBox in boxTypes:\\n            # Take as many boxes until we\\'re out of space on the truck\\n            # or we\\'re out of boxes of this type\\n            numBoxes = min(truckSize, numberOfBoxes)\\n            totalUnits += numBoxes * unitsPerBox\\n            truckSize -= numBoxes\\n        return totalUnits\\n            \\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        // Sort boxes so that boxes with the most units appear first\\n        sort(boxTypes.begin(), boxTypes.end(), [](auto& box1, auto& box2) {\\n            return box1[1] > box2[1];\\n        });\\n        \\n        int totalUnits = 0;\\n        for (auto& box : boxTypes) {\\n            // Take as many boxes until we\\'re out of space on the truck\\n            // or we\\'re out of boxes of this type\\n            int numBoxes = min(truckSize, box[0]);\\n            totalUnits += numBoxes * box[1];\\n            truckSize -= numBoxes;\\n        }\\n        return totalUnits;\\n    }\\n};\\n```\\n\\n**Time Complexity**: O(nlogn) - Sorting takes O(nlogn). Iterating through the array takes O(n). The time complexity is dominated by sorting.\\n**Space Complexity**: O(1) - No extra space used besides variables.\\n**Note**: In some implementations of sort (e.g. Python\\'s builtin sort), O(n) space is used during the sort.\\n\\nThere is an alternative solution to this problem using heap. Join our discord to discuss how to ideas for the heap solution!\\n**https://discord.gg/m9MRe9ZR**",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        # Sort boxes so that boxes with the most units appear first\\n        boxTypes.sort(key=lambda box: box[1], reverse=True)\\n        \\n        totalUnits = 0\\n        for numberOfBoxes, unitsPerBox in boxTypes:\\n            # Take as many boxes until we\\'re out of space on the truck\\n            # or we\\'re out of boxes of this type\\n            numBoxes = min(truckSize, numberOfBoxes)\\n            totalUnits += numBoxes * unitsPerBox\\n            truckSize -= numBoxes\\n        return totalUnits\\n            \\n```\n```c++\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        // Sort boxes so that boxes with the most units appear first\\n        sort(boxTypes.begin(), boxTypes.end(), [](auto& box1, auto& box2) {\\n            return box1[1] > box2[1];\\n        });\\n        \\n        int totalUnits = 0;\\n        for (auto& box : boxTypes) {\\n            // Take as many boxes until we\\'re out of space on the truck\\n            // or we\\'re out of boxes of this type\\n            int numBoxes = min(truckSize, box[0]);\\n            totalUnits += numBoxes * box[1];\\n            truckSize -= numBoxes;\\n        }\\n        return totalUnits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220494,
                "title": "c-brut-force-to-optimal-faste-then-100-00",
                "content": "**Brut-force:-**\\nWe will then proceed to sort  and then loop through each element el of boxes (taken as a reference, of course):\\n\\n* compute currBatch as the minimum between the current truckSize and el[0] (how many boxes of that size are available);\\n* decrease truckSize accordingly, to reflect loading this batch;\\n* increase res by currBatch multiplied el[1] (how many units are inside each box of this type);\\n* if truckSize is now 0, no point in continuing and we can break;\\n* Once done, we can return res :)\\n\\n**The code:**\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, currBatch;\\n        // sorting boxes by decreasing capacity\\n        sort(begin(boxes), end(boxes), [](auto &a, auto &b){return a[1] > b[1];});\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (auto &el: boxes) {\\n            currBatch = min(el[0], truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * el[1];\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**If you think this post is useful, I\\'m happy if you give a vote. Any questions or discussions are welcome! Thank a lot. Balence the number of view and upvote\\uD83D\\uDE01**\\n\\n\\n**Optimal Solutions :-**\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, sizeBucket[1001] = {}, maxBucket = INT_MIN, minBucket = INT_MAX;\\n        // bucket sorting tthe boxes and recording the bucket range\\n        for (auto &boxType: boxes) {\\n            maxBucket = max(maxBucket, boxType[1]);\\n            minBucket = min(minBucket, boxType[1]);\\n            sizeBucket[boxType[1]] += boxType[0];\\n        }\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (int i = maxBucket, size, currBatch; i >= minBucket; i--) {\\n            size = sizeBucket[i];\\n            if (!size) continue;\\n            currBatch = min(size, truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * i;\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**If you think this post is useful, I\\'m happy if you give a vote. Any questions or discussions are welcome! Thank a lot. Balence the number of view and upvote\\uD83D\\uDE01**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, currBatch;\\n        // sorting boxes by decreasing capacity\\n        sort(begin(boxes), end(boxes), [](auto &a, auto &b){return a[1] > b[1];});\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (auto &el: boxes) {\\n            currBatch = min(el[0], truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * el[1];\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, sizeBucket[1001] = {}, maxBucket = INT_MIN, minBucket = INT_MAX;\\n        // bucket sorting tthe boxes and recording the bucket range\\n        for (auto &boxType: boxes) {\\n            maxBucket = max(maxBucket, boxType[1]);\\n            minBucket = min(minBucket, boxType[1]);\\n            sizeBucket[boxType[1]] += boxType[0];\\n        }\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (int i = maxBucket, size, currBatch; i >= minBucket; i--) {\\n            size = sizeBucket[i];\\n            if (!size) continue;\\n            currBatch = min(size, truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * i;\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999230,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x:x[1],reverse=1)\\n        s=0\\n        for i,j in boxTypes:\\n            i=min(i,truckSize)\\n            s+=i*j\\n            truckSize-=i\\n            if truckSize==0:\\n                break\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x:x[1],reverse=1)\\n        s=0\\n        for i,j in boxTypes:\\n            i=min(i,truckSize)\\n            s+=i*j\\n            truckSize-=i\\n            if truckSize==0:\\n                break\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220566,
                "title": "java-simple-greedy-approach-sorting",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t\\t\\tArrays.sort(boxTypes, Comparator.comparingInt(o -> -o[1]));\\n\\t\\t\\tint ans = 0, i = 0, n = boxTypes.length;\\n\\t\\t\\twhile (i < n && truckSize > 0) {\\n\\t\\t\\t\\tint maxi = Math.min(boxTypes[i][0], truckSize);\\n\\t\\t\\t\\tans += maxi * boxTypes[i][1];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\ttruckSize -= maxi;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t\\t\\tArrays.sort(boxTypes, Comparator.comparingInt(o -> -o[1]));\\n\\t\\t\\tint ans = 0, i = 0, n = boxTypes.length;\\n\\t\\t\\twhile (i < n && truckSize > 0) {\\n\\t\\t\\t\\tint maxi = Math.min(boxTypes[i][0], truckSize);\\n\\t\\t\\t\\tans += maxi * boxTypes[i][1];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\ttruckSize -= maxi;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2220692,
                "title": "c-explaination-beats-100-greedy-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\nThe logic behind it:\\n**Idea**: Put the boxes with higher **numberOfUnit**\\n\\n**Solution:**\\nLet, **boxTypes = [[5,10],[2,5],[4,7],[3,9]]** & **truckSize = 10**.\\n\\nSort it in descending order according to the unit. So, it will be **[[5,10], [3, 9], [4,7], [2, 5]]**\\nNow, take the boxes serially until the truck is full.\\n**5 boxes** from the first boxType, so units = **5 * 10 = 50**\\n**3 boxes** from the 2nd boxType, so units = **3 * 9 = 27**\\n**2 boxes** from the 3rd boxType, so units = **2 * 7 = 14**\\n\\nSo maximum total number of units = 50 + 27 + 14 = **91**\\nCredits for example: @abdulhalimchy\\n\\n**Time complexity: `O(nlogn)`**\\n**Space complexity: `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    // comparator function to sort in vector w.r.t no. of units per boxes in descending order\\n    static bool compare(vector<int> v1, vector<int> v2)\\n    {\\n        return v1[1]>v2[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        \\n        int totalUnits = 0, i = 0;\\n        // sort the vector in descending order w.r.t no. of units per boxes \\n        sort(boxTypes.begin(), boxTypes.end(), compare);\\n        \\n        // Make sure truckSize > 0 && pointer should not exceed boxTypes.size()\\n        while (truckSize>0 && i<boxTypes.size()){\\n            \\n            // if current boxes is <= truckSize, that means we can take the entire current box\\n            if(boxTypes[i][0] <= truckSize){\\n                totalUnits += boxTypes[i][0] * boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            \\n            // if current boxes is > truckSize, we can only take a fraction from the current boxes\\n            else{\\n                \\n                int canTakeBoxes = truckSize;\\n                truckSize -= canTakeBoxes; // here truckSize = 0 \\n                totalUnits += canTakeBoxes * boxTypes[i][1]; \\n            }\\n            \\n            // iterate the loop\\n            i++;\\n        }\\n    \\n        return totalUnits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // comparator function to sort in vector w.r.t no. of units per boxes in descending order\\n    static bool compare(vector<int> v1, vector<int> v2)\\n    {\\n        return v1[1]>v2[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        \\n        int totalUnits = 0, i = 0;\\n        // sort the vector in descending order w.r.t no. of units per boxes \\n        sort(boxTypes.begin(), boxTypes.end(), compare);\\n        \\n        // Make sure truckSize > 0 && pointer should not exceed boxTypes.size()\\n        while (truckSize>0 && i<boxTypes.size()){\\n            \\n            // if current boxes is <= truckSize, that means we can take the entire current box\\n            if(boxTypes[i][0] <= truckSize){\\n                totalUnits += boxTypes[i][0] * boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            \\n            // if current boxes is > truckSize, we can only take a fraction from the current boxes\\n            else{\\n                \\n                int canTakeBoxes = truckSize;\\n                truckSize -= canTakeBoxes; // here truckSize = 0 \\n                totalUnits += canTakeBoxes * boxTypes[i][1]; \\n            }\\n            \\n            // iterate the loop\\n            i++;\\n        }\\n    \\n        return totalUnits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271352,
                "title": "maximum-units-on-a-truck-short-easy-w-explanation-greedy-select-by-max-units-box",
                "content": "\\u2714\\uFE0F ***Solution (Sort & Choose Greedily)***\\n\\nWe can easiliy observe that it will **always be better to choose the box with maximum number of units** in it so that the overall number of units that can be put on truck is maximized.\\n\\nThus, we will sort the given *`boxTypes`* array based on number of units in each box. Then we greedily keep choosing the boxes starting from the first one from the sorted array till we fill the whole truck.\\n\\n**C++**\\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tsort(begin(boxTypes), end(boxTypes), [](auto& a, auto& b){ return a[1] > b[1];}); // sort by number of units / box\\n\\tint maxUnits = 0;\\n\\tfor(auto& box : boxTypes) {\\n\\t\\tif(truckSize <= 0) break;                    // keep choosing greedily till you run out of truckSize \\n\\t\\tmaxUnits += min(truckSize, box[0]) * box[1]; // add (no of box * units) in that box\\n\\t\\ttruckSize -= box[0];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\tboxTypes.sort(key=lambda a:-a[1])\\n\\tmax_units = 0\\n\\tfor box in boxTypes:\\n\\t\\tif truckSize < 0 : break\\n\\t\\tmax_units += min(truckSize, box[0]) * box[1]\\n\\t\\ttruckSize -= box[0]\\n\\treturn max_units\\n```\\n\\n***Time Complexity :*** **`O(NlogN)`**, where *`N`* is the number of elements in *`boxTypes`*\\n***Space Complexity :*** **`O(1)`**, we are always using constant amount of space (ignoring the space required by the sort algorithm)\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Similar to Counting sort)***\\n\\nThe given constraints for `numberOfUnitsPerBox` are small enough that we can use an approach similar to counting sort to reduce the time complexity to `O(N)`.\\n\\nHere, we can declare an array *`freq`* of size=1000 (which is maximum number of units per box) where *`freq[i]`* will denote the number of boxes that can hold *`i`* number of units. We can iterate through the given *`boxTypes`* array and populate the `freq` array. Then we can iterate over the `freq` array and greedily choose starting from `i=1000 ` till we run out of *`truckSize`* or pick all available boxes.\\n\\n**C++**\\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tint freq[1001]{0}, maxUnits = 0;   // freq[i] = number of boxes that can hold i units\\n\\tfor(auto& box : boxTypes) freq[box[1]] += box[0];\\n\\t// greedily choose starting from max units till either truckSize runs out or you choose all boxes\\n\\tfor(int units = 1000; truckSize > 0 && ~units; --units) { \\n\\t\\tmaxUnits += min(truckSize, freq[units]) * units;\\n\\t\\ttruckSize -= freq[units];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n    freq, max_units = [0]*1001, 0\\n    for box in boxTypes:\\n        freq[box[1]] += box[0]\\n    for units in range(1000,0,-1):\\n        if truckSize < 0: break\\n        max_units += min(truckSize, freq[units]) * units\\n        truckSize -= freq[units]\\n    return max_units\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tsort(begin(boxTypes), end(boxTypes), [](auto& a, auto& b){ return a[1] > b[1];}); // sort by number of units / box\\n\\tint maxUnits = 0;\\n\\tfor(auto& box : boxTypes) {\\n\\t\\tif(truckSize <= 0) break;                    // keep choosing greedily till you run out of truckSize \\n\\t\\tmaxUnits += min(truckSize, box[0]) * box[1]; // add (no of box * units) in that box\\n\\t\\ttruckSize -= box[0];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\tboxTypes.sort(key=lambda a:-a[1])\\n\\tmax_units = 0\\n\\tfor box in boxTypes:\\n\\t\\tif truckSize < 0 : break\\n\\t\\tmax_units += min(truckSize, box[0]) * box[1]\\n\\t\\ttruckSize -= box[0]\\n\\treturn max_units\\n```\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tint freq[1001]{0}, maxUnits = 0;   // freq[i] = number of boxes that can hold i units\\n\\tfor(auto& box : boxTypes) freq[box[1]] += box[0];\\n\\t// greedily choose starting from max units till either truckSize runs out or you choose all boxes\\n\\tfor(int units = 1000; truckSize > 0 && ~units; --units) { \\n\\t\\tmaxUnits += min(truckSize, freq[units]) * units;\\n\\t\\ttruckSize -= freq[units];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n    freq, max_units = [0]*1001, 0\\n    for box in boxTypes:\\n        freq[box[1]] += box[0]\\n    for units in range(1000,0,-1):\\n        if truckSize < 0: break\\n        max_units += min(truckSize, freq[units]) * units\\n        truckSize -= freq[units]\\n    return max_units\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1086950,
                "title": "java-100-faster-1ms-time-o-n",
                "content": "Key concept: instead of sorting (takes O(N*LogN) time) `boxTypes` by number of units in descending order,\\n**use task constraint** `1 <= numberOfUnitsPerBoxi <= 1000` and create buckets with the number of boxes, where index of bucket will be unit count.\\n\\n```\\nclass Solution \\n{\\n    public int maximumUnits(int[][] boxTypes, int truckSize) \\n    {\\n        int [] unitCount = new int[1001];\\n        \\n        for (int [] boxType : boxTypes)\\n        {\\n            unitCount[boxType[1]] += boxType[0];\\n        }\\n        \\n        int count = 0;\\n        \\n        for (int i = unitCount.length-1; i >= 0; i--)\\n        {\\n            if (unitCount[i] == 0) continue;\\n            \\n            int num = Math.min(unitCount[i], truckSize);\\n            count += num * i;\\n            truckSize -= num;\\n            if (truckSize == 0) break;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximumUnits(int[][] boxTypes, int truckSize) \\n    {\\n        int [] unitCount = new int[1001];\\n        \\n        for (int [] boxType : boxTypes)\\n        {\\n            unitCount[boxType[1]] += boxType[0];\\n        }\\n        \\n        int count = 0;\\n        \\n        for (int i = unitCount.length-1; i >= 0; i--)\\n        {\\n            if (unitCount[i] == 0) continue;\\n            \\n            int num = Math.min(unitCount[i], truckSize);\\n            count += num * i;\\n            truckSize -= num;\\n            if (truckSize == 0) break;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271933,
                "title": "c-16ms-fastest-to-date-simple-vs-bucket-sort-solutions-explained-100-time-95-space",
                "content": "Easy problem, that you can solve just sorting all the available `boxes` by decreasing order of capacity, in order to get the most convenient boxes first.\\n\\nTo do so, we will declare a few support variables:\\n* `res` will store how much we can actually fit in our truck;\\n* `currBatch` will be used later to store the size of the current batch.\\n\\nWe will then proceed to sort as explained 2 paragraph above and then loop through each element `el` of `boxes` (taken as a reference, of course):\\n* compute `currBatch` as the minimum between the current `truckSize` and `el[0]` (how many boxes of that size are available);\\n* decrease `truckSize` accordingly, to reflect loading this batch;\\n* increase `res` by `currBatch` multiplied `el[1]` (how many units are inside each box of this type);\\n* if `truckSize` is now `0`, no point in continuing and we can `break`;\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, currBatch;\\n        // sorting boxes by decreasing capacity\\n        sort(begin(boxes), end(boxes), [](auto &a, auto &b){return a[1] > b[1];});\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (auto &el: boxes) {\\n            currBatch = min(el[0], truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * el[1];\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, wait a moment: a relatively small range and data type, so we know a better way of sorting - doing so in linear time instead of linearithmic, courtesy of the bucket sorting magic (and some extra space to use).\\n\\nThis time we will store info into `sizeBucket`, an array of `1001` elements (to cover all the provided range) all set to `0` and that we will populate while also storing the extremes of said range in `minBucket` and `maxBucket`, increasing each bucket of size `boxType[1]` by `boxType[0]` (how many we have) as we go. Be sure to add, not to assign here, since we do not know if we would be given multiple entries of the same size.\\n\\nOnce done, we can loop through the boxes we bucket-sorted going from `maxBucket` to `minBucket` (included) and following a logic specular to the previous one.\\n\\nThis bucket sorting version, which despite using buckets, turns out to be even more efficient in terms of space too:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, sizeBucket[1001] = {}, maxBucket = INT_MIN, minBucket = INT_MAX;\\n        // bucket sorting tthe boxes and recording the bucket range\\n        for (auto &boxType: boxes) {\\n            maxBucket = max(maxBucket, boxType[1]);\\n            minBucket = min(minBucket, boxType[1]);\\n            sizeBucket[boxType[1]] += boxType[0];\\n        }\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (int i = maxBucket, size, currBatch; i >= minBucket; i--) {\\n            size = sizeBucket[i];\\n            if (!size) continue;\\n            currBatch = min(size, truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * i;\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n\\n![image](https://assets.leetcode.com/users/images/1eebc018-fba8-434e-b021-342567e00f0f_1623673124.6360505.png)\\n\\nFinally, I wanted to try if storing each available `size` of a bucket in a set would help (think of some edge cases in which you would get very sparse ranges of sizes), but it boils down to another nlgn approach, so not too performing and just marginally better than the first:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, sizeBucket[1001] = {}, currBatch;\\n        set<int, greater<int>> bucketSizes;\\n        // bucket sorting tthe boxes and recording the bucket range\\n        for (auto &boxType: boxes) {\\n            bucketSizes.insert(boxType[1]);\\n            sizeBucket[boxType[1]] += boxType[0];\\n        }\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (int size: bucketSizes) {\\n            currBatch = min(sizeBucket[size], truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * size;\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, currBatch;\\n        // sorting boxes by decreasing capacity\\n        sort(begin(boxes), end(boxes), [](auto &a, auto &b){return a[1] > b[1];});\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (auto &el: boxes) {\\n            currBatch = min(el[0], truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * el[1];\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, sizeBucket[1001] = {}, maxBucket = INT_MIN, minBucket = INT_MAX;\\n        // bucket sorting tthe boxes and recording the bucket range\\n        for (auto &boxType: boxes) {\\n            maxBucket = max(maxBucket, boxType[1]);\\n            minBucket = min(minBucket, boxType[1]);\\n            sizeBucket[boxType[1]] += boxType[0];\\n        }\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (int i = maxBucket, size, currBatch; i >= minBucket; i--) {\\n            size = sizeBucket[i];\\n            if (!size) continue;\\n            currBatch = min(size, truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * i;\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxes, int truckSize) {\\n        // support variables\\n        int res = 0, sizeBucket[1001] = {}, currBatch;\\n        set<int, greater<int>> bucketSizes;\\n        // bucket sorting tthe boxes and recording the bucket range\\n        for (auto &boxType: boxes) {\\n            bucketSizes.insert(boxType[1]);\\n            sizeBucket[boxType[1]] += boxType[0];\\n        }\\n\\t\\t// carrying as many larger sized boxes as we can first\\n        for (int size: bucketSizes) {\\n            currBatch = min(sizeBucket[size], truckSize);\\n            truckSize -= currBatch;\\n            res += currBatch * size;\\n            if (!truckSize) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271377,
                "title": "maximum-units-on-a-truck-js-python-java-c-simple-sort-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we simply need to prioritize the more valuable boxes first. To do this, we should **sort** the boxtypes array (**B**) in descending order by the number of units per box (**B[i][1]**).\\n\\nThen we can iterate through **B** and at each step, we should add as many of the **boxes** as we can, until we reach the truck size (**T**). We should add the number of **boxes** added multiplied by the units per box to our answer (**ans**), and decrease **T** by the same number of **boxes**.\\n\\nOnce the truck is full (**T == 0**), or once the iteration is done, we should **return ans**.\\n\\n - _**Time Complexity: O(N log N)** where **N** is the length of **B**, for the sort_\\n - _**Space Complexity: O(1)** to **O(N)** depending on the sort algorithm used_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar maximumUnits = function(B, T) {\\n    B.sort((a,b) => b[1] - a[1])\\n    let ans = 0\\n    for (let i = 0; T && i < B.length; i++) {\\n        let count = Math.min(B[i][0], T)\\n        ans += count * B[i][1], T -= count\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def maximumUnits(self, B: List[List[int]], T: int) -> int:\\n        B.sort(key=lambda x: x[1], reverse=True)\\n        ans = 0\\n        for b,n in B:\\n            boxes = min(b, T)\\n            ans += boxes * n\\n            T -= boxes\\n            if T == 0: return ans\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int maximumUnits(int[][] B, int T) {\\n        Arrays.sort(B, (a,b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for (int[] b : B) {\\n            int count = Math.min(b[0], T);\\n            ans += count * b[1];\\n            T -= count;\\n\\t\\t\\tif (T == 0) return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& B, int T) {\\n        sort(B.begin(), B.end(), [](auto& a, auto& b) { return b[1] < a[1];});\\n        int ans = 0;\\n        for (auto& b : B) {\\n            int count = min(b[0], T);\\n            ans += count * b[1], T -= count;\\n\\t\\t\\tif (!T) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar maximumUnits = function(B, T) {\\n    B.sort((a,b) => b[1] - a[1])\\n    let ans = 0\\n    for (let i = 0; T && i < B.length; i++) {\\n        let count = Math.min(B[i][0], T)\\n        ans += count * B[i][1], T -= count\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def maximumUnits(self, B: List[List[int]], T: int) -> int:\\n        B.sort(key=lambda x: x[1], reverse=True)\\n        ans = 0\\n        for b,n in B:\\n            boxes = min(b, T)\\n            ans += boxes * n\\n            T -= boxes\\n            if T == 0: return ans\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int maximumUnits(int[][] B, int T) {\\n        Arrays.sort(B, (a,b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for (int[] b : B) {\\n            int count = Math.min(b[0], T);\\n            ans += count * b[1];\\n            T -= count;\\n\\t\\t\\tif (T == 0) return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& B, int T) {\\n        sort(B.begin(), B.end(), [](auto& a, auto& b) { return b[1] < a[1];});\\n        int ans = 0;\\n        for (auto& b : B) {\\n            int count = min(b[0], T);\\n            ans += count * b[1], T -= count;\\n\\t\\t\\tif (!T) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999356,
                "title": "c-simple-solution-sort-and-greedy-approach",
                "content": "1. Custom sort the given input (box with max units should come first)\\n2. Using greedy technique pick boxed untill capacity is full.\\n\\n```\\nclass Solution {\\npublic:\\n    bool static comparator(vector<int> &x,vector<int> &y){\\n        return (x[1]>y[1]);\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),comparator);\\n        int ans=0; //total units\\n\\t\\t\\n        for(int i=0;i<boxTypes.size();i++){\\n            int box_count=min(boxTypes[i][0],truckSize);\\n            ans+=box_count*boxTypes[i][1];\\n            truckSize-=box_count;\\n            if(truckSize==0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comparator(vector<int> &x,vector<int> &y){\\n        return (x[1]>y[1]);\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),comparator);\\n        int ans=0; //total units\\n\\t\\t\\n        for(int i=0;i<boxTypes.size();i++){\\n            int box_count=min(boxTypes[i][0],truckSize);\\n            ans+=box_count*boxTypes[i][1];\\n            truckSize-=box_count;\\n            if(truckSize==0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222651,
                "title": "c-simple-leetcode-challenge-july-day-1-sorting-beats-95",
                "content": "\\tstatic bool check(const vector<int> &v1,const vector<int> &v2){\\n        return v1[1]>v2[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),check);\\n        int count = 0;\\n       \\n        for(int i=0;i<boxTypes.size();i++){\\n            \\n            if(boxTypes[i][0]>=truckSize){\\n                count+= truckSize*boxTypes[i][1];\\n                 truckSize = 0;\\n            }\\n            else{\\n              truckSize -= boxTypes[i][0];\\n                count += boxTypes[i][0]*boxTypes[i][1];\\n            }\\n\\t\\t\\t\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "\\tstatic bool check(const vector<int> &v1,const vector<int> &v2){\\n        return v1[1]>v2[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),check);\\n        int count = 0;\\n       \\n        for(int i=0;i<boxTypes.size();i++){\\n            \\n            if(boxTypes[i][0]>=truckSize){\\n                count+= truckSize*boxTypes[i][1];\\n                 truckSize = 0;\\n            }\\n            else{\\n              truckSize -= boxTypes[i][0];\\n                count += boxTypes[i][0]*boxTypes[i][1];\\n            }\\n\\t\\t\\t\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1271383,
                "title": "python-simple-sort-solution-explained",
                "content": "We have only limit for number of boxes, not for their size, so what we need to choose boxes with biggest sizes. So, let us sort them by sizes, starting from big and then just iterate and try to put group of box in our truck. Each time we check if we can do it and if we have less space than needed, we put not all group, but such number so truck is full and then break.\\n\\n#### Complexity\\nTime is just `O(n log n)` to sort data and space is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximumUnits(self, boxTypes, truckSize):\\n        ans = 0\\n        for box_num, units in sorted(boxTypes, key = lambda x:-x[1]):\\n            if not truckSize: break\\n            ans += min(box_num, truckSize) * units\\n            truckSize -= min(box_num, truckSize)\\n\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumUnits(self, boxTypes, truckSize):\\n        ans = 0\\n        for box_num, units in sorted(boxTypes, key = lambda x:-x[1]):\\n            if not truckSize: break\\n            ans += min(box_num, truckSize) * units\\n            truckSize -= min(box_num, truckSize)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000308,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (x, y) -> y[1] - x[1]);\\n        int count = 0, size = boxTypes.length;\\n        for (int i = 0; i < size && truckSize > 0; ++i) {\\n            int boxes = boxTypes[i][0];\\n            int units = boxTypes[i][1];\\n            truckSize -= boxes;\\n            count += boxes * units;\\n            if (truckSize < 0) {\\n                count += truckSize * units;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (x, y) -> y[1] - x[1]);\\n        int count = 0, size = boxTypes.length;\\n        for (int i = 0; i < size && truckSize > 0; ++i) {\\n            int boxes = boxTypes[i][0];\\n            int units = boxTypes[i][1];\\n            truckSize -= boxes;\\n            count += boxes * units;\\n            if (truckSize < 0) {\\n                count += truckSize * units;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220971,
                "title": "sort-it-easy-explanation-code-c",
                "content": "Since all the boxes of different types are considered as 1 truckSize  , we can do this greedily and first put the box with maximum number of units .\\nSort the vector on the basis of number of units it contains and then take the boxes as much as you can from the start.\\n**Time Complexity : O(n logn) (sorting)\\nSpace Complexity : O(1)**\\n```\\n static bool compare(const vector<int> &v1,const vector<int> &v2){\\n        return v1[1]>v2[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),compare);\\n        int count = 0;\\n       \\n        for(int i=0;i<boxTypes.size();i++){\\n            \\n            if(boxTypes[i][0]>=truckSize){\\n                count+= truckSize*boxTypes[i][1];\\n                 truckSize = 0;\\n            }\\n            else{\\n              truckSize -= boxTypes[i][0];\\n                count += boxTypes[i][0]*boxTypes[i][1];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n static bool compare(const vector<int> &v1,const vector<int> &v2){\\n        return v1[1]>v2[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),compare);\\n        int count = 0;\\n       \\n        for(int i=0;i<boxTypes.size();i++){\\n            \\n            if(boxTypes[i][0]>=truckSize){\\n                count+= truckSize*boxTypes[i][1];\\n                 truckSize = 0;\\n            }\\n            else{\\n              truckSize -= boxTypes[i][0];\\n                count += boxTypes[i][0]*boxTypes[i][1];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595720,
                "title": "c-greedy-approach-easy",
                "content": "```\\nbool cmp(vector<int>& a, vector<int>& b){\\n        return a[1] > b[1];\\n}\\nclass Solution {\\npublic:\\n    //Basic Greedy Question\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);// sort on the basis of units\\n        int ans=0;\\n        \\n        for(auto box: boxTypes){\\n            if(truckSize>box[0]){\\n                ans+=box[0]*box[1];\\n                truckSize-=box[0];\\n            }\\n            else{\\n                ans+=truckSize*box[1];\\n                truckSize=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    //Basic Greedy Question\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);// sort on the basis of units\\n        int ans=0;\\n        \\n        for(auto box: boxTypes){\\n            if(truckSize>box[0]){\\n                ans+=box[0]*box[1];\\n                truckSize-=box[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1594586,
                "title": "python-simple-solution-faster-96-89-time-o-nlogn",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\t\\t\\tboxTypes = sorted(boxTypes, key = lambda x : x[1], reverse = True)\\n\\t\\t\\toutput = 0\\n\\t\\t\\tfor no, units in boxTypes:\\n\\t\\t\\t\\tif truckSize > no:\\n\\t\\t\\t\\t\\ttruckSize -= no\\n\\t\\t\\t\\t\\toutput += (no * units)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\toutput += (truckSize * units)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn output\\n\\n**If You Like The Solution Upvote.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\t\\t\\tboxTypes = sorted(boxTypes, key = lambda x : x[1], reverse = True)\\n\\t\\t\\toutput = 0\\n\\t\\t\\tfor no, units in boxTypes:\\n\\t\\t\\t\\tif truckSize > no:\\n\\t\\t\\t\\t\\ttruckSize -= no\\n\\t\\t\\t\\t\\toutput += (no * units)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\toutput += (truckSize * units)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn output\\n\\n**If You Like The Solution Upvote.**",
                "codeTag": "Java"
            },
            {
                "id": 999974,
                "title": "c-100-100",
                "content": "```\\npublic int MaximumUnits(int[][] boxTypes, int truckSize) {\\n\\tvar size = 0;\\n\\tvar units = 0;\\n\\n\\tforeach (var boxType in boxTypes.OrderByDescending(bt => bt[1])) {\\n\\t\\tif (size + boxType[0] < truckSize) {\\n\\t\\t\\tunits += boxType[0] * boxType[1];\\n\\t\\t\\tsize += boxType[0];\\n\\t\\t} else {\\n\\t\\t\\tunits += (truckSize - size) * boxType[1];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\treturn units;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaximumUnits(int[][] boxTypes, int truckSize) {\\n\\tvar size = 0;\\n\\tvar units = 0;\\n\\n\\tforeach (var boxType in boxTypes.OrderByDescending(bt => bt[1])) {\\n\\t\\tif (size + boxType[0] < truckSize) {\\n\\t\\t\\tunits += boxType[0] * boxType[1];\\n\\t\\t\\tsize += boxType[0];\\n\\t\\t} else {\\n\\t\\t\\tunits += (truckSize - size) * boxType[1];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\treturn units;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2275442,
                "title": "c-solution-short-easy-explanation",
                "content": "Sort & Choose Greedily\\n---\\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\n\\t// sort by number of units\\n\\tsort(begin(boxTypes), end(boxTypes), [](auto& a, auto& b){ return a[1] > b[1];}); \\n\\t\\n\\tint maxUnits = 0;\\n\\tfor(auto& box : boxTypes) {\\n\\t\\n\\t\\tif(truckSize <= 0) break;      \\n\\t\\t// keep choosing greedily till you run out of truckSize \\n\\t\\tmaxUnits += min(truckSize, box[0]) * box[1]; \\n\\t\\t// add (no of box * units) in that box\\n\\t\\ttruckSize -= box[0];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\n\\t// sort by number of units\\n\\tsort(begin(boxTypes), end(boxTypes), [](auto& a, auto& b){ return a[1] > b[1];}); \\n\\t\\n\\tint maxUnits = 0;\\n\\tfor(auto& box : boxTypes) {\\n\\t\\n\\t\\tif(truckSize <= 0) break;      \\n\\t\\t// keep choosing greedily till you run out of truckSize \\n\\t\\tmaxUnits += min(truckSize, box[0]) * box[1]; \\n\\t\\t// add (no of box * units) in that box\\n\\t\\ttruckSize -= box[0];\\n\\t}\\n\\treturn maxUnits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221248,
                "title": "c-sorting-greedy-maximum-units-on-a-truck",
                "content": "\\t// Sort the boxes in decreasing order of units\\n\\t// Take the boxes if the total no of boxes+ current number of  box is less than or equal to trucksize\\n\\t// otherwise check how many boxes we can take by subtracting total boxestaken from trucksize i.e.\\n\\t// trucksize-boxestaken \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstatic bool compare(vector<int>&a, vector<int>&b)\\n\\t\\t{\\n\\t\\t\\tif(a[1]==b[1])\\n\\t\\t\\t\\treturn a[0]>b[0];\\n\\t\\t\\treturn a[1]>b[1];\\n\\t\\t}\\n\\t\\tint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\t\\t\\tsort(boxTypes.begin(),boxTypes.end(),compare);\\n\\n\\t\\t\\tint unit=0,boxesTaken=0;        \\n\\t\\t\\tfor(int i=0;i<boxTypes.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint curr=boxTypes[i][0];\\n\\t\\t\\t\\tif(boxesTaken+curr<=truckSize){\\n\\t\\t\\t\\t\\tboxesTaken+=curr;\\n\\t\\t\\t\\t\\tunit+=curr*boxTypes[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tunit+=(truckSize-boxesTaken)*boxTypes[i][1];\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn unit;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstatic bool compare(vector<int>&a, vector<int>&b)\\n\\t\\t{\\n\\t\\t\\tif(a[1]==b[1])\\n\\t\\t\\t\\treturn a[0]>b[0];\\n\\t\\t\\treturn a[1]>b[1];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2220393,
                "title": "c-beginner-friendly-simple-easy",
                "content": "**UPVOTE IF YOU FIND IT USEFUL**\\n```\\nclass Solution {\\npublic:\\n    // comparator function to sort in accordance to no of units per boxes\\n    static int comp(vector<int>&a,vector<int>&b)\\n    {  \\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truck) {\\n       int n=boxTypes.size();\\n    \\n     //   We can easiliy observe that it will always be better to choose the box with maximum number of units in it so that the overall number of units that can be put on truck is maximized.\\n     // thus sort the vector in the order in which we will try to maximise the number of units per boxes\\n\\n        sort(boxTypes.begin(),boxTypes.end(),comp);\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n       //  keep choosing the boxes starting from the first one from the sorted array till we fill the whole truck  \\n           \\n            if(truck-boxTypes[i][0]>=0)\\n            {\\n               ans+=(boxTypes[i][0] * boxTypes[i][1]); \\n                truck-=boxTypes[i][0];\\n            }\\n            else\\n            {\\n              // condition when our truck size is less than no of boxes  \\n               ans+=(truck * boxTypes[i][1]); \\n               break; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // comparator function to sort in accordance to no of units per boxes\\n    static int comp(vector<int>&a,vector<int>&b)\\n    {  \\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truck) {\\n       int n=boxTypes.size();\\n    \\n     //   We can easiliy observe that it will always be better to choose the box with maximum number of units in it so that the overall number of units that can be put on truck is maximized.\\n     // thus sort the vector in the order in which we will try to maximise the number of units per boxes\\n\\n        sort(boxTypes.begin(),boxTypes.end(),comp);\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n       //  keep choosing the boxes starting from the first one from the sorted array till we fill the whole truck  \\n           \\n            if(truck-boxTypes[i][0]>=0)\\n            {\\n               ans+=(boxTypes[i][0] * boxTypes[i][1]); \\n                truck-=boxTypes[i][0];\\n            }\\n            else\\n            {\\n              // condition when our truck size is less than no of boxes  \\n               ans+=(truck * boxTypes[i][1]); \\n               break; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434485,
                "title": "greedy-approach-c-fractional-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&a, vector<int>&b){\\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxtypes, int truckSize) {\\n        int totalSum = 0;\\n        sort(boxtypes.begin(), boxtypes.end(), cmp);\\n        int i=0;\\n        while(truckSize>0 && i<boxtypes.size()){\\n            // if weight is less than truckSize\\n            if(truckSize-boxtypes[i][0]>0){\\n                truckSize-=boxtypes[i][0];\\n                totalSum += (boxtypes[i][0]*boxtypes[i][1]);\\n            }\\n            // if weight is greater than truckSize\\n            else{\\n                totalSum += (truckSize*boxtypes[i][1]);\\n                truckSize = 0;\\n            }\\n            i++;\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&a, vector<int>&b){\\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxtypes, int truckSize) {\\n        int totalSum = 0;\\n        sort(boxtypes.begin(), boxtypes.end(), cmp);\\n        int i=0;\\n        while(truckSize>0 && i<boxtypes.size()){\\n            // if weight is less than truckSize\\n            if(truckSize-boxtypes[i][0]>0){\\n                truckSize-=boxtypes[i][0];\\n                totalSum += (boxtypes[i][0]*boxtypes[i][1]);\\n            }\\n            // if weight is greater than truckSize\\n            else{\\n                totalSum += (truckSize*boxtypes[i][1]);\\n                truckSize = 0;\\n            }\\n            i++;\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271478,
                "title": "java-100-faster-bucket-sort-o-n",
                "content": "Create 1000 buckets (based on the constraints given, this is feasible) and save the number of boxes for each unit in the bucket. Index represents units and value at that index is number of boxes with that units.\\n\\nAfter building the buckets in O(n), loop from the last taking the maximum units available.\\n\\n**Time complexity: O(n)\\nSpace complexity: O(1000) = O(1)**\\n\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        int[] buckets = new int[1001];\\n        int units = 0;\\n        \\n        for (int i = 0; i < boxTypes.length; i++) {\\n            if (buckets[boxTypes[i][1]] == 0) {\\n                buckets[boxTypes[i][1]] = boxTypes[i][0];\\n            } else {\\n                buckets[boxTypes[i][1]] += boxTypes[i][0];\\n            }\\n        }\\n        \\n        for (int i = 1000; truckSize > 0 && i >= 0; --i) {\\n            if (buckets[i] == 0) continue;\\n\\n            units += Math.min(truckSize, buckets[i])*i;\\n            truckSize -= buckets[i]; \\n        }\\n        \\n        return units;\\n    }\\n};\\n\\n```\\n\\n\\nAnother solution is using simple sorting but takes **O(nlogn)** time.\\n\\nSort the boxes based on units in reverse and pick as many boxes of that units as you can until the truck size allows.\\n\\n```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, new Comparator<int[]>() {\\n            public int compare(int[] idx1, int[] idx2) {\\n                return Integer.compare(idx2[1], idx1[1]);\\n            }\\n        });\\n \\n        int i=0, units  = 0;\\n        while(i<boxTypes.length && truckSize>0) {\\n                units += boxTypes[i][1]*(Math.min(truckSize, boxTypes[i][0]));\\n                truckSize -= boxTypes[i][0];\\n                i++;                \\n        }\\n        \\n        return units;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        int[] buckets = new int[1001];\\n        int units = 0;\\n        \\n        for (int i = 0; i < boxTypes.length; i++) {\\n            if (buckets[boxTypes[i][1]] == 0) {\\n                buckets[boxTypes[i][1]] = boxTypes[i][0];\\n            } else {\\n                buckets[boxTypes[i][1]] += boxTypes[i][0];\\n            }\\n        }\\n        \\n        for (int i = 1000; truckSize > 0 && i >= 0; --i) {\\n            if (buckets[i] == 0) continue;\\n\\n            units += Math.min(truckSize, buckets[i])*i;\\n            truckSize -= buckets[i]; \\n        }\\n        \\n        return units;\\n    }\\n};\\n\\n```\n```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, new Comparator<int[]>() {\\n            public int compare(int[] idx1, int[] idx2) {\\n                return Integer.compare(idx2[1], idx1[1]);\\n            }\\n        });\\n \\n        int i=0, units  = 0;\\n        while(i<boxTypes.length && truckSize>0) {\\n                units += boxTypes[i][1]*(Math.min(truckSize, boxTypes[i][0]));\\n                truckSize -= boxTypes[i][0];\\n                i++;                \\n        }\\n        \\n        return units;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222371,
                "title": "maximum-units-on-a-truck-java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        //sort the array in ascending order according to the second column(i.e numberOfUnitsPerBox)\\n        Arrays.sort(boxTypes, (a, b) -> Integer.compare(a[1],b[1]));\\n        \\n        int ans = 0;\\n        for(int i=boxTypes.length-1;i>=0;i--)\\n        {\\n            if(truckSize == 0)\\n                return ans;\\n            if(boxTypes[i][0] <= truckSize)\\n            {\\n                ans += boxTypes[i][0]*boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            else\\n            {\\n                ans += truckSize*boxTypes[i][1];\\n                truckSize = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        //sort the array in ascending order according to the second column(i.e numberOfUnitsPerBox)\\n        Arrays.sort(boxTypes, (a, b) -> Integer.compare(a[1],b[1]));\\n        \\n        int ans = 0;\\n        for(int i=boxTypes.length-1;i>=0;i--)\\n        {\\n            if(truckSize == 0)\\n                return ans;\\n            if(boxTypes[i][0] <= truckSize)\\n            {\\n                ans += boxTypes[i][0]*boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            else\\n            {\\n                ans += truckSize*boxTypes[i][1];\\n                truckSize = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222142,
                "title": "js-sort-simple-straight-forward",
                "content": "```\\n/**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n  boxTypes.sort((a, b) => b[1] - a[1]);\\n  \\n  let result = 0;\\n  for (const [ boxes, units ] of boxTypes) {\\n    const takeBoxes = Math.min(boxes, truckSize);\\n    result += units * takeBoxes;\\n    truckSize -= takeBoxes;\\n    if (!truckSize) break;\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n  boxTypes.sort((a, b) => b[1] - a[1]);\\n  \\n  let result = 0;\\n  for (const [ boxes, units ] of boxTypes) {\\n    const takeBoxes = Math.min(boxes, truckSize);\\n    result += units * takeBoxes;\\n    truckSize -= takeBoxes;\\n    if (!truckSize) break;\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221361,
                "title": "java-simple-sort-with-explanation",
                "content": "# Idea:\\n**For this problem, we simply need to prioritize the more valuable boxes first. To do this, we should sort the boxtypes array *(boxTypes)* in descending order by the number of units per box *(boxTypes[i] [1])*.**\\n\\n**Then we can iterate through *boxTypes* and at each step, we should add as many of the boxes as we can, until we reach the truck size *(truckSize)*. We should add the number of boxes added multiplied by the units per box to our answer *(ans)*, and decrease *truckSize* by the same number of boxes**.\\n\\n**Once the truck is full *(truckSize == 0)*, or once the iteration is done, we should return *ans*.**\\n\\n\\n**Time Complexity: O(N log N) where N is the length of boxTypes, for the sort\\nSpace Complexity: O(1) to O(N) depending on the sort algorithm used**\\n\\n\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n     Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n      int ans = 0;\\n      for(int[] b : boxTypes) {\\n        int count = Math.min(b[0], truckSize);\\n        ans += count * b[1];\\n        truckSize -= count;\\n        if(truckSize == 0) return ans;\\n      }\\n      return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n     Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n      int ans = 0;\\n      for(int[] b : boxTypes) {\\n        int count = Math.min(b[0], truckSize);\\n        ans += count * b[1];\\n        truckSize -= count;\\n        if(truckSize == 0) return ans;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2220795,
                "title": "c-simple-greedy-sorting-easy-to-understand",
                "content": "**TIME COMPLEXITY = O(NlogN)**\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxes, int n) {\\n        sort(begin(boxes), end(boxes), cmp);\\n        int ans = 0;\\n        for(auto box : boxes){\\n            int left = min(box[0], n);\\n            ans += left*box[1];\\n            n -= left;\\n            if(n==0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you like then upvote!!!!!",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b){\\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxes, int n) {\\n        sort(begin(boxes), end(boxes), cmp);\\n        int ans = 0;\\n        for(auto box : boxes){\\n            int left = min(box[0], n);\\n            ans += left*box[1];\\n            n -= left;\\n            if(n==0)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273277,
                "title": "javascript-easy-to-understand-2-solutions-build-in-sort-bucket-sort",
                "content": "Since we don\\'t need to think about the size of different box types, it\\'s a simple greedy strategy for only units of boxes.\\n\\n## SOLUTION 1\\n\\nWe use the build-in `sort` method for an array to sort the `boxTypes`. And try to choose the boxes with more units.\\n\\n```js\\nconst maximumUnits = (boxTypes, truckSize) => {\\n  let ret = 0;\\n  boxTypes.sort((a, b) => b[1] - a[1]);\\n  for (let idx = 0; ; ) {\\n    if (idx >= boxTypes.length) break;\\n    const [count, unit] = boxTypes[idx];\\n    if (count === 0) { ++idx; continue; }\\n    if (truckSize <= count) { ret += truckSize * unit; break; }\\n    truckSize -= count;\\n    ret += count * unit;\\n    ++idx;\\n  }\\n  return ret;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nWe use bucket sort to make the sorting part O(n). There\\'s a little optimization, traversal from the `max` should be better than the edge of bucket.\\n\\n```js\\nconst maximumUnits = (boxTypes, truckSize) => {\\n  const bucket = new Uint16Array(1001);\\n  let ret = 0;\\n  let max = 0;\\n  for (let i = 0; i < boxTypes.length; ++i) {\\n    bucket[boxTypes[i][1]] += boxTypes[i][0];\\n\\tboxTypes[i][1] > max && (max = boxTypes[i][1]);\\n  }\\n  for (let idx = max; ; ) {\\n    if (idx < 0) break;\\n    const count = bucket[idx];\\n    if (count === 0) { --idx; continue; }\\n    if (truckSize <= count) { ret += truckSize * idx; break; }\\n    truckSize -= count;\\n    ret += count * idx;\\n    --idx;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst maximumUnits = (boxTypes, truckSize) => {\\n  let ret = 0;\\n  boxTypes.sort((a, b) => b[1] - a[1]);\\n  for (let idx = 0; ; ) {\\n    if (idx >= boxTypes.length) break;\\n    const [count, unit] = boxTypes[idx];\\n    if (count === 0) { ++idx; continue; }\\n    if (truckSize <= count) { ret += truckSize * unit; break; }\\n    truckSize -= count;\\n    ret += count * unit;\\n    ++idx;\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst maximumUnits = (boxTypes, truckSize) => {\\n  const bucket = new Uint16Array(1001);\\n  let ret = 0;\\n  let max = 0;\\n  for (let i = 0; i < boxTypes.length; ++i) {\\n    bucket[boxTypes[i][1]] += boxTypes[i][0];\\n\\tboxTypes[i][1] > max && (max = boxTypes[i][1]);\\n  }\\n  for (let idx = max; ; ) {\\n    if (idx < 0) break;\\n    const count = bucket[idx];\\n    if (count === 0) { --idx; continue; }\\n    if (truckSize <= count) { ret += truckSize * idx; break; }\\n    truckSize -= count;\\n    ret += count * idx;\\n    --idx;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034009,
                "title": "python-sort-greedy-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: greed\\nh: we put the box that contains the largest unit into the Truck\\n    until:\\n    1) such type of box has been all put into the truck\\n    2) we cannot put any box into truck anymore\\n\\'\\'\\'\\n\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        res = 0\\n        boxTypes = sorted(boxTypes, reverse=True, key=lambda x:x[1])\\n        #print(boxTypes)\\n        \\n        for b, u in boxTypes:\\n            #1. the truck is full\\n            if truckSize - b <= 0:\\n                res += (truckSize) * u\\n                break\\n            \\n            #2. put all the boxes into the truck\\n            else:\\n                res += b * u\\n                truckSize -= b\\n            \\n        \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: greed\\nh: we put the box that contains the largest unit into the Truck\\n    until:\\n    1) such type of box has been all put into the truck\\n    2) we cannot put any box into truck anymore\\n\\'\\'\\'\\n\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        res = 0\\n        boxTypes = sorted(boxTypes, reverse=True, key=lambda x:x[1])\\n        #print(boxTypes)\\n        \\n        for b, u in boxTypes:\\n            #1. the truck is full\\n            if truckSize - b <= 0:\\n                res += (truckSize) * u\\n                break\\n            \\n            #2. put all the boxes into the truck\\n            else:\\n                res += b * u\\n                truckSize -= b\\n            \\n        \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006166,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        units = 0\\n        for box in sorted(boxTypes, key=lambda x: x[1], reverse=True):\\n            boxes = min(box[0], truckSize)\\n            units += boxes * box[1]\\n            truckSize -= boxes\\n            if truckSize == 0:\\n                break\\n        return units\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        units = 0\\n        for box in sorted(boxTypes, key=lambda x: x[1], reverse=True):\\n            boxes = min(box[0], truckSize)\\n            units += boxes * box[1]\\n            truckSize -= boxes\\n            if truckSize == 0:\\n                break\\n        return units\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223784,
                "title": "go-greedy-clear-solution",
                "content": "```\\nfunc maximumUnits(boxTypes [][]int, truckSize int) int {\\n    sort.Slice(boxTypes, func (i, j int) bool {\\n        return boxTypes[i][1] > boxTypes[j][1]\\n    })\\n    \\n    units := 0\\n    for _, boxType := range boxTypes {\\n        taken := Min(boxType[0], truckSize)\\n        units += taken*boxType[1]\\n        truckSize -= taken\\n        if truckSize == 0 { break }\\n    }\\n    return units\\n}\\n\\nfunc Min(a, b int) int { if a < b { return a }; return b }\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc maximumUnits(boxTypes [][]int, truckSize int) int {\\n    sort.Slice(boxTypes, func (i, j int) bool {\\n        return boxTypes[i][1] > boxTypes[j][1]\\n    })\\n    \\n    units := 0\\n    for _, boxType := range boxTypes {\\n        taken := Min(boxType[0], truckSize)\\n        units += taken*boxType[1]\\n        truckSize -= taken\\n        if truckSize == 0 { break }\\n    }\\n    return units\\n}\\n\\nfunc Min(a, b int) int { if a < b { return a }; return b }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2223202,
                "title": "python-simple-sorting-as-per-the-hints-given-for-this-problem",
                "content": "Please comment if my time analysis is incorrect and If there are any optimizations I can make for my code. Thank you.\\n\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        \\n        units = 0\\n        \\n        boxTypes.sort(key=lambda row: row[1], reverse=True)\\n        for boxes in boxTypes:\\n            if truckSize > boxes[0]:\\n                units += boxes[0] * boxes[1]\\n            elif truckSize > 0:\\n                units += truckSize * boxes[1]\\n            truckSize = truckSize - boxes[0]\\n        return units\\n    \\n# Time Complexity: O(nlogn)\\n# Space Complexity: o(n*m) for input boxtypes and O(1) for units\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        \\n        units = 0\\n        \\n        boxTypes.sort(key=lambda row: row[1], reverse=True)\\n        for boxes in boxTypes:\\n            if truckSize > boxes[0]:\\n                units += boxes[0] * boxes[1]\\n            elif truckSize > 0:\\n                units += truckSize * boxes[1]\\n            truckSize = truckSize - boxes[0]\\n        return units\\n    \\n# Time Complexity: O(nlogn)\\n# Space Complexity: o(n*m) for input boxtypes and O(1) for units\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221247,
                "title": "c-using-comparator-function-detailed-explanation-with-comments-asked-in-amazon",
                "content": "```\\n\\n// comparator function to sort the 2d vector in decreasing order on the basis of column which is (no_of_units)\\n// so we get the boxes in order of greater number of units per box. \\nbool sortbycol(const vector<int> &v1, const vector<int> &v2)\\n{\\n   return v1[1] > v2[1];\\n}\\nclass Solution\\n{\\npublic:\\n    int maximumUnits(vector<vector<int>> &boxTypes, int truckSize)\\n    {\\n        int result = 0;\\n        sort(boxTypes.begin(), boxTypes.end(), sortbycol);\\n        // now we have sorted the 2d vector according to the highest number of units per box.\\n        for (int i = 0; i < boxTypes.size(); i++)\\n        {\\n            // no of boxes\\n            int no_of_boxes = boxTypes[i][0]; // no of boxes of ith type\\n            int units_per_box = boxTypes[i][1]; // no of units in boxes of ith type\\n            // now for every type of box we check if no of boxes are greater than trucksize or not\\n            // now for every type of box we check if, no of boxes of this type are greater than remaining trucksize.\\n            if (no_of_boxes > truckSize)\\n            {\\n                // if they are greater than remaining truck size, we put no of boxes = remaining truck size and thus add into our result no of units in all these boxes , which would be number of boxes (= remaining truck size in this case) * (units_per_box)\\n                result += (truckSize * units_per_box);\\n                // now as truck is full , we won\\'t be able to add more boxes\\n                // so we set truck size = 0\\n                truckSize = 0;\\n                // and break out of the loop\\n                break;\\n            }\\n            else\\n            {\\n                // if they are less than remaining truck size, we take all boxes of this particular type and thus we add into our result no of units in all these boxes, which would be (number of boxes) * (units_per_box)\\n                result += (no_of_boxes * units_per_box);\\n                // we decrement truckSize by no of boxes added. \\n                truckSize -= no_of_boxes;\\n                \\n            }\\n        }\\n        // we return the value of result variable to the main function. \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\n// comparator function to sort the 2d vector in decreasing order on the basis of column which is (no_of_units)\\n// so we get the boxes in order of greater number of units per box. \\nbool sortbycol(const vector<int> &v1, const vector<int> &v2)\\n{\\n   return v1[1] > v2[1];\\n}\\nclass Solution\\n{\\npublic:\\n    int maximumUnits(vector<vector<int>> &boxTypes, int truckSize)\\n    {\\n        int result = 0;\\n        sort(boxTypes.begin(), boxTypes.end(), sortbycol);\\n        // now we have sorted the 2d vector according to the highest number of units per box.\\n        for (int i = 0; i < boxTypes.size(); i++)\\n        {\\n            // no of boxes\\n            int no_of_boxes = boxTypes[i][0]; // no of boxes of ith type\\n            int units_per_box = boxTypes[i][1]; // no of units in boxes of ith type\\n            // now for every type of box we check if no of boxes are greater than trucksize or not\\n            // now for every type of box we check if, no of boxes of this type are greater than remaining trucksize.\\n            if (no_of_boxes > truckSize)\\n            {\\n                // if they are greater than remaining truck size, we put no of boxes = remaining truck size and thus add into our result no of units in all these boxes , which would be number of boxes (= remaining truck size in this case) * (units_per_box)\\n                result += (truckSize * units_per_box);\\n                // now as truck is full , we won\\'t be able to add more boxes\\n                // so we set truck size = 0\\n                truckSize = 0;\\n                // and break out of the loop\\n                break;\\n            }\\n            else\\n            {\\n                // if they are less than remaining truck size, we take all boxes of this particular type and thus we add into our result no of units in all these boxes, which would be (number of boxes) * (units_per_box)\\n                result += (no_of_boxes * units_per_box);\\n                // we decrement truckSize by no of boxes added. \\n                truckSize -= no_of_boxes;\\n                \\n            }\\n        }\\n        // we return the value of result variable to the main function. \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220711,
                "title": "knapsack-like-greedy-july-1",
                "content": "**What greedy says?** \\nCollect the boxes which have **greater units per box first** (Greedily) reduce the truck size accordingly \\nand then pick the remaining one\\'s respectively\\n\\n    static bool cmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[1]>v2[1];  //sort to bring boxes wth greater units per box above\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int n = boxTypes.size();\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);\\n        int maxUnits = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(truckSize<boxTypes[i][0])                \\n            {\\n                 boxTypes[i][0] = truckSize;\\n            }\\n            maxUnits += boxTypes[i][1]*boxTypes[i][0];               //boxType[i][1] is number of units per box\\n\\t\\t\\ttruckSize -= boxTypes[i][0];                             // boxType[i][0] is number of boxes\\n        }\\n        return maxUnits;\\n    }\\n\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "**What greedy says?** \\nCollect the boxes which have **greater units per box first** (Greedily) reduce the truck size accordingly \\nand then pick the remaining one\\'s respectively\\n\\n    static bool cmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[1]>v2[1];  //sort to bring boxes wth greater units per box above\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int n = boxTypes.size();\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);\\n        int maxUnits = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(truckSize<boxTypes[i][0])                \\n            {\\n                 boxTypes[i][0] = truckSize;\\n            }\\n            maxUnits += boxTypes[i][1]*boxTypes[i][0];               //boxType[i][1] is number of units per box\\n\\t\\t\\ttruckSize -= boxTypes[i][0];                             // boxType[i][0] is number of boxes\\n        }\\n        return maxUnits;\\n    }\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2220455,
                "title": "python-o-nlogn-solution",
                "content": "```\\nclass Solution(object):\\n    def maximumUnits(self, boxTypes, truckSize):\\n        \"\"\"\\n        :type boxTypes: List[List[int]]\\n        :type truckSize: int\\n        :rtype: int\\n        \"\"\"\\n        boxTypes.sort(key = lambda x:-x[1])\\n        ans = 0\\n        for box in boxTypes:\\n            num_boxes, num_units = box[0], box[1]\\n            if truckSize >= num_boxes:\\n                ans += num_boxes * num_units\\n                truckSize -= num_boxes\\n                continue\\n            else:\\n                ans += truckSize * num_units\\n                break\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumUnits(self, boxTypes, truckSize):\\n        \"\"\"\\n        :type boxTypes: List[List[int]]\\n        :type truckSize: int\\n        :rtype: int\\n        \"\"\"\\n        boxTypes.sort(key = lambda x:-x[1])\\n        ans = 0\\n        for box in boxTypes:\\n            num_boxes, num_units = box[0], box[1]\\n            if truckSize >= num_boxes:\\n                ans += num_boxes * num_units\\n                truckSize -= num_boxes\\n                continue\\n            else:\\n                ans += truckSize * num_units\\n                break\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699527,
                "title": "java-fractional-knapsack-explained",
                "content": "**Idea:** \\n* This is a variation of a classic CS problem called [Fractional Knapsack](https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_fractional_knapsack.htm). I\\'d highly recommend reading about it.\\n* Maximize the units you can take by sorting boxTypes in descending order\\n* Keep taking boxes as long as there is space in truck i.e. truck size > 0\\n>**T/S:** O(n lg n)/O(1), where n = size(boxTypes)\\n```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\tArrays.sort(boxTypes, Comparator.comparingInt(boxType -> -boxType[1]));\\n\\tvar units = 0;\\n\\t\\n\\tfor (var boxType : boxTypes) {\\n\\t\\tunits += Math.min(truckSize, boxType[0]) * boxType[1];\\n\\t\\ttruckSize -= boxType[0];\\n\\t\\t\\n\\t\\tif (truckSize <= 0)\\n\\t\\t\\tbreak;\\n\\t}\\n\\t\\n\\treturn units;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\tArrays.sort(boxTypes, Comparator.comparingInt(boxType -> -boxType[1]));\\n\\tvar units = 0;\\n\\t\\n\\tfor (var boxType : boxTypes) {\\n\\t\\tunits += Math.min(truckSize, boxType[0]) * boxType[1];\\n\\t\\ttruckSize -= boxType[0];\\n\\t\\t\\n\\t\\tif (truckSize <= 0)\\n\\t\\t\\tbreak;\\n\\t}\\n\\t\\n\\treturn units;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658845,
                "title": "java-greedy-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        Arrays.sort(boxTypes, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] l, int[] r) {\\n                return l[1] < r[1] ? -1 : 1;\\n            }\\n        });\\n        \\n         int res=0;\\n\\n         for(int i =boxTypes.length-1;i>=0;i--){\\n             if(boxTypes[i][0]<=truckSize){\\n                 System.out.println(boxTypes[i][0]+\"  \"+ boxTypes[i][1] +\"  \"+truckSize);\\n                 res+=boxTypes[i][0]*boxTypes[i][1];\\n                 truckSize-=boxTypes[i][0];\\n             }\\n             else{\\n                 res+=(truckSize*boxTypes[i][1]);\\n                 break;\\n             }\\n         }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        Arrays.sort(boxTypes, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] l, int[] r) {\\n                return l[1] < r[1] ? -1 : 1;\\n            }\\n        });\\n        \\n         int res=0;\\n\\n         for(int i =boxTypes.length-1;i>=0;i--){\\n             if(boxTypes[i][0]<=truckSize){\\n                 System.out.println(boxTypes[i][0]+\"  \"+ boxTypes[i][1] +\"  \"+truckSize);\\n                 res+=boxTypes[i][0]*boxTypes[i][1];\\n                 truckSize-=boxTypes[i][0];\\n             }\\n             else{\\n                 res+=(truckSize*boxTypes[i][1]);\\n                 break;\\n             }\\n         }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349751,
                "title": "c-simple-sort-and-add-in-result",
                "content": "```\\npublic:\\n    int maximumUnits(vector<vector<int>>& arr, int truckSize) {\\n        for(int i=0; i<arr.size(); i++){\\n            swap(arr[i][0], arr[i][1]);    // swap so that we can directly sort with numberOfUnitsPerBoxi  ( eg. weight of each box )  \\n        }\\n        sort(arr.begin(), arr.end(), greater<vector<int>>());   // sort according to weight in decreasing order now for test case 2 ( [[5,10],[2,5],[4,7],[3,9]] )  we have \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 10 5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 9 3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 7 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 5 2\\n        for(auto it:arr){\\n            cout << it[0] << it[1] << \"\\\\n\";\\n        }\\n        int total = 0;\\n        for(auto box : arr){\\n            int curr_space = min(box[1], truckSize);     // check current space left  box[1] -> no. of boxex we have.\\n            total += box[0]*curr_space;   // add in total  box[0] -> weight of box\\n            truckSize -= curr_space;\\n            if(truckSize == 0) return total;\\n        }\\n        return total;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic:\\n    int maximumUnits(vector<vector<int>>& arr, int truckSize) {\\n        for(int i=0; i<arr.size(); i++){\\n            swap(arr[i][0], arr[i][1]);    // swap so that we can directly sort with numberOfUnitsPerBoxi  ( eg. weight of each box )  \\n        }\\n        sort(arr.begin(), arr.end(), greater<vector<int>>());   // sort according to weight in decreasing order now for test case 2 ( [[5,10],[2,5],[4,7],[3,9]] )  we have \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 10 5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 9 3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 7 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// 5 2\\n        for(auto it:arr){\\n            cout << it[0] << it[1] << \"\\\\n\";\\n        }\\n        int total = 0;\\n        for(auto box : arr){\\n            int curr_space = min(box[1], truckSize);     // check current space left  box[1] -> no. of boxex we have.\\n            total += box[0]*curr_space;   // add in total  box[0] -> weight of box\\n            truckSize -= curr_space;\\n            if(truckSize == 0) return total;\\n        }\\n        return total;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1271685,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn maximum_units(mut box_types: Vec<Vec<i32>>, mut truck_size: i32) -> i32 {\\n        box_types.sort_unstable_by_key(|b| std::cmp::Reverse(b[1]));\\n        box_types\\n            .iter()\\n            .map(|b| (b[0], b[1]))\\n            .fold(0, |acc, (n, units)| {\\n                let take = n.min(truck_size);\\n                truck_size -= take;\\n                acc + take * units\\n            })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximum_units(mut box_types: Vec<Vec<i32>>, mut truck_size: i32) -> i32 {\\n        box_types.sort_unstable_by_key(|b| std::cmp::Reverse(b[1]));\\n        box_types\\n            .iter()\\n            .map(|b| (b[0], b[1]))\\n            .fold(0, |acc, (n, units)| {\\n                let take = n.min(truck_size);\\n                truck_size -= take;\\n                acc + take * units\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231724,
                "title": "python3-97-faster-solution",
                "content": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: x[1] , reverse=True)\\n                \\n        count = 0\\n        \\n        k = 0\\n        \\n        for i , j in boxTypes:\\n            if(truckSize < i):\\n                break\\n            \\n            count += i * j\\n            \\n            truckSize -= i\\n            \\n            k += 1\\n        \\n        try:\\n            return count + (truckSize * boxTypes[k][1])\\n        except:\\n            return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: x[1] , reverse=True)\\n                \\n        count = 0\\n        \\n        k = 0\\n        \\n        for i , j in boxTypes:\\n            if(truckSize < i):\\n                break\\n            \\n            count += i * j\\n            \\n            truckSize -= i\\n            \\n            k += 1\\n        \\n        try:\\n            return count + (truckSize * boxTypes[k][1])\\n        except:\\n            return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009491,
                "title": "python-solutions-max-heap-sort",
                "content": "**Solution 1: Max-heap**\\n**Time Complexity: O(nlogn)**\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\theap = []\\n\\tfor box, count in boxTypes:\\n\\t\\t# push the count of each box in the max-heap\\n\\t\\theapq.heappush(heap, [-count, box])\\n\\n\\tunit_count = 0\\n\\twhile heap and truckSize > 0:\\n\\t\\ttop = heapq.heappop(heap)\\n\\t\\tbox_count = min(truckSize, top[1])\\n\\t\\tunit_count += box_count * (-1 * top[0])\\n\\t\\ttruckSize -= box_count\\n\\n\\treturn unit_count\\n```\\n**Solution 2: Sorting**\\n**Time Complexity: O(nlogn)**\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\tboxTypes.sort(key=lambda x: x[1])\\n\\tunit_count = 0\\n\\twhile boxTypes and truckSize > 0:\\n\\t\\ttop = boxTypes.pop()\\n\\t\\tbox_count = min(truckSize, top[0])\\n\\t\\tunit_count += box_count * top[1]\\n\\t\\ttruckSize -= box_count\\n\\n\\treturn unit_count\\n```\\n\\t",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\theap = []\\n\\tfor box, count in boxTypes:\\n\\t\\t# push the count of each box in the max-heap\\n\\t\\theapq.heappush(heap, [-count, box])\\n\\n\\tunit_count = 0\\n\\twhile heap and truckSize > 0:\\n\\t\\ttop = heapq.heappop(heap)\\n\\t\\tbox_count = min(truckSize, top[1])\\n\\t\\tunit_count += box_count * (-1 * top[0])\\n\\t\\ttruckSize -= box_count\\n\\n\\treturn unit_count\\n```\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n\\tboxTypes.sort(key=lambda x: x[1])\\n\\tunit_count = 0\\n\\twhile boxTypes and truckSize > 0:\\n\\t\\ttop = boxTypes.pop()\\n\\t\\tbox_count = min(truckSize, top[0])\\n\\t\\tunit_count += box_count * top[1]\\n\\t\\ttruckSize -= box_count\\n\\n\\treturn unit_count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1001016,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 24 ms, faster than 100.00% of Go online submissions for Maximum Units on a Truck.\\nMemory Usage: 6.1 MB, less than 100.00% of Go online submissions for Maximum Units on a Truck.\\n\\n```go\\nfunc maximumUnits(boxTypes [][]int, truckSize int) int {\\n    sort.Slice(boxTypes, func(a, b int) bool { return boxTypes[a][1] > boxTypes[b][1] })\\n    ans := 0\\n    for _, box := range boxTypes {\\n        if box[0] <= truckSize {\\n            ans += box[0] * box[1]\\n            truckSize -= box[0]\\n        } else {\\n            ans += box[1] * truckSize\\n            break\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maximumUnits(boxTypes [][]int, truckSize int) int {\\n    sort.Slice(boxTypes, func(a, b int) bool { return boxTypes[a][1] > boxTypes[b][1] })\\n    ans := 0\\n    for _, box := range boxTypes {\\n        if box[0] <= truckSize {\\n            ans += box[0] * box[1]\\n            truckSize -= box[0]\\n        } else {\\n            ans += box[1] * truckSize\\n            break\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000041,
                "title": "c-100",
                "content": "```\\npublic int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        Array.Sort(boxTypes, (a, b) => {return b[1] - a[1];});\\n        int count = 0;\\n        \\n        foreach(var type in boxTypes)\\n        {\\n            int num = Math.Min(type[0], truckSize);\\n            count += num*type[1];\\n            \\n            if(truckSize < num)\\n                break;\\n            truckSize -= num;            \\n        } \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        Array.Sort(boxTypes, (a, b) => {return b[1] - a[1];});\\n        int count = 0;\\n        \\n        foreach(var type in boxTypes)\\n        {\\n            int num = Math.Min(type[0], truckSize);\\n            count += num*type[1];\\n            \\n            if(truckSize < num)\\n                break;\\n            truckSize -= num;            \\n        } \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999487,
                "title": "java-sort-and-greedy",
                "content": "```\\n    public int maximumUnits(int[][] bt, int ts) {\\n        Arrays.sort(bt, (a, b) -> b[1] - a[1]);  // sort by unit per type;\\n        int res = 0, cap = ts, i = 0, load = 0;  // cap for rest of capactiy of the truck, load for num of boxes per load; \\n        while (cap > 0 && i < bt.length) {  // each loop by one type of boxes, from max to min;\\n            load = Math.min(cap, bt[i][0]);    // greedy try loading all current max unit type of boxes\\n            cap -= load;   // res of the capacity\\n            res += load * bt[i++][1];  //units added by this loading\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maximumUnits(int[][] bt, int ts) {\\n        Arrays.sort(bt, (a, b) -> b[1] - a[1]);  // sort by unit per type;\\n        int res = 0, cap = ts, i = 0, load = 0;  // cap for rest of capactiy of the truck, load for num of boxes per load; \\n        while (cap > 0 && i < bt.length) {  // each loop by one type of boxes, from max to min;\\n            load = Math.min(cap, bt[i][0]);    // greedy try loading all current max unit type of boxes\\n            cap -= load;   // res of the capacity\\n            res += load * bt[i++][1];  //units added by this loading\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999187,
                "title": "easy-to-understand-sorting-and-select",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n        int res = 0;\\n        for(int i = 0; i < boxTypes.length; i++) {\\n            res += Math.min(truckSize, boxTypes[i][0]) * boxTypes[i][1];\\n            truckSize -= Math.min(truckSize, boxTypes[i][0]);\\n            if(truckSize == 0)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n        int res = 0;\\n        for(int i = 0; i < boxTypes.length; i++) {\\n            res += Math.min(truckSize, boxTypes[i][0]) * boxTypes[i][1];\\n            truckSize -= Math.min(truckSize, boxTypes[i][0]);\\n            if(truckSize == 0)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321424,
                "title": "easiest-solution-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: -x[1])\\n        totalnumber=0\\n        for numberboxes,units in boxTypes:\\n            if truckSize<=numberboxes:\\n                totalnumber+=(truckSize*units)\\n                break\\n            totalnumber+=(numberboxes*units)\\n            truckSize-=numberboxes\\n        return totalnumber\\n           #plz do upvote it will be greatful if u did it\\n     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: -x[1])\\n        totalnumber=0\\n        for numberboxes,units in boxTypes:\\n            if truckSize<=numberboxes:\\n                totalnumber+=(truckSize*units)\\n                break\\n            totalnumber+=(numberboxes*units)\\n            truckSize-=numberboxes\\n        return totalnumber\\n           #plz do upvote it will be greatful if u did it\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064418,
                "title": "java-simple-easy-and-fast-solution",
                "content": "\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes,(a,b)->b[1]-a[1]); // Sort on basis of quantity \\n        int ans  = 0 ;\\n        \\n        for(int []elem : boxTypes){\\n            if(truckSize>=elem[0]){\\n                ans+=elem[0]*elem[1];\\n                truckSize-=elem[0];\\n            }else if (truckSize >0 && truckSize < elem[0]){\\n                ans+=truckSize*elem[1];\\n                truckSize= 0;\\n            }\\n            if(truckSize == 0){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes,(a,b)->b[1]-a[1]); // Sort on basis of quantity \\n        int ans  = 0 ;\\n        \\n        for(int []elem : boxTypes){\\n            if(truckSize>=elem[0]){\\n                ans+=elem[0]*elem[1];\\n                truckSize-=elem[0];\\n            }else if (truckSize >0 && truckSize < elem[0]){\\n                ans+=truckSize*elem[1];\\n                truckSize= 0;\\n            }\\n            if(truckSize == 0){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2338496,
                "title": "python-3-faster-than-90-easy-to-understand",
                "content": "**Explanation:**\\n\\nI sorted boxTypes in a way that I would go from maximum units per box to minimum.\\nThan i simply just add (units * box) to sum_ while truckSize > 0.\\n\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        sum_ = 0\\n\\t\\t#sorting boxTypes by the second element\\n        boxTypes.sort(key=lambda x:x[1])\\n\\t\\t#reverse because going from max units per box to min units per box\\n        boxTypes.reverse()\\n        for box, units in boxTypes:\\n            if truckSize > box:\\n                truckSize -= box\\n                sum_ += box * units\\n            else:\\n                sum_ += truckSize * units\\n                break\\n        return sum_\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        sum_ = 0\\n\\t\\t#sorting boxTypes by the second element\\n        boxTypes.sort(key=lambda x:x[1])\\n\\t\\t#reverse because going from max units per box to min units per box\\n        boxTypes.reverse()\\n        for box, units in boxTypes:\\n            if truckSize > box:\\n                truckSize -= box\\n                sum_ += box * units\\n            else:\\n                sum_ += truckSize * units\\n                break\\n        return sum_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316583,
                "title": "must-check-it-40-ms-faster-than-96-46-of-c-online-submissions-for-maximum-units-on-a-truck",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE :**\\n```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int limit=0, totalUnits=0, leftBox=0;\\n        priority_queue<pair<int, int>> pq;\\n        for(auto v: boxTypes) {\\n            pq.push({v[1],v[0]});\\n        }\\n        while(!pq.empty() && limit<truckSize) {\\n            if((pq.top().second + limit) < truckSize) {\\n                limit += pq.top().second;\\n                totalUnits += pq.top().first*pq.top().second;\\n            }\\n            else {\\n                leftBox = truckSize - limit;\\n                totalUnits += pq.top().first*leftBox;\\n                limit += leftBox;\\n            }\\n            pq.pop();\\n        }\\n        return totalUnits;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int limit=0, totalUnits=0, leftBox=0;\\n        priority_queue<pair<int, int>> pq;\\n        for(auto v: boxTypes) {\\n            pq.push({v[1],v[0]});\\n        }\\n        while(!pq.empty() && limit<truckSize) {\\n            if((pq.top().second + limit) < truckSize) {\\n                limit += pq.top().second;\\n                totalUnits += pq.top().first*pq.top().second;\\n            }\\n            else {\\n                leftBox = truckSize - limit;\\n                totalUnits += pq.top().first*leftBox;\\n                limit += leftBox;\\n            }\\n            pq.pop();\\n        }\\n        return totalUnits;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245106,
                "title": "javascript-1710-maximum-units-on-a-truck",
                "content": "```\\n/**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n   //sort the array in non-increasing (descending i.e highest to Lowest)\\n    boxTypes.sort((a,b)=>{\\n       return b[1]-a[1]\\n    })\\n    // initialize max unit equal to zero\\n    let maxUnit = 0;\\n    \\n    for(let i = 0; i < boxTypes.length; i++){\\n        //first check if truckSize is less than or eq to zero because it (truckSize) will keep decrementing and break out of the loop\\n        if(truckSize <= 0){\\n            break;\\n        }\\n        //if truckSize is greater than numberOfBoxes (boxTypes[i][0]) of type i , \\n        if(truckSize > boxTypes[i][0]){\\n            // multiply numberOfBoxes (boxTypes[i][0]) and  numberOfUnitsPerBox (boxTypes[i][1]) , add to maxUnit\\n            maxUnit += boxTypes[i][0] * boxTypes[i][1]\\n            // decrement truckSize by numberOfBoxes (boxTypes[i][0])\\n            truckSize -= boxTypes[i][0]\\n        }\\n        else{\\n            // since truckSize is less than numberOfBoxes (boxTypes[i][0]) of type i, multiply truckSize and  numberOfUnitsPerBox (boxTypes[i][1]) , add to maxUnit\\n            maxUnit += truckSize * boxTypes[i][1]\\n            // decrement truckSize by numberOfBoxes (boxTypes[i][0])\\n            truckSize -= boxTypes[i][0]\\n        }\\n    }\\n    \\n    return maxUnit\\n};\\n\\n\\n// [[5,10],[3,9],[4,7],[2,5]]\\n\\n// 10 truckSize\\n// maxUnit = 0\\n// 1st iteration truck size (10) is greater than 5, maxUnit = maxUnit + (5*10), truckSize = truckSize(10) -5 \\n// 2nd iteration, truckSize is now 5 and it is greater than 3, maxUnit = maxUnit + (3*9),truckSize = truckSize (5) - 3\\n// 3rd iteration, truckSize is now 2 and it is greater than 3, maxUnit = maxUnit + (2*7),truckSize = truckSize(2) - 4\\n\\n// 4th iteration truckSize is now -2\\n\\n// break out of loop if truckSize is less than or eq to zero and now truckSize is -2 hence we breakout of loop and return maxUnit\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n   //sort the array in non-increasing (descending i.e highest to Lowest)\\n    boxTypes.sort((a,b)=>{\\n       return b[1]-a[1]\\n    })\\n    // initialize max unit equal to zero\\n    let maxUnit = 0;\\n    \\n    for(let i = 0; i < boxTypes.length; i++){\\n        //first check if truckSize is less than or eq to zero because it (truckSize) will keep decrementing and break out of the loop\\n        if(truckSize <= 0){\\n            break;\\n        }\\n        //if truckSize is greater than numberOfBoxes (boxTypes[i][0]) of type i , \\n        if(truckSize > boxTypes[i][0]){\\n            // multiply numberOfBoxes (boxTypes[i][0]) and  numberOfUnitsPerBox (boxTypes[i][1]) , add to maxUnit\\n            maxUnit += boxTypes[i][0] * boxTypes[i][1]\\n            // decrement truckSize by numberOfBoxes (boxTypes[i][0])\\n            truckSize -= boxTypes[i][0]\\n        }\\n        else{\\n            // since truckSize is less than numberOfBoxes (boxTypes[i][0]) of type i, multiply truckSize and  numberOfUnitsPerBox (boxTypes[i][1]) , add to maxUnit\\n            maxUnit += truckSize * boxTypes[i][1]\\n            // decrement truckSize by numberOfBoxes (boxTypes[i][0])\\n            truckSize -= boxTypes[i][0]\\n        }\\n    }\\n    \\n    return maxUnit\\n};\\n\\n\\n// [[5,10],[3,9],[4,7],[2,5]]\\n\\n// 10 truckSize\\n// maxUnit = 0\\n// 1st iteration truck size (10) is greater than 5, maxUnit = maxUnit + (5*10), truckSize = truckSize(10) -5 \\n// 2nd iteration, truckSize is now 5 and it is greater than 3, maxUnit = maxUnit + (3*9),truckSize = truckSize (5) - 3\\n// 3rd iteration, truckSize is now 2 and it is greater than 3, maxUnit = maxUnit + (2*7),truckSize = truckSize(2) - 4\\n\\n// 4th iteration truckSize is now -2\\n\\n// break out of loop if truckSize is less than or eq to zero and now truckSize is -2 hence we breakout of loop and return maxUnit\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2237192,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> a, vector<int> b){\\n        return a[1] > b[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), compare);\\n        int maxUnits = 0;\\n        \\n        for(auto it: boxTypes){\\n            if(truckSize < it[0]){\\n                return maxUnits + truckSize* it[1];\\n            }\\n            maxUnits += it[0] * it[1];\\n            truckSize -= it[0];\\n        }\\n        return maxUnits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> a, vector<int> b){\\n        return a[1] > b[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), compare);\\n        int maxUnits = 0;\\n        \\n        for(auto it: boxTypes){\\n            if(truckSize < it[0]){\\n                return maxUnits + truckSize* it[1];\\n            }\\n            maxUnits += it[0] * it[1];\\n            truckSize -= it[0];\\n        }\\n        return maxUnits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221828,
                "title": "c-greedy-fractional-knapsack",
                "content": "```\\nclass Solution {\\npublic:    \\n    static bool cmp(vector<int>& a, vector<int>& b) {\\n    return a[1] > b[1];   \\n    }\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);\\n        int k =boxTypes.size();\\n        int unit =0;\\n        for(int i =0 ; i<k ;i++){\\n            if(truckSize >= boxTypes[i][0]){\\n                truckSize -= boxTypes[i][0];\\n                unit += boxTypes[i][0]*boxTypes[i][1];\\n            }\\n            else{\\n                \\n                unit +=truckSize*boxTypes[i][1];\\n                break;\\n            }\\n        }\\n       return unit; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    static bool cmp(vector<int>& a, vector<int>& b) {\\n    return a[1] > b[1];   \\n    }\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);\\n        int k =boxTypes.size();\\n        int unit =0;\\n        for(int i =0 ; i<k ;i++){\\n            if(truckSize >= boxTypes[i][0]){\\n                truckSize -= boxTypes[i][0];\\n                unit += boxTypes[i][0]*boxTypes[i][1];\\n            }\\n            else{\\n                \\n                unit +=truckSize*boxTypes[i][1];\\n                break;\\n            }\\n        }\\n       return unit; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794302,
                "title": "python3-priority-queue-max-heap-greedy-algorithm",
                "content": "TC: O(nlogk)\\nSC: O(n)\\n\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        unit, res = truckSize, 0\\n        max_heap = []\\n        \\n        for box in boxTypes:\\n            heappush(max_heap, (-box[1], box[0]))\\n            \\n        while max_heap and unit:\\n            box = heappop(max_heap)\\n            qual, quan = -box[0], box[1]\\n            \\n            if quan <= unit:\\n                res += qual * quan\\n                unit -= quan\\n            else:\\n                res += qual * unit\\n                unit -= unit\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        unit, res = truckSize, 0\\n        max_heap = []\\n        \\n        for box in boxTypes:\\n            heappush(max_heap, (-box[1], box[0]))\\n            \\n        while max_heap and unit:\\n            box = heappop(max_heap)\\n            qual, quan = -box[0], box[1]\\n            \\n            if quan <= unit:\\n                res += qual * quan\\n                unit -= quan\\n            else:\\n                res += qual * unit\\n                unit -= unit\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1519200,
                "title": "simple-to-understand-greedy-basic-loop-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        var result = 0;\\n        \\n        // Sort the box types by number of units per box in descending order\\n        Array.Sort(boxTypes, (a, b) => {\\n           return b[1] - a[1]; \\n        });\\n        \\n        // Determine how many units can be added to the truck\\n        var remainingSize = truckSize;\\n        foreach (var type in boxTypes) {\\n            // Get the box count and units per box\\n            var boxCount = type[0];\\n            var unitsPerBox = type[1];\\n            \\n            // Check to see if theres enough room to add more boxes\\n            var adjustedBoxCount = 0;            \\n            if (remainingSize - boxCount > 0) {\\n                adjustedBoxCount = boxCount; // All boxes can be added\\n            } else {\\n                adjustedBoxCount = remainingSize; // Only the remaining amount can be added\\n            }\\n            \\n            // Add the units to the result\\n            result += adjustedBoxCount * unitsPerBox;\\n            \\n            // Adjust remaining truck size with the added boxes\\n            remainingSize -= adjustedBoxCount;\\n            \\n            // Exit if there is no more room remaining\\n            if (remainingSize == 0) {\\n                break;\\n            }\\n        }                \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        var result = 0;\\n        \\n        // Sort the box types by number of units per box in descending order\\n        Array.Sort(boxTypes, (a, b) => {\\n           return b[1] - a[1]; \\n        });\\n        \\n        // Determine how many units can be added to the truck\\n        var remainingSize = truckSize;\\n        foreach (var type in boxTypes) {\\n            // Get the box count and units per box\\n            var boxCount = type[0];\\n            var unitsPerBox = type[1];\\n            \\n            // Check to see if theres enough room to add more boxes\\n            var adjustedBoxCount = 0;            \\n            if (remainingSize - boxCount > 0) {\\n                adjustedBoxCount = boxCount; // All boxes can be added\\n            } else {\\n                adjustedBoxCount = remainingSize; // Only the remaining amount can be added\\n            }\\n            \\n            // Add the units to the result\\n            result += adjustedBoxCount * unitsPerBox;\\n            \\n            // Adjust remaining truck size with the added boxes\\n            remainingSize -= adjustedBoxCount;\\n            \\n            // Exit if there is no more room remaining\\n            if (remainingSize == 0) {\\n                break;\\n            }\\n        }                \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271689,
                "title": "simple-javascript-explained-solution",
                "content": "```\\n/**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    /*\\n    Sort the boxes by their unit size in descending order\\n    Keep taking all the boxes until we can\\n    If we can\\'t take all the boxes then take the maximum boxes of the current box type which we can take. Exit the loop\\n    */\\n    let unitCount=0,boxesTaken;\\n    boxTypes.sort(function(a,b){return b[1]-a[1]});//Sort the boxes by their unit size in descending order\\n    for(let i=0;i<boxTypes.length;i++){\\n        if(truckSize-boxTypes[i][0]>=0){//Keep taking all the boxes until we can\\n            truckSize = truckSize-boxTypes[i][0];\\n            unitCount = unitCount+(boxTypes[i][0]*boxTypes[i][1]);\\n        }else{//If we can\\'t take all the boxes then take the maximum boxes of the current box type which we can take. Exit the loop\\n            boxesTaken = truckSize;\\n            truckSize=truckSize-boxesTaken;//This will be zero\\n            unitCount = unitCount+(boxesTaken*boxTypes[i][1]);\\n            break;\\n        }\\n    }\\n    return unitCount;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    /*\\n    Sort the boxes by their unit size in descending order\\n    Keep taking all the boxes until we can\\n    If we can\\'t take all the boxes then take the maximum boxes of the current box type which we can take. Exit the loop\\n    */\\n    let unitCount=0,boxesTaken;\\n    boxTypes.sort(function(a,b){return b[1]-a[1]});//Sort the boxes by their unit size in descending order\\n    for(let i=0;i<boxTypes.length;i++){\\n        if(truckSize-boxTypes[i][0]>=0){//Keep taking all the boxes until we can\\n            truckSize = truckSize-boxTypes[i][0];\\n            unitCount = unitCount+(boxTypes[i][0]*boxTypes[i][1]);\\n        }else{//If we can\\'t take all the boxes then take the maximum boxes of the current box type which we can take. Exit the loop\\n            boxesTaken = truckSize;\\n            truckSize=truckSize-boxesTaken;//This will be zero\\n            unitCount = unitCount+(boxesTaken*boxTypes[i][1]);\\n            break;\\n        }\\n    }\\n    return unitCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1271469,
                "title": "python-easy-greedy-sorting-o-nlogn-counting-sort-o-n",
                "content": "**First Solution**\\n* `Time Complexity` : `O(n*log(n))` for in- built sorting\\n* `Space Comlexity` : `O(1)` \\n\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key = lambda x: -x[1])\\n        ans = 0\\n        for boxes, units in boxTypes:\\n            if boxes<=truckSize:\\n                ans += boxes*units\\n                truckSize -= boxes\\n            else:\\n                ans += truckSize*units\\n                return ans\\n        return ans\\n```\\n\\n**Second Solution**\\n* `Time Complexity` : `O(n+mx)` for Counting sort \\xA0\\n* `Space Comlexity` : `O(mx)` where mx is maximum unit in **boxTypes**\\n\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        #using counting sort\\n        mx = max(units for _, units in boxTypes)\\n        arr = [0]*(mx+1)\\n        #Now storing no. of boxes holding that unit\\n        for boxes, units in boxTypes:\\n            arr[units] += boxes\\n        ans = 0\\n        #Since maximum units are at end we traverse in reverse\\n        for units in range(mx, 0, -1):\\n            boxes = arr[units]\\n            if boxes<=truckSize:\\n                ans += boxes*units\\n                truckSize -= boxes\\n            else:\\n                ans += truckSize*units\\n                return ans\\n        return ans\\n```\\n\\n\\n*please upvote if you like the solution and comment for queries*. \\xA0 \\xA0",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key = lambda x: -x[1])\\n        ans = 0\\n        for boxes, units in boxTypes:\\n            if boxes<=truckSize:\\n                ans += boxes*units\\n                truckSize -= boxes\\n            else:\\n                ans += truckSize*units\\n                return ans\\n        return ans\\n```\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        #using counting sort\\n        mx = max(units for _, units in boxTypes)\\n        arr = [0]*(mx+1)\\n        #Now storing no. of boxes holding that unit\\n        for boxes, units in boxTypes:\\n            arr[units] += boxes\\n        ans = 0\\n        #Since maximum units are at end we traverse in reverse\\n        for units in range(mx, 0, -1):\\n            boxes = arr[units]\\n            if boxes<=truckSize:\\n                ans += boxes*units\\n                truckSize -= boxes\\n            else:\\n                ans += truckSize*units\\n                return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271357,
                "title": "c-simple-and-easy-solution-using-custom-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> a, vector<int> b) {\\n        return a[1] > b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), compare);\\n        int res = 0;\\n        \\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            int tmp = min(truckSize, boxTypes[i][0]);\\n            truckSize -= tmp;\\n            res += tmp*boxTypes[i][1];\\n\\t\\t\\t\\n            if (!truckSize) return res;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> a, vector<int> b) {\\n        return a[1] > b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), compare);\\n        int res = 0;\\n        \\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            int tmp = min(truckSize, boxTypes[i][0]);\\n            truckSize -= tmp;\\n            res += tmp*boxTypes[i][1];\\n\\t\\t\\t\\n            if (!truckSize) return res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186440,
                "title": "ruby-all-boxes-have-the-same-size",
                "content": "## Leetcode: 1710. Maximum Units on a Truck.\\n\\n\\n**Ruby: All boxes have the same size.**\\n\\nAll boxes have the same size but contain different amount of units, need to sort boxes so ones with maximum amount of units are first, and start to pick up them into the truck saving amout of units loaded. \\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1710. Maximum Units on a Truck.\\n# https://leetcode.com/problems/maximum-units-on-a-truck/\\n# Runtime: 52 ms, faster than 100.00% of Ruby online submissions for Maximum Units on a Truck.\\n# Memory Usage: 210.3 MB, less than 96.30% of Ruby online submissions for Maximum Units on a Truck.\\n# Thanks God!\\n# @param {Integer[][]} box_types\\n# @param {Integer} truck_size\\n# @return {Integer}\\ndef maximum_units(box_types, truck_size)\\n    x = box_types.sort_by{|(a,b)| -b}\\n    count = 0\\n    x.each do |(n,units)|\\n        if truck_size >= n\\n            truck_size -= n\\n            count += (n*units)\\n        else\\n            count += truck_size * units\\n            break\\n        end\\n    end\\n    count\\nend\\n```\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1710. Maximum Units on a Truck.\\n# https://leetcode.com/problems/maximum-units-on-a-truck/\\n# Runtime: 52 ms, faster than 100.00% of Ruby online submissions for Maximum Units on a Truck.\\n# Memory Usage: 210.3 MB, less than 96.30% of Ruby online submissions for Maximum Units on a Truck.\\n# Thanks God!\\n# @param {Integer[][]} box_types\\n# @param {Integer} truck_size\\n# @return {Integer}\\ndef maximum_units(box_types, truck_size)\\n    x = box_types.sort_by{|(a,b)| -b}\\n    count = 0\\n    x.each do |(n,units)|\\n        if truck_size >= n\\n            truck_size -= n\\n            count += (n*units)\\n        else\\n            count += truck_size * units\\n            break\\n        end\\n    end\\n    count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1112196,
                "title": "java-solution-faster-98",
                "content": "JAVA CODE IS:\\n#     \\n```\\n\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n      //BOXTYPE : #boxes,#units per box\\n        int res=0;\\n        Arrays.sort(boxTypes,(a,b)-> b[1]-a[1]);\\n        for(int i=0;i<boxTypes.length;i++){\\n            res+=(truckSize >= boxTypes[i][0] ? boxTypes[i][0]*boxTypes[i][1] : truckSize*boxTypes[i][1]);\\n            truckSize=(boxTypes[i][0]>=truckSize ? 0 : truckSize-boxTypes[i][0]);\\n            if(truckSize==0) return res;\\n        }\\n        return res;\\n    }\\n}\\n```\\nTIME : O(nlogn)\\nSPACE : O(1)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n      //BOXTYPE : #boxes,#units per box\\n        int res=0;\\n        Arrays.sort(boxTypes,(a,b)-> b[1]-a[1]);\\n        for(int i=0;i<boxTypes.length;i++){\\n            res+=(truckSize >= boxTypes[i][0] ? boxTypes[i][0]*boxTypes[i][1] : truckSize*boxTypes[i][1]);\\n            truckSize=(boxTypes[i][0]>=truckSize ? 0 : truckSize-boxTypes[i][0]);\\n            if(truckSize==0) return res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070990,
                "title": "c-solution",
                "content": "**Intition**\\nAlways start with the boxes that have the most units.\\n\\n**Complexity**\\n- Time: O(NlogN) for the sorting part.\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        if(boxTypes == null || boxTypes.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(boxTypes, (a,b) => b[1] - a[1]);\\n        int res = 0, i = 0;\\n        while(truckSize > 0 && i < boxTypes.Length)\\n        {\\n            int cnt = Math.Min(truckSize, boxTypes[i][0]);     \\n            res += cnt * boxTypes[i][1];\\n            truckSize -= cnt;\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        if(boxTypes == null || boxTypes.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(boxTypes, (a,b) => b[1] - a[1]);\\n        int res = 0, i = 0;\\n        while(truckSize > 0 && i < boxTypes.Length)\\n        {\\n            int cnt = Math.Min(truckSize, boxTypes[i][0]);     \\n            res += cnt * boxTypes[i][1];\\n            truckSize -= cnt;\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001205,
                "title": "o-nlog-n-intuitive-solution",
                "content": "```\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    boxTypes.sort((a, b) => b[1] - a[1]);\\n    let max = 0;\\n    for (const [numberOfBoxes,numberOfUnistsPerBox] of boxTypes) {\\n        if (numberOfBoxes>=truckSize) {\\n            max+=(truckSize*numberOfUnistsPerBox);\\n            return max;\\n        }\\n        else {\\n            max+=(numberOfBoxes*numberOfUnistsPerBox);\\n            truckSize-=numberOfBoxes;\\n        }\\n    }\\n    return max;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    boxTypes.sort((a, b) => b[1] - a[1]);\\n    let max = 0;\\n    for (const [numberOfBoxes,numberOfUnistsPerBox] of boxTypes) {\\n        if (numberOfBoxes>=truckSize) {\\n            max+=(truckSize*numberOfUnistsPerBox);\\n            return max;\\n        }\\n        else {\\n            max+=(numberOfBoxes*numberOfUnistsPerBox);\\n            truckSize-=numberOfBoxes;\\n        }\\n    }\\n    return max;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999888,
                "title": "java-greedy-100-faster",
                "content": "```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n        int res = 0;\\n        \\n        for (int i = 0; i < boxTypes.length && truckSize > 0; i++) {\\n            int min = Math.min(truckSize, boxTypes[i][0]);\\n            truckSize -= min;\\n            res += min * boxTypes[i][1];\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n        int res = 0;\\n        \\n        for (int i = 0; i < boxTypes.length && truckSize > 0; i++) {\\n            int min = Math.min(truckSize, boxTypes[i][0]);\\n            truckSize -= min;\\n            res += min * boxTypes[i][1];\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999155,
                "title": "java-priorityqueue",
                "content": "```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\tPriorityQueue<int[]> queue = new PriorityQueue<>((x,y) -> y[1]-x[1]);\\n\\tfor(int[] boxType: boxTypes) queue.offer(boxType);\\n\\tint result = 0;\\n\\twhile(truckSize > 0 && !queue.isEmpty()) {\\n\\t\\tint[] boxType = queue.poll();\\n\\t\\tresult += Math.min(boxType[0], truckSize) * boxType[1];\\n\\t\\ttruckSize -= boxType[0];\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\tPriorityQueue<int[]> queue = new PriorityQueue<>((x,y) -> y[1]-x[1]);\\n\\tfor(int[] boxType: boxTypes) queue.offer(boxType);\\n\\tint result = 0;\\n\\twhile(truckSize > 0 && !queue.isEmpty()) {\\n\\t\\tint[] boxType = queue.poll();\\n\\t\\tresult += Math.min(boxType[0], truckSize) * boxType[1];\\n\\t\\ttruckSize -= boxType[0];\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999108,
                "title": "python-easy-solution-with-explanation-accepted-nlogn",
                "content": "We need to find the max no. of units, as we already know the no. of units per box, we can sort the boxTypes by the no. of units per box and thats it. Now just iterate, susbstract the no. of boxes till 0\\n\\n```\\n\\tdef maximumUnits(boxTypes, truckSize):\\n        boxTypes.sort(key = lambda x: (-x[1], x[0]))\\n        count = 0\\n        \\n        i = 0\\n        while i < len(boxTypes) and truckSize > 0:\\n            if boxTypes[i][0] <= truckSize:\\n                truckSize -= boxTypes[i][0]\\n                count += boxTypes[i][0] * boxTypes[i][1]\\n            else:\\n                count += truckSize * boxTypes[i][1]\\n                truckSize -= truckSize\\n                \\n            i += 1\\n                \\n        return count",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "We need to find the max no. of units, as we already know the no. of units per box, we can sort the boxTypes by the no. of units per box and thats it. Now just iterate, susbstract the no. of boxes till 0\\n\\n```\\n\\tdef maximumUnits(boxTypes, truckSize):\\n        boxTypes.sort(key = lambda x: (-x[1], x[0]))\\n        count = 0\\n        \\n        i = 0\\n        while i < len(boxTypes) and truckSize > 0:\\n            if boxTypes[i][0] <= truckSize:\\n                truckSize -= boxTypes[i][0]\\n                count += boxTypes[i][0] * boxTypes[i][1]\\n            else:\\n                count += truckSize * boxTypes[i][1]\\n                truckSize -= truckSize\\n                \\n            i += 1\\n                \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 3833159,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Sorting\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        vector<pair<int, int>> v;\\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            v.push_back({boxTypes[i][1], boxTypes[i][0]});\\n        }\\n        sort(v.rbegin(), v.rend());\\n        int ans = 0;\\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            if (v[i].second <= truckSize) {\\n                ans += v[i].first * v[i].second;\\n                truckSize -= v[i].second;\\n            }\\n            else {\\n                ans += v[i].first * truckSize;\\n                truckSize = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        vector<pair<int, int>> v;\\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            v.push_back({boxTypes[i][1], boxTypes[i][0]});\\n        }\\n        sort(v.rbegin(), v.rend());\\n        int ans = 0;\\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            if (v[i].second <= truckSize) {\\n                ans += v[i].first * v[i].second;\\n                truckSize -= v[i].second;\\n            }\\n            else {\\n                ans += v[i].first * truckSize;\\n                truckSize = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259961,
                "title": "c-soln-brute-force-approach-greedy-approach-updated-beats-99-in-memory-consumption",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n      int row = boxTypes.size();\\n      int ans = 0;\\n      int n = truckSize;\\n      int temp = INT_MIN;\\n      int unit = 0;\\n\\n\\n      for(int i = 0;i < row;i++){\\n          unit  = boxTypes[i][1];\\n          temp = boxTypes[i][0];\\n        for(int j = i+1; j < row;j++){\\n            if(unit < boxTypes[j][1]){\\n              swap(boxTypes[i][0],boxTypes[j][0]);\\n              swap(boxTypes[i][1],boxTypes[j][1]);\\n              unit  = boxTypes[i][1];\\n              temp = boxTypes[i][0];\\n            }\\n            else if(unit == boxTypes[j][1] ){\\n                if(temp > boxTypes[j][0]){\\n                    swap(boxTypes[i][0],boxTypes[j][0]);\\n                    swap(boxTypes[i][1],boxTypes[j][1]);\\n                    unit  = boxTypes[i][1];\\n                    temp = boxTypes[i][0];\\n                }\\n            }\\n        }\\n      }\\n      for(int i = 0; i < row;i++){\\n          if(boxTypes[i][0] >= n){\\n              ans += n*boxTypes[i][1];\\n              n = 0;\\n              break;\\n          }else{\\n               n = n - boxTypes[i][0];\\n              ans += boxTypes[i][0]*boxTypes[i][1];\\n          }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```\\n# Code 2 (Greedy Approach)\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        vector<pair<int,int>> mp;\\n        int ans = 0;\\n        \\n        for(int i = 0;i < boxTypes.size();i++)\\n            mp.push_back(make_pair(boxTypes[i][1],boxTypes[i][0]));\\n        \\n        sort(mp.begin(),mp.end(),greater<pair<int,int>> ());\\n\\n        for(int i = 0; i < mp.size();i++){\\n            if(mp[i].second <= truckSize){\\n                ans += mp[i].first * mp[i].second;\\n                truckSize -= mp[i].second;\\n            }\\n            else{\\n                ans += mp[i].first * truckSize;\\n                truckSize = 0;\\n                break; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n      int row = boxTypes.size();\\n      int ans = 0;\\n      int n = truckSize;\\n      int temp = INT_MIN;\\n      int unit = 0;\\n\\n\\n      for(int i = 0;i < row;i++){\\n          unit  = boxTypes[i][1];\\n          temp = boxTypes[i][0];\\n        for(int j = i+1; j < row;j++){\\n            if(unit < boxTypes[j][1]){\\n              swap(boxTypes[i][0],boxTypes[j][0]);\\n              swap(boxTypes[i][1],boxTypes[j][1]);\\n              unit  = boxTypes[i][1];\\n              temp = boxTypes[i][0];\\n            }\\n            else if(unit == boxTypes[j][1] ){\\n                if(temp > boxTypes[j][0]){\\n                    swap(boxTypes[i][0],boxTypes[j][0]);\\n                    swap(boxTypes[i][1],boxTypes[j][1]);\\n                    unit  = boxTypes[i][1];\\n                    temp = boxTypes[i][0];\\n                }\\n            }\\n        }\\n      }\\n      for(int i = 0; i < row;i++){\\n          if(boxTypes[i][0] >= n){\\n              ans += n*boxTypes[i][1];\\n              n = 0;\\n              break;\\n          }else{\\n               n = n - boxTypes[i][0];\\n              ans += boxTypes[i][0]*boxTypes[i][1];\\n          }\\n      }\\n\\n      return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        vector<pair<int,int>> mp;\\n        int ans = 0;\\n        \\n        for(int i = 0;i < boxTypes.size();i++)\\n            mp.push_back(make_pair(boxTypes[i][1],boxTypes[i][0]));\\n        \\n        sort(mp.begin(),mp.end(),greater<pair<int,int>> ());\\n\\n        for(int i = 0; i < mp.size();i++){\\n            if(mp[i].second <= truckSize){\\n                ans += mp[i].first * mp[i].second;\\n                truckSize -= mp[i].second;\\n            }\\n            else{\\n                ans += mp[i].first * truckSize;\\n                truckSize = 0;\\n                break; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107595,
                "title": "c-o-nlogn-solution-beats-90",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        for(int i=0;i<boxTypes.size();i++){\\n            swap(boxTypes[i][0],boxTypes[i][1]);\\n        }\\n        sort(boxTypes.begin(),boxTypes.end());\\n        int ans=0;\\n        for(int i=boxTypes.size()-1;i>=0;i--){\\n            if(boxTypes[i][1]<=truckSize){\\n                truckSize-=boxTypes[i][1];\\n                ans+=(boxTypes[i][1]*boxTypes[i][0]);\\n            }\\n            else if(truckSize!=0 && boxTypes[i][1]>truckSize){\\n                ans+=(truckSize*boxTypes[i][0]);\\n                truckSize=0;\\n                break;\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        for(int i=0;i<boxTypes.size();i++){\\n            swap(boxTypes[i][0],boxTypes[i][1]);\\n        }\\n        sort(boxTypes.begin(),boxTypes.end());\\n        int ans=0;\\n        for(int i=boxTypes.size()-1;i>=0;i--){\\n            if(boxTypes[i][1]<=truckSize){\\n                truckSize-=boxTypes[i][1];\\n                ans+=(boxTypes[i][1]*boxTypes[i][0]);\\n            }\\n            else if(truckSize!=0 && boxTypes[i][1]>truckSize){\\n                ans+=(truckSize*boxTypes[i][0]);\\n                truckSize=0;\\n                break;\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841257,
                "title": "max-units-on-truck-ez-solution",
                "content": "**plz Upvote if it was helpful \\uD83D\\uDC4D**\\n\\n# Intuition\\nThe most optimal way to get the most units onto the truck is at every step, if you can, put on a box with the most units. (a box with 3 units should be loaded onto the truck before a box with only 1 unit).\\n\\n# Approach\\nSort the box types in non-increasing order by how many units they contain. For each box, load on as many boxes as possible onto the truck, and if the truck is full, the answer is how many units you currently have.\\n\\n# Complexity\\n- Time complexity:\\n`O(N log N)` for the sort + `O(N)` for looping through all the box types.\\n\\n- Space complexity:\\n`O(N)` for the sorted box types, `O(1)` for the other variables (how many boxes the truck can still hold, the units used so far).\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumUnits(boxTypes: Array<IntArray>, truckSize: Int): Int {\\n        val sort = boxTypes.sortedBy { -it[1] }\\n        var left = truckSize\\n        var units = 0\\n        for (i in sort) {\\n            var amountLeft = i[0]\\n            while (left > 0 && amountLeft > 0) {\\n                left--\\n                units += i[1]\\n                amountLeft--\\n            }\\n            if (left == 0) return units\\n        }\\n        return units\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumUnits(boxTypes: Array<IntArray>, truckSize: Int): Int {\\n        val sort = boxTypes.sortedBy { -it[1] }\\n        var left = truckSize\\n        var units = 0\\n        for (i in sort) {\\n            var amountLeft = i[0]\\n            while (left > 0 && amountLeft > 0) {\\n                left--\\n                units += i[1]\\n                amountLeft--\\n            }\\n            if (left == 0) return units\\n        }\\n        return units\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818318,
                "title": "python-solution",
                "content": "```\\ndef maximumUnits(self, boxTypes, truckSize):\\n        \"\"\"\\n        :type boxTypes: List[List[int]]\\n        :type truckSize: int\\n        :rtype: int\\n        \"\"\"\\n        heap = []\\n        for i in range(len(boxTypes)):\\n            heappush(heap, (-boxTypes[i][1], boxTypes[i][0]))\\n        tot = 0\\n        while truckSize>0 and heap:\\n            units, num = heappop(heap)\\n            val = truckSize-num\\n            if val<0:\\n                num = truckSize\\n            tot+= -units*num\\n            truckSize = val\\n        return tot",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maximumUnits(self, boxTypes, truckSize):\\n        \"\"\"\\n        :type boxTypes: List[List[int]]\\n        :type truckSize: int\\n        :rtype: int\\n        \"\"\"\\n        heap = []\\n        for i in range(len(boxTypes)):\\n            heappush(heap, (-boxTypes[i][1], boxTypes[i][0]))\\n        tot = 0\\n        while truckSize>0 and heap:\\n            units, num = heappop(heap)\\n            val = truckSize-num\\n            if val<0:\\n                num = truckSize\\n            tot+= -units*num\\n            truckSize = val\\n        return tot",
                "codeTag": "Python3"
            },
            {
                "id": 2768259,
                "title": "easy-java-solution-using-comparator",
                "content": "```\\nclass boxes{\\n    int no_of_box;\\n    int box_per_unit;\\n    public boxes(int no_of_box,int box_per_unit){\\n        this.no_of_box=no_of_box;\\n        this.box_per_unit=box_per_unit;\\n    }\\n}\\nclass mycompareforboxes implements Comparator<boxes>{\\n    public int compare(boxes item1,boxes item2){\\nif(item1.box_per_unit<item2.box_per_unit) {return 1;}\\nif(item1.box_per_unit>item2.box_per_unit) {return -1;}\\nelse return 0;\\n    }\\n}\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n         int no_of_box[] = new int[boxTypes.length];\\n        for (int i = 0; i < boxTypes.length; i++) {\\n            no_of_box[i] = boxTypes[i][0];\\n        }\\n        int unit_per_box[] = new int[boxTypes.length];\\n        for (int i = 0; i < boxTypes.length; i++) {\\n            unit_per_box[i] = boxTypes[i][1];\\n        }\\n        ArrayList <boxes> list=new ArrayList<>();\\n        for (int i = 0; i <unit_per_box.length ; i++) {\\n            list.add(new boxes(no_of_box[i],unit_per_box[i] ));\\n        }\\n        mycompareforboxes mc_for_boxes=new mycompareforboxes();\\n        Collections.sort(list,mc_for_boxes);\\n\\n        int total=0;\\n\\n        for (int i = 0; i <list.size() ; i++) {\\n            int box_number=list.get(i).no_of_box;\\n            int box_per_unit=list.get(i).box_per_unit;\\n//            System.out.println(truckSize);\\nif(truckSize-box_number>=0){\\n    truckSize=truckSize-box_number;\\n    total=total+box_per_unit*box_number;\\n}\\nelse {\\n     if(box_number-truckSize>=0){\\ntotal=total +truckSize*box_per_unit;\\ntruckSize=truckSize-truckSize;\\n    }\\n}\\n    }\\n        return total;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass boxes{\\n    int no_of_box;\\n    int box_per_unit;\\n    public boxes(int no_of_box,int box_per_unit){\\n        this.no_of_box=no_of_box;\\n        this.box_per_unit=box_per_unit;\\n    }\\n}\\nclass mycompareforboxes implements Comparator<boxes>{\\n    public int compare(boxes item1,boxes item2){\\nif(item1.box_per_unit<item2.box_per_unit) {return 1;}\\nif(item1.box_per_unit>item2.box_per_unit) {return -1;}\\nelse return 0;\\n    }\\n}\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n         int no_of_box[] = new int[boxTypes.length];\\n        for (int i = 0; i < boxTypes.length; i++) {\\n            no_of_box[i] = boxTypes[i][0];\\n        }\\n        int unit_per_box[] = new int[boxTypes.length];\\n        for (int i = 0; i < boxTypes.length; i++) {\\n            unit_per_box[i] = boxTypes[i][1];\\n        }\\n        ArrayList <boxes> list=new ArrayList<>();\\n        for (int i = 0; i <unit_per_box.length ; i++) {\\n            list.add(new boxes(no_of_box[i],unit_per_box[i] ));\\n        }\\n        mycompareforboxes mc_for_boxes=new mycompareforboxes();\\n        Collections.sort(list,mc_for_boxes);\\n\\n        int total=0;\\n\\n        for (int i = 0; i <list.size() ; i++) {\\n            int box_number=list.get(i).no_of_box;\\n            int box_per_unit=list.get(i).box_per_unit;\\n//            System.out.println(truckSize);\\nif(truckSize-box_number>=0){\\n    truckSize=truckSize-box_number;\\n    total=total+box_per_unit*box_number;\\n}\\nelse {\\n     if(box_number-truckSize>=0){\\ntotal=total +truckSize*box_per_unit;\\ntruckSize=truckSize-truckSize;\\n    }\\n}\\n    }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548401,
                "title": "maximum-units-on-a-truck-with-java-perfect-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t\\t\\tArrays.sort(boxTypes, (a, b) -> Integer.compare(b[1], a[1]));\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor (int[] box:boxTypes){\\n\\t\\t\\t\\tif (truckSize >= box[0]){\\n\\t\\t\\t\\t\\ttotal += box[0] * box[1];\\n\\t\\t\\t\\t\\ttruckSize -= box[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttotal += truckSize * box[1];\\n\\t\\t\\t\\t\\treturn total;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn total;  \\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t\\t\\tArrays.sort(boxTypes, (a, b) -> Integer.compare(b[1], a[1]));\\n\\t\\t\\tint total = 0;\\n\\t\\t\\tfor (int[] box:boxTypes){\\n\\t\\t\\t\\tif (truckSize >= box[0]){\\n\\t\\t\\t\\t\\ttotal += box[0] * box[1];\\n\\t\\t\\t\\t\\ttruckSize -= box[0];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2409447,
                "title": "c-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int> >& boxTypes, int truckSize)\\n    {\\n        sort(boxTypes.begin(), boxTypes.end(), [](const auto& a, const auto& b) { return a[1] > b[1]; });\\n\\n        int res = 0;\\n\\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            if (truckSize >= boxTypes[i][0]) {\\n                truckSize -= boxTypes[i][0];\\n                res += boxTypes[i][0] * boxTypes[i][1];\\n            }\\n            else {\\n                if (truckSize <= 0) {\\n                    break;\\n                }\\n\\n                res += truckSize * boxTypes[i][1];\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int> >& boxTypes, int truckSize)\\n    {\\n        sort(boxTypes.begin(), boxTypes.end(), [](const auto& a, const auto& b) { return a[1] > b[1]; });\\n\\n        int res = 0;\\n\\n        for (int i = 0; i < boxTypes.size(); i++) {\\n            if (truckSize >= boxTypes[i][0]) {\\n                truckSize -= boxTypes[i][0];\\n                res += boxTypes[i][0] * boxTypes[i][1];\\n            }\\n            else {\\n                if (truckSize <= 0) {\\n                    break;\\n                }\\n\\n                res += truckSize * boxTypes[i][1];\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227477,
                "title": "c-simple-greedy-approach-sorting-by-comparator",
                "content": "![image](https://assets.leetcode.com/users/images/3eb4e565-7a17-4a50-bf0a-4c805203b792_1656767457.856521.png)\\n\\n***n== bt.size();***\\n**T->O(n*logn*1) [Complexity of comparator is O(1)]\\nS->O(1)**\\n\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maximumUnits(vector<vector<int>>& bt, int ts) {\\n\\t\\t\\t\\tsort(bt.begin(),bt.end(),[](vector<int> a,vector<int> b){\\n\\t\\t\\t\\t\\treturn a[1]>=b[1];\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tint count=0,ans=0;\\n\\t\\t\\t\\tfor(int i=0;i<bt.size();i++){\\n\\t\\t\\t\\t\\tif(count+bt[i][0]<ts){\\n\\t\\t\\t\\t\\t\\tans+=(bt[i][0]*bt[i][1]);\\n\\t\\t\\t\\t\\t\\tcount+=bt[i][0];\\n\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tans+=((ts-count)*bt[i][1]);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maximumUnits(vector<vector<int>>& bt, int ts) {\\n\\t\\t\\t\\tsort(bt.begin(),bt.end(),[](vector<int> a,vector<int> b){\\n\\t\\t\\t\\t\\treturn a[1]>=b[1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2224259,
                "title": "1710-maximum-units-on-a-truck-not-dp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    //just compare here \\n    static bool compare(const vector<int> &box1,const vector<int> &box2)\\n    {\\n        return box1[1]>box2[1];\\n    }\\n    //main function\\n    int maximumUnits(vector<vector<int>>& box, int truckSize) \\n    {\\n        //get box size\\n        int n=box.size();\\n        //then sort it with comapring simulutanoeusly\\n        sort(box.begin(),box.end(),compare);\\n        //set total =\\'0\\'\\n        int total=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            //check the condition if trucksize do not exceed with taken box units\\n            if(total+box[i][0]>truckSize)\\n            {\\n                ans+=(truckSize-total)*box[i][1];\\n                break;\\n            }\\n            else\\n            {\\n                //otherwise simply\\n                //do add the boxes with containing units\\n                ans+=box[i][0]*box[i][1];\\n                total+=box[i][0];\\n            }\\n        } \\n        //print output\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    //just compare here \\n    static bool compare(const vector<int> &box1,const vector<int> &box2)\\n    {\\n        return box1[1]>box2[1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2223734,
                "title": "greedy-approach-beginner-friendly-easy-explanation-c",
                "content": "The intution behind the solution is simple, we need to return the **maximum total number of units that can be put on the truck.**\\n We can infer two things from the above sentence:\\n1.  The number of units should be maximum.\\n2.  The final no. of boxes should be equal to that of the truck size.\\nSo, can we sort the boxTypes by the no. of units in a box, wich is stored in the 2nd index of array.\\n\\nNow, let\\'s take the help of 2nd test case to understand better:\\n\\nInput: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\\nOutput: 91\\n\\nHow did we get output 91?\\n\\nNow, as states above, since we need to get maximum no. of units in total, so sort greedily th no. of units.\\nAfter sorting we get:\\n\\n [[5,10],[3,9],[4,7],[2,5]]\\n 10>9>7>5\\n \\ntruckSize=10, sum=0\\nStart iterating for each box in array boxTypes(sorted)\\n\\nsince, 5(no. of boxes int 1st index)<10(truck size) so we can take all the 5 boxes of unit 10\\nNow, we get the sum=(5*10)=50, truckSize=10-5=5\\n\\ncoming to next box,\\n3<5(truck Size)\\nso, sum=50+(3*9)=77, truckSize=2\\n\\ncoming to next box\\n4>2 so\\nwe can take (4-2) boxes at most,\\nso sum=77+(2*7)=91, truckSize=0(Stop iterating)\\n\\nBelow is the c++ implemantation of the same:\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a, vector<int>&b){\\n        return a[1]>b[1] || (a[1]==b[1] && a[0]<b[0]);\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),comp);\\n        int sum=0;\\n        for(auto i: boxTypes){\\n          if(truckSize-i[0]>=0){\\n              truckSize-=i[0];\\n              sum+=(i[0]*i[1]);\\n          }\\n          else{\\n              if(truckSize!=0 && i[0]>truckSize){\\n                  sum+=(truckSize*i[1]);\\n                  truckSize=0;\\n              }\\n          }\\n        }\\n        return sum;\\n            \\n            \\n    \\n}\\n};\\n```\\n\\n\\n \\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>&a, vector<int>&b){\\n        return a[1]>b[1] || (a[1]==b[1] && a[0]<b[0]);\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),comp);\\n        int sum=0;\\n        for(auto i: boxTypes){\\n          if(truckSize-i[0]>=0){\\n              truckSize-=i[0];\\n              sum+=(i[0]*i[1]);\\n          }\\n          else{\\n              if(truckSize!=0 && i[0]>truckSize){\\n                  sum+=(truckSize*i[1]);\\n                  truckSize=0;\\n              }\\n          }\\n        }\\n        return sum;\\n            \\n            \\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222794,
                "title": "super-readable-code-with-detailed-explanation",
                "content": "**Please upvote if this was helpful :)**\\n\\nWe need to maximize the units loaded onto the truck.\\n\\nWe only have **truckSize** amount of boxes to load. Since every box loaded takes 1 out of the truckSize, we want to greedily load the boxes that will give us the best cost, hence have the best **numberOfUnitsPerBox**.\\n\\nWe will sort by **numberOfUnitsPerBox** and keep loading our truck until we are left out of space.\\n\\nIn the end, return the cost we accumulated\\n\\n\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxes_amount_left_to_load = truckSize\\n        boxTypes.sort(key=lambda x: x[1], reverse=True)\\n        maximum_units_loaded = 0\\n        \\n        # We want to greedily put the boxes with the highest amount of numberOfUnitsPerBox\\n        for num_of_boxes, units_per_box in boxTypes:\\n            if boxes_amount_left_to_load == 0:\\n                break\\n            \\n            # take boxes_amount_left_to_load if we can\\'t take all the boxes from this one\\n            num_of_boxes_to_take = min(boxes_amount_left_to_load, num_of_boxes)\\n            \\n            maximum_units_loaded += num_of_boxes_to_take * units_per_box\\n            boxes_amount_left_to_load -= num_of_boxes_to_take\\n            \\n        return maximum_units_loaded\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxes_amount_left_to_load = truckSize\\n        boxTypes.sort(key=lambda x: x[1], reverse=True)\\n        maximum_units_loaded = 0\\n        \\n        # We want to greedily put the boxes with the highest amount of numberOfUnitsPerBox\\n        for num_of_boxes, units_per_box in boxTypes:\\n            if boxes_amount_left_to_load == 0:\\n                break\\n            \\n            # take boxes_amount_left_to_load if we can\\'t take all the boxes from this one\\n            num_of_boxes_to_take = min(boxes_amount_left_to_load, num_of_boxes)\\n            \\n            maximum_units_loaded += num_of_boxes_to_take * units_per_box\\n            boxes_amount_left_to_load -= num_of_boxes_to_take\\n            \\n        return maximum_units_loaded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222787,
                "title": "python-simple-greedy-approach-beats-98-60",
                "content": "```\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        units = 0\\n        boxTypes.sort(key= lambda x : x[1],reverse=True) #Sort using 2nd element of each box type\\n        for p in boxTypes:\\n            if truckSize >= p[0]: # If all the boxes can be added\\n                units += p[1]*p[0]\\n                truckSize -= p[0]\\n            elif truckSize > 0: # If few boxes can be added\\n                units += p[1]*truckSize\\n                truckSize = 0                \\n            if truckSize == 0: # If truck is full\\n                return units\\n        return units\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        units = 0\\n        boxTypes.sort(key= lambda x : x[1],reverse=True) #Sort using 2nd element of each box type\\n        for p in boxTypes:\\n            if truckSize >= p[0]: # If all the boxes can be added\\n                units += p[1]*p[0]\\n                truckSize -= p[0]\\n            elif truckSize > 0: # If few boxes can be added\\n                units += p[1]*truckSize\\n                truckSize = 0                \\n            if truckSize == 0: # If truck is full\\n                return units\\n        return units\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2222763,
                "title": "greedy-solution-using-custom-comparator",
                "content": "Sort the array in decreasing order using custom comparator and then greedily find max capacity.\\n```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> a,vector<int> b){\\n        return a[1]>b[1];\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int ans=0;\\n        sort(boxTypes.begin(),boxTypes.end(),compare);\\n        int i=0;\\n        while(i<boxTypes.size() && truckSize>=0){\\n            int x=boxTypes[i][0];\\n            int y=boxTypes[i][1];\\n            if(truckSize>x){\\n                ans+=x*y;\\n                truckSize-=x;\\n            }\\n            else{\\n                ans+=truckSize*y;\\n                break;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    static bool compare(vector<int> a,vector<int> b){\\n        return a[1]>b[1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2222618,
                "title": "c-fractional-knapsack-greedy-approach-o-nlogn",
                "content": "```\\n   bool compare(vector<int>v1,vector<int>v2){\\n            return v1[1]>v2[1];\\n        }\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        \\n         \\n        int totalNum=0;\\n        //sort the aray in descending order\\n        sort(boxTypes.begin(),boxTypes.end(),compare);\\n        int i =0;\\n        \\n     //   loop runs till the trucksize becomes 0 and we iterate over the complete array\\n        \\n        while(truckSize>0 && i<boxTypes.size()){\\n            if(boxTypes[i][0]<=truckSize){\\n                totalNum+=boxTypes[i][0]*boxTypes[i][1];\\n                truckSize-=boxTypes[i][0];\\n            }\\n            else{\\n                int leftVal = truckSize;\\n                truckSize-=leftVal;\\n                totalNum+=leftVal*boxTypes[i][1];\\n            }\\n            i++;\\n            \\n        }\\n        return totalNum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n   bool compare(vector<int>v1,vector<int>v2){\\n            return v1[1]>v2[1];\\n        }\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        \\n         \\n        int totalNum=0;\\n        //sort the aray in descending order\\n        sort(boxTypes.begin(),boxTypes.end(),compare);\\n        int i =0;\\n        \\n     //   loop runs till the trucksize becomes 0 and we iterate over the complete array\\n        \\n        while(truckSize>0 && i<boxTypes.size()){\\n            if(boxTypes[i][0]<=truckSize){\\n                totalNum+=boxTypes[i][0]*boxTypes[i][1];\\n                truckSize-=boxTypes[i][0];\\n            }\\n            else{\\n                int leftVal = truckSize;\\n                truckSize-=leftVal;\\n                totalNum+=leftVal*boxTypes[i][1];\\n            }\\n            i++;\\n            \\n        }\\n        return totalNum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222398,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n       sort(boxTypes.begin(),boxTypes.end(),[](vector<int>p,vector<int>p1){\\n           return p[1]>p1[1];\\n       });\\n        int ans=0;\\n        for(int i=0;i<boxTypes.size();i++)\\n        {\\n            if(boxTypes[i][0]<=truckSize)\\n            {\\n                ans+=(boxTypes[i][0]*boxTypes[i][1]);\\n                truckSize-=boxTypes[i][0];\\n            }\\n            else if(truckSize)\\n            {\\n                ans+=(truckSize*boxTypes[i][1]);\\n                break;\\n            }\\n        }\\n        return ans;\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n       sort(boxTypes.begin(),boxTypes.end(),[](vector<int>p,vector<int>p1){\\n           return p[1]>p1[1];\\n       });\\n        int ans=0;\\n        for(int i=0;i<boxTypes.size();i++)\\n        {\\n            if(boxTypes[i][0]<=truckSize)\\n            {\\n                ans+=(boxTypes[i][0]*boxTypes[i][1]);\\n                truckSize-=boxTypes[i][0];\\n            }\\n            else if(truckSize)\\n            {\\n                ans+=(truckSize*boxTypes[i][1]);\\n                break;\\n            }\\n        }\\n        return ans;\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222359,
                "title": "c-faster-than-14-69",
                "content": "Runtime: 209 ms, faster than 14.69% of C# online submissions for Maximum Units on a Truck.\\nMemory Usage: 41.2 MB, less than 35.00% of C# online submissions for Maximum Units on a Truck.\\n```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        var sortedBoxes = boxTypes.OrderByDescending(x => x[1]).ThenBy(x=> x[0]);\\n        int count = 0;\\n        \\n        foreach(var box in sortedBoxes)\\n        {\\n            count += Math.Min(truckSize, box[0]) * box[1];\\n            truckSize -= Math.Min(truckSize, box[0]);\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        var sortedBoxes = boxTypes.OrderByDescending(x => x[1]).ThenBy(x=> x[0]);\\n        int count = 0;\\n        \\n        foreach(var box in sortedBoxes)\\n        {\\n            count += Math.Min(truckSize, box[0]) * box[1];\\n            truckSize -= Math.Min(truckSize, box[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2222352,
                "title": "c-simple-solution-using-sorting",
                "content": "We have asked about the maximum number of boxes per units we can carry with a given number of box types.\\nSo, from the question we can clearly see that we have to find the  maximum number of boxes so the best idea is to pick the boxes with having the maximum number of boxes per unit which we can do that by sorting the matrix by the number of boxes per unit.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxtypes, int truckSize) {\\n        int maxUnits= 0;\\n        sort(boxtypes.begin(),boxtypes.end(),cmp);\\n        for(int i = 0;i<boxtypes.size();i++){\\n            if(truckSize > 0){\\n                maxUnits += min(truckSize, boxtypes[i][0]) * boxtypes[i][1];\\n                truckSize-=boxtypes[i][0];\\n                }\\n        }\\n        return maxUnits;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[1]>b[1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2221964,
                "title": "c-priorityqueue-int-int",
                "content": "```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        var maxHeap = new PriorityQueue<int[], int>();\\n        \\n        for(int i = 0; i < boxTypes.Length; i++) {\\n            maxHeap.Enqueue(boxTypes[i], -boxTypes[i][1]);\\n        }\\n        \\n        int count = 0;\\n        while(truckSize > 0 && maxHeap.Count > 0) {\\n            \\n            var boxType = maxHeap.Dequeue();\\n            \\n            if(boxType[0] <= truckSize) {\\n                truckSize -= boxType[0];\\n                count += (boxType[0] * boxType[1]);\\n                continue;\\n            }\\n            \\n            //boxType has more boxes than capacity\\n            count += truckSize * boxType[1];\\n            truckSize = 0;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        var maxHeap = new PriorityQueue<int[], int>();\\n        \\n        for(int i = 0; i < boxTypes.Length; i++) {\\n            maxHeap.Enqueue(boxTypes[i], -boxTypes[i][1]);\\n        }\\n        \\n        int count = 0;\\n        while(truckSize > 0 && maxHeap.Count > 0) {\\n            \\n            var boxType = maxHeap.Dequeue();\\n            \\n            if(boxType[0] <= truckSize) {\\n                truckSize -= boxType[0];\\n                count += (boxType[0] * boxType[1]);\\n                continue;\\n            }\\n            \\n            //boxType has more boxes than capacity\\n            count += truckSize * boxType[1];\\n            truckSize = 0;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221577,
                "title": "java-sorting",
                "content": "Runtime: 12 ms, faster than 58.54% of Java online submissions for Maximum Units on a Truck.\\nMemory Usage: 52 MB, less than 6.25% of Java online submissions for Maximum Units on a Truck.\\n```\\nclass Solution {\\n  public int maximumUnits(int[][] boxTypes, int truckSize) {\\n    Arrays.sort(boxTypes, (int[] a, int[] b) -> b[1] - a[1]);\\n    \\n    int ans = 0; \\n    for(int[] b: boxTypes)\\n      if(b[0] > truckSize) {ans += b[1] * truckSize; break;}\\n      else {ans += b[1] * b[0]; truckSize -= b[0]; }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumUnits(int[][] boxTypes, int truckSize) {\\n    Arrays.sort(boxTypes, (int[] a, int[] b) -> b[1] - a[1]);\\n    \\n    int ans = 0; \\n    for(int[] b: boxTypes)\\n      if(b[0] > truckSize) {ans += b[1] * truckSize; break;}\\n      else {ans += b[1] * b[0]; truckSize -= b[0]; }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221123,
                "title": "c-simple-solution-using-sorting",
                "content": "```class Solution {\\npublic:\\n    static bool cmp(vector<int>abc,vector<int>xyz)\\n    {\\n        return abc[1]>xyz[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);\\n        int units=0;\\n        int i=0;\\n        while(truckSize>0 and i<boxTypes.size())\\n        {\\n            \\n            if(boxTypes[i][0]<=truckSize)\\n            {\\n                units+=boxTypes[i][0]*boxTypes[i][1];\\n                truckSize-=boxTypes[i][0];\\n            }\\n            else if(boxTypes[i][0]>truckSize)\\n            {\\n                while(boxTypes[i][0]>truckSize)\\n                {\\n                    boxTypes[i][0]--;\\n                }\\n                units+=boxTypes[i][0]*boxTypes[i][1];\\n                truckSize-=boxTypes[i][0];\\n            }\\n            i++;\\n        }\\n        return units;\\n    }\\n};```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```class Solution {\\npublic:\\n    static bool cmp(vector<int>abc,vector<int>xyz)\\n    {\\n        return abc[1]>xyz[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),cmp);\\n        int units=0;\\n        int i=0;\\n        while(truckSize>0 and i<boxTypes.size())\\n        {\\n            \\n            if(boxTypes[i][0]<=truckSize)\\n            {\\n                units+=boxTypes[i][0]*boxTypes[i][1];\\n                truckSize-=boxTypes[i][0];\\n            }\\n            else if(boxTypes[i][0]>truckSize)\\n            {\\n                while(boxTypes[i][0]>truckSize)\\n                {\\n                    boxTypes[i][0]--;\\n                }\\n                units+=boxTypes[i][0]*boxTypes[i][1];\\n                truckSize-=boxTypes[i][0];\\n            }\\n            i++;\\n        }\\n        return units;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2220967,
                "title": "python-greedy-explanation",
                "content": "**Upvote if u like**\\n\\nWe follow Greedy approach . And add boxes with greater number of units in our truck. \\n\\n**Complexity Analysis**\\nTime : O(n*log(n))     -> Sorting\\nSpace:  O(1)\\n\\n\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        ans=0\\n        i=0     #To traverse array\\n        \\n        #Sort according to decreasing values of numberOfBoxes\\n        boxTypes.sort(key=lambda x:(-x[1]))\\n        \\n        n=len(boxTypes)\\n        while(truckSize!=0 and i<n):\\n            print(truckSize)\\n            if truckSize > boxTypes[i][0]:\\n                ans += boxTypes[i][0]*boxTypes[i][1]\\n                truckSize -= boxTypes[i][0]\\n                i+=1\\n            \\n            elif truckSize <= boxTypes[i][0]:\\n                ans += truckSize*boxTypes[i][1]\\n                return ans\\n        \\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        ans=0\\n        i=0     #To traverse array\\n        \\n        #Sort according to decreasing values of numberOfBoxes\\n        boxTypes.sort(key=lambda x:(-x[1]))\\n        \\n        n=len(boxTypes)\\n        while(truckSize!=0 and i<n):\\n            print(truckSize)\\n            if truckSize > boxTypes[i][0]:\\n                ans += boxTypes[i][0]*boxTypes[i][1]\\n                truckSize -= boxTypes[i][0]\\n                i+=1\\n            \\n            elif truckSize <= boxTypes[i][0]:\\n                ans += truckSize*boxTypes[i][1]\\n                return ans\\n        \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220783,
                "title": "c-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/2b58d0a3-926f-4e95-81dd-0a061ab9c6d8_1656645657.425793.png)\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), [](auto& box1, auto& box2) {\\n            return box1[1] > box2[1];\\n        });\\n       \\n        int ans=0;\\n        for(auto box: boxTypes){\\n            int boxNum = min(truckSize,box[0]);\\n            ans += boxNum*box[1];\\n            truckSize -= boxNum; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), [](auto& box1, auto& box2) {\\n            return box1[1] > box2[1];\\n        });\\n       \\n        int ans=0;\\n        for(auto box: boxTypes){\\n            int boxNum = min(truckSize,box[0]);\\n            ans += boxNum*box[1];\\n            truckSize -= boxNum; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220677,
                "title": "using-greedy-technique-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool Comparator(vector<int> a, vector<int> b){\\n        return (a[1] > b[1]);\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        //boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]\\n        sort(boxTypes.begin(), boxTypes.end(), Comparator);\\n        int ans = 0;\\n        for(auto i : boxTypes){\\n            int x = min(i[0], truckSize);\\n            ans += x*i[1];\\n            truckSize-=x;\\n            if(!truckSize) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool Comparator(vector<int> a, vector<int> b){\\n        return (a[1] > b[1]);\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        //boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]\\n        sort(boxTypes.begin(), boxTypes.end(), Comparator);\\n        int ans = 0;\\n        for(auto i : boxTypes){\\n            int x = min(i[0], truckSize);\\n            ans += x*i[1];\\n            truckSize-=x;\\n            if(!truckSize) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220480,
                "title": "java-easy-solution-sort-greedy-explanation",
                "content": "To get the maximum total number of units, we should choose the box with the biggest units first (greedy).\\nSo by sorting the boxTypes by numberOfUnitsPerBox, we can solve this problem quickly!\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> {return b[1] - a[1];});\\n        \\n        int maximum = 0;\\n        int leftSize = truckSize;\\n        \\n        for (int[] boxType : boxTypes) {\\n            if (leftSize >= boxType[0]) {\\n                maximum += boxType[0] * boxType[1];\\n                leftSize -= boxType[0];\\n            } else {\\n                maximum += leftSize * boxType[1];\\n                break;\\n            }\\n        }\\n        \\n        return maximum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> {return b[1] - a[1];});\\n        \\n        int maximum = 0;\\n        int leftSize = truckSize;\\n        \\n        for (int[] boxType : boxTypes) {\\n            if (leftSize >= boxType[0]) {\\n                maximum += boxType[0] * boxType[1];\\n                leftSize -= boxType[0];\\n            } else {\\n                maximum += leftSize * boxType[1];\\n                break;\\n            }\\n        }\\n        \\n        return maximum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220389,
                "title": "c-expalined-via-out-of-box-approach",
                "content": "```\\n\\nUPVOTE IF U LOVED THE SOLUTION\\n\\nThe given constraints for numberOfUnitsPerBox are small enough that we can use an approach similar to counting sort to reduce the time complexity to O(N).\\n\\nHere, we can declare an array freq of size=1000 (which is maximum number of units per box) where freq[i] will denote the number of boxes that can hold i number of units. We can iterate through the given boxTypes array and populate the freq array. Then we can iterate over the freq array and greedily choose starting from i=1000 till we run out of truckSize or pick all available boxes.\\n\\nC++\\n\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tint freq[1001]{0}, maxUnits = 0;   // freq[i] = number of boxes that can hold i units\\n\\tfor(auto& box : boxTypes) freq[box[1]] += box[0];\\n\\t// greedily choose starting from max units till either truckSize runs out or you choose all boxes\\n\\tfor(int units = 1000; truckSize > 0 && ~units; --units) { \\n\\t\\tmaxUnits += min(truckSize, freq[units]) * units;\\n\\t\\ttruckSize -= freq[units];\\n\\t}\\n\\treturn maxUnits;\\n}\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nUPVOTE IF U LOVED THE SOLUTION\\n\\nThe given constraints for numberOfUnitsPerBox are small enough that we can use an approach similar to counting sort to reduce the time complexity to O(N).\\n\\nHere, we can declare an array freq of size=1000 (which is maximum number of units per box) where freq[i] will denote the number of boxes that can hold i number of units. We can iterate through the given boxTypes array and populate the freq array. Then we can iterate over the freq array and greedily choose starting from i=1000 till we run out of truckSize or pick all available boxes.\\n\\nC++\\n\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tint freq[1001]{0}, maxUnits = 0;   // freq[i] = number of boxes that can hold i units\\n\\tfor(auto& box : boxTypes) freq[box[1]] += box[0];\\n\\t// greedily choose starting from max units till either truckSize runs out or you choose all boxes\\n\\tfor(int units = 1000; truckSize > 0 && ~units; --units) { \\n\\t\\tmaxUnits += min(truckSize, freq[units]) * units;\\n\\t\\ttruckSize -= freq[units];\\n\\t}\\n\\treturn maxUnits;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1932219,
                "title": "java-easy-to-understand",
                "content": "```\\n\\tpublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for(int boxType[] : boxTypes) {\\n            int numOfBoxes = boxType[0];\\n            int numOfUnits = boxType[1];\\n            if(numOfBoxes > truckSize) {\\n                ans += truckSize*numOfUnits;\\n                break;\\n            }\\n            ans += numOfBoxes*numOfUnits;\\n            truckSize -= numOfBoxes;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for(int boxType[] : boxTypes) {\\n            int numOfBoxes = boxType[0];\\n            int numOfUnits = boxType[1];\\n            if(numOfBoxes > truckSize) {\\n                ans += truckSize*numOfUnits;\\n                break;\\n            }\\n            ans += numOfBoxes*numOfUnits;\\n            truckSize -= numOfBoxes;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850109,
                "title": "beginner-friendly-python-solution",
                "content": "**Time Complexity : O(n)**\\n```\\nclass Solution(object):\\n    def maximumUnits(self, boxTypes, truckSize):\\n        boxTypes.sort(key = lambda x: -x[1])\\n        totalunits = 0\\n        for box, units in boxTypes:\\n            if box <= truckSize:\\n                totalunits += box * units\\n                truckSize -= box\\n            else:\\n                totalunits += truckSize * units\\n                return totalunits\\n        return totalunits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumUnits(self, boxTypes, truckSize):\\n        boxTypes.sort(key = lambda x: -x[1])\\n        totalunits = 0\\n        for box, units in boxTypes:\\n            if box <= truckSize:\\n                totalunits += box * units\\n                truckSize -= box\\n            else:\\n                totalunits += truckSize * units\\n                return totalunits\\n        return totalunits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848275,
                "title": "heavily-commented-code-using-custom-sorting",
                "content": "**Please Upvote,it helps a lot**\\n```\\n//Time Complexity : nlogn\\n//Auxiliary space : O(1)\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes,(a,b) -> (b[1] - a[1])); //descending acc to units/box\\n        int count = 0;\\n        int idx = 0;\\n        int len = boxTypes.length;\\n        while(truckSize > 0 && idx < len){ //while there is space in truck\\n            int boxes = boxTypes[idx][0]; //boxes available of this type\\n            if(boxes <= truckSize){ // can use all the boxes\\n                count += boxTypes[idx][1] * boxes; //no.of units/box * no.of boxes\\n                truckSize -= boxes;\\n            }else{  // cannot use all the boxes availabe of this type\\n                count += boxTypes[idx][1] * truckSize;\\n                break; //as we don\\'t have space in truck now\\n            }\\n            idx++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n//Time Complexity : nlogn\\n//Auxiliary space : O(1)\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes,(a,b) -> (b[1] - a[1])); //descending acc to units/box\\n        int count = 0;\\n        int idx = 0;\\n        int len = boxTypes.length;\\n        while(truckSize > 0 && idx < len){ //while there is space in truck\\n            int boxes = boxTypes[idx][0]; //boxes available of this type\\n            if(boxes <= truckSize){ // can use all the boxes\\n                count += boxTypes[idx][1] * boxes; //no.of units/box * no.of boxes\\n                truckSize -= boxes;\\n            }else{  // cannot use all the boxes availabe of this type\\n                count += boxTypes[idx][1] * truckSize;\\n                break; //as we don\\'t have space in truck now\\n            }\\n            idx++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737359,
                "title": "java-easy-to-understand-solution",
                "content": "\\n       \\'\\n\\t   \\n        \\n       public int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t\\tint total[] = new int[1001];\\n\\t\\tfor(int i=0;i<boxTypes.length;i++)\\n        {\\n            if(total[boxTypes[i][1]]==0){\\n                total[boxTypes[i][1]]=boxTypes[i][0];\\n                }else{\\n                total[boxTypes[i][1]]+=boxTypes[i][0];\\n            }\\n        }\\n        int totalUnits=0;\\n        for(int i=1000;i>=0 && truckSize>0;i--){\\n            if(total[i]!=0){\\n                totalUnits+=i*1;\\n                total[i]--;\\n                truckSize--;\\n                i++;\\n            }\\n        }\\n        return totalUnits;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n       \\'\\n\\t   \\n        \\n       public int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t\\tint total[] = new int[1001];\\n\\t\\tfor(int i=0;i<boxTypes.length;i++)\\n        {\\n            if(total[boxTypes[i][1]]==0){\\n                total[boxTypes[i][1]]=boxTypes[i][0];\\n                }else{\\n                total[boxTypes[i][1]]+=boxTypes[i][0];\\n            }\\n        }\\n        int totalUnits=0;\\n        for(int i=1000;i>=0 && truckSize>0;i--){\\n            if(total[i]!=0){\\n                totalUnits+=i*1;\\n                total[i]--;\\n                truckSize--;\\n                i++;\\n            }\\n        }\\n        return totalUnits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1686498,
                "title": "js-ts-simple-sort-solution",
                "content": "```\\nfunction maximumUnits(boxTypes: number[][], truckSize: number): number {\\n    \\n    boxTypes.sort((a,b) => (b[1] - a[1]))\\n    \\n    let total = 0\\n    let i = 0\\n\\n    while (truckSize && i < boxTypes.length) {\\n        let [count, units] = boxTypes[i];\\n        if (count < truckSize) {\\n            total += count * units\\n            truckSize -= count\\n        } else {\\n            while (count && truckSize) {\\n                total += units;\\n                count--;\\n                truckSize--;\\n            }\\n        }\\n        i++;\\n    }\\n    \\n    return total\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maximumUnits(boxTypes: number[][], truckSize: number): number {\\n    \\n    boxTypes.sort((a,b) => (b[1] - a[1]))\\n    \\n    let total = 0\\n    let i = 0\\n\\n    while (truckSize && i < boxTypes.length) {\\n        let [count, units] = boxTypes[i];\\n        if (count < truckSize) {\\n            total += count * units\\n            truckSize -= count\\n        } else {\\n            while (count && truckSize) {\\n                total += units;\\n                count--;\\n                truckSize--;\\n            }\\n        }\\n        i++;\\n    }\\n    \\n    return total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1636929,
                "title": "python-3-using-sorted",
                "content": "We need maximum units so first we would try to fill our truck with boxes with higher number of units. To do this, we need to sort the boxTypes in desc order on unitcount\\n\\nNext we need to keep adding to our result as long as we have space in our truck -> truckSize > 0\\n\\nif the number of boxes is less than trucksize we can put all of them in our truck, if not we check the space remaining in the truck and fill only that many units\\n\\nLastly we remove the number of boxes added from the iteration\\n\\n*Note: Using reverse=True performs slightly better than using lambda x: -x[1]* \\n\\nTime Complexity: Worst case: **O(nlogn)** where n is the length of boxTypes\\n\\n```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        result = 0\\n        for boxes in sorted(boxTypes, reverse=True, key= lambda x: x[1]):\\n            if truckSize > 0:        \\n                if boxes[0] < truckSize: \\n\\t\\t\\t\\t\\tresult+=(boxes[1]*boxes[0])\\n                else: \\n\\t\\t\\t\\t\\tresult+=(boxes[1]*truckSize)\\n                truckSize-=boxes[0]\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        result = 0\\n        for boxes in sorted(boxTypes, reverse=True, key= lambda x: x[1]):\\n            if truckSize > 0:        \\n                if boxes[0] < truckSize: \\n\\t\\t\\t\\t\\tresult+=(boxes[1]*boxes[0])\\n                else: \\n\\t\\t\\t\\t\\tresult+=(boxes[1]*truckSize)\\n                truckSize-=boxes[0]\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1569862,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: x[1], reverse=True)\\n        count=0\\n        for box in boxTypes:\\n            rem=min(truckSize,box[0])\\n            count+=rem*box[1]\\n            truckSize-=rem\\n            if truckSize<=0:\\n                break\\n        return count",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: x[1], reverse=True)\\n        count=0\\n        for box in boxTypes:\\n            rem=min(truckSize,box[0])\\n            count+=rem*box[1]\\n            truckSize-=rem\\n            if truckSize<=0:\\n                break\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1538972,
                "title": "c-clean-easy-fractional-knapsack",
                "content": "**O(nlog(n))**\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), [&](vector<int> a, vector<int> b) {\\n            return a[1] > b[1];\\n        });\\n        \\n        int res = 0, n = boxTypes.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(boxTypes[i][0] < truckSize) {\\n                res += boxTypes[i][0]*boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            else {\\n                res += truckSize*boxTypes[i][1];\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), [&](vector<int> a, vector<int> b) {\\n            return a[1] > b[1];\\n        });\\n        \\n        int res = 0, n = boxTypes.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(boxTypes[i][0] < truckSize) {\\n                res += boxTypes[i][0]*boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            else {\\n                res += truckSize*boxTypes[i][1];\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521163,
                "title": "sort-pairwise",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& b, int truckSize) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<b.size();i++){\\n            v.push_back({b[i][1],b[i][0]});\\n        }\\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n        int ans=0;\\n        for(int i=0;i<v.size();i++){\\n            while(v[i].second--){\\n                ans+=v[i].first;\\n                truckSize--;\\n                if(truckSize==0){\\n                    break;\\n                }\\n            }\\n            if(truckSize==0){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& b, int truckSize) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<b.size();i++){\\n            v.push_back({b[i][1],b[i][0]}",
                "codeTag": "Java"
            },
            {
                "id": 1502728,
                "title": "c-easy-two-approaches-explained-with-simulation-comparison",
                "content": "# Approach 1:\\n**The key point:** The more unit per box is, the more units can be added to truck. \\n**Approach:** We can sort the box array by units per box from higher to lower. Hence, we will ge the higher units per box in the top of the array.\\n\\nFor test case: 2\\ninitially: boxTypes = [[5,10],[2,5],[4,7],[3,9]]\\nafter sorting: boxTypes = [[5,10],[3,9],[4,7],[2,5]]\\n\\nNow, we will start picking box from *index-0*.\\n\\nPick index 0: [5,10] => spaceLeft = truckSize = 10 || currentBoxes = 5, unitsPerBox = 10, totalUnits = 5\\\\*10 = 50, spaceLeft = 10-5 = 5\\nPick index 1: [3,9] => spaceLeft = 5 || currentBoxes = 3, unitsPerBox = 9, totalUnits =50 + 3\\\\*9 = 50 + 27 = 77, spaceLeft = 5-3 = 2\\nPick index 2: [4,7] => spaceLeft = 2 || (cannot be picked all of the 4 boxes, have to pick as spaceLeft) \\ncurrentBoxes = 4, unitsPerBox = 7, totalUnits =77 + 2\\\\*7 = 77 + 14 = 91, spaceLeft = 2-2 = 0 \\nPick index 3: [4,7] => spaceLeft = 0 || cannot be picked any further as no space left.\\n(no space left, terminate loop)\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    static bool sortByUnitPerItem(const vector<int>& v1, const vector<int>& v2) {\\n        return v1[1]>v2[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), sortByUnitPerItem);\\n        int currSpace=0, totalUnits=0;\\n        for(int i=0; i<boxTypes.size() && currSpace<truckSize; i++) {\\n            int currNumOfBox=boxTypes[i][0];\\n            int currUnitPerBox=boxTypes[i][1];\\n            if(currNumOfBox+currSpace>=truckSize) { //if all of the box can be picked\\n                int remainSpace = truckSize-currSpace;\\n                totalUnits += remainSpace * currUnitPerBox;\\n            } else {\\n                totalUnits += currNumOfBox * currUnitPerBox;\\n            }\\n            currSpace+=currNumOfBox;\\n        }\\n        return totalUnits;\\n    }\\n};\\n```\\n**Complexity:**\\nTime: O (n\\\\*logn) [for sorting]\\nSpace: O (1) [no extra space needed]\\n# Approach 2:\\n**The key point:** The max units per box is 1000, so, we can loop from 1000 to 1 (higher to lower boxPerUnit) without any sorting.\\n**Approach:** We can track units per box vs how many boxes of that kind and store them in the array.\\n\\nFor test case: 2\\nboxTypes = [[5,10],[2,5],[4,7],[3,9]]\\narray: (unitsPerBox = boxCount)\\n0 = 0\\n1 = 0\\n2 = 5\\n3 = 0\\n4 = 0\\n5 = 2\\n6 = 0\\n7 = 4\\n8 = 0\\n9 = 3\\n10 = 5\\n...all until 1000 = 0\\n\\nNow, we can iterate from 1000 to 1 (higher to lower boxPerUnit).\\n....\\nfor index 10 (5): spaceLeft = truckSize = 10 || currentBoxes = 5, unitsPerBox = 10, totalUnits = 5\\\\*10 = 50, spaceLeft = 10-5 = 5\\nfor index 9 (3): spaceLeft = 5 || currentBoxes = 3, unitsPerBox = 9, totalUnits =50 + 3\\\\*9 = 50 + 27 = 77, spaceLeft = 5-3 = 2\\nfor index 8 (0): spaceLeft = 2 || no boxes available for unitsPerBox = 8\\n...\\nfor index 7 (4): spaceLeft = 2 || (cannot be picked all of the 4 boxes, have to pick as spaceLeft) \\ncurrentBoxes = 4, unitsPerBox = 7, totalUnits =77 + 2\\\\*7 = 77 + 14 = 91, spaceLeft = 2-2 = 0 \\n(no space left, terminate loop)\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int currSpaceLeft=truckSize, units=0;\\n        int arr[10001] = {0};\\n        for(int i=0; i<boxTypes.size(); i++) {\\n            arr[boxTypes[i][1]]+=boxTypes[i][0];\\n        }\\n        for(int i=1000; i>0; i--) {\\n            if(currSpaceLeft<=arr[i]) {\\n                units+=currSpaceLeft*i;\\n                break;\\n            } else {\\n                units+=arr[i]*i;\\n            }\\n            currSpaceLeft-=arr[i];\\n        }\\n        return units;\\n    }\\n};\\n```\\n**Complexity:**\\nTime: O (1000), can be said O (1)\\nSpace: O (1000), can be said O (1)",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortByUnitPerItem(const vector<int>& v1, const vector<int>& v2) {\\n        return v1[1]>v2[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), sortByUnitPerItem);\\n        int currSpace=0, totalUnits=0;\\n        for(int i=0; i<boxTypes.size() && currSpace<truckSize; i++) {\\n            int currNumOfBox=boxTypes[i][0];\\n            int currUnitPerBox=boxTypes[i][1];\\n            if(currNumOfBox+currSpace>=truckSize) { //if all of the box can be picked\\n                int remainSpace = truckSize-currSpace;\\n                totalUnits += remainSpace * currUnitPerBox;\\n            } else {\\n                totalUnits += currNumOfBox * currUnitPerBox;\\n            }\\n            currSpace+=currNumOfBox;\\n        }\\n        return totalUnits;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int currSpaceLeft=truckSize, units=0;\\n        int arr[10001] = {0};\\n        for(int i=0; i<boxTypes.size(); i++) {\\n            arr[boxTypes[i][1]]+=boxTypes[i][0];\\n        }\\n        for(int i=1000; i>0; i--) {\\n            if(currSpaceLeft<=arr[i]) {\\n                units+=currSpaceLeft*i;\\n                break;\\n            } else {\\n                units+=arr[i]*i;\\n            }\\n            currSpaceLeft-=arr[i];\\n        }\\n        return units;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502644,
                "title": "c-easy-solution-explained-with-comments",
                "content": "First I have sorted the 2D vector with respect to the second element that is the number of units.Once sorted we can directly compute the total units.\\n```\\nclass Solution {\\npublic:\\n   static bool sortcomp(const vector<int>&a,const vector<int>&b)//This function sorts the 2d vector on the basis of the                                                                       second element in descending order\\n    {\\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),sortcomp);//Sort accepts 3 parameters\\n   \\n        long int total=0;\\n        long int sum=0;\\n        for(int i=0;i<boxTypes.size();i++)\\n        {\\n            sum+=boxTypes[i][0];//calculating the sum of the number of boxes\\n            if(sum>truckSize)//moment sum exceeds the truckSize\\n            {\\n                sum-=boxTypes[i][0];//subtract the last added sum\\n                total+=((truckSize-sum)*boxTypes[i][1]);//find some of the remaining boxes\\n                break;\\n            }\\n            else\\n            {\\n                total+=(boxTypes[i][0]*boxTypes[i][1]);//finding total units\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool sortcomp(const vector<int>&a,const vector<int>&b)//This function sorts the 2d vector on the basis of the                                                                       second element in descending order\\n    {\\n        return a[1]>b[1];\\n    }\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),boxTypes.end(),sortcomp);//Sort accepts 3 parameters\\n   \\n        long int total=0;\\n        long int sum=0;\\n        for(int i=0;i<boxTypes.size();i++)\\n        {\\n            sum+=boxTypes[i][0];//calculating the sum of the number of boxes\\n            if(sum>truckSize)//moment sum exceeds the truckSize\\n            {\\n                sum-=boxTypes[i][0];//subtract the last added sum\\n                total+=((truckSize-sum)*boxTypes[i][1]);//find some of the remaining boxes\\n                break;\\n            }\\n            else\\n            {\\n                total+=(boxTypes[i][0]*boxTypes[i][1]);//finding total units\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439434,
                "title": "java-solution-applying-greedy-algorithm",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        Arrays.sort(boxTypes, (a,b)->(Integer.compare(b[1], a[1]))); //sorting in descending order of the numberOfUnitsPerBox\\n\\t\\t // for(int i = 0; i< boxTypes.length; i++) {\\n        //     for(int j = 0; j<boxTypes[0].length; j++) {\\n        //         System.out.print(boxTypes[i][j] + \" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        int units = 0;\\n        for (int[] box : boxTypes) {\\n            if (truckSize >= box[0]) {  //if truckSSize is greater than the numberOfBoxes then add (noOfBoxes * numberOfUnitsPerBoxes)\\n                units += box[0] * box[1];\\n                truckSize -= box[0];        //substract the size of the noOfBoxes after placing it in the truck\\n            }else {\\n                units += truckSize * box[1]; //when the truck is almost full and NoOfBoxes in the particular row is not able to fit completely then we add the size in truck left * numberOfUnitsPerBox and break.\\n                break;\\n            }\\n        }\\n        return units;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        Arrays.sort(boxTypes, (a,b)->(Integer.compare(b[1], a[1]))); //sorting in descending order of the numberOfUnitsPerBox\\n\\t\\t // for(int i = 0; i< boxTypes.length; i++) {\\n        //     for(int j = 0; j<boxTypes[0].length; j++) {\\n        //         System.out.print(boxTypes[i][j] + \" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        int units = 0;\\n        for (int[] box : boxTypes) {\\n            if (truckSize >= box[0]) {  //if truckSSize is greater than the numberOfBoxes then add (noOfBoxes * numberOfUnitsPerBoxes)\\n                units += box[0] * box[1];\\n                truckSize -= box[0];        //substract the size of the noOfBoxes after placing it in the truck\\n            }else {\\n                units += truckSize * box[1]; //when the truck is almost full and NoOfBoxes in the particular row is not able to fit completely then we add the size in truck left * numberOfUnitsPerBox and break.\\n                break;\\n            }\\n        }\\n        return units;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383425,
                "title": "c-greedy-algorithm",
                "content": "* **Greedy Soluion**\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) \\n    {\\n        int res=0;\\n        sort(boxTypes.begin(), boxTypes.end(), [](vector<int> v1, vector<int> v2)\\n             {\\n                 return v1[1] > v2[1];\\n             });    \\n        for(int i=0; i<boxTypes.size(); i++)\\n        {\\n            if(truckSize >= boxTypes[i][0]) // It is feasible solution\\n            {\\n                res += boxTypes[i][0] * boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            else\\n            {\\n                res += truckSize * boxTypes[i][1]; // Partially feasible solution\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please Do Upvote If you Find This Solution Helpful...   *:)***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) \\n    {\\n        int res=0;\\n        sort(boxTypes.begin(), boxTypes.end(), [](vector<int> v1, vector<int> v2)\\n             {\\n                 return v1[1] > v2[1];\\n             });    \\n        for(int i=0; i<boxTypes.size(); i++)\\n        {\\n            if(truckSize >= boxTypes[i][0]) // It is feasible solution\\n            {\\n                res += boxTypes[i][0] * boxTypes[i][1];\\n                truckSize -= boxTypes[i][0];\\n            }\\n            else\\n            {\\n                res += truckSize * boxTypes[i][1]; // Partially feasible solution\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325215,
                "title": "clean-java-solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes,(a,b)-> b[1]-a[1]);\\n        int  units=0;\\n        int ans=0;\\n        for(int[] arr:boxTypes) {\\n            if(units>=truckSize) return ans;\\n            if(arr[0]+units>truckSize) ans+=(truckSize-units)*arr[1];\\n            else ans+=arr[0]*arr[1];\\n            units+=arr[0];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes,(a,b)-> b[1]-a[1]);\\n        int  units=0;\\n        int ans=0;\\n        for(int[] arr:boxTypes) {\\n            if(units>=truckSize) return ans;\\n            if(arr[0]+units>truckSize) ans+=(truckSize-units)*arr[1];\\n            else ans+=arr[0]*arr[1];\\n            units+=arr[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1316310,
                "title": "java-simple-solution-with-comments",
                "content": "class Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        //Sorting(java-8 lambda) the array in such a way that the boxes which contain more units will appear first.\\n        Arrays.sort(boxTypes, (x,y) -> y[1]-x[1]);\\n        \\n        //count to store the total\\n        int count=0; \\n        \\n        //length to iterate array\\n        int size = boxTypes.length;\\n        \\n        for(int i=0; i<size; i++)\\n        {\\n            //if truck size is more than the boxes available of type i, we can include all the boxes\\n            if(truckSize>boxTypes[i][0]){\\n                count += boxTypes[i][0]*boxTypes[i][1];\\n                //reduce the size of the truck by the number of boxes added\\n                truckSize -= boxTypes[i][0];\\n            }\\n            //here the truck size is less than the boxes available of type i, so we will include only the boxes which truck can accomidate.\\n            else{\\n                count += truckSize*boxTypes[i][1];\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        //Sorting(java-8 lambda) the array in such a way that the boxes which contain more units will appear first.\\n        Arrays.sort(boxTypes, (x,y) -> y[1]-x[1]);\\n        \\n        //count to store the total\\n        int count=0; \\n        \\n        //length to iterate array\\n        int size = boxTypes.length;\\n        \\n        for(int i=0; i<size; i++)\\n        {\\n            //if truck size is more than the boxes available of type i, we can include all the boxes\\n            if(truckSize>boxTypes[i][0]){\\n                count += boxTypes[i][0]*boxTypes[i][1];\\n                //reduce the size of the truck by the number of boxes added\\n                truckSize -= boxTypes[i][0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1300759,
                "title": "easy-python-solution-95-99",
                "content": "Runtime: 144 ms, faster than 95.99% of Python3 online submissions for Maximum Units on a Truck.\\nMemory Usage: 14.8 MB, less than 69.71% of Python3 online submissions for Maximum Units on a Truck.\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        c=0\\n        s=0\\n        boxTypes=sorted(boxTypes, key=lambda x : -x[1])\\n        i=0\\n        while truckSize>0 and i<len(boxTypes):\\n            truckSize-=boxTypes[i][0]\\n            if(truckSize>=0):\\n                s+=boxTypes[i][0]*boxTypes[i][1]\\n            else:\\n                c=0-truckSize\\n                s+=(boxTypes[i][0]-c)*boxTypes[i][1]\\n            i+=1\\n        return s\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 144 ms, faster than 95.99% of Python3 online submissions for Maximum Units on a Truck.\\nMemory Usage: 14.8 MB, less than 69.71% of Python3 online submissions for Maximum Units on a Truck.\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        c=0\\n        s=0\\n        boxTypes=sorted(boxTypes, key=lambda x : -x[1])\\n        i=0\\n        while truckSize>0 and i<len(boxTypes):\\n            truckSize-=boxTypes[i][0]\\n            if(truckSize>=0):\\n                s+=boxTypes[i][0]*boxTypes[i][1]\\n            else:\\n                c=0-truckSize\\n                s+=(boxTypes[i][0]-c)*boxTypes[i][1]\\n            i+=1\\n        return s\\n",
                "codeTag": "Java"
            },
            {
                "id": 1274030,
                "title": "c-32ms-greedy-solution-using-sorting-logic",
                "content": "```\\nclass Solution {\\n \\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int ans = 0;\\n        \\n        vector<pair<int, int>> data;\\n        \\n        for(auto i=0; i<boxTypes.size(); i++)\\n            data.push_back( make_pair(boxTypes[i][1], boxTypes[i][0]) );  // no of units per box , no of boxes\\n        \\n        sort(data.begin(), data.end());\\n        reverse(data.begin(), data.end());\\n        \\n        int i=0;\\n        \\n        while(truckSize != 0 && i<data.size()) {\\n            \\n            ans += min(truckSize, data[i].second) * data[i].first;\\n            truckSize -= min(truckSize, data[i].second);\\n            i++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int ans = 0;\\n        \\n        vector<pair<int, int>> data;\\n        \\n        for(auto i=0; i<boxTypes.size(); i++)\\n            data.push_back( make_pair(boxTypes[i][1], boxTypes[i][0]) );  // no of units per box , no of boxes\\n        \\n        sort(data.begin(), data.end());\\n        reverse(data.begin(), data.end());\\n        \\n        int i=0;\\n        \\n        while(truckSize != 0 && i<data.size()) {\\n            \\n            ans += min(truckSize, data[i].second) * data[i].first;\\n            truckSize -= min(truckSize, data[i].second);\\n            i++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272870,
                "title": "java-with-sort-method",
                "content": "if you like it pls upvote\\n\\nJAVA\\n\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        int max = 0;\\n\\n        Arrays.sort(boxTypes, (int[]a, int[]b) -> (b[1] - a[1]));\\n\\n        for(int i = 0; i < boxTypes.length && truckSize >0; i++){\\n            int[] boxType = boxTypes[i];\\n            max += Math.min(truckSize,boxType[0])*boxType[1];\\n            truckSize-=Math.min(truckSize,boxType[0]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        int max = 0;\\n\\n        Arrays.sort(boxTypes, (int[]a, int[]b) -> (b[1] - a[1]));\\n\\n        for(int i = 0; i < boxTypes.length && truckSize >0; i++){\\n            int[] boxType = boxTypes[i];\\n            max += Math.min(truckSize,boxType[0])*boxType[1];\\n            truckSize-=Math.min(truckSize,boxType[0]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271988,
                "title": "maximum-units-on-a-truck-python-simple-self-explainatory-code",
                "content": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda boxType: boxType[1], reverse=True)\\n        boxUnits = 0\\n        boxes = 0\\n        for boxType in boxTypes:\\n            remainingSize = truckSize - boxes\\n            if remainingSize == 0:\\n                break\\n            else:\\n                boxesAdded = min(boxType[0], remainingSize)\\n                boxes += boxesAdded\\n                boxUnits += (boxesAdded * boxType[1])\\n        return boxUnits\\n```\\n\\n***If you like the above solution then please upvote.***",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda boxType: boxType[1], reverse=True)\\n        boxUnits = 0\\n        boxes = 0\\n        for boxType in boxTypes:\\n            remainingSize = truckSize - boxes\\n            if remainingSize == 0:\\n                break\\n            else:\\n                boxesAdded = min(boxType[0], remainingSize)\\n                boxes += boxesAdded\\n                boxUnits += (boxesAdded * boxType[1])\\n        return boxUnits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271907,
                "title": "java-beginner-friendly-easy-comments-greedy",
                "content": "**Please upvote if you like it :)**\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t//sort based on the number of units\\n        Arrays.sort(boxTypes, (a,b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for(int[] box : boxTypes)\\n        {\\n\\t\\t//if the current no. of boxes is less than or equal to the TruckSize then add all the units and reduce the truckSize by the amount of boxes that hadve been added.\\n            if(box[0] <= truckSize)\\n            {\\n                ans += box[1] * box[0];\\n                truckSize -= box[0];\\n            }\\n\\t\\t\\t//if you have extra boxes than is required(truckSize) then add the no. of units which is equal to the truckSize and return.\\n            else\\n            {\\n                ans += box[1] * truckSize;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n\\t//sort based on the number of units\\n        Arrays.sort(boxTypes, (a,b) -> b[1] - a[1]);\\n        int ans = 0;\\n        for(int[] box : boxTypes)\\n        {\\n\\t\\t//if the current no. of boxes is less than or equal to the TruckSize then add all the units and reduce the truckSize by the amount of boxes that hadve been added.\\n            if(box[0] <= truckSize)\\n            {\\n                ans += box[1] * box[0];\\n                truckSize -= box[0];\\n            }\\n\\t\\t\\t//if you have extra boxes than is required(truckSize) then add the no. of units which is equal to the truckSize and return.\\n            else\\n            {\\n                ans += box[1] * truckSize;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271600,
                "title": "java-priority-queue-heap",
                "content": "Idea: How Priority Queue with lambda works? It works in the following way. If you put these elements ```[[6, 3],[3, 2],[1, 5]]```, then the expression ```\\n(a, b) -> b[1] - a[1]``` will make ```Starting point of poll(): [1, 5] <- [6, 3] <- [3, 2]]``` because we want to have boxes that contain the largest number of units to maximize the truck.\\n\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>((a, b) -> b[1] - a[1]);\\n        \\n        for (int[] box_type : boxTypes)\\n            heap.offer(box_type);\\n    \\n        int units = 0;\\n        while (truckSize >= 0 && !heap.isEmpty()) {\\n            int[] box_type = heap.poll();\\n            int boxes = Math.min(truckSize, box_type[0]);\\n            \\n            units += boxes * box_type[1];\\n            truckSize -= boxes;\\n        } \\n        \\n        return units;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```[[6, 3],[3, 2],[1, 5]]```\n```\\n(a, b) -> b[1] - a[1]```\n```Starting point of poll(): [1, 5] <- [6, 3] <- [3, 2]]```\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>((a, b) -> b[1] - a[1]);\\n        \\n        for (int[] box_type : boxTypes)\\n            heap.offer(box_type);\\n    \\n        int units = 0;\\n        while (truckSize >= 0 && !heap.isEmpty()) {\\n            int[] box_type = heap.poll();\\n            int boxes = Math.min(truckSize, box_type[0]);\\n            \\n            units += boxes * box_type[1];\\n            truckSize -= boxes;\\n        } \\n        \\n        return units;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1271535,
                "title": "efficient-fast-approach-using-python",
                "content": "```\\nclass Solution(object):\\n    def maximumUnits(self, boxTypes, truckSize):\\n        \"\"\"\\n        :type boxTypes: List[List[int]]\\n        :type truckSize: int\\n        :rtype: int\\n        \"\"\"\\n        boxTypes.sort(key=itemgetter(1), reverse=1)\\n        units = 0\\n        for i,j in boxTypes:\\n            i = min(i, truckSize)\\n            k = i * j\\n            units += k\\n            truckSize -= i\\n            if (truckSize == 0):\\n                break\\n        return units\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximumUnits(self, boxTypes, truckSize):\\n        \"\"\"\\n        :type boxTypes: List[List[int]]\\n        :type truckSize: int\\n        :rtype: int\\n        \"\"\"\\n        boxTypes.sort(key=itemgetter(1), reverse=1)\\n        units = 0\\n        for i,j in boxTypes:\\n            i = min(i, truckSize)\\n            k = i * j\\n            units += k\\n            truckSize -= i\\n            if (truckSize == 0):\\n                break\\n        return units\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200213,
                "title": "python-using-max-heap",
                "content": "```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        \\n        heap, maxUnits = list(), 0\\n        \\n        for boxType in boxTypes:\\n            boxes, units = boxType\\n            heapq.heappush(heap, (-units, boxes))\\n        \\n        while heap and truckSize > 0:\\n            units, boxes = heapq.heappop(heap)            \\n            maxUnits = maxUnits + (-1 * units * (boxes if truckSize >= boxes else truckSize))\\n            truckSize -= boxes            \\n        \\n        return maxUnits\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        \\n        heap, maxUnits = list(), 0\\n        \\n        for boxType in boxTypes:\\n            boxes, units = boxType\\n            heapq.heappush(heap, (-units, boxes))\\n        \\n        while heap and truckSize > 0:\\n            units, boxes = heapq.heappop(heap)            \\n            maxUnits = maxUnits + (-1 * units * (boxes if truckSize >= boxes else truckSize))\\n            truckSize -= boxes            \\n        \\n        return maxUnits\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1197176,
                "title": "simple-and-understoodable-js-sol",
                "content": "```\\n  /**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    boxTypes.sort((a,b)=>(b[1]-a[1]));\\n    var count=0,sum=0;\\n    for(var i=0;i<boxTypes.length;i++)\\n    {  \\n       for(var t=0;t<boxTypes[i][0];t++)\\n       {  \\n           sum+=1;\\n           if(sum<=truckSize)\\n           {\\n               \\n              count+=boxTypes[i][1];\\n           }\\n           \\n       }\\n       \\n    }\\n     return count;  \\n};",
                "solutionTags": [],
                "code": "```\\n  /**\\n * @param {number[][]} boxTypes\\n * @param {number} truckSize\\n * @return {number}\\n */\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    boxTypes.sort((a,b)=>(b[1]-a[1]));\\n    var count=0,sum=0;\\n    for(var i=0;i<boxTypes.length;i++)\\n    {  \\n       for(var t=0;t<boxTypes[i][0];t++)\\n       {  \\n           sum+=1;\\n           if(sum<=truckSize)\\n           {\\n               \\n              count+=boxTypes[i][1];\\n           }\\n           \\n       }\\n       \\n    }\\n     return count;  \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1175005,
                "title": "c-sort-greedy",
                "content": "Approach 1:  Greedy Solution\\nTime/Space: O(NlogN); O(1)\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), [&](auto& a, auto& b){return a[1] > b[1];}); // sort the input array descendingly\\n        int ans = 0;\\n        for(auto& e: boxTypes){\\n            if(truckSize < 0) break;\\n            int num_of_choosing_boxes = min(e[0], truckSize);\\n            ans += num_of_choosing_boxes * e[1];\\n            truckSize -=num_of_choosing_boxes;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(), boxTypes.end(), [&](auto& a, auto& b){return a[1] > b[1];}); // sort the input array descendingly\\n        int ans = 0;\\n        for(auto& e: boxTypes){\\n            if(truckSize < 0) break;\\n            int num_of_choosing_boxes = min(e[0], truckSize);\\n            ans += num_of_choosing_boxes * e[1];\\n            truckSize -=num_of_choosing_boxes;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154970,
                "title": "java-100-fast-without-arrays-sort",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        int count[] = new int[1001];\\n        \\n        for(int i=0; i<boxTypes.length; i++){\\n            count[boxTypes[i][1]] += boxTypes[i][0];\\n        }\\n        \\n        int res = 0;\\n        \\n\\t\\t// Reverse traverse so that maximum units will be hit first\\n        for(int i=count.length-1; i>=0; i--){\\n            if(count[i] == 0) continue;\\n            \\n            if(truckSize >= count[i]){\\n                res += i*count[i];\\n                truckSize -= count[i];\\n            } else {\\n                res += i*truckSize;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        \\n        int count[] = new int[1001];\\n        \\n        for(int i=0; i<boxTypes.length; i++){\\n            count[boxTypes[i][1]] += boxTypes[i][0];\\n        }\\n        \\n        int res = 0;\\n        \\n\\t\\t// Reverse traverse so that maximum units will be hit first\\n        for(int i=count.length-1; i>=0; i--){\\n            if(count[i] == 0) continue;\\n            \\n            if(truckSize >= count[i]){\\n                res += i*count[i];\\n                truckSize -= count[i];\\n            } else {\\n                res += i*truckSize;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096763,
                "title": "javascript-python",
                "content": "```\\nconst maximumUnits = (boxTypes, truckSize) => {\\n    boxTypes.sort((a, b) => b[1] - a[1])\\n    let currentSize = 0\\n    let total = 0\\n    for(const [idx, val] of boxTypes.entries()) {\\n        const [box, unit] = val\\n        total += unit * Math.min(truckSize - currentSize, box)\\n        currentSize += Math.min(truckSize - currentSize, box)\\n    }\\n    return total\\n};\\n```\\n\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: -x[1])\\n        current_size, total = 0, 0\\n        for box, unit in boxTypes:\\n            total += unit * min(truckSize - current_size, box)\\n            current_size += min(truckSize - current_size, box)\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nconst maximumUnits = (boxTypes, truckSize) => {\\n    boxTypes.sort((a, b) => b[1] - a[1])\\n    let currentSize = 0\\n    let total = 0\\n    for(const [idx, val] of boxTypes.entries()) {\\n        const [box, unit] = val\\n        total += unit * Math.min(truckSize - currentSize, box)\\n        currentSize += Math.min(truckSize - currentSize, box)\\n    }\\n    return total\\n};\\n```\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x: -x[1])\\n        current_size, total = 0, 0\\n        for box, unit in boxTypes:\\n            total += unit * min(truckSize - current_size, box)\\n            current_size += min(truckSize - current_size, box)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045278,
                "title": "easy-python-solution-using-sorting",
                "content": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x:x[1]) #sort boxtypes based on the number of units per box\\n        result = 0\\n        while truckSize>0:\\n            # check if there are any boxes to load\\n            if len(boxTypes)>0:\\n                num_boxes, units_per_box = boxTypes.pop()\\n                # check if the truck has the capacity to load all the boxes of type i, if yes, then load the boxes\\n                if num_boxes<=truckSize:\\n                    result += (num_boxes * units_per_box)\\n                    truckSize -= num_boxes\\n                # if the truck doesn\\'t have enough capacity to load all the boxes of type i, then load only the number of boxes the truck can accommodate.    \\n                else:\\n                    result += (truckSize * units_per_box)\\n                    truckSize -= truckSize\\n            # if all the boxes have been loaded and yet there is empty space in the truck, then break the loop.\\n            else:\\n                break\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key=lambda x:x[1]) #sort boxtypes based on the number of units per box\\n        result = 0\\n        while truckSize>0:\\n            # check if there are any boxes to load\\n            if len(boxTypes)>0:\\n                num_boxes, units_per_box = boxTypes.pop()\\n                # check if the truck has the capacity to load all the boxes of type i, if yes, then load the boxes\\n                if num_boxes<=truckSize:\\n                    result += (num_boxes * units_per_box)\\n                    truckSize -= num_boxes\\n                # if the truck doesn\\'t have enough capacity to load all the boxes of type i, then load only the number of boxes the truck can accommodate.    \\n                else:\\n                    result += (truckSize * units_per_box)\\n                    truckSize -= truckSize\\n            # if all the boxes have been loaded and yet there is empty space in the truck, then break the loop.\\n            else:\\n                break\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029167,
                "title": "javascript-no-sorting-o-n-beats-99-6",
                "content": "```javascript\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    const bucket = [];\\n    let total = 0;\\n    \\n    for(let i = 0; i < boxTypes.length; i++) {\\n        const [numBox, numUnit] = boxTypes[i];\\n        if(!bucket[numUnit]) bucket[numUnit] = numBox;\\n        else bucket[numUnit] += numBox;\\n    }\\n    \\n    for(let i = bucket.length-1; i >= 0; i--) {\\n        if(!bucket[i]) continue;\\n            \\n        const numBox = bucket[i];\\n\\n        if(truckSize >= numBox) {\\n            total += (numBox * i);\\n            truckSize -= numBox;\\n        } else {\\n            total += (truckSize * i);\\n            return total;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    const bucket = [];\\n    let total = 0;\\n    \\n    for(let i = 0; i < boxTypes.length; i++) {\\n        const [numBox, numUnit] = boxTypes[i];\\n        if(!bucket[numUnit]) bucket[numUnit] = numBox;\\n        else bucket[numUnit] += numBox;\\n    }\\n    \\n    for(let i = bucket.length-1; i >= 0; i--) {\\n        if(!bucket[i]) continue;\\n            \\n        const numBox = bucket[i];\\n\\n        if(truckSize >= numBox) {\\n            total += (numBox * i);\\n            truckSize -= numBox;\\n        } else {\\n            total += (truckSize * i);\\n            return total;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1006473,
                "title": "simple-swift-solution",
                "content": "Simple Swift solution\\n```\\nclass Solution {\\n    func maximumUnits(_ boxTypes: [[Int]], _ truckSize: Int) -> Int {\\n        let boxTypes = boxTypes.sorted(by: { $0[1] > $1[1] })\\n        var result = 0, remainder = truckSize\\n        for boxType in boxTypes {\\n            if remainder > 0 {\\n                result += min(remainder, boxType[0]) * boxType[1]\\n                remainder -= boxType[0]\\n            } else {\\n                break\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumUnits(_ boxTypes: [[Int]], _ truckSize: Int) -> Int {\\n        let boxTypes = boxTypes.sorted(by: { $0[1] > $1[1] })\\n        var result = 0, remainder = truckSize\\n        for boxType in boxTypes {\\n            if remainder > 0 {\\n                result += min(remainder, boxType[0]) * boxType[1]\\n                remainder -= boxType[0]\\n            } else {\\n                break\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001777,
                "title": "c-solution",
                "content": "```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tsort(boxTypes.begin(), boxTypes.end(), [] (vector<int>& a, vector<int>& b) {\\n\\t\\treturn a[1] > b[1];\\n\\t});\\n\\tint resUnits = 0, resBoxes = 0;\\n\\tfor (auto curBox : boxTypes) {\\n\\t\\tif (resBoxes == truckSize)\\n\\t\\t\\tbreak;\\n\\n\\t\\tint curBoxes = min(curBox[0], truckSize - resBoxes);\\n\\t\\tresBoxes += curBoxes;\\n\\t\\tresUnits += (curBoxes * curBox[1]);\\n\\t}\\n\\treturn resUnits;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\tsort(boxTypes.begin(), boxTypes.end(), [] (vector<int>& a, vector<int>& b) {\\n\\t\\treturn a[1] > b[1];\\n\\t});\\n\\tint resUnits = 0, resBoxes = 0;\\n\\tfor (auto curBox : boxTypes) {\\n\\t\\tif (resBoxes == truckSize)\\n\\t\\t\\tbreak;\\n\\n\\t\\tint curBoxes = min(curBox[0], truckSize - resBoxes);\\n\\t\\tresBoxes += curBoxes;\\n\\t\\tresUnits += (curBoxes * curBox[1]);\\n\\t}\\n\\treturn resUnits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000278,
                "title": "python-sort-short-and-fast-100",
                "content": "Using sort for complexit of N log N. \\nFrom an algorithmic point of view a more optimal solution is to use heap, but it would be slower in python and more complicated.\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        result = 0\\n        for num, units in sorted(boxTypes, reverse=True, key=itemgetter(1)):\\n            if num < truckSize:\\n                result += num * units\\n                truckSize -= num\\n            else:\\n                result += truckSize * units\\n                break\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        result = 0\\n        for num, units in sorted(boxTypes, reverse=True, key=itemgetter(1)):\\n            if num < truckSize:\\n                result += num * units\\n                truckSize -= num\\n            else:\\n                result += truckSize * units\\n                break\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999756,
                "title": "c-easy-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstatic bool mycomp(vector<int> &a,vector<int> &b){\\n\\t\\t\\treturn a[1] >= b[1];\\n\\t\\t}\\n\\n\\t\\tint maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n\\n\\t\\t\\tsort(boxTypes.begin(), boxTypes.end(), mycomp);\\n\\n\\t\\t\\tlong long int ans = 0;\\n\\n\\t\\t\\tfor(int i=0;i<boxTypes.size();i++){\\n\\n\\t\\t\\t\\tans += min(truckSize,boxTypes[i][0]) * boxTypes[i][1];\\n\\n\\t\\t\\t\\ttruckSize -= min(truckSize,boxTypes[i][0]);\\n\\n\\t\\t\\t\\tif(truckSize == 0) break;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstatic bool mycomp(vector<int> &a,vector<int> &b){\\n\\t\\t\\treturn a[1] >= b[1];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 999513,
                "title": "javascript-solution-using-sort-92-ms",
                "content": "```\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    let result = 0;\\n    boxTypes.sort((a, b) => b[1] - a[1]);\\n    \\n    for (let i = 0; i < boxTypes.length; ++i) {\\n        if (boxTypes[i][0] > truckSize) {\\n            result += truckSize * boxTypes[i][1];\\n            break;\\n        } else {\\n            result += boxTypes[i][0] * boxTypes[i][1];\\n            truckSize -= boxTypes[i][0];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximumUnits = function(boxTypes, truckSize) {\\n    let result = 0;\\n    boxTypes.sort((a, b) => b[1] - a[1]);\\n    \\n    for (let i = 0; i < boxTypes.length; ++i) {\\n        if (boxTypes[i][0] > truckSize) {\\n            result += truckSize * boxTypes[i][1];\\n            break;\\n        } else {\\n            result += boxTypes[i][0] * boxTypes[i][1];\\n            truckSize -= boxTypes[i][0];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999404,
                "title": "simple-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector<int> v1 , vector<int> v2 ){\\n        return v1[1] >  v2[1] ;\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),  boxTypes.end() , cmp );\\n        \\n        int n =  boxTypes.size();\\n        int ans =0, i =0;\\n        \\n        while (truckSize >  0  && i < n ){\\n            \\n            int used =  (truckSize - boxTypes[i][0] >=0 ) ? boxTypes[i][0] : truckSize;\\n            \\n            truckSize -= (used);\\n            ans += (used * boxTypes[i][1]);\\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector<int> v1 , vector<int> v2 ){\\n        return v1[1] >  v2[1] ;\\n    }\\n    \\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        sort(boxTypes.begin(),  boxTypes.end() , cmp );\\n        \\n        int n =  boxTypes.size();\\n        int ans =0, i =0;\\n        \\n        while (truckSize >  0  && i < n ){\\n            \\n            int used =  (truckSize - boxTypes[i][0] >=0 ) ? boxTypes[i][0] : truckSize;\\n            \\n            truckSize -= (used);\\n            ans += (used * boxTypes[i][1]);\\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999397,
                "title": "rust-greedy",
                "content": "```rust\\nimpl Solution {\\n    pub fn maximum_units(mut box_types: Vec<Vec<i32>>, mut truck_size: i32) -> i32 {\\n        let mut res = 0;\\n        box_types.sort_by_key(|x| -x[1]);\\n        for p in box_types {\\n            let (boxes, units) = (p[0], p[1]);\\n            let x = truck_size.min(boxes);\\n            truck_size -= x;\\n            res += x * units;\\n        }\\n        res\\n    }\\n}\\n```\\n\\nCheaty 1-liner using scan (sadly no \"sorted\" function):\\n```rust\\nimpl Solution {\\n    pub fn maximum_units(mut b: Vec<Vec<i32>>, t: i32) -> i32 {\\n        b.sort_by_key(|x|-x[1]); b.into_iter().scan(t,|s, p|{let(b,u)=(p[0].min(*s),p[1]);*s-=b;Some(b*u)}).sum()\\n    }\\n}\\n```\\n\\nUsing fold function:\\n```rust\\nimpl Solution {\\n    pub fn maximum_units(mut box_types: Vec<Vec<i32>>, truck_size: i32) -> i32 {\\n        box_types.sort_by_key(|x|-x[1]);\\n        box_types.into_iter().fold((truck_size, 0), |(s, acc), p| ((s - p[0]).max(0), acc + p[1] * p[0].min(s))).1\\n    }\\n}\\n```\\n\\nAlso check out my oneliner in Python: https://leetcode.com/problems/maximum-units-on-a-truck/discuss/999325/Python-oneliner",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximum_units(mut box_types: Vec<Vec<i32>>, mut truck_size: i32) -> i32 {\\n        let mut res = 0;\\n        box_types.sort_by_key(|x| -x[1]);\\n        for p in box_types {\\n            let (boxes, units) = (p[0], p[1]);\\n            let x = truck_size.min(boxes);\\n            truck_size -= x;\\n            res += x * units;\\n        }\\n        res\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn maximum_units(mut b: Vec<Vec<i32>>, t: i32) -> i32 {\\n        b.sort_by_key(|x|-x[1]); b.into_iter().scan(t,|s, p|{let(b,u)=(p[0].min(*s),p[1]);*s-=b;Some(b*u)}).sum()\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn maximum_units(mut box_types: Vec<Vec<i32>>, truck_size: i32) -> i32 {\\n        box_types.sort_by_key(|x|-x[1]);\\n        box_types.into_iter().fold((truck_size, 0), |(s, acc), p| ((s - p[0]).max(0), acc + p[1] * p[0].min(s))).1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999325,
                "title": "python-oneliner-greedy",
                "content": "1 line in Python:\\n\\n```python\\nclass Solution:\\n    def maximumUnits(self, b: List[List[int]], t: int) -> int:\\n        return reduce(lambda a,b:(a[0]-min(a[0],b[0]),a[1]+min(a[0],b[0])*b[1]),sorted(b,key=lambda x:x[1])[::-1],[t,0])[1]\\n```\\n\\nExplanation:\\n\\n```python\\ndef fn(a,b):\\n    truckSize, acc = a\\n    boxes, units = b\\n    return truckSize - min(truckSize, boxes), acc + min(truckSize, boxes)*units\\n\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        return reduce(fn, sorted(boxTypes,key=lambda x:x[1], reverse=True), [truckSize, 0])[1]\\n```\\n\\n**Upd.**\\n\\nAnother oneliner by @KellyBundy that beats the shit out of mine:\\n\\n```python\\ndef maximumUnits(self, b: List[List[int]], t: int) -> int:\\n    return sum(sorted(u for n, u in b for u in [u] * n)[-t:])\\n```\\n\\nHeap version by @KellyBundy that improves time for small truckSize, heapify is O(n) and every heappop is O(log n):\\n\\n```python\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n    heap = [[-u, -b] for b, u in boxTypes]\\n    heapify(heap)\\n    units = 0\\n    while heap:\\n        u, b = heappop(heap)\\n        if -b > truckSize:\\n            return units - truckSize * u\\n        units += u * b\\n        truckSize += b\\n    return units\\n```\\n\\nAlso check out Rust: https://leetcode.com/problems/maximum-units-on-a-truck/discuss/999397/Rust",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumUnits(self, b: List[List[int]], t: int) -> int:\\n        return reduce(lambda a,b:(a[0]-min(a[0],b[0]),a[1]+min(a[0],b[0])*b[1]),sorted(b,key=lambda x:x[1])[::-1],[t,0])[1]\\n```\n```python\\ndef fn(a,b):\\n    truckSize, acc = a\\n    boxes, units = b\\n    return truckSize - min(truckSize, boxes), acc + min(truckSize, boxes)*units\\n\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        return reduce(fn, sorted(boxTypes,key=lambda x:x[1], reverse=True), [truckSize, 0])[1]\\n```\n```python\\ndef maximumUnits(self, b: List[List[int]], t: int) -> int:\\n    return sum(sorted(u for n, u in b for u in [u] * n)[-t:])\\n```\n```python\\ndef maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n    heap = [[-u, -b] for b, u in boxTypes]\\n    heapify(heap)\\n    units = 0\\n    while heap:\\n        u, b = heappop(heap)\\n        if -b > truckSize:\\n            return units - truckSize * u\\n        units += u * b\\n        truckSize += b\\n    return units\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999268,
                "title": "java-greedy-solution",
                "content": "Basically we need to load the heaviest box first to get the optimal solution. So we need to sort the box based on the weight.\\n```\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]); // Sort the box reversely.\\n        int ans = 0, index = 0;\\n        while (truckSize > 0) {\\n            if (truckSize > boxTypes[index][0]) {\\n                truckSize -= boxTypes[index][0];\\n                ans += boxTypes[index][1] * boxTypes[index][0];\\n                index++;\\n                if (index == boxTypes.length) break; // If load all boxes, break immediately to avoid out of boundary.\\n            } else {\\n                ans += boxTypes[index][1] * truckSize;\\n                truckSize = 0;\\n            }\\n        }\\n        return ans;        \\n    }\\n```\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(1) means no extra space.",
                "solutionTags": [],
                "code": "```\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]); // Sort the box reversely.\\n        int ans = 0, index = 0;\\n        while (truckSize > 0) {\\n            if (truckSize > boxTypes[index][0]) {\\n                truckSize -= boxTypes[index][0];\\n                ans += boxTypes[index][1] * boxTypes[index][0];\\n                index++;\\n                if (index == boxTypes.length) break; // If load all boxes, break immediately to avoid out of boundary.\\n            } else {\\n                ans += boxTypes[index][1] * truckSize;\\n                truckSize = 0;\\n            }\\n        }\\n        return ans;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999198,
                "title": "java-solution",
                "content": "```\\n\\n```class Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n     \\n        \\n        Arrays.sort(boxTypes, new java.util.Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) {\\n        int q =Integer.compare(a[1], b[1]);\\n        if(q==1 || q==-1){\\n            return Integer.compare(b[1], a[1]);\\n        }else {\\n             return Integer.compare(a[0], b[0]);\\n        }\\n    }\\n});\\nint sum=0;\\n     for(int i=0;i<boxTypes.length;i++){\\n\\t\\tif(boxTypes[i][0]<=truckSize){\\n                sum+=(boxTypes[i][0]*boxTypes[i][1]);\\n                truckSize-=boxTypes[i][0];\\n   }\\n            else if (boxTypes[i][0]>truckSize){\\n                \\n                sum+=truckSize*boxTypes[i][1];\\n                truckSize=0;\\n                \\n            }\\n        }\\n        \\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999117,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& b, int k) {\\n        sort(b.begin(),b.end(),[](vector<int> &x,vector<int> &y){\\n            return x[1]>y[1];\\n        });\\n        \\n        int ans=0;\\n        for(int i=0;i<b.size() && k;i++){\\n            int units = min(b[i][0],k);\\n            ans += units*b[i][1];\\n            k -= units;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& b, int k) {\\n        sort(b.begin(),b.end(),[](vector<int> &x,vector<int> &y){\\n            return x[1]>y[1];\\n        });\\n        \\n        int ans=0;\\n        for(int i=0;i<b.size() && k;i++){\\n            int units = min(b[i][0],k);\\n            ans += units*b[i][1];\\n            k -= units;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999101,
                "title": "easy-java-o-nlogn-greedy",
                "content": "```\\n\\n    public int maximumUnits(int[][] boxTypes, int truckSize) \\n    {\\n        int max = 0;\\n        \\n        Arrays.sort(boxTypes, (int[]a, int[]b) -> (b[1] - a[1]));\\n        \\n        for(int i = 0; i < boxTypes.length; i++)\\n        {\\n            int[] boxType = boxTypes[i];\\n            \\n            while(truckSize > 0 && boxType[0] > 0)\\n            {\\n                max += boxType[1];\\n                boxType[0]--;\\n                truckSize--;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public int maximumUnits(int[][] boxTypes, int truckSize) \\n    {\\n        int max = 0;\\n        \\n        Arrays.sort(boxTypes, (int[]a, int[]b) -> (b[1] - a[1]));\\n        \\n        for(int i = 0; i < boxTypes.length; i++)\\n        {\\n            int[] boxType = boxTypes[i];\\n            \\n            while(truckSize > 0 && boxType[0] > 0)\\n            {\\n                max += boxType[1];\\n                boxType[0]--;\\n                truckSize--;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 999095,
                "title": "a-few-solutions",
                "content": "Sort the input array `A` by decreasing density (ie. number of units per box), then greedily take `boxes` while we `have` room.  Return the accumulated maximum amount of `units` we can `take` as the `best` answer.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maximumUnits(A: Array<IntArray>, have_: Int): Int {\\n        A.sortWith(Comparator{ a: IntArray, b: IntArray -> b[1].compareTo(a[1]) })\\n        var have = have_\\n        var best = 0\\n        for ((boxes, units) in A) {\\n            var take = Math.min(have, boxes)\\n            best += take * units; have -= take\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Java*\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] A, int have) {\\n        Arrays.sort(A, (a, b) -> Integer.compare(b[1], a[1]));\\n        int best = 0;\\n        for (int[] pair: A) {\\n            int boxes = pair[0];\\n            int units = pair[1];\\n            int take = Math.min(have, boxes);\\n            best += take * units; have -= take;\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maximumUnits = (A, have, best = 0) => {\\n    A.sort((a, b) => b[1] - a[1]);\\n    for (let [boxes, units] of A) {\\n        let take = Math.min(have, boxes);\\n        best += take * units, have -= take;\\n    }\\n    return best;\\n};\\n```\\n\\n*Javascript: \"1-liner\" (just for fun! :-P)*\\n```\\nlet maximumUnits = (A, have) =>\\n    A.sort((a, b) => b[1] - a[1])\\n     .reduce((best, [boxes, units]) => {\\n        let take = Math.min(have, boxes);\\n        have -= take;\\n        return best + take * units;\\n    }, 0);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maximumUnits(self, A: List[List[int]], have: int, best = 0) -> int:\\n        A.sort(key = cmp_to_key(lambda a, b: b[1] - a[1]))\\n        for boxes, units in A:\\n            take = min(have, boxes)\\n            best += take * units; have -= take\\n        return best\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn maximum_units(mut A: Vec<Vec<i32>>, mut have: i32) -> i32 {\\n        A.sort_by(|a, b| Ord::cmp(&b[1], &a[1]));\\n        let mut best = 0;\\n        for pair in A {\\n            let (boxes, units) = (pair[0], pair[1]);\\n            let take = min(have, boxes);\\n            best += take * units; have -= take;\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maximumUnits(VVI& A, int have, int best = 0) {\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return b[1] < a[1]; });\\n        for (auto& pair: A) {\\n            auto [boxes, units] = tie(pair[0], pair[1]);\\n            auto take = min(have, boxes);\\n            best += take * units, have -= take;\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximumUnits(A: Array<IntArray>, have_: Int): Int {\\n        A.sortWith(Comparator{ a: IntArray, b: IntArray -> b[1].compareTo(a[1]) })\\n        var have = have_\\n        var best = 0\\n        for ((boxes, units) in A) {\\n            var take = Math.min(have, boxes)\\n            best += take * units; have -= take\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumUnits(int[][] A, int have) {\\n        Arrays.sort(A, (a, b) -> Integer.compare(b[1], a[1]));\\n        int best = 0;\\n        for (int[] pair: A) {\\n            int boxes = pair[0];\\n            int units = pair[1];\\n            int take = Math.min(have, boxes);\\n            best += take * units; have -= take;\\n        }\\n        return best;\\n    }\\n}\\n```\n```\\nlet maximumUnits = (A, have, best = 0) => {\\n    A.sort((a, b) => b[1] - a[1]);\\n    for (let [boxes, units] of A) {\\n        let take = Math.min(have, boxes);\\n        best += take * units, have -= take;\\n    }\\n    return best;\\n};\\n```\n```\\nlet maximumUnits = (A, have) =>\\n    A.sort((a, b) => b[1] - a[1])\\n     .reduce((best, [boxes, units]) => {\\n        let take = Math.min(have, boxes);\\n        have -= take;\\n        return best + take * units;\\n    }, 0);\\n```\n```\\nclass Solution:\\n    def maximumUnits(self, A: List[List[int]], have: int, best = 0) -> int:\\n        A.sort(key = cmp_to_key(lambda a, b: b[1] - a[1]))\\n        for boxes, units in A:\\n            take = min(have, boxes)\\n            best += take * units; have -= take\\n        return best\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn maximum_units(mut A: Vec<Vec<i32>>, mut have: i32) -> i32 {\\n        A.sort_by(|a, b| Ord::cmp(&b[1], &a[1]));\\n        let mut best = 0;\\n        for pair in A {\\n            let (boxes, units) = (pair[0], pair[1]);\\n            let take = min(have, boxes);\\n            best += take * units; have -= take;\\n        }\\n        return best;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maximumUnits(VVI& A, int have, int best = 0) {\\n        sort(A.begin(), A.end(), [](auto& a, auto& b) { return b[1] < a[1]; });\\n        for (auto& pair: A) {\\n            auto [boxes, units] = tie(pair[0], pair[1]);\\n            auto take = min(have, boxes);\\n            best += take * units, have -= take;\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744157,
                "title": "c-simple-solution-greedy-sorting",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int result = 0;\\n\\n        sort(boxTypes.begin(), boxTypes.end(), [](auto& a, auto& b) {\\n            return a[1] > b[1];\\n        });\\n\\n        for (auto& box : boxTypes) {\\n            if (truckSize < box[0]) {\\n                result += (truckSize * box[1]);\\n                break;\\n            }\\n            result += (box[0] * box[1]);\\n            truckSize -= box[0];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int result = 0;\\n\\n        sort(boxTypes.begin(), boxTypes.end(), [](auto& a, auto& b) {\\n            return a[1] > b[1];\\n        });\\n\\n        for (auto& box : boxTypes) {\\n            if (truckSize < box[0]) {\\n                result += (truckSize * box[1]);\\n                break;\\n            }\\n            result += (box[0] * box[1]);\\n            truckSize -= box[0];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722019,
                "title": "maximum-units-on-a-truck-fractional-knapsack-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts a fractional Knapsack Problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy Approach to pick up box with max. unit first\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n) //Sorting is applied\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        //Fractional Knapsack\\n        int max = 0;\\n        //Greedy: sort by units, to pick up box with max units first\\n        Arrays.sort(boxTypes,Comparator.comparingDouble(o->o[1]));\\n        \\n        //Loop backwards to pick max unit box first\\n        for(int i = boxTypes.length-1; i>=0; i--){\\n            //pick till truck has space\\n            if(truckSize >= boxTypes[i][0]){\\n                truckSize -= boxTypes[i][0];\\n                max += boxTypes[i][0] * boxTypes[i][1]; \\n            }else{\\n                max+= truckSize * boxTypes[i][1];\\n                return max;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        //Fractional Knapsack\\n        int max = 0;\\n        //Greedy: sort by units, to pick up box with max units first\\n        Arrays.sort(boxTypes,Comparator.comparingDouble(o->o[1]));\\n        \\n        //Loop backwards to pick max unit box first\\n        for(int i = boxTypes.length-1; i>=0; i--){\\n            //pick till truck has space\\n            if(truckSize >= boxTypes[i][0]){\\n                truckSize -= boxTypes[i][0];\\n                max += boxTypes[i][0] * boxTypes[i][1]; \\n            }else{\\n                max+= truckSize * boxTypes[i][1];\\n                return max;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302896,
                "title": "simple-solution-in-python-beats-84-28",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key = lambda boxTypes: boxTypes[1], reverse=True)\\n        res = cur_size = 0\\n        for box, pack in boxTypes:\\n            if cur_size == truckSize:\\n                break\\n            if box > truckSize-cur_size:\\n                return res + (truckSize-cur_size)*pack\\n            else:\\n                res += box*pack\\n                cur_size += box\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key = lambda boxTypes: boxTypes[1], reverse=True)\\n        res = cur_size = 0\\n        for box, pack in boxTypes:\\n            if cur_size == truckSize:\\n                break\\n            if box > truckSize-cur_size:\\n                return res + (truckSize-cur_size)*pack\\n            else:\\n                res += box*pack\\n                cur_size += box\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286895,
                "title": "maximum-units-on-a-truck-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int i, ans=0, box=0;\\n        \\n        for(i=0 ; i<boxTypes.size() ; i++)\\n        {\\n            reverse(boxTypes[i].begin(), boxTypes[i].end());\\n        }\\n        sort(boxTypes.begin(), boxTypes.end());\\n        reverse(boxTypes.begin(), boxTypes.end());\\n        for(i=0 ; i<boxTypes.size() ; i++)\\n        {\\n            if((box+boxTypes[i][1])<=truckSize)\\n            {\\n                ans += boxTypes[i][1]*boxTypes[i][0];\\n                box += boxTypes[i][1];\\n            }\\n            else if((box+boxTypes[i][1])>truckSize)\\n            {\\n                ans += (truckSize-box)*boxTypes[i][0];\\n                box += truckSize-box;\\n            }\\n            if(box==truckSize)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\\n        int i, ans=0, box=0;\\n        \\n        for(i=0 ; i<boxTypes.size() ; i++)\\n        {\\n            reverse(boxTypes[i].begin(), boxTypes[i].end());\\n        }\\n        sort(boxTypes.begin(), boxTypes.end());\\n        reverse(boxTypes.begin(), boxTypes.end());\\n        for(i=0 ; i<boxTypes.size() ; i++)\\n        {\\n            if((box+boxTypes[i][1])<=truckSize)\\n            {\\n                ans += boxTypes[i][1]*boxTypes[i][0];\\n                box += boxTypes[i][1];\\n            }\\n            else if((box+boxTypes[i][1])>truckSize)\\n            {\\n                ans += (truckSize-box)*boxTypes[i][0];\\n                box += truckSize-box;\\n            }\\n            if(box==truckSize)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069403,
                "title": "easy-python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        box=0        \\n        boxTypes.sort(key=lambda x:-x[1])\\n        for i in range(len(boxTypes)):\\n            if truckSize>=boxTypes[i][0]:\\n                truckSize -= boxTypes[i][0]\\n                box += boxTypes[i][0]*boxTypes[i][1]\\n            else:\\n                box += boxTypes[i][1]*truckSize\\n                break\\n        return box\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        box=0        \\n        boxTypes.sort(key=lambda x:-x[1])\\n        for i in range(len(boxTypes)):\\n            if truckSize>=boxTypes[i][0]:\\n                truckSize -= boxTypes[i][0]\\n                box += boxTypes[i][0]*boxTypes[i][1]\\n            else:\\n                box += boxTypes[i][1]*truckSize\\n                break\\n        return box\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927702,
                "title": "java-maxheap-greedy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem says we need to get maximum units within the truckSize limit(meaning truck can hold only limited boxes). So lets be **_greedy_** and use **_maxHeap_** to sort boxes with max \\'units\\'. This way we will be able store boxes with most units and get more space for other boxes with more units...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet us sort the array according to \\'units\\' value. The maxHeap can be used with greedy approach. \\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> Integer.compare(b[1] , \\n        a[1]));\\n        int i = 0;\\n        while(heap.size() < boxTypes.length){\\n            heap.offer(boxTypes[i++]);\\n        }\\n        int[] boxAndUnitCount;\\n        int totalMaxUnits = 0;\\n        while(!heap.isEmpty() && truckSize > 0){\\n            boxAndUnitCount = heap.poll();\\n            if(truckSize - boxAndUnitCount[0] >= 0)\\n                totalMaxUnits += boxAndUnitCount[0]*boxAndUnitCount[1];\\n            else\\n                totalMaxUnits += truckSize * boxAndUnitCount[1];\\n            truckSize -= boxAndUnitCount[0];\\n        }\\n\\n        return totalMaxUnits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> Integer.compare(b[1] , \\n        a[1]));\\n        int i = 0;\\n        while(heap.size() < boxTypes.length){\\n            heap.offer(boxTypes[i++]);\\n        }\\n        int[] boxAndUnitCount;\\n        int totalMaxUnits = 0;\\n        while(!heap.isEmpty() && truckSize > 0){\\n            boxAndUnitCount = heap.poll();\\n            if(truckSize - boxAndUnitCount[0] >= 0)\\n                totalMaxUnits += boxAndUnitCount[0]*boxAndUnitCount[1];\\n            else\\n                totalMaxUnits += truckSize * boxAndUnitCount[1];\\n            truckSize -= boxAndUnitCount[0];\\n        }\\n\\n        return totalMaxUnits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861167,
                "title": "python-faster-than-81-43-memory-beats-84-9",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(reverse=True, key=lambda x:x[1])\\n        units = 0\\n        boxesUsed = 0\\n        for box in boxTypes:\\n            if boxesUsed == truckSize: return units\\n            if boxesUsed + box[0] <= truckSize:\\n                units += box[1] * box[0]\\n                boxesUsed += box[0]\\n            elif boxesUsed + box[0] > truckSize:\\n                units += box[1] * (truckSize - boxesUsed)\\n                boxesUsed += truckSize - boxesUsed\\n        return units\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/99b8fe17-63a4-4b3f-97ca-73d17f86056a_1669769957.803379.png)\\n![image.png](https://assets.leetcode.com/users/images/ddf2151e-735e-4768-a95a-859b496d02a4_1669770109.2075849.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(reverse=True, key=lambda x:x[1])\\n        units = 0\\n        boxesUsed = 0\\n        for box in boxTypes:\\n            if boxesUsed == truckSize: return units\\n            if boxesUsed + box[0] <= truckSize:\\n                units += box[1] * box[0]\\n                boxesUsed += box[0]\\n            elif boxesUsed + box[0] > truckSize:\\n                units += box[1] * (truckSize - boxesUsed)\\n                boxesUsed += truckSize - boxesUsed\\n        return units\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860831,
                "title": "c-very-very-easy-solution-without-using-built-in-functions",
                "content": "```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n     int result = 0, boxTypesCount = 0, orginalTruckSize = truckSize;\\n\\n            boxTypes = selectionSortDesc(boxTypes, 1);\\n\\n            for (int i = 0; i < boxTypes.Length; i++)\\n            {\\n                truckSize -= boxTypes[i][0];\\n\\n                if (truckSize < 0)\\n                {\\n                    result += (orginalTruckSize - boxTypesCount) * boxTypes[i][1];\\n                    break;\\n                }\\n\\n                result += (boxTypes[i][0]) * boxTypes[i][1];\\n                boxTypesCount += boxTypes[i][0];\\n\\n            }\\n\\n            return result;   \\n    }\\n\\n            static int[][] selectionSortDesc(int[][] arr, int sortIndexValue)\\n        {\\n            int[] temp = new int[2];\\n\\n            if (sortIndexValue == 0 || sortIndexValue == 1)\\n            {\\n                for (int i = 0; i < arr.Length - 1; i++)\\n                {\\n                    for (int j = i+1; j < arr.Length ; j++)\\n                    {\\n                        if (arr[i][sortIndexValue] < arr[j][sortIndexValue])\\n                        {\\n                            temp = arr[i];\\n                            arr[i] = arr[j];\\n                            arr[j] = temp;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                Console.WriteLine(\"Invalid sortIndexValue\");\\n            }\\n\\n            return arr;\\n        }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumUnits(int[][] boxTypes, int truckSize) {\\n     int result = 0, boxTypesCount = 0, orginalTruckSize = truckSize;\\n\\n            boxTypes = selectionSortDesc(boxTypes, 1);\\n\\n            for (int i = 0; i < boxTypes.Length; i++)\\n            {\\n                truckSize -= boxTypes[i][0];\\n\\n                if (truckSize < 0)\\n                {\\n                    result += (orginalTruckSize - boxTypesCount) * boxTypes[i][1];\\n                    break;\\n                }\\n\\n                result += (boxTypes[i][0]) * boxTypes[i][1];\\n                boxTypesCount += boxTypes[i][0];\\n\\n            }\\n\\n            return result;   \\n    }\\n\\n            static int[][] selectionSortDesc(int[][] arr, int sortIndexValue)\\n        {\\n            int[] temp = new int[2];\\n\\n            if (sortIndexValue == 0 || sortIndexValue == 1)\\n            {\\n                for (int i = 0; i < arr.Length - 1; i++)\\n                {\\n                    for (int j = i+1; j < arr.Length ; j++)\\n                    {\\n                        if (arr[i][sortIndexValue] < arr[j][sortIndexValue])\\n                        {\\n                            temp = arr[i];\\n                            arr[i] = arr[j];\\n                            arr[j] = temp;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                Console.WriteLine(\"Invalid sortIndexValue\");\\n            }\\n\\n            return arr;\\n        }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789508,
                "title": "normal-sorting-and-comparing-o-n-n-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        //Do normal array sorting based upon the numberOfUnitsPerBox(Column 2)\\n        \\n        for(int i=0;i<boxTypes.length-1;i++){\\n            for(int j=i+1;j<boxTypes.length;j++){\\n                if(boxTypes[i][1]<boxTypes[j][1]){\\n                    int first = boxTypes[i][0];\\n                    int second = boxTypes[i][1];\\n                    boxTypes[i][0] = boxTypes[j][0];\\n                    boxTypes[i][1] = boxTypes[j][1];\\n                    boxTypes[j][0] = first;\\n                    boxTypes[j][1] = second;\\n                }\\n            }\\n        }\\n        \\n        // Get the maxUnit as per the availability\\n        int total = 0;\\n        int curTotal = 0;\\n        for(int A[]:boxTypes){\\n            //Get the max Unit for ith box\\n            curTotal = A[0]*A[1];\\n            if(truckSize>=A[0]) total += curTotal;\\n            else{\\n                total += truckSize * A[1];\\n                break;\\n            } \\n            truckSize -= A[0];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\\n        //Do normal array sorting based upon the numberOfUnitsPerBox(Column 2)\\n        \\n        for(int i=0;i<boxTypes.length-1;i++){\\n            for(int j=i+1;j<boxTypes.length;j++){\\n                if(boxTypes[i][1]<boxTypes[j][1]){\\n                    int first = boxTypes[i][0];\\n                    int second = boxTypes[i][1];\\n                    boxTypes[i][0] = boxTypes[j][0];\\n                    boxTypes[i][1] = boxTypes[j][1];\\n                    boxTypes[j][0] = first;\\n                    boxTypes[j][1] = second;\\n                }\\n            }\\n        }\\n        \\n        // Get the maxUnit as per the availability\\n        int total = 0;\\n        int curTotal = 0;\\n        for(int A[]:boxTypes){\\n            //Get the max Unit for ith box\\n            curTotal = A[0]*A[1];\\n            if(truckSize>=A[0]) total += curTotal;\\n            else{\\n                total += truckSize * A[1];\\n                break;\\n            } \\n            truckSize -= A[0];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653375,
                "title": "trash-solution-hoping-for-coaching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n            boxTypes = sorted(boxTypes, key = lambda x:x[1],reverse = True)\\n            sum = 0\\n            i = 0\\n            \\n            while truckSize: \\n                if i >= len(boxTypes):\\n                    break \\n                sum = sum + boxTypes[i][1]\\n                \\n                boxTypes[i][0] = boxTypes[i][0]-1\\n                if boxTypes[i][0] == 0:\\n                    i = i+1\\n                truckSize = truckSize - 1\\n\\n                \\n            return sum \\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n            boxTypes = sorted(boxTypes, key = lambda x:x[1],reverse = True)\\n            sum = 0\\n            i = 0\\n            \\n            while truckSize: \\n                if i >= len(boxTypes):\\n                    break \\n                sum = sum + boxTypes[i][1]\\n                \\n                boxTypes[i][0] = boxTypes[i][0]-1\\n                if boxTypes[i][0] == 0:\\n                    i = i+1\\n                truckSize = truckSize - 1\\n\\n                \\n            return sum \\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468252,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key= lambda x: x[1], reverse=True) #sorting the list by unit count\\n        i=0\\n        unit_count=0\\n        while i<len(boxTypes) and truckSize > 0 :\\n            unit_count+= min(boxTypes[i][0],truckSize)*boxTypes[i][1]\\n            truckSize-=boxTypes[i][0]\\n            i+=1\\n        return unit_count\\n       \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key= lambda x: x[1], reverse=True) #sorting the list by unit count\\n        i=0\\n        unit_count=0\\n        while i<len(boxTypes) and truckSize > 0 :\\n            unit_count+= min(boxTypes[i][0],truckSize)*boxTypes[i][1]\\n            truckSize-=boxTypes[i][0]\\n            i+=1\\n        return unit_count\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434642,
                "title": "python-solution-beats-93-57",
                "content": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key = lambda x:x[1], reverse=True)\\n        \\n        sz = 0\\n        mxUnits = 0\\n        \\n        for size, units in boxTypes:\\n            if sz+size < truckSize:\\n                sz += size\\n                mxUnits += size*units\\n            else:\\n                mxUnits += (truckSize-sz)*units\\n                break\\n        \\n        return mxUnits",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n        boxTypes.sort(key = lambda x:x[1], reverse=True)\\n        \\n        sz = 0\\n        mxUnits = 0\\n        \\n        for size, units in boxTypes:\\n            if sz+size < truckSize:\\n                sz += size\\n                mxUnits += size*units\\n            else:\\n                mxUnits += (truckSize-sz)*units\\n                break\\n        \\n        return mxUnits",
                "codeTag": "Java"
            },
            {
                "id": 2396813,
                "title": "fractional-knapsack",
                "content": "```\\nbool comp(vector<int> &a,vector<int> &b)\\n{\\n    return a[1]>b[1];\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& bt, int ts) {\\n        sort(bt.begin(),bt.end(),comp);\\n        \\n        int res = 0;\\n        int i=0;\\n        int n = bt.size();\\n        while(i<n)\\n        {\\n            if(ts>= bt[i][0])\\n            {\\n                res+=(bt[i][0] * bt[i][1]);\\n                ts-= bt[i][0];\\n            }\\n            else\\n            {\\n                res+=(ts * bt[i][1]);\\n                break;\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool comp(vector<int> &a,vector<int> &b)\\n{\\n    return a[1]>b[1];\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maximumUnits(vector<vector<int>>& bt, int ts) {\\n        sort(bt.begin(),bt.end(),comp);\\n        \\n        int res = 0;\\n        int i=0;\\n        int n = bt.size();\\n        while(i<n)\\n        {\\n            if(ts>= bt[i][0])\\n            {\\n                res+=(bt[i][0] * bt[i][1]);\\n                ts-= bt[i][0];\\n            }\\n            else\\n            {\\n                res+=(ts * bt[i][1]);\\n                break;\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565733,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-units-on-a-truck/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Array Sort\n\n  \n**Approach 3:** Using Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nadiatx2015",
                        "content": "[[5,10],[2,5],[4,7],[3,9]], truckSize = 10 should not it be 81, instead of 91.\\n5*10=50 , 2*5=10, 3*7=21,,,, 50+10+21=81    5+2+3=10truck size"
                    },
                    {
                        "username": "user6059G",
                        "content": "they ask need to put maximum box so that we need to consider  [3,9] array instead of [2,5]\\n5*10 =50\\n3 * 9 =27\\n2 * 7 = 14\\nso total = 91"
                    },
                    {
                        "username": "Elamanov",
                        "content": "You pick:\\nAll 5 boxes containing 10 items\\nAll 3 boxes containing 9 items\\n2 (out of 4) boxes containing 7 items\\n\\n50+27+14=91"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Difficulty was easy, but instructions should have been more clear that it\\'s possible to have multiple quantities of the same box-capacity (which makes zero sense logically)."
                    },
                    {
                        "username": "learnerground",
                        "content": "Why in this test case result is = (1 * 3) + (2 * 2) + (1 * 1) = 8 ?\\nI didn\\'t understand (1 * 1)\\nCan anyone explain it?"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "[@narasimhakamath](/narasimhakamath)  after doing that second testcase get answer 81 how? explain"
                    },
                    {
                        "username": "learnerground",
                        "content": "[@narasimhakamath](/narasimhakamath) Thanks a lot I got it."
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "I think it is like, the truck can fit 4 boxes in total.\\n1 box from the first set, 2 boxes from the second set. Since we have already loaded 3 boxes, we can only load 1 more from the third set. So, 1+2+1 = 4, no more boxes can be accommodated.\\nFirst set, 1 box, has 3 units each, so 1 x 3 = 3.\\nSecond set, 2 boxes, has 2 units each, so 2 x 2 = 4.\\nThird set, 1 box, has 1 units each, so 1 * 1 = 1.\\nTotal units = 3 + 4 + 1 = 8."
                    },
                    {
                        "username": "sudheer_121",
                        "content": "The greedy solution made sense if it were a fractional Knapsack problem i.e fractions of boxes allowed. \\nThe dynamic programming solution looks like [this](https://leetcode.com/submissions/detail/507895544/). \\nHow do you prove that the greedy solution (i.e involves sorting) is optimal too ? \\n\\n\\n"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "I Got TLE at Last test Case \"75\" .  using only 2 forloops.\\nAfter that i did it using Sorting"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem \"Maximum Units on a Truck\" can be approximately mapped to the \"Fractional Knapsack Problem\". \\n\\nIn both problems, we have a set of items with individual quantities and values, and a limit on the total quantity that can be taken. The goal is to maximize the total value within the given constraints. \\n\\nThe \"Fractional Knapsack Problem\" is a simpler problem compared to \"Maximum Units on a Truck\". In the \"Fractional Knapsack Problem\", you can take fractions of items to reach the optimal solution, which is not allowed in \"Maximum Units on a Truck\". In \"Maximum Units on a Truck\", we have to take whole items (or boxes), which can make the problem slightly more complex, especially if the total quantity limit is not a multiple of the item quantities."
                    }
                ]
            },
            {
                "id": 1854213,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-units-on-a-truck/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Array Sort\n\n  \n**Approach 3:** Using Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nadiatx2015",
                        "content": "[[5,10],[2,5],[4,7],[3,9]], truckSize = 10 should not it be 81, instead of 91.\\n5*10=50 , 2*5=10, 3*7=21,,,, 50+10+21=81    5+2+3=10truck size"
                    },
                    {
                        "username": "user6059G",
                        "content": "they ask need to put maximum box so that we need to consider  [3,9] array instead of [2,5]\\n5*10 =50\\n3 * 9 =27\\n2 * 7 = 14\\nso total = 91"
                    },
                    {
                        "username": "Elamanov",
                        "content": "You pick:\\nAll 5 boxes containing 10 items\\nAll 3 boxes containing 9 items\\n2 (out of 4) boxes containing 7 items\\n\\n50+27+14=91"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Difficulty was easy, but instructions should have been more clear that it\\'s possible to have multiple quantities of the same box-capacity (which makes zero sense logically)."
                    },
                    {
                        "username": "learnerground",
                        "content": "Why in this test case result is = (1 * 3) + (2 * 2) + (1 * 1) = 8 ?\\nI didn\\'t understand (1 * 1)\\nCan anyone explain it?"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "[@narasimhakamath](/narasimhakamath)  after doing that second testcase get answer 81 how? explain"
                    },
                    {
                        "username": "learnerground",
                        "content": "[@narasimhakamath](/narasimhakamath) Thanks a lot I got it."
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "I think it is like, the truck can fit 4 boxes in total.\\n1 box from the first set, 2 boxes from the second set. Since we have already loaded 3 boxes, we can only load 1 more from the third set. So, 1+2+1 = 4, no more boxes can be accommodated.\\nFirst set, 1 box, has 3 units each, so 1 x 3 = 3.\\nSecond set, 2 boxes, has 2 units each, so 2 x 2 = 4.\\nThird set, 1 box, has 1 units each, so 1 * 1 = 1.\\nTotal units = 3 + 4 + 1 = 8."
                    },
                    {
                        "username": "sudheer_121",
                        "content": "The greedy solution made sense if it were a fractional Knapsack problem i.e fractions of boxes allowed. \\nThe dynamic programming solution looks like [this](https://leetcode.com/submissions/detail/507895544/). \\nHow do you prove that the greedy solution (i.e involves sorting) is optimal too ? \\n\\n\\n"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "I Got TLE at Last test Case \"75\" .  using only 2 forloops.\\nAfter that i did it using Sorting"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem \"Maximum Units on a Truck\" can be approximately mapped to the \"Fractional Knapsack Problem\". \\n\\nIn both problems, we have a set of items with individual quantities and values, and a limit on the total quantity that can be taken. The goal is to maximize the total value within the given constraints. \\n\\nThe \"Fractional Knapsack Problem\" is a simpler problem compared to \"Maximum Units on a Truck\". In the \"Fractional Knapsack Problem\", you can take fractions of items to reach the optimal solution, which is not allowed in \"Maximum Units on a Truck\". In \"Maximum Units on a Truck\", we have to take whole items (or boxes), which can make the problem slightly more complex, especially if the total quantity limit is not a multiple of the item quantities."
                    }
                ]
            },
            {
                "id": 1857125,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-units-on-a-truck/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Array Sort\n\n  \n**Approach 3:** Using Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nadiatx2015",
                        "content": "[[5,10],[2,5],[4,7],[3,9]], truckSize = 10 should not it be 81, instead of 91.\\n5*10=50 , 2*5=10, 3*7=21,,,, 50+10+21=81    5+2+3=10truck size"
                    },
                    {
                        "username": "user6059G",
                        "content": "they ask need to put maximum box so that we need to consider  [3,9] array instead of [2,5]\\n5*10 =50\\n3 * 9 =27\\n2 * 7 = 14\\nso total = 91"
                    },
                    {
                        "username": "Elamanov",
                        "content": "You pick:\\nAll 5 boxes containing 10 items\\nAll 3 boxes containing 9 items\\n2 (out of 4) boxes containing 7 items\\n\\n50+27+14=91"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Difficulty was easy, but instructions should have been more clear that it\\'s possible to have multiple quantities of the same box-capacity (which makes zero sense logically)."
                    },
                    {
                        "username": "learnerground",
                        "content": "Why in this test case result is = (1 * 3) + (2 * 2) + (1 * 1) = 8 ?\\nI didn\\'t understand (1 * 1)\\nCan anyone explain it?"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "[@narasimhakamath](/narasimhakamath)  after doing that second testcase get answer 81 how? explain"
                    },
                    {
                        "username": "learnerground",
                        "content": "[@narasimhakamath](/narasimhakamath) Thanks a lot I got it."
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "I think it is like, the truck can fit 4 boxes in total.\\n1 box from the first set, 2 boxes from the second set. Since we have already loaded 3 boxes, we can only load 1 more from the third set. So, 1+2+1 = 4, no more boxes can be accommodated.\\nFirst set, 1 box, has 3 units each, so 1 x 3 = 3.\\nSecond set, 2 boxes, has 2 units each, so 2 x 2 = 4.\\nThird set, 1 box, has 1 units each, so 1 * 1 = 1.\\nTotal units = 3 + 4 + 1 = 8."
                    },
                    {
                        "username": "sudheer_121",
                        "content": "The greedy solution made sense if it were a fractional Knapsack problem i.e fractions of boxes allowed. \\nThe dynamic programming solution looks like [this](https://leetcode.com/submissions/detail/507895544/). \\nHow do you prove that the greedy solution (i.e involves sorting) is optimal too ? \\n\\n\\n"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "I Got TLE at Last test Case \"75\" .  using only 2 forloops.\\nAfter that i did it using Sorting"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem \"Maximum Units on a Truck\" can be approximately mapped to the \"Fractional Knapsack Problem\". \\n\\nIn both problems, we have a set of items with individual quantities and values, and a limit on the total quantity that can be taken. The goal is to maximize the total value within the given constraints. \\n\\nThe \"Fractional Knapsack Problem\" is a simpler problem compared to \"Maximum Units on a Truck\". In the \"Fractional Knapsack Problem\", you can take fractions of items to reach the optimal solution, which is not allowed in \"Maximum Units on a Truck\". In \"Maximum Units on a Truck\", we have to take whole items (or boxes), which can make the problem slightly more complex, especially if the total quantity limit is not a multiple of the item quantities."
                    }
                ]
            },
            {
                "id": 1786872,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-units-on-a-truck/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Array Sort\n\n  \n**Approach 3:** Using Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nadiatx2015",
                        "content": "[[5,10],[2,5],[4,7],[3,9]], truckSize = 10 should not it be 81, instead of 91.\\n5*10=50 , 2*5=10, 3*7=21,,,, 50+10+21=81    5+2+3=10truck size"
                    },
                    {
                        "username": "user6059G",
                        "content": "they ask need to put maximum box so that we need to consider  [3,9] array instead of [2,5]\\n5*10 =50\\n3 * 9 =27\\n2 * 7 = 14\\nso total = 91"
                    },
                    {
                        "username": "Elamanov",
                        "content": "You pick:\\nAll 5 boxes containing 10 items\\nAll 3 boxes containing 9 items\\n2 (out of 4) boxes containing 7 items\\n\\n50+27+14=91"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Difficulty was easy, but instructions should have been more clear that it\\'s possible to have multiple quantities of the same box-capacity (which makes zero sense logically)."
                    },
                    {
                        "username": "learnerground",
                        "content": "Why in this test case result is = (1 * 3) + (2 * 2) + (1 * 1) = 8 ?\\nI didn\\'t understand (1 * 1)\\nCan anyone explain it?"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "[@narasimhakamath](/narasimhakamath)  after doing that second testcase get answer 81 how? explain"
                    },
                    {
                        "username": "learnerground",
                        "content": "[@narasimhakamath](/narasimhakamath) Thanks a lot I got it."
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "I think it is like, the truck can fit 4 boxes in total.\\n1 box from the first set, 2 boxes from the second set. Since we have already loaded 3 boxes, we can only load 1 more from the third set. So, 1+2+1 = 4, no more boxes can be accommodated.\\nFirst set, 1 box, has 3 units each, so 1 x 3 = 3.\\nSecond set, 2 boxes, has 2 units each, so 2 x 2 = 4.\\nThird set, 1 box, has 1 units each, so 1 * 1 = 1.\\nTotal units = 3 + 4 + 1 = 8."
                    },
                    {
                        "username": "sudheer_121",
                        "content": "The greedy solution made sense if it were a fractional Knapsack problem i.e fractions of boxes allowed. \\nThe dynamic programming solution looks like [this](https://leetcode.com/submissions/detail/507895544/). \\nHow do you prove that the greedy solution (i.e involves sorting) is optimal too ? \\n\\n\\n"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "I Got TLE at Last test Case \"75\" .  using only 2 forloops.\\nAfter that i did it using Sorting"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem \"Maximum Units on a Truck\" can be approximately mapped to the \"Fractional Knapsack Problem\". \\n\\nIn both problems, we have a set of items with individual quantities and values, and a limit on the total quantity that can be taken. The goal is to maximize the total value within the given constraints. \\n\\nThe \"Fractional Knapsack Problem\" is a simpler problem compared to \"Maximum Units on a Truck\". In the \"Fractional Knapsack Problem\", you can take fractions of items to reach the optimal solution, which is not allowed in \"Maximum Units on a Truck\". In \"Maximum Units on a Truck\", we have to take whole items (or boxes), which can make the problem slightly more complex, especially if the total quantity limit is not a multiple of the item quantities."
                    }
                ]
            },
            {
                "id": 1575406,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-units-on-a-truck/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Array Sort\n\n  \n**Approach 3:** Using Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nadiatx2015",
                        "content": "[[5,10],[2,5],[4,7],[3,9]], truckSize = 10 should not it be 81, instead of 91.\\n5*10=50 , 2*5=10, 3*7=21,,,, 50+10+21=81    5+2+3=10truck size"
                    },
                    {
                        "username": "user6059G",
                        "content": "they ask need to put maximum box so that we need to consider  [3,9] array instead of [2,5]\\n5*10 =50\\n3 * 9 =27\\n2 * 7 = 14\\nso total = 91"
                    },
                    {
                        "username": "Elamanov",
                        "content": "You pick:\\nAll 5 boxes containing 10 items\\nAll 3 boxes containing 9 items\\n2 (out of 4) boxes containing 7 items\\n\\n50+27+14=91"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Difficulty was easy, but instructions should have been more clear that it\\'s possible to have multiple quantities of the same box-capacity (which makes zero sense logically)."
                    },
                    {
                        "username": "learnerground",
                        "content": "Why in this test case result is = (1 * 3) + (2 * 2) + (1 * 1) = 8 ?\\nI didn\\'t understand (1 * 1)\\nCan anyone explain it?"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "[@narasimhakamath](/narasimhakamath)  after doing that second testcase get answer 81 how? explain"
                    },
                    {
                        "username": "learnerground",
                        "content": "[@narasimhakamath](/narasimhakamath) Thanks a lot I got it."
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "I think it is like, the truck can fit 4 boxes in total.\\n1 box from the first set, 2 boxes from the second set. Since we have already loaded 3 boxes, we can only load 1 more from the third set. So, 1+2+1 = 4, no more boxes can be accommodated.\\nFirst set, 1 box, has 3 units each, so 1 x 3 = 3.\\nSecond set, 2 boxes, has 2 units each, so 2 x 2 = 4.\\nThird set, 1 box, has 1 units each, so 1 * 1 = 1.\\nTotal units = 3 + 4 + 1 = 8."
                    },
                    {
                        "username": "sudheer_121",
                        "content": "The greedy solution made sense if it were a fractional Knapsack problem i.e fractions of boxes allowed. \\nThe dynamic programming solution looks like [this](https://leetcode.com/submissions/detail/507895544/). \\nHow do you prove that the greedy solution (i.e involves sorting) is optimal too ? \\n\\n\\n"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "I Got TLE at Last test Case \"75\" .  using only 2 forloops.\\nAfter that i did it using Sorting"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem \"Maximum Units on a Truck\" can be approximately mapped to the \"Fractional Knapsack Problem\". \\n\\nIn both problems, we have a set of items with individual quantities and values, and a limit on the total quantity that can be taken. The goal is to maximize the total value within the given constraints. \\n\\nThe \"Fractional Knapsack Problem\" is a simpler problem compared to \"Maximum Units on a Truck\". In the \"Fractional Knapsack Problem\", you can take fractions of items to reach the optimal solution, which is not allowed in \"Maximum Units on a Truck\". In \"Maximum Units on a Truck\", we have to take whole items (or boxes), which can make the problem slightly more complex, especially if the total quantity limit is not a multiple of the item quantities."
                    }
                ]
            },
            {
                "id": 2036907,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-units-on-a-truck/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Array Sort\n\n  \n**Approach 3:** Using Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nadiatx2015",
                        "content": "[[5,10],[2,5],[4,7],[3,9]], truckSize = 10 should not it be 81, instead of 91.\\n5*10=50 , 2*5=10, 3*7=21,,,, 50+10+21=81    5+2+3=10truck size"
                    },
                    {
                        "username": "user6059G",
                        "content": "they ask need to put maximum box so that we need to consider  [3,9] array instead of [2,5]\\n5*10 =50\\n3 * 9 =27\\n2 * 7 = 14\\nso total = 91"
                    },
                    {
                        "username": "Elamanov",
                        "content": "You pick:\\nAll 5 boxes containing 10 items\\nAll 3 boxes containing 9 items\\n2 (out of 4) boxes containing 7 items\\n\\n50+27+14=91"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Difficulty was easy, but instructions should have been more clear that it\\'s possible to have multiple quantities of the same box-capacity (which makes zero sense logically)."
                    },
                    {
                        "username": "learnerground",
                        "content": "Why in this test case result is = (1 * 3) + (2 * 2) + (1 * 1) = 8 ?\\nI didn\\'t understand (1 * 1)\\nCan anyone explain it?"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "[@narasimhakamath](/narasimhakamath)  after doing that second testcase get answer 81 how? explain"
                    },
                    {
                        "username": "learnerground",
                        "content": "[@narasimhakamath](/narasimhakamath) Thanks a lot I got it."
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "I think it is like, the truck can fit 4 boxes in total.\\n1 box from the first set, 2 boxes from the second set. Since we have already loaded 3 boxes, we can only load 1 more from the third set. So, 1+2+1 = 4, no more boxes can be accommodated.\\nFirst set, 1 box, has 3 units each, so 1 x 3 = 3.\\nSecond set, 2 boxes, has 2 units each, so 2 x 2 = 4.\\nThird set, 1 box, has 1 units each, so 1 * 1 = 1.\\nTotal units = 3 + 4 + 1 = 8."
                    },
                    {
                        "username": "sudheer_121",
                        "content": "The greedy solution made sense if it were a fractional Knapsack problem i.e fractions of boxes allowed. \\nThe dynamic programming solution looks like [this](https://leetcode.com/submissions/detail/507895544/). \\nHow do you prove that the greedy solution (i.e involves sorting) is optimal too ? \\n\\n\\n"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "I Got TLE at Last test Case \"75\" .  using only 2 forloops.\\nAfter that i did it using Sorting"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem \"Maximum Units on a Truck\" can be approximately mapped to the \"Fractional Knapsack Problem\". \\n\\nIn both problems, we have a set of items with individual quantities and values, and a limit on the total quantity that can be taken. The goal is to maximize the total value within the given constraints. \\n\\nThe \"Fractional Knapsack Problem\" is a simpler problem compared to \"Maximum Units on a Truck\". In the \"Fractional Knapsack Problem\", you can take fractions of items to reach the optimal solution, which is not allowed in \"Maximum Units on a Truck\". In \"Maximum Units on a Truck\", we have to take whole items (or boxes), which can make the problem slightly more complex, especially if the total quantity limit is not a multiple of the item quantities."
                    }
                ]
            },
            {
                "id": 1991923,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-units-on-a-truck/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Array Sort\n\n  \n**Approach 3:** Using Priority Queue\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nadiatx2015",
                        "content": "[[5,10],[2,5],[4,7],[3,9]], truckSize = 10 should not it be 81, instead of 91.\\n5*10=50 , 2*5=10, 3*7=21,,,, 50+10+21=81    5+2+3=10truck size"
                    },
                    {
                        "username": "user6059G",
                        "content": "they ask need to put maximum box so that we need to consider  [3,9] array instead of [2,5]\\n5*10 =50\\n3 * 9 =27\\n2 * 7 = 14\\nso total = 91"
                    },
                    {
                        "username": "Elamanov",
                        "content": "You pick:\\nAll 5 boxes containing 10 items\\nAll 3 boxes containing 9 items\\n2 (out of 4) boxes containing 7 items\\n\\n50+27+14=91"
                    },
                    {
                        "username": "startupveteran",
                        "content": "Difficulty was easy, but instructions should have been more clear that it\\'s possible to have multiple quantities of the same box-capacity (which makes zero sense logically)."
                    },
                    {
                        "username": "learnerground",
                        "content": "Why in this test case result is = (1 * 3) + (2 * 2) + (1 * 1) = 8 ?\\nI didn\\'t understand (1 * 1)\\nCan anyone explain it?"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "[@narasimhakamath](/narasimhakamath)  after doing that second testcase get answer 81 how? explain"
                    },
                    {
                        "username": "learnerground",
                        "content": "[@narasimhakamath](/narasimhakamath) Thanks a lot I got it."
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "I think it is like, the truck can fit 4 boxes in total.\\n1 box from the first set, 2 boxes from the second set. Since we have already loaded 3 boxes, we can only load 1 more from the third set. So, 1+2+1 = 4, no more boxes can be accommodated.\\nFirst set, 1 box, has 3 units each, so 1 x 3 = 3.\\nSecond set, 2 boxes, has 2 units each, so 2 x 2 = 4.\\nThird set, 1 box, has 1 units each, so 1 * 1 = 1.\\nTotal units = 3 + 4 + 1 = 8."
                    },
                    {
                        "username": "sudheer_121",
                        "content": "The greedy solution made sense if it were a fractional Knapsack problem i.e fractions of boxes allowed. \\nThe dynamic programming solution looks like [this](https://leetcode.com/submissions/detail/507895544/). \\nHow do you prove that the greedy solution (i.e involves sorting) is optimal too ? \\n\\n\\n"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "I Got TLE at Last test Case \"75\" .  using only 2 forloops.\\nAfter that i did it using Sorting"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem \"Maximum Units on a Truck\" can be approximately mapped to the \"Fractional Knapsack Problem\". \\n\\nIn both problems, we have a set of items with individual quantities and values, and a limit on the total quantity that can be taken. The goal is to maximize the total value within the given constraints. \\n\\nThe \"Fractional Knapsack Problem\" is a simpler problem compared to \"Maximum Units on a Truck\". In the \"Fractional Knapsack Problem\", you can take fractions of items to reach the optimal solution, which is not allowed in \"Maximum Units on a Truck\". In \"Maximum Units on a Truck\", we have to take whole items (or boxes), which can make the problem slightly more complex, especially if the total quantity limit is not a multiple of the item quantities."
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Good Meals",
        "question_content": "<p>A <strong>good meal</strong> is a meal that contains <strong>exactly two different food items</strong> with a sum of deliciousness equal to a power of two.</p>\n\n<p>You can pick <strong>any</strong> two different foods to make a good meal.</p>\n\n<p>Given an array of integers <code>deliciousness</code> where <code>deliciousness[i]</code> is the deliciousness of the <code>i<sup>​​​​​​th</sup>​​​​</code>​​​​ item of food, return <em>the number of different <strong>good meals</strong> you can make from this list modulo</em> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>Note that items with different indices are considered different even if they have the same deliciousness value.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> deliciousness = [1,3,5,7,9]\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>The good meals are (1,3), (1,7), (3,5) and, (7,9).\nTheir respective sums are 4, 8, 8, and 16, all of which are powers of 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> deliciousness = [1,1,1,3,3,3,7]\n<strong>Output:</strong> 15\n<strong>Explanation: </strong>The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= deliciousness.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= deliciousness[i] &lt;= 2<sup>20</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 999119,
                "title": "java-hashmap-two-sum-o-n",
                "content": "Strictly speaking this is O(22*N) but 22 can be treated as constant.\\n\\nBasic idea is somewhat similar to that of two sum, where we store the count of all encountered nums in a hashmap. Then for each num, we go through all powers of twos in the integer range (22 iterations total), and try to find the corresponding entry in the map. \\n\\nEDIT: Thanks to @chin-heng\\'s point, we can further reduce the constant modifier to 22 from 32, due to the constraint in problem that `0 <= deliciousness[i] <= 2^20`.\\n\\n```java\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countPairs(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = arr.length;\\n        long res = 0;\\n        for (int num : arr) {\\n            int power = 1;\\n            for (int i = 0; i < 22; i++) {\\n                if (map.containsKey(power - num)) {\\n                    res += map.get(power - num);\\n                    res %= mod;\\n                }\\n                power *= 2;\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countPairs(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = arr.length;\\n        long res = 0;\\n        for (int num : arr) {\\n            int power = 1;\\n            for (int i = 0; i < 22; i++) {\\n                if (map.containsKey(power - num)) {\\n                    res += map.get(power - num);\\n                    res %= mod;\\n                }\\n                power *= 2;\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999249,
                "title": "easy-c-count-good-meals",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& a) {\\n        unordered_map<int,int> lks;\\n        long long ans=0;\\n        for(int x : a){\\n            for(int i=1;i<=(1<<22);i*=2){\\n                if(lks.count(i-x)) ans+=lks[i-x];\\n            }\\n            lks[x]+=1;\\n        }\\n        return ans % (int)(1e9 + 7);\\n    }\\n};\\n```\\n\\n# Quick Explanation\\n```\\nStep 1. Create an Unordered Map\\nStep 2. Initialise the ans=0\\nStep 3. Loop through Each Element in the vector\\nStep 4. For Each Element loot through pow(2,1) to pow(2,22) \\nStep 5. Find For the element pow(2,i) - x  in the map . If found then make add the frequency.\\nStep 6. Every time add the element of the vector into the map\\nStep7 . Return the ans with modulo\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& a) {\\n        unordered_map<int,int> lks;\\n        long long ans=0;\\n        for(int x : a){\\n            for(int i=1;i<=(1<<22);i*=2){\\n                if(lks.count(i-x)) ans+=lks[i-x];\\n            }\\n            lks[x]+=1;\\n        }\\n        return ans % (int)(1e9 + 7);\\n    }\\n};\\n```\n```\\nStep 1. Create an Unordered Map\\nStep 2. Initialise the ans=0\\nStep 3. Loop through Each Element in the vector\\nStep 4. For Each Element loot through pow(2,1) to pow(2,22) \\nStep 5. Find For the element pow(2,i) - x  in the map . If found then make add the frequency.\\nStep 6. Every time add the element of the vector into the map\\nStep7 . Return the ans with modulo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999170,
                "title": "python3-frequency-table",
                "content": "**Algo**\\nCompute frequency table of `deliciousness` from which you can check for complement of each `2**k` given a number (since there are only < 30 such power of 2 to consider).\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x in deliciousness: \\n            for k in range(22): ans += freq[2**k - x]\\n            freq[x] += 1\\n        return ans % 1_000_000_007\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`\\n\\nEdited on 1/3/2021\\nAdding a 2-pass version\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in deliciousness: freq[x] += 1\\n        \\n        ans = 0\\n        for x in freq: \\n            for k in range(22): \\n                if 2**k - x <= x and 2**k - x in freq: \\n                    ans += freq[x]*(freq[x]-1)//2 if 2**k - x == x else freq[x]*freq[2**k-x]\\n        return ans % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x in deliciousness: \\n            for k in range(22): ans += freq[2**k - x]\\n            freq[x] += 1\\n        return ans % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        freq = defaultdict(int)\\n        for x in deliciousness: freq[x] += 1\\n        \\n        ans = 0\\n        for x in freq: \\n            for k in range(22): \\n                if 2**k - x <= x and 2**k - x in freq: \\n                    ans += freq[x]*(freq[x]-1)//2 if 2**k - x == x else freq[x]*freq[2**k-x]\\n        return ans % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999436,
                "title": "java-o-n-hashmap-solution-two-sum-variation",
                "content": "In this question, we can use the brute force to check pair by pair, and count. But this O(n^2) solution will give you a TLE. \\n\\nWe can find that **we only care about the number of pairs**, not what are the pairs. So we can use a HashMap to reduce the search time by O(1). We also need to notice that **the number in arr is less than or equal to 2^20**, so we can use this info to reduce our search space!\\n\\n**Also since 2^20 + 2^20 = 2^21, so we need to search until 2^21, rather 2^20. That is the testcase [1048576, 1048576].** Here is the code:\\n```\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>(); // key: num, val: ocurrence\\n        int length = deliciousness.length, answer = 0, MOD = 1000000007;\\n        for (int num : deliciousness) {\\n            int sum = 1;\\n            for (int i = 0; i <= 21; i++) {// 21 because 2^20 + 2^20 = 2^21, this is largest sum we can obtain in this problem.\\n                if (sum >= num && map.containsKey(sum - num)) {\\n                    answer += map.get(sum - num);\\n                    answer %= MOD;\\n                }\\n                sum *= 2;\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return (int)answer;\\n    }\\n```\\n\\nTime Complexity: O(22n) = O(n)\\nSpace Complexity: O(n)\\n**Please upvote for me if you find this is helpful for your understanding the solution.**",
                "solutionTags": [],
                "code": "```\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>(); // key: num, val: ocurrence\\n        int length = deliciousness.length, answer = 0, MOD = 1000000007;\\n        for (int num : deliciousness) {\\n            int sum = 1;\\n            for (int i = 0; i <= 21; i++) {// 21 because 2^20 + 2^20 = 2^21, this is largest sum we can obtain in this problem.\\n                if (sum >= num && map.containsKey(sum - num)) {\\n                    answer += map.get(sum - num);\\n                    answer %= MOD;\\n                }\\n                sum *= 2;\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return (int)answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999120,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int n = deliciousness.size();\\n        if (n == 1) {return 0;}\\n        unordered_map<int, int> cnt;\\n        int ans = 0;\\n        int M = 1000000007;\\n        \\n        sort(deliciousness.begin(), deliciousness.end());\\n        cnt[deliciousness[0]]++;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int p = 0; p <= 21; p++) {\\n                if ((int)pow(2,p) > 2 * deliciousness[i]) {break;}\\n                \\n                int target = (int)pow(2, p) - deliciousness[i];\\n                if (cnt.find(target) != cnt.end()) {\\n                    ans += cnt[target] % M;\\n                    ans %= M;\\n                }\\n            }\\n            cnt[deliciousness[i]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n I sorted the array at first and then prune some unnecessary searching using if statement in for loop. This costs O(nlogn) for sorting. \\nIf remove the sorting and this if statement, time complexity would be O(21n) . Both are acceptable for this problem.\\nSpace complexity is O(n).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int n = deliciousness.size();\\n        if (n == 1) {return 0;}\\n        unordered_map<int, int> cnt;\\n        int ans = 0;\\n        int M = 1000000007;\\n        \\n        sort(deliciousness.begin(), deliciousness.end());\\n        cnt[deliciousness[0]]++;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int p = 0; p <= 21; p++) {\\n                if ((int)pow(2,p) > 2 * deliciousness[i]) {break;}\\n                \\n                int target = (int)pow(2, p) - deliciousness[i];\\n                if (cnt.find(target) != cnt.end()) {\\n                    ans += cnt[target] % M;\\n                    ans %= M;\\n                }\\n            }\\n            cnt[deliciousness[i]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999116,
                "title": "java-python-3-2-codes-treemap-dict-o-nlogn-and-hashmap-counter-o-n",
                "content": "\\n**Method 1: TreeMap/dict**\\n1. Use TreeMap to count the occurrences of each deliciousness;\\n2. Reversely poll out the entries of the TreeMap one by one; \\nThere are 3 possibilities:\\na) The deliciousness itself is a power of `2` and there is a deliciousness of `0`;\\nb) The deliciousness itself is a power of `2` and there are at least `2` occurrences,\\nhence there are C(n, 2) of pairs, where `n` is the occurrences;\\nc) The deliciousness itself is Not a power of `2` and there is one that is less than it \\nand the pair is a power of `2`.\\n3. Count all of them in 2 to get the solution.\\n\\n```java\\n    public int countPairs(int[] deliciousness) {\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        for (int d : deliciousness) {\\n            cnt.put(d, 1 + cnt.getOrDefault(d, 0));\\n        }\\n        long ans = 0;\\n        while (!cnt.isEmpty()) {\\n            var e = cnt.pollLastEntry();\\n            int key = e.getKey(), v = e.getValue(), p = 1;\\n            while (p <= key) {\\n                p <<= 1;\\n            }\\n            if (Integer.bitCount(key) == 1) {\\n                ans += 1L * v * cnt.getOrDefault(0, 0);    \\n                ans += (v - 1L) * v / 2;   \\n            }else if (cnt.containsKey(p - key)) {\\n                ans += 1L * v * cnt.get(p - key);\\n            }\\n        }\\n        return (int)(ans % 1_000_000_007);         \\n    }\\n```\\n```python\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        cnt = Counter(deliciousness)\\n        ans = 0\\n        for key in reversed(sorted(cnt.keys())):\\n            c = cnt[key]\\n            if bin(key).count(\\'1\\') == 1:\\n                ans += c * cnt[0] + (c - 1) * c // 2\\n            else:\\n                p = 1\\n                while p <= key:\\n                    p <<= 1    \\n                ans += c * cnt[p - key]    \\n            cnt.pop(key)    \\n        return ans % (10 ** 9 + 7)\\n```\\n\\n----\\n\\n**Method 2: TwoSum**\\n**Q & A:**\\n\\nQ1: In method 2, why the range is `[0, 22)`?\\nA1: In problem description, we have the following constraint:\\n`0 <= deliciousness[i] <= 2^20`\\nwhich implies in `deliciousness` the sum of any two items `<= 2 ^ 20 + 2 ^ 20 = 2 ^ 21.` Therefore, the range is `0 ~ 21`.\\n\\nQ2: I am confused as to why, you need to adjust counter HashMap during the loop? If I initialize cnt as Counter(deliciousness) don\\'t use cnt[d] += 1 to update the HashMap during the loop it does not work. I don\\'t understand why the accumulation of the HashMap must be done during the loop instead of before. Also why must cnt[d] += 1 happen after increasing ans? Why can\\'t it come before?\\n\\nA2:\\na) Why do you need to adjust counter/HashMap during the loop? \\ne.g., [0, 0, 1, 1] \\n1. d = 0\\n{}\\nno pairs\\n2. d = 0\\n{0: 1}\\nno pairs\\n3. d = 1\\n{0: 2}\\n2 pairs found\\n4. d = 1\\n{0 : 2, 1 : 1}\\n3 more pairs found, total 5.\\n\\nOnly if adjusting HashMap during the loop, can we find and accumulate the number of pairs;\\n\\nb) why the accumulation of the HashMap must be done during the loop instead of before. Also why must cnt[d] += 1 happen after increasing ans? Why can\\'t it come before?\\n\\nWe can NOT pair a number with itself. If counting in a number before  increasing `ans`, we actually pair a number with itself.\\n\\n**End of Q & A**\\n\\n----\\n\\n1. Similar to `Two Sum`, we need to find pairs\\' sums; the difference from `Two Sum` is that the sum could be any power of `2`. \\n2. Therefore, for each number in `deliciousness`, we need to traverse all possible of power of `2: 2 ^ i`, where `0 <= i <= 21`, to find the pairing; accumulate the occurrences of all pairs according to the HashMap `cnt`;\\n3. Count the current number `d` in the HashMap `cnt`.\\n```java\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        long ans = 0;\\n        for (int d : deliciousness) {\\n            for (int power = 1, i = 0; i < 22; ++i, power <<= 1) {\\n                ans += cnt.getOrDefault(power - d, 0);        \\n            }\\n            cnt.put(d, 1 + cnt.getOrDefault(d, 0));\\n        }\\n        return (int)(ans % 1_000_000_007);         \\n    }\\n```\\n```python\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        cnt = Counter()\\n        ans = 0\\n        for d in deliciousness:\\n            for i in range(22):\\n                ans += cnt[(1 << i) - d]\\n            cnt[d] += 1    \\n        return ans % (10 ** 9 + 7)    \\n```",
                "solutionTags": [],
                "code": "```java\\n    public int countPairs(int[] deliciousness) {\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        for (int d : deliciousness) {\\n            cnt.put(d, 1 + cnt.getOrDefault(d, 0));\\n        }\\n        long ans = 0;\\n        while (!cnt.isEmpty()) {\\n            var e = cnt.pollLastEntry();\\n            int key = e.getKey(), v = e.getValue(), p = 1;\\n            while (p <= key) {\\n                p <<= 1;\\n            }\\n            if (Integer.bitCount(key) == 1) {\\n                ans += 1L * v * cnt.getOrDefault(0, 0);    \\n                ans += (v - 1L) * v / 2;   \\n            }else if (cnt.containsKey(p - key)) {\\n                ans += 1L * v * cnt.get(p - key);\\n            }\\n        }\\n        return (int)(ans % 1_000_000_007);         \\n    }\\n```\n```python\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        cnt = Counter(deliciousness)\\n        ans = 0\\n        for key in reversed(sorted(cnt.keys())):\\n            c = cnt[key]\\n            if bin(key).count(\\'1\\') == 1:\\n                ans += c * cnt[0] + (c - 1) * c // 2\\n            else:\\n                p = 1\\n                while p <= key:\\n                    p <<= 1    \\n                ans += c * cnt[p - key]    \\n            cnt.pop(key)    \\n        return ans % (10 ** 9 + 7)\\n```\n```java\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        long ans = 0;\\n        for (int d : deliciousness) {\\n            for (int power = 1, i = 0; i < 22; ++i, power <<= 1) {\\n                ans += cnt.getOrDefault(power - d, 0);        \\n            }\\n            cnt.put(d, 1 + cnt.getOrDefault(d, 0));\\n        }\\n        return (int)(ans % 1_000_000_007);         \\n    }\\n```\n```python\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        cnt = Counter()\\n        ans = 0\\n        for d in deliciousness:\\n            for i in range(22):\\n                ans += cnt[(1 << i) - d]\\n            cnt[d] += 1    \\n        return ans % (10 ** 9 + 7)    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1261673,
                "title": "easy-c-code-using-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        long long ans = 0;\\n        for(auto a : arr)\\n        {\\n            for(int i=1;i<=pow(2,21);i*=2)\\n            {\\n                if(mp.count(i-a))\\n                {\\n                    ans += mp[i-a];\\n                }\\n            }\\n            mp[a]++;\\n        }\\n        return ans % (int)(1e9 + 7);\\n    }\\n    \\n};\\n  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        long long ans = 0;\\n        for(auto a : arr)\\n        {\\n            for(int i=1;i<=pow(2,21);i*=2)\\n            {\\n                if(mp.count(i-a))\\n                {\\n                    ans += mp[i-a];\\n                }\\n            }\\n            mp[a]++;\\n        }\\n        return ans % (int)(1e9 + 7);\\n    }\\n    \\n};\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396246,
                "title": "python-super-simple-solution-o-22-n",
                "content": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        result = 0\\n        hm = Counter()\\n        for num in deliciousness:\\n            for i in range(22): result += hm[2**i-num]\\n            hm[num] += 1\\n        return result % ((10 ** 9) + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        result = 0\\n        hm = Counter()\\n        for num in deliciousness:\\n            for i in range(22): result += hm[2**i-num]\\n            hm[num] += 1\\n        return result % ((10 ** 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999181,
                "title": "accepted-c-o-n-840ms",
                "content": "```\\n    int countPairs(vector<int>& d) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        int mod = 1000000007;\\n        for (int &i : d) {\\n            for (int j = 0; j < 22; j++) {\\n                int temp = (1 << j) - i;\\n                if (temp >= 0 && count.count(temp)) {\\n                    res += count[temp];\\n                }\\n                res %= mod;\\n            }\\n            count[i]++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int countPairs(vector<int>& d) {\\n        int res = 0;\\n        unordered_map<int, int> count;\\n        int mod = 1000000007;\\n        for (int &i : d) {\\n            for (int j = 0; j < 22; j++) {\\n                int temp = (1 << j) - i;\\n                if (temp >= 0 && count.count(temp)) {\\n                    res += count[temp];\\n                }\\n                res %= mod;\\n            }\\n            count[i]++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126176,
                "title": "c-hashmap-easy",
                "content": "class Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        \\n        \\n        /*instead of finding two numbers whose sum is in power of 2\\n        try to find second number when sum and first number is  known*/\\n        \\n        int n=d.size();\\n        long long ans=0;\\n        unordered_map<int,int> m;\\n        for(auto &it:d)\\n        {\\n            \\n            int val=it;\\n           // long long freq=(long long)it.second;\\n            int i=0;\\n            \\n            // max sum can be 2^21(2^20 + 2^20)\\n            // min sum can be 1 (1+0)\\n            for( i=0;i<=21;i++)\\n            {\\n                int p=1<<i;\\n                if(m.find(p-val)!=m.end())\\n                {\\n                 //   cout<<val<<\" \"<<p-val<<endl;\\n                    \\n                    ans=ans +m[p-val];\\n                }\\n            }\\n            \\n            m[it]++;\\n    \\n            \\n            \\n        }\\n        \\n        \\n         return (int)(ans%1000000007);\\n      \\n        \\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        \\n        \\n        /*instead of finding two numbers whose sum is in power of 2\\n        try to find second number when sum and first number is  known*/\\n        \\n        int n=d.size();\\n        long long ans=0;\\n        unordered_map<int,int> m;\\n        for(auto &it:d)\\n        {\\n            \\n            int val=it;\\n           // long long freq=(long long)it.second;\\n            int i=0;\\n            \\n            // max sum can be 2^21(2^20 + 2^20)\\n            // min sum can be 1 (1+0)\\n            for( i=0;i<=21;i++)\\n            {\\n                int p=1<<i;\\n                if(m.find(p-val)!=m.end())\\n                {\\n                 //   cout<<val<<\" \"<<p-val<<endl;\\n                    \\n                    ans=ans +m[p-val];\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 1553939,
                "title": "actually-legible-and-commented-python-solution",
                "content": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        pows = [2 ** i for i in range(0,22)] # form our list of powers of 2\\n        dp_seen = {} # dict to store what we\\'ve seen - dynamic programming solution for time requirement\\n        count = 0 # to store the answer\\n\\n        for j in range(0, len(deliciousness)):\\n            for i in range(0, len(pows)):\\n                if pows[i] - deliciousness[j] in dp_seen: # \"if we find a previous deliciousness[j] as pows[i] - deliciousness[j], then we will add dp_seen[deliciousness[j]] to count\"\\n                    count += dp_seen[pows[i] - deliciousness[j]]\\n            if deliciousness[j] in dp_seen:\\n                dp_seen[deliciousness[j]] += 1 \\n            else:\\n                dp_seen[deliciousness[j]] = 1\\n                \\n        return count % (10**9 + 7) # the arbitrary modulo, presumably to reduce the answer size\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        pows = [2 ** i for i in range(0,22)] # form our list of powers of 2\\n        dp_seen = {} # dict to store what we\\'ve seen - dynamic programming solution for time requirement\\n        count = 0 # to store the answer\\n\\n        for j in range(0, len(deliciousness)):\\n            for i in range(0, len(pows)):\\n                if pows[i] - deliciousness[j] in dp_seen: # \"if we find a previous deliciousness[j] as pows[i] - deliciousness[j], then we will add dp_seen[deliciousness[j]] to count\"\\n                    count += dp_seen[pows[i] - deliciousness[j]]\\n            if deliciousness[j] in dp_seen:\\n                dp_seen[deliciousness[j]] += 1 \\n            else:\\n                dp_seen[deliciousness[j]] = 1\\n                \\n        return count % (10**9 + 7) # the arbitrary modulo, presumably to reduce the answer size\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1026190,
                "title": "java-map-o-n-22",
                "content": "This question is regarding the 2 sum problem. The logic is just that we will need to check the sum of a,b such that a+b == 2^n eg : 2 = 1+1, 4 = 2+2, 8 = 5+3\\nAlso we can use the complexity be n for traversing each element in array but the inner loop is for checking with the sum such that in [1,3] map stored with 1:1 now again in for loop we can check the 2^0 - 2^21 inclusively - the element at the point. \\nWhich we can actually use as constant of inner loop as in thr question it is given that delicious[i] value will be from 0 to atmost 2^21, so we can count complexity as O(n*22).\\n\\nAlso in the question we need to keep modding with 1000000007\\n\\n```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        \\n        int mod = 1000000007;\\n        int count=0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int num : deliciousness)\\n        {\\n            int power = 1;\\n            for(int i=0; i<=21; i++)\\n            {\\n                if(hm.containsKey(power-num))\\n                {\\n                    count+=hm.get(power-num);\\n                    count%=mod;\\n                }\\n                power*=2;\\n            }\\n            hm.put(num,hm.getOrDefault(num,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        \\n        int mod = 1000000007;\\n        int count=0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        \\n        for(int num : deliciousness)\\n        {\\n            int power = 1;\\n            for(int i=0; i<=21; i++)\\n            {\\n                if(hm.containsKey(power-num))\\n                {\\n                    count+=hm.get(power-num);\\n                    count%=mod;\\n                }\\n                power*=2;\\n            }\\n            hm.put(num,hm.getOrDefault(num,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003645,
                "title": "javascript-simple-map-solution-w-explanation-beats-100-70",
                "content": "***Idea:***\\n\\nThe straightforward, brute-force approach would be to check each number against each other number at a time complexity of **O(n^2)**. With a range of **0 <= D[i] <= 2e20**, that means the range of pair sums is **0 <= D[i] + D[j] <= 2e21**, which also means that there are only 22 possible target sums **(2e0 - 2e21)**. So rather than checking if each pair sums to a power of 2, we can more efficiently check each number to see if there are any matching pair numbers for the 22 target sums at a time complexity of **O(n)**.\\n\\nIn order to do this, we\\'ll first need to convert the data to be value-based, rather than index-based, and with such a large range of values, that suggests a **Map()**.\\n\\nThe best result for the code below is **120ms / 53.3MB**.\\n\\n` `\\n***Implementation:***\\n\\nThe first step is to pass **D** into a standard **frequency map**. After that, we can process each **[key, value]** pair, and iterate through each of the power sums looking for a match. To do this more efficiently, we can make use of **bitwise shifts**. Shifting downward from **i =1 << 21** (**2^21**) will also simplify the final eding condition to just **i** (**0**).\\n\\nWhen we iterate through all **k** values, we\\'ll duplicate pairs, since each pair **k1 + k2 = i** will find a match when checking both **k1** and **k2**. To avoid this, we can add a secondary ending condition **i >= 2 * k** which will limit the checks to only allow matches that are larger than **k**.\\n\\nFirst we\\'ll want to see if the checked number is a match to itself (**i === 2 * k**), and if so we\\'ll use the \"n choose 2\" formula (**v * (v - 1) / 2**) to find the amount of pairs we should add to **ans**. Otherwise, when we find a match, we\\'ll want to add the product of those two numbers\\' frequencies (**v * m.get(i - k)**) to our **ans**.\\n\\nAnd after all the iterations are done, we can return **ans**.\\n\\n` `\\n***Code:***\\n```\\nvar countPairs = function(D) {\\n    let m = new Map(), ans = 0\\n    for (let n of D) m.set(n, (m.get(n) || 0) + 1)           // Push D into a standard frequency map\\n    for (let [k,v] of m)                                     // For each [key, value] pair\\n        for (let i = 1 << 21; i >= 2 * k && i; i >>= 1)      // Iterate through power sums using bitwise shifts\\n            if (i === 2 * k) ans += v * (v - 1) / 2          // If  k is its own matching number, add pairs to ans\\n            else if (m.has(i - k)) ans += m.get(i - k) * v   // Otherwise, add product with matching number freq.\\n    return ans % 1000000007\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPairs = function(D) {\\n    let m = new Map(), ans = 0\\n    for (let n of D) m.set(n, (m.get(n) || 0) + 1)           // Push D into a standard frequency map\\n    for (let [k,v] of m)                                     // For each [key, value] pair\\n        for (let i = 1 << 21; i >= 2 * k && i; i >>= 1)      // Iterate through power sums using bitwise shifts\\n            if (i === 2 * k) ans += v * (v - 1) / 2          // If  k is its own matching number, add pairs to ans\\n            else if (m.has(i - k)) ans += m.get(i - k) * v   // Otherwise, add product with matching number freq.\\n    return ans % 1000000007\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999197,
                "title": "python3-o-n-100-100-easy-to-understand",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    dp -> key: i value: amount of deliciousness == i\\n    for d in 2**0, 2**1, ..., 2**21\\n    why 2**21: max of deliciousness is 2*20, sum of 2 max is 2**21\\n    O(22*N)\\n    \"\"\"\\n    def countPairs(self, ds: List[int]) -> int:\\n        from collections import defaultdict\\n        dp = defaultdict(int)\\n        # ds.sort() # no need to sort\\n        res = 0\\n        \\n        for d in ds:\\n            for i in range(22):\\n                # if 2**i - d in dp:\\n                res += dp[2**i - d]\\n            dp[d] += 1\\n        return res % (10**9 + 7)\\n                \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    dp -> key: i value: amount of deliciousness == i\\n    for d in 2**0, 2**1, ..., 2**21\\n    why 2**21: max of deliciousness is 2*20, sum of 2 max is 2**21\\n    O(22*N)\\n    \"\"\"\\n    def countPairs(self, ds: List[int]) -> int:\\n        from collections import defaultdict\\n        dp = defaultdict(int)\\n        # ds.sort() # no need to sort\\n        res = 0\\n        \\n        for d in ds:\\n            for i in range(22):\\n                # if 2**i - d in dp:\\n                res += dp[2**i - d]\\n            dp[d] += 1\\n        return res % (10**9 + 7)\\n                \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859861,
                "title": "python3-math-hash-table-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N * 22)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        cnt = collections.Counter(deliciousness)\\n        res = 0\\n        for k, v in cnt.items():\\n            for i in range(22):\\n                p = (1 << i) - k\\n                if p >= 0 and p in cnt:\\n                    if p == k: res += v * (v - 1)\\n                    else: res += v * cnt[p]\\n            \\n        return (res // 2)  % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        cnt = collections.Counter(deliciousness)\\n        res = 0\\n        for k, v in cnt.items():\\n            for i in range(22):\\n                p = (1 << i) - k\\n                if p >= 0 and p in cnt:\\n                    if p == k: res += v * (v - 1)\\n                    else: res += v * cnt[p]\\n            \\n        return (res // 2)  % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648668,
                "title": "unordered-map-c-two-sum",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Very Similar to **Two Sum Problem.** Store the values of power 2 (upto 2^21) and Apply Two Sum Approach.\\n\\n# Complexity\\n- Time complexity:O(21*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        int mod = 1e9+7;\\n        unordered_map<int,int> mp;\\n        vector<int> v;\\n        int num = 1,ans = 0,n = arr.size();\\n        v.push_back(1);\\n\\n        for(int i = 0;i<=21;i++)\\n        {\\n            num<<=1;\\n            v.push_back(num);\\n        }\\n        \\n        for(int i = 0;i<arr.size();i++)\\n        mp[arr[i]]++;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n             mp[arr[i]]--;\\n             if(mp[arr[i]]==0)\\n             mp.erase(arr[i]);\\n             for(int j = 0;j<v.size();j++)\\n             {\\n                 if(mp.find(v[j]-arr[i])!=mp.end())\\n                 ans = (ans+mp[v[j]-arr[i]])%mod;    \\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/3c69d440-e1aa-4920-9cb5-77dec69fec76_1687008529.912742.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        int mod = 1e9+7;\\n        unordered_map<int,int> mp;\\n        vector<int> v;\\n        int num = 1,ans = 0,n = arr.size();\\n        v.push_back(1);\\n\\n        for(int i = 0;i<=21;i++)\\n        {\\n            num<<=1;\\n            v.push_back(num);\\n        }\\n        \\n        for(int i = 0;i<arr.size();i++)\\n        mp[arr[i]]++;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n             mp[arr[i]]--;\\n             if(mp[arr[i]]==0)\\n             mp.erase(arr[i]);\\n             for(int j = 0;j<v.size();j++)\\n             {\\n                 if(mp.find(v[j]-arr[i])!=mp.end())\\n                 ans = (ans+mp[v[j]-arr[i]])%mod;    \\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192607,
                "title": "python-from-o-n-2-tle-to-o-n-explanation-easy-understanding",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def countPairsTLE(self, deliciousness: List[int]) -> int:\\n        # O(N^2)\\n        ways = 0\\n        for (x, y) in combinations(deliciousness, 2):\\n            val = x + y\\n            if (val & (val - 1) == 0) and val != 0:\\n                ways += 1\\n        return ways % ((10**9) + 7)\\n    \\n    def countPairs(self, deliciousness):\\n        \"\"\"\\n        Given numbers are in range of 0 and 2^20.\\n        Max sum must be under 2^21 (reason: 2^20 +2^20 = 2^21)\\n        \"\"\"\\n        # O(22N)\\n        # pre computing powers of 2 for saving time\\n        powers_of_2 = [2**i for i in range(22)]\\n        \\n        # for every number check if its power_of_2 - itself exists\\n        \\n        c = Counter() # to keep track of frequency\\n        ans = 0\\n        for d in deliciousness:\\n            # doing this before incremeting value count\\n            # because we dont want to do increments twice.\\n            # example in (1,3) there is only one way\\n            # but we want to the find the way when the pointer is at 3\\n            # and not at 1.\\n            for pw in powers_of_2:\\n                ans += c[pw-d]\\n            # increment value frequency\\n            c[d] += 1\\n        # return result\\n        return ans % ((10**9) + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def countPairsTLE(self, deliciousness: List[int]) -> int:\\n        # O(N^2)\\n        ways = 0\\n        for (x, y) in combinations(deliciousness, 2):\\n            val = x + y\\n            if (val & (val - 1) == 0) and val != 0:\\n                ways += 1\\n        return ways % ((10**9) + 7)\\n    \\n    def countPairs(self, deliciousness):\\n        \"\"\"\\n        Given numbers are in range of 0 and 2^20.\\n        Max sum must be under 2^21 (reason: 2^20 +2^20 = 2^21)\\n        \"\"\"\\n        # O(22N)\\n        # pre computing powers of 2 for saving time\\n        powers_of_2 = [2**i for i in range(22)]\\n        \\n        # for every number check if its power_of_2 - itself exists\\n        \\n        c = Counter() # to keep track of frequency\\n        ans = 0\\n        for d in deliciousness:\\n            # doing this before incremeting value count\\n            # because we dont want to do increments twice.\\n            # example in (1,3) there is only one way\\n            # but we want to the find the way when the pointer is at 3\\n            # and not at 1.\\n            for pw in powers_of_2:\\n                ans += c[pw-d]\\n            # increment value frequency\\n            c[d] += 1\\n        # return result\\n        return ans % ((10**9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083175,
                "title": "c-three-solutions-two-pointers-map-unordered-set-unordered-map",
                "content": "Overall, it is the advanced verison of classic two sum problem. At first glance, it is easy to get a brutal force solution which will have LTE but I didn\\'t try since the size of test cases would be 10^5. Therefore, the solution with time complexity O(n^2) would not be helpful for deriving an AC solution. **Note: constraints show 0 <= deliciousness[i] <= 2^20 and mean two 2 ^ 20 numbers may sum up to 2 ^21. Since the two sum is only equal to power of 2, the total possible accumulations are within [1,2,4,8,16,..,2^21].** \\n\\n1st Solution: (Two Pointers + Map)\\n```\\nclass Solution {\\nprivate:\\n    long long comb(long long num) {\\n        return (long long)(num * (num - 1) / 2);\\n    }\\n    \\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod = 1e9 + 7;\\n        map<int, int> m;\\n        for(auto& d : deliciousness) {\\n            ++m[d];\\n        }\\n        int res = 0;\\n        for(int i = 0; i <= 21; ++i) {\\n            int power = (1 << i);\\n            for(auto e : m) {\\n                if(power - e.first == e.first) {\\n                    res += comb(m[e.first]) % mod;\\n                }\\n            }\\n            auto l = m.begin();\\n            auto r = prev(m.end());\\n            while(l != r) {\\n                if((l->first + r->first) == power) {\\n                    res += l->second * r->second;\\n                    l = next(l);\\n                }\\n                else if(l->first + r->first < power) {\\n                    l = next(l);\\n                }\\n                else {\\n                    r = prev(r);\\n                }\\n            }\\n            res = (res % mod + mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```\\nstep1: save each value with the count into a map which can maintain sorted keys.\\nstep2: for a specific value of power of 2, apply two points to find how many pairs can be found out. Note: Input: deliciousness = [1,1,1,3,3,3,7], if power of 2 is equal to 2, the good meal (1,1) has 3 ways which is 3!/2. For the good meal (1, 3) has 9 ways which 3 * 3 from key = 1 and key = 3\\nstep3: this method would have to use long int or long long int to save the result and then modulo 10e9 + 7 \\n\\nTime Complexity O(n*k)\\nSpace Complexity O(n)\\n\\n2nd Solution: (Unordered_Set)\\n```\\nclass Solution {\\nprivate:\\n    long long comb(long long num) {\\n        return (long long)(num * (num - 1) / 2);\\n    }\\n    \\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod = 1e9 + 7;\\n        map<int, int> m;\\n        for(auto& d : deliciousness) {\\n            ++m[d];\\n        }\\n        long long res = 0;\\n        for(int i = 0; i <= 21; ++i) {\\n            int power = (1 << i);\\n            unordered_set<int> us;\\n            for(auto e : m) {\\n                if(us.find(e.first) == us.end() && m.find(power - e.first) != m.end()) {\\n                    if(e.first == power - e.first) {\\n                        res += comb(m[e.first]);\\n                    }\\n                    else {\\n                        res += e.second * m[power - e.first];\\n                    }\\n                    us.insert(e.first);\\n                    us.insert(power - e.first);\\n                }\\n                res %= mod;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe idea is similiar to two pointers but it uses an unordered_set for each iteraiton for avoiding duplicating caculation.\\nTime Complexity O(n*k)\\nSpace Complexity O(n)\\n\\n3rd Solution: (Unordered_Map)\\n(inspired by https://leetcode.com/problems/count-good-meals/discuss/999181/Accepted-c%2B%2B-or-O(N)-or-840ms)\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod = 1e9 + 7;\\n        sort(deliciousness.begin(), deliciousness.end());\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        for(auto d : deliciousness) {\\n            for(int i = 0; i <= 21; ++i) {\\n                int power = 1 << i;\\n                if(m.find(power - d) != m.end()) {\\n                    res += m[power - d];\\n                }\\n                res %= mod;\\n            }\\n            ++m[d];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity O(n*k)\\nSpace Complexity O(n)\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long comb(long long num) {\\n        return (long long)(num * (num - 1) / 2);\\n    }\\n    \\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod = 1e9 + 7;\\n        map<int, int> m;\\n        for(auto& d : deliciousness) {\\n            ++m[d];\\n        }\\n        int res = 0;\\n        for(int i = 0; i <= 21; ++i) {\\n            int power = (1 << i);\\n            for(auto e : m) {\\n                if(power - e.first == e.first) {\\n                    res += comb(m[e.first]) % mod;\\n                }\\n            }\\n            auto l = m.begin();\\n            auto r = prev(m.end());\\n            while(l != r) {\\n                if((l->first + r->first) == power) {\\n                    res += l->second * r->second;\\n                    l = next(l);\\n                }\\n                else if(l->first + r->first < power) {\\n                    l = next(l);\\n                }\\n                else {\\n                    r = prev(r);\\n                }\\n            }\\n            res = (res % mod + mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    long long comb(long long num) {\\n        return (long long)(num * (num - 1) / 2);\\n    }\\n    \\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod = 1e9 + 7;\\n        map<int, int> m;\\n        for(auto& d : deliciousness) {\\n            ++m[d];\\n        }\\n        long long res = 0;\\n        for(int i = 0; i <= 21; ++i) {\\n            int power = (1 << i);\\n            unordered_set<int> us;\\n            for(auto e : m) {\\n                if(us.find(e.first) == us.end() && m.find(power - e.first) != m.end()) {\\n                    if(e.first == power - e.first) {\\n                        res += comb(m[e.first]);\\n                    }\\n                    else {\\n                        res += e.second * m[power - e.first];\\n                    }\\n                    us.insert(e.first);\\n                    us.insert(power - e.first);\\n                }\\n                res %= mod;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod = 1e9 + 7;\\n        sort(deliciousness.begin(), deliciousness.end());\\n        unordered_map<int, int> m;\\n        int res = 0;\\n        for(auto d : deliciousness) {\\n            for(int i = 0; i <= 21; ++i) {\\n                int power = 1 << i;\\n                if(m.find(power - d) != m.end()) {\\n                    res += m[power - d];\\n                }\\n                res %= mod;\\n            }\\n            ++m[d];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999218,
                "title": "c-using-dictionary-o-n-log-n-solution",
                "content": "```csharp\\npublic int CountPairs(int[] deliciousness)\\n{\\n\\tDictionary<long, long> frequency = new Dictionary<long, long>();\\n\\tforeach (var num in deliciousness)\\n\\t{\\n\\t\\tif (frequency.ContainsKey(num))\\n\\t\\t{\\n\\t\\t\\tfrequency[num]++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfrequency.Add(num, 1);\\n\\t\\t}\\n\\t}\\n\\n\\tlong result = 0;\\n\\tconst int MOD = (int)(1E9) + 7;\\n\\t// MaxSum =  2 ^ 20 + 2 ^ 20  = 2 ^ 21\\n\\tfor (int i = 0; i <= 21; i++)\\n\\t{\\n\\t\\tlong nextPower = 1L << i;\\n\\t\\tforeach (var key in frequency.Keys)\\n\\t\\t{\\n\\t\\t\\tlong other = nextPower - key;\\n\\t\\t\\tif (other >= 0 && frequency.ContainsKey(other))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (key != other)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresult = (result + (frequency[key] * frequency[other]));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresult = (result + (frequency[key] * (frequency[key] - 1)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)((result / 2) % MOD);\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int CountPairs(int[] deliciousness)\\n{\\n\\tDictionary<long, long> frequency = new Dictionary<long, long>();\\n\\tforeach (var num in deliciousness)\\n\\t{\\n\\t\\tif (frequency.ContainsKey(num))\\n\\t\\t{\\n\\t\\t\\tfrequency[num]++;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfrequency.Add(num, 1);\\n\\t\\t}\\n\\t}\\n\\n\\tlong result = 0;\\n\\tconst int MOD = (int)(1E9) + 7;\\n\\t// MaxSum =  2 ^ 20 + 2 ^ 20  = 2 ^ 21\\n\\tfor (int i = 0; i <= 21; i++)\\n\\t{\\n\\t\\tlong nextPower = 1L << i;\\n\\t\\tforeach (var key in frequency.Keys)\\n\\t\\t{\\n\\t\\t\\tlong other = nextPower - key;\\n\\t\\t\\tif (other >= 0 && frequency.ContainsKey(other))\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (key != other)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresult = (result + (frequency[key] * frequency[other]));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tresult = (result + (frequency[key] * (frequency[key] - 1)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)((result / 2) % MOD);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3217565,
                "title": "simple-solution-using-pre-computation",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int mod = 1e9 + 7;\\n    int countPairs(vector<int> &d)\\n    {\\n        int cnt = 0;\\n        unordered_map<int, int> vis;\\n        set<int> s;\\n        int x = 1;\\n        for (int i = 0; i < 22; i++)\\t//reduction in strength \\uD83D\\uDD25\\n        {\\n            s.insert(x);\\n            x += x;\\n        }\\n        for (int i = 0; i < d.size(); i++)\\n        {\\n            for (auto x: s)\\n                if (vis.find(x - d[i]) != vis.end())\\n                    cnt = ((cnt + vis[x - d[i]]) % mod);\\n            vis[d[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int mod = 1e9 + 7;\\n    int countPairs(vector<int> &d)\\n    {\\n        int cnt = 0;\\n        unordered_map<int, int> vis;\\n        set<int> s;\\n        int x = 1;\\n        for (int i = 0; i < 22; i++)\\t//reduction in strength \\uD83D\\uDD25\\n        {\\n            s.insert(x);\\n            x += x;\\n        }\\n        for (int i = 0; i < d.size(); i++)\\n        {\\n            for (auto x: s)\\n                if (vis.find(x - d[i]) != vis.end())\\n                    cnt = ((cnt + vis[x - d[i]]) % mod);\\n            vis[d[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452448,
                "title": "c-hashmap-twosum-o-n",
                "content": "# Explanation:\\n* Method using the two pointer concept & hashmap.\\n* Traverse through array & store the element in hashmap with its frequency.\\n* For each element that is added to the hashmap check if there\\'s any element already present in the hashmap such that their sum is a power of 2.\\n* The maximum valued element possible in array is 2^20 (constraints) now as we\\'re taking sum of two elements the maximum value of sum will be: 2^20 + 2^20 = 2^21.\\n* Hence, traverse through map to search all the possible elements to make the sum a power of two :\\n* (2^0 - array[i]) or (2^1 - array[i]) or (2^2 - array[i]) ... (2^21 - array[i]) - For an element array[i] search for possible values in the hashmap. ( array[i] + (2^m - array[i]) = 2^m )\\n* If the element is present in the map, increase the count by the frequency of the element in hashmap.\\n* Time Complexity: O(N*22) \\n```\\nclass Solution {\\npublic:\\n    int mod = (7+1e9);\\n    int countPairs(vector<int>& array) {\\n        int n=array.size();\\n        unordered_map<int, int> mpp;\\n        long int count=0;\\n        \\n        for(int i=0; i<n; i++){\\n            mpp[array[i]]++;\\n            \\n            //For every element try & find the element if present such that the sum will be power of two.\\n            //Constraints: max value = 2^20 & taking sum of two elements of max value: 2*2^20\\n            //Check if there\\'s present (2^0 - array[i]) or (2^1 - array[i]) or ... (2^21 - array[i])\\n            for(int x=0; x<=21; x++){\\n                mpp[array[i]]--;    //Do not count the current element again. Example: 2+2\\n                if(mpp.find((1<<x) - array[i])!=mpp.end()) count += mpp[((1<<x) - array[i])];\\n                mpp[array[i]]++;    //Reset.\\n            }\\n        }\\n        \\n        return (count%mod);\\n    }\\n};\\n```\\n\\nUpvote!",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (7+1e9);\\n    int countPairs(vector<int>& array) {\\n        int n=array.size();\\n        unordered_map<int, int> mpp;\\n        long int count=0;\\n        \\n        for(int i=0; i<n; i++){\\n            mpp[array[i]]++;\\n            \\n            //For every element try & find the element if present such that the sum will be power of two.\\n            //Constraints: max value = 2^20 & taking sum of two elements of max value: 2*2^20\\n            //Check if there\\'s present (2^0 - array[i]) or (2^1 - array[i]) or ... (2^21 - array[i])\\n            for(int x=0; x<=21; x++){\\n                mpp[array[i]]--;    //Do not count the current element again. Example: 2+2\\n                if(mpp.find((1<<x) - array[i])!=mpp.end()) count += mpp[((1<<x) - array[i])];\\n                mpp[array[i]]++;    //Reset.\\n            }\\n        }\\n        \\n        return (count%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006723,
                "title": "easy-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] d) {\\n        int mod = (int)1e9+7;\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int val : d){\\n            int power = 1;\\n            for(int j = 0; j <= 21; j++){\\n                if(power - val >= 0 && map.containsKey(power-val) == true){\\n                    count += map.get(power - val);\\n                    count = count % mod;\\n                }\\n                power *= 2;\\n            }\\n            map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] d) {\\n        int mod = (int)1e9+7;\\n        int count = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int val : d){\\n            int power = 1;\\n            for(int j = 0; j <= 21; j++){\\n                if(power - val >= 0 && map.containsKey(power-val) == true){\\n                    count += map.get(power - val);\\n                    count = count % mod;\\n                }\\n                power *= 2;\\n            }\\n            map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847649,
                "title": "java-99-02-speed-map-brief-explanation",
                "content": "Because there are only 22 possible outcomes (i.e. 1, 2, 4, 8, ..., 2^21), we just have to iterate through all of them and query from the hashmap.\\n\\nThere is two or maybe three edge cases.\\n1. Int overflown - Use long to prevent this. The question asked us to mod 1e9 + 7, don\\'t forget.\\n\\n2. There are 22 possible outcomes, not 21, because 2^20 + 2^20 = 2^21.\\n\\n3. A power of 2 adds themsevles forms another power of 2, so in that case, we have to choose 2 from the pile, i.e. n * (n - 1) / 2.\\n\\n**Solution**\\n```Java\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : deliciousness){ // freq table\\n            map.merge(n, 1, Integer::sum);\\n        }\\n\\n        long ans = 0;\\n        for (int key : map.keySet()){\\n            int i = 1, cur = map.get(key);\\n            while(key > i - key) i <<= 1; // only check those no less than the current key number\\n            while(i <= (1 << 21)){\\n                ans += (key != i - key? \\n                        1L * cur * map.getOrDefault(i - key, 0) : // choose one from each pile\\n                       (1L * cur * (cur - 1)) / 2); // edge case -> choose two from the same pile \\n                i <<= 1;\\n            }\\n        }\\n\\n        return (int)(ans % (int)(1e9+7));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : deliciousness){ // freq table\\n            map.merge(n, 1, Integer::sum);\\n        }\\n\\n        long ans = 0;\\n        for (int key : map.keySet()){\\n            int i = 1, cur = map.get(key);\\n            while(key > i - key) i <<= 1; // only check those no less than the current key number\\n            while(i <= (1 << 21)){\\n                ans += (key != i - key? \\n                        1L * cur * map.getOrDefault(i - key, 0) : // choose one from each pile\\n                       (1L * cur * (cur - 1)) / 2); // edge case -> choose two from the same pile \\n                i <<= 1;\\n            }\\n        }\\n\\n        return (int)(ans % (int)(1e9+7));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515877,
                "title": "c-map-two-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int cnt=0;\\n        unordered_map<int,int> mp;\\n        mp[deliciousness[0]]++;\\n        int mod=1e9+7;\\n        for(int i=1;i<deliciousness.size();i++){\\n            for(int p=1;p<=(1<<21);p*=2){\\n                if(mp.find(p-deliciousness[i])!=mp.end()){\\n                    cnt=(cnt+mp[p-deliciousness[i]])%mod;\\n                    \\n                }\\n            }\\n            mp[deliciousness[i]]++;\\n            \\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int cnt=0;\\n        unordered_map<int,int> mp;\\n        mp[deliciousness[0]]++;\\n        int mod=1e9+7;\\n        for(int i=1;i<deliciousness.size();i++){\\n            for(int p=1;p<=(1<<21);p*=2){\\n                if(mp.find(p-deliciousness[i])!=mp.end()){\\n                    cnt=(cnt+mp[p-deliciousness[i]])%mod;\\n                    \\n                }\\n            }\\n            mp[deliciousness[i]]++;\\n            \\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445216,
                "title": "count-good-meals-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int N = deliciousness.size();\\n        unordered_map<int, int> mp;\\n        \\n        int count = 0, mod = 1000000007;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j <= 21; j++) {\\n                int target = pow(2, j);\\n                \\n                if (mp.find(target - deliciousness[i]) != mp.end()) {\\n                    count = (count + mp[target - deliciousness[i]]) % mod;\\n                }\\n            }\\n            \\n            mp[deliciousness[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\nExplanation:\\n1. The objective is to find a pair whose sum is equal to 2^p. We can calculate the range of \\'p\\' easily by looking at the constraints for the values in vector deliciousness. Here is how we can find it:\\n\\t```\\n\\tLet, a and b be two numbers whose sum is equal to 2^p\\n\\ta + b = 2^p\\n\\tSince, 0 <= deliciousness[i] <= 2^20, maximum possible value of a and b will be 2^20, therefore\\n\\t2^20 + 2^20 = 2^p\\n\\t2^21 = 2^p\\n\\thence, maximum possible value of p will be 21\\n\\t```\\n2. We have created an unordered map that will store values of vector deliciousness and their frequency in the vector\\n3. We create an count variable that will store our final answer\\n4. We will loop through the vector deliciousness and for each we value, let us say ```a```, will check if ```2^p - a``` is present in our unordered map or not. If we find such value we will add its frequency to our count variable.\\n\\t*** Remember 2^p is our target sum and since ```0 <= p <= 21```, we will need to consider every possible target sum for the corresponding value of ```p```. That is why we will need an additional for loop from j = 0 to j = 21.***\\n5. We will store the deliciousness[i] in unordered_map once we get out of the second for loop.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int N = deliciousness.size();\\n        unordered_map<int, int> mp;\\n        \\n        int count = 0, mod = 1000000007;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j <= 21; j++) {\\n                int target = pow(2, j);\\n                \\n                if (mp.find(target - deliciousness[i]) != mp.end()) {\\n                    count = (count + mp[target - deliciousness[i]]) % mod;\\n                }\\n            }\\n            \\n            mp[deliciousness[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n\\tLet, a and b be two numbers whose sum is equal to 2^p\\n\\ta + b = 2^p\\n\\tSince, 0 <= deliciousness[i] <= 2^20, maximum possible value of a and b will be 2^20, therefore\\n\\t2^20 + 2^20 = 2^p\\n\\t2^21 = 2^p\\n\\thence, maximum possible value of p will be 21\\n\\t```\n```a```\n```2^p - a```\n```0 <= p <= 21```\n```p```",
                "codeTag": "Java"
            },
            {
                "id": 1004722,
                "title": "java-o-n",
                "content": "```\\n    private static int mod = 1_000_000_007;\\n\\n    private static int[] twoSquare = new int[]{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};\\n\\n    public static int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = 0;\\n        for (int i = 0; i < deliciousness.length; i++) {\\n            for (int square : twoSquare) {\\n                int target = square - deliciousness[i];\\n                int count = map.getOrDefault(target, 0);\\n                ans = (ans + count) % mod;\\n            }\\n            map.put(deliciousness[i], map.getOrDefault(deliciousness[i], 0) + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static int mod = 1_000_000_007;\\n\\n    private static int[] twoSquare = new int[]{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};\\n\\n    public static int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = 0;\\n        for (int i = 0; i < deliciousness.length; i++) {\\n            for (int square : twoSquare) {\\n                int target = square - deliciousness[i];\\n                int count = map.getOrDefault(target, 0);\\n                ans = (ans + count) % mod;\\n            }\\n            map.put(deliciousness[i], map.getOrDefault(deliciousness[i], 0) + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999127,
                "title": "simple-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n\\n        public int CountPairs(int[] deliciousness)\\n        {\\n            IDictionary<int, List<int>> map = new Dictionary<int, List<int>>();\\n            for (int i = 0; i < deliciousness.Length; i++)\\n            {\\n                if (!map.ContainsKey(deliciousness[i]))\\n                {\\n                    map[deliciousness[i]] = new List<int>();\\n                }\\n\\n                map[deliciousness[i]].Add(i);\\n            }\\n\\n            int res = 0;\\n\\n            for (int i = 0; i < deliciousness.Length; i++)\\n            {\\n                //maximum sum will be 2^20 + 2^20 = 2^21\\n                //iterate through all possible powers of two\\n                for (int j = 0; j <= 21; j++)\\n                {\\n                    var target = 1 << j;\\n                    var other = target - deliciousness[i];\\n\\n                    if (map.ContainsKey(other))\\n                    {\\n                        //to calculate unique pairs we should kepp indices order: in pair[idx1, idx2] idx2 > idx1\\n                        var list = map[other];\\n                        var found = list.BinarySearch(i);\\n                        if (found >= 0)\\n                        {\\n                            //we can\\'t use the same index twice for one pair\\n                            found++;\\n                        }\\n                        else\\n                        {\\n                            found++;\\n                            found = -found;\\n                        }\\n\\n                        res += (list.Count - found);\\n                        res %= MODULO;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n\\n        public int CountPairs(int[] deliciousness)\\n        {\\n            IDictionary<int, List<int>> map = new Dictionary<int, List<int>>();\\n            for (int i = 0; i < deliciousness.Length; i++)\\n            {\\n                if (!map.ContainsKey(deliciousness[i]))\\n                {\\n                    map[deliciousness[i]] = new List<int>();\\n                }\\n\\n                map[deliciousness[i]].Add(i);\\n            }\\n\\n            int res = 0;\\n\\n            for (int i = 0; i < deliciousness.Length; i++)\\n            {\\n                //maximum sum will be 2^20 + 2^20 = 2^21\\n                //iterate through all possible powers of two\\n                for (int j = 0; j <= 21; j++)\\n                {\\n                    var target = 1 << j;\\n                    var other = target - deliciousness[i];\\n\\n                    if (map.ContainsKey(other))\\n                    {\\n                        //to calculate unique pairs we should kepp indices order: in pair[idx1, idx2] idx2 > idx1\\n                        var list = map[other];\\n                        var found = list.BinarySearch(i);\\n                        if (found >= 0)\\n                        {\\n                            //we can\\'t use the same index twice for one pair\\n                            found++;\\n                        }\\n                        else\\n                        {\\n                            found++;\\n                            found = -found;\\n                        }\\n\\n                        res += (list.Count - found);\\n                        res %= MODULO;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502300,
                "title": "awesome-solution-using-log-c",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N LOG N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& de) {\\n        unordered_map<long,long> st;\\n        set<int> visi;\\n        long count=0;\\n        int l=de.size();\\n        sort(de.begin(),de.end());\\n        for(int i=0;i<l;i++){\\n            int rem=pow(2,ceil(log(de[i])/log(2)));\\n            if(de[i]==0) {\\n                st[de[i]]+=1;\\n                continue;\\n            }\\n            if(ceil(log(de[i])/log(2))==floor(log(de[i])/log(2))){\\n                if(st.find(de[i])!=st.end()){\\n                    count+=st[de[i]];\\n                    count%=1000000007;\\n                }\\n                if(st.find(0)!=st.end()){\\n                    count+=st[0];\\n                    count%=1000000007;\\n                }\\n            }\\n            else if(st.find(rem-de[i])!=st.end()){\\n                count+=st[rem-de[i]];\\n                count%=1000000007;\\n            }\\n            st[de[i]]+=1;\\n        }\\n        return count%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& de) {\\n        unordered_map<long,long> st;\\n        set<int> visi;\\n        long count=0;\\n        int l=de.size();\\n        sort(de.begin(),de.end());\\n        for(int i=0;i<l;i++){\\n            int rem=pow(2,ceil(log(de[i])/log(2)));\\n            if(de[i]==0) {\\n                st[de[i]]+=1;\\n                continue;\\n            }\\n            if(ceil(log(de[i])/log(2))==floor(log(de[i])/log(2))){\\n                if(st.find(de[i])!=st.end()){\\n                    count+=st[de[i]];\\n                    count%=1000000007;\\n                }\\n                if(st.find(0)!=st.end()){\\n                    count+=st[0];\\n                    count%=1000000007;\\n                }\\n            }\\n            else if(st.find(rem-de[i])!=st.end()){\\n                count+=st[rem-de[i]];\\n                count%=1000000007;\\n            }\\n            st[de[i]]+=1;\\n        }\\n        return count%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217556,
                "title": "simple-map-power-of-2-array-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //O(N*21)\\n    //O(21)\\n    int countPairs(vector<int>&nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        vector<int>powers;\\n        for(int i=0;i<=21;i++){\\n            powers.push_back(pow(2,i));\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int pow=0;pow<powers.size();pow++)\\n            {\\n                if(mp.find(powers[pow]-nums[i])!=mp.end()){\\n                    ans=(ans+mp[powers[pow]-nums[i]])%1000000007;\\n                }\\n            }\\n            mp[nums[i]]++;\\n        }\\n        return (ans)%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //O(N*21)\\n    //O(21)\\n    int countPairs(vector<int>&nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>mp;\\n        vector<int>powers;\\n        for(int i=0;i<=21;i++){\\n            powers.push_back(pow(2,i));\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int pow=0;pow<powers.size();pow++)\\n            {\\n                if(mp.find(powers[pow]-nums[i])!=mp.end()){\\n                    ans=(ans+mp[powers[pow]-nums[i]])%1000000007;\\n                }\\n            }\\n            mp[nums[i]]++;\\n        }\\n        return (ans)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698203,
                "title": "easy-python-solution-without-using-any-external-library-counter",
                "content": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        dicts={}\\n        count=0\\n        for i in deliciousness:\\n            if len(dicts)==0:\\n                dicts[i]=0\\n            for j in range(22):\\n                if (2**j)-i in dicts:\\n                    count+=dicts[(2**j)-i]  \\n            if i not in dicts:\\n                dicts[i]=1\\n            elif i in dicts or dicts[i]==0:\\n                dicts[i]+=1  \\n        return count % ((10**9)+7)              \\n                \\n                ```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        dicts={}\\n        count=0\\n        for i in deliciousness:\\n            if len(dicts)==0:\\n                dicts[i]=0\\n            for j in range(22):\\n                if (2**j)-i in dicts:\\n                    count+=dicts[(2**j)-i]  \\n            if i not in dicts:\\n                dicts[i]=1\\n            elif i in dicts or dicts[i]==0:\\n                dicts[i]+=1  \\n        return count % ((10**9)+7)              \\n                \\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 2008664,
                "title": "easy-explanation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    #define modu int(1e9+7)\\n    // For each element in the array we will be checking for the possible elements in the map so that by adding them we can get the sum equal to the power of 2\\n    // like for getting 2^0 ,2^1,2^2 .......2^21 we will be checking the elements present in the map\\n    \\n    int countPairs(vector<int>& d) {\\n\\n        int n = d.size();\\n        int ans = 0;\\n        \\n        map<int,int>mp;\\n        for(int i = 0;i<n;i++){\\n            int t = 1;\\n            while(t<=pow(2,21)){\\n                if(mp.count(t-d[i])){\\n                    ans = (ans + mp[t-d[i]])%modu;\\n                    \\n                }\\n                t = t*2;\\n            }\\n            mp[d[i]]++; \\n        }\\n        \\n        return ans = ans%modu;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define modu int(1e9+7)\\n    // For each element in the array we will be checking for the possible elements in the map so that by adding them we can get the sum equal to the power of 2\\n    // like for getting 2^0 ,2^1,2^2 .......2^21 we will be checking the elements present in the map\\n    \\n    int countPairs(vector<int>& d) {\\n\\n        int n = d.size();\\n        int ans = 0;\\n        \\n        map<int,int>mp;\\n        for(int i = 0;i<n;i++){\\n            int t = 1;\\n            while(t<=pow(2,21)){\\n                if(mp.count(t-d[i])){\\n                    ans = (ans + mp[t-d[i]])%modu;\\n                    \\n                }\\n                t = t*2;\\n            }\\n            mp[d[i]]++; \\n        }\\n        \\n        return ans = ans%modu;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926756,
                "title": "c-map-o-n-time-precompute-power-simple-solution-with-explanation",
                "content": "(1) Precompute power from `1` to `2^21` as `pow` then iterate `deliciousness` for each `deliciousness[i]`.\\n(2) Then check if we have count any number for `pow[j]-deliciousness[i]`. If we do, then `res += map[pow[j]-deliciousness[i]]`.\\n(3) After that, `map[deliciousness[i]] += 1` as recording current value.\\n\\n* time : `O(n)`\\n* space: `O(n)`\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int n = deliciousness.size(), res = 0, mod = 1e9+7;\\n        vector<int> pow(22, 0);\\n        pow[0] = 1;\\n        for (int i = 1; i < 22; ++i) {\\n            pow[i] = (pow[i-1] << 1);\\n        }\\n        unordered_map<int, int> map;\\n        for (auto &d: deliciousness) {\\n            for (auto &p: pow) {\\n                res = (res+map[p-d])%mod;\\n            }\\n            ++map[d];\\n        }\\n        return res;            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int n = deliciousness.size(), res = 0, mod = 1e9+7;\\n        vector<int> pow(22, 0);\\n        pow[0] = 1;\\n        for (int i = 1; i < 22; ++i) {\\n            pow[i] = (pow[i-1] << 1);\\n        }\\n        unordered_map<int, int> map;\\n        for (auto &d: deliciousness) {\\n            for (auto &p: pow) {\\n                res = (res+map[p-d])%mod;\\n            }\\n            ++map[d];\\n        }\\n        return res;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538130,
                "title": "unordered-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const unsigned int M = 1000000007;\\n    int countPairs(vector<int>& del) {\\n        int ans = 0;\\n        int n = del.size();\\n        unordered_map<int , int> hash;\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int p = 1;p <= 1<<21;p *= 2){\\n                if(hash[p-del[i]] != 0){\\n                    ans = (ans+hash[p-del[i]])%M;\\n                }\\n            }\\n            hash[del[i]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const unsigned int M = 1000000007;\\n    int countPairs(vector<int>& del) {\\n        int ans = 0;\\n        int n = del.size();\\n        unordered_map<int , int> hash;\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int p = 1;p <= 1<<21;p *= 2){\\n                if(hash[p-del[i]] != 0){\\n                    ans = (ans+hash[p-del[i]])%M;\\n                }\\n            }\\n            hash[del[i]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484437,
                "title": "js-like-2-sum-o-n",
                "content": "```\\nvar countPairs = function(nums) {\\n    const pows = [], feq = new Map(), mod = 1e9+7;\\n    for(let i=0;i<=21;i++) {\\n        pows.push(Math.pow(2,i));\\n    }\\n    let res = 0;\\n    for(const num of nums) {\\n        for(const pow of pows) {\\n            if (feq.has(pow-num)) {\\n                res += feq.get(pow-num);\\n                res = res %  mod;\\n            } \\n        }\\n        \\n        feq.set(num, feq.get(num)+1 || 1);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countPairs = function(nums) {\\n    const pows = [], feq = new Map(), mod = 1e9+7;\\n    for(let i=0;i<=21;i++) {\\n        pows.push(Math.pow(2,i));\\n    }\\n    let res = 0;\\n    for(const num of nums) {\\n        for(const pow of pows) {\\n            if (feq.has(pow-num)) {\\n                res += feq.get(pow-num);\\n                res = res %  mod;\\n            } \\n        }\\n        \\n        feq.set(num, feq.get(num)+1 || 1);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1456288,
                "title": "javascript-solution-hash-table-a-little-bit-of-math",
                "content": "I found that by grouping up the numbers and calculating the count, we get a better performance because we often will decrease the number of times we need to check from `2^0` to `2^21`.\\n\\n\\n```\\nvar countPairs = function(deliciousness) {\\n    const n = deliciousness.length;\\n    const MOD = 1e9 + 7;\\n    \\n    const map = new Map();\\n    \\n    for (const num of deliciousness) {\\n        if (!map.has(num)) map.set(num, 0);\\n        map.set(num, map.get(num) + 1);\\n    }\\n    \\n    let max = 2**21; \\n    let res = 0;\\n    \\n    for (const [num, count] of map) {\\n\\n        let two = 1;\\n        \\n        while (two <= max) {\\n            const diff = two - num;\\n            \\n            if (diff >= 0 && map.has(diff)) {\\n                \\n                const otherCount = map.get(diff);\\n                \\n                if (num != diff) res += (count * otherCount);\\n                else res += (count * (count - 1) / 2);\\n            }\\n            \\n            two <<= 1;\\n        }\\n        \\n        map.delete(num);\\n    }\\n    \\n    return res % MOD;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar countPairs = function(deliciousness) {\\n    const n = deliciousness.length;\\n    const MOD = 1e9 + 7;\\n    \\n    const map = new Map();\\n    \\n    for (const num of deliciousness) {\\n        if (!map.has(num)) map.set(num, 0);\\n        map.set(num, map.get(num) + 1);\\n    }\\n    \\n    let max = 2**21; \\n    let res = 0;\\n    \\n    for (const [num, count] of map) {\\n\\n        let two = 1;\\n        \\n        while (two <= max) {\\n            const diff = two - num;\\n            \\n            if (diff >= 0 && map.has(diff)) {\\n                \\n                const otherCount = map.get(diff);\\n                \\n                if (num != diff) res += (count * otherCount);\\n                else res += (count * (count - 1) / 2);\\n            }\\n            \\n            two <<= 1;\\n        }\\n        \\n        map.delete(num);\\n    }\\n    \\n    return res % MOD;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1442382,
                "title": "java-hash-map-solution-with-comments",
                "content": "Suggest changes to improve on the runtime :)\\n```\\n\\nclass Solution {\\n\\n    public int countPairs(int[] deli) {\\n        \\n        //generating powers of 2 upto 21 and storing in an array\\n        int[] squares = new int[22];\\n        squares[0]=1;\\n        for(int i=1;i<22;i++){\\n            squares[i] = squares[i-1]*2;\\n        }\\n        \\n        //HashMap for storing elements and their occurences\\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        int len = deli.length;\\n        \\n        //count to return as result\\n        long count = 0;\\n        \\n        //loop from 0 to len-1\\n        for(int i=0; i<len; i++){\\n            int curr = deli[i];\\n            //checking for every power of 2 from 0 to 21 \\n            for(int j=0; j<=21; j++){\\n                \\n                int currTarget = squares[j];\\n                //currTarget-curr --> this is the number we need for the pair to be delicious\\n                if(map.containsKey(currTarget-curr)){\\n                    count += map.get(currTarget-curr);\\n                }\\n            }   \\n            //inc occurences / add new elements to hashmap\\n            if(map.containsKey(curr)){\\n               map.put(curr,map.get(curr)+1); \\n            }\\n            else{\\n                map.put(curr,1);\\n            }\\n        }\\n        \\n        //returning mod 10e9+7\\n        return (int)(count % 1000000007);\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n\\n    public int countPairs(int[] deli) {\\n        \\n        //generating powers of 2 upto 21 and storing in an array\\n        int[] squares = new int[22];\\n        squares[0]=1;\\n        for(int i=1;i<22;i++){\\n            squares[i] = squares[i-1]*2;\\n        }\\n        \\n        //HashMap for storing elements and their occurences\\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        int len = deli.length;\\n        \\n        //count to return as result\\n        long count = 0;\\n        \\n        //loop from 0 to len-1\\n        for(int i=0; i<len; i++){\\n            int curr = deli[i];\\n            //checking for every power of 2 from 0 to 21 \\n            for(int j=0; j<=21; j++){\\n                \\n                int currTarget = squares[j];\\n                //currTarget-curr --> this is the number we need for the pair to be delicious\\n                if(map.containsKey(currTarget-curr)){\\n                    count += map.get(currTarget-curr);\\n                }\\n            }   \\n            //inc occurences / add new elements to hashmap\\n            if(map.containsKey(curr)){\\n               map.put(curr,map.get(curr)+1); \\n            }\\n            else{\\n                map.put(curr,1);\\n            }\\n        }\\n        \\n        //returning mod 10e9+7\\n        return (int)(count % 1000000007);\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372272,
                "title": "c-map-solution-o-n",
                "content": "Runtime: 1088 ms, faster than 13.31% of C++ online submissions for Count Good Meals.\\nMemory Usage: 181.6 MB, less than 8.55% of C++ online submissions for Count Good Meals.\\n\\n\\nSolution is similar to Two Sum problem. We loop through nums array and for item t we check if K-t count\\nin the Map. As we have to find the sum K as power of number 2 and so we loop values of K from 0 to 2^21.\\nIf count > 0 we increment sum count. Also increment the item t count in Map.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        \\n        unordered_map<int,int>track;    // track number occuerence count\\n        int MOD = 1000000007; \\n        \\n        // generate power of 2 from 0 to 21\\n        int pow_arr[22];\\n        for(int i=0;i<22;i++)pow_arr[i] = pow(2,i);\\n        \\n        // total good meal count\\n        long long res = 0;\\n        \\n        for(auto &t: arr)\\n        {\\n            for(int i=0;i<22;i++)       // check complement of t for power of 2 from 0 to 21\\n                res += track[pow_arr[i]-t];    // add complement of t count with result count        \\n            track[t]++; // increase current item count\\n        }\\n        \\n        return res % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        \\n        unordered_map<int,int>track;    // track number occuerence count\\n        int MOD = 1000000007; \\n        \\n        // generate power of 2 from 0 to 21\\n        int pow_arr[22];\\n        for(int i=0;i<22;i++)pow_arr[i] = pow(2,i);\\n        \\n        // total good meal count\\n        long long res = 0;\\n        \\n        for(auto &t: arr)\\n        {\\n            for(int i=0;i<22;i++)       // check complement of t for power of 2 from 0 to 21\\n                res += track[pow_arr[i]-t];    // add complement of t count with result count        \\n            track[t]++; // increase current item count\\n        }\\n        \\n        return res % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342257,
                "title": "c-explained-twosum-hashmap-o-22n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576 \\n    int countPairs(vector<int>& arr) {\\n        int mod = 1000000007;\\n        unordered_map<int, int> map;\\n        int ans=0, n=arr.size();\\n        \\n        // Iterate over all the numbers.\\n        for(int i=0; i<n; i++){\\n            int power = 1;\\n            // Iterate 22 times for different powers of 2 from 2^0=1 till 2^21\\n            for(int j=0; j<22; j++){\\n                // Check if the difference of power of 2 and arr[i] exists in the map already\\n                // If it exists, then add the frequency\\n                if(map.count(power-arr[i])){\\n                    ans += map[power-arr[i]];\\n                    ans %= mod;\\n                }\\n                // Increase the power by 2X so that the loop checks for the next pow of 2\\n                power*=2;\\n            }\\n            // Increment the freq of arr[i] in map now.\\n            // By doing this now, we are not counting the pairs twice EX: (1,3) and (3,1) for power=4\\n            // When arr[i] = 1, then 3 was not present in map so pow=4, it will say Not present in map.\\n            // When arr[i] = 3, and pow=4, then it will say that map[4-3] is present already ans inc by 1.\\n            map[arr[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576 \\n    int countPairs(vector<int>& arr) {\\n        int mod = 1000000007;\\n        unordered_map<int, int> map;\\n        int ans=0, n=arr.size();\\n        \\n        // Iterate over all the numbers.\\n        for(int i=0; i<n; i++){\\n            int power = 1;\\n            // Iterate 22 times for different powers of 2 from 2^0=1 till 2^21\\n            for(int j=0; j<22; j++){\\n                // Check if the difference of power of 2 and arr[i] exists in the map already\\n                // If it exists, then add the frequency\\n                if(map.count(power-arr[i])){\\n                    ans += map[power-arr[i]];\\n                    ans %= mod;\\n                }\\n                // Increase the power by 2X so that the loop checks for the next pow of 2\\n                power*=2;\\n            }\\n            // Increment the freq of arr[i] in map now.\\n            // By doing this now, we are not counting the pairs twice EX: (1,3) and (3,1) for power=4\\n            // When arr[i] = 1, then 3 was not present in map so pow=4, it will say Not present in map.\\n            // When arr[i] = 3, and pow=4, then it will say that map[4-3] is present already ans inc by 1.\\n            map[arr[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218489,
                "title": "c-using-hashmap-explanation",
                "content": "As maximum limit of constraint is 2 ^ 20,  there are exactly 21 values which are power of 2 and lie in the given range. (From 2^0 to 2^20). \\n\\n\\n```\\n int countPairs(vector<int>& d) \\n    {\\n        int res = 0;\\n        int mod = 1e9 + 7;\\n        int n = d.size();\\n \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t\\n            for(int p = 0; p <= 21; p++)     \\n            {\\n                int power = 1 << p;     //(x<<y) is equivalent to multiplying x with 2^y\\n                if(mp.find(power - d[i]) != mp.end())  //search for the element in map\\n                    res += mp[power - d[i]];\\n               \\n                res %= mod;\\n            }\\n            \\n            mp[d[i]]++;   \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int countPairs(vector<int>& d) \\n    {\\n        int res = 0;\\n        int mod = 1e9 + 7;\\n        int n = d.size();\\n \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n\\t\\t\\n            for(int p = 0; p <= 21; p++)     \\n            {\\n                int power = 1 << p;     //(x<<y) is equivalent to multiplying x with 2^y\\n                if(mp.find(power - d[i]) != mp.end())  //search for the element in map\\n                    res += mp[power - d[i]];\\n               \\n                res %= mod;\\n            }\\n            \\n            mp[d[i]]++;   \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166545,
                "title": "java-array-two-sum-beats-100-t-c-o-n-s-c-o-math-pow-2-20",
                "content": "\\n    public int countPairs(int[] deliciousness) {\\n\\n\\t\\tint[] map = new int[1048577];\\n\\t\\tint len = deliciousness.length, mod = 1_000_000_007, len2 = 1048577;\\n\\t\\tlong ans = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint a = deliciousness[i], mul = 1;\\n\\t\\t\\tfor (int j = 0; j <= 21; j++) {\\n\\t\\t\\t\\tint b = mul - a;\\n\\t\\t\\t\\tmul *= 2;\\n\\n\\t\\t\\t\\tif (b < 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse if (b >= len2)\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tint count = map[b];\\n\\t\\t\\t\\tans += count;\\n\\t\\t\\t}\\n\\t\\t\\tmap[a] += 1;\\n\\t\\t}\\n\\t\\treturn (int) (ans % mod);\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public int countPairs(int[] deliciousness) {\\n\\n\\t\\tint[] map = new int[1048577];\\n\\t\\tint len = deliciousness.length, mod = 1_000_000_007, len2 = 1048577;\\n\\t\\tlong ans = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint a = deliciousness[i], mul = 1;\\n\\t\\t\\tfor (int j = 0; j <= 21; j++) {\\n\\t\\t\\t\\tint b = mul - a;\\n\\t\\t\\t\\tmul *= 2;\\n\\n\\t\\t\\t\\tif (b < 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse if (b >= len2)\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tint count = map[b];\\n\\t\\t\\t\\tans += count;\\n\\t\\t\\t}\\n\\t\\t\\tmap[a] += 1;\\n\\t\\t}\\n\\t\\treturn (int) (ans % mod);\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1139386,
                "title": "easy-c-90-fast-with-comments-172ms",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        map<int, long long> meals;\\n        set<int> powerOfTwo;\\n\\t\\t\\n\\t\\t//Power_array to store power of 2\\n        for(int i = 0; i <= 21; i++) {\\n            powerOfTwo.insert(1<<i);\\n        }\\n        long long res = 0;\\n\\t\\t\\n\\t\\t//store meals with there count \\n        for(int num : deliciousness) {\\n            meals[num]++;\\n        }\\n\\n\\t\\t//for each meal we will check if there exist any other meal that sums to good meal.\\n        for(auto meal : meals) {\\n\\t\\t\\n\\t\\t// Loop from lower bound of square value of meal till end \\n\\t\\t// example if  meal 4 then we will search lower bound of 16 in our stored power array.\\n            for(auto num = powerOfTwo.lower_bound(meal.first<<1); num != powerOfTwo.end(); num++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// checking lower bound of *num - meal.first exist in meals.\\n\\t\\t\\t\\t//example : num = 16 , meal.first = 1 then we will check for 15\\n                auto it = meals.lower_bound(*num - meal.first);\\n                if(it == meals.end())\\n\\t\\t\\t\\t//if not found break\\n                    break;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we found the number we are searching  i.e  15(it.first) + 1(meal.first) == 16(num) then we will calculate the result\\n                if(it->first + meal.first == *num) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// to calculate ways  \\n                    if(it->first == meal.first)\\n                        res += it->second * (meal.second - 1) / 2;\\n                    else\\n                        res += it->second * meal.second;\\n                }\\n            }\\n        }\\n\\n        return res % 1000000007;\\n    }\\n};\\n```\\n\\n\\n**PLEASE UPVOTE IF YOU FIND HELPFULL**\\n**FEEL FREE TO COMMENT FOR DOUBTS**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        map<int, long long> meals;\\n        set<int> powerOfTwo;\\n\\t\\t\\n\\t\\t//Power_array to store power of 2\\n        for(int i = 0; i <= 21; i++) {\\n            powerOfTwo.insert(1<<i);\\n        }\\n        long long res = 0;\\n\\t\\t\\n\\t\\t//store meals with there count \\n        for(int num : deliciousness) {\\n            meals[num]++;\\n        }\\n\\n\\t\\t//for each meal we will check if there exist any other meal that sums to good meal.\\n        for(auto meal : meals) {\\n\\t\\t\\n\\t\\t// Loop from lower bound of square value of meal till end \\n\\t\\t// example if  meal 4 then we will search lower bound of 16 in our stored power array.\\n            for(auto num = powerOfTwo.lower_bound(meal.first<<1); num != powerOfTwo.end(); num++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t// checking lower bound of *num - meal.first exist in meals.\\n\\t\\t\\t\\t//example : num = 16 , meal.first = 1 then we will check for 15\\n                auto it = meals.lower_bound(*num - meal.first);\\n                if(it == meals.end())\\n\\t\\t\\t\\t//if not found break\\n                    break;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we found the number we are searching  i.e  15(it.first) + 1(meal.first) == 16(num) then we will calculate the result\\n                if(it->first + meal.first == *num) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// to calculate ways  \\n                    if(it->first == meal.first)\\n                        res += it->second * (meal.second - 1) / 2;\\n                    else\\n                        res += it->second * meal.second;\\n                }\\n            }\\n        }\\n\\n        return res % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113160,
                "title": "python3-counter-o-n",
                "content": "Since the input size is 10^5, if you just do naive solution with O(n^2), it will TLE. The following hash table achieves O(21n) = O(n). The reason why we have 21 here is because 0 <= deliciousness[i] <= 2^20 so the sum of every pair should be no more than 2^21.\\n\\n```python\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        def complement(i, n):\\n            return (1<<n)-i\\n\\n        MOD = 10**9 + 7\\n        count = Counter(deliciousness)\\n        ans = 0\\n        for i in count:\\n            for n in range(22):\\n                j = complement(i, n)\\n                if j in count:\\n                    if i == j:\\n                        ans += count[i] * (count[i]-1)\\n                    else:\\n                        ans += count[i] * count[j]\\n        return (ans // 2)%MOD\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        def complement(i, n):\\n            return (1<<n)-i\\n\\n        MOD = 10**9 + 7\\n        count = Counter(deliciousness)\\n        ans = 0\\n        for i in count:\\n            for n in range(22):\\n                j = complement(i, n)\\n                if j in count:\\n                    if i == j:\\n                        ans += count[i] * (count[i]-1)\\n                    else:\\n                        ans += count[i] * count[j]\\n        return (ans // 2)%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111599,
                "title": "how-to-pass-the-last-test-case",
                "content": "I\\'ve already added \\'mod\\' almost everywhere when I am counting, but still failed in the last test case (an array filled with many 32)... What did I miss?\\n\\n    class Solution {\\n    public int countPairs(int[] d) {\\n        \\n        int max = Integer.MIN_VALUE;\\n        int mod = 1000000007;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int n : d) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            max = Math.max(max, n);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i <= max * 2; i *= 2) {\\n            ans += getPairsCount(map, d, i) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n    \\n    // counting pairs with given sum \\n    private int getPairsCount(Map<Integer, Integer> map, int[] d, int sum) {\\n        \\n        int count = 0;\\n        int mod = 1000000007;\\n        \\n        for (int n : d) {\\n            \\n            int complement = sum - n;\\n            \\n            if (map.containsKey(complement)) {\\n                count += map.get(complement) % mod;\\n            }\\n            \\n            if (complement == n) {\\n                count--;\\n            }\\n        }\\n        \\n        return count / 2;\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPairs(int[] d) {\\n        \\n        int max = Integer.MIN_VALUE;\\n        int mod = 1000000007;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int n : d) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            max = Math.max(max, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1000341,
                "title": "my-java-o-n-solution-with-a-small-improvement",
                "content": "Just keep the current max value in the loop so we don\\'t need to check until 2**20.\\n\\n```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        int res = 0, max = 0;\\n\\n        int[] pow = new int[22];\\n        for(int i = 0, val = 1; i < pow.length; i++) {\\n            pow[i] = val;\\n            val = (val << 1);\\n        }\\n        \\n        for (int n : deliciousness) {\\n            max = Math.max(max, n);\\n            int up = (int)(Math.log(2*max)/Math.log(2));\\n            for (int i = 0; i <= up; i++) {\\n                res = (res + m.getOrDefault(pow[i] - n, 0))%(int)(1e9+7);\\n            }\\n            m.put(n, m.getOrDefault(n, 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        int res = 0, max = 0;\\n\\n        int[] pow = new int[22];\\n        for(int i = 0, val = 1; i < pow.length; i++) {\\n            pow[i] = val;\\n            val = (val << 1);\\n        }\\n        \\n        for (int n : deliciousness) {\\n            max = Math.max(max, n);\\n            int up = (int)(Math.log(2*max)/Math.log(2));\\n            for (int i = 0; i <= up; i++) {\\n                res = (res + m.getOrDefault(pow[i] - n, 0))%(int)(1e9+7);\\n            }\\n            m.put(n, m.getOrDefault(n, 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999284,
                "title": "python-using-dictionary-10-lines",
                "content": "```\\nclass Solution:\\n    def countPairs(self, d: List[int]) -> int:\\n        c=0\\n        D={}\\n        for i in d:\\n            for j in range(22):\\n                if 2**j - i in D:\\n                    c+=D[2**j - i]\\n            if i in D:\\n                D[i]+=1\\n            else:\\n                D[i]=1\\n        return c%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, d: List[int]) -> int:\\n        c=0\\n        D={}\\n        for i in d:\\n            for j in range(22):\\n                if 2**j - i in D:\\n                    c+=D[2**j - i]\\n            if i in D:\\n                D[i]+=1\\n            else:\\n                D[i]=1\\n        return c%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999261,
                "title": "python-solution",
                "content": "Since `0 <= deliciousness[i] <= 2**20`, the sum of deliciousness of a good meal is less than or equal to `2**21`. Hence all possible sum of deliciousness of a good meal is `pow_of_2 = [2**i for i in range(0, 22)]`. Then we can first calculate a dictionary of counters of elements in `deliciousness`, and loop over the key, value pairs in the dictionary. For each key, value pair, we loop over all possible elements `n` in `pow_of_2`, and check if `n - key` is also in the dictionary. If yes, and `n - key == key`, we increment the result by `value * (value - 1) // 2`; otherwise, we increment the result by `value * cnt[n - key]` (to avoid double counting, we need to make sure we haven\\'t seen `n - key` already before we reach `key`, hence we use a set `visit` to keep track of all keys we\\'ve already seen).\\n\\nTime complexity: O(n), space complexity: O(n).\\n\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        pow_of_2 = set([2**i for i in range(0, 22)])\\n        MOD = 10**9 + 7\\n        \\n        cnt = {}\\n        for d in deliciousness:\\n            if d in cnt:\\n                cnt[d] += 1\\n            else:\\n                cnt[d] = 1\\n                \\n        res = 0\\n        visit = set()\\n        for key, val in cnt.items():\\n            for n in pow_of_2:\\n                if n - key in cnt:\\n                    if n - key == key:\\n                        res += val * (val - 1) // 2\\n                    else:\\n                        if n - key not in visit:\\n                            res += val * cnt[n - key]\\n            visit.add(key)\\n        return res % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        pow_of_2 = set([2**i for i in range(0, 22)])\\n        MOD = 10**9 + 7\\n        \\n        cnt = {}\\n        for d in deliciousness:\\n            if d in cnt:\\n                cnt[d] += 1\\n            else:\\n                cnt[d] = 1\\n                \\n        res = 0\\n        visit = set()\\n        for key, val in cnt.items():\\n            for n in pow_of_2:\\n                if n - key in cnt:\\n                    if n - key == key:\\n                        res += val * (val - 1) // 2\\n                    else:\\n                        if n - key not in visit:\\n                            res += val * cnt[n - key]\\n            visit.add(key)\\n        return res % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999238,
                "title": "passed-68-69-testcases-can-anyone-tell-me-what-wrong-in-my-code",
                "content": "it does not pass test case [32,32,32,32,32,......10^5 times]\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n      ll mod=pow(10,9)+7;\\n      int n=d.size();\\n      \\n      \\n      unordered_map<ll,ll>map;\\n      \\n      for(auto v:d)map[v]++;\\n      \\n//       for(auto pair : map)cout<<pair.first<<\" \"<<pair.second<<endl;\\n      \\n//       cout<<\"-------------------\"<<endl;\\n      ll count=0;\\n      \\n      for(auto pair:map){\\n        \\n        for(ll val=1;val<=pow(2,21);val=val*2){\\n          \\n          if(map.find(val-pair.first)!=map.end()){\\n            if(val-pair.first==pair.first && map[pair.first]>1){\\n              //cout<<pair.first<<endl;\\n              count=(count+((map[pair.first]*(map[pair.first]-1))%mod))%mod;\\n            }\\n            else if(val-pair.first!=pair.first){\\n              //cout<<pair.first<<\" \"<<val-pair.first<<endl;\\n              count=(count+((map[val-pair.first]* map[pair.first]))%mod)%mod;\\n            }\\n          }\\n          \\n        }\\n      }\\n      count=((count/2)%mod);\\n      return count%mod;\\n      \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n      ll mod=pow(10,9)+7;\\n      int n=d.size();\\n      \\n      \\n      unordered_map<ll,ll>map;\\n      \\n      for(auto v:d)map[v]++;\\n      \\n//       for(auto pair : map)cout<<pair.first<<\" \"<<pair.second<<endl;\\n      \\n//       cout<<\"-------------------\"<<endl;\\n      ll count=0;\\n      \\n      for(auto pair:map){\\n        \\n        for(ll val=1;val<=pow(2,21);val=val*2){\\n          \\n          if(map.find(val-pair.first)!=map.end()){\\n            if(val-pair.first==pair.first && map[pair.first]>1){\\n              //cout<<pair.first<<endl;\\n              count=(count+((map[pair.first]*(map[pair.first]-1))%mod))%mod;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 999132,
                "title": "python-3-dictionary",
                "content": "1.  Create Dictionary (counter for each deliciousness)\\n2. Iterate over all distinct deliciousness (keys in the dictionary)\\n3. Check for all possible powers of 2 (only 22 available values), if \"missing\" part is in dictionary (it means, that it is in deliciousness)\\n4. Count all options\\n5. We counted everything two times, we have to devide answer by 2\\n\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powers2=[2**i for i in range(22)]\\n        answ=0\\n        d={}\\n        for x in deliciousness:\\n            if x in d: d[x]+=1\\n            else: d[x]=1     \\n                \\n        for k, v in d.items():\\n            if v>1 and k in powers2: answ+=v*(v-1)\\n            a=0\\n            for p2 in powers2:\\n                q=p2-k\\n                if q!=k and q in d:\\n                    a+=d[q]\\n            answ+=a*v\\n        answ//=2\\n        return answ % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powers2=[2**i for i in range(22)]\\n        answ=0\\n        d={}\\n        for x in deliciousness:\\n            if x in d: d[x]+=1\\n            else: d[x]=1     \\n                \\n        for k, v in d.items():\\n            if v>1 and k in powers2: answ+=v*(v-1)\\n            a=0\\n            for p2 in powers2:\\n                q=p2-k\\n                if q!=k and q in d:\\n                    a+=d[q]\\n            answ+=a*v\\n        answ//=2\\n        return answ % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837120,
                "title": "c-hashmap-soultion-complexity-average-o-n-worst-case-o-n-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        long M = 1000000007;\\n        int n = arr.size();\\n        unordered_map<int,int> powers;\\n        \\n        long long ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            int itr=1;\\n            for(int j=0;j<22;j++){\\n                if(powers.count(itr-arr[i])){\\n                    ans += powers[itr-arr[i]];\\n                }\\n                itr*=2;\\n            }\\n            powers[arr[i]]++;\\n        }\\n\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr) {\\n        long M = 1000000007;\\n        int n = arr.size();\\n        unordered_map<int,int> powers;\\n        \\n        long long ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            int itr=1;\\n            for(int j=0;j<22;j++){\\n                if(powers.count(itr-arr[i])){\\n                    ans += powers[itr-arr[i]];\\n                }\\n                itr*=2;\\n            }\\n            powers[arr[i]]++;\\n        }\\n\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957244,
                "title": "o-n-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(22N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar countPairs = function(deliciousness) {\\n    let squares = [];\\n    const complement = new Map();\\n    let MOD = 10**9 + 7\\n\\n    let res = 0;\\n    for(let rate of deliciousness) {\\n        for(let i = 21; i >= 0; i--) {\\n            let sqr = 2**i;\\n            if(sqr - rate < 0) break;\\n            if(complement.has(sqr - rate)){\\n                res += complement.get(sqr - rate)\\n            }\\n        }\\n        complement.set(rate, complement.get(rate) + 1 || 1)\\n    }\\n\\n    return res%MOD\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPairs = function(deliciousness) {\\n    let squares = [];\\n    const complement = new Map();\\n    let MOD = 10**9 + 7\\n\\n    let res = 0;\\n    for(let rate of deliciousness) {\\n        for(let i = 21; i >= 0; i--) {\\n            let sqr = 2**i;\\n            if(sqr - rate < 0) break;\\n            if(complement.has(sqr - rate)){\\n                res += complement.get(sqr - rate)\\n            }\\n        }\\n        complement.set(rate, complement.get(rate) + 1 || 1)\\n    }\\n\\n    return res%MOD\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957239,
                "title": "clean-code-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(22N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        count = {}\\n        res = 0\\n        MOD = pow(10, 9) + 7\\n\\n        for rate in deliciousness:\\n            for i in range(22):\\n                sqr = pow(2, i)\\n                target = sqr - rate\\n                if target in count:\\n                    res += count[target]\\n            if rate in count:\\n                count[rate] += 1\\n            else:\\n                count[rate] = 1\\n        \\n        return res % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        count = {}\\n        res = 0\\n        MOD = pow(10, 9) + 7\\n\\n        for rate in deliciousness:\\n            for i in range(22):\\n                sqr = pow(2, i)\\n                target = sqr - rate\\n                if target in count:\\n                    res += count[target]\\n            if rate in count:\\n                count[rate] += 1\\n            else:\\n                count[rate] = 1\\n        \\n        return res % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939538,
                "title": "o-n-python-solution",
                "content": "# Intuition\\nWe know we can solve this in O(n^2). But can we make it efficient? It turns out, yes we can. \\n\\n# Approach\\nWe know that power functions grow very fast.\\n- If we look at the constraints, we can see that the largest possible number is 2^20. what this tells us is that, there is exactly 20 numbers in the range 0 - 2^20 that are powers of two. these are 2^0, 2^1, 2^2, 2^3,...,2^20.\\n\\n- now, the problem is reduced to \"two sum\" problem but in this case we are not searching for a single sum, but the powers of 2, which we found to be a maximum of 20.\\n\\n- by doing this, we broke down the problem from O(n^2) to O(20*n), which is O(n).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powers = [2 ** i for i in range(22)]\\n        MOD = 10e8 + 7\\n        count = Counter(deliciousness)\\n        good_meals = set()\\n        for n in count:\\n            for p in powers:\\n                if p - n in count and (n != p - n or count[p - n] > 1) and (p - n, n) not in good_meals:\\n                    good_meals.add((n, p - n))\\n        \\n        ans = 0\\n        for m in good_meals:\\n            if m[0] == m[1]:\\n                ans += ((count[m[0]] - 1) * (count[m[0]]) // 2)\\n            else:\\n                ans += (count[m[0]] * count[m[1]])\\n        return int(ans % MOD)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powers = [2 ** i for i in range(22)]\\n        MOD = 10e8 + 7\\n        count = Counter(deliciousness)\\n        good_meals = set()\\n        for n in count:\\n            for p in powers:\\n                if p - n in count and (n != p - n or count[p - n] > 1) and (p - n, n) not in good_meals:\\n                    good_meals.add((n, p - n))\\n        \\n        ans = 0\\n        for m in good_meals:\\n            if m[0] == m[1]:\\n                ans += ((count[m[0]] - 1) * (count[m[0]]) // 2)\\n            else:\\n                ans += (count[m[0]] * count[m[1]])\\n        return int(ans % MOD)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538430,
                "title": "c-simple-o-21-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> myMap;\\n        int mod = 1e9 + 7;\\n        int num = 1;\\n        vector<int> power = {1};\\n        for (int i=0; i<21; ++i) {\\n            num *= 2;\\n            power.push_back(num);\\n        }\\n        long long count = 0;\\n        \\n        for (int i=0; i<deliciousness.size(); ++i) {\\n            for (int j=0; j<power.size(); ++j) {\\n                if (myMap.count(power[j] - deliciousness[i])) {\\n                    count += myMap[power[j] - deliciousness[i]];\\n                    count %= mod;\\n                }\\n            }\\n            myMap[deliciousness[i]] ++;\\n        }\\n        count %= mod;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> myMap;\\n        int mod = 1e9 + 7;\\n        int num = 1;\\n        vector<int> power = {1};\\n        for (int i=0; i<21; ++i) {\\n            num *= 2;\\n            power.push_back(num);\\n        }\\n        long long count = 0;\\n        \\n        for (int i=0; i<deliciousness.size(); ++i) {\\n            for (int j=0; j<power.size(); ++j) {\\n                if (myMap.count(power[j] - deliciousness[i])) {\\n                    count += myMap[power[j] - deliciousness[i]];\\n                    count %= mod;\\n                }\\n            }\\n            myMap[deliciousness[i]] ++;\\n        }\\n        count %= mod;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490015,
                "title": "c-using-unordered-map-o-n-solution",
                "content": "```\\n\\nclass Solution {\\n    long long int maxOperations(int k,unordered_map<int,int> &mp) {\\n        long ans = 0;unordered_map<int,bool> pmp;\\n        for(auto it : mp){\\n            int x = it.first;\\n            int y = k - x;\\n            if(mp.find(y)!=mp.end()){\\n                if(!pmp[x] || !pmp[y]){\\n                    long add = long(mp[x])*long(mp[y]);\\n                    if(x==y) add = (add-mp[x])/2;\\n                    ans += add;\\n                    pmp[x] = true,pmp[y] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        vector<int> v;int x = 1;long ans = 0; \\n        for(int i = 0;i<=21;i++) v.push_back(x),x<<=1;\\n        unordered_map<int,int> mp;\\n        for(auto it :deliciousness) mp[it]++;\\n        for(auto it:v) {\\n            ans = ans + maxOperations(it,mp);\\n        }\\n        \\n        return int(ans% 1000000007);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n    long long int maxOperations(int k,unordered_map<int,int> &mp) {\\n        long ans = 0;unordered_map<int,bool> pmp;\\n        for(auto it : mp){\\n            int x = it.first;\\n            int y = k - x;\\n            if(mp.find(y)!=mp.end()){\\n                if(!pmp[x] || !pmp[y]){\\n                    long add = long(mp[x])*long(mp[y]);\\n                    if(x==y) add = (add-mp[x])/2;\\n                    ans += add;\\n                    pmp[x] = true,pmp[y] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        vector<int> v;int x = 1;long ans = 0; \\n        for(int i = 0;i<=21;i++) v.push_back(x),x<<=1;\\n        unordered_map<int,int> mp;\\n        for(auto it :deliciousness) mp[it]++;\\n        for(auto it:v) {\\n            ans = ans + maxOperations(it,mp);\\n        }\\n        \\n        return int(ans% 1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478297,
                "title": "very-easy-c-hashmap-twosum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int countPairs(vector<int>& arr) \\n    {\\n        unordered_map<long long int ,long long int>mp;\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]++;      //adding the frequency\\n\\n            //value  1 , 2 , 4 , 8  ------>2^21\\n            //mpx + arr[i] == p    and 1<=p<=2^21\\n            for(int x=0;x<=21;x++)\\n            {\\n                mp[arr[i]]--;\\n\\n                if(mp.find((1<<x)-arr[i])!=mp.end())\\n                {\\n                    count=((count%mod)+(mp[(1<<x)-arr[i]])%mod)%mod;\\n                }\\n                mp[arr[i]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int countPairs(vector<int>& arr) \\n    {\\n        unordered_map<long long int ,long long int>mp;\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]++;      //adding the frequency\\n\\n            //value  1 , 2 , 4 , 8  ------>2^21\\n            //mpx + arr[i] == p    and 1<=p<=2^21\\n            for(int x=0;x<=21;x++)\\n            {\\n                mp[arr[i]]--;\\n\\n                if(mp.find((1<<x)-arr[i])!=mp.end())\\n                {\\n                    count=((count%mod)+(mp[(1<<x)-arr[i]])%mod)%mod;\\n                }\\n                mp[arr[i]]++;\\n            }\\n        }\\n        return count%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446551,
                "title": "map",
                "content": "```\\n    int countPairs(vector<int>& a) {\\n        unordered_map<int, int> mpp;\\n        int mod = 1000000007;\\n        long long int ans =0;\\n        \\n        for(auto it : a){\\n            mpp[it]++;\\n        }\\n        for(auto x:a){\\n            for(int i=0; i<=21;i++){\\n                int z= pow(2,i);\\n                int y=z-x;\\n                if(y==x){\\n                    ans+=(mpp[y]-1);\\n                }\\n                else{\\n                    ans+=mpp[y];\\n                }\\n            }\\n        }\\n        return (ans/2)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    int countPairs(vector<int>& a) {\\n        unordered_map<int, int> mpp;\\n        int mod = 1000000007;\\n        long long int ans =0;\\n        \\n        for(auto it : a){\\n            mpp[it]++;\\n        }\\n        for(auto x:a){\\n            for(int i=0; i<=21;i++){\\n                int z= pow(2,i);\\n                int y=z-x;\\n                if(y==x){\\n                    ans+=(mpp[y]-1);\\n                }\\n                else{\\n                    ans+=mpp[y];\\n                }\\n            }\\n        }\\n        return (ans/2)%mod;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115424,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Unordered Map***\\n\\n* ***Time Complexity : O(N * constant)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long mod = 1e9 + 7;\\n    \\n    int countPairs(vector<int>& deliciousness) {\\n        \\n        int n = deliciousness.size();\\n        \\n        // store the power of 2\\'s into power array\\n        \\n        vector<long long> power;\\n        \\n        for(int i = 0; i <= 21; i++)\\n        {\\n            power.push_back(pow(2, i));\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < power.size(); j++)\\n            {\\n                int need = power[j] - deliciousness[i];\\n                \\n                if(mp.count(need))\\n                {\\n                    count =  (count % mod + mp[need] % mod) % mod;\\n                }\\n            }\\n            \\n            mp[deliciousness[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long mod = 1e9 + 7;\\n    \\n    int countPairs(vector<int>& deliciousness) {\\n        \\n        int n = deliciousness.size();\\n        \\n        // store the power of 2\\'s into power array\\n        \\n        vector<long long> power;\\n        \\n        for(int i = 0; i <= 21; i++)\\n        {\\n            power.push_back(pow(2, i));\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < power.size(); j++)\\n            {\\n                int need = power[j] - deliciousness[i];\\n                \\n                if(mp.count(need))\\n                {\\n                    count =  (count % mod + mp[need] % mod) % mod;\\n                }\\n            }\\n            \\n            mp[deliciousness[i]]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107496,
                "title": "more-like-2-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int,int> mp;\\n        int mod = 1000000007;\\n        long long res = 0;\\n        for(int d: deliciousness){\\n            \\n            for(int i = 0; i <= 21; i++){\\n                \\n                int pow = 1<<i;\\n                if(mp.find(pow-d) != mp.end())  res += mp[pow-d];\\n                    \\n            }\\n            \\n            mp[d]++;\\n            \\n        }\\n        \\n        return (int)(res%mod);\\n        \\n    }\\n};\\n```\\nDon\\'t forget to like:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int,int> mp;\\n        int mod = 1000000007;\\n        long long res = 0;\\n        for(int d: deliciousness){\\n            \\n            for(int i = 0; i <= 21; i++){\\n                \\n                int pow = 1<<i;\\n                if(mp.find(pow-d) != mp.end())  res += mp[pow-d];\\n                    \\n            }\\n            \\n            mp[d]++;\\n            \\n        }\\n        \\n        return (int)(res%mod);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050274,
                "title": "simple-and-clean-solution",
                "content": "class Solution {\\npublic:\\n  \\n    int countPairs(vector<int>& a) {\\n        long long ans=0;\\n        int n=a.size();\\n        unordered_map<int,int>mp;\\n        for(auto it:a)\\n            mp[it]++;\\n        for(int i=0;i<n;i++)\\n        {  \\n            if(mp.find(a[i])!=mp.end())\\n            {\\n                mp[a[i]]--;\\n                if(mp[a[i]]==0)\\n                    mp.erase(a[i]);\\n                for(int j=0;j<=21;j++)\\n                {\\n                    long long s=pow(2,j);\\n                    if(mp.find(s-a[i])!=mp.end())\\n                    {\\n                        ans+=mp[s-a[i]];\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        int md=1e9+7;\\n        ans%=md;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n  \\n    int countPairs(vector<int>& a) {\\n        long long ans=0;\\n        int n=a.size();\\n        unordered_map<int,int>mp;\\n        for(auto it:a)\\n            mp[it]++;\\n        for(int i=0;i<n;i++)\\n        {  \\n            if(mp.find(a[i])!=mp.end())\\n            {\\n                mp[a[i]]--;\\n                if(mp[a[i]]==0)\\n                    mp.erase(a[i]);\\n                for(int j=0;j<=21;j++)\\n                {\\n                    long long s=pow(2,j);\\n                    if(mp.find(s-a[i])!=mp.end())\\n                    {\\n                        ans+=mp[s-a[i]];\\n                        \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1829344,
                "title": "o-n-python-similar-to-2sum-hashmap",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        \\n        res1=0\\n        res2=0\\n        good_pairs = Counter(deliciousness)\\n        powers=[]\\n        for i in range(0,22):\\n            powers.append(2**i)\\n        for num in good_pairs:\\n            for power in powers:\\n                if (power-num) in good_pairs:\\n                    if((power-num)!=num):\\n                        res1=res1+good_pairs[power-num]*good_pairs[num]\\n                    if((power-num)==num and good_pairs[num]!=1):\\n                        res2=res2+math.comb(good_pairs[num],2)\\n        return int((res1/2)+res2)%(10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        \\n        res1=0\\n        res2=0\\n        good_pairs = Counter(deliciousness)\\n        powers=[]\\n        for i in range(0,22):\\n            powers.append(2**i)\\n        for num in good_pairs:\\n            for power in powers:\\n                if (power-num) in good_pairs:\\n                    if((power-num)!=num):\\n                        res1=res1+good_pairs[power-num]*good_pairs[num]\\n                    if((power-num)==num and good_pairs[num]!=1):\\n                        res2=res2+math.comb(good_pairs[num],2)\\n        return int((res1/2)+res2)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808345,
                "title": "java-100-faster-code-with-simple-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int mod = (int) 1e9 + 7;\\n        Map<Integer, Integer> dict = new LinkedHashMap<>();\\n        \\n        for (int d : deliciousness) {\\n            dict.put(d, dict.getOrDefault(d, 0) + 1);\\n        }\\n        \\n        long ans = 0;\\n        for (int key : dict.keySet()) {\\n            int val = dict.get(key);\\n            int sum = 1;\\n            for (int power = 0; power <= 21; power++) {\\n                int diff = sum - key;\\n                if (key <= diff && dict.containsKey(diff)) {\\n                    if (diff == key) {\\n                        long res = 1L * val * (val - 1) / 2 % mod;\\n                        ans += res;\\n                        ans %= mod;\\n                    } else {\\n                        int val2 = dict.get(diff);\\n                        long res = 1L * val * val2 % mod;\\n                        ans += res;\\n                        ans %= mod;\\n                    }\\n                }\\n                sum = sum * 2;\\n            }\\n        }\\n        \\n        return (int) ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int mod = (int) 1e9 + 7;\\n        Map<Integer, Integer> dict = new LinkedHashMap<>();\\n        \\n        for (int d : deliciousness) {\\n            dict.put(d, dict.getOrDefault(d, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1759632,
                "title": "python-hashmap-o-n",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        from collections import Counter\\n\\t\\t# Generate a hashmap out of all the numbers (code will run faster with lots duplicate numbers)\\n        counter = Counter(deliciousness)\\n\\t\\t# Pre-generate all possible power of two \\n        powers = [2 ** x for x in range(21, -1, -1)]\\n\\n\\t\\t# variable to hold final result\\n        res = 0\\n\\t\\t\\n\\t\\t# go through each distinct number\\n        for n in counter:\\n\\t\\t    # try all 21 possible power of 2\\n            for p in powers:\\n\\t\\t\\t    # this is borrowed from two-sum solution, we calcuate the number we need\\n\\t\\t\\t\\t# to make it p\\n                target = p - n\\n\\t\\t\\t\\t# if the target <= 0 means we don\\'t have to look at the rest of the power of 2\\n\\t\\t\\t\\t# since the power of 2 we generated is in reverse order\\n                if target <= 0:\\n                    break\\n                if n == target:\\n\\t\\t\\t\\t    # if the target is the same number, we use size * (size - 1) // 2 to calculate possible combinations\\n                    res += counter[n] * (counter[n] - 1) // 2\\n                elif target >= n:\\n\\t\\t\\t\\t    # otherwise it\\'s just a product of two counts\\n                    res += counter[n] * counter[target]\\n        return res % (10 ** 9 + 7)\\n```\\n\\n```\\nRuntime: 788 ms, faster than 93.52% of Python3 online submissions for Count Good Meals.\\nMemory Usage: 21.5 MB, less than 54.94% of Python3 online submissions for Count Good Meals.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        from collections import Counter\\n\\t\\t# Generate a hashmap out of all the numbers (code will run faster with lots duplicate numbers)\\n        counter = Counter(deliciousness)\\n\\t\\t# Pre-generate all possible power of two \\n        powers = [2 ** x for x in range(21, -1, -1)]\\n\\n\\t\\t# variable to hold final result\\n        res = 0\\n\\t\\t\\n\\t\\t# go through each distinct number\\n        for n in counter:\\n\\t\\t    # try all 21 possible power of 2\\n            for p in powers:\\n\\t\\t\\t    # this is borrowed from two-sum solution, we calcuate the number we need\\n\\t\\t\\t\\t# to make it p\\n                target = p - n\\n\\t\\t\\t\\t# if the target <= 0 means we don\\'t have to look at the rest of the power of 2\\n\\t\\t\\t\\t# since the power of 2 we generated is in reverse order\\n                if target <= 0:\\n                    break\\n                if n == target:\\n\\t\\t\\t\\t    # if the target is the same number, we use size * (size - 1) // 2 to calculate possible combinations\\n                    res += counter[n] * (counter[n] - 1) // 2\\n                elif target >= n:\\n\\t\\t\\t\\t    # otherwise it\\'s just a product of two counts\\n                    res += counter[n] * counter[target]\\n        return res % (10 ** 9 + 7)\\n```\n```\\nRuntime: 788 ms, faster than 93.52% of Python3 online submissions for Count Good Meals.\\nMemory Usage: 21.5 MB, less than 54.94% of Python3 online submissions for Count Good Meals.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739508,
                "title": "hashmap-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        long out=0;\\n        long mod=1000000007;\\n        HashMap<Integer,Integer>map=new HashMap<Integer,Integer>();\\n        for(int num:deliciousness){\\n            for(int i=0;i<31;i++){\\n                int powerof2= 1<<i;\\n                int req=powerof2-num;\\n                if(map.containsKey(req)){\\n                   out+=map.get(req); \\n                    out%=mod;\\n                }\\n            }\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        return (int)out;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        long out=0;\\n        long mod=1000000007;\\n        HashMap<Integer,Integer>map=new HashMap<Integer,Integer>();\\n        for(int num:deliciousness){\\n            for(int i=0;i<31;i++){\\n                int powerof2= 1<<i;\\n                int req=powerof2-num;\\n                if(map.containsKey(req)){\\n                   out+=map.get(req); \\n                    out%=mod;\\n                }\\n            }\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        return (int)out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696503,
                "title": "python-solution",
                "content": "Runtime: 4555 ms, faster than 10.73% of Python3 online submissions for Count Good Meals.\\nMemory Usage: 20.5 MB, less than 87.25% of Python3 online submissions for Count Good Meals.\\n\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        result = 0\\n        mapper = {}\\n        for num in deliciousness:\\n            for i in range(22): \\n                target = 2**i-num\\n                if target in mapper:\\n                    result += mapper[target]\\n            if num in mapper: \\n                mapper[num] += 1\\n            else:\\n                mapper[num] = 1\\n            \\n        return result % ((10 ** 9) + 7)",
                "solutionTags": [],
                "code": "Runtime: 4555 ms, faster than 10.73% of Python3 online submissions for Count Good Meals.\\nMemory Usage: 20.5 MB, less than 87.25% of Python3 online submissions for Count Good Meals.\\n\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        result = 0\\n        mapper = {}\\n        for num in deliciousness:\\n            for i in range(22): \\n                target = 2**i-num\\n                if target in mapper:\\n                    result += mapper[target]\\n            if num in mapper: \\n                mapper[num] += 1\\n            else:\\n                mapper[num] = 1\\n            \\n        return result % ((10 ** 9) + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 1635828,
                "title": "c-hash-map-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        long int count = 0;\\n        sort(deliciousness.begin(),deliciousness.end());\\n        int maxTwo;\\n        if(deliciousness.size()>=2)\\n            maxTwo = ceil(log2(deliciousness[deliciousness.size()-1]+deliciousness[deliciousness.size()-2]));\\n        else\\n            maxTwo = ceil(log2(deliciousness[deliciousness.size()-1]));\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<deliciousness.size();i++){\\n            int num = deliciousness[i];\\n            for(int j=0;j<=maxTwo;j++){\\n                int power = pow(2,j);\\n                int req = (power-num);\\n                if(mp.find(req)!=mp.end()){\\n                    count+=mp[req];\\n                }\\n            }\\n            mp[deliciousness[i]]++;\\n        }\\n        return count % (int)(1e9 + 7);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        long int count = 0;\\n        sort(deliciousness.begin(),deliciousness.end());\\n        int maxTwo;\\n        if(deliciousness.size()>=2)\\n            maxTwo = ceil(log2(deliciousness[deliciousness.size()-1]+deliciousness[deliciousness.size()-2]));\\n        else\\n            maxTwo = ceil(log2(deliciousness[deliciousness.size()-1]));\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<deliciousness.size();i++){\\n            int num = deliciousness[i];\\n            for(int j=0;j<=maxTwo;j++){\\n                int power = pow(2,j);\\n                int req = (power-num);\\n                if(mp.find(req)!=mp.end()){\\n                    count+=mp[req];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1399631,
                "title": "easy-python-precompute-powers-of-2",
                "content": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powersOf2=[2**i for i in range(22)]\\n        c=Counter()\\n        pairs=0\\n        for i in  deliciousness:\\n            for k in powersOf2:\\n                if k-i in c:\\n                    pairs+=c[k-i]\\n            c[i]+=1\\n        return (pairs)%1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powersOf2=[2**i for i in range(22)]\\n        c=Counter()\\n        pairs=0\\n        for i in  deliciousness:\\n            for k in powersOf2:\\n                if k-i in c:\\n                    pairs+=c[k-i]\\n            c[i]+=1\\n        return (pairs)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379143,
                "title": "o-n-log-n-solution-that-runs-faster-than-o-n-python",
                "content": "Approach is similar to one explained in most of the posts, using hashmap. The only difference is that if we sort the input, then we don\\'t have to check for all `22` powers of `2`. We only need to check for the next power of two. \\n\\nThis runs in `O(n * log n)` time, in theory due to sorting. But the `log n` factor is pretty small for `n = 10^5`, smaller than the constant factor of `22` in the `O(n)` approach.\\n\\n```\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        deliciousness.sort()\\n        counter = defaultdict(int)\\n        ways = 0\\n            \\n        for d in deliciousness:\\n            if d > 0 and d & (d-1) == 0: # d is power of two\\n                ways += counter[0] + counter[d]\\n            elif d > 0:\\n                p = abs((1 << (len(bin(d))-2)) - d) # diff to next power of two\\n                ways += counter[p]\\n            ways %= 1000000007\\n            counter[d] += 1\\n        return ways\\n```\\n\\nThis runs about 5 times faster than a few python implementations I checked from the other discussion posts. Of course, for larger values of `n` this will eventually become slower, but I believe it can hold up the speed for quite large inputs, due to fast in-built sorting implementation.\\n\\nNote: The `O(n)` solutions presented in other posts (using hashmaps) are really `O(n * log N)` where `N` is the max value in the input, which I think should be clarified, specially in the interviews. \\n\\nTaking this into account, the solution presented above is really `O(n * log n + n * log N)` since it computes the length of the binary form of the number `d` and shifts `1` by that much. It still runs `5x` faster due to the implementation of `sort()` and `bin()` may be.",
                "solutionTags": [],
                "code": "```\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        deliciousness.sort()\\n        counter = defaultdict(int)\\n        ways = 0\\n            \\n        for d in deliciousness:\\n            if d > 0 and d & (d-1) == 0: # d is power of two\\n                ways += counter[0] + counter[d]\\n            elif d > 0:\\n                p = abs((1 << (len(bin(d))-2)) - d) # diff to next power of two\\n                ways += counter[p]\\n            ways %= 1000000007\\n            counter[d] += 1\\n        return ways\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1357098,
                "title": "c-solution-2-sum-approach-two-sum-variation-easy-implementation",
                "content": "Solution - O(N)\\nIterate for every element and check whether that element can that element can be used  to make a pair sum of any power of 2 (from 2^0 to 2^21)\\nCondition: if( (2^0 to 2^21 ) - (elem_i) ) is available in array then cnt++;\\n\\nCatch : Don\\'t count the pair twice.\\n\\n```\\n    // Question asks to find pairs such that sum of both the numbers is power of two\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod= 1e9+ 7;\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n\\n        for(int x: deliciousness){\\n            for(int i=0; i<=21; i++){\\n                int z= pow(2,i);\\n                int y= z-x;\\n                if(mp.count(y)) {\\n                    ans += mp[y];\\n                    ans %= mod;\\n                }\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n```\\n\\nStep 1. Create an Unordered Map\\nStep 2. Initialise the ans=0\\nStep 3. Loop through Each Element in the vector\\nStep 4. For Each Element loot through pow(2,1) to pow(2,22) \\nStep 5. Find For the element pow(2,i) - x  in the map . If found then make add the frequency.\\nStep 6. Every time add the element of the vector into the map\\nStep7 . Return the ans with modulo\\n",
                "solutionTags": [],
                "code": "```\\n    // Question asks to find pairs such that sum of both the numbers is power of two\\n    int countPairs(vector<int>& deliciousness) {\\n        int mod= 1e9+ 7;\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n\\n        for(int x: deliciousness){\\n            for(int i=0; i<=21; i++){\\n                int z= pow(2,i);\\n                int y= z-x;\\n                if(mp.count(y)) {\\n                    ans += mp[y];\\n                    ans %= mod;\\n                }\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1340332,
                "title": "python3-o-22-n",
                "content": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        answer=0\\n        d=defaultdict(int)\\n        degrees=[2**i for i in range(22)]\\n        for delic in deliciousness:\\n            answer=answer+d[delic]\\n            for i in range(len(degrees)):    \\n                d[degrees[i]-delic]+=1\\n        return answer%1_000_000_007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        answer=0\\n        d=defaultdict(int)\\n        degrees=[2**i for i in range(22)]\\n        for delic in deliciousness:\\n            answer=answer+d[delic]\\n            for i in range(len(degrees)):    \\n                d[degrees[i]-delic]+=1\\n        return answer%1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331686,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        long count = 0;\\n        int mod = 1000000007;\\n        Arrays.sort(deliciousness);\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int i : deliciousness){\\n            map.put(i, Long.valueOf(map.getOrDefault(i, Long.valueOf(0))) + 1);\\n        }\\n        List<Integer> list = new ArrayList(map.keySet());\\n        Collections.sort(list);\\n        for(int i = 0; i < list.size(); i++){\\n            int first = list.get(i);\\n            for(int j = 0; j <= 21; j++){\\n                if(map.containsKey((int)Math.pow(2, j) - first)){\\n                    int k = (int) Math.pow(2, j) - first;\\n                    if(k == first){\\n                        long n = helper(map.get(first));\\n                        count = (count + n) % mod;\\n                    }else if(k > first){\\n                        count = (count + map.get(first) * map.get(k)) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        return (int) count;\\n    }\\n    private long helper(long n){\\n        long top = 1;\\n        long a = n;\\n        long b = n - 2;\\n        while(a > b){\\n            top *= a;\\n            a--;\\n        }\\n        return top / 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        long count = 0;\\n        int mod = 1000000007;\\n        Arrays.sort(deliciousness);\\n        Map<Integer, Long> map = new HashMap<>();\\n        for(int i : deliciousness){\\n            map.put(i, Long.valueOf(map.getOrDefault(i, Long.valueOf(0))) + 1);\\n        }\\n        List<Integer> list = new ArrayList(map.keySet());\\n        Collections.sort(list);\\n        for(int i = 0; i < list.size(); i++){\\n            int first = list.get(i);\\n            for(int j = 0; j <= 21; j++){\\n                if(map.containsKey((int)Math.pow(2, j) - first)){\\n                    int k = (int) Math.pow(2, j) - first;\\n                    if(k == first){\\n                        long n = helper(map.get(first));\\n                        count = (count + n) % mod;\\n                    }else if(k > first){\\n                        count = (count + map.get(first) * map.get(k)) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        return (int) count;\\n    }\\n    private long helper(long n){\\n        long top = 1;\\n        long a = n;\\n        long b = n - 2;\\n        while(a > b){\\n            top *= a;\\n            a--;\\n        }\\n        return top / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243239,
                "title": "c-solution-using-unordered-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int countPairs(vector<int>& del)\\n    {\\n        vector<int>v(23,0);\\n        int p=1;\\n        for(int i=0;i<=22;i++)\\n        {\\n            v[i]=p;\\n            p=p*2;\\n        }\\n        int mod=1e9+7;\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<del.size();i++)\\n        {\\n            for(auto it:v)\\n            {\\n                if(mp.find(it-del[i])!=mp.end())\\n                {\\n                    count=(count+mp[it-del[i]])%mod;\\n                }\\n            }\\n            mp[del[i]]++;\\n        }\\n        return count%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int countPairs(vector<int>& del)\\n    {\\n        vector<int>v(23,0);\\n        int p=1;\\n        for(int i=0;i<=22;i++)\\n        {\\n            v[i]=p;\\n            p=p*2;\\n        }\\n        int mod=1e9+7;\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<del.size();i++)\\n        {\\n            for(auto it:v)\\n            {\\n                if(mp.find(it-del[i])!=mp.end())\\n                {\\n                    count=(count+mp[it-del[i]])%mod;\\n                }\\n            }\\n            mp[del[i]]++;\\n        }\\n        return count%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241491,
                "title": "python3-o-n",
                "content": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        mapped = {}\\n        cnt = 0\\n        for n in deliciousness:\\n            if n in mapped:\\n                cnt += mapped[n]\\n            for i in range(22):\\n                rem = 2**i - n\\n                if rem in mapped:\\n                    mapped[rem] += 1\\n                else:\\n                    mapped[rem] = 1\\n        return cnt % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        mapped = {}\\n        cnt = 0\\n        for n in deliciousness:\\n            if n in mapped:\\n                cnt += mapped[n]\\n            for i in range(22):\\n                rem = 2**i - n\\n                if rem in mapped:\\n                    mapped[rem] += 1\\n                else:\\n                    mapped[rem] = 1\\n        return cnt % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230710,
                "title": "faster-than-97-17-memory-less-than-99-easy-intuitive-o-nlogn-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long \\n    #define v vector\\n    #define mod 1000000007\\n    long power(long long x, long long y, long long p) //x^y\\n    {\\n        int res = 1; // Initialize result\\n\\n        x = x % p; // Update x if it is more than or\\n                             // equal to p\\n\\n        if (x == 0)\\n            return 0; // In case x is divisible by p;\\n\\n        while (y > 0)\\n        {\\n            // If y is odd, multiply x with result\\n            if (y & 1)\\n                res = (res * x) % p;\\n\\n            // y must be even now\\n            y = y >> 1; // y = y/2\\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    int countPairs(vector<int>& d) {\\n        ll n=d.size();\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(ll i=0;i<=21;i++)\\n        {\\n            long long target=power(2,i,mod);\\n            ll start=0;\\n            ll end=n-1;\\n            \\n            while(start<end)\\n            {\\n                ll temp_ans=d[start]+d[end];\\n                \\n                if(temp_ans>target)\\n                {\\n                    end--;\\n                }\\n                else if(temp_ans<target)\\n                {\\n                    start++;\\n                }\\n                else \\n                {\\n                    // cout<<start<<\\' \\'<<end<<endl;\\n                    if(d[start]!=d[end])\\n                    {\\n                        ll temp=d[start];\\n                        ll c1=0;\\n                        ll c2=0;\\n                        \\n                        while(d[start]==temp)\\n                        {\\n                            c1++;\\n                            start++;\\n                        }\\n                        \\n                        temp=d[end];\\n                        \\n                        while(d[end]==temp)\\n                        {\\n                            end--;\\n                            c2++;\\n                        }\\n                        ans=(ans+(c1*c2)%mod)%mod;\\n                    }\\n                    else \\n                    {\\n                        ll c=0;\\n                        ll temp=d[start];\\n                        while(start<n&&d[start]==temp)\\n                        {\\n                            c++;\\n                            start++;\\n                        }\\n                        ans=(ans+((c)*(c-1))/2)%mod;\\n                    }\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long \\n    #define v vector\\n    #define mod 1000000007\\n    long power(long long x, long long y, long long p) //x^y\\n    {\\n        int res = 1; // Initialize result\\n\\n        x = x % p; // Update x if it is more than or\\n                             // equal to p\\n\\n        if (x == 0)\\n            return 0; // In case x is divisible by p;\\n\\n        while (y > 0)\\n        {\\n            // If y is odd, multiply x with result\\n            if (y & 1)\\n                res = (res * x) % p;\\n\\n            // y must be even now\\n            y = y >> 1; // y = y/2\\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    int countPairs(vector<int>& d) {\\n        ll n=d.size();\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(ll i=0;i<=21;i++)\\n        {\\n            long long target=power(2,i,mod);\\n            ll start=0;\\n            ll end=n-1;\\n            \\n            while(start<end)\\n            {\\n                ll temp_ans=d[start]+d[end];\\n                \\n                if(temp_ans>target)\\n                {\\n                    end--;\\n                }\\n                else if(temp_ans<target)\\n                {\\n                    start++;\\n                }\\n                else \\n                {\\n                    // cout<<start<<\\' \\'<<end<<endl;\\n                    if(d[start]!=d[end])\\n                    {\\n                        ll temp=d[start];\\n                        ll c1=0;\\n                        ll c2=0;\\n                        \\n                        while(d[start]==temp)\\n                        {\\n                            c1++;\\n                            start++;\\n                        }\\n                        \\n                        temp=d[end];\\n                        \\n                        while(d[end]==temp)\\n                        {\\n                            end--;\\n                            c2++;\\n                        }\\n                        ans=(ans+(c1*c2)%mod)%mod;\\n                    }\\n                    else \\n                    {\\n                        ll c=0;\\n                        ll temp=d[start];\\n                        while(start<n&&d[start]==temp)\\n                        {\\n                            c++;\\n                            start++;\\n                        }\\n                        ans=(ans+((c)*(c-1))/2)%mod;\\n                    }\\n                }\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1191672,
                "title": "c-no-bullshit-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& a) {\\n        map<int,int> m;\\n        int s=0;\\n        int ans=0;\\n        int mod=1000000007;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s=1;\\n            for(int j=0;j<22;j++)\\n            {\\n                \\n                ans=ans+m[s-a[i]];\\n                s=s*2;\\n            }\\n            ans=ans%mod;\\n            m[a[i]]++;\\n            \\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& a) {\\n        map<int,int> m;\\n        int s=0;\\n        int ans=0;\\n        int mod=1000000007;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s=1;\\n            for(int j=0;j<22;j++)\\n            {\\n                \\n                ans=ans+m[s-a[i]];\\n                s=s*2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1138666,
                "title": "c-hashmap-o-kn-fast-by-92",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<long long,long long> mp;\\n        long long res = 0;\\n        for(int i=0;i<deliciousness.size();i++)\\n        {\\n            mp[deliciousness[i]]++;\\n        }\\n        for(auto it = mp.begin();it!=mp.end();it++)\\n        {\\n            for(int j=0;j<=21;j++)\\n            {\\n                int num = pow(2,j);\\n                int key = num - it->first;\\n                if(key>=it->first)\\n                {\\n                    if(key==it->first)\\n                    {\\n                        long long temp = mp[key]*(mp[key]-1);\\n                        res = (res + temp/2)%1000000007;\\n                    }\\n                    else if(mp.find(key)!=mp.end())\\n                    {\\n                        long long temp = mp[key]*it->second;\\n                        res = (res+temp)%1000000007;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<long long,long long> mp;\\n        long long res = 0;\\n        for(int i=0;i<deliciousness.size();i++)\\n        {\\n            mp[deliciousness[i]]++;\\n        }\\n        for(auto it = mp.begin();it!=mp.end();it++)\\n        {\\n            for(int j=0;j<=21;j++)\\n            {\\n                int num = pow(2,j);\\n                int key = num - it->first;\\n                if(key>=it->first)\\n                {\\n                    if(key==it->first)\\n                    {\\n                        long long temp = mp[key]*(mp[key]-1);\\n                        res = (res + temp/2)%1000000007;\\n                    }\\n                    else if(mp.find(key)!=mp.end())\\n                    {\\n                        long long temp = mp[key]*it->second;\\n                        res = (res+temp)%1000000007;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118867,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        int n=d.size();\\n        int i=0,j=n-1,ans=0;\\n        unordered_map<int,int> m;\\n        int mod=1e9+7;\\n        for(auto &i: d){\\n                for(int j=0;j<=21;j++){\\n                    int p=1<<j;\\n                    if(m.find(p-i)!=m.end())\\n                        ans=(ans+m[p-i])%mod;\\n            }\\n            m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        int n=d.size();\\n        int i=0,j=n-1,ans=0;\\n        unordered_map<int,int> m;\\n        int mod=1e9+7;\\n        for(auto &i: d){\\n                for(int j=0;j<=21;j++){\\n                    int p=1<<j;\\n                    if(m.find(p-i)!=m.end())\\n                        ans=(ans+m[p-i])%mod;\\n            }\\n            m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118090,
                "title": "c-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> lookup;\\n        lookup[deliciousness[0]] = 1;\\n        int res = 0, MOD = 1e9+7;\\n        for(int i = 1; i < deliciousness.size(); ++i) {\\n            int power = 1;\\n            for(int k = 0; k < 22; ++k) {\\n                int search = power - deliciousness[i];\\n                if(search >= 0 && lookup.count(search)) {\\n                    res = (res + lookup[search]) % MOD;\\n                }\\n                power <<= 1;\\n            }\\n            lookup[deliciousness[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> lookup;\\n        lookup[deliciousness[0]] = 1;\\n        int res = 0, MOD = 1e9+7;\\n        for(int i = 1; i < deliciousness.size(); ++i) {\\n            int power = 1;\\n            for(int k = 0; k < 22; ++k) {\\n                int search = power - deliciousness[i];\\n                if(search >= 0 && lookup.count(search)) {\\n                    res = (res + lookup[search]) % MOD;\\n                }\\n                power <<= 1;\\n            }\\n            lookup[deliciousness[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103667,
                "title": "java-map-and-bit-operation-approach-comment-explained",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int result = 0;\\n        //brute force TLE\\n        // for (int i=0;i<deliciousness.length;i++){\\n        //     for (int j = i+1;j<deliciousness.length;j++){\\n        //         int sum = deliciousness[i] + deliciousness[j];\\n        //         if ((sum&(sum-1)) == 0) result++;\\n        //     }\\n        // }\\n        //\\n\\t\\t\\n        int mod = 1000000007;\\n        Map<Integer, Integer> map = new HashMap<>();    //map to store the sum\\n        for (int val : deliciousness){\\n            for (int j = 0;j <= 21;j++){ // we try to go up 2 power 21 (2 power 20 + 2 power 20)\\n                int sum = 1 << j;           //trying each of the power of 2\\n                if (sum >= val && map.containsKey(sum - val))  if the difference is there then compute the result\\n                    result = (result + map.get(sum - val)) % mod;\\n            }\\n            map.put(val, map.getOrDefault(val, 0) + 1);        \\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int result = 0;\\n        //brute force TLE\\n        // for (int i=0;i<deliciousness.length;i++){\\n        //     for (int j = i+1;j<deliciousness.length;j++){\\n        //         int sum = deliciousness[i] + deliciousness[j];\\n        //         if ((sum&(sum-1)) == 0) result++;\\n        //     }\\n        // }\\n        //\\n\\t\\t\\n        int mod = 1000000007;\\n        Map<Integer, Integer> map = new HashMap<>();    //map to store the sum\\n        for (int val : deliciousness){\\n            for (int j = 0;j <= 21;j++){ // we try to go up 2 power 21 (2 power 20 + 2 power 20)\\n                int sum = 1 << j;           //trying each of the power of 2\\n                if (sum >= val && map.containsKey(sum - val))  if the difference is there then compute the result\\n                    result = (result + map.get(sum - val)) % mod;\\n            }\\n            map.put(val, map.getOrDefault(val, 0) + 1);        \\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091021,
                "title": "c-not-fancy-but-works",
                "content": "```\\nprivate long sumPrevious(int start) {\\n\\t\\t\\t// If we have a set of 1s...  lets say 3,\\n\\t\\t\\t// then the unique combinations will be\\n\\t\\t\\t// count(3) => 2 + 1 = 3\\n\\t\\t\\t// count(4) => 3 + 2 + 1 = 6\\n\\t\\t\\tlong sum = 0;\\n\\t\\t\\tfor(int cnt = 0; cnt < start; cnt++)\\n\\t\\t\\t\\tsum += cnt;\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\tpublic int CountPairs(int[] deliciousness) {\\n\\t\\t\\t//long i = 0;\\n\\t\\t\\t//foreach(int b in deliciousness)\\n\\t\\t\\t//\\ti++;\\n\\t\\t\\t//Console.WriteLine(\"Length: \" + i);\\n\\n\\n\\t\\t\\t// index numbers and count the occurances\\n\\t\\t\\tDictionary<int, int> dicNumToOccurances = new Dictionary<int, int>();\\n\\t\\t\\tforeach(int num in deliciousness) {\\n\\t\\t\\t\\tif(!dicNumToOccurances.ContainsKey(num))\\n\\t\\t\\t\\t\\tdicNumToOccurances.Add(num, 0);\\n\\t\\t\\t\\tdicNumToOccurances[num]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// calculate all squares up to the max numbr seen\\n\\t\\t\\tHashSet<int> powersOfTwo = new HashSet<int>();\\n\\t\\t\\tfor(int cnt = 0; cnt <= 21; cnt++)\\n\\t\\t\\t\\tpowersOfTwo.Add((int) Math.Pow(2, cnt));\\n\\n\\t\\t\\t// get unique numbers\\n\\t\\t\\tint[] uniqueNumbers = new List<int>(dicNumToOccurances.Keys).ToArray();\\n\\n\\t\\t\\t// for each unique number, compare to self and all others\\n\\t\\t\\tlong count = 0;\\n\\t\\t\\tforeach(int currentNum in uniqueNumbers) {\\n\\t\\t\\t\\tforeach(int powTwo in powersOfTwo) {\\n\\t\\t\\t\\t\\tint target = powTwo - currentNum;\\n\\t\\t\\t\\t\\tif(target == currentNum)\\n\\t\\t\\t\\t\\t\\tcount += sumPrevious(dicNumToOccurances[currentNum]);\\n\\t\\t\\t\\t\\telse if(dicNumToOccurances.ContainsKey(target) && currentNum < target)\\n\\t\\t\\t\\t\\t\\tcount += dicNumToOccurances[target] * dicNumToOccurances[currentNum];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (int) (count % 1000000007);\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate long sumPrevious(int start) {\\n\\t\\t\\t// If we have a set of 1s...  lets say 3,\\n\\t\\t\\t// then the unique combinations will be\\n\\t\\t\\t// count(3) => 2 + 1 = 3\\n\\t\\t\\t// count(4) => 3 + 2 + 1 = 6\\n\\t\\t\\tlong sum = 0;\\n\\t\\t\\tfor(int cnt = 0; cnt < start; cnt++)\\n\\t\\t\\t\\tsum += cnt;\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\tpublic int CountPairs(int[] deliciousness) {\\n\\t\\t\\t//long i = 0;\\n\\t\\t\\t//foreach(int b in deliciousness)\\n\\t\\t\\t//\\ti++;\\n\\t\\t\\t//Console.WriteLine(\"Length: \" + i);\\n\\n\\n\\t\\t\\t// index numbers and count the occurances\\n\\t\\t\\tDictionary<int, int> dicNumToOccurances = new Dictionary<int, int>();\\n\\t\\t\\tforeach(int num in deliciousness) {\\n\\t\\t\\t\\tif(!dicNumToOccurances.ContainsKey(num))\\n\\t\\t\\t\\t\\tdicNumToOccurances.Add(num, 0);\\n\\t\\t\\t\\tdicNumToOccurances[num]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// calculate all squares up to the max numbr seen\\n\\t\\t\\tHashSet<int> powersOfTwo = new HashSet<int>();\\n\\t\\t\\tfor(int cnt = 0; cnt <= 21; cnt++)\\n\\t\\t\\t\\tpowersOfTwo.Add((int) Math.Pow(2, cnt));\\n\\n\\t\\t\\t// get unique numbers\\n\\t\\t\\tint[] uniqueNumbers = new List<int>(dicNumToOccurances.Keys).ToArray();\\n\\n\\t\\t\\t// for each unique number, compare to self and all others\\n\\t\\t\\tlong count = 0;\\n\\t\\t\\tforeach(int currentNum in uniqueNumbers) {\\n\\t\\t\\t\\tforeach(int powTwo in powersOfTwo) {\\n\\t\\t\\t\\t\\tint target = powTwo - currentNum;\\n\\t\\t\\t\\t\\tif(target == currentNum)\\n\\t\\t\\t\\t\\t\\tcount += sumPrevious(dicNumToOccurances[currentNum]);\\n\\t\\t\\t\\t\\telse if(dicNumToOccurances.ContainsKey(target) && currentNum < target)\\n\\t\\t\\t\\t\\t\\tcount += dicNumToOccurances[target] * dicNumToOccurances[currentNum];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (int) (count % 1000000007);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1086110,
                "title": "why-is-this-brute-force-soln-not-working",
                "content": "I wrote this soln for brute forcing and it works on the test cases, But the submission is failing. Can someone help me understand what is the problem with this code?\\n```\\ndef powerof2(self, num:int)->bool:\\n        if (num & (num-1))==0:\\n            return True\\n        else:\\n            return False\\n    \\n    def countPairs(self, de: List[int]) -> int:\\n        num=1e9+7\\n        cnt=0\\n        for i in range(len(de)):\\n            for j in range(i+1,len(de)):\\n                if i!=j and self.powerof2(de[i]+de[j]) :\\n                    print(i, j, de[i], de[j])\\n                    cnt+=1\\n                    \\n        return int(cnt%num)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef powerof2(self, num:int)->bool:\\n        if (num & (num-1))==0:\\n            return True\\n        else:\\n            return False\\n    \\n    def countPairs(self, de: List[int]) -> int:\\n        num=1e9+7\\n        cnt=0\\n        for i in range(len(de)):\\n            for j in range(i+1,len(de)):\\n                if i!=j and self.powerof2(de[i]+de[j]) :\\n                    print(i, j, de[i], de[j])\\n                    cnt+=1\\n                    \\n        return int(cnt%num)\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1080960,
                "title": "python-99-9-frequency-count-solution-o-n",
                "content": "In case of other solutions, they try to scan the target from `1` to `2^n`. I do not believe it is necessary.  \\n\\nFor each `x`, you need to find the smallest `n` such that `x < 2^n`, then check whether there is a `y = 2^n - x` in the hashmap. We do not need to consider when `n` is bigger than the smallest `n`, since that will make `y` greater than `x` and will be counted again when we are scanning the value `y`. \\n\\n```\\nfrom collections import Counter\\nimport math\\n\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        \\n        count = Counter(deliciousness)\\n        \\n        cnt = 0\\n        DIV = 10 ** 9 + 7\\n        \\n        for k in count.keys():\\n            if k == 0:\\n                continue\\n                \\n            n = math.ceil(math.log(k, 2))\\n            \\n            target = pow(2, n)\\n            # pow of two\\n            if  target == k:\\n                cnt += math.comb(count[k], 2)\\n        \\n            cnt += count[target - k ]  * count[k]\\n            cnt = cnt % DIV\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nimport math\\n\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        \\n        count = Counter(deliciousness)\\n        \\n        cnt = 0\\n        DIV = 10 ** 9 + 7\\n        \\n        for k in count.keys():\\n            if k == 0:\\n                continue\\n                \\n            n = math.ceil(math.log(k, 2))\\n            \\n            target = pow(2, n)\\n            # pow of two\\n            if  target == k:\\n                cnt += math.comb(count[k], 2)\\n        \\n            cnt += count[target - k ]  * count[k]\\n            cnt = cnt % DIV\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042395,
                "title": "c-hashmap-13-line",
                "content": "```\\n    int countPairs(vector<int>& deliciousness) {\\n        long long res = 0, mod = 1e9+7;\\n        unordered_map<int,long> cnt; \\n        for(auto x:deliciousness) cnt[x]++;\\n        vector<int> vpow = {1};\\n        for(int i=0;i<=20;i++) vpow.emplace_back(vpow.back() * 2);\\n        for(auto [x, n] : cnt){\\n            for(auto pow : vpow){\\n                int y = pow - x;\\n                if(!cnt.count(y)) continue;\\n                if(y == x) res += n*(n-1);\\n                else res += n * cnt[y];\\n            }\\n        }\\n        return res/2 % mod;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int countPairs(vector<int>& deliciousness) {\\n        long long res = 0, mod = 1e9+7;\\n        unordered_map<int,long> cnt; \\n        for(auto x:deliciousness) cnt[x]++;\\n        vector<int> vpow = {1};\\n        for(int i=0;i<=20;i++) vpow.emplace_back(vpow.back() * 2);\\n        for(auto [x, n] : cnt){\\n            for(auto pow : vpow){\\n                int y = pow - x;\\n                if(!cnt.count(y)) continue;\\n                if(y == x) res += n*(n-1);\\n                else res += n * cnt[y];\\n            }\\n        }\\n        return res/2 % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1037746,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] arr) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            int power=1;\\n            for(int j=0;j<22;j++){\\n                if(hm.containsKey(power-arr[i])){\\n                    ans+=(hm.get(power-arr[i]));\\n                    ans%=1000000007;\\n                }\\n                   power*=2;\\n            }\\n            if(hm.containsKey(arr[i]))\\n                hm.put(arr[i],hm.get(arr[i])+1);\\n            else\\n                hm.put(arr[i],1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] arr) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            int power=1;\\n            for(int j=0;j<22;j++){\\n                if(hm.containsKey(power-arr[i])){\\n                    ans+=(hm.get(power-arr[i]));\\n                    ans%=1000000007;\\n                }\\n                   power*=2;\\n            }\\n            if(hm.containsKey(arr[i]))\\n                hm.put(arr[i],hm.get(arr[i])+1);\\n            else\\n                hm.put(arr[i],1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033527,
                "title": "python-3-a-solution-like-others-with-heap-and-log",
                "content": "class Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n\\t\\n        count=0\\n        d=defaultdict(int)\\n        deliciousness=heapq.nsmallest(len(deliciousness),deliciousness)\\n        for i in range(len(deliciousness)):\\n            for j in range(int(log(2*deliciousness[i]+1,2))+1):\\n                count+=d[(1<<j)-deliciousness[i]]\\n            d[deliciousness[i]]+=1\\n        return count%((10**9) + 7)",
                "solutionTags": [],
                "code": "class Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n\\t\\n        count=0\\n        d=defaultdict(int)\\n        deliciousness=heapq.nsmallest(len(deliciousness),deliciousness)\\n        for i in range(len(deliciousness)):\\n            for j in range(int(log(2*deliciousness[i]+1,2))+1):\\n                count+=d[(1<<j)-deliciousness[i]]\\n            d[deliciousness[i]]+=1\\n        return count%((10**9) + 7)",
                "codeTag": "Java"
            },
            {
                "id": 1031544,
                "title": "python-o-n-with-comments",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        # max count for good meals\\n        max_value = 10 ** 9 + 7\\n        \\n        # Counter Dictionary -> key (deliciousness), value -> frequency\\n        d = Counter(deliciousness)\\n        \\n        # max value of deliciousness is 2^20, therefore, a good meal would have a max value of 2^21 i.e (2^20 + 2^21)\\n        twos = [2**i for i in range(22)]\\n        \\n        # number of good meals we can make\\n        ct_goodmeals = 0\\n        \\n        # all good meals\\n        goodmeals = set()\\n        \\n        for dl in d.keys():\\n            for t in twos:\\n                # complement number required to form a power of two\\n                c = t - dl\\n                \\n                if c not in d:\\n                    # only possibility is that d is a power of two\\n                    if c == 0 and (dl, dl) not in goodmeals:\\n                        goodmeals.add((dl, dl) )\\n                        # count += nc2 = n*(n-1)/2\\n                        ct_goodmeals += ( d[dl] * (d[dl] - 1) ) // 2\\n                        \\n                else:\\n                    # only possibility is that d is a power of two -> (d + d) forms the next power of two\\n                    if c == dl and (dl, dl) not in goodmeals:\\n                        goodmeals.add((dl, dl) )\\n                        # count += nc2 = n*(n-1)/2\\n                        ct_goodmeals += ( d[dl] * (d[dl] - 1) ) // 2\\n                \\n                    else:\\n                        # ordering is necessary here inordering to avoid duplication in counting\\n                        pair = (c, dl) if c < dl else (dl, c)\\n                        if pair not in goodmeals:\\n                            goodmeals.add(pair)\\n                            # since the numbers are different -> mc1 * nc1\\n                            ct_goodmeals += d[dl] * d[c]\\n        \\n        return ct_goodmeals % max_value\\n```\\n\\nTime Complexity -> O(N)\\nSpace Complexity -> O(N)",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        # max count for good meals\\n        max_value = 10 ** 9 + 7\\n        \\n        # Counter Dictionary -> key (deliciousness), value -> frequency\\n        d = Counter(deliciousness)\\n        \\n        # max value of deliciousness is 2^20, therefore, a good meal would have a max value of 2^21 i.e (2^20 + 2^21)\\n        twos = [2**i for i in range(22)]\\n        \\n        # number of good meals we can make\\n        ct_goodmeals = 0\\n        \\n        # all good meals\\n        goodmeals = set()\\n        \\n        for dl in d.keys():\\n            for t in twos:\\n                # complement number required to form a power of two\\n                c = t - dl\\n                \\n                if c not in d:\\n                    # only possibility is that d is a power of two\\n                    if c == 0 and (dl, dl) not in goodmeals:\\n                        goodmeals.add((dl, dl) )\\n                        # count += nc2 = n*(n-1)/2\\n                        ct_goodmeals += ( d[dl] * (d[dl] - 1) ) // 2\\n                        \\n                else:\\n                    # only possibility is that d is a power of two -> (d + d) forms the next power of two\\n                    if c == dl and (dl, dl) not in goodmeals:\\n                        goodmeals.add((dl, dl) )\\n                        # count += nc2 = n*(n-1)/2\\n                        ct_goodmeals += ( d[dl] * (d[dl] - 1) ) // 2\\n                \\n                    else:\\n                        # ordering is necessary here inordering to avoid duplication in counting\\n                        pair = (c, dl) if c < dl else (dl, c)\\n                        if pair not in goodmeals:\\n                            goodmeals.add(pair)\\n                            # since the numbers are different -> mc1 * nc1\\n                            ct_goodmeals += d[dl] * d[c]\\n        \\n        return ct_goodmeals % max_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001864,
                "title": "kt-js-py3-cpp-map-brute-force-search",
                "content": "**Synopsis:**\\n\\nUse a map `m` to track the frequency of each value `x` in `A`.  Then accumulate the count `cnt` of good meals to be returned via a brute-force search for `y` such that `x + y == t` where `t` is a power of 2 between [2<sup>0</sup> .. 2<sup>21</sup>] inclusive.\\n\\n---\\n\\n**Contest 222 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/484fc798-efa5-41ed-8aec-5a43c4a2a200_1609720619.4969242.png)\\n\\nhttps://www.youtube.com/watch?v=jPTjegnxYp4\\n\\n* My solution TLE\\'d because I mis-read the problem: I thought 10<sup>20</sup> was the max value for `deliciousness[i]` (but it\\'s actually 2<sup>20</sup>) \\uD83D\\uDE15\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countPairs(A: IntArray): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Int, Int>()\\n        A.forEach { x ->\\n            var t = 1\\n            while (t <= 1 shl 21) {\\n                var y = t - x\\n                if (m.contains(y))\\n                    cnt = (cnt + m[y]!!) % (1e9 + 7).toInt()\\n                t = t shl 1\\n            }\\n            m[x] = 1 + m.getOrDefault(x, 0)\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countPairs = (A, m = new Map(), cnt = 0) => {\\n    A.forEach(x => {\\n        for (let t = 1; t <= (1 << 21); t <<= 1) {\\n            let y = t - x;\\n            if (m.has(y))\\n                cnt = (cnt + m.get(y)) % (1e9 + 7);\\n        }\\n        m.set(x, 1 + (m.get(x) || 0));\\n    });\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countPairs(self, A: List[int], cnt = 0) -> int:\\n        m = {}\\n        for x in A:\\n            t = 1\\n            while t <= 1 << 21:\\n                y = t - x\\n                if y in m:\\n                    cnt = (cnt + m[y]) % int(1e9 + 7)\\n                t <<= 1\\n            m[x] = 1 + m[x] if x in m else 1\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int countPairs(VI& A, Map m = {}, int cnt = 0) {\\n        for (auto x: A) {\\n            for (auto t{ 1 }; t <= (1 << 21); t <<= 1) {\\n                auto y = t - x;\\n                if (0 <= y && m.find(y) != m.end())\\n                    cnt = (cnt + m[y]) % int(1e9 + 7);\\n            }\\n            ++m[x];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countPairs(A: IntArray): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Int, Int>()\\n        A.forEach { x ->\\n            var t = 1\\n            while (t <= 1 shl 21) {\\n                var y = t - x\\n                if (m.contains(y))\\n                    cnt = (cnt + m[y]!!) % (1e9 + 7).toInt()\\n                t = t shl 1\\n            }\\n            m[x] = 1 + m.getOrDefault(x, 0)\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countPairs = (A, m = new Map(), cnt = 0) => {\\n    A.forEach(x => {\\n        for (let t = 1; t <= (1 << 21); t <<= 1) {\\n            let y = t - x;\\n            if (m.has(y))\\n                cnt = (cnt + m.get(y)) % (1e9 + 7);\\n        }\\n        m.set(x, 1 + (m.get(x) || 0));\\n    });\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countPairs(self, A: List[int], cnt = 0) -> int:\\n        m = {}\\n        for x in A:\\n            t = 1\\n            while t <= 1 << 21:\\n                y = t - x\\n                if y in m:\\n                    cnt = (cnt + m[y]) % int(1e9 + 7)\\n                t <<= 1\\n            m[x] = 1 + m[x] if x in m else 1\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int countPairs(VI& A, Map m = {}, int cnt = 0) {\\n        for (auto x: A) {\\n            for (auto t{ 1 }; t <= (1 << 21); t <<= 1) {\\n                auto y = t - x;\\n                if (0 <= y && m.find(y) != m.end())\\n                    cnt = (cnt + m[y]) % int(1e9 + 7);\\n            }\\n            ++m[x];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001716,
                "title": "java-o-n-easy-solution-using-map",
                "content": "https://www.youtube.com/watch?v=34sx1KQoNMY\\n```\\nclass Solution {\\n    final int mod = (int)1e9+7;\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> mp = new HashMap<>();\\n        for (int d: deliciousness) {\\n            mp.put(d, mp.getOrDefault(d, 0)+1);\\n        }\\n        long res = 0;\\n        for (Map.Entry<Integer, Integer> it : mp.entrySet()) {\\n            if (it.getKey() != 0) {\\n                int power_of_two, num2 = 0, num1 = it.getKey();\\n                if ((num1&(num1-1)) != 0) {\\n                    power_of_two = (int)(Math.log(num1)/Math.log(2)) + 1;\\n                    num2 = (int)Math.pow(2, power_of_two) - num1;\\n                }\\n                int cnt = it.getValue();\\n                res += mp.getOrDefault(num2, 0) * cnt;\\n                if (num2 == 0)\\n                    res += ((long)cnt*(cnt-1))/2;\\n                res = res%mod;\\n            }\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    final int mod = (int)1e9+7;\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> mp = new HashMap<>();\\n        for (int d: deliciousness) {\\n            mp.put(d, mp.getOrDefault(d, 0)+1);\\n        }\\n        long res = 0;\\n        for (Map.Entry<Integer, Integer> it : mp.entrySet()) {\\n            if (it.getKey() != 0) {\\n                int power_of_two, num2 = 0, num1 = it.getKey();\\n                if ((num1&(num1-1)) != 0) {\\n                    power_of_two = (int)(Math.log(num1)/Math.log(2)) + 1;\\n                    num2 = (int)Math.pow(2, power_of_two) - num1;\\n                }\\n                int cnt = it.getValue();\\n                res += mp.getOrDefault(num2, 0) * cnt;\\n                if (num2 == 0)\\n                    res += ((long)cnt*(cnt-1))/2;\\n                res = res%mod;\\n            }\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000223,
                "title": "javascript-o-n-over-100",
                "content": "```\\n/**\\n * @param {number[]} deliciousness\\n * @return {number}\\n */\\nvar countPairs = function(foods) {\\n    const powers = []\\n    for (let i = 0; i <= 21; i++) {\\n        const power = 2 ** i\\n        powers.push(power)\\n    }\\n    \\n    \\n    // delness => count of delness\\n    const map = new Map()\\n    for (const food of foods.values()) {\\n        map.set(food, 1 + (map.get(food) || 0))\\n    }\\n    \\n    \\n    // count thru map\\n    const moduloMe = (10 ** 9) + 7\\n    let result = 0\\n    for (const [food, foodCount] of map.entries()) {\\n        for (let i = -1 + powers.length; i >= 0; i--) {\\n            const power = powers[i]\\n            // ensure that seekMe >= food\\n            if (power < food * 2)  break\\n            \\n            const seekMe = power - food\\n            const seekMeCount = map.get(seekMe) || 0\\n            \\n            let outcome = 0\\n            if (seekMe === food) {\\n                if (seekMeCount > 1) {\\n                    outcome = foodCount * (foodCount - 1) / 2\\n                }\\n            } else {\\n                if (seekMeCount > 0) {\\n                    outcome = foodCount * seekMeCount\\n                }\\n            }\\n            \\n            result += outcome\\n            result %= moduloMe\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} deliciousness\\n * @return {number}\\n */\\nvar countPairs = function(foods) {\\n    const powers = []\\n    for (let i = 0; i <= 21; i++) {\\n        const power = 2 ** i\\n        powers.push(power)\\n    }\\n    \\n    \\n    // delness => count of delness\\n    const map = new Map()\\n    for (const food of foods.values()) {\\n        map.set(food, 1 + (map.get(food) || 0))\\n    }\\n    \\n    \\n    // count thru map\\n    const moduloMe = (10 ** 9) + 7\\n    let result = 0\\n    for (const [food, foodCount] of map.entries()) {\\n        for (let i = -1 + powers.length; i >= 0; i--) {\\n            const power = powers[i]\\n            // ensure that seekMe >= food\\n            if (power < food * 2)  break\\n            \\n            const seekMe = power - food\\n            const seekMeCount = map.get(seekMe) || 0\\n            \\n            let outcome = 0\\n            if (seekMe === food) {\\n                if (seekMeCount > 1) {\\n                    outcome = foodCount * (foodCount - 1) / 2\\n                }\\n            } else {\\n                if (seekMeCount > 0) {\\n                    outcome = foodCount * seekMeCount\\n                }\\n            }\\n            \\n            result += outcome\\n            result %= moduloMe\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000032,
                "title": "c-hash-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> have;\\n        long long r = 0;\\n        for (int x : deliciousness) {\\n            for (int y = 1 << 21; y && y >= x; y >>= 1) {\\n                const auto t = have.find(y - x);\\n                if (t != have.end()) {\\n                    r += t->second;\\n                }\\n            }\\n            ++have[x];\\n        }\\n        return r % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> have;\\n        long long r = 0;\\n        for (int x : deliciousness) {\\n            for (int y = 1 << 21; y && y >= x; y >>= 1) {\\n                const auto t = have.find(y - x);\\n                if (t != have.end()) {\\n                    r += t->second;\\n                }\\n            }\\n            ++have[x];\\n        }\\n        return r % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999585,
                "title": "java-two-sum-approach-o-n",
                "content": "**Understand the problem**\\n1.  You need to make pairs which are powers of 2\\n2.  Generate a list of powers of 2\\n3.  Iterate each item in the arr and check if the other item in the pair exists in the map\\n4.  If found, increment the count\\n\\n```\\nclass Solution {\\n    public int countPairs(int[] arr) {\\n        List<Integer> pows = new ArrayList<>();\\n        int pow = 1;\\n        for (int i = 1; i < 32; i++) {\\n            pows.add(pow);\\n            pow = pow * 2;\\n        }\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: arr) {\\n            for (int p: pows) {\\n                int diff = p - num;\\n                if (map.containsKey(diff) && diff >= 0) {\\n                    count += map.get(diff);\\n                    count %= 1000000007;\\n                }\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] arr) {\\n        List<Integer> pows = new ArrayList<>();\\n        int pow = 1;\\n        for (int i = 1; i < 32; i++) {\\n            pows.add(pow);\\n            pow = pow * 2;\\n        }\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: arr) {\\n            for (int p: pows) {\\n                int diff = p - num;\\n                if (map.containsKey(diff) && diff >= 0) {\\n                    count += map.get(diff);\\n                    count %= 1000000007;\\n                }\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999503,
                "title": "java-map-and-arrays-43-ms",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int[] tp = new int[22];\\n        for(int i = 0, m = 1; i < tp.length; i++) {\\n            tp[i] = m;\\n            m = (m << 1);\\n        }\\n\\n        int[] d2 = new int[deliciousness.length];\\n        int l2 = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int one : deliciousness) {\\n            if(map.containsKey(one)) {\\n                map.put(one, map.get(one) + 1);\\n            } else {\\n                map.put(one, 1);\\n                d2[l2] = one;\\n                l2++;\\n            }\\n        }\\n\\n        long rV = 0;\\n\\n        for(int i1 = 0; i1 < l2; i1++) {\\n            int num1 = d2[i1];\\n            for(int i = 0; i < tp.length; i++) {\\n                int num2 = tp[i] - num1;\\n                if(num2 >= num1 && map.containsKey(num2)) {\\n                    int value1 = map.get(num1);\\n                    if (num1 == num2) {\\n                        if (value1 > 1) {\\n                            rV += getC2(value1);\\n                            rV %= 1000_000_007;\\n                        }\\n                    } else {\\n\\t\\t\\t\\t\\t\\tint value2 = map.get(num2);\\n                        rV += value1 * value2;\\n                        rV %= 1000_000_007;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (int) (rV);\\n    }\\n\\n    private long getC2(long n) {\\n        return (n * (n - 1)) / 2;\\n    }\\n\\n}\\n```\\nv2\\n```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int[] tp = new int[22];\\n        for(int i = 0, m = 1; i < tp.length; i++) {\\n            tp[i] = m;\\n            m = (m << 1);\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int one : deliciousness)\\n            map.put(one, map.getOrDefault(one, 0) + 1);\\n\\n        long rV = 0;\\n\\n        for(Map.Entry entry : map.entrySet()) {\\n            int num1 = (int) entry.getKey();\\n            for(int i = 0; i < tp.length; i++) {\\n                int num2 = tp[i] - num1;\\n                if(num2 >= num1 && map.containsKey(num2)) {\\n                    int value1 = (int) entry.getValue();\\n                    if (num1 == num2) {\\n                        if (value1 > 1) {\\n                            rV += getC2(value1);\\n                            rV %= 1000_000_007;\\n                        }\\n                    } else {\\n                        int value2 = map.get(num2);\\n                        rV += value1 * value2;\\n                        rV %= 1000_000_007;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (int) (rV);\\n    }\\n\\n    private long getC2(long n) {\\n        return (n * (n - 1)) / 2;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int[] tp = new int[22];\\n        for(int i = 0, m = 1; i < tp.length; i++) {\\n            tp[i] = m;\\n            m = (m << 1);\\n        }\\n\\n        int[] d2 = new int[deliciousness.length];\\n        int l2 = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int one : deliciousness) {\\n            if(map.containsKey(one)) {\\n                map.put(one, map.get(one) + 1);\\n            } else {\\n                map.put(one, 1);\\n                d2[l2] = one;\\n                l2++;\\n            }\\n        }\\n\\n        long rV = 0;\\n\\n        for(int i1 = 0; i1 < l2; i1++) {\\n            int num1 = d2[i1];\\n            for(int i = 0; i < tp.length; i++) {\\n                int num2 = tp[i] - num1;\\n                if(num2 >= num1 && map.containsKey(num2)) {\\n                    int value1 = map.get(num1);\\n                    if (num1 == num2) {\\n                        if (value1 > 1) {\\n                            rV += getC2(value1);\\n                            rV %= 1000_000_007;\\n                        }\\n                    } else {\\n\\t\\t\\t\\t\\t\\tint value2 = map.get(num2);\\n                        rV += value1 * value2;\\n                        rV %= 1000_000_007;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (int) (rV);\\n    }\\n\\n    private long getC2(long n) {\\n        return (n * (n - 1)) / 2;\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int[] tp = new int[22];\\n        for(int i = 0, m = 1; i < tp.length; i++) {\\n            tp[i] = m;\\n            m = (m << 1);\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int one : deliciousness)\\n            map.put(one, map.getOrDefault(one, 0) + 1);\\n\\n        long rV = 0;\\n\\n        for(Map.Entry entry : map.entrySet()) {\\n            int num1 = (int) entry.getKey();\\n            for(int i = 0; i < tp.length; i++) {\\n                int num2 = tp[i] - num1;\\n                if(num2 >= num1 && map.containsKey(num2)) {\\n                    int value1 = (int) entry.getValue();\\n                    if (num1 == num2) {\\n                        if (value1 > 1) {\\n                            rV += getC2(value1);\\n                            rV %= 1000_000_007;\\n                        }\\n                    } else {\\n                        int value2 = map.get(num2);\\n                        rV += value1 * value2;\\n                        rV %= 1000_000_007;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (int) (rV);\\n    }\\n\\n    private long getC2(long n) {\\n        return (n * (n - 1)) / 2;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999281,
                "title": "using-hashmap-o-n-java",
                "content": "Time Complexity is N*32 ~ O(N) and Space Complexity is O(N)\\n\\n```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int result = 0;\\n        int MOD=1000000007;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<deliciousness.length; i++){\\n            for(int j=0; j<32; j++){\\n                int key = (int)Math.pow(2, j);\\n                int value = key - deliciousness[i];\\n                result = (result + map.getOrDefault(value, 0))%MOD;\\n            }\\n            map.put(deliciousness[i], map.getOrDefault(deliciousness[i], 0)+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int result = 0;\\n        int MOD=1000000007;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<deliciousness.length; i++){\\n            for(int j=0; j<32; j++){\\n                int key = (int)Math.pow(2, j);\\n                int value = key - deliciousness[i];\\n                result = (result + map.getOrDefault(value, 0))%MOD;\\n            }\\n            map.put(deliciousness[i], map.getOrDefault(deliciousness[i], 0)+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999235,
                "title": "leetcode-is-not-fair-with-unordered-map-tles",
                "content": "In this problem, I used unordered_map and kept getting TLE (3 times) until I replaced it with a big array. However, now I see that unordered_map solution was accepted for some people. This only concludes one thing: **Leetcode Online Judge is not fair**. Let me add code snippets:\\n\\n**My unordered_map based solution (Time Limit Exceeded):**\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> prev;\\n        long long res = 0, mod = 1e9 + 7;\\n        for(int del : deliciousness) {\\n            for(int p = 1; p <= (1<<21); p <<= 1) {\\n                res = (res + prev[p - del]) % mod;\\n            }\\n            prev[del]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Accepted unordered_map based code:**\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<long long, long long> freq;\\n        for (auto n: deliciousness) {\\n            freq[n] ++;\\n        }\\n        long long ans = 0;\\n        int mod = 1e9+7;\\n        for (auto& kv: freq) {\\n            int a = kv.first;\\n            for (int i = 1; i <= 1<<21; i *= 2) {\\n                int b = i - a;\\n                if (freq.count(b) == 0) continue;\\n                if (b > a) {\\n                    ans += kv.second * freq[b];\\n                    ans = ans % mod;\\n                } else if (b == a) {\\n                    ans += kv.second * (kv.second-1)/2;\\n                    ans = ans % mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**My vector based accepted solution:**\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int MAXN = (1 << 20) + 1;\\n        vector<int> count(MAXN, 0);\\n        long long res = 0, mod = 1e9 + 7;\\n        for(int del : deliciousness) {\\n            for(int p = 1; p <= (1<<21); p <<= 1) {\\n                int x = p - del;\\n                if(x >= 0 && x < MAXN) res = (res + count[x]) % mod;\\n            }\\n            count[del]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n@Leetcode @moderator @awice please look into this.\\nGuys, how to notify Leetcode moderators about this?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> prev;\\n        long long res = 0, mod = 1e9 + 7;\\n        for(int del : deliciousness) {\\n            for(int p = 1; p <= (1<<21); p <<= 1) {\\n                res = (res + prev[p - del]) % mod;\\n            }\\n            prev[del]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        unordered_map<long long, long long> freq;\\n        for (auto n: deliciousness) {\\n            freq[n] ++;\\n        }\\n        long long ans = 0;\\n        int mod = 1e9+7;\\n        for (auto& kv: freq) {\\n            int a = kv.first;\\n            for (int i = 1; i <= 1<<21; i *= 2) {\\n                int b = i - a;\\n                if (freq.count(b) == 0) continue;\\n                if (b > a) {\\n                    ans += kv.second * freq[b];\\n                    ans = ans % mod;\\n                } else if (b == a) {\\n                    ans += kv.second * (kv.second-1)/2;\\n                    ans = ans % mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int MAXN = (1 << 20) + 1;\\n        vector<int> count(MAXN, 0);\\n        long long res = 0, mod = 1e9 + 7;\\n        for(int del : deliciousness) {\\n            for(int p = 1; p <= (1<<21); p <<= 1) {\\n                int x = p - del;\\n                if(x >= 0 && x < MAXN) res = (res + count[x]) % mod;\\n            }\\n            count[del]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999231,
                "title": "python-3-using-counter",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        c = Counter(deliciousness)\\n        possible_sum = [2**i for i in range(21, -1, -1)]\\n        result = 0\\n\\t\\t# k is the number, v1 is the number of appearance in deliciousness\\n        for k, v1 in c.items():\\n            for p in possible_sum:\\n\\t\\t\\t\\t# don\\'t check for sums less than k *2, saves half os the checks\\n                if p < k * 2:\\n                    break\\n                v2 = c.get(p - k, 0)\\n\\t\\t\\t\\t# if it is the same number, N_combination is v1 * (v1 - 1)\\n                if p - k == k:\\n                    result += v1 * (v1 - 1) // 2\\n\\t\\t\\t\\t# otherwise, N_combination is just the product\\n                else:\\n                    result += v1 * v2\\n        return int(result % (1000000007))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        c = Counter(deliciousness)\\n        possible_sum = [2**i for i in range(21, -1, -1)]\\n        result = 0\\n\\t\\t# k is the number, v1 is the number of appearance in deliciousness\\n        for k, v1 in c.items():\\n            for p in possible_sum:\\n\\t\\t\\t\\t# don\\'t check for sums less than k *2, saves half os the checks\\n                if p < k * 2:\\n                    break\\n                v2 = c.get(p - k, 0)\\n\\t\\t\\t\\t# if it is the same number, N_combination is v1 * (v1 - 1)\\n                if p - k == k:\\n                    result += v1 * (v1 - 1) // 2\\n\\t\\t\\t\\t# otherwise, N_combination is just the product\\n                else:\\n                    result += v1 * v2\\n        return int(result % (1000000007))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999207,
                "title": "why-my-c-code-give-tle-65-69-passed",
                "content": "```\\n#define md 1000000007\\nclass Solution {\\npublic:\\n    \\n    int countPairs(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        long ans=0;\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < n; i++)\\n            m[arr[i]]++;\\n        for(int j=0;j<=20;j++)\\n        {\\n            long sum=(long)pow(2,j);\\n\\n            long twice_count = 0;\\n            for (int i = 0; i < n; i++) \\n            {\\n                twice_count += m[sum - arr[i]];\\n                if (sum - arr[i] == arr[i])\\n                    twice_count--;\\n            }\\n            ans+= ((twice_count / 2)%md); \\n            ans=ans%md;\\n        }\\n        return ans%md;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define md 1000000007\\nclass Solution {\\npublic:\\n    \\n    int countPairs(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        long ans=0;\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < n; i++)\\n            m[arr[i]]++;\\n        for(int j=0;j<=20;j++)\\n        {\\n            long sum=(long)pow(2,j);\\n\\n            long twice_count = 0;\\n            for (int i = 0; i < n; i++) \\n            {\\n                twice_count += m[sum - arr[i]];\\n                if (sum - arr[i] == arr[i])\\n                    twice_count--;\\n            }\\n            ans+= ((twice_count / 2)%md); \\n            ans=ans%md;\\n        }\\n        return ans%md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999195,
                "title": "python-simplest-solution-heap-similar-to-two-sum",
                "content": "```python\\nclass Solution(object):\\n    def countPairs(self, deliciousness):\\n        hq, res, counts = [], 0, collections.Counter(deliciousness)\\n        for num, times in counts.items():\\n            heapq.heappush(hq, (-num, times))\\n        while hq:\\n            i, sumN = heapq.heappop(hq), 1\\n            while sumN <= 2 * -i[0]:\\n                candi = sumN + i[0]\\n                if candi == -i[0]:\\n                    res = res + i[1] * (i[1]-1) // 2 if i[1] >= 2 else res\\n                elif candi in counts:\\n                    res += i[1] * counts[candi]\\n                sumN *= 2\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution(object):\\n    def countPairs(self, deliciousness):\\n        hq, res, counts = [], 0, collections.Counter(deliciousness)\\n        for num, times in counts.items():\\n            heapq.heappush(hq, (-num, times))\\n        while hq:\\n            i, sumN = heapq.heappop(hq), 1\\n            while sumN <= 2 * -i[0]:\\n                candi = sumN + i[0]\\n                if candi == -i[0]:\\n                    res = res + i[1] * (i[1]-1) // 2 if i[1] >= 2 else res\\n                elif candi in counts:\\n                    res += i[1] * counts[candi]\\n                sumN *= 2\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999169,
                "title": "python-o-n-easy-solution",
                "content": "```\\nfrom collections import Counter\\nimport math \\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        poweroftwo = [1 << i for i in range(22)]\\n        d = Counter(deliciousness)\\n        finale = 0\\n        for v in d:\\n            for pot in poweroftwo:\\n                tt = (pot - v)\\n                if v == pot - v :\\n                    if d[v] >= 2:\\n                        finale += math.comb(d[v], 2)\\n                elif tt in d and v <= tt:\\n                    finale += d[v] * d[tt]\\n        return finale % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nimport math \\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        poweroftwo = [1 << i for i in range(22)]\\n        d = Counter(deliciousness)\\n        finale = 0\\n        for v in d:\\n            for pot in poweroftwo:\\n                tt = (pot - v)\\n                if v == pot - v :\\n                    if d[v] >= 2:\\n                        finale += math.comb(d[v], 2)\\n                elif tt in d and v <= tt:\\n                    finale += d[v] * d[tt]\\n        return finale % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999163,
                "title": "c-time-o-nlogn-space-o-n",
                "content": "\\n     int countPairs(vector<int>& d) {\\n        int n = d.size(), ans = 0, mod = 1e9+7;\\n        unordered_map<int, int> m; \\n        sort(d.begin(), d.end());\\n        \\n        m[d[0]]++; \\n        for (int i = 1; i<n; i++) {\\n            for (int j = 0; j<31; j++) {\\n                int key = pow(2, j) - d[i];\\n                if (key > d[i])\\n                    break;\\n                else if (m.find(key) == m.end())\\n                    continue;\\n                ans += m[key];\\n                ans %= mod;\\n            }\\n            m[d[i]]++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n     int countPairs(vector<int>& d) {\\n        int n = d.size(), ans = 0, mod = 1e9+7;\\n        unordered_map<int, int> m; \\n        sort(d.begin(), d.end());\\n        \\n        m[d[0]]++; \\n        for (int i = 1; i<n; i++) {\\n            for (int j = 0; j<31; j++) {\\n                int key = pow(2, j) - d[i];\\n                if (key > d[i])\\n                    break;\\n                else if (m.find(key) == m.end())\\n                    continue;\\n                ans += m[key];\\n                ans %= mod;\\n            }\\n            m[d[i]]++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 999161,
                "title": "python-using-dict",
                "content": "```\\ndef countPairs(self, deliciousness: List[int]) -> int:\\n\\td = {}\\n\\tdeliciousness.sort()\\n\\twant_list = [1]\\n\\tlimit = deliciousness[-1] + deliciousness[-2]\\n\\tx = 2\\n\\twhile x <= limit:\\n\\t\\twant_list.append(x)\\n\\t\\tx = x*2\\n\\n\\n\\tfor i, item in enumerate(deliciousness):\\n\\t\\tif item not in d:\\n\\t\\t\\td[item] = []\\n\\t\\td[item].append(i)\\n\\n\\tans = 0\\n\\tfor key, val in d.items():\\n\\t\\treq_list = [i-key for i in want_list]\\n\\t\\tfor i in req_list:\\n\\t\\t\\tif i == key:\\n\\t\\t\\t\\tans += len(val)*(len(val) - 1)\\n\\t\\t\\telif i in d:\\n\\t\\t\\t\\tans += len(val)*len(d[i])\\n\\n\\treturn int(ans//2)%(1000000007)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countPairs(self, deliciousness: List[int]) -> int:\\n\\td = {}\\n\\tdeliciousness.sort()\\n\\twant_list = [1]\\n\\tlimit = deliciousness[-1] + deliciousness[-2]\\n\\tx = 2\\n\\twhile x <= limit:\\n\\t\\twant_list.append(x)\\n\\t\\tx = x*2\\n\\n\\n\\tfor i, item in enumerate(deliciousness):\\n\\t\\tif item not in d:\\n\\t\\t\\td[item] = []\\n\\t\\td[item].append(i)\\n\\n\\tans = 0\\n\\tfor key, val in d.items():\\n\\t\\treq_list = [i-key for i in want_list]\\n\\t\\tfor i in req_list:\\n\\t\\t\\tif i == key:\\n\\t\\t\\t\\tans += len(val)*(len(val) - 1)\\n\\t\\t\\telif i in d:\\n\\t\\t\\t\\tans += len(val)*len(d[i])\\n\\n\\treturn int(ans//2)%(1000000007)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4079129,
                "title": "simple-python-code-beated-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        deliciousness_group_by = Counter(deliciousness)\\n        upper_bound = 22\\n        power2 = [(1 << i) for i in range(upper_bound)]\\n        ans = 0\\n        for delicious in deliciousness_group_by:\\n            left_index = bisect_left(power2, delicious)\\n            for index in range(left_index, upper_bound):\\n                left_over = power2[index] - delicious\\n                if left_over not in deliciousness_group_by:\\n                    continue\\n                ans += deliciousness_group_by[delicious] * deliciousness_group_by[left_over] - (deliciousness_group_by[delicious] if delicious == left_over else 0)\\n        return (ans >> 1) % 100000000\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        deliciousness_group_by = Counter(deliciousness)\\n        upper_bound = 22\\n        power2 = [(1 << i) for i in range(upper_bound)]\\n        ans = 0\\n        for delicious in deliciousness_group_by:\\n            left_index = bisect_left(power2, delicious)\\n            for index in range(left_index, upper_bound):\\n                left_over = power2[index] - delicious\\n                if left_over not in deliciousness_group_by:\\n                    continue\\n                ans += deliciousness_group_by[delicious] * deliciousness_group_by[left_over] - (deliciousness_group_by[delicious] if delicious == left_over else 0)\\n        return (ans >> 1) % 100000000\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077334,
                "title": "python-5-lines-variation-of-2-sum",
                "content": "# Intuition\\nSame idea as in hash table based 2 sum. Difference is, here one needs to find previously seen value that sum up to some power of 2, To speed up power of 2 match, precompute powers of 2.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        occ, mod, result, powers = Counter(), 1_000_000_007, 0, [2**i for i in range(24)]\\n        for v in deliciousness:\\n            for p in powers: result = (result + occ[p-v]) % mod\\n            occ[v] += 1\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        occ, mod, result, powers = Counter(), 1_000_000_007, 0, [2**i for i in range(24)]\\n        for v in deliciousness:\\n            for p in powers: result = (result + occ[p-v]) % mod\\n            occ[v] += 1\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002544,
                "title": "c-implementation-using-bit-manupulation-and-hashing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst int MOD=1e9+7;\\n    int mul(int a,int b){\\n        a=a%MOD;\\n        b=b%MOD;\\n        a=(a*b)%MOD;\\n        return a;\\n    }\\n    long long countPairs(vector<int>& deliciousness) {\\n        long long  ans=0;\\n        map<long long,long long>mp;\\n\\n        for(auto x:deliciousness)\\n        {\\n            mp[x]++;\\n        }\\n        set<pair<int,int>>st;\\n        vector<int>nums;\\n        for(auto x:mp){\\n            int num=x.first;\\n            nums.push_back(num);\\n        }\\n        // mp[0]++;\\n        for(auto x:nums){\\n            int num=x;\\n            for(int j=0;j<25;j++){\\n                int diff=(1<<j) - num;\\n                if(diff>=0 && st.find({num,diff})==st.end()){\\n                    if(num==diff){\\n                        ans+=(mp[num]*(mp[num]-1)/2)  %MOD;\\n                    }\\n                    else{\\n                        ans+=(mp[num]*mp[diff]) %MOD;\\n                    }\\n                    st.insert({num,diff});\\n                    st.insert({diff,num});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst int MOD=1e9+7;\\n    int mul(int a,int b){\\n        a=a%MOD;\\n        b=b%MOD;\\n        a=(a*b)%MOD;\\n        return a;\\n    }\\n    long long countPairs(vector<int>& deliciousness) {\\n        long long  ans=0;\\n        map<long long,long long>mp;\\n\\n        for(auto x:deliciousness)\\n        {\\n            mp[x]++;\\n        }\\n        set<pair<int,int>>st;\\n        vector<int>nums;\\n        for(auto x:mp){\\n            int num=x.first;\\n            nums.push_back(num);\\n        }\\n        // mp[0]++;\\n        for(auto x:nums){\\n            int num=x;\\n            for(int j=0;j<25;j++){\\n                int diff=(1<<j) - num;\\n                if(diff>=0 && st.find({num,diff})==st.end()){\\n                    if(num==diff){\\n                        ans+=(mp[num]*(mp[num]-1)/2)  %MOD;\\n                    }\\n                    else{\\n                        ans+=(mp[num]*mp[diff]) %MOD;\\n                    }\\n                    st.insert({num,diff});\\n                    st.insert({diff,num});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982453,
                "title": "python-very-simple",
                "content": "# Intuition / Approach\\nLike two sum, iterate though the ints and keep a hash map of old ints to check if current int will sum with previous int to equal a target.Iterate through the targets which are possible powers of 2 to sum up matches for each of the ints.\\n\\n# Complexity\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        ans = 0; m={}\\n        for d in deliciousness:\\n            for i in range(22): ans += m.get(math.pow(2,i)-d, 0)\\n            m[d]=m.get(d,0)+1\\n        return int(ans % (7+1e9))\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        ans = 0; m={}\\n        for d in deliciousness:\\n            for i in range(22): ans += m.get(math.pow(2,i)-d, 0)\\n            m[d]=m.get(d,0)+1\\n        return int(ans % (7+1e9))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950425,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] del) {\\n        int n = del.length;\\n        //  Arrays.sort(del);\\n        int[] pow = new int[(1 << 22) + 1];\\n        int res = 0, mod = 1000_000_000 + 7;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 23; j++) {\\n                if ((1 << j) - del[i] >= 0) {\\n                    res = (res % mod + (pow[(1 << j) - del[i]]) % mod) % mod;\\n                }\\n            }\\n            pow[del[i]]++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] del) {\\n        int n = del.length;\\n        //  Arrays.sort(del);\\n        int[] pow = new int[(1 << 22) + 1];\\n        int res = 0, mod = 1000_000_000 + 7;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 23; j++) {\\n                if ((1 << j) - del[i] >= 0) {\\n                    res = (res % mod + (pow[(1 << j) - del[i]]) % mod) % mod;\\n                }\\n            }\\n            pow[del[i]]++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938584,
                "title": "how-much-is-this-different-from-2sum-hashtable-runnig-up-to-22-times",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        deliciousness.sort()\\n        res = 0\\n        for i in range(22):\\n            target = 2**i\\n            if max(deliciousness)*2 < target: break \\n            freq = {}\\n            for a in deliciousness:\\n                if a > target:\\n                    break\\n                if target - a in freq:\\n                    res += freq[target-a]\\n                if a not in freq:\\n                    freq[a] = 0\\n                freq[a] += 1\\n        return res % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        deliciousness.sort()\\n        res = 0\\n        for i in range(22):\\n            target = 2**i\\n            if max(deliciousness)*2 < target: break \\n            freq = {}\\n            for a in deliciousness:\\n                if a > target:\\n                    break\\n                if target - a in freq:\\n                    res += freq[target-a]\\n                if a not in freq:\\n                    freq[a] = 0\\n                freq[a] += 1\\n        return res % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927641,
                "title": "very-simple-solution-like-leetcode-1-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        # devide the result by modulo in the question \\n        ct=0\\n        my_dict={}\\n        for i in range(len(deliciousness)):\\n            for n in range(22):\\n                b=2**n - deliciousness[i]\\n                if b in my_dict:\\n                    ct+=my_dict[b]\\n            my_dict[deliciousness[i]]=1+my_dict.get(deliciousness[i],0)\\n\\n        return ct%(10**9+7) # devide the result by modulo in the question \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        # devide the result by modulo in the question \\n        ct=0\\n        my_dict={}\\n        for i in range(len(deliciousness)):\\n            for n in range(22):\\n                b=2**n - deliciousness[i]\\n                if b in my_dict:\\n                    ct+=my_dict[b]\\n            my_dict[deliciousness[i]]=1+my_dict.get(deliciousness[i],0)\\n\\n        return ct%(10**9+7) # devide the result by modulo in the question \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875811,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] arr) {\\n        int n = arr.length;\\n\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n        long ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            int pow = 1;\\n            for(int j=0; j<22; j++){\\n                if(hp.containsKey(pow-arr[i])){\\n                    ans+=hp.get(pow-arr[i]);\\n                    ans%=1000000007;\\n                }\\n                pow*=2;\\n            }\\n            if(hp.containsKey(arr[i])) hp.put(arr[i],hp.get(arr[i])+1);\\n            else hp.put(arr[i],1);\\n        }\\n\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] arr) {\\n        int n = arr.length;\\n\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n        long ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            int pow = 1;\\n            for(int j=0; j<22; j++){\\n                if(hp.containsKey(pow-arr[i])){\\n                    ans+=hp.get(pow-arr[i]);\\n                    ans%=1000000007;\\n                }\\n                pow*=2;\\n            }\\n            if(hp.containsKey(arr[i])) hp.put(arr[i],hp.get(arr[i])+1);\\n            else hp.put(arr[i],1);\\n        }\\n\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868938,
                "title": "python3-ez",
                "content": "\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        c = Counter(deliciousness)\\n        d = set(deliciousness)\\n        tot = 0\\n        for e in d:\\n            for i in range(22):\\n                if e == 2**i-e:\\n                    tot+=2*((c[e]*(c[e]-1))//2)\\n                else:\\n                    tot+= c[e]*c[2**i-e]\\n\\n        return (tot//2)%1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        c = Counter(deliciousness)\\n        d = set(deliciousness)\\n        tot = 0\\n        for e in d:\\n            for i in range(22):\\n                if e == 2**i-e:\\n                    tot+=2*((c[e]*(c[e]-1))//2)\\n                else:\\n                    tot+= c[e]*c[2**i-e]\\n\\n        return (tot//2)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859416,
                "title": "best-solution-easiest-solution-simple-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst I have stored the power of 2 in a vector array named as `value` and then for each value of `nums[i]` we are searching the `value[j]-nums[i]` and if it is present in the initial array,We add that number of times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(32*n*logn) = O(n*logn)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        vector<int>value;\\n        int p=1;\\n        for(int i=0;i<22;i++){\\n            value.push_back(p);\\n            p*=2;\\n        }\\n        int count = 0 ;\\n        for(int i=0;i<nums.size();i++){\\n            int s = nums[i];\\n            int k;\\n            for(int j=0;j<22;j++){\\n                int ll = value[j]-s;\\n                if(mp.find(ll) != mp.end()){\\n                    count += mp[ll];\\n                    count%=int(1e9+7);\\n                }\\n            }\\n            mp[nums[i]]++;\\n        }\\n        return count%int(1e9+7);\\n    }\\n};\\n```\\n\\nIf you like \\uD83D\\uDC4D this solution do upvote \\u2B06\\uFE0F and if there is any improvement or suggestion do mention it in the comment section \\uD83D\\uDE0A.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        vector<int>value;\\n        int p=1;\\n        for(int i=0;i<22;i++){\\n            value.push_back(p);\\n            p*=2;\\n        }\\n        int count = 0 ;\\n        for(int i=0;i<nums.size();i++){\\n            int s = nums[i];\\n            int k;\\n            for(int j=0;j<22;j++){\\n                int ll = value[j]-s;\\n                if(mp.find(ll) != mp.end()){\\n                    count += mp[ll];\\n                    count%=int(1e9+7);\\n                }\\n            }\\n            mp[nums[i]]++;\\n        }\\n        return count%int(1e9+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804666,
                "title": "beats-100-ruby-easy-to-understand-1711-count-good-meals",
                "content": "# Approach\\n- Hash\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(22\\u2217N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[]} deliciousness\\n# @return {Integer}\\ndef count_pairs(deliciousness)\\n    hash_d={}\\n    count=0\\n    for i in deliciousness\\n        hash_d[i]=0 if hash_d.length==0\\n        for j in (0...22)\\n            if hash_d[(2**j)-i]\\n                count += hash_d[(2**j)-i]\\n            end\\n        end\\n        if hash_d[i] || hash_d[i]==0\\n            hash_d[i]+=1\\n        else\\n            hash_d[i]=1\\n        end\\n    end\\n    return count % ((10**9)+7)\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Hash Table",
                    "Math",
                    "String",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\n# @param {Integer[]} deliciousness\\n# @return {Integer}\\ndef count_pairs(deliciousness)\\n    hash_d={}\\n    count=0\\n    for i in deliciousness\\n        hash_d[i]=0 if hash_d.length==0\\n        for j in (0...22)\\n            if hash_d[(2**j)-i]\\n                count += hash_d[(2**j)-i]\\n            end\\n        end\\n        if hash_d[i] || hash_d[i]==0\\n            hash_d[i]+=1\\n        else\\n            hash_d[i]=1\\n        end\\n    end\\n    return count % ((10**9)+7)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3802015,
                "title": "math-solution-with-explanation-in-comments-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        nums = {}\\n        max1, max2 = 0, 0\\n\\n        for i in deliciousness:\\n            if i not in nums:\\n                nums[i] = 0\\n            nums[i] += 1\\n\\n            if i > max1:\\n                max2, max1 = max1, i\\n            elif i > max2:\\n                max2 = i\\n\\n        i, p = 1, pow(2, 0)\\n        # get the max sum of the biggest 2 numbers, no need to continue once that number has been reached\\n        _max = max1 + max2\\n        keys = list(nums.keys())\\n        count = 0\\n        \\n        # for each power of 2, check all key combinations that sum up to this power and add them\\n        while p <= _max:\\n            # keep track of the keys used, if we added (1-3), do not re-add (3-1)\\n            used_keys = set()\\n            for k in range(len(keys)):\\n                key1 = keys[k]\\n                key2 = p - key1\\n                if key2 in nums and key2 not in used_keys:\\n                    if key1 != key2:\\n                        # if the sum of these two numbers is a power of 2,\\n                        # add the product of their occurrences\\n                        count += nums[key1] * nums[key2]\\n                    elif nums[key1] > 1:\\n                        # adding nCr of this number (n! / ((n-r)! r!))\\n                        # ex: [1, 1, 1] can have 3 permutations\\n                        # ex: [1, 1, 1, 1] can have 6 permutations\\n                        count += factorial(nums[key1]) // (factorial((nums[key1] - 2)) * 2)\\n\\n                used_keys.add(key1)\\n            p = pow(2, i)\\n            i += 1\\n\\n        return count % (pow(10, 9) + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        nums = {}\\n        max1, max2 = 0, 0\\n\\n        for i in deliciousness:\\n            if i not in nums:\\n                nums[i] = 0\\n            nums[i] += 1\\n\\n            if i > max1:\\n                max2, max1 = max1, i\\n            elif i > max2:\\n                max2 = i\\n\\n        i, p = 1, pow(2, 0)\\n        # get the max sum of the biggest 2 numbers, no need to continue once that number has been reached\\n        _max = max1 + max2\\n        keys = list(nums.keys())\\n        count = 0\\n        \\n        # for each power of 2, check all key combinations that sum up to this power and add them\\n        while p <= _max:\\n            # keep track of the keys used, if we added (1-3), do not re-add (3-1)\\n            used_keys = set()\\n            for k in range(len(keys)):\\n                key1 = keys[k]\\n                key2 = p - key1\\n                if key2 in nums and key2 not in used_keys:\\n                    if key1 != key2:\\n                        # if the sum of these two numbers is a power of 2,\\n                        # add the product of their occurrences\\n                        count += nums[key1] * nums[key2]\\n                    elif nums[key1] > 1:\\n                        # adding nCr of this number (n! / ((n-r)! r!))\\n                        # ex: [1, 1, 1] can have 3 permutations\\n                        # ex: [1, 1, 1, 1] can have 6 permutations\\n                        count += factorial(nums[key1]) // (factorial((nums[key1] - 2)) * 2)\\n\\n                used_keys.add(key1)\\n            p = pow(2, i)\\n            i += 1\\n\\n        return count % (pow(10, 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779874,
                "title": "count-pairs-with-given-sum",
                "content": "*deliciousness[i] <= 2^20*, so in a pair, the max sum is `2 * 2^20 = 2^21` - try all 22 possibilities \\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPairs(int[] deliciousness) \\n    {\\n        const long M = 1000000007;\\n        int ret = 0, targetSum = 1;\\n\\n        for(int k = 0; k <= 21; k++)\\n        {\\n            var d = new Dictionary<int, int>();\\n            for(int i = 0; i < deliciousness.Length; i++)\\n            {\\n                if (d.ContainsKey(targetSum - deliciousness[i]))\\n                    ret = (int)((ret + d[targetSum - deliciousness[i]]) % M);\\n                d[deliciousness[i]] = d.ContainsKey(deliciousness[i]) ? d[deliciousness[i]] + 1 : 1;\\n            }\\n\\n            targetSum *= 2;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPairs(int[] deliciousness) \\n    {\\n        const long M = 1000000007;\\n        int ret = 0, targetSum = 1;\\n\\n        for(int k = 0; k <= 21; k++)\\n        {\\n            var d = new Dictionary<int, int>();\\n            for(int i = 0; i < deliciousness.Length; i++)\\n            {\\n                if (d.ContainsKey(targetSum - deliciousness[i]))\\n                    ret = (int)((ret + d[targetSum - deliciousness[i]]) % M);\\n                d[deliciousness[i]] = d.ContainsKey(deliciousness[i]) ? d[deliciousness[i]] + 1 : 1;\\n            }\\n\\n            targetSum *= 2;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776557,
                "title": "considering-possible-22-numbers-2-0-2-21-and-pair-sum",
                "content": "# Intuition\\nConstraint ``0 <= deliciousness[i] <= 2^20``\\nThe max possible sum is ``2^20+2^20 = 2^21``. So, possible valid sum are ``[2^0,2^21]`` - 22 numbers.\\n\\n\\n# Approach\\nUse Pair sum approach to find pairs with sum ``2^i`` where i in range ``[0,21]``\\n\\n# Complexity\\n- Time complexity:\\nSorting will take ``O(nlgn)`` and ``count_pair_with_sum`` will take O(n)\\nTotal time -``O(nlgn + 22*n)=O(nlgn)``\\n\\n- Space complexity:\\n``O(n)`` as maximum keys in the map could be n if all are unique. \\n\\n# Code\\n```\\ndef countPairs(self, deliciousness: List[int]) -> int:\\n    arr = sorted(deliciousness)\\n\\n    def count_pair_with_sum(s):\\n        pairs, c = Counter(), 0\\n        for x in arr:\\n            if s - x in pairs:\\n                c += pairs[s - x]\\n            pairs[x] += 1\\n        return c % (10 ** 9 + 7)\\n\\n    return sum(count_pair_with_sum(2 ** i) for i in range(22))\\n\\n       \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countPairs(self, deliciousness: List[int]) -> int:\\n    arr = sorted(deliciousness)\\n\\n    def count_pair_with_sum(s):\\n        pairs, c = Counter(), 0\\n        for x in arr:\\n            if s - x in pairs:\\n                c += pairs[s - x]\\n            pairs[x] += 1\\n        return c % (10 ** 9 + 7)\\n\\n    return sum(count_pair_with_sum(2 ** i) for i in range(22))\\n\\n       \\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3770604,
                "title": "simple-variation-of-two-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>(); // key: num, val: ocurrence\\n        int length = deliciousness.length, answer = 0, MOD = 1000000007;\\n        for (int num : deliciousness) {\\n            int sum = 1;\\n            for (int i = 0; i <= 21; i++) {\\n                if (sum >= num && map.containsKey(sum - num)) {\\n                    answer += map.get(sum - num);\\n                    answer %= MOD;\\n                }\\n                sum *= 2;\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return (int)answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n       public int countPairs(int[] deliciousness) {\\n        Map<Integer, Integer> map = new HashMap<>(); // key: num, val: ocurrence\\n        int length = deliciousness.length, answer = 0, MOD = 1000000007;\\n        for (int num : deliciousness) {\\n            int sum = 1;\\n            for (int i = 0; i <= 21; i++) {\\n                if (sum >= num && map.containsKey(sum - num)) {\\n                    answer += map.get(sum - num);\\n                    answer %= MOD;\\n                }\\n                sum *= 2;\\n            }\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        return (int)answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737701,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        int mod=1e9+7,res=0;\\n        int ma=*max_element(d.begin(),d.end());\\n        vector<int> count(ma+1,0);\\n        int k,temp;\\n        sort(d.begin(),d.end());\\n        for(int i=0;i<d.size();i++){\\n            if(d[i]==0)k=0;\\n            else\\n             k=log2(d[i]);\\n            while(k<32){\\n                 temp=1<<k;\\n                 if(temp-d[i]>ma)break;\\n                if(temp-d[i]>=0 && count[temp-d[i]]>0)\\n                    res=(res+count[temp-d[i]])%mod,cout<<temp-d[i]<<\" \"<<d[i]<<endl;\\n                k++;\\n            }\\n            count[d[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        int mod=1e9+7,res=0;\\n        int ma=*max_element(d.begin(),d.end());\\n        vector<int> count(ma+1,0);\\n        int k,temp;\\n        sort(d.begin(),d.end());\\n        for(int i=0;i<d.size();i++){\\n            if(d[i]==0)k=0;\\n            else\\n             k=log2(d[i]);\\n            while(k<32){\\n                 temp=1<<k;\\n                 if(temp-d[i]>ma)break;\\n                if(temp-d[i]>=0 && count[temp-d[i]]>0)\\n                    res=(res+count[temp-d[i]])%mod,cout<<temp-d[i]<<\" \"<<d[i]<<endl;\\n                k++;\\n            }\\n            count[d[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3715974,
                "title": "golang-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc countPairs(deliciousness []int) int {\\n\\tpowers := []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152}\\n\\n\\tm := make(map[int]int)\\n    // put all deliciousness to map m, value is the count of that number\\n\\tfor _, num := range deliciousness {\\n\\t\\tm[num]++\\n\\t}\\n\\n\\ttotal := 0\\n    // range the map\\n\\tfor num, count := range m {\\n        // range the 22 powers from 2^0 to 2^21\\n\\t\\tfor _, power := range powers {\\n            // diff equals to the power - num, only if diff >= 0 is valid\\n\\t\\t\\tdiff := power - num\\n\\t\\t\\tif diff < 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif num == diff {\\n                // if the power was the sum of two same deliciousness numbers n, the count of ways should be A(n,n), which is count(a) * (count(a)-1)\\n                // (a,b) & (b,a) will be calculated twice\\n\\t\\t\\t\\ttotal += (count * (count - 1))\\n\\t\\t\\t} else {\\n                // if two different numbers, count should be count(a) * count(b)\\n                // if diff is not deliciousness, the map value is 0\\n\\t\\t\\t\\ttotal += count * m[diff]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    // since we calculated (a,b) & (b,a) for twice, divided 2\\n\\treturn (total / 2) % 1000000007\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPairs(deliciousness []int) int {\\n\\tpowers := []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152}\\n\\n\\tm := make(map[int]int)\\n    // put all deliciousness to map m, value is the count of that number\\n\\tfor _, num := range deliciousness {\\n\\t\\tm[num]++\\n\\t}\\n\\n\\ttotal := 0\\n    // range the map\\n\\tfor num, count := range m {\\n        // range the 22 powers from 2^0 to 2^21\\n\\t\\tfor _, power := range powers {\\n            // diff equals to the power - num, only if diff >= 0 is valid\\n\\t\\t\\tdiff := power - num\\n\\t\\t\\tif diff < 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif num == diff {\\n                // if the power was the sum of two same deliciousness numbers n, the count of ways should be A(n,n), which is count(a) * (count(a)-1)\\n                // (a,b) & (b,a) will be calculated twice\\n\\t\\t\\t\\ttotal += (count * (count - 1))\\n\\t\\t\\t} else {\\n                // if two different numbers, count should be count(a) * count(b)\\n                // if diff is not deliciousness, the map value is 0\\n\\t\\t\\t\\ttotal += count * m[diff]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    // since we calculated (a,b) & (b,a) for twice, divided 2\\n\\treturn (total / 2) % 1000000007\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689279,
                "title": "java-implementation-time-o-nlogn-space-o-n-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    private int MOD = 1_000_000_007;\\n\\n    public int countPairs(int[] deliciousness) {\\n        Arrays.sort(deliciousness);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int count = 0;\\n\\n        for (int d : deliciousness) {\\n            // Next power of two from current value\\n            int npot = (int)(Math.log(d)/Math.log(2)) + 1;\\n            int nextVal = 1 << npot;\\n\\n            int diff = nextVal - d;\\n\\n            if (map.containsKey(diff)) {\\n                count = (count + map.get(diff)) % MOD;\\n            } \\n            \\n            // If d itself is power of two, then checking for whether 0 exist before\\n            if ((d & (d-1)) == 0 && map.containsKey(0) && d != 0) {\\n                count = (count + map.get(0)) % MOD;\\n            }\\n\\n            map.put(d, map.getOrDefault(d, 0) + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    private int MOD = 1_000_000_007;\\n\\n    public int countPairs(int[] deliciousness) {\\n        Arrays.sort(deliciousness);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int count = 0;\\n\\n        for (int d : deliciousness) {\\n            // Next power of two from current value\\n            int npot = (int)(Math.log(d)/Math.log(2)) + 1;\\n            int nextVal = 1 << npot;\\n\\n            int diff = nextVal - d;\\n\\n            if (map.containsKey(diff)) {\\n                count = (count + map.get(diff)) % MOD;\\n            } \\n            \\n            // If d itself is power of two, then checking for whether 0 exist before\\n            if ((d & (d-1)) == 0 && map.containsKey(0) && d != 0) {\\n                count = (count + map.get(0)) % MOD;\\n            }\\n\\n            map.put(d, map.getOrDefault(d, 0) + 1);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668701,
                "title": "c-unordered-map-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst int mod=1e9+7;\\n\\n    int countPairs(vector<int>& del) {\\n        \\n        vector<int> power(22);\\n        for(int i=0 ;i<22 ;i++)\\n        power[i] = pow(2, i);\\n\\n        unordered_map<int, int> mp;\\n\\n        for(int i=0 ;i<del.size() ;i++)\\n        mp[del[i]]++;\\n\\n        int ans = 0;\\n        for(int i=0 ;i<del.size() ;i++){\\n            long long count = 0;\\n            int val = del[i];\\n\\n            for(int j=0 ;j<22 ;j++){\\n                long long pw = power[j];\\n\\n                int rem = pw - del[i];\\n                \\n                if(mp.find(rem)!=mp.end()){\\n                    count += mp[rem];\\n                    if(rem==del[i] && mp[rem]>0)  // to avoid duplicate like index 0 have 2 and rem value is also 2 then it take same value from index 0. For example in case -> 1, 1, 1\\n                    count--;\\n                }\\n            }\\n            ans = (ans%mod + count%mod)%mod;\\n            mp[del[i]]--;  // to avoid reverse pair like (1,7) and (7,1)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst int mod=1e9+7;\\n\\n    int countPairs(vector<int>& del) {\\n        \\n        vector<int> power(22);\\n        for(int i=0 ;i<22 ;i++)\\n        power[i] = pow(2, i);\\n\\n        unordered_map<int, int> mp;\\n\\n        for(int i=0 ;i<del.size() ;i++)\\n        mp[del[i]]++;\\n\\n        int ans = 0;\\n        for(int i=0 ;i<del.size() ;i++){\\n            long long count = 0;\\n            int val = del[i];\\n\\n            for(int j=0 ;j<22 ;j++){\\n                long long pw = power[j];\\n\\n                int rem = pw - del[i];\\n                \\n                if(mp.find(rem)!=mp.end()){\\n                    count += mp[rem];\\n                    if(rem==del[i] && mp[rem]>0)  // to avoid duplicate like index 0 have 2 and rem value is also 2 then it take same value from index 0. For example in case -> 1, 1, 1\\n                    count--;\\n                }\\n            }\\n            ans = (ans%mod + count%mod)%mod;\\n            mp[del[i]]--;  // to avoid reverse pair like (1,7) and (7,1)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652189,
                "title": "c-hash-table",
                "content": "# Intuition\\nSort the array and for each power of two look up two matching numbers using double pointers.\\n\\n# Approach\\nInsert a number of different goodies values into the hash table to make it easier to find the seconds values.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> deliciousnessMap;\\n        int max = 0;\\n        for (const int& val : deliciousness) {\\n            if (val > max) {\\n                max = val;\\n            }\\n            auto it = deliciousnessMap.find(val);\\n            if (it != deliciousnessMap.end()) {\\n                it->second++;\\n            } else {\\n                deliciousnessMap.insert({val, 1});\\n            }\\n        }\\n        long result = 0;\\n        for (int sum = 1; sum <= 2 * max; sum *= 2) {\\n            for(auto const &[key, value] : deliciousnessMap) {\\n                if (2 * key > sum) {\\n                    continue;\\n                }\\n                if (2 * key == sum) {\\n                    result += (long)value * (value - 1) / 2;\\n                } else {\\n                    auto other = deliciousnessMap.find(sum - key);\\n                    if (other != deliciousnessMap.end()) {\\n                        result += (long)value * other->second;\\n                    }\\n                }\\n            }\\n        }\\n        return result % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long countPairs(vector<int>& deliciousness) {\\n        unordered_map<int, int> deliciousnessMap;\\n        int max = 0;\\n        for (const int& val : deliciousness) {\\n            if (val > max) {\\n                max = val;\\n            }\\n            auto it = deliciousnessMap.find(val);\\n            if (it != deliciousnessMap.end()) {\\n                it->second++;\\n            } else {\\n                deliciousnessMap.insert({val, 1});\\n            }\\n        }\\n        long result = 0;\\n        for (int sum = 1; sum <= 2 * max; sum *= 2) {\\n            for(auto const &[key, value] : deliciousnessMap) {\\n                if (2 * key > sum) {\\n                    continue;\\n                }\\n                if (2 * key == sum) {\\n                    result += (long)value * (value - 1) / 2;\\n                } else {\\n                    auto other = deliciousnessMap.find(sum - key);\\n                    if (other != deliciousnessMap.end()) {\\n                        result += (long)value * other->second;\\n                    }\\n                }\\n            }\\n        }\\n        return result % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648199,
                "title": "c-o-n-log2-max-two-sum-of-arr-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        if(d.size()<2)\\n         return 0;\\n         sort(d.begin(),d.end());\\n        int ans=0;\\n        int mod=1e9+7;\\n        unordered_map<int,pair<int,int>>mp;\\n        sort(d.begin(),d.end());\\n        int i=0,cnt=1;\\n        while(i<d.size()){\\n            int st=i;\\n           while(i+1<d.size() && d[i]==d[i+1]){\\n               i++;\\n               cnt++;\\n           }\\n           mp[d[i]]={st,cnt};\\n           i++;\\n           cnt=1;\\n        }\\n        int max_sum=d[d.size()-1]+d[d.size()-2];\\n        int n=log(max_sum)/log(2);\\n        cout<<\"n-\"<<n<<\"\\\\n\";\\n        for(int i=0;i<d.size()-1;i++){\\n            for(int j=0;j<=n;j++){\\n                int num=pow(2,j)-d[i];\\n                if(num>=d[i] && mp.find(num)!=mp.end()){\\n                  if(num==d[i])\\n                   {\\n                       int x=mp[num].second-(i-mp[num].first+1);\\n                       if(x>0)\\n                        ans=(ans+x)%mod;;\\n                   }\\n                  else\\n                   ans=(ans+mp[num].second)%mod;\\n                }\\n                //cout<<d[i]<<\" -ans:\"<<ans<<\"\\\\n\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        if(d.size()<2)\\n         return 0;\\n         sort(d.begin(),d.end());\\n        int ans=0;\\n        int mod=1e9+7;\\n        unordered_map<int,pair<int,int>>mp;\\n        sort(d.begin(),d.end());\\n        int i=0,cnt=1;\\n        while(i<d.size()){\\n            int st=i;\\n           while(i+1<d.size() && d[i]==d[i+1]){\\n               i++;\\n               cnt++;\\n           }\\n           mp[d[i]]={st,cnt};\\n           i++;\\n           cnt=1;\\n        }\\n        int max_sum=d[d.size()-1]+d[d.size()-2];\\n        int n=log(max_sum)/log(2);\\n        cout<<\"n-\"<<n<<\"\\\\n\";\\n        for(int i=0;i<d.size()-1;i++){\\n            for(int j=0;j<=n;j++){\\n                int num=pow(2,j)-d[i];\\n                if(num>=d[i] && mp.find(num)!=mp.end()){\\n                  if(num==d[i])\\n                   {\\n                       int x=mp[num].second-(i-mp[num].first+1);\\n                       if(x>0)\\n                        ans=(ans+x)%mod;;\\n                   }\\n                  else\\n                   ans=(ans+mp[num].second)%mod;\\n                }\\n                //cout<<d[i]<<\" -ans:\"<<ans<<\"\\\\n\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3594641,
                "title": "javascript-easy-understandable-solution-o-n",
                "content": "# Code \\n```\\n// Though it\\'s actually O(22N) but that\\'s a constant.\\n/**\\n * @param {number[]} deliciousness\\n * @return {number}\\n */\\nvar countPairs = function(deliciousness) {\\n    let goodMeals = 0, map = new Map(), sqr;\\n    const MODULO = 10**9 + 7;\\n\\n    for(let rate of deliciousness) {\\n        for(let i = 21; i >= 0; i--) {\\n            sqr = 2**i;\\n            if(sqr - rate < 0) break;\\n            if(map.has(sqr - rate)) { // Checking if sum make a power of 2\\n                goodMeals += map.get(sqr - rate); // if yes, then add the frequency\\n            }\\n        }\\n        map.set(rate, (map.get(rate) || 0) + 1);\\n    }\\n    return goodMeals % MODULO;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Though it\\'s actually O(22N) but that\\'s a constant.\\n/**\\n * @param {number[]} deliciousness\\n * @return {number}\\n */\\nvar countPairs = function(deliciousness) {\\n    let goodMeals = 0, map = new Map(), sqr;\\n    const MODULO = 10**9 + 7;\\n\\n    for(let rate of deliciousness) {\\n        for(let i = 21; i >= 0; i--) {\\n            sqr = 2**i;\\n            if(sqr - rate < 0) break;\\n            if(map.has(sqr - rate)) { // Checking if sum make a power of 2\\n                goodMeals += map.get(sqr - rate); // if yes, then add the frequency\\n            }\\n        }\\n        map.set(rate, (map.get(rate) || 0) + 1);\\n    }\\n    return goodMeals % MODULO;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585069,
                "title": "c-solution-just-use-the-idea-from-previous-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPairs(int[] deliciousness) {\\n       Dictionary<int, int> map = new Dictionary<int, int>();\\n        int length = deliciousness.Length;\\n        int count = 0;\\n        int mod = 1000000007;\\n        \\n        foreach(var num in deliciousness)\\n        {\\n            int sum = 1;\\n            for(int i = 0; i <= 21; i++)\\n            {\\n                if(sum >= num && map.ContainsKey(sum - num))\\n                {\\n                    count += map[sum - num];\\n                    count %= mod;\\n                }\\n                sum *= 2;\\n            }\\n            map[num] = map.GetValueOrDefault(num) + 1;\\n            \\n        }\\n       \\n\\n        \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPairs(int[] deliciousness) {\\n       Dictionary<int, int> map = new Dictionary<int, int>();\\n        int length = deliciousness.Length;\\n        int count = 0;\\n        int mod = 1000000007;\\n        \\n        foreach(var num in deliciousness)\\n        {\\n            int sum = 1;\\n            for(int i = 0; i <= 21; i++)\\n            {\\n                if(sum >= num && map.ContainsKey(sum - num))\\n                {\\n                    count += map[sum - num];\\n                    count %= mod;\\n                }\\n                sum *= 2;\\n            }\\n            map[num] = map.GetValueOrDefault(num) + 1;\\n            \\n        }\\n       \\n\\n        \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576539,
                "title": "o-n-log-n",
                "content": "\\n\\n# Code\\n```\\nconst int mod = 1000000007;\\n\\nint countPairs(vector<int>& ds) {\\n    int maxVal = 0;\\n    unordered_map<int, int> m;\\n    for (auto d: ds) {\\n        ++m[d];\\n        maxVal = max(maxVal, d);\\n    }\\n\\n    long long result = 0;\\n    for (int power = 1; power <= 2 * maxVal; power = power << 1) {\\n        long long similar = 0;\\n        long long diff = 0;\\n        for (auto &p: m) {\\n            auto it = m.find(power - p.first);\\n            if (it != m.end()) {\\n                if (p.first == power - p.first) {\\n                    similar = (similar + static_cast<long long>(p.second) * (p.second - 1)/2) % mod;\\n                }\\n                else {\\n                    diff = (diff + static_cast<long long>(p.second) * it->second) % mod;\\n                }\\n            }\\n        }\\n        result = (result + similar + diff/2) % mod;\\n    }\\n    return static_cast<int>(result);\\n}\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int mod = 1000000007;\\n\\nint countPairs(vector<int>& ds) {\\n    int maxVal = 0;\\n    unordered_map<int, int> m;\\n    for (auto d: ds) {\\n        ++m[d];\\n        maxVal = max(maxVal, d);\\n    }\\n\\n    long long result = 0;\\n    for (int power = 1; power <= 2 * maxVal; power = power << 1) {\\n        long long similar = 0;\\n        long long diff = 0;\\n        for (auto &p: m) {\\n            auto it = m.find(power - p.first);\\n            if (it != m.end()) {\\n                if (p.first == power - p.first) {\\n                    similar = (similar + static_cast<long long>(p.second) * (p.second - 1)/2) % mod;\\n                }\\n                else {\\n                    diff = (diff + static_cast<long long>(p.second) * it->second) % mod;\\n                }\\n            }\\n        }\\n        result = (result + similar + diff/2) % mod;\\n    }\\n    return static_cast<int>(result);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535891,
                "title": "2-sum-approach-on-all-powers-of-2",
                "content": "# Intuition\\n2 sum approach on all powers of 2\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nstore the visited numbers in map and then apply 2 sum problem approach on each number for all powers of 2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        map<int, int> m;\\n        int n = d.size();\\n        int ans = 0;\\n        int mod = 1e9+7;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 21; j>=0; j--)\\n            {\\n                int rem = (1<<j) - d[i];\\n                if(rem<0) break;\\n                else ans = (ans+m[rem]%mod)%mod;\\n            }\\n            m[d[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        map<int, int> m;\\n        int n = d.size();\\n        int ans = 0;\\n        int mod = 1e9+7;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 21; j>=0; j--)\\n            {\\n                int rem = (1<<j) - d[i];\\n                if(rem<0) break;\\n                else ans = (ans+m[rem]%mod)%mod;\\n            }\\n            m[d[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531361,
                "title": "beats-94-in-time-and-98-in-space",
                "content": "# Intuition\\nGenerate all possible combination for a number\\n\\n# Approach\\nUse ArrayList to check for possible pairs\\n\\n# Complexity\\n- Time complexity:\\n- if sorting required\\nO(n*20) + o(nlogn)\\n\\n- Space complexity:\\nO(n*20)\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)1e9 +7;\\n    public int countPairs(int[] d) {\\n        Map<Integer, List<Integer>> hm = new HashMap<>();\\n        List<Integer> l;\\n        Arrays.sort(d);\\n        Map<Integer, Integer> h1 = new LinkedHashMap<>();\\n        for(int i = 0; i < d.length; i++) h1.put(d[i], h1.getOrDefault(d[i], 0) + 1);\\n        for(Map.Entry<Integer, Integer> m: h1.entrySet()) {\\n            l = new ArrayList<>();\\n            int k = 0, j = m.getKey(); \\n            \\n            while(1<<k <= 1<<20) {\\n                if((1<<k) - j >= j){\\n                    l.add((1<<k) - j);\\n                    //System.out.print((1<<k) - j+\" \");\\n                }\\n                k++;\\n            }   \\n            hm.put(m.getKey(), l);\\n        }\\n        //System.out.print(\"Tes\");\\n        if(h1.size() == 1) {\\n            long p1 = 0;\\n            for(int i = 0; i <= 20; i++) {\\n                if(h1.containsKey(1<<i)) {\\n                    long q = h1.get(1<<i);\\n                    p1 = q*(q-1)/2;\\n                    //System.out.print((1<<i)+\" \"+ q);\\n                    return (int)(p1%mod);\\n                }\\n            }\\n            return (int)p1;\\n        }\\n        long res = 0, tot = 0, ans = 0;\\n        for(Map.Entry<Integer, Integer> m: h1.entrySet()) {\\n            l = hm.get(m.getKey());\\n            res = m.getValue();\\n            //System.out.print(m.getKey()+\":\"+m.getValue()+\" \");\\n            tot = 0;\\n            for(int i = 0; i < l.size(); i++) {\\n                if(h1.containsKey(l.get(i))) {\\n                    long p = h1.get(l.get(i));\\n                    if((int)l.get(i) == (int)m.getKey()) {\\n                        if(res != 1) tot = res*(res-1)/2;\\n                    }else{\\n                        tot = (tot + (res*p))%mod;\\n                    }\\n                    // System.out.print(((int)l.get(i) == (int)m.getKey())+\" \"+ l.get(i)+ \" \"+ m.getKey());\\n                }\\n                \\n            }\\n            ans = (ans + tot)%mod;\\n        }\\n        return (int)ans%mod;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9 +7;\\n    public int countPairs(int[] d) {\\n        Map<Integer, List<Integer>> hm = new HashMap<>();\\n        List<Integer> l;\\n        Arrays.sort(d);\\n        Map<Integer, Integer> h1 = new LinkedHashMap<>();\\n        for(int i = 0; i < d.length; i++) h1.put(d[i], h1.getOrDefault(d[i], 0) + 1);\\n        for(Map.Entry<Integer, Integer> m: h1.entrySet()) {\\n            l = new ArrayList<>();\\n            int k = 0, j = m.getKey(); \\n            \\n            while(1<<k <= 1<<20) {\\n                if((1<<k) - j >= j){\\n                    l.add((1<<k) - j);\\n                    //System.out.print((1<<k) - j+\" \");\\n                }\\n                k++;\\n            }   \\n            hm.put(m.getKey(), l);\\n        }\\n        //System.out.print(\"Tes\");\\n        if(h1.size() == 1) {\\n            long p1 = 0;\\n            for(int i = 0; i <= 20; i++) {\\n                if(h1.containsKey(1<<i)) {\\n                    long q = h1.get(1<<i);\\n                    p1 = q*(q-1)/2;\\n                    //System.out.print((1<<i)+\" \"+ q);\\n                    return (int)(p1%mod);\\n                }\\n            }\\n            return (int)p1;\\n        }\\n        long res = 0, tot = 0, ans = 0;\\n        for(Map.Entry<Integer, Integer> m: h1.entrySet()) {\\n            l = hm.get(m.getKey());\\n            res = m.getValue();\\n            //System.out.print(m.getKey()+\":\"+m.getValue()+\" \");\\n            tot = 0;\\n            for(int i = 0; i < l.size(); i++) {\\n                if(h1.containsKey(l.get(i))) {\\n                    long p = h1.get(l.get(i));\\n                    if((int)l.get(i) == (int)m.getKey()) {\\n                        if(res != 1) tot = res*(res-1)/2;\\n                    }else{\\n                        tot = (tot + (res*p))%mod;\\n                    }\\n                    // System.out.print(((int)l.get(i) == (int)m.getKey())+\" \"+ l.get(i)+ \" \"+ m.getKey());\\n                }\\n                \\n            }\\n            ans = (ans + tot)%mod;\\n        }\\n        return (int)ans%mod;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510821,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countPairs(self, deliciousness):\\n        \"\"\"\\n        :type deliciousness: List[int]\\n        :rtype: int\\n        \"\"\"\\n        counter = collections.Counter(deliciousness)\\n        powers_of_two = [2 ** i for i in range(22)]\\n\\n        ans = 0\\n        for k, v in counter.items():\\n            for power in powers_of_two:\\n                a = power - k\\n                if a in counter:\\n                    if k == a:\\n                        ans += v * (v - 1)\\n                    else:\\n                        ans += v * counter[a]\\n\\n        return ans // 2 % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPairs(self, deliciousness):\\n        \"\"\"\\n        :type deliciousness: List[int]\\n        :rtype: int\\n        \"\"\"\\n        counter = collections.Counter(deliciousness)\\n        powers_of_two = [2 ** i for i in range(22)]\\n\\n        ans = 0\\n        for k, v in counter.items():\\n            for power in powers_of_two:\\n                a = power - k\\n                if a in counter:\\n                    if k == a:\\n                        ans += v * (v - 1)\\n                    else:\\n                        ans += v * counter[a]\\n\\n        return ans // 2 % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490772,
                "title": "hashmap-sum-of-ap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        pow_2 = [1]\\n        thresh = (2**20)\\n        thresh*=2\\n        i=0\\n        x=1\\n        while x <= thresh:\\n            x*=2\\n            i+=1\\n            pow_2.append(x)\\n        ans=0\\n        delic = Counter(deliciousness)\\n\\n        for i in delic:\\n            for j in pow_2:\\n                if (j-i in delic) and ((j-i )>= i):\\n                    if ((j-i) == i): \\n                        ans+=(delic[i]*(delic[i]-1))//2\\n                    else:\\n                        ans+=delic[i]*delic[j-i]\\n        return ans % (10**9 + 7)\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        pow_2 = [1]\\n        thresh = (2**20)\\n        thresh*=2\\n        i=0\\n        x=1\\n        while x <= thresh:\\n            x*=2\\n            i+=1\\n            pow_2.append(x)\\n        ans=0\\n        delic = Counter(deliciousness)\\n\\n        for i in delic:\\n            for j in pow_2:\\n                if (j-i in delic) and ((j-i )>= i):\\n                    if ((j-i) == i): \\n                        ans+=(delic[i]*(delic[i]-1))//2\\n                    else:\\n                        ans+=delic[i]*delic[j-i]\\n        return ans % (10**9 + 7)\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461191,
                "title": "hashing",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powers,mod,ct = [],int(1e9+7),int(0)\\n        for i in range(33): powers.append(1<<i)\\n        hsh = defaultdict(int)\\n        [hsh.__setitem__(delicious,hsh[delicious]+1) for delicious in deliciousness]\\n        for delicious in deliciousness:\\n            hsh[delicious] -= 1\\n            for power in powers:\\n                req = power-delicious\\n                num = hsh[req]\\n                if num > 0: ct += num\\n            hsh[delicious] += 1\\n        return int(ct/2%mod)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        powers,mod,ct = [],int(1e9+7),int(0)\\n        for i in range(33): powers.append(1<<i)\\n        hsh = defaultdict(int)\\n        [hsh.__setitem__(delicious,hsh[delicious]+1) for delicious in deliciousness]\\n        for delicious in deliciousness:\\n            hsh[delicious] -= 1\\n            for power in powers:\\n                req = power-delicious\\n                num = hsh[req]\\n                if num > 0: ct += num\\n            hsh[delicious] += 1\\n        return int(ct/2%mod)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412358,
                "title": "easy-solution",
                "content": "\\n\\n# Approach : Using map\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogw)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* #define   mod  1e9+7\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int cnt = 0;\\n        map <int, int> mp;\\n        for(int i = 0; i < deliciousness.size(); i++){\\n            int p = 1;\\n            for(int j = 0; j < 21; j++){\\n                if(mp.find(p-deliciousness[i]) != mp.end()){\\n                    cnt += (cnt%mod);\\n                }\\n                p *= 2;\\n            }\\n            mp[deliciousness[i]]++;\\n        }\\n        return cnt;      \\n    }\\n}; */\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int cnt = 0;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < deliciousness.size(); i++) {\\n            int p = 1;\\n            for (int j = 0; j < 22; j++) {\\n                cnt = (cnt + mp[p - deliciousness[i]]) % mod;\\n                p *= 2;\\n            }\\n            mp[deliciousness[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/* #define   mod  1e9+7\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int cnt = 0;\\n        map <int, int> mp;\\n        for(int i = 0; i < deliciousness.size(); i++){\\n            int p = 1;\\n            for(int j = 0; j < 21; j++){\\n                if(mp.find(p-deliciousness[i]) != mp.end()){\\n                    cnt += (cnt%mod);\\n                }\\n                p *= 2;\\n            }\\n            mp[deliciousness[i]]++;\\n        }\\n        return cnt;      \\n    }\\n}; */\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int cnt = 0;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < deliciousness.size(); i++) {\\n            int p = 1;\\n            for (int j = 0; j < 22; j++) {\\n                cnt = (cnt + mp[p - deliciousness[i]]) % mod;\\n                p *= 2;\\n            }\\n            mp[deliciousness[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387678,
                "title": "straightforward-solution-c",
                "content": "# Approach\\nJust straightforwardly count the number of occurrences of every distinct meal deliciousness, and then calc the number of pairs that form the powers of 2 by multiplying the occurrences of each element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N * 22) == O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(std::vector<int>& data) {\\n        int modulo = 1e9 + 7;\\n        std::unordered_map<int, int> counts;\\n        long long result = 0;\\n\\n        for (auto d: data) {\\n            counts[d]++;\\n        }\\n\\n        for (const auto& it: counts) {\\n            for (int i = 1, pow2 = 1; i <= 22; i++, pow2 *= 2) {\\n                const auto& correspIt = counts.find(pow2 - it.first);\\n\\n                if (correspIt == counts.end() || it.first > correspIt->first) {\\n                    continue;\\n                }\\n\\n                if (it.first == correspIt->first) {\\n                    result += (long long)(it.second - 1) * (it.second) / 2;\\n                } else {\\n                    result += (long long)(it.second) * correspIt->second;\\n                }\\n                result %= modulo;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(std::vector<int>& data) {\\n        int modulo = 1e9 + 7;\\n        std::unordered_map<int, int> counts;\\n        long long result = 0;\\n\\n        for (auto d: data) {\\n            counts[d]++;\\n        }\\n\\n        for (const auto& it: counts) {\\n            for (int i = 1, pow2 = 1; i <= 22; i++, pow2 *= 2) {\\n                const auto& correspIt = counts.find(pow2 - it.first);\\n\\n                if (correspIt == counts.end() || it.first > correspIt->first) {\\n                    continue;\\n                }\\n\\n                if (it.first == correspIt->first) {\\n                    result += (long long)(it.second - 1) * (it.second) / 2;\\n                } else {\\n                    result += (long long)(it.second) * correspIt->second;\\n                }\\n                result %= modulo;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374806,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int countPairs(vector<int>& arr) {\\n        unordered_map<long long int,long long int>mp;\\n        long long int ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int ele=arr[i];\\n            long long int p=1;\\n            for(int j=0;j<=40;j++)\\n            {\\n                if(mp.find(p-ele)!=mp.end())\\n                {\\n                    ans=((ans%mod)+(mp[p-ele]%mod))%mod;\\n                }\\n                p=p*2;\\n            }\\n            mp[ele]++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int countPairs(vector<int>& arr) {\\n        unordered_map<long long int,long long int>mp;\\n        long long int ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            int ele=arr[i];\\n            long long int p=1;\\n            for(int j=0;j<=40;j++)\\n            {\\n                if(mp.find(p-ele)!=mp.end())\\n                {\\n                    ans=((ans%mod)+(mp[p-ele]%mod))%mod;\\n                }\\n                p=p*2;\\n            }\\n            mp[ele]++;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365003,
                "title": "simple-map-power-of-2-array-c",
                "content": "class Solution {\\npublic:\\n    int count(vector<int>nums){\\n        sort(nums.begin() , nums.end());\\n        int i = 0 ;\\n        int j = nums.size()-1;\\n        long long int cnt = 0;\\n\\t\\t\\n        unordered_map<int, int>m ;\\n        long long int mod = 1000000007;\\n\\t\\t\\n        for(auto &i : nums){ \\n          for(int j = 0 ; j<22 ; j++){\\n           long long int x = pow(2 , j);\\n           if(m.find(x - i) != m.end()){\\n                   cnt += m[x-i] ;\\n           }\\n          }\\n          m[i]++;  \\n        }\\n        return (int)(cnt%mod);\\n    } \\n    int countPairs(vector<int>& deliciousness) {\\n        ios_base::sync_with_stdio(false);\\n        return count(deliciousness) ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int count(vector<int>nums){\\n        sort(nums.begin() , nums.end());\\n        int i = 0 ;\\n        int j = nums.size()-1;\\n        long long int cnt = 0;\\n\\t\\t\\n        unordered_map<int, int>m ;\\n        long long int mod = 1000000007;\\n\\t\\t\\n        for(auto &i : nums){ \\n          for(int j = 0 ; j<22 ; j++){\\n           long long int x = pow(2 , j);\\n           if(m.find(x - i) != m.end()){\\n                   cnt += m[x-i] ;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3354742,
                "title": "c-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> m;\\n        for(auto &i:nums)\\n        m[i]++;\\n        int ans=0;\\n        for(int i=0;i<=21;i++)\\n        {\\n            int k = pow(2,i);\\n            for(auto &i:m)\\n            {\\n                int num1 = i.first;\\n                int num2 = k-num1;\\n                if(num2<num1)\\n                continue;\\n                if(m.find(num2)!=m.end())\\n                {\\n                    long long fre1 = m[num1];\\n                    long long fre2 = m[num2];\\n                    if(num1==num2)\\n                    {\\n                        if(m[num1]>1)\\n                        ans = (ans+(fre1*(fre1-1))/2)%mod;\\n                    }\\n                    else\\n                    {\\n                        ans = (ans+(fre1*fre2))%mod;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> m;\\n        for(auto &i:nums)\\n        m[i]++;\\n        int ans=0;\\n        for(int i=0;i<=21;i++)\\n        {\\n            int k = pow(2,i);\\n            for(auto &i:m)\\n            {\\n                int num1 = i.first;\\n                int num2 = k-num1;\\n                if(num2<num1)\\n                continue;\\n                if(m.find(num2)!=m.end())\\n                {\\n                    long long fre1 = m[num1];\\n                    long long fre2 = m[num2];\\n                    if(num1==num2)\\n                    {\\n                        if(m[num1]>1)\\n                        ans = (ans+(fre1*(fre1-1))/2)%mod;\\n                    }\\n                    else\\n                    {\\n                        ans = (ans+(fre1*fre2))%mod;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262671,
                "title": "java-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private long mod = (long) Math.pow(10, 9) + 7;\\n\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Long> d = initD(deliciousness);\\n        long count = 0;\\n        \\n        for (int num: d.keySet()) {\\n            \\n            for (int i = 0; i <= 21; i++) {\\n                int power = (int) Math.pow(2, i);\\n                int key = power - num;\\n                \\n                if (key == num) {\\n                    long val = d.get(key);\\n                    count += ((val - 1L) *val);\\n                }\\n\\n                else if (d.containsKey(key))\\n                    count += d.get(num) * d.get(key);\\n            }\\n        }\\n        \\n        return (int) ((count / 2) % mod);\\n    }\\n\\n    private Map<Integer, Long> initD(int[] arr) {\\n        Map<Integer, Long> d = new HashMap<>();\\n\\n        for (int num: arr)\\n            d.put(num, d.getOrDefault(num, 0L) + 1);\\n        \\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private long mod = (long) Math.pow(10, 9) + 7;\\n\\n    public int countPairs(int[] deliciousness) {\\n        Map<Integer, Long> d = initD(deliciousness);\\n        long count = 0;\\n        \\n        for (int num: d.keySet()) {\\n            \\n            for (int i = 0; i <= 21; i++) {\\n                int power = (int) Math.pow(2, i);\\n                int key = power - num;\\n                \\n                if (key == num) {\\n                    long val = d.get(key);\\n                    count += ((val - 1L) *val);\\n                }\\n\\n                else if (d.containsKey(key))\\n                    count += d.get(num) * d.get(key);\\n            }\\n        }\\n        \\n        return (int) ((count / 2) % mod);\\n    }\\n\\n    private Map<Integer, Long> initD(int[] arr) {\\n        Map<Integer, Long> d = new HashMap<>();\\n\\n        for (int num: arr)\\n            d.put(num, d.getOrDefault(num, 0L) + 1);\\n        \\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208954,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        static const int MOD = 1e9 + 7;\\n\\n        static const auto& floor_log2_x = [](int x) {\\n            return 8 * sizeof(int) - __builtin_clz(x) - 1;\\n        };\\n\\n        int max_pow = floor_log2_x(*max_element(cbegin(deliciousness), cend(deliciousness))) + 1;\\n        unordered_map<int, int> cnt;\\n        int result = 0;\\n        for (const auto& d : deliciousness) {\\n            int p = 1;\\n            for (int i = 0; i <= max_pow; ++i) {\\n                result = (result + cnt[p - d]) % MOD;\\n                p <<= 1;\\n            }\\n            ++cnt[d];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        static const int MOD = 1e9 + 7;\\n\\n        static const auto& floor_log2_x = [](int x) {\\n            return 8 * sizeof(int) - __builtin_clz(x) - 1;\\n        };\\n\\n        int max_pow = floor_log2_x(*max_element(cbegin(deliciousness), cend(deliciousness))) + 1;\\n        unordered_map<int, int> cnt;\\n        int result = 0;\\n        for (const auto& d : deliciousness) {\\n            int p = 1;\\n            for (int i = 0; i <= max_pow; ++i) {\\n                result = (result + cnt[p - d]) % MOD;\\n                p <<= 1;\\n            }\\n            ++cnt[d];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200298,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_pairs(deliciousness: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n\\n        fn get_pairs(val: i32, count: &HashMap<i32, i32>) -> i64 {\\n            let mut answer = 0_i64;\\n            for i in 0..22 {\\n                let power_of_two = i32::pow(2, i);\\n                let target = power_of_two - val;\\n                if count.contains_key(&target) {\\n                    let target_count = *count.get(&target).unwrap() as i64;\\n                    answer += if target == val { target_count - 1 } else { target_count };\\n                }\\n            }\\n            answer\\n        }\\n\\n        let mut nums_count: HashMap<i32, i32> = HashMap::new();\\n        for num in &deliciousness {\\n            let mut count = 0;\\n            if nums_count.contains_key(num) {\\n                count = *nums_count.get(num).unwrap();\\n            }\\n            count += 1;\\n            nums_count.insert(*num, count);\\n        }\\n\\n        let mut answer = 0;\\n        for num in deliciousness {\\n            answer += get_pairs(num, &nums_count);\\n        }\\n        answer /= 2;\\n        let mod_num = i64::pow(10, 9) + 7;\\n        answer %= mod_num;\\n        answer as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_pairs(deliciousness: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n\\n        fn get_pairs(val: i32, count: &HashMap<i32, i32>) -> i64 {\\n            let mut answer = 0_i64;\\n            for i in 0..22 {\\n                let power_of_two = i32::pow(2, i);\\n                let target = power_of_two - val;\\n                if count.contains_key(&target) {\\n                    let target_count = *count.get(&target).unwrap() as i64;\\n                    answer += if target == val { target_count - 1 } else { target_count };\\n                }\\n            }\\n            answer\\n        }\\n\\n        let mut nums_count: HashMap<i32, i32> = HashMap::new();\\n        for num in &deliciousness {\\n            let mut count = 0;\\n            if nums_count.contains_key(num) {\\n                count = *nums_count.get(num).unwrap();\\n            }\\n            count += 1;\\n            nums_count.insert(*num, count);\\n        }\\n\\n        let mut answer = 0;\\n        for num in deliciousness {\\n            answer += get_pairs(num, &nums_count);\\n        }\\n        answer /= 2;\\n        let mod_num = i64::pow(10, 9) + 7;\\n        answer %= mod_num;\\n        answer as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3064628,
                "title": "python-solution-using-o-nlog-n-and-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        tem={}\\n        for item in deliciousness:\\n            if(item in tem):\\n                tem[item]+=1\\n            else:\\n                tem[item]=1\\n        ans=0\\n        for item in sorted(tem):\\n            x=self.find(tem,item)\\n            ans+=x\\n            ans%=int(1e9+7)\\n        return ans\\n    def find(self,tem,val):\\n        ans=0\\n        for i in range(21,-1,-1):\\n            b=1<<i\\n            if((b-val)<val):\\n                break\\n            else:\\n                if(b-val in tem):\\n                    if(b-val!=val):\\n                        ans+=(tem[val]*tem[b-val])\\n                    else:\\n                        ans+=(tem[val]*(tem[val]-1))//2\\n                    ans%=(int(1e9+7))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        tem={}\\n        for item in deliciousness:\\n            if(item in tem):\\n                tem[item]+=1\\n            else:\\n                tem[item]=1\\n        ans=0\\n        for item in sorted(tem):\\n            x=self.find(tem,item)\\n            ans+=x\\n            ans%=int(1e9+7)\\n        return ans\\n    def find(self,tem,val):\\n        ans=0\\n        for i in range(21,-1,-1):\\n            b=1<<i\\n            if((b-val)<val):\\n                break\\n            else:\\n                if(b-val in tem):\\n                    if(b-val!=val):\\n                        ans+=(tem[val]*tem[b-val])\\n                    else:\\n                        ans+=(tem[val]*(tem[val]-1))//2\\n                    ans%=(int(1e9+7))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052352,
                "title": "c-precalculate-power-of-2-s-and-then-iterate",
                "content": "You could use a for loop to push the power\\'s of 2 instead of just hard coding numbers.\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        vector<long> p = \\n        {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};\\n        unordered_map<long, long> m;\\n        for (auto& n : d) ++m[n];\\n        long ans = 0;\\n        for (auto& [f,s] : m){\\n            long num = f;\\n            long numCount = s;\\n            for (auto& n : p){\\n                if (m.find(n - num) != m.end()){\\n                    if (n - num == num){\\n                        ans += numCount * (numCount - 1);\\n                    }\\n                    else{\\n                        ans += numCount * m[n - num];\\n                    }\\n                }\\n            }\\n        }\\n        return ans / 2 % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& d) {\\n        vector<long> p = \\n        {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};\\n        unordered_map<long, long> m;\\n        for (auto& n : d) ++m[n];\\n        long ans = 0;\\n        for (auto& [f,s] : m){\\n            long num = f;\\n            long numCount = s;\\n            for (auto& n : p){\\n                if (m.find(n - num) != m.end()){\\n                    if (n - num == num){\\n                        ans += numCount * (numCount - 1);\\n                    }\\n                    else{\\n                        ans += numCount * m[n - num];\\n                    }\\n                }\\n            }\\n        }\\n        return ans / 2 % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025026,
                "title": "o-len-deliciousness-time-to-clalcluate-closest-power",
                "content": "# Intuition\\nvvv\\n\\n# Approach\\nnumber X can be a (strong) maximum in only 1 type of pair \\n(X, closest_power_of_2_to_X - X). so fro each X we will do\\nres += cntr[closest_power_of_2_to_X - X]\\n\\nin addition if X is a power of 2, then we also need to calculate how many pairs of (X,X) we can have which is M * (M-1) / 2 where M is the frequency of X. so for each X that is a power of 2 we will do \\nres += (cntr[X] * (cntr[X] - 1) / 2) / (cntr[X]) := (cntr[X] - 1) / 2\\nwe will add this : \"(cntr[X] - 1) / 2\" cntr[X] times, so eventually we will cnt all the pairs.\\n\\n# Complexity\\n- Time complexity:\\nO(len(deliciousness)) * max_time_to_calclualate_the_closest_power_of_2\\nwhich is ~21 with minimal efffort and can be optimized to be ~5, but I dont think that optimizing it is a part of the question.\\n- Space complexity:\\nO(len(deliciousness))\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countPairs(self, deliciousness):\\n        \"\"\"\\n        :type deliciousness: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr = Counter(deliciousness)\\n        res = 0.0\\n        for food in deliciousness:\\n            if food != 0:                \\n                closestUpperPowerOf2 = 2**(math.ceil(math.log(food, 2)))\\n                res += cntr[closestUpperPowerOf2 - food]\\n                if (food == closestUpperPowerOf2):\\n                    res += (cntr[food] - 1) / 2.0\\n        return int(res) % (10**9 + 7)\\n\\n                \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPairs(self, deliciousness):\\n        \"\"\"\\n        :type deliciousness: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr = Counter(deliciousness)\\n        res = 0.0\\n        for food in deliciousness:\\n            if food != 0:                \\n                closestUpperPowerOf2 = 2**(math.ceil(math.log(food, 2)))\\n                res += cntr[closestUpperPowerOf2 - food]\\n                if (food == closestUpperPowerOf2):\\n                    res += (cntr[food] - 1) / 2.0\\n        return int(res) % (10**9 + 7)\\n\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941708,
                "title": "o-n-time-rust-solution",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    \\n    fn getPairs(val: i32, count: &HashMap<i32, i32>) -> i64 {\\n        \\n        let mut answer = 0 as i64;\\n        \\n        for i in (0..22) {\\n            let power_of_two = i32::pow(2, i);\\n            let target = power_of_two - val;\\n            \\n            if count.contains_key(&target) {\\n                let target_count = *count.get(&target).unwrap() as i64;\\n                answer += if (target == val) {target_count-1} else {target_count};\\n            }   \\n        }\\n        return answer;\\n    }\\n    \\n    \\n    // O(n) time,\\n    // O(n) space,\\n    // Approach: hashmap, \\n    pub fn count_pairs(deliciousness: Vec<i32>) -> i32 {\\n        let mut nums_count: HashMap<i32, i32> = HashMap::new();\\n        for num in &deliciousness {\\n            let mut count = 0;\\n            if nums_count.contains_key(&num) {\\n                count = *nums_count.get(&num).unwrap();\\n            }\\n            count += 1;\\n            nums_count.insert(*num, count);\\n        }\\n        \\n        let mut answer = 0;\\n        for num in deliciousness {\\n            answer += Solution::getPairs(num, &nums_count);\\n        }\\n        answer /= 2;\\n        let MOD = i64::pow(10, 9) + 7;\\n        answer %= MOD;\\n        return answer as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    \\n    fn getPairs(val: i32, count: &HashMap<i32, i32>) -> i64 {\\n        \\n        let mut answer = 0 as i64;\\n        \\n        for i in (0..22) {\\n            let power_of_two = i32::pow(2, i);\\n            let target = power_of_two - val;\\n            \\n            if count.contains_key(&target) {\\n                let target_count = *count.get(&target).unwrap() as i64;\\n                answer += if (target == val) {target_count-1} else {target_count};\\n            }   \\n        }\\n        return answer;\\n    }\\n    \\n    \\n    // O(n) time,\\n    // O(n) space,\\n    // Approach: hashmap, \\n    pub fn count_pairs(deliciousness: Vec<i32>) -> i32 {\\n        let mut nums_count: HashMap<i32, i32> = HashMap::new();\\n        for num in &deliciousness {\\n            let mut count = 0;\\n            if nums_count.contains_key(&num) {\\n                count = *nums_count.get(&num).unwrap();\\n            }\\n            count += 1;\\n            nums_count.insert(*num, count);\\n        }\\n        \\n        let mut answer = 0;\\n        for num in deliciousness {\\n            answer += Solution::getPairs(num, &nums_count);\\n        }\\n        answer /= 2;\\n        let MOD = i64::pow(10, 9) + 7;\\n        answer %= MOD;\\n        return answer as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2941656,
                "title": "o-n-time-hashmap-pyhton3-solution",
                "content": "```\\nclass Solution:\\n    \\n    def getPairs(self, val, count) -> int:\\n        \\n        answer = 0;\\n        for i in range(0, 22):\\n            power_of_two = 2**i\\n            target = power_of_two-val\\n            if target in count:\\n                answer += (count[target]-1) if target == val else count[target]\\n        \\n        return answer\\n        \\n    \\n    # O(n) time,\\n    # O(n) space,\\n    # Approach: hashtable, math\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        MOD = (10**9)+7\\n        answer = 0\\n        nums_count = Counter(deliciousness)\\n        for val in deliciousness:\\n            answer += self.getPairs(val, nums_count)\\n            \\n        answer //= 2\\n        answer %= MOD\\n        return answer\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def getPairs(self, val, count) -> int:\\n        \\n        answer = 0;\\n        for i in range(0, 22):\\n            power_of_two = 2**i\\n            target = power_of_two-val\\n            if target in count:\\n                answer += (count[target]-1) if target == val else count[target]\\n        \\n        return answer\\n        \\n    \\n    # O(n) time,\\n    # O(n) space,\\n    # Approach: hashtable, math\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        MOD = (10**9)+7\\n        answer = 0\\n        nums_count = Counter(deliciousness)\\n        for val in deliciousness:\\n            answer += self.getPairs(val, nums_count)\\n            \\n        answer //= 2\\n        answer %= MOD\\n        return answer\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932424,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n    private static int[] arr;\\n    int mod = 1000000007;\\n\\n    static {\\n        arr = new int[22];\\n        arr[0] = 1;\\n        for (int i = 1; i < 22; i++) {\\n            arr[i] = arr[i - 1] * 2;\\n        }\\n    }\\n\\n    public int countPairs(int[] deliciousness) {\\n        int res = 0, n = deliciousness.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int target : arr) {\\n                int remain = target - deliciousness[i];\\n                res += map.getOrDefault(remain, 0);\\n                res %= mod;\\n            }\\n            map.put(deliciousness[i], map.getOrDefault(deliciousness[i], 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int[] arr;\\n    int mod = 1000000007;\\n\\n    static {\\n        arr = new int[22];\\n        arr[0] = 1;\\n        for (int i = 1; i < 22; i++) {\\n            arr[i] = arr[i - 1] * 2;\\n        }\\n    }\\n\\n    public int countPairs(int[] deliciousness) {\\n        int res = 0, n = deliciousness.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int target : arr) {\\n                int remain = target - deliciousness[i];\\n                res += map.getOrDefault(remain, 0);\\n                res %= mod;\\n            }\\n            map.put(deliciousness[i], map.getOrDefault(deliciousness[i], 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930365,
                "title": "python-using-counter-simple-o-22n",
                "content": "\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        counter = Counter(deliciousness)\\n        powers = [pow(2,i) for i in range(22)]\\n        MOD = 10**9 + 7\\n        res = 0\\n        for i in counter:\\n            for j in powers:\\n                if j >= i:\\n                    if j - i == i:\\n                        res = (res + counter[i]*(counter[i] - 1)//2)%MOD\\n                    elif j - i > i:\\n                        res = (res + counter[i]*counter[j-i])%MOD\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        counter = Counter(deliciousness)\\n        powers = [pow(2,i) for i in range(22)]\\n        MOD = 10**9 + 7\\n        res = 0\\n        for i in counter:\\n            for j in powers:\\n                if j >= i:\\n                    if j - i == i:\\n                        res = (res + counter[i]*(counter[i] - 1)//2)%MOD\\n                    elif j - i > i:\\n                        res = (res + counter[i]*counter[j-i])%MOD\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879611,
                "title": "javascript-map-solution",
                "content": "/**\\n * @param {number[]} deliciousness\\n * @return {number}\\n */\\nvar countPairs = function(deliciousness) {\\n    \\n    function counter(x){\\n        let temp=x\\n        let count=0\\n        while(x){\\n            x=Math.floor(x/2)\\n            count++\\n        }\\n        return (1<<count)-temp\\n    }\\n    \\n    let map=new Map()\\n    for(let meal of deliciousness){\\n        if(!map.has(meal)) map.set(meal,1)\\n        else map.set(meal,map.get(meal)+1)\\n    }\\n  \\n    let res=0\\n    for(let [k,v] of map){\\n        \\n        if(k==counter(k)) {\\n            res+=(v*(v-1)/2)\\n            if(k!=1 && map.has(0)) {\\n                res+=(map.get(k)*map.get(0))\\n            }\\n        }\\n        else {\\n            if(map.has(counter(k))){\\n                res+=(map.get(k)*map.get(counter(k)))\\n            }\\n        }\\n    }\\n    \\n    return res%(10**9+7)\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "/**\\n * @param {number[]} deliciousness\\n * @return {number}\\n */\\nvar countPairs = function(deliciousness) {\\n    \\n    function counter(x){\\n        let temp=x\\n        let count=0\\n        while(x){\\n            x=Math.floor(x/2)\\n            count++\\n        }\\n        return (1<<count)-temp\\n    }\\n    \\n    let map=new Map()\\n    for(let meal of deliciousness){\\n        if(!map.has(meal)) map.set(meal,1)\\n        else map.set(meal,map.get(meal)+1)\\n    }\\n  \\n    let res=0\\n    for(let [k,v] of map){\\n        \\n        if(k==counter(k)) {\\n            res+=(v*(v-1)/2)\\n            if(k!=1 && map.has(0)) {\\n                res+=(map.get(k)*map.get(0))\\n            }\\n        }\\n        else {\\n            if(map.has(counter(k))){\\n                res+=(map.get(k)*map.get(counter(k)))\\n            }\\n        }\\n    }\\n    \\n    return res%(10**9+7)\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2867696,
                "title": "best-fast-solution-in-c-o-n-tc",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int size=deliciousness.size(),count=0,mod=1e9+7,x=1;\\n        unordered_map<int,int> mp;\\n        vector<int> vec(1,1);\\n        for(int i=0;i<21;i++){\\n            x*=2;\\n            vec.push_back(x);\\n        }\\n        for(auto it:deliciousness){\\n            for(auto gt:vec){\\n                int x=gt-it;\\n                if(mp.find(x)!=mp.end())\\n                    count=count%mod+mp[x];\\n            }\\n            mp[it]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& deliciousness) {\\n        int size=deliciousness.size(),count=0,mod=1e9+7,x=1;\\n        unordered_map<int,int> mp;\\n        vector<int> vec(1,1);\\n        for(int i=0;i<21;i++){\\n            x*=2;\\n            vec.push_back(x);\\n        }\\n        for(auto it:deliciousness){\\n            for(auto gt:vec){\\n                int x=gt-it;\\n                if(mp.find(x)!=mp.end())\\n                    count=count%mod+mp[x];\\n            }\\n            mp[it]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858521,
                "title": "python-hashmap",
                "content": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        s, ans, MOD = set(2 ** i for i in range(22)), 0, 1000000007\\n        cnt, seen = Counter(deliciousness), set()\\n        for i in cnt:\\n            for ss in s: \\n                j = ss - i\\n                if (i, j) in seen or (j, i) in seen: continue\\n                seen.add((i, j))\\n                if i == j:\\n                    ans += (cnt[i] * (cnt[i] - 1) // 2) % MOD\\n                else:\\n                    ans += cnt[i] * cnt[j] % MOD\\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n        s, ans, MOD = set(2 ** i for i in range(22)), 0, 1000000007\\n        cnt, seen = Counter(deliciousness), set()\\n        for i in cnt:\\n            for ss in s: \\n                j = ss - i\\n                if (i, j) in seen or (j, i) in seen: continue\\n                seen.add((i, j))\\n                if i == j:\\n                    ans += (cnt[i] * (cnt[i] - 1) // 2) % MOD\\n                else:\\n                    ans += cnt[i] * cnt[j] % MOD\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808553,
                "title": "help-me-understand-the-expected-result",
                "content": "Hi,\\nhow is the result **6** expected  with input [0,1,3,5,7,8,9]?\\nPlease list the **6** pairs... I can only see 5\\n0 8 \\n1 3\\n1 7\\n3 5\\n7 9",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2801291,
                "title": "python-hashmap-solution-beats-93-speed-70-space",
                "content": "```\\ndef countPairs(self, d: List[int]) -> int:\\n        power = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576]\\n        dic=Counter(d)\\n        re=0\\n        for i,j in dic.items():\\n            for ele in power:\\n                sub = ele - i\\n                if sub in dic and sub == i:\\n                    re+=j*(j-1)//2\\n                elif sub in dic and sub != i:\\n                    re+=j*dic[sub]/2\\n        return int(re)%(10**9 +7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countPairs(self, d: List[int]) -> int:\\n        power = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576]\\n        dic=Counter(d)\\n        re=0\\n        for i,j in dic.items():\\n            for ele in power:\\n                sub = ele - i\\n                if sub in dic and sub == i:\\n                    re+=j*(j-1)//2\\n                elif sub in dic and sub != i:\\n                    re+=j*dic[sub]/2\\n        return int(re)%(10**9 +7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2787106,
                "title": "based-on-hashmap-java-solution",
                "content": "# Intuition\\nAny good meal has exactly tow items. I could get this can be solved in O(n)2. So tried to optimize.\\n\\n# Approach\\nAny two numbers from input make the good meal. So if I have a number in hand, I can look for all the possible pair from map upto the max possible value.\\n\\n# Complexity\\n- Time complexity:\\nO(22powerN) -> 22 is constant -> So O(N)\\n\\n- Space complexity:\\nO(N) - every number from input array will be placed in Map\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int MOD = 1_00_00_00_007;\\n        int res = 0;\\n        Map<Integer, Integer> numVsCount = new HashMap();\\n\\n        for(int num : deliciousness) {\\n            // The max number given in the input is 2power20. And any good meal has exactly two item. \\n            // So while adding two of the same max number would result in a number less than 2power22. \\n            // This is just a max number I have considered to have an upper limit.\\n            for(int i = 0; i <= 22; i++) {\\n                int k = (int)Math.pow(2, i);\\n                if(numVsCount.containsKey(k - num)) {\\n                    res += numVsCount.get(k - num);\\n                    res %= MOD;\\n                }\\n            }\\n            numVsCount.put(num, numVsCount.getOrDefault(num, 0)+1);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] deliciousness) {\\n        int MOD = 1_00_00_00_007;\\n        int res = 0;\\n        Map<Integer, Integer> numVsCount = new HashMap();\\n\\n        for(int num : deliciousness) {\\n            // The max number given in the input is 2power20. And any good meal has exactly two item. \\n            // So while adding two of the same max number would result in a number less than 2power22. \\n            // This is just a max number I have considered to have an upper limit.\\n            for(int i = 0; i <= 22; i++) {\\n                int k = (int)Math.pow(2, i);\\n                if(numVsCount.containsKey(k - num)) {\\n                    res += numVsCount.get(k - num);\\n                    res %= MOD;\\n                }\\n            }\\n            numVsCount.put(num, numVsCount.getOrDefault(num, 0)+1);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742619,
                "title": "python3-easy-straightforward-commented-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we need a fast way to check whether any number is a power of two. Since the numbers are limited to 2^20, we can never reach higher than 2* 2^20 = 2^21. Therefore we can just initialize a set with all the 21 power of two in the given range.\\n\\nThen we count the number of occurences per unique number so have less pairs to check. Having all the possible numbers of two also enables us to just check for every number if we encounterd the given counterpart.\\n\\nE.G. For number seven this could be 1, 9, 25 etc.\\n\\nThis makes it a linear solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every number we have we check if it can build a number in the powers of two itself and then check if we have any complimentary numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(22*N) -> O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) as we need to build the counter which is worst case all different numbers.\\n\\n# Code\\n```\\nclass Solution:\\n\\n    # get all the powers of two\\n    powers = set([2**exp for exp in range(22)])\\n\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n\\n        # count the number of occurences\\n        cn = collections.Counter(deliciousness)\\n\\n        # iterate over the combinations\\n        result = 0\\n        for item, amount in cn.items():\\n\\n            # get all the self pairs\\n            if item in self.powers:\\n                result += amount*(amount-1)//2\\n            \\n            # check for all powers of two\\n            # if our counterpart has values\\n            for power in self.powers:\\n                if power > 2*item:\\n                    result += cn[power - item]*amount\\n        return result % 1_000_000_007\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    # get all the powers of two\\n    powers = set([2**exp for exp in range(22)])\\n\\n    def countPairs(self, deliciousness: List[int]) -> int:\\n\\n        # count the number of occurences\\n        cn = collections.Counter(deliciousness)\\n\\n        # iterate over the combinations\\n        result = 0\\n        for item, amount in cn.items():\\n\\n            # get all the self pairs\\n            if item in self.powers:\\n                result += amount*(amount-1)//2\\n            \\n            # check for all powers of two\\n            # if our counterpart has values\\n            for power in self.powers:\\n                if power > 2*item:\\n                    result += cn[power - item]*amount\\n        return result % 1_000_000_007\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565368,
                "content": [
                    {
                        "username": "Frikster",
                        "content": "Did anyone else think hiding the test case  `[1048576,1048576]` was silly if you got it incorrect? For me this was just because of an off-by-one error due to oopsie math. You\\'re already penalized on the contest for submitting it wrong so it seems pedantic to also obscure the incorrect test case, especially if there is no good reason for obscuring it.\\n\\nOr perhaps I am missing something and there was a good reason for this? Also note I don\\'t know if all test cases were obscured for this question. Maybe there is a reasonable rationale. In which case I\\'d love to hear it.\\n\\nAnyway, I\\'m by no means a contest expert, but man, getting 68/69 for this question only to realize it was due to an off-by-one rather than my approach being in any major way incorrect really makes me feel cheated."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "For the test case [32,32,32,......] (array.length=100000, all items are 32)\\nI think it should be 100000*99999/2=4999950000, but give answer 999949972. Where am I wrong?"
                    },
                    {
                        "username": "developerwhitehat295",
                        "content": "return the module to 1000000007"
                    },
                    {
                        "username": "_noexcuses",
                        "content": "It seems the time limit for C++ was unreasonably low for this problem. I suggest cancelling this one for the contest, @Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/efa58fb0-744f-482f-a07e-fba602a309b8_1609648329.8465528.png)\\n\\n![image](https://assets.leetcode.com/users/images/23bafc1d-1cc8-4cf9-830d-03441fb7fcee_1609648329.8647382.png)\\n\\n"
                    },
                    {
                        "username": "morrobay",
                        "content": "I see the mod of 1000000007 is used everywhere but not sure what it means, can ayone explain? thanks."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "very late reply .....ha but it due to it being one of the largest prime number \\n"
                    },
                    {
                        "username": "yared123yared",
                        "content": "yes it worked wuth ans % 1_000_000_007, but can any one explain to me why it worked?\\n"
                    },
                    {
                        "username": "chirag879",
                        "content": "[149,107,1,63,0,1,6867,1325,5611,2581,39,89,46,18,12,20,22,234]"
                    },
                    {
                        "username": "8800AB",
                        "content": "consider \\'1\\' as power of 2 too , as 2^0 = 1"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation:** https://federico-feresini.medium.com/count-good-meals-algorithms-visualizations-a13a1b883b4"
                    },
                    {
                        "username": "geek_1010",
                        "content": "Can anyone explain what does it mean by \\n\"you can make from this list modulo 10^9 + 7?\""
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "it means you return your result modulo 10^9 + 7:\\nnWays = nWays % 1000000007"
                    }
                ]
            },
            {
                "id": 1570348,
                "content": [
                    {
                        "username": "Frikster",
                        "content": "Did anyone else think hiding the test case  `[1048576,1048576]` was silly if you got it incorrect? For me this was just because of an off-by-one error due to oopsie math. You\\'re already penalized on the contest for submitting it wrong so it seems pedantic to also obscure the incorrect test case, especially if there is no good reason for obscuring it.\\n\\nOr perhaps I am missing something and there was a good reason for this? Also note I don\\'t know if all test cases were obscured for this question. Maybe there is a reasonable rationale. In which case I\\'d love to hear it.\\n\\nAnyway, I\\'m by no means a contest expert, but man, getting 68/69 for this question only to realize it was due to an off-by-one rather than my approach being in any major way incorrect really makes me feel cheated."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "For the test case [32,32,32,......] (array.length=100000, all items are 32)\\nI think it should be 100000*99999/2=4999950000, but give answer 999949972. Where am I wrong?"
                    },
                    {
                        "username": "developerwhitehat295",
                        "content": "return the module to 1000000007"
                    },
                    {
                        "username": "_noexcuses",
                        "content": "It seems the time limit for C++ was unreasonably low for this problem. I suggest cancelling this one for the contest, @Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/efa58fb0-744f-482f-a07e-fba602a309b8_1609648329.8465528.png)\\n\\n![image](https://assets.leetcode.com/users/images/23bafc1d-1cc8-4cf9-830d-03441fb7fcee_1609648329.8647382.png)\\n\\n"
                    },
                    {
                        "username": "morrobay",
                        "content": "I see the mod of 1000000007 is used everywhere but not sure what it means, can ayone explain? thanks."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "very late reply .....ha but it due to it being one of the largest prime number \\n"
                    },
                    {
                        "username": "yared123yared",
                        "content": "yes it worked wuth ans % 1_000_000_007, but can any one explain to me why it worked?\\n"
                    },
                    {
                        "username": "chirag879",
                        "content": "[149,107,1,63,0,1,6867,1325,5611,2581,39,89,46,18,12,20,22,234]"
                    },
                    {
                        "username": "8800AB",
                        "content": "consider \\'1\\' as power of 2 too , as 2^0 = 1"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation:** https://federico-feresini.medium.com/count-good-meals-algorithms-visualizations-a13a1b883b4"
                    },
                    {
                        "username": "geek_1010",
                        "content": "Can anyone explain what does it mean by \\n\"you can make from this list modulo 10^9 + 7?\""
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "it means you return your result modulo 10^9 + 7:\\nnWays = nWays % 1000000007"
                    }
                ]
            },
            {
                "id": 1565894,
                "content": [
                    {
                        "username": "Frikster",
                        "content": "Did anyone else think hiding the test case  `[1048576,1048576]` was silly if you got it incorrect? For me this was just because of an off-by-one error due to oopsie math. You\\'re already penalized on the contest for submitting it wrong so it seems pedantic to also obscure the incorrect test case, especially if there is no good reason for obscuring it.\\n\\nOr perhaps I am missing something and there was a good reason for this? Also note I don\\'t know if all test cases were obscured for this question. Maybe there is a reasonable rationale. In which case I\\'d love to hear it.\\n\\nAnyway, I\\'m by no means a contest expert, but man, getting 68/69 for this question only to realize it was due to an off-by-one rather than my approach being in any major way incorrect really makes me feel cheated."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "For the test case [32,32,32,......] (array.length=100000, all items are 32)\\nI think it should be 100000*99999/2=4999950000, but give answer 999949972. Where am I wrong?"
                    },
                    {
                        "username": "developerwhitehat295",
                        "content": "return the module to 1000000007"
                    },
                    {
                        "username": "_noexcuses",
                        "content": "It seems the time limit for C++ was unreasonably low for this problem. I suggest cancelling this one for the contest, @Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/efa58fb0-744f-482f-a07e-fba602a309b8_1609648329.8465528.png)\\n\\n![image](https://assets.leetcode.com/users/images/23bafc1d-1cc8-4cf9-830d-03441fb7fcee_1609648329.8647382.png)\\n\\n"
                    },
                    {
                        "username": "morrobay",
                        "content": "I see the mod of 1000000007 is used everywhere but not sure what it means, can ayone explain? thanks."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "very late reply .....ha but it due to it being one of the largest prime number \\n"
                    },
                    {
                        "username": "yared123yared",
                        "content": "yes it worked wuth ans % 1_000_000_007, but can any one explain to me why it worked?\\n"
                    },
                    {
                        "username": "chirag879",
                        "content": "[149,107,1,63,0,1,6867,1325,5611,2581,39,89,46,18,12,20,22,234]"
                    },
                    {
                        "username": "8800AB",
                        "content": "consider \\'1\\' as power of 2 too , as 2^0 = 1"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation:** https://federico-feresini.medium.com/count-good-meals-algorithms-visualizations-a13a1b883b4"
                    },
                    {
                        "username": "geek_1010",
                        "content": "Can anyone explain what does it mean by \\n\"you can make from this list modulo 10^9 + 7?\""
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "it means you return your result modulo 10^9 + 7:\\nnWays = nWays % 1000000007"
                    }
                ]
            },
            {
                "id": 1576380,
                "content": [
                    {
                        "username": "Frikster",
                        "content": "Did anyone else think hiding the test case  `[1048576,1048576]` was silly if you got it incorrect? For me this was just because of an off-by-one error due to oopsie math. You\\'re already penalized on the contest for submitting it wrong so it seems pedantic to also obscure the incorrect test case, especially if there is no good reason for obscuring it.\\n\\nOr perhaps I am missing something and there was a good reason for this? Also note I don\\'t know if all test cases were obscured for this question. Maybe there is a reasonable rationale. In which case I\\'d love to hear it.\\n\\nAnyway, I\\'m by no means a contest expert, but man, getting 68/69 for this question only to realize it was due to an off-by-one rather than my approach being in any major way incorrect really makes me feel cheated."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "For the test case [32,32,32,......] (array.length=100000, all items are 32)\\nI think it should be 100000*99999/2=4999950000, but give answer 999949972. Where am I wrong?"
                    },
                    {
                        "username": "developerwhitehat295",
                        "content": "return the module to 1000000007"
                    },
                    {
                        "username": "_noexcuses",
                        "content": "It seems the time limit for C++ was unreasonably low for this problem. I suggest cancelling this one for the contest, @Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/efa58fb0-744f-482f-a07e-fba602a309b8_1609648329.8465528.png)\\n\\n![image](https://assets.leetcode.com/users/images/23bafc1d-1cc8-4cf9-830d-03441fb7fcee_1609648329.8647382.png)\\n\\n"
                    },
                    {
                        "username": "morrobay",
                        "content": "I see the mod of 1000000007 is used everywhere but not sure what it means, can ayone explain? thanks."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "very late reply .....ha but it due to it being one of the largest prime number \\n"
                    },
                    {
                        "username": "yared123yared",
                        "content": "yes it worked wuth ans % 1_000_000_007, but can any one explain to me why it worked?\\n"
                    },
                    {
                        "username": "chirag879",
                        "content": "[149,107,1,63,0,1,6867,1325,5611,2581,39,89,46,18,12,20,22,234]"
                    },
                    {
                        "username": "8800AB",
                        "content": "consider \\'1\\' as power of 2 too , as 2^0 = 1"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation:** https://federico-feresini.medium.com/count-good-meals-algorithms-visualizations-a13a1b883b4"
                    },
                    {
                        "username": "geek_1010",
                        "content": "Can anyone explain what does it mean by \\n\"you can make from this list modulo 10^9 + 7?\""
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "it means you return your result modulo 10^9 + 7:\\nnWays = nWays % 1000000007"
                    }
                ]
            },
            {
                "id": 1574805,
                "content": [
                    {
                        "username": "Frikster",
                        "content": "Did anyone else think hiding the test case  `[1048576,1048576]` was silly if you got it incorrect? For me this was just because of an off-by-one error due to oopsie math. You\\'re already penalized on the contest for submitting it wrong so it seems pedantic to also obscure the incorrect test case, especially if there is no good reason for obscuring it.\\n\\nOr perhaps I am missing something and there was a good reason for this? Also note I don\\'t know if all test cases were obscured for this question. Maybe there is a reasonable rationale. In which case I\\'d love to hear it.\\n\\nAnyway, I\\'m by no means a contest expert, but man, getting 68/69 for this question only to realize it was due to an off-by-one rather than my approach being in any major way incorrect really makes me feel cheated."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "For the test case [32,32,32,......] (array.length=100000, all items are 32)\\nI think it should be 100000*99999/2=4999950000, but give answer 999949972. Where am I wrong?"
                    },
                    {
                        "username": "developerwhitehat295",
                        "content": "return the module to 1000000007"
                    },
                    {
                        "username": "_noexcuses",
                        "content": "It seems the time limit for C++ was unreasonably low for this problem. I suggest cancelling this one for the contest, @Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/efa58fb0-744f-482f-a07e-fba602a309b8_1609648329.8465528.png)\\n\\n![image](https://assets.leetcode.com/users/images/23bafc1d-1cc8-4cf9-830d-03441fb7fcee_1609648329.8647382.png)\\n\\n"
                    },
                    {
                        "username": "morrobay",
                        "content": "I see the mod of 1000000007 is used everywhere but not sure what it means, can ayone explain? thanks."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "very late reply .....ha but it due to it being one of the largest prime number \\n"
                    },
                    {
                        "username": "yared123yared",
                        "content": "yes it worked wuth ans % 1_000_000_007, but can any one explain to me why it worked?\\n"
                    },
                    {
                        "username": "chirag879",
                        "content": "[149,107,1,63,0,1,6867,1325,5611,2581,39,89,46,18,12,20,22,234]"
                    },
                    {
                        "username": "8800AB",
                        "content": "consider \\'1\\' as power of 2 too , as 2^0 = 1"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation:** https://federico-feresini.medium.com/count-good-meals-algorithms-visualizations-a13a1b883b4"
                    },
                    {
                        "username": "geek_1010",
                        "content": "Can anyone explain what does it mean by \\n\"you can make from this list modulo 10^9 + 7?\""
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "it means you return your result modulo 10^9 + 7:\\nnWays = nWays % 1000000007"
                    }
                ]
            },
            {
                "id": 1574772,
                "content": [
                    {
                        "username": "Frikster",
                        "content": "Did anyone else think hiding the test case  `[1048576,1048576]` was silly if you got it incorrect? For me this was just because of an off-by-one error due to oopsie math. You\\'re already penalized on the contest for submitting it wrong so it seems pedantic to also obscure the incorrect test case, especially if there is no good reason for obscuring it.\\n\\nOr perhaps I am missing something and there was a good reason for this? Also note I don\\'t know if all test cases were obscured for this question. Maybe there is a reasonable rationale. In which case I\\'d love to hear it.\\n\\nAnyway, I\\'m by no means a contest expert, but man, getting 68/69 for this question only to realize it was due to an off-by-one rather than my approach being in any major way incorrect really makes me feel cheated."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "For the test case [32,32,32,......] (array.length=100000, all items are 32)\\nI think it should be 100000*99999/2=4999950000, but give answer 999949972. Where am I wrong?"
                    },
                    {
                        "username": "developerwhitehat295",
                        "content": "return the module to 1000000007"
                    },
                    {
                        "username": "_noexcuses",
                        "content": "It seems the time limit for C++ was unreasonably low for this problem. I suggest cancelling this one for the contest, @Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/efa58fb0-744f-482f-a07e-fba602a309b8_1609648329.8465528.png)\\n\\n![image](https://assets.leetcode.com/users/images/23bafc1d-1cc8-4cf9-830d-03441fb7fcee_1609648329.8647382.png)\\n\\n"
                    },
                    {
                        "username": "morrobay",
                        "content": "I see the mod of 1000000007 is used everywhere but not sure what it means, can ayone explain? thanks."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "very late reply .....ha but it due to it being one of the largest prime number \\n"
                    },
                    {
                        "username": "yared123yared",
                        "content": "yes it worked wuth ans % 1_000_000_007, but can any one explain to me why it worked?\\n"
                    },
                    {
                        "username": "chirag879",
                        "content": "[149,107,1,63,0,1,6867,1325,5611,2581,39,89,46,18,12,20,22,234]"
                    },
                    {
                        "username": "8800AB",
                        "content": "consider \\'1\\' as power of 2 too , as 2^0 = 1"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation:** https://federico-feresini.medium.com/count-good-meals-algorithms-visualizations-a13a1b883b4"
                    },
                    {
                        "username": "geek_1010",
                        "content": "Can anyone explain what does it mean by \\n\"you can make from this list modulo 10^9 + 7?\""
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "it means you return your result modulo 10^9 + 7:\\nnWays = nWays % 1000000007"
                    }
                ]
            },
            {
                "id": 1904971,
                "content": [
                    {
                        "username": "Frikster",
                        "content": "Did anyone else think hiding the test case  `[1048576,1048576]` was silly if you got it incorrect? For me this was just because of an off-by-one error due to oopsie math. You\\'re already penalized on the contest for submitting it wrong so it seems pedantic to also obscure the incorrect test case, especially if there is no good reason for obscuring it.\\n\\nOr perhaps I am missing something and there was a good reason for this? Also note I don\\'t know if all test cases were obscured for this question. Maybe there is a reasonable rationale. In which case I\\'d love to hear it.\\n\\nAnyway, I\\'m by no means a contest expert, but man, getting 68/69 for this question only to realize it was due to an off-by-one rather than my approach being in any major way incorrect really makes me feel cheated."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "For the test case [32,32,32,......] (array.length=100000, all items are 32)\\nI think it should be 100000*99999/2=4999950000, but give answer 999949972. Where am I wrong?"
                    },
                    {
                        "username": "developerwhitehat295",
                        "content": "return the module to 1000000007"
                    },
                    {
                        "username": "_noexcuses",
                        "content": "It seems the time limit for C++ was unreasonably low for this problem. I suggest cancelling this one for the contest, @Leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/efa58fb0-744f-482f-a07e-fba602a309b8_1609648329.8465528.png)\\n\\n![image](https://assets.leetcode.com/users/images/23bafc1d-1cc8-4cf9-830d-03441fb7fcee_1609648329.8647382.png)\\n\\n"
                    },
                    {
                        "username": "morrobay",
                        "content": "I see the mod of 1000000007 is used everywhere but not sure what it means, can ayone explain? thanks."
                    },
                    {
                        "username": "vabhijith2003",
                        "content": "very late reply .....ha but it due to it being one of the largest prime number \\n"
                    },
                    {
                        "username": "yared123yared",
                        "content": "yes it worked wuth ans % 1_000_000_007, but can any one explain to me why it worked?\\n"
                    },
                    {
                        "username": "chirag879",
                        "content": "[149,107,1,63,0,1,6867,1325,5611,2581,39,89,46,18,12,20,22,234]"
                    },
                    {
                        "username": "8800AB",
                        "content": "consider \\'1\\' as power of 2 too , as 2^0 = 1"
                    },
                    {
                        "username": "Feresini",
                        "content": "**Medium article with code, analysis, and step-by-step solution explanation:** https://federico-feresini.medium.com/count-good-meals-algorithms-visualizations-a13a1b883b4"
                    },
                    {
                        "username": "geek_1010",
                        "content": "Can anyone explain what does it mean by \\n\"you can make from this list modulo 10^9 + 7?\""
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "it means you return your result modulo 10^9 + 7:\\nnWays = nWays % 1000000007"
                    }
                ]
            }
        ]
    },
    {
        "title": "Ways to Split Array Into Three Subarrays",
        "question_content": "<p>A split of an integer array is <strong>good</strong> if:</p>\n\n<ul>\n\t<li>The array is split into three <strong>non-empty</strong> contiguous subarrays - named <code>left</code>, <code>mid</code>, <code>right</code> respectively from left to right.</li>\n\t<li>The sum of the elements in <code>left</code> is less than or equal to the sum of the elements in <code>mid</code>, and the sum of the elements in <code>mid</code> is less than or equal to the sum of the elements in <code>right</code>.</li>\n</ul>\n\n<p>Given <code>nums</code>, an array of <strong>non-negative</strong> integers, return <em>the number of <strong>good</strong> ways to split</em> <code>nums</code>. As the number may be too large, return it <strong>modulo</strong> <code>10<sup>9 </sup>+ 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The only good way to split nums is [1] [1] [1].</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2,2,5,0]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are three good ways of splitting nums:\n[1] [2] [2,2,5,0]\n[1] [2,2] [2,5,0]\n[1,2] [2,2] [5,0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no good way to split nums.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 999113,
                "title": "java-scala-detailed-explanation-prefix-sum-binary-search",
                "content": "**Key Notes:**\\n- Naive solution would be: O(N^2), searching all two points, which separates leftSum, midSum and rightSum\\n- To quickly find the range sum, we will use **prefix sum** here (10^4 * 10^5 not out of bound of Integer, we good)\\n- By fixing one point (A), we could use binary search to find another point (B).\\n\\t- If the point B is too left, the **midSum** will be too small\\n\\t- If the point B is too right, the **rightSum** will be too small\\n\\t- Basically, we are finding **a range of the point B**, which satisfies the condition (leftSum <= midSum <= rightSum)\\n\\t\\t- Similar the to question [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\\n\\n![image](https://assets.leetcode.com/users/images/9ca8c136-7c3d-4e6c-ad2a-3f9090c26053_1609657205.8195658.png)\\n\\n```java\\npublic int waysToSplit(int[] nums) {\\n        \\n\\tint MOD = (int) (1e9 + 7);\\n\\n\\tint N = nums.length;\\n\\n\\t// prefix array\\n\\tint[] A = new int[N];\\n\\tA[0] = nums[0];\\n\\tfor (int i = 1; i < N; ++i) A[i] = A[i - 1] + nums[i];\\n\\n\\tint res = 0;\\n\\tfor (int i = 1; i < N - 1; ++i) {\\n\\t\\n\\t\\tif (A[i - 1] > (A[N - 1] - A[i - 1]) / 2) break;  // early termination\\n\\n\\t\\tint left = helper(A, A[i - 1], i, true);\\n\\t\\tint right = helper(A, A[i - 1], i, false);\\n\\n\\t\\tif (left == -1 || right == -1) continue;  // none is satisfied\\n\\n\\t\\tres = (res + (right - left + 1) % MOD) % MOD;\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int helper(int[] A, int leftSum, int index, boolean searchLeft) {\\n\\n\\tint N = A.length;\\n\\tint l = index, r = N - 2;\\n\\tint res = -1;\\n\\n\\twhile (l <= r) {\\n\\n\\t\\tint m = (r - l) / 2 + l;\\n\\t\\tint midSum = A[m] - A[index - 1];\\n\\t\\tint rightSum = A[N - 1] - A[m];\\n\\n\\t\\tif (leftSum <= midSum && midSum <= rightSum) {\\n\\t\\t\\tres = m;\\n\\t\\t\\tif (searchLeft) r = m - 1;\\n\\t\\t\\telse l = m + 1;\\n\\t\\t} else if (leftSum > midSum) {  // shrink left\\n\\t\\t\\tl = m + 1;\\n\\t\\t} else {  // shrink right\\n\\t\\t\\tr = m - 1;\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n**Poor Scala Version** (Feel free to correct/improve/accuse my poor/naive Scala code, I would really appreciate that!)\\n```scala\\ndef waysToSplit(nums: Array[Int]): Int = {\\n        \\n\\tval MOD = (1e9 + 7).toInt\\n\\tval N = nums.length\\n\\n\\t// prefix array\\n\\tval A: Array[Int] = nums.map{var s = 0; d => {s += d; s}}\\n\\n\\tdef binarySearch(A: Array[Int], leftSum: Int, index: Int, searchLeft: Boolean): Int = {\\n\\t\\n\\t\\t@tailrec\\n\\t\\tdef binarySearchHelper(l: Int, r: Int, acc: Int): Int = {\\n\\t\\t\\tif (l > r) acc\\n\\t\\t\\telse {\\n\\t\\t\\t\\tval m = (r - l) / 2 + l\\n\\t\\t\\t\\tval midSum = A(m) - A(index - 1)\\n\\t\\t\\t\\tval rightSum = A(N - 1) - A(m)\\n\\n\\t\\t\\t\\tif (leftSum <= midSum && midSum <= rightSum)\\n\\t\\t\\t\\t\\tbinarySearchHelper(if (searchLeft) l else m + 1, if (searchLeft) m - 1 else r, m)\\n\\t\\t\\t\\telse if (leftSum > midSum) binarySearchHelper(m + 1, r, acc)\\n\\t\\t\\t\\telse binarySearchHelper(l, m - 1, acc)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tbinarySearchHelper(index, N - 2, -1)\\n\\t}\\n\\n\\t@tailrec\\n\\tdef waysToSplitHelper(i: Int, res: Int): Int = {\\n\\t\\tif (i == N - 1) res\\n\\t\\telse {\\n\\t\\t\\tval left = binarySearch(A, A(i - 1), i, searchLeft = true)\\n\\t\\t\\tval right = binarySearch(A, A(i - 1), i, searchLeft = false)\\n\\t\\t\\twaysToSplitHelper(i + 1, if (left == -1 || right == -1) res else (res + (right - left + 1)) % MOD)\\n\\t\\t}\\n\\t}\\n\\t\\n\\twaysToSplitHelper(1, 0)\\n}\\n```\\nHappy new year!",
                "solutionTags": [],
                "code": "```java\\npublic int waysToSplit(int[] nums) {\\n        \\n\\tint MOD = (int) (1e9 + 7);\\n\\n\\tint N = nums.length;\\n\\n\\t// prefix array\\n\\tint[] A = new int[N];\\n\\tA[0] = nums[0];\\n\\tfor (int i = 1; i < N; ++i) A[i] = A[i - 1] + nums[i];\\n\\n\\tint res = 0;\\n\\tfor (int i = 1; i < N - 1; ++i) {\\n\\t\\n\\t\\tif (A[i - 1] > (A[N - 1] - A[i - 1]) / 2) break;  // early termination\\n\\n\\t\\tint left = helper(A, A[i - 1], i, true);\\n\\t\\tint right = helper(A, A[i - 1], i, false);\\n\\n\\t\\tif (left == -1 || right == -1) continue;  // none is satisfied\\n\\n\\t\\tres = (res + (right - left + 1) % MOD) % MOD;\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int helper(int[] A, int leftSum, int index, boolean searchLeft) {\\n\\n\\tint N = A.length;\\n\\tint l = index, r = N - 2;\\n\\tint res = -1;\\n\\n\\twhile (l <= r) {\\n\\n\\t\\tint m = (r - l) / 2 + l;\\n\\t\\tint midSum = A[m] - A[index - 1];\\n\\t\\tint rightSum = A[N - 1] - A[m];\\n\\n\\t\\tif (leftSum <= midSum && midSum <= rightSum) {\\n\\t\\t\\tres = m;\\n\\t\\t\\tif (searchLeft) r = m - 1;\\n\\t\\t\\telse l = m + 1;\\n\\t\\t} else if (leftSum > midSum) {  // shrink left\\n\\t\\t\\tl = m + 1;\\n\\t\\t} else {  // shrink right\\n\\t\\t\\tr = m - 1;\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```\n```scala\\ndef waysToSplit(nums: Array[Int]): Int = {\\n        \\n\\tval MOD = (1e9 + 7).toInt\\n\\tval N = nums.length\\n\\n\\t// prefix array\\n\\tval A: Array[Int] = nums.map{var s = 0; d => {s += d; s}}\\n\\n\\tdef binarySearch(A: Array[Int], leftSum: Int, index: Int, searchLeft: Boolean): Int = {\\n\\t\\n\\t\\t@tailrec\\n\\t\\tdef binarySearchHelper(l: Int, r: Int, acc: Int): Int = {\\n\\t\\t\\tif (l > r) acc\\n\\t\\t\\telse {\\n\\t\\t\\t\\tval m = (r - l) / 2 + l\\n\\t\\t\\t\\tval midSum = A(m) - A(index - 1)\\n\\t\\t\\t\\tval rightSum = A(N - 1) - A(m)\\n\\n\\t\\t\\t\\tif (leftSum <= midSum && midSum <= rightSum)\\n\\t\\t\\t\\t\\tbinarySearchHelper(if (searchLeft) l else m + 1, if (searchLeft) m - 1 else r, m)\\n\\t\\t\\t\\telse if (leftSum > midSum) binarySearchHelper(m + 1, r, acc)\\n\\t\\t\\t\\telse binarySearchHelper(l, m - 1, acc)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tbinarySearchHelper(index, N - 2, -1)\\n\\t}\\n\\n\\t@tailrec\\n\\tdef waysToSplitHelper(i: Int, res: Int): Int = {\\n\\t\\tif (i == N - 1) res\\n\\t\\telse {\\n\\t\\t\\tval left = binarySearch(A, A(i - 1), i, searchLeft = true)\\n\\t\\t\\tval right = binarySearch(A, A(i - 1), i, searchLeft = false)\\n\\t\\t\\twaysToSplitHelper(i + 1, if (left == -1 || right == -1) res else (res + (right - left + 1)) % MOD)\\n\\t\\t}\\n\\t}\\n\\t\\n\\twaysToSplitHelper(1, 0)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 999257,
                "title": "c-java-python-o-n-with-picture",
                "content": "The approach is not too hard, but the implementation was tricky for me to get right.\\n\\nFirst, we prepare the prefix sum array, so that we can compute subarray sums in O(1). Then, we move the boundary of the first subarray left to right. This is the first pointer - `i`.\\n\\nFor each point `i`, we find the minimum (`j`) and maximum (`k`) boundaries of the second subarray:\\n- `nums[j] >= 2 * nums[i]`\\n- `nums[sz - 1] - nums[k] >= nums[k] - nums[i] `\\n\\n> Note that in the code and examples below, `k` points to the element *after* the second array. In other words, it marks the start of the (shortest) third subarray. This makes the logic a bit simpler.\\n\\nWith these conditions, sum(0, i) <= sum(i + 1, j), and sum(i + 1, k - 1) < sum(k, n). Therefore, for a point `i`, we can build `k - j ` subarrays satisfying the problem requirements.\\n\\nFinal thing is to realize that j and k will only move forward, which result in a linear-time solution. \\n\\nThe following picture demonstrate this approach for the `[4,2,3,0,3,5,3,12]` test case.\\n\\n![image](https://assets.leetcode.com/users/images/1f373639-66e5-496e-9450-15fde8836ad9_1609707433.9044826.png)\\n**C++**\\n```cpp\\nint waysToSplit(vector<int>& nums) {\\n    int res = 0, sz = nums.size();\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    for (int i = 0, j = 0, k = 0; i < sz - 2; ++i) {\\n        j = max(i + 1, j);\\n        while (j < sz - 1 && nums[j] < nums[i] * 2)\\n            ++j;\\n        k = max(j, k);\\n        while (k < sz - 1 && nums[k] - nums[i] <= nums[sz - 1] - nums[k])\\n            ++k;\\n        res = (res + k - j) % 1000000007;\\n    }\\n    return res;\\n} \\n```\\n**Java**\\n```java\\npublic int waysToSplit(int[] nums) {\\n    int sz = nums.length, res = 0;\\n    for (int i = 1; i < sz; ++i)\\n        nums[i] += nums[i - 1];\\n    for (int i = 0, j = 0, k = 0; i < sz - 2; ++i) {\\n        while (j <= i || (j < sz - 1 && nums[j] < nums[i] * 2))\\n            ++j;\\n        while (k < j || ( k < sz - 1 && nums[k] - nums[i] <= nums[sz - 1] - nums[k]))\\n            ++k;\\n        res = (res + k - j) % 1000000007;\\n    }    \\n    return res;\\n}\\n```\\n**Python**\\n```python\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        sz, res, j, k = len(nums), 0, 0, 0\\n        nums = list(accumulate(nums))\\n        for i in range(sz - 2):\\n            while j <= i or (j < sz - 1 and nums[j] < nums[i] * 2):\\n                j += 1\\n            while k < j or (k < sz - 1 and nums[k] - nums[i] <= nums[-1] - nums[k]):\\n                k += 1\\n            res = (res + k - j) % 1000000007\\n        return res\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(n) for the prefix sum array - or O(1) as we reuse the input.",
                "solutionTags": [],
                "code": "```cpp\\nint waysToSplit(vector<int>& nums) {\\n    int res = 0, sz = nums.size();\\n    partial_sum(begin(nums), end(nums), begin(nums));\\n    for (int i = 0, j = 0, k = 0; i < sz - 2; ++i) {\\n        j = max(i + 1, j);\\n        while (j < sz - 1 && nums[j] < nums[i] * 2)\\n            ++j;\\n        k = max(j, k);\\n        while (k < sz - 1 && nums[k] - nums[i] <= nums[sz - 1] - nums[k])\\n            ++k;\\n        res = (res + k - j) % 1000000007;\\n    }\\n    return res;\\n} \\n```\n```java\\npublic int waysToSplit(int[] nums) {\\n    int sz = nums.length, res = 0;\\n    for (int i = 1; i < sz; ++i)\\n        nums[i] += nums[i - 1];\\n    for (int i = 0, j = 0, k = 0; i < sz - 2; ++i) {\\n        while (j <= i || (j < sz - 1 && nums[j] < nums[i] * 2))\\n            ++j;\\n        while (k < j || ( k < sz - 1 && nums[k] - nums[i] <= nums[sz - 1] - nums[k]))\\n            ++k;\\n        res = (res + k - j) % 1000000007;\\n    }    \\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        sz, res, j, k = len(nums), 0, 0, 0\\n        nums = list(accumulate(nums))\\n        for i in range(sz - 2):\\n            while j <= i or (j < sz - 1 and nums[j] < nums[i] * 2):\\n                j += 1\\n            while k < j or (k < sz - 1 and nums[k] - nums[i] <= nums[-1] - nums[k]):\\n                k += 1\\n            res = (res + k - j) % 1000000007\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999157,
                "title": "python3-binary-search-2-pointer",
                "content": "**Algo**\\nCompute prefix array of `nums`. Any at index `i`, you want to find index `j` such at \\n`prefix[i] <= prefix[j] - prefix[i] <= prefix[-1] - prefix[j]`\\nThe rest comes out naturally. \\n\\n**Implementation** \\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = 0\\n        for i in range(1, len(nums)): \\n            j = bisect_left(prefix, 2*prefix[i])\\n            k = bisect_right(prefix, (prefix[i] + prefix[-1])//2)\\n            ans += max(0, min(len(nums), k) - max(i+1, j))\\n        return ans % 1_000_000_007\\n```\\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\nEdit\\nAdding two pointers approach `O(N)` time\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = j = k = 0 \\n        for i in range(1, len(nums)): \\n            j = max(j, i+1)\\n            while j < len(nums) and 2*prefix[i] > prefix[j]: j += 1\\n            k = max(k, j)\\n            while k < len(nums) and 2*prefix[k] <= prefix[i] + prefix[-1]: k += 1\\n            ans += k - j \\n        return ans % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = 0\\n        for i in range(1, len(nums)): \\n            j = bisect_left(prefix, 2*prefix[i])\\n            k = bisect_right(prefix, (prefix[i] + prefix[-1])//2)\\n            ans += max(0, min(len(nums), k) - max(i+1, j))\\n        return ans % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = j = k = 0 \\n        for i in range(1, len(nums)): \\n            j = max(j, i+1)\\n            while j < len(nums) and 2*prefix[i] > prefix[j]: j += 1\\n            k = max(k, j)\\n            while k < len(nums) and 2*prefix[k] <= prefix[i] + prefix[-1]: k += 1\\n            ans += k - j \\n        return ans % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999099,
                "title": "c-solution-greedy-approach",
                "content": "**Solution:**\\n\\nConsiderig every prefix of the array as the \\'left\\' subarray count the number of possible \\'middle\\' subarrays and add them to the final answer.\\n\\n**Explanation:**\\n\\n* Make a prefix sum array. \\n* Now start traversing the array and assume the sum[i] to be the sum of \\'left\\' array. \\n* The \\'middle\\' array has to be atleast this sum so use binary search over the prefix sum array to find the starting value\\n* The maximum possible value for the \\'middle\\' array is the (sum of array - left array sum)/2 again find the ending value using the binary search. \\n* Having the starting and ending possible indexes of \\'middle\\' array we will add the count to the final answer.\\n```\\nint mod = 1e9+7;\\n    \\n    int waysToSplit(vector<int>& nums) {\\n        \\n        int i, left, remaining, mid_startpoint, mid_endpoint, max_mid, length, n = nums.size();\\n        vector<int>sum(n, 0);\\n        \\n        long long ans=0;\\n        \\n        sum[0] = nums[0];\\n        for(i = 1; i < n; i++) \\n            sum [i] = sum[i-1] + nums[i];\\n        \\n        for(i = 0; i < n; i++) {\\n            \\n            left = sum[i];\\n            remaining = sum[n-1] - left;\\n\\n            max_mid = remaining/2;\\n                 \\n            mid_startpoint = lower_bound(sum.begin() + i + 1, sum.end(), sum[i] + left) - sum.begin();\\n            \\n            // have to apply search upto n-1 otherwise an empty right part will also be counted\\n            mid_endpoint = upper_bound(sum.begin() + i + 1, sum.begin() + n - 1  , sum[i] + max_mid) - sum.begin();\\n            mid_endpoint--;\\n\\n            length = (mid_endpoint - mid_startpoint + 1);\\n            \\n            ans += max(0, length);\\n            \\n        }\\n        \\n        return ans % mod;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint mod = 1e9+7;\\n    \\n    int waysToSplit(vector<int>& nums) {\\n        \\n        int i, left, remaining, mid_startpoint, mid_endpoint, max_mid, length, n = nums.size();\\n        vector<int>sum(n, 0);\\n        \\n        long long ans=0;\\n        \\n        sum[0] = nums[0];\\n        for(i = 1; i < n; i++) \\n            sum [i] = sum[i-1] + nums[i];\\n        \\n        for(i = 0; i < n; i++) {\\n            \\n            left = sum[i];\\n            remaining = sum[n-1] - left;\\n\\n            max_mid = remaining/2;\\n                 \\n            mid_startpoint = lower_bound(sum.begin() + i + 1, sum.end(), sum[i] + left) - sum.begin();\\n            \\n            // have to apply search upto n-1 otherwise an empty right part will also be counted\\n            mid_endpoint = upper_bound(sum.begin() + i + 1, sum.begin() + n - 1  , sum[i] + max_mid) - sum.begin();\\n            mid_endpoint--;\\n\\n            length = (mid_endpoint - mid_startpoint + 1);\\n            \\n            ans += max(0, length);\\n            \\n        }\\n        \\n        return ans % mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003178,
                "title": "this-problem-should-be-under-leetcode-hard",
                "content": "Though the concepts used in this problem is of medium level, the thought process to come up with the solution using prefix sum coupled with binary search is difficult especially during a contest.\\n\\nMy solution : \\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n + 1];\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }\\n        int mod = 1000000007;\\n        long count = 0;\\n        \\n        for (int i = 0; i < n - 2; i++) {\\n            int x = prefix[i];\\n            int y = 2 * x;\\n            int low = i + 1;\\n            int high = n - 2;\\n            int ans = -1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (prefix[mid] >= y) {\\n                    ans = mid;\\n                    high = mid - 1;\\n                } \\n                else low = mid + 1;\\n            }\\n            if (ans == -1) continue;\\n            low = ans;\\n            int ans2 = -1;\\n            high = n - 2;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                 int diff2 = prefix[n - 1] - prefix[mid];\\n                int diff1 = prefix[mid] - prefix[i];\\n                if (diff1 <= diff2) {\\n                    ans2 = mid;\\n                    low = mid + 1;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n                \\n            }\\n            if (ans2 == -1) continue;\\n            count += (ans2 - ans + 1);\\n       \\n        }\\n        return (int)(count % mod);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n + 1];\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 999288,
                "title": "c-a-clean-implementation",
                "content": "Suppose we split our array into 3 parts, with sum as `a    |    (sum - (a + b)    |    b`. To satisfy the constraints, we must have\\n\\n`a <= sum - (a + b)` and `sum - (a + b) <= b`. \\n\\nSuppose, we fix `b`, then we have `(sum - 2b) <= a <= (sum - b)/2`.\\n\\nSo, we need to fix each possible `b`, and find out the the number of elements in the range `[low, high]` which are to the left of the segment containing `b`. (Note that we have to reserve atleast one block for the mid element, so, if the suffix segment starts at `i`, we only have to look for `a` in the region `[0, i - 2]`).\\n\\nSo, this brings us to another abstraction, **How to find the number of elements in an inclusive range?**. Notice that the prefix sum array is always sorted (in case of non negative integers). So, we can use the `upper_bound` and `lower_bound` feature in STL. Recall that `lower_bound` returns the iterator to the first element which is not less than `key`, while `upper_bound` returns an iterator to the first element which is strictly greater than key. Hence, all elements in between lie in our inclusive range.\\n\\n\\nTo summarise, iterate through each suffix, leave one block for middle element, and binary search the permissible elements in the prefix. \\n\\nTime complexity is `O(n log(n))`\\n```\\nconst int mod = 1e9 + 7;\\n\\nint count_bet(vector<int> &a, int ind, int low, int high) {\\n    if(low > high) return 0;\\n    \\n    auto l_itr = lower_bound(a.begin(), a.begin() + ind, low);\\n    auto r_itr = upper_bound(a.begin(), a.begin() + ind, high);\\n    return (r_itr - l_itr);\\n}\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& a) {\\n        int n = a.size();\\n\\t\\t\\n        auto pref = a;\\n        for(int i = 1; i < n; i++) {\\n            pref[i] += pref[i - 1];\\n        }\\n        \\n        int sum = pref.back();\\n        long long cnt = 0;\\n        \\n        int suf = 0;\\n        for(int i = n - 1; i >= 2; i--) {\\n            suf += a[i];\\n            auto in_bet = count_bet(pref, i - 1, sum - 2*suf, (sum - suf)/2);\\n            cnt = (cnt + in_bet) % mod;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int mod = 1e9 + 7;\\n\\nint count_bet(vector<int> &a, int ind, int low, int high) {\\n    if(low > high) return 0;\\n    \\n    auto l_itr = lower_bound(a.begin(), a.begin() + ind, low);\\n    auto r_itr = upper_bound(a.begin(), a.begin() + ind, high);\\n    return (r_itr - l_itr);\\n}\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& a) {\\n        int n = a.size();\\n\\t\\t\\n        auto pref = a;\\n        for(int i = 1; i < n; i++) {\\n            pref[i] += pref[i - 1];\\n        }\\n        \\n        int sum = pref.back();\\n        long long cnt = 0;\\n        \\n        int suf = 0;\\n        for(int i = n - 1; i >= 2; i--) {\\n            suf += a[i];\\n            auto in_bet = count_bet(pref, i - 1, sum - 2*suf, (sum - suf)/2);\\n            cnt = (cnt + in_bet) % mod;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447421,
                "title": "python-3-binary-search-explanation",
                "content": "### Explanation\\n- Calculate prefix sum and store at `pre_sum`\\n- Iterate each index `i` and consider it as the ending index of the 1st segment\\n- Do _**binary search**_ on the 2nd segment ending index. This is doable because `pre_sum` is a non-decreasing array\\n\\t- `[i+1, j]` is the shortest possible segment of the 2nd segment (`bisect_left`)\\n\\t\\t- Condition to find: `pre_sum[i] * 2 <= pre_sum[j]`\\n\\t\\t- Meaning the 2nd segment sum will not be less than the 1st segment sum\\n\\t- `[i+1, k-1]` is the longest possible segment of the 2nd segment (`bisect_right`)\\n\\t\\t- Condition to find: `pre_sum[k-1] - pre_sum[i] <= pre_sum[-1] - pre_sum[k-1]`\\n\\t\\t- Meaning the 3rd segment sum will not be less than the 2dn segment sum\\n\\t- For example, all combinations below will be acceptable\\n\\t```\\n\\t\\t\\t# [0, i], [i+1, j], [j+1, n-1]\\n\\t\\t\\t# [0, i], [i+1, j+1], [j+2, n-1]\\n\\t\\t\\t# [0, i], [i+1, ...], [..., n-1]\\n\\t\\t\\t# [0, i], [i+1, k-2], [k-1, n-1]\\n\\t\\t\\t# [0, i], [i+1, k-1], [k, n-1]\\n\\t```\\n- Don\\'t forget to handle the edge case when `k == n`\\n- Time: `O(NlogN)`\\n- Space: `O(N)`\\n### Implementation\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod, pre_sum = int(1e9+7), [nums[0]]\\n        for num in nums[1:]:                               # create prefix sum array\\n            pre_sum.append(pre_sum[-1] + num)\\n        ans, n = 0, len(nums)\\n        for i in range(n):                                 # pre_sum[i] is the sum of the 1st segment\\n            prev = pre_sum[i]                              # i+1 is the starting index of the 2nd segment\\n            if prev * 3 > pre_sum[-1]: break               # break loop if first segment is larger than the sum of 2 & 3 segments\\n                \\n            j = bisect.bisect_left(pre_sum, prev * 2, i+1) # j is the first possible ending index of 2nd segment\\n                \\n            middle = (prev + pre_sum[-1]) // 2             # last possible ending value of 2nd segment\\n            k = bisect.bisect_right(pre_sum, middle, j+1)  # k-1 is the last possible ending index of 2nd segment\\n            if k-1 >= n or pre_sum[k-1] > middle: continue # make sure the value satisfy the condition since we are using bisect_right here\\n            ans = (ans + min(k, n - 1) - j) % mod          # count & handle edge case\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n\\t\\t\\t# [0, i], [i+1, j], [j+1, n-1]\\n\\t\\t\\t# [0, i], [i+1, j+1], [j+2, n-1]\\n\\t\\t\\t# [0, i], [i+1, ...], [..., n-1]\\n\\t\\t\\t# [0, i], [i+1, k-2], [k-1, n-1]\\n\\t\\t\\t# [0, i], [i+1, k-1], [k, n-1]\\n\\t```\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod, pre_sum = int(1e9+7), [nums[0]]\\n        for num in nums[1:]:                               # create prefix sum array\\n            pre_sum.append(pre_sum[-1] + num)\\n        ans, n = 0, len(nums)\\n        for i in range(n):                                 # pre_sum[i] is the sum of the 1st segment\\n            prev = pre_sum[i]                              # i+1 is the starting index of the 2nd segment\\n            if prev * 3 > pre_sum[-1]: break               # break loop if first segment is larger than the sum of 2 & 3 segments\\n                \\n            j = bisect.bisect_left(pre_sum, prev * 2, i+1) # j is the first possible ending index of 2nd segment\\n                \\n            middle = (prev + pre_sum[-1]) // 2             # last possible ending value of 2nd segment\\n            k = bisect.bisect_right(pre_sum, middle, j+1)  # k-1 is the last possible ending index of 2nd segment\\n            if k-1 >= n or pre_sum[k-1] > middle: continue # make sure the value satisfy the condition since we are using bisect_right here\\n            ans = (ans + min(k, n - 1) - j) % mod          # count & handle edge case\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999795,
                "title": "c-3-pointers-o-n-time-o-1-space",
                "content": "## Solution 1. Three Pointers\\n\\nTurn array `A` into its prefix sum array. \\n\\nLet `i` be the last index of the `left` part. So `A[i]` is the sum of the `left` part.\\n\\nGiven `i`, the last index of the `mid` part is a range. Let it be `[j, k)`.\\n\\nWhen we increment `i`, `j` and `k` must be monotonically increasing.\\n\\nTo find `j`, we can increment `j` from `i + 1` until `mid >= left` i.e. `A[j] - A[i] >= A[i]`.\\n\\nTo find `k`, we can increment `k` from `j` until `mid < right`, i.e. `A[N - 1] - A[k] < A[k] - A[i]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& A) {\\n        long mod = 1e9+7, ans = 0;\\n        for (int i = 1; i < A.size(); ++i) A[i] += A[i - 1];\\n        long N = A.size(), i = 0, j = 0, k = 0;\\n        for (; i < N; ++i) {\\n            long left = A[i];\\n            j = max(i + 1, j); // `j` is at least one greater than `i`.\\n            while (j < N && A[j] - left < left) ++j; // find the smallest `j` that satisfies `mid >= left`\\n            if (j >= N) break; // No room for `k`. Break\\n            k = max(k, j);\\n            while (k < N - 1 && A.back() - A[k] >= A[k] - A[i]) ++k;\\n            ans = (ans + k - j) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& A) {\\n        long mod = 1e9+7, ans = 0;\\n        for (int i = 1; i < A.size(); ++i) A[i] += A[i - 1];\\n        long N = A.size(), i = 0, j = 0, k = 0;\\n        for (; i < N; ++i) {\\n            long left = A[i];\\n            j = max(i + 1, j); // `j` is at least one greater than `i`.\\n            while (j < N && A[j] - left < left) ++j; // find the smallest `j` that satisfies `mid >= left`\\n            if (j >= N) break; // No room for `k`. Break\\n            k = max(k, j);\\n            while (k < N - 1 && A.back() - A[k] >= A[k] - A[i]) ++k;\\n            ans = (ans + k - j) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999236,
                "title": "java-prefix-sum-binary-search-for-left-right-cutpoint",
                "content": "```\\nclass Solution {\\n    public int waysToSplit(int[] A) {\\n        long res=0;\\n        int mod=1000000007;\\n        int sum=0;\\n        int pre[]=new int[A.length];\\n        \\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            pre[i]=sum;\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            int left=pre[i];\\n            int l=i+1,r=A.length-2;//ensure the right have at least 1 element\\n            int leftbound=-1;\\n            int rightbound=-1;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                int mid=pre[m]-left;\\n                if(mid>=left){\\n                    leftbound=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            \\n            l=i+1;r=A.length-2;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                int mid=pre[m]-left;\\n                int right=sum-mid-left;\\n                if(right>=mid){\\n                    rightbound=m;\\n                    l=m+1;\\n                }\\n                else{\\n                    r=m-1;\\n                }\\n            }\\n\\t\\t\\t\\n            if(rightbound==-1||leftbound==-1||leftbound>rightbound)continue;\\n            int dif=rightbound-leftbound+1;//as we have the bound, we can cut at anyplace within this bound\\n            res+=dif;\\n            res%=mod;\\n            \\n        }\\n        return (int)(res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] A) {\\n        long res=0;\\n        int mod=1000000007;\\n        int sum=0;\\n        int pre[]=new int[A.length];\\n        \\n        for(int i=0;i<A.length;i++){\\n            sum+=A[i];\\n            pre[i]=sum;\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            int left=pre[i];\\n            int l=i+1,r=A.length-2;//ensure the right have at least 1 element\\n            int leftbound=-1;\\n            int rightbound=-1;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                int mid=pre[m]-left;\\n                if(mid>=left){\\n                    leftbound=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            \\n            l=i+1;r=A.length-2;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                int mid=pre[m]-left;\\n                int right=sum-mid-left;\\n                if(right>=mid){\\n                    rightbound=m;\\n                    l=m+1;\\n                }\\n                else{\\n                    r=m-1;\\n                }\\n            }\\n\\t\\t\\t\\n            if(rightbound==-1||leftbound==-1||leftbound>rightbound)continue;\\n            int dif=rightbound-leftbound+1;//as we have the bound, we can cut at anyplace within this bound\\n            res+=dif;\\n            res%=mod;\\n            \\n        }\\n        return (int)(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626298,
                "title": "c-binary-search-nlogn",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION**\\n\\n```\\nclass Solution {\\n    const int M=1e9+7;\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        //calculate the prefix-sum array\\n        for(int i=1;i<n;i++)\\n            nums[i]+=nums[i-1];\\n        \\n        int count=0;\\n        for(int i=0;i<=n-1;i++)\\n        {\\n            //we need to have at least one element in the 1st and 3rd group so we consider lo=i+1 && hi=n-2\\n            int lo=i+1,hi=n-2,right=-1,left=-1;\\n    \\n            //we calculate the right-most valid index\\n            while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(nums[mid]-nums[i]<=nums.back()-nums[mid])\\n                {\\n                    right=mid;\\n                    lo=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n            \\n            lo=i+1;hi=n-2;\\n            //we calculate the left-most valid index\\n             while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(nums[i]<=nums[mid]-nums[i])\\n                {\\n                    left=mid;\\n                    hi=mid-1;\\n                }\\n                else\\n                    lo=mid+1;\\n            }\\n            //invalid condition check i.e. if one of the bound does not exist \\n            //or left bound is greater than right bound\\n            if(left==-1||right==-1||left>right)continue;\\n            \\n            count=(count+(right-left+1)%M)%M;\\n        }\\n        return count%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    const int M=1e9+7;\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        //calculate the prefix-sum array\\n        for(int i=1;i<n;i++)\\n            nums[i]+=nums[i-1];\\n        \\n        int count=0;\\n        for(int i=0;i<=n-1;i++)\\n        {\\n            //we need to have at least one element in the 1st and 3rd group so we consider lo=i+1 && hi=n-2\\n            int lo=i+1,hi=n-2,right=-1,left=-1;\\n    \\n            //we calculate the right-most valid index\\n            while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(nums[mid]-nums[i]<=nums.back()-nums[mid])\\n                {\\n                    right=mid;\\n                    lo=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n            \\n            lo=i+1;hi=n-2;\\n            //we calculate the left-most valid index\\n             while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(nums[i]<=nums[mid]-nums[i])\\n                {\\n                    left=mid;\\n                    hi=mid-1;\\n                }\\n                else\\n                    lo=mid+1;\\n            }\\n            //invalid condition check i.e. if one of the bound does not exist \\n            //or left bound is greater than right bound\\n            if(left==-1||right==-1||left>right)continue;\\n            \\n            count=(count+(right-left+1)%M)%M;\\n        }\\n        return count%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999112,
                "title": "java-two-pointer-o-n-solution-with-detailed-explanation",
                "content": "Assume L/M/R are sums of three subarrarys:\\n* `j` is the start index of the right subarray\\n* `i1` is the maximum start index of the middle subarray that NOT qualifies `M <= R` when `j` is fixed\\n* `i2` is the maximum start index of the middle subarray that qualifies `L <= M` when `j` is fixed\\n\\nWe can fix right subarray each time, and use **binary search** to find `i1` and `i2`. But we also notice that for adjacent `j`s, there is a correlation between their corresponding `i1`s and `i2`s, so we can do it better.\\n\\nDetailed explanation:\\n* pre-calculate prefix sum (can be eliminated to further improve space complexity)\\n* move `j` from right to left\\n* when `j` moves left one element, `R` will increase and `M` will decrease\\n* thus, both `i1` and `i2` has to move to the left side to meet the above requirements\\n* so we move `i1` and `i2` to the left until the above requirements are met, then add `i2 - i1` to the res\\n\\ntime complexity: O(n)\\nspace complexity: O(n), can be optimized to O(1) by memorizing `prefix[i1]`, `prefix[i2]`, `prefix[j]`\\n\\n```\\nclass Solution {\\n  public int waysToSplit(int[] nums) {\\n    final int N = nums.length;\\n    int[] prefix = new int[N + 1];\\n    for (int i = 0; i < N; i++) {\\n      prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n    long res = 0;\\n    int i1 = N - 2;\\n    int i2 = N - 2;\\n    for (int j = N - 1; j >= 2; j--) {\\n      int right = prefix[N] - prefix[j];\\n      while (i1 > 0 && prefix[j] - prefix[i1] <= right) {\\n\\t    // M <= R\\n        i1--;\\n      }\\n      i2 = Math.min(i2, j - 1);\\n      while (i2 > 0 && prefix[i2] > prefix[j] - prefix[i2]) {\\n\\t    // L > M\\n        i2--;\\n      }\\n      if (i2 > i1 && i1 >= 0) {\\n        res += (long) (i2 - i1);\\n      }      \\n    }    \\n    return (int) (res % 1_000_000_007);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int waysToSplit(int[] nums) {\\n    final int N = nums.length;\\n    int[] prefix = new int[N + 1];\\n    for (int i = 0; i < N; i++) {\\n      prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n    long res = 0;\\n    int i1 = N - 2;\\n    int i2 = N - 2;\\n    for (int j = N - 1; j >= 2; j--) {\\n      int right = prefix[N] - prefix[j];\\n      while (i1 > 0 && prefix[j] - prefix[i1] <= right) {\\n\\t    // M <= R\\n        i1--;\\n      }\\n      i2 = Math.min(i2, j - 1);\\n      while (i2 > 0 && prefix[i2] > prefix[j] - prefix[i2]) {\\n\\t    // L > M\\n        i2--;\\n      }\\n      if (i2 > i1 && i1 >= 0) {\\n        res += (long) (i2 - i1);\\n      }      \\n    }    \\n    return (int) (res % 1_000_000_007);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004218,
                "title": "clean-binary-search-solution-in-c",
                "content": "```\\n  int waysToSplit(vector<int>& nums) {\\n    int ans = 0, m = 1e9+7, leftsum, totalsum;\\n    vector<int> sums(nums.size()); // prefix sums\\n    partial_sum(nums.begin(), nums.end(), sums.begin());\\n    totalsum = *sums.rbegin();\\n    \\n    // i: iterator to the last element of left\\n    // j: iterator to the left-most last element of mid\\n    // k: iterator to the right-most last element of mid\\n    for (auto i = sums.begin(); i < sums.end() - 2; i++) {\\n      leftsum = *i;\\n      int midsum_max = (totalsum - leftsum) / 2;\\n      if (leftsum > midsum_max) break;\\n      auto j = lower_bound(i+1, sums.end()-1, 2*leftsum);\\n      auto k = upper_bound(i+1, sums.end()-1, leftsum + midsum_max);\\n      ans = (ans + k - j) % m;\\n    }\\n    return ans;\\n  }\\n  ```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  int waysToSplit(vector<int>& nums) {\\n    int ans = 0, m = 1e9+7, leftsum, totalsum;\\n    vector<int> sums(nums.size()); // prefix sums\\n    partial_sum(nums.begin(), nums.end(), sums.begin());\\n    totalsum = *sums.rbegin();\\n    \\n    // i: iterator to the last element of left\\n    // j: iterator to the left-most last element of mid\\n    // k: iterator to the right-most last element of mid\\n    for (auto i = sums.begin(); i < sums.end() - 2; i++) {\\n      leftsum = *i;\\n      int midsum_max = (totalsum - leftsum) / 2;\\n      if (leftsum > midsum_max) break;\\n      auto j = lower_bound(i+1, sums.end()-1, 2*leftsum);\\n      auto k = upper_bound(i+1, sums.end()-1, leftsum + midsum_max);\\n      ans = (ans + k - j) % m;\\n    }\\n    return ans;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 999385,
                "title": "c-o-nlogn-8-liners-prefix-and-binary-search-solution-with-brief-explanation-and-comments",
                "content": "Idea:\\n1. sum(subarray1)<=sum(nums)/3\\n2. sum(subarray2)>=sum(subarray1) and sum(subarray2)<=(sum(nums)-sum(subarray1))/2\\n->so that sum(subarray3)>=sum(subarray2)>=sum(subarray1)\\n3. use nums directly to save space\\n```\\nint waysToSplit(vector<int>& nums) \\n{\\n\\tlong result=0,n=nums.size(),d=1000000007;\\n\\tfor(int i=1;i<n;i++) nums[i]+=nums[i-1]; //use nums for prefix sum to save space\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tif(nums[i]>nums.back()/3) break; //so that sum(subarray1)<=sum(nums)/3\\n\\n\\t\\tvector<int>::iterator low=lower_bound(nums.begin()+i+1,nums.end()-1,2*nums[i]); //so sum(subarray2)>=sum(subarray1)\\n\\t\\tvector<int>::iterator up=upper_bound(low,nums.end()-1,nums[i]+(nums.back()-nums[i])/2); //so that sum(subarray2)<=sum(subarray3)\\n\\t\\tresult=(result+up-low)%d;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint waysToSplit(vector<int>& nums) \\n{\\n\\tlong result=0,n=nums.size(),d=1000000007;\\n\\tfor(int i=1;i<n;i++) nums[i]+=nums[i-1]; //use nums for prefix sum to save space\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tif(nums[i]>nums.back()/3) break; //so that sum(subarray1)<=sum(nums)/3\\n\\n\\t\\tvector<int>::iterator low=lower_bound(nums.begin()+i+1,nums.end()-1,2*nums[i]); //so sum(subarray2)>=sum(subarray1)\\n\\t\\tvector<int>::iterator up=upper_bound(low,nums.end()-1,nums[i]+(nums.back()-nums[i])/2); //so that sum(subarray2)<=sum(subarray3)\\n\\t\\tresult=(result+up-low)%d;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999596,
                "title": "easy-c-ways-to-split-array-into-three-subarrays",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size(), mod = 1e9 + 7;  long long ans = 0;\\n        vector<int> prefix(n);\\n        partial_sum(nums.begin(), nums.end(),prefix.begin());\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = prefix[i], remain = (prefix[n - 1] - prefix[i]);\\n                if (remain < left * 2) break;\\n            int leftPtr = lower_bound(prefix.begin() + i + 1, prefix.end() - 1, left * 2) - prefix.begin();\\n            int rightPtr = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, left + remain / 2) - prefix.begin() - 1;\\n\\n            if (rightPtr - leftPtr + 1 > 0) ans += rightPtr - leftPtr + 1;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```\\n# Quick Explanation\\n```\\nStep 1. Initilise n= size of vector and ans=0 and mod = 1e9 +7\\nStep 2. Create a prefix sum vector name prefix\\nStep 3. Loop thourgh the prefix vector\\nStep 4. Calculate Lower bound of prefix[i] and Upper bound of prefix[i] + (prefix[n-1] - prefix[i])/2\\nStep 5. If difference of UB and LB +1 is positive then add them to answer.\\nStep 6. return ans with moduls\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size(), mod = 1e9 + 7;  long long ans = 0;\\n        vector<int> prefix(n);\\n        partial_sum(nums.begin(), nums.end(),prefix.begin());\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = prefix[i], remain = (prefix[n - 1] - prefix[i]);\\n                if (remain < left * 2) break;\\n            int leftPtr = lower_bound(prefix.begin() + i + 1, prefix.end() - 1, left * 2) - prefix.begin();\\n            int rightPtr = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, left + remain / 2) - prefix.begin() - 1;\\n\\n            if (rightPtr - leftPtr + 1 > 0) ans += rightPtr - leftPtr + 1;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```\n```\\nStep 1. Initilise n= size of vector and ans=0 and mod = 1e9 +7\\nStep 2. Create a prefix sum vector name prefix\\nStep 3. Loop thourgh the prefix vector\\nStep 4. Calculate Lower bound of prefix[i] and Upper bound of prefix[i] + (prefix[n-1] - prefix[i])/2\\nStep 5. If difference of UB and LB +1 is positive then add them to answer.\\nStep 6. return ans with moduls\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680728,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "* ****Using Prefix Sum and Binary Search****\\n* ****Let i and j be the left _boundary && j be the right_boundary : arr[i] <= arr[j] - arr[i] <= arr[n-1] - arr[j]****\\n* ****After Simplifying the above inequality , we get arr[j] >= 2 * arr[i]  && arr[j] <= (arr[n-1] + arr[i])/2****\\n\\n1. ***Time Complexity : O(NlogN)***\\n2. ***Space Complexity : O(N)***\\n\\n```\\n    int mod = 1e9 + 7;\\n    \\n    int find_left_boundary(vector<int> &arr, int start, int end, int i, int n)\\n    {\\n        int left_boundary = n;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            \\n            if(arr[mid] >= 2 * arr[i])\\n            {\\n                left_boundary = mid;\\n                \\n                end = mid - 1;\\n            }\\n            \\n            else{\\n                \\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return left_boundary;\\n    }\\n    \\n    int find_right_boundary(vector<int> &arr, int start, int end, int i, int n)\\n    {\\n        int right_boundary = i;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            \\n            if(arr[mid] <= (arr[n-1] + arr[i]) / 2)\\n            {\\n                right_boundary = mid;\\n                \\n                start = mid + 1;\\n            }\\n            \\n            else{\\n                \\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return right_boundary;\\n    }\\n    \\n    int waysToSplit(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int ans = 0;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        for(int i = 0; i <= n - 3; i++)\\n        {\\n            int left_boundary = find_left_boundary(arr, i + 1, n - 2, i, n);\\n            \\n            int right_boundary = find_right_boundary(arr, i + 1, n - 2, i, n);\\n            \\n            if(right_boundary >= left_boundary)\\n            {\\n                ans = (ans % mod + (right_boundary - left_boundary + 1) % mod ) % mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n    int mod = 1e9 + 7;\\n    \\n    int find_left_boundary(vector<int> &arr, int start, int end, int i, int n)\\n    {\\n        int left_boundary = n;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            \\n            if(arr[mid] >= 2 * arr[i])\\n            {\\n                left_boundary = mid;\\n                \\n                end = mid - 1;\\n            }\\n            \\n            else{\\n                \\n                start = mid + 1;\\n            }\\n        }\\n        \\n        return left_boundary;\\n    }\\n    \\n    int find_right_boundary(vector<int> &arr, int start, int end, int i, int n)\\n    {\\n        int right_boundary = i;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            \\n            if(arr[mid] <= (arr[n-1] + arr[i]) / 2)\\n            {\\n                right_boundary = mid;\\n                \\n                start = mid + 1;\\n            }\\n            \\n            else{\\n                \\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return right_boundary;\\n    }\\n    \\n    int waysToSplit(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int ans = 0;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            arr[i] += arr[i-1];\\n        }\\n        \\n        for(int i = 0; i <= n - 3; i++)\\n        {\\n            int left_boundary = find_left_boundary(arr, i + 1, n - 2, i, n);\\n            \\n            int right_boundary = find_right_boundary(arr, i + 1, n - 2, i, n);\\n            \\n            if(right_boundary >= left_boundary)\\n            {\\n                ans = (ans % mod + (right_boundary - left_boundary + 1) % mod ) % mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441032,
                "title": "solution-by-average-coder-if-you-are-struggling-check-it-once",
                "content": "```\\nTo all average coders out there like me,i know many are struggling to understand these long codes\\nwell let me explain :)\\n\\nconsider --> (1,1,1) by this example we can understand we can divide it by (1),(1),(1)\\nso basically to get sum of subarrays we will use prefix sum array right!, then \\n\\n1,to satisfy 2nd part greater than first part,its value must be min of first part ,so we choose the index of lower bound of left part sum L[i],\\n2,ans same to third part 2nd part value should can have max of third part value,which is half of remaining sum ,as we already cutted l[i]\\n\\njust try to understand clearly by pen and paper using this example: (1,2,2,5,0)\\nhere sum is 12\\nprefix sum array is (1 3 5 10 10)\\nso here\\ncase one:left part: 1\\nthen middle part prefix sum should have atleast 2*1=2;\\nand max can go upto half of remaning sum,as rest half would be third part right?,are you getting it?\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n        \\n        vector<int>pre(n,0);\\n        pre[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n            pre[i]=pre[i-1]+nums[i];\\n        \\n        long long int ans=0;\\n        int l,r;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          l=pre[i];\\n          r=pre[nums.size()-1]-l;\\n          int x=lower_bound(pre.begin()+i+1,pre.end(),2*l)-pre.begin();\\n          int y=upper_bound(pre.begin()+i+1,pre.begin()+nums.size()-1,l+r/2)-pre.begin();\\n            \\n            if(y>x)\\n                ans+=y-x;\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n        \\n        vector<int>pre(n,0);\\n        pre[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n            pre[i]=pre[i-1]+nums[i];\\n        \\n        long long int ans=0;\\n        int l,r;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          l=pre[i];\\n          r=pre[nums.size()-1]-l;\\n          int x=lower_bound(pre.begin()+i+1,pre.end(),2*l)-pre.begin();\\n          int y=upper_bound(pre.begin()+i+1,pre.begin()+nums.size()-1,l+r/2)-pre.begin();\\n            \\n            if(y>x)\\n                ans+=y-x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2914881,
                "title": "using-prefix-sum-binary-search-c-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int> pre(n,0);\\n           pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        pre[i]=pre[i-1]+nums[i];\\n        int mod=1e9+7;\\n        // 1 3 5 7 12 12 \\n        for(int i=0;i<n;i++)\\n        {\\n           int low=lower_bound(pre.begin()+i+1,pre.end(),2*pre[i])-pre.begin();//it will return min boundary if we have middle subarray sum equal to first sub array sum(we are checking 2*pre[i] because it is prefix sum and we do not have to conside first subarray sum i.e pre[i])\\n           int up=upper_bound(pre.begin()+i+1,pre.begin()+n-1,pre[i]+((pre[n-1]-pre[i])/2))-pre.begin();//max for second subarray will (remaing part)/2 \\n           ans+=(max(0,(up-low)))%mod;\\n           ans=ans%mod;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int> pre(n,0);\\n           pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        pre[i]=pre[i-1]+nums[i];\\n        int mod=1e9+7;\\n        // 1 3 5 7 12 12 \\n        for(int i=0;i<n;i++)\\n        {\\n           int low=lower_bound(pre.begin()+i+1,pre.end(),2*pre[i])-pre.begin();//it will return min boundary if we have middle subarray sum equal to first sub array sum(we are checking 2*pre[i] because it is prefix sum and we do not have to conside first subarray sum i.e pre[i])\\n           int up=upper_bound(pre.begin()+i+1,pre.begin()+n-1,pre[i]+((pre[n-1]-pre[i])/2))-pre.begin();//max for second subarray will (remaing part)/2 \\n           ans+=(max(0,(up-low)))%mod;\\n           ans=ans%mod;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257189,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int M=1e9+7;\\n        vector<long long>pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        long long ans=0;\\n        for(int i=0;i<=n-3;i++){\\n            long long leftSum=pre[i];\\n            int l=i+1;\\n            int r=n-2;\\n            int p1=-1,p2=-1;\\n            //finding end point of range i.e. p2\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                \\n                long long midSum=pre[m]-leftSum;\\n                long long rightSum=pre[n-1]-pre[m];\\n                if(midSum<=rightSum)\\n                    p2=m,l=m+1;\\n                else\\n                    r=m-1;\\n            }\\n            \\n            //finding start point of range i.e. p1\\n            l=i+1;\\n            r=p2;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                \\n                long long midSum=pre[m]-leftSum;\\n                if(leftSum<=midSum)\\n                    p1=m,r=m-1;\\n                else\\n                    l=m+1;\\n            }\\n            \\n            if(p1!=-1 && p2!=-1 && p1<=p2)\\n                ans+=(p2-p1+1);\\n            ans=ans%M;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n// <---------------><-----------------><------------------->\\n//    leftSum        p1                p2        rightSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int M=1e9+7;\\n        vector<long long>pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        long long ans=0;\\n        for(int i=0;i<=n-3;i++){\\n            long long leftSum=pre[i];\\n            int l=i+1;\\n            int r=n-2;\\n            int p1=-1,p2=-1;\\n            //finding end point of range i.e. p2\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                \\n                long long midSum=pre[m]-leftSum;\\n                long long rightSum=pre[n-1]-pre[m];\\n                if(midSum<=rightSum)\\n                    p2=m,l=m+1;\\n                else\\n                    r=m-1;\\n            }\\n            \\n            //finding start point of range i.e. p1\\n            l=i+1;\\n            r=p2;\\n            while(l<=r){\\n                int m=l+(r-l)/2;\\n                \\n                long long midSum=pre[m]-leftSum;\\n                if(leftSum<=midSum)\\n                    p1=m,r=m-1;\\n                else\\n                    l=m+1;\\n            }\\n            \\n            if(p1!=-1 && p2!=-1 && p1<=p2)\\n                ans+=(p2-p1+1);\\n            ans=ans%M;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n// <---------------><-----------------><------------------->\\n//    leftSum        p1                p2        rightSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000705,
                "title": "python-clear-prefix-sum-binary-search-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/tSYfTRau5HE\\n\\nIntuition: Prefix Sum+Binary Search\\n\\n**Code**\\n\\nInspired by https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/999157/Python3-binary-search-and-2-pointer\\n\\n```\\nfrom bisect import *\\n\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod = 10**9+7\\n        \\n        pre_sum = [0]\\n        for num in nums: \\n            pre_sum.append(pre_sum[-1]+num)\\n        \\n        res = 0\\n        \\n        for i in range(1, len(nums)): \\n            l = bisect_left(pre_sum, 2*pre_sum[i])\\n            r = bisect_right(pre_sum, (pre_sum[i]+pre_sum[-1])//2)\\n            res += max(0, min(len(nums), r)-max(i+1, l))\\n            \\n        return res%mod\\n```\\n\\nTime: O(nlogn) / Space: O(n)\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import *\\n\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod = 10**9+7\\n        \\n        pre_sum = [0]\\n        for num in nums: \\n            pre_sum.append(pre_sum[-1]+num)\\n        \\n        res = 0\\n        \\n        for i in range(1, len(nums)): \\n            l = bisect_left(pre_sum, 2*pre_sum[i])\\n            r = bisect_right(pre_sum, (pre_sum[i]+pre_sum[-1])//2)\\n            res += max(0, min(len(nums), r)-max(i+1, l))\\n            \\n        return res%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000544,
                "title": "python-good-practice-of-bisect",
                "content": "`L \\u2264 M \\u2264 R` or `S[:i] \\u2264 S[i:j] \\u2264 S[j:]` where S is the prefix sum array.\\nGiven that all elements are non-negative, S is a non decreasing array so we can use binary search to search a valid range of `M` for each index `i`.\\nSuppose `M`\\'s left end is `i+1` and right end range is `[j, k)`, `ans += k-j` for `nums[i]`.\\n\\nThe idea is easy to come up, but the implementation is a good practice of `bisect`. Which value should we search? Which end point should we use? Plus the prefix array `S[i] = sum(nums[:i])` which actually doesn\\'t include `nums[i]`. That could be tricky.\\n\\nSince left end is fixed to be `i+1` for `nums[i]`, it could be `i` for `nums[i-1]`, we can use `S[i]` as `L` when we actually checking the contribution from `nums[i-1]`. And `M` is `S[j]-S[i]` and `R` is `S[n]-S[j]`.\\n\\nI\\'m using `[j, k)` as right end\\'s range, a.k.a an inclusive `j` end and exclusive `k` so I should search `j`  as the smallest value that makes `L \\u2264 M` or `S[i] \\u2264 S[j]-S[i]`. And since `k` is exclusive, I should search `k` as the smallest value that makes `M > R` or `S[j]-S[i] > S[n]-S[j]`. Note `k` is exclusive so `k-1` is the right end of the valid range which should guarantee `M \\u2264 R`. \\n\\nSo we should use `bisect_left` for both searches. For `k`, as `S[j]-S[i] > S[n]-S[j]` or `S[j] > (S[i]+S[n])/2`, I searched  `(S[i]+S[n])//2 + 1`.\\n\\nAnd all the search should be in range `[i+1, n)` as `len(sub_array) > 0`, we can use the `lo` and `hi` parameter provided by `bisect`.\\n\\nLast, once `S[i] > S[n]/3`, we don\\'t have to search any further since `min(M, R) < S[n]/3 < S[i]`.\\n\\n```\\ndef waysToSplit(nums):\\n\\tn = len(nums)\\n\\tS = [0]\\n\\tfor x in nums:\\n\\t\\tS.append(S[-1]+x)\\n\\tans, s = 0, S[n]\\n\\tfor i in range(1, n-1):\\n\\t\\tif S[i] > s/3:\\n\\t\\t\\tbreak\\n\\t\\tj = bisect.bisect_left(S, S[i]<<1, i+1, n)\\n\\t\\tk = bisect.bisect_left(S, ((s+S[i])>>1)+1, j, n)\\n\\t\\tans += k - j\\n\\treturn ans % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef waysToSplit(nums):\\n\\tn = len(nums)\\n\\tS = [0]\\n\\tfor x in nums:\\n\\t\\tS.append(S[-1]+x)\\n\\tans, s = 0, S[n]\\n\\tfor i in range(1, n-1):\\n\\t\\tif S[i] > s/3:\\n\\t\\t\\tbreak\\n\\t\\tj = bisect.bisect_left(S, S[i]<<1, i+1, n)\\n\\t\\tk = bisect.bisect_left(S, ((s+S[i])>>1)+1, j, n)\\n\\t\\tans += k - j\\n\\treturn ans % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3137722,
                "title": "java-solution-8-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        int ways = 0;\\n        for (int i = 0, j = 0, k = 0; i < nums.length - 2 && 3 * nums[i] <= nums[nums.length - 1]; i++) {\\n            j = Math.max(j, i + 1);\\n            while (j < nums.length - 1 && nums[j] - nums[i] < nums[i]) \\n                j++;\\n            k = Math.max(k, j);\\n            while (k < nums.length - 1 && nums[k] - nums[i] <= nums[nums.length - 1] - nums[k]) \\n                k++;\\n            ways = (ways + k - j) % 1000000007;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        int ways = 0;\\n        for (int i = 0, j = 0, k = 0; i < nums.length - 2 && 3 * nums[i] <= nums[nums.length - 1]; i++) {\\n            j = Math.max(j, i + 1);\\n            while (j < nums.length - 1 && nums[j] - nums[i] < nums[i]) \\n                j++;\\n            k = Math.max(k, j);\\n            while (k < nums.length - 1 && nums[k] - nums[i] <= nums[nums.length - 1] - nums[k]) \\n                k++;\\n            ways = (ways + k - j) % 1000000007;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235060,
                "title": "c-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll n = nums.size(), pref[100005], mod = 1e9+7;;\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) pref[i] = pref[i-1]+nums[i];\\n        int cnt = 0;\\n        for(int i = 0; i < n-2; i++) {\\n            ll left = pref[i];\\n            ll rest = pref[n-1]-pref[i];\\n            auto lb = lower_bound(pref+i+1,pref+n-1,2*left);\\n            auto ub = upper_bound(pref+i+1,pref+n-1,rest/2+left);\\n            if(ub-lb > 0) cnt += ub-lb; \\n            cnt %= mod;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll n = nums.size(), pref[100005], mod = 1e9+7;;\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) pref[i] = pref[i-1]+nums[i];\\n        int cnt = 0;\\n        for(int i = 0; i < n-2; i++) {\\n            ll left = pref[i];\\n            ll rest = pref[n-1]-pref[i];\\n            auto lb = lower_bound(pref+i+1,pref+n-1,2*left);\\n            auto ub = upper_bound(pref+i+1,pref+n-1,rest/2+left);\\n            if(ub-lb > 0) cnt += ub-lb; \\n            cnt %= mod;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396045,
                "title": "c-prefix-sum-binary-search-inline-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* \\n        Let i and j be two pointers which splits the array into 3 parts. \\n    \\n        Condition for splitting: nums[i] <= nums[j]-nums[i] <= nums.back() - nums[j];\\n        \\n        which can be simplified to -\\n        1. nums[j] >= 2*nums[i]                     --> (condition for left boundary of j)  \\n        2. nums[j] <= (nums.back() + nums[i]) / 2   --> (condition for right boundary of j)\\n    */\\n    \\n    \\n    /* function to calculate left boundary for j */\\n\\n    int getLeftBoundary (vector<int> & nums, int start, int end, int i, int n){\\n        int bound = n;\\n        \\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(nums[mid] < 2*nums[i])\\n                start = mid+1;\\n            \\n            else{\\n                bound = mid;\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return bound;\\n    }\\n    \\n    \\n    /* Function to calculate right boundary for j */\\n    \\n    int getRightBoundary (vector<int> & nums, int start, int end, int i, int n){\\n        int bound = i;\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n\\n            if(nums[mid] > (nums[n-1] + nums[i])/2)\\n                end = mid-1;\\n            \\n            else{\\n                bound = mid;\\n                start = mid+1;\\n            }\\n        }\\n        \\n        return bound;\\n    }\\n    \\n    \\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        int M = 1000000007; \\n        \\n        /* Computing prefix sum */\\n        \\n        for(int i=1; i<n; i++)\\n            nums[i] += nums[i-1]; \\n        \\n        int ans = 0;\\n        \\n        /* for every i, compute leftBoundary and rightBoundary of j such that it satisfies the conditions */\\n        \\n        for(int i=0; i<n-2; i++){\\n            \\n            int leftBoundary = getLeftBoundary(nums, i+1, n-2, i, n);\\n            int rightBoundary = getRightBoundary(nums, i+1, n-2, i, n);\\n            \\n            if(rightBoundary>=leftBoundary)\\n                ans = (ans%M + (rightBoundary - leftBoundary + 1)%M)%M;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* \\n        Let i and j be two pointers which splits the array into 3 parts. \\n    \\n        Condition for splitting: nums[i] <= nums[j]-nums[i] <= nums.back() - nums[j];\\n        \\n        which can be simplified to -\\n        1. nums[j] >= 2*nums[i]                     --> (condition for left boundary of j)  \\n        2. nums[j] <= (nums.back() + nums[i]) / 2   --> (condition for right boundary of j)\\n    */\\n    \\n    \\n    /* function to calculate left boundary for j */\\n\\n    int getLeftBoundary (vector<int> & nums, int start, int end, int i, int n){\\n        int bound = n;\\n        \\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(nums[mid] < 2*nums[i])\\n                start = mid+1;\\n            \\n            else{\\n                bound = mid;\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return bound;\\n    }\\n    \\n    \\n    /* Function to calculate right boundary for j */\\n    \\n    int getRightBoundary (vector<int> & nums, int start, int end, int i, int n){\\n        int bound = i;\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n\\n            if(nums[mid] > (nums[n-1] + nums[i])/2)\\n                end = mid-1;\\n            \\n            else{\\n                bound = mid;\\n                start = mid+1;\\n            }\\n        }\\n        \\n        return bound;\\n    }\\n    \\n    \\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        int M = 1000000007; \\n        \\n        /* Computing prefix sum */\\n        \\n        for(int i=1; i<n; i++)\\n            nums[i] += nums[i-1]; \\n        \\n        int ans = 0;\\n        \\n        /* for every i, compute leftBoundary and rightBoundary of j such that it satisfies the conditions */\\n        \\n        for(int i=0; i<n-2; i++){\\n            \\n            int leftBoundary = getLeftBoundary(nums, i+1, n-2, i, n);\\n            int rightBoundary = getRightBoundary(nums, i+1, n-2, i, n);\\n            \\n            if(rightBoundary>=leftBoundary)\\n                ans = (ans%M + (rightBoundary - leftBoundary + 1)%M)%M;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002315,
                "title": "javascript-prefix-sum-3-pointer-solution-w-explanation-beats-100-100",
                "content": "_(**Edit**: Fixed an issue with the code and dealt with a simple edge case of all **0**\\'s leading to an easy triangular number answer.)_\\n\\n***Idea:***\\n\\nRather than attempting to check all permutations, this seems like a classic case for a **sliding window** approach, with the difference being the need for **three pointers** to help keep track of the upper/lower bounds of the middle subarray. And since we\\'re dealing with the sums of contiguous subarrays, it makes sense to **prefix sum** the given array rather than having to keep track of multiple other sum variables. The best result for the code below is **96ms / 48.9MB**.\\n\\n` `\\n***Implementation:***\\n\\nIn this specific instance, as we\\'ll be increasing each pointer by **1** each time, we could achieve much the same efficiency without a prefix sum, but since we need to iterate through **N** at the start in order to obtain the **max** sum of the array, there\\'s no real reason not to.\\n\\nWe\\'ll need to iterate through values of the left pointer **i** representing the end of the left subarray, and at each stop we\\'ll calculate the remaining two pointers **j** and **k** representing the lower and upper bounds possible for the end of the middle subarray. Once the sum of the left subarray (**N[i]**) passes **max / 3**, there\\'s no possibility for larger values of the mid and right subarrays, and we likewise need to allow room for both other subarrays, so we\\'ll make those the end conditions of our **for** loop.\\n\\nThe first step will be to increment **j** until the sum of the middle subarray reaches that of the newly increased left subarray. Since we applied a prefix sum, the sum of the left subarray is simply **N[i]** and the sum of the middle subarray is **N[j] - N[i]**. That means that **N[j] - N[i] >= N[i]**, which can more efficienty written as **N[j] >= N[i] * 2**. In a **for** loop, that means we want to increment **j** while **N[j] < N[i] * 2**. We\\'ll also need to make sure that both the middle and right subarrays have room, so **j > i** and **j < lim**.\\n\\nSimilar to the previous step, **k** will need to be incremented until the sum of the middle subarray (**N[k] - N[i]**) passes the sum of the right subarray (**max - N[k]**). (*This means that **k** will actually be pointing to one past the upper bound, but it will keep us from having to use **N[k+1]** here and will also allow for an easier calculation later.*) The equation **N[k] - N[i] > max - N[k]** can be rewritten as **N[k] > (max + N[i]) / 2**, which means that we\\'ll increment **k** while **N[k] <= (max + N[i]) / 2**. Just like before, we\\'ll need to make sure that enough room remains, so **k <= lim**.\\n\\nAnd the end of each iteration of **i**, we\\'ll also add to **ans** the number of possible permutations found, which is **k - j**. (*Had we forced **k** to be one less in order to accurately represent the upper bound, this equation would have ended up as **k - j + 1**, so it\\'s a win/win.*)\\n\\nAfter the iterations are through, we just need to return our **ans** with the modulo applied.\\n\\n` `\\n***Code:***\\n```\\nvar waysToSplit = function(N) {\\n    let len = N.length\\n    for (let i = 1; i < len; i++)\\n        N[i] += N[i - 1]\\n    let max = N[len - 1], ans = 0\\n    if (max === 0)\\n        return ((len - 2) * (len - 1) / 2) % 1000000007\\n    for (let i = 0, j = 1, k = 1; N[i] <= max / 3; i++) {\\n        let lo = N[i] * 2, hi = (max + N[i]) / 2\\n        while (j === i || N[j] < lo)\\n            j++\\n        while (N[k] <= hi)\\n            k++\\n        ans += k - j\\n    }\\n    return ans % 1000000007\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar waysToSplit = function(N) {\\n    let len = N.length\\n    for (let i = 1; i < len; i++)\\n        N[i] += N[i - 1]\\n    let max = N[len - 1], ans = 0\\n    if (max === 0)\\n        return ((len - 2) * (len - 1) / 2) % 1000000007\\n    for (let i = 0, j = 1, k = 1; N[i] <= max / 3; i++) {\\n        let lo = N[i] * 2, hi = (max + N[i]) / 2\\n        while (j === i || N[j] < lo)\\n            j++\\n        while (N[k] <= hi)\\n            k++\\n        ans += k - j\\n    }\\n    return ans % 1000000007\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999383,
                "title": "go-3-pointers-o-n",
                "content": "```go\\ntype ll uint64\\nconst MOD ll = 1e9 + 7\\n\\nfunc waysToSplit(nums []int) int {\\n    var ans, cur, sum, leftSum, midSum ll = 0, 0, 0, ll(nums[0]), ll(nums[0])\\n    n, lo, hi := len(nums), 1, 1\\n    \\n    for _, num := range nums {\\n        sum += ll(num)\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        cur += ll(nums[i])\\n        \\n        // right is the right sumarray\\n        right := sum - cur\\n        \\n        if i == 0 || i == n - 1 {\\n            continue\\n        }\\n        \\n        // calculate the right boundry of the middle array by increasing midSum till it is as twice as big as left (cur - midSum)\\n        for hi <= i && cur >= 2 * midSum {\\n            midSum += ll(nums[hi])\\n            hi++\\n        }\\n        \\n        // calculate the left boundry of th middle array while midSum ramains <= right\\n        for lo < hi && cur - leftSum > right {\\n            leftSum += ll(nums[lo])\\n            lo++\\n        }\\n        \\n        if lo < hi {\\n            ans += ll(hi - lo)\\n            ans %= MOD\\n        }\\n    }\\n    \\n    return int(ans)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype ll uint64\\nconst MOD ll = 1e9 + 7\\n\\nfunc waysToSplit(nums []int) int {\\n    var ans, cur, sum, leftSum, midSum ll = 0, 0, 0, ll(nums[0]), ll(nums[0])\\n    n, lo, hi := len(nums), 1, 1\\n    \\n    for _, num := range nums {\\n        sum += ll(num)\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        cur += ll(nums[i])\\n        \\n        // right is the right sumarray\\n        right := sum - cur\\n        \\n        if i == 0 || i == n - 1 {\\n            continue\\n        }\\n        \\n        // calculate the right boundry of the middle array by increasing midSum till it is as twice as big as left (cur - midSum)\\n        for hi <= i && cur >= 2 * midSum {\\n            midSum += ll(nums[hi])\\n            hi++\\n        }\\n        \\n        // calculate the left boundry of th middle array while midSum ramains <= right\\n        for lo < hi && cur - leftSum > right {\\n            leftSum += ll(nums[lo])\\n            lo++\\n        }\\n        \\n        if lo < hi {\\n            ans += ll(hi - lo)\\n            ans %= MOD\\n        }\\n    }\\n    \\n    return int(ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236210,
                "title": "c-binary-search-prefix-sum",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/188cf10b-e4a5-4cd2-970b-64a17c0fc709_1687511283.4797945.png)\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) \\n    {\\n        long long count=0,M=1000000007;\\n        int n=nums.size();\\n        \\n        vector<long long int> prefix(n,nums[0]);\\n        for(int i=1;i<n;i++)\\n        prefix[i]=prefix[i-1]+nums[i];\\n        // we have calculated the prefix sum for finding sum of lrm in O(1) time.\\n        \\n        for(int i=0;i<n-1;i++)\\n        {   \\n            int right=-1,left=-1; // for storing the indexes;\\n            \\n            int lo=i+1,hi=n-2;\\n            //we calculate the right-most valid index\\n            while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(prefix[mid]-prefix[i]<=prefix.back()-prefix[mid])\\n                {\\n                    right=mid;\\n                    lo=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n            \\n            lo=i+1;hi=n-2;\\n            //we calculate the left-most valid index\\n             while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(prefix[i]<=prefix[mid]-prefix[i])\\n                {\\n                    left=mid;\\n                    hi=mid-1;\\n                }\\n                else\\n                    lo=mid+1;\\n            }\\n            //invalid condition check i.e. if one of the bound does not exist \\n            //or left bound is greater than right bound\\n            if(left==-1||right==-1||left>right)continue;\\n            \\n            count=(count+(right-left+1)%M)%M;\\n        }\\n        return count;\\n    }\\n};\\n```\\n# Sol 2 with lowerbound and upperbound :\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    \\n    int waysToSplit(vector<int>& nums) \\n    {\\n        int i, left, remaining, mid_startpoint, mid_endpoint, max_mid, length, n = nums.size();\\n\\n        vector<int>sum(n, 0);\\n        sum[0] = nums[0];\\n        for(i = 1; i < n; i++) \\n            sum [i] = sum[i-1] + nums[i];\\n        \\n        long long ans=0;\\n        for(i = 0; i < n; i++) \\n        {\\n            left = sum[i];\\n            remaining = sum[n-1] - left;\\n\\n            max_mid = remaining/2;\\n                 \\n            mid_startpoint = lower_bound(sum.begin() + i + 1, sum.end(), sum[i] + left) - sum.begin();\\n            \\n            // have to apply search upto n-1 otherwise an empty right part will also be counted\\n            mid_endpoint = upper_bound(sum.begin() + i + 1, sum.begin() + n - 1  , sum[i] + max_mid) - sum.begin();\\n            mid_endpoint--;\\n\\n            length = (mid_endpoint - mid_startpoint + 1);\\n            \\n            ans += max(0, length);\\n        }\\n        \\n        return ans % mod;\\n    }\\n}; \\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) \\n    {\\n        long long count=0,M=1000000007;\\n        int n=nums.size();\\n        \\n        vector<long long int> prefix(n,nums[0]);\\n        for(int i=1;i<n;i++)\\n        prefix[i]=prefix[i-1]+nums[i];\\n        // we have calculated the prefix sum for finding sum of lrm in O(1) time.\\n        \\n        for(int i=0;i<n-1;i++)\\n        {   \\n            int right=-1,left=-1; // for storing the indexes;\\n            \\n            int lo=i+1,hi=n-2;\\n            //we calculate the right-most valid index\\n            while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(prefix[mid]-prefix[i]<=prefix.back()-prefix[mid])\\n                {\\n                    right=mid;\\n                    lo=mid+1;\\n                }\\n                else\\n                    hi=mid-1;\\n            }\\n            \\n            lo=i+1;hi=n-2;\\n            //we calculate the left-most valid index\\n             while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                if(prefix[i]<=prefix[mid]-prefix[i])\\n                {\\n                    left=mid;\\n                    hi=mid-1;\\n                }\\n                else\\n                    lo=mid+1;\\n            }\\n            //invalid condition check i.e. if one of the bound does not exist \\n            //or left bound is greater than right bound\\n            if(left==-1||right==-1||left>right)continue;\\n            \\n            count=(count+(right-left+1)%M)%M;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902962,
                "title": "c-o-n-prefix-sum-three-pointers-solution",
                "content": "Runtime: 233 ms, faster than 72.07% of C++ online submissions for Ways to Split Array Into Three Subarrays.\\nMemory Usage: 81.5 MB, less than 74.31% of C++ online submissions for Ways to Split Array Into Three Subarrays.\\n\\n**Solution taken from votrubac.**\\n\\n```\\nWe use three pointer Left, Mid and Right to find the possible subarray count.\\nFor calculating the range sum of values in this immutable array, we generate its prefix sum.\\n\\nLeft pointer is the last pointer of first part.\\nMid pointer is the first / minimum pointer of middle part.\\nRight pointer is the last / maximum pointer of middle part.\\n\\nNow we loop through array with Left value 0 to N-1. For each Left value we find the \\nMid and Right pointer and the range of Mid and Right pointer is the possible ways \\nto split array for that Left pointer. As Left increases, Mid and Right increases too and\\nmoves forward without resetting which makes the solution O(N).\\n\\nWe move Mid pointer forward as long as Mid value is less than 2 * Left value\\nWe move Right pointer forward as long as middle part sum <= last part sum\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // generate prefix sum\\n        for(int i=1;i<n;i++)nums[i]+=nums[i-1];\\n        \\n        int left  = 0;  // last pointer of first part\\n        int mid = 1;    // first pointer of middle part\\n        int right = 2;  // last pointer of middle part\\n        int count = 0;\\n        \\n        // loop through array and find the mid and right for each left pointer\\n        // as left pointer moves forward, mid and right pointer moves forward too\\n        while(left < n-2)\\n        {\\n            mid = max(mid,left+1);\\n            \\n            // move mid forward as long as sum till mid < 2 * sum till left  \\n            // goal is to find the minimum pointer of middle part for current left part\\n            while(mid<n-1 && nums[mid]<2*nums[left])mid++;\\n            \\n            right = max(mid,right);\\n\\n            // move right forward as long as mid part sum <= right part sum\\n            // goal is to find the maximum pointer of middle part for current left part\\n            while(right<n-1 && nums[right]-nums[left]<=nums[n-1]-nums[right])right++;\\n            \\n            count = (count + right - mid) % 1000000007;\\n            \\n            left++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nWe use three pointer Left, Mid and Right to find the possible subarray count.\\nFor calculating the range sum of values in this immutable array, we generate its prefix sum.\\n\\nLeft pointer is the last pointer of first part.\\nMid pointer is the first / minimum pointer of middle part.\\nRight pointer is the last / maximum pointer of middle part.\\n\\nNow we loop through array with Left value 0 to N-1. For each Left value we find the \\nMid and Right pointer and the range of Mid and Right pointer is the possible ways \\nto split array for that Left pointer. As Left increases, Mid and Right increases too and\\nmoves forward without resetting which makes the solution O(N).\\n\\nWe move Mid pointer forward as long as Mid value is less than 2 * Left value\\nWe move Right pointer forward as long as middle part sum <= last part sum\\n```\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // generate prefix sum\\n        for(int i=1;i<n;i++)nums[i]+=nums[i-1];\\n        \\n        int left  = 0;  // last pointer of first part\\n        int mid = 1;    // first pointer of middle part\\n        int right = 2;  // last pointer of middle part\\n        int count = 0;\\n        \\n        // loop through array and find the mid and right for each left pointer\\n        // as left pointer moves forward, mid and right pointer moves forward too\\n        while(left < n-2)\\n        {\\n            mid = max(mid,left+1);\\n            \\n            // move mid forward as long as sum till mid < 2 * sum till left  \\n            // goal is to find the minimum pointer of middle part for current left part\\n            while(mid<n-1 && nums[mid]<2*nums[left])mid++;\\n            \\n            right = max(mid,right);\\n\\n            // move right forward as long as mid part sum <= right part sum\\n            // goal is to find the maximum pointer of middle part for current left part\\n            while(right<n-1 && nums[right]-nums[left]<=nums[n-1]-nums[right])right++;\\n            \\n            count = (count + right - mid) % 1000000007;\\n            \\n            left++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511845,
                "title": "well-coded-both-method-two-pointer-binary-search",
                "content": "## IDEA:\\n\\n**Two Pointers :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        \\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        for i in range(1,n):\\n            nums[i]+=nums[i-1]\\n        \\n        res,j,k = 0,0,0\\n        for i in range(n-2):\\n            if j<=i:\\n                j = i+1\\n            while j<n-1 and nums[i]>nums[j]-nums[i]:\\n                j+=1\\n            \\n\\t\\t\\tif k<j:\\n                k = j\\n            while k<n-1 and nums[k]-nums[i]<=nums[n-1]-nums[k]:\\n                k += 1\\n            res = (res + k - j)%MOD\\n        \\n        return res\\n\\n****\\n**Using Binary Search :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod, pre_sum = int(1e9+7), [nums[0]]\\n        for num in nums[1:]:                               # create prefix sum array\\n            pre_sum.append(pre_sum[-1] + num)\\n        ans, n = 0, len(nums)\\n        for i in range(n):                                 # pre_sum[i] is the sum of the 1st segment\\n            prev = pre_sum[i]                              # i+1 is the starting index of the 2nd segment\\n            if prev * 3 > pre_sum[-1]: break               # break loop if first segment is larger than the sum of 2 & 3 segments\\n                \\n            j = bisect.bisect_left(pre_sum, prev * 2, i+1) # j is the first possible ending index of 2nd segment\\n                \\n            middle = (prev + pre_sum[-1]) // 2             # last possible ending value of 2nd segment\\n            k = bisect.bisect_right(pre_sum, middle, j+1)  # k-1 is the last possible ending index of 2nd segment\\n            if k-1 >= n or pre_sum[k-1] > middle: continue # make sure the value satisfy the condition since we are using bisect_right here\\n            ans = (ans + min(k, n - 1) - j) % mod          # count & handle edge case\\n        return ans\\n\\n### Thanks and Upvote if you got any help!!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "## IDEA:\\n\\n**Two Pointers :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        \\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        for i in range(1,n):\\n            nums[i]+=nums[i-1]\\n        \\n        res,j,k = 0,0,0\\n        for i in range(n-2):\\n            if j<=i:\\n                j = i+1\\n            while j<n-1 and nums[i]>nums[j]-nums[i]:\\n                j+=1\\n            \\n\\t\\t\\tif k<j:\\n                k = j\\n            while k<n-1 and nums[k]-nums[i]<=nums[n-1]-nums[k]:\\n                k += 1\\n            res = (res + k - j)%MOD\\n        \\n        return res\\n\\n****\\n**Using Binary Search :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod, pre_sum = int(1e9+7), [nums[0]]\\n        for num in nums[1:]:                               # create prefix sum array\\n            pre_sum.append(pre_sum[-1] + num)\\n        ans, n = 0, len(nums)\\n        for i in range(n):                                 # pre_sum[i] is the sum of the 1st segment\\n            prev = pre_sum[i]                              # i+1 is the starting index of the 2nd segment\\n            if prev * 3 > pre_sum[-1]: break               # break loop if first segment is larger than the sum of 2 & 3 segments\\n                \\n            j = bisect.bisect_left(pre_sum, prev * 2, i+1) # j is the first possible ending index of 2nd segment\\n                \\n            middle = (prev + pre_sum[-1]) // 2             # last possible ending value of 2nd segment\\n            k = bisect.bisect_right(pre_sum, middle, j+1)  # k-1 is the last possible ending index of 2nd segment\\n            if k-1 >= n or pre_sum[k-1] > middle: continue # make sure the value satisfy the condition since we are using bisect_right here\\n            ans = (ans + min(k, n - 1) - j) % mod          # count & handle edge case\\n        return ans\\n\\n### Thanks and Upvote if you got any help!!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1065408,
                "title": "c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int mod = pow(10, 9) + 7, n = nums.size();\\n        unsigned long long count = 0;\\n        vector<int> prefix(n + 1, 0);\\n        for (int i = 0; i < nums.size(); i++)   prefix[i + 1] = prefix[i] + nums[i];\\n        for (int i = 1; i <= n - 2; i++) {\\n            int diff = prefix[n] - prefix[i];\\n            int mid = diff / 2;\\n            if (mid < prefix[i])    break;\\n            mid += prefix[i];\\n            //cout << i << \":\" << prefix[i] << \":\" << mid << endl;\\n            vector<int> :: iterator it_up = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, mid);\\n            if (it_up == prefix.end()) break;\\n            vector<int> :: iterator it_low = lower_bound(prefix.begin() + i + 1, \\n                                                        prefix.end(), 2 * prefix[i]);\\n            if (it_low == prefix.end()) break;\\n            if (it_low == prefix.begin() + i)   ++it_low;\\n            if (it_low < it_up) {\\n                count += (it_up - it_low);\\n                count %= mod;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int mod = pow(10, 9) + 7, n = nums.size();\\n        unsigned long long count = 0;\\n        vector<int> prefix(n + 1, 0);\\n        for (int i = 0; i < nums.size(); i++)   prefix[i + 1] = prefix[i] + nums[i];\\n        for (int i = 1; i <= n - 2; i++) {\\n            int diff = prefix[n] - prefix[i];\\n            int mid = diff / 2;\\n            if (mid < prefix[i])    break;\\n            mid += prefix[i];\\n            //cout << i << \":\" << prefix[i] << \":\" << mid << endl;\\n            vector<int> :: iterator it_up = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, mid);\\n            if (it_up == prefix.end()) break;\\n            vector<int> :: iterator it_low = lower_bound(prefix.begin() + i + 1, \\n                                                        prefix.end(), 2 * prefix[i]);\\n            if (it_low == prefix.end()) break;\\n            if (it_low == prefix.begin() + i)   ++it_low;\\n            if (it_low < it_up) {\\n                count += (it_up - it_low);\\n                count %= mod;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1056821,
                "title": "java-prefix-sum-o-n-time",
                "content": "the key point here is how can you find the right boundary between second and third array.\\nOne way is to use binary search by target value; (O(nlgn))\\nThe other way is use another pointer to find the cutting point, naively from i+1 to n - 2 everytime when i increases (O(n2)). However, this can be further optimized by not starting from i+1 everytime but use the previously scanned value. (O(n))\\n\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        int n = nums.length;\\n        int[] sums = new int[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            sums[i] = sums[i-1] + nums[i-1];\\n        }\\n        \\n        long res = 0;\\n        int j = 1;\\n        int k = 2;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = sums[i+1];\\n            int target = (sums[n] - sums[i+1]) / 2;\\n            if (target < left) {\\n                break;\\n            }\\n            \\n            while (j <= i || j < n - 1 && sums[j+1] - sums[i+1] < left) {\\n                j++;\\n            }\\n            \\n            while (k < j || k < n - 1 && sums[k+1] - sums[i+1] <= sums[n] - sums[k+1]) {\\n                k++;\\n            }\\n            res = (res + k - j) % mod;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        int n = nums.length;\\n        int[] sums = new int[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            sums[i] = sums[i-1] + nums[i-1];\\n        }\\n        \\n        long res = 0;\\n        int j = 1;\\n        int k = 2;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = sums[i+1];\\n            int target = (sums[n] - sums[i+1]) / 2;\\n            if (target < left) {\\n                break;\\n            }\\n            \\n            while (j <= i || j < n - 1 && sums[j+1] - sums[i+1] < left) {\\n                j++;\\n            }\\n            \\n            while (k < j || k < n - 1 && sums[k+1] - sums[i+1] <= sums[n] - sums[k+1]) {\\n                k++;\\n            }\\n            res = (res + k - j) % mod;\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022201,
                "title": "c-binary-search-simple-with-stl",
                "content": "Assuming `prefix` array has the prefix sum of the `nums`. The main condition to generate is:\\n```\\nleftSum <= midSum <= rightSum  - (i)\\n\\nleftSum = prefix[i]\\nmidSum = prefix[mid] - leftSum\\nrightSum = prefix[end] - prefix[mid]\\n\\n2*prefix[i] <= prefix[mid] <= (prefix[end] + prefix[i])/2  - (ii)\\n```\\n\\nNow we need to find the `lower_bound` for left part and `upper_bound` for right part in `(ii)`. That would give us the interval in which the condition `(i)` would be true. \\n\\nHere is my code:\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> prefix;\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            prefix.push_back(sum);\\n        }\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < nums.size() - 2; ++i) {\\n            auto lo = lower_bound(prefix.begin() + i + 1, prefix.end(), \\n                                  2*prefix[i]);\\n            auto up = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, \\n                                  (prefix.back() + prefix[i])/2);\\n            if (lo < up)\\n                cnt = (cnt + up - lo) % mod;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\nprivate:\\n    const int mod = 1e9 + 7;\\n};\\n```\\n\\nNote: `prefix.end()-1` for the `upper_bound` is to not search till the end of the `prefix` array since then we won\\'t have a 3-way split that way.",
                "solutionTags": [],
                "code": "```\\nleftSum <= midSum <= rightSum  - (i)\\n\\nleftSum = prefix[i]\\nmidSum = prefix[mid] - leftSum\\nrightSum = prefix[end] - prefix[mid]\\n\\n2*prefix[i] <= prefix[mid] <= (prefix[end] + prefix[i])/2  - (ii)\\n```\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> prefix;\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            prefix.push_back(sum);\\n        }\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < nums.size() - 2; ++i) {\\n            auto lo = lower_bound(prefix.begin() + i + 1, prefix.end(), \\n                                  2*prefix[i]);\\n            auto up = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, \\n                                  (prefix.back() + prefix[i])/2);\\n            if (lo < up)\\n                cnt = (cnt + up - lo) % mod;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\nprivate:\\n    const int mod = 1e9 + 7;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007027,
                "title": "java-o-n-log-n-binary-search-solution-with-explanation",
                "content": "```java\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    \\n    // O(N*LogN)\\n    public int waysToSplit(int[] nums) {\\n        int[] summary = new int[nums.length];\\n        int totalSummary = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            totalSummary += nums[i];\\n            summary[i] = totalSummary;\\n        }\\n        int ways = 0;\\n        // i: right bound of part1\\n        for (int i = 0; i < nums.length-2 && summary[i] <= totalSummary/3; i++) {\\n            // binary-search\\n            int left = summary[i];\\n            // find splitIndexMax which part2 \\u2264 part3\\n            int l = i+1, r = nums.length-2;\\n            while (l <= r) {\\n                int m = (l+r)>>1;\\n                int mTemp = summary[m] - left;         // [i+1, m]\\n                int rTemp = totalSummary - summary[m]; // [m+1, nums.length-1]\\n                if (mTemp <= rTemp) {\\n                    // m, satisfy condition\\n                    l = m+1;\\n                } else {\\n                    r = m-1;\\n                }\\n            }\\n            // if l-1 in [i+1, nums.length-2], it\\'s a valid split\\n            if (l-1 < i+1 || l-1 > nums.length-2) {\\n                continue;\\n            }\\n            int splitIndexMax = l-1;\\n\\n            // find splitIndexMin which part1 \\u2264 part2\\n            l = i+1;\\n            r = splitIndexMax;\\n            while (l <= r) {\\n                int m = (l+r)>>1;\\n                int mTemp = summary[m] - left; // [i+1, m]\\n                if (mTemp >= left) {\\n                    // m, satisfy condition\\n                    r = m-1;\\n                } else {\\n                    l = m+1;\\n                }\\n            }\\n            // if r+1 in [i+1, splitIndexMax], it\\'s a valid split\\n            if (r+1 < i+1 || r+1 > splitIndexMax) {\\n                continue;\\n            }\\n            int splitIndexMin = r+1;\\n            // add to ways and make mod\\n            ways += splitIndexMax - splitIndexMin + 1;\\n            ways %= MOD;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    \\n    // O(N*LogN)\\n    public int waysToSplit(int[] nums) {\\n        int[] summary = new int[nums.length];\\n        int totalSummary = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            totalSummary += nums[i];\\n            summary[i] = totalSummary;\\n        }\\n        int ways = 0;\\n        // i: right bound of part1\\n        for (int i = 0; i < nums.length-2 && summary[i] <= totalSummary/3; i++) {\\n            // binary-search\\n            int left = summary[i];\\n            // find splitIndexMax which part2 \\u2264 part3\\n            int l = i+1, r = nums.length-2;\\n            while (l <= r) {\\n                int m = (l+r)>>1;\\n                int mTemp = summary[m] - left;         // [i+1, m]\\n                int rTemp = totalSummary - summary[m]; // [m+1, nums.length-1]\\n                if (mTemp <= rTemp) {\\n                    // m, satisfy condition\\n                    l = m+1;\\n                } else {\\n                    r = m-1;\\n                }\\n            }\\n            // if l-1 in [i+1, nums.length-2], it\\'s a valid split\\n            if (l-1 < i+1 || l-1 > nums.length-2) {\\n                continue;\\n            }\\n            int splitIndexMax = l-1;\\n\\n            // find splitIndexMin which part1 \\u2264 part2\\n            l = i+1;\\n            r = splitIndexMax;\\n            while (l <= r) {\\n                int m = (l+r)>>1;\\n                int mTemp = summary[m] - left; // [i+1, m]\\n                if (mTemp >= left) {\\n                    // m, satisfy condition\\n                    r = m-1;\\n                } else {\\n                    l = m+1;\\n                }\\n            }\\n            // if r+1 in [i+1, splitIndexMax], it\\'s a valid split\\n            if (r+1 < i+1 || r+1 > splitIndexMax) {\\n                continue;\\n            }\\n            int splitIndexMin = r+1;\\n            // add to ways and make mod\\n            ways += splitIndexMax - splitIndexMin + 1;\\n            ways %= MOD;\\n        }\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000508,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int size = nums.length;\\n        for (int i = 1; i < size; ++i) {\\n            nums[i] += nums[i - 1];\\n        }\\n        int res = 0;\\n        int mod = 1_000_000_007;\\n        for (int i = 0; i < size - 2; ++i) {\\n            int left = searchLeft(nums, i, size - 1);\\n            int right = searchRight(nums, i, size - 1);\\n            if (left == -1 || right == -1) {\\n                continue;\\n            }\\n            res = (res + right - left + 1) % mod;\\n        }\\n        return res;\\n    }\\n    \\n    private int searchLeft(int[] nums, int left, int right) {\\n        int pos = -1;\\n        int min = nums[left];\\n        int lo = left + 1, hi = right - 1;\\n        while (lo <= hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            int mid = nums[mi] - min;\\n            int max = nums[right] - nums[mi];\\n            if (mid < min) {\\n                lo = mi + 1;\\n            } else if (max < mid){\\n                hi = mi - 1;\\n            } else {\\n                pos = mi;\\n                hi = mi - 1;\\n            }\\n        }\\n        return pos;\\n    }\\n    \\n    private int searchRight(int[] nums, int left, int right) {\\n        int pos = -1;\\n        int min = nums[left];\\n        int lo = left + 1, hi = right - 1;\\n        while (lo <= hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            int mid = nums[mi] - min;\\n            int max = nums[right] - nums[mi];\\n            if (mid < min) {\\n                lo = mi + 1;\\n            } else if (max < mid){\\n                hi = mi - 1;\\n            } else {\\n                pos = mi;\\n                lo = mi + 1;\\n            }\\n        }\\n        return pos;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int size = nums.length;\\n        for (int i = 1; i < size; ++i) {\\n            nums[i] += nums[i - 1];\\n        }\\n        int res = 0;\\n        int mod = 1_000_000_007;\\n        for (int i = 0; i < size - 2; ++i) {\\n            int left = searchLeft(nums, i, size - 1);\\n            int right = searchRight(nums, i, size - 1);\\n            if (left == -1 || right == -1) {\\n                continue;\\n            }\\n            res = (res + right - left + 1) % mod;\\n        }\\n        return res;\\n    }\\n    \\n    private int searchLeft(int[] nums, int left, int right) {\\n        int pos = -1;\\n        int min = nums[left];\\n        int lo = left + 1, hi = right - 1;\\n        while (lo <= hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            int mid = nums[mi] - min;\\n            int max = nums[right] - nums[mi];\\n            if (mid < min) {\\n                lo = mi + 1;\\n            } else if (max < mid){\\n                hi = mi - 1;\\n            } else {\\n                pos = mi;\\n                hi = mi - 1;\\n            }\\n        }\\n        return pos;\\n    }\\n    \\n    private int searchRight(int[] nums, int left, int right) {\\n        int pos = -1;\\n        int min = nums[left];\\n        int lo = left + 1, hi = right - 1;\\n        while (lo <= hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            int mid = nums[mi] - min;\\n            int max = nums[right] - nums[mi];\\n            if (mid < min) {\\n                lo = mi + 1;\\n            } else if (max < mid){\\n                hi = mi - 1;\\n            } else {\\n                pos = mi;\\n                lo = mi + 1;\\n            }\\n        }\\n        return pos;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000367,
                "title": "javascript-o-n-with-three-pointers-easy-to-understand-code",
                "content": "```\\nvar waysToSplit = function (A) {\\n  const N = A.length;\\n  const mod = 1e9 + 7;\\n  const pre = [...A];\\n  for (let i = 1; i < N; i++) pre[i] += pre[i - 1];\\n  let res = 0;\\n  // j is the smallest ending idx of mid arr j > i, j < N - 1\\n  // k is the largest ending idx of mid arr k >= j, k < N - 1\\n  for (let i = 0, j = 1, k = 1; i < N - 2; i++) {\\n    j = Math.max(j, i + 1);\\n    k = Math.max(k, j);\\n    const left = pre[i];\\n    if (left > pre[N - 1] / 3) break;\\n\\n    // while left > mid, we need to increase j\\n    while (left > pre[j] - pre[i] && j < N - 1) j++;\\n    if (j >= N - 1) break;\\n\\n    /// while mid <= right, we still have room to increase k\\n    while (pre[k] - pre[i] <= pre[N - 1] - pre[k] && k < N - 1) k++;\\n    k--; // Shift back one position\\n    if (k < j || k >= N - 1) continue;\\n\\n    res += (k - j + 1) % mod;\\n  }\\n  return res % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar waysToSplit = function (A) {\\n  const N = A.length;\\n  const mod = 1e9 + 7;\\n  const pre = [...A];\\n  for (let i = 1; i < N; i++) pre[i] += pre[i - 1];\\n  let res = 0;\\n  // j is the smallest ending idx of mid arr j > i, j < N - 1\\n  // k is the largest ending idx of mid arr k >= j, k < N - 1\\n  for (let i = 0, j = 1, k = 1; i < N - 2; i++) {\\n    j = Math.max(j, i + 1);\\n    k = Math.max(k, j);\\n    const left = pre[i];\\n    if (left > pre[N - 1] / 3) break;\\n\\n    // while left > mid, we need to increase j\\n    while (left > pre[j] - pre[i] && j < N - 1) j++;\\n    if (j >= N - 1) break;\\n\\n    /// while mid <= right, we still have room to increase k\\n    while (pre[k] - pre[i] <= pre[N - 1] - pre[k] && k < N - 1) k++;\\n    k--; // Shift back one position\\n    if (k < j || k >= N - 1) continue;\\n\\n    res += (k - j + 1) % mod;\\n  }\\n  return res % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999315,
                "title": "javascript-binary-search-twice-o-nlgn",
                "content": "For each i:\\n*  First binary search find the smallest possible ending idx of mid arr: j\\n*  Second binary search find the largest possible ending idx of mid arr: k\\n\\n\\n```\\nvar waysToSplit = function (A) {\\n  const n = A.length;\\n  const mod = 1e9 + 7;\\n  const pre = [...A];\\n  for (let i = 1; i < n; i++) pre[i] += pre[i - 1];\\n  let res = 0;\\n  for (let i = 0; i < n; i++) {\\n    const left = pre[i];\\n    if (left > pre[n - 1] / 3) break;\\n\\n    // First binary search find the smallest possible ending idx of mid arr: j\\n    let [l, r] = [i + 1, n - 2];\\n    while (l < r) {\\n      const mid = (l + r) >> 1;\\n      const midV = pre[mid] - pre[i];\\n      if (midV < left) l = mid + 1;\\n      else r = mid;\\n    }\\n    // Double check\\n    if (pre[l] - pre[i] < left) continue;\\n    const j = l;\\n\\n    // Second binary search find the largest possible ending idx of mid arr: k\\n    r = n - 2;\\n    while (l < r) {\\n      const mid = (l + r) >> 1;\\n      const midV = pre[mid] - pre[i];\\n      const rightV = pre[n - 1] - pre[mid];\\n      if (midV <= rightV) l = mid + 1;\\n      else r = mid - 1;\\n    }\\n    \\n    // Double check\\n    if (pre[l] - pre[i] > pre[n - 1] - pre[l] || l >= n - 1) {\\n      l--;\\n      if (pre[l] - pre[i] > pre[n - 1] - pre[l] || l < j) continue;\\n    }\\n    const k = l;\\n\\n    res += (k - j + 1) % mod;\\n    res %= mod;\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar waysToSplit = function (A) {\\n  const n = A.length;\\n  const mod = 1e9 + 7;\\n  const pre = [...A];\\n  for (let i = 1; i < n; i++) pre[i] += pre[i - 1];\\n  let res = 0;\\n  for (let i = 0; i < n; i++) {\\n    const left = pre[i];\\n    if (left > pre[n - 1] / 3) break;\\n\\n    // First binary search find the smallest possible ending idx of mid arr: j\\n    let [l, r] = [i + 1, n - 2];\\n    while (l < r) {\\n      const mid = (l + r) >> 1;\\n      const midV = pre[mid] - pre[i];\\n      if (midV < left) l = mid + 1;\\n      else r = mid;\\n    }\\n    // Double check\\n    if (pre[l] - pre[i] < left) continue;\\n    const j = l;\\n\\n    // Second binary search find the largest possible ending idx of mid arr: k\\n    r = n - 2;\\n    while (l < r) {\\n      const mid = (l + r) >> 1;\\n      const midV = pre[mid] - pre[i];\\n      const rightV = pre[n - 1] - pre[mid];\\n      if (midV <= rightV) l = mid + 1;\\n      else r = mid - 1;\\n    }\\n    \\n    // Double check\\n    if (pre[l] - pre[i] > pre[n - 1] - pre[l] || l >= n - 1) {\\n      l--;\\n      if (pre[l] - pre[i] > pre[n - 1] - pre[l] || l < j) continue;\\n    }\\n    const k = l;\\n\\n    res += (k - j + 1) % mod;\\n    res %= mod;\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989989,
                "title": "ways-to-split-array-into-three-subarrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll n = nums.size(), pref[100005], mod = 1e9+7;;\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) pref[i] = pref[i-1]+nums[i];\\n        int cnt = 0;\\n        for(int i = 0; i < n-2; i++) {\\n            ll left = pref[i];\\n            ll rest = pref[n-1]-pref[i];\\n            auto lb = lower_bound(pref+i+1,pref+n-1,2*left);\\n            auto ub = upper_bound(pref+i+1,pref+n-1,rest/2+left);\\n            if(ub-lb > 0) cnt += ub-lb; \\n            cnt %= mod;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll n = nums.size(), pref[100005], mod = 1e9+7;;\\n        pref[0] = nums[0];\\n        for(int i = 1; i < n; i++) pref[i] = pref[i-1]+nums[i];\\n        int cnt = 0;\\n        for(int i = 0; i < n-2; i++) {\\n            ll left = pref[i];\\n            ll rest = pref[n-1]-pref[i];\\n            auto lb = lower_bound(pref+i+1,pref+n-1,2*left);\\n            auto ub = upper_bound(pref+i+1,pref+n-1,rest/2+left);\\n            if(ub-lb > 0) cnt += ub-lb; \\n            cnt %= mod;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717735,
                "title": "python-o-n-solution-commented",
                "content": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        #Initialise variables\\n        # left and right are the minimum left and maximum right ends of the middle subarray\\n        MOD, sz, left, right = 1000000007, len(nums), 0, 0\\n        # Create a prefix array so that we can get subarray sums in O(1)\\n        prefix, res = list(accumulate(nums)), 0\\n        for idx in range(sz - 2):\\n            # creating a left wall for the particular idx where the sum of left subarray would be\\n            # less than or equal to the middle subarray\\n            while left <= idx or (left < sz - 1 and prefix[left] < prefix[idx] * 2):\\n                left += 1\\n            # creating a right wall for the particular idx where the sum of middle subarray would be\\n            # less than or equal to the right subarray\\n            while right < left or (right < sz - 1 and prefix[right] - prefix[idx] <= prefix[-1] - prefix[right]):\\n                right += 1\\n            # updating res\\n            # the number of possible middle subarrays is (max right - min left) + 1\\n            res = (res + right - left) % MOD\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        #Initialise variables\\n        # left and right are the minimum left and maximum right ends of the middle subarray\\n        MOD, sz, left, right = 1000000007, len(nums), 0, 0\\n        # Create a prefix array so that we can get subarray sums in O(1)\\n        prefix, res = list(accumulate(nums)), 0\\n        for idx in range(sz - 2):\\n            # creating a left wall for the particular idx where the sum of left subarray would be\\n            # less than or equal to the middle subarray\\n            while left <= idx or (left < sz - 1 and prefix[left] < prefix[idx] * 2):\\n                left += 1\\n            # creating a right wall for the particular idx where the sum of middle subarray would be\\n            # less than or equal to the right subarray\\n            while right < left or (right < sz - 1 and prefix[right] - prefix[idx] <= prefix[-1] - prefix[right]):\\n                right += 1\\n            # updating res\\n            # the number of possible middle subarrays is (max right - min left) + 1\\n            res = (res + right - left) % MOD\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497413,
                "title": "simple-c-solution-bianry-search-with-explanantion",
                "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497371,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long long n = nums.size(),ans=0,mod=1e9+7;\\n        // Here we are using prefix sum\\n        for(int i=1;i<n;i++) nums[i] += nums[i-1];\\n        for(int i=0;i<n;i++){\\n            int j1=i+1,j2=n-1,ans1=0,ans2=0;\\n            // ans1 will find the minimum index at which \\n            // the sum of second subsequence will be greater than first subsequence containing \\n            // 1st i  elements\\n            while(j1<=j2){\\n                int m = (j1+j2)/2;\\n\\t            if(nums[m]>=2*nums[i]) ans1=m,j2=m-1;\\n\\t            else j1=m+1;\\n            }\\n            // ans2 will be the last index till which sum will be third\\n            // subsequence sum will be greater than second\\n            j1=i+1,j2=n-1;\\n            while(j1<j2){\\n                int m = (j1+j2)/2;\\n\\t            if(nums[n-1]>=2*nums[m]-nums[i]) ans2=m,j1=m+1;\\n\\t            else j2=m;\\n            }\\n            // any indices that are in between ans1 and ans2 can be considered valid\\n            if(ans1>ans2 || ans1==0 || ans2==0 || ans1<i || ans2<i) continue;\\n            ans = (ans + (ans2 - ans1 + 1)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long long n = nums.size(),ans=0,mod=1e9+7;\\n        // Here we are using prefix sum\\n        for(int i=1;i<n;i++) nums[i] += nums[i-1];\\n        for(int i=0;i<n;i++){\\n            int j1=i+1,j2=n-1,ans1=0,ans2=0;\\n            // ans1 will find the minimum index at which \\n            // the sum of second subsequence will be greater than first subsequence containing \\n            // 1st i  elements\\n            while(j1<=j2){\\n                int m = (j1+j2)/2;\\n\\t            if(nums[m]>=2*nums[i]) ans1=m,j2=m-1;\\n\\t            else j1=m+1;\\n            }\\n            // ans2 will be the last index till which sum will be third\\n            // subsequence sum will be greater than second\\n            j1=i+1,j2=n-1;\\n            while(j1<j2){\\n                int m = (j1+j2)/2;\\n\\t            if(nums[n-1]>=2*nums[m]-nums[i]) ans2=m,j1=m+1;\\n\\t            else j2=m;\\n            }\\n            // any indices that are in between ans1 and ans2 can be considered valid\\n            if(ans1>ans2 || ans1==0 || ans2==0 || ans1<i || ans2<i) continue;\\n            ans = (ans + (ans2 - ans1 + 1)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455273,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int binarysearch(int i, int j, vector<int> &prfsm, int w1)\\n    {\\n        int r = -1, n = prfsm.size();\\n        while(i <= j)\\n        {\\n            int mid = i + (j-i)/2;\\n            if(mid == n-1)\\n                break;\\n            if(prfsm[n-1]-prfsm[mid] >= prfsm[mid] - prfsm[w1])\\n            {\\n                r = mid;\\n                i = mid+1;\\n            }\\n            else\\n            {\\n                j = mid-1;\\n            }\\n        }\\n        return r;\\n    }\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> prefixsm;\\n        int sum = 0, mod = 1e9 + 7, ans = 0, n = nums.size();\\n        for(int &num : nums)\\n        {\\n            sum += num;\\n            prefixsm.push_back(sum);\\n        }\\n        for(int i = 0; i < n-2; i++)\\n        {\\n            int fst = prefixsm[i];\\n            auto snditr = lower_bound(prefixsm.begin(), prefixsm.end(), 2*fst);\\n            if(snditr == prefixsm.end())\\n                return ans;\\n            int snd = snditr-prefixsm.begin();\\n            if(snd <= i)\\n                snd = i + 1;\\n            int trd = binarysearch(snd, n-1, prefixsm, i);\\n            if(trd == -1)\\n                continue;\\n            ans = (ans % mod + (trd-snd+1)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int binarysearch(int i, int j, vector<int> &prfsm, int w1)\\n    {\\n        int r = -1, n = prfsm.size();\\n        while(i <= j)\\n        {\\n            int mid = i + (j-i)/2;\\n            if(mid == n-1)\\n                break;\\n            if(prfsm[n-1]-prfsm[mid] >= prfsm[mid] - prfsm[w1])\\n            {\\n                r = mid;\\n                i = mid+1;\\n            }\\n            else\\n            {\\n                j = mid-1;\\n            }\\n        }\\n        return r;\\n    }\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> prefixsm;\\n        int sum = 0, mod = 1e9 + 7, ans = 0, n = nums.size();\\n        for(int &num : nums)\\n        {\\n            sum += num;\\n            prefixsm.push_back(sum);\\n        }\\n        for(int i = 0; i < n-2; i++)\\n        {\\n            int fst = prefixsm[i];\\n            auto snditr = lower_bound(prefixsm.begin(), prefixsm.end(), 2*fst);\\n            if(snditr == prefixsm.end())\\n                return ans;\\n            int snd = snditr-prefixsm.begin();\\n            if(snd <= i)\\n                snd = i + 1;\\n            int trd = binarysearch(snd, n-1, prefixsm, i);\\n            if(trd == -1)\\n                continue;\\n            ans = (ans % mod + (trd-snd+1)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136379,
                "title": "c-easy-to-understand-simple-prefix-sum-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll mod=1e9+7;\\n        ll n=nums.size();\\n        vector<ll> prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(ll i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        ll ans=0;\\n        ll sum=0;\\n        ll total=prefix[n-1];\\n        for(int i=0;i<n-2;i++)\\n        {\\n            if(prefix[i]>total/3)\\n            break;\\n            ll j=lower_bound(prefix.begin()+i+1,prefix.end(),prefix[i]*2)-prefix.begin();\\n            ll l=upper_bound(prefix.begin()+i+1,prefix.end(),(total-prefix[i])/2+prefix[i])-prefix.begin();\\n            if(l<j)\\n            continue;\\n            else\\n            {\\n                if(l==n)\\n                {\\n                    ans=(ans%mod+(l-j-1)%mod)%mod;\\n                }\\n                else\\n                {\\n                    ans=(ans%mod+(l-j)%mod)%mod;\\n                }\\n            } \\n        }\\n        if(n==3&&ans>1)\\n        return 1;\\n        return (int)(ans%mod);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll mod=1e9+7;\\n        ll n=nums.size();\\n        vector<ll> prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(ll i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        ll ans=0;\\n        ll sum=0;\\n        ll total=prefix[n-1];\\n        for(int i=0;i<n-2;i++)\\n        {\\n            if(prefix[i]>total/3)\\n            break;\\n            ll j=lower_bound(prefix.begin()+i+1,prefix.end(),prefix[i]*2)-prefix.begin();\\n            ll l=upper_bound(prefix.begin()+i+1,prefix.end(),(total-prefix[i])/2+prefix[i])-prefix.begin();\\n            if(l<j)\\n            continue;\\n            else\\n            {\\n                if(l==n)\\n                {\\n                    ans=(ans%mod+(l-j-1)%mod)%mod;\\n                }\\n                else\\n                {\\n                    ans=(ans%mod+(l-j)%mod)%mod;\\n                }\\n            } \\n        }\\n        if(n==3&&ans>1)\\n        return 1;\\n        return (int)(ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949049,
                "title": "c-binary-search-prefix-sum",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n     int n = nums.size();\\n        \\n        // generate prefix sum\\n        for(int i=1;i<n;i++)nums[i]+=nums[i-1];\\n        \\n        int left  = 0;  // last pointer of first part\\n        int mid = 1;    // first pointer of middle part\\n        int right = 2;  // last pointer of middle part\\n        int count = 0;\\n        \\n        // loop through array and find the mid and right for each left pointer\\n        // as left pointer moves forward, mid and right pointer moves forward too\\n        while(left < n-2)\\n        {\\n            mid = max(mid,left+1);\\n            \\n            // move mid forward as long as sum till mid < 2 * sum till left  \\n            // goal is to find the minimum pointer of middle part for current left part\\n            while(mid<n-1 && nums[mid]<2*nums[left])mid++;\\n            \\n            right = max(mid,right);\\n\\n            // move right forward as long as mid part sum <= right part sum\\n            // goal is to find the maximum pointer of middle part for current left part\\n            while(right<n-1 && nums[right]-nums[left]<=nums[n-1]-nums[right])right++;\\n            \\n            count = (count + right - mid) % 1000000007;\\n            \\n            left++;\\n        }\\n        \\n        return count;   \\n    }\\n};\\n```\\n\\nUpvote If you liked.",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n     int n = nums.size();\\n        \\n        // generate prefix sum\\n        for(int i=1;i<n;i++)nums[i]+=nums[i-1];\\n        \\n        int left  = 0;  // last pointer of first part\\n        int mid = 1;    // first pointer of middle part\\n        int right = 2;  // last pointer of middle part\\n        int count = 0;\\n        \\n        // loop through array and find the mid and right for each left pointer\\n        // as left pointer moves forward, mid and right pointer moves forward too\\n        while(left < n-2)\\n        {\\n            mid = max(mid,left+1);\\n            \\n            // move mid forward as long as sum till mid < 2 * sum till left  \\n            // goal is to find the minimum pointer of middle part for current left part\\n            while(mid<n-1 && nums[mid]<2*nums[left])mid++;\\n            \\n            right = max(mid,right);\\n\\n            // move right forward as long as mid part sum <= right part sum\\n            // goal is to find the maximum pointer of middle part for current left part\\n            while(right<n-1 && nums[right]-nums[left]<=nums[n-1]-nums[right])right++;\\n            \\n            count = (count + right - mid) % 1000000007;\\n            \\n            left++;\\n        }\\n        \\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521389,
                "title": "brute-force-tle-python-0-n-2",
                "content": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0] * len(nums)\\n        prefix[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            prefix[i] += prefix[i - 1] + nums[i]\\n        ans = 0\\n        for i in range(1, len(nums) - 1):\\n            for j in range(i):\\n                # mid is non-existent in this case so continue\\n                if j == i:\\n                    continue\\n                left = prefix[j]\\n                mid = prefix[i] - prefix[j]\\n                right = prefix[-1] - (prefix[i])\\n                \\n                if left <= mid <= right:\\n                    ans += 1\\n        return ans\\n            \\n\\n```\\n\\nWe are essentially trying out all combinations of left, mid, and right ways to split the array, whenever we see a valid combination, we increment by 1. This times out, but its worth it to look at.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0] * len(nums)\\n        prefix[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            prefix[i] += prefix[i - 1] + nums[i]\\n        ans = 0\\n        for i in range(1, len(nums) - 1):\\n            for j in range(i):\\n                # mid is non-existent in this case so continue\\n                if j == i:\\n                    continue\\n                left = prefix[j]\\n                mid = prefix[i] - prefix[j]\\n                right = prefix[-1] - (prefix[i])\\n                \\n                if left <= mid <= right:\\n                    ans += 1\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435292,
                "title": "both-binary-search-o-n-log-n-and-two-pointers-o-n-with-o-n-space",
                "content": "Since we want to split array into 3 subarrays, we need to make two cuts, so that array will be divided into 3 parts. Also given sum of numbers in each parts must be greater than or equal to its previous part. It seems reasonable to take prefix sum of all elements and store them in array since **all elements in array are greater than or equal to 0. If we want to get the sum of elements in a given range [i,j] we can do prefixsum[j] - prefixsum[i - 1]**.\\n\\n**For each prefix sum P, we want to find F and L where F is the first position where F - P >= P and similary L -1 - P > E - (L - 1) where E is end of array**. \\n\\n**Now number of subarrays that satisfies our condition for a given prefix P is L - F**\\n\\n**Two pointers: O(n)**\\nWe maintain two pointers **j** and **k** For a given prefix P, from P + 1 to find F, we can increment a pointer as long as F - P >= P. This works since prefix sums are sorted in non-decreasing order. \\nSimilarly, to find F we do the same thing with another pointer k\\n```\\npublic int waysToSplit(int[] nums) {\\n\\tint count = 0, mod = 1_000_000_007, l = nums.length;\\n\\tfor(int i = 1; i < l; i++){\\n\\t\\tnums[i] += nums[i - 1];\\n\\t}\\n\\tfor(int i = 0, j = 0, k = 0; i < l - 2; i++){\\n\\t\\tif(j <= i){\\n\\t\\t\\tj = i + 1; //if j is less than i, move it after i to find F\\n\\t\\t}\\n\\t\\twhile(j < l - 1 && nums[i] > nums[j] - nums[i]){\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif(k < j) {\\n\\t\\t\\tk = j; //if k is greather than j, assign j to k, so that we find L\\n\\t\\t}\\n\\t\\twhile(k < l - 1 && nums[k] - nums[i] <= nums[l - 1] - nums[k]){\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\t//here k is the position where second subarray [i, k] is greater than third subarray [k, e]\\n\\t\\t//hence from j till before k, all those elements form second subarray for a given prefix sum P which is at i\\n\\t\\tcount = (count + k - j) % mod;\\n\\t}\\n\\treturn count;\\n}\\n```\\n\\n**Binary Search: O(n logn)**\\n1) For each prefix sum **P**, find where we can make next cut so that its sum is bigger than or equal to current prefix sum **P**. We can do binary search since prefix sums array is non-decreasing. Lets call it **F**\\n2) Similarly, once you find #1, do another binary search from F and find a position **L** where sum of elements from P to L is less than remaining sum (sum of elements from L to end of array **E**). Once we find L, we know that array is divided as [0, P] [P + 1, F] [P + 1, F + 1] [P + 1, F + 2] .... [p + 1, L - 1], [L - 1, E]. \\n```\\npublic int waysToSplit(int[] nums) {\\n\\tint[] psum = new int[nums.length];\\n\\tpsum[0] = nums[0];\\n\\tfor(int i = 1; i < nums.length; i++){\\n\\t\\tpsum[i] = nums[i] + psum[i - 1];\\n\\t}\\n\\tint mod = 1_000_000_007;\\n\\tint count = 0;\\n\\tfor(int i = 0; i < nums.length - 2; i++){\\n\\t\\tint fpos = findSecond(psum, i + 1, psum[i]);\\n\\t\\tint spos = findThird(psum, i + 1, psum[i]);\\n\\t\\tif(fpos < nums.length - 1 && spos < nums.length){\\n\\t\\t\\tif(psum[fpos] - psum[i] >= psum[i] && psum[spos - 1] - psum[i] <= psum[nums.length - 1] - psum[spos - 1]){\\n\\t\\t\\t\\tcount = (count + spos - fpos) % mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n\\nprivate int findSecond(int[] psum, int l, int esum){\\n\\tint h = psum.length - 1;\\n\\twhile(l < h){\\n\\t\\tint mid = l + (h - l) / 2;\\n\\t\\tif(psum[mid] - esum < esum) {\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}else if(psum[mid] - esum <= psum[psum.length - 1] - psum[mid]){\\n\\t\\t\\th = mid;\\n\\t\\t}else {\\n\\t\\t\\th = mid - 1;\\n\\t\\t}\\n\\t}\\n\\treturn l;\\n}\\nprivate int findThird(int[] psum, int l, int esum){\\n\\tint h = psum.length - 1;\\n\\twhile(l < h){\\n\\t\\tint mid = l + (h - l) / 2;\\n\\t\\tif(psum[mid] - esum < esum) {\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}else if(psum[mid] - esum <= psum[psum.length - 1] - psum[mid]){\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}else {\\n\\t\\t\\th = mid;\\n\\t\\t}\\n\\t}\\n\\treturn l;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int waysToSplit(int[] nums) {\\n\\tint count = 0, mod = 1_000_000_007, l = nums.length;\\n\\tfor(int i = 1; i < l; i++){\\n\\t\\tnums[i] += nums[i - 1];\\n\\t}\\n\\tfor(int i = 0, j = 0, k = 0; i < l - 2; i++){\\n\\t\\tif(j <= i){\\n\\t\\t\\tj = i + 1; //if j is less than i, move it after i to find F\\n\\t\\t}\\n\\t\\twhile(j < l - 1 && nums[i] > nums[j] - nums[i]){\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tif(k < j) {\\n\\t\\t\\tk = j; //if k is greather than j, assign j to k, so that we find L\\n\\t\\t}\\n\\t\\twhile(k < l - 1 && nums[k] - nums[i] <= nums[l - 1] - nums[k]){\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\t//here k is the position where second subarray [i, k] is greater than third subarray [k, e]\\n\\t\\t//hence from j till before k, all those elements form second subarray for a given prefix sum P which is at i\\n\\t\\tcount = (count + k - j) % mod;\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\npublic int waysToSplit(int[] nums) {\\n\\tint[] psum = new int[nums.length];\\n\\tpsum[0] = nums[0];\\n\\tfor(int i = 1; i < nums.length; i++){\\n\\t\\tpsum[i] = nums[i] + psum[i - 1];\\n\\t}\\n\\tint mod = 1_000_000_007;\\n\\tint count = 0;\\n\\tfor(int i = 0; i < nums.length - 2; i++){\\n\\t\\tint fpos = findSecond(psum, i + 1, psum[i]);\\n\\t\\tint spos = findThird(psum, i + 1, psum[i]);\\n\\t\\tif(fpos < nums.length - 1 && spos < nums.length){\\n\\t\\t\\tif(psum[fpos] - psum[i] >= psum[i] && psum[spos - 1] - psum[i] <= psum[nums.length - 1] - psum[spos - 1]){\\n\\t\\t\\t\\tcount = (count + spos - fpos) % mod;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n\\nprivate int findSecond(int[] psum, int l, int esum){\\n\\tint h = psum.length - 1;\\n\\twhile(l < h){\\n\\t\\tint mid = l + (h - l) / 2;\\n\\t\\tif(psum[mid] - esum < esum) {\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}else if(psum[mid] - esum <= psum[psum.length - 1] - psum[mid]){\\n\\t\\t\\th = mid;\\n\\t\\t}else {\\n\\t\\t\\th = mid - 1;\\n\\t\\t}\\n\\t}\\n\\treturn l;\\n}\\nprivate int findThird(int[] psum, int l, int esum){\\n\\tint h = psum.length - 1;\\n\\twhile(l < h){\\n\\t\\tint mid = l + (h - l) / 2;\\n\\t\\tif(psum[mid] - esum < esum) {\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}else if(psum[mid] - esum <= psum[psum.length - 1] - psum[mid]){\\n\\t\\t\\tl = mid + 1;\\n\\t\\t}else {\\n\\t\\t\\th = mid;\\n\\t\\t}\\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1358352,
                "title": "python-binary-search-with-explanation-for-linear-binary-approach",
                "content": "The first step to solving this problem is realizing that you are choosing a first array, and for each first array, you are choosing a second and third sub array that fulfills the condition. By using cumulative sums, your [1,2,2,2,5,0] array becomes [1,3,5,7,12,12].\\n\\nThis now makes it easier to do a linear search to see if a current sub array is larger than the previous sub array by just subtracting the prefix sum at one index with another. So if you want to solve this problem in o(n^2) you can just loop for each first subarray, you find a first and last index +1 for the second array in which the second subarray sum can sum up to. Why is it first and last+1? Because for first sub array [1], you can have [2], and [2,2] which would fulfill the conditions the problem is asking. Now notice when you get to [2,2,2], the condition no longer becomes true. \\n\\nOnce you have your first and last index, you add the difference to your output because the difference (4-2) is how many subarrays can work with the first given subarray [1].  Then you do the same thing for first subarray [1,2], and you find only [2,2] that works with it. So your first and last index would be [2,3], and add 3-2 to your output. \\n\\nNow what do you look exactly for first and last index? The minimum the second subarray can be is the equivalent of the first. This is also double the first prefix sum. The maximum can be the mid point of the start of the second subarray and the end of the array. \\n\\nThis is how you do the linear approach, and from there since the cumulative sum array is sorted, you can do a binary search.\\n```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n        ps = list(accumulate(nums))\\n        largest_split = cs[-1] / 3\\n        output = 0\\n\\n        def find_first(arr, t, l, r):\\n            while l < r:\\n                m = l+(r-l)//2\\n                if arr[m] >= t:\\n                    r = m\\n                else:\\n                    l = m+1\\n            return r\\n        \\n        def find_last(arr, t, l, r):\\n            while l < r:\\n                m = l+(r-l)//2\\n                if arr[m] <= t:\\n                    l = m+1\\n                else:\\n                    r = m\\n            return l\\n        for i in range(len(nums)-2):\\n            if ps[i] > largest_split: break\\n              \\n            left = find_first(cs, 2*cs[i], i+1,len(nums)-1)\\n            right = find_last(cs, (cs[-1] + cs[i])/2, i+1,len(nums)-1)\\n            output += right-left\\n\\t\\t\\n\\t\\treturn output\\n```",
                "solutionTags": [],
                "code": "```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n        ps = list(accumulate(nums))\\n        largest_split = cs[-1] / 3\\n        output = 0\\n\\n        def find_first(arr, t, l, r):\\n            while l < r:\\n                m = l+(r-l)//2\\n                if arr[m] >= t:\\n                    r = m\\n                else:\\n                    l = m+1\\n            return r\\n        \\n        def find_last(arr, t, l, r):\\n            while l < r:\\n                m = l+(r-l)//2\\n                if arr[m] <= t:\\n                    l = m+1\\n                else:\\n                    r = m\\n            return l\\n        for i in range(len(nums)-2):\\n            if ps[i] > largest_split: break\\n              \\n            left = find_first(cs, 2*cs[i], i+1,len(nums)-1)\\n            right = find_last(cs, (cs[-1] + cs[i])/2, i+1,len(nums)-1)\\n            output += right-left\\n\\t\\t\\n\\t\\treturn output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1210857,
                "title": "python-binary-search-prefix-sums",
                "content": "Once again we encounter the theme where we need to binary search over prefix sums. The idea is to exploit the monotonicity of the prefix sum array which can be searched in logarithmic time. Here we consider all splits ending at index `i` (where `i >= 2`) and find the leftmost index `j` and rightmost index `k` for which valid splits can be produced. That means we can have `k - j + 1` splits at `i`-th iteration. We need a left and right binary search to find `j` and `k`.\\n\\nThis time, however, it is slightly tricky, as we compare three sums during binary search. If `P[mi] <= P[i] - P[mi] <= x` is satisfied we have a valid condition and proceed as usual. Otherwise we need to split based on outcome. There are three more cases as shown in else-if statements below; basically, if the left sum is too large we increase `lo`, if the mid sum is too large we decrease `hi`. This will eventually terminate the while-loop; but we may not have a valid index (if the sums are not possible to satisfy, consider for example `[9 8 7]`). We therefore check the index at termination one last time and return an invalid index which will be checked in the main loop (`0` is invalid in prefix sum array).\\n\\nRemark: This is also an instructive question on how `bisect_left` and `bisect_right` are implemented. For the former we use `mi = lo + hi >> 1` whereas for the latter we have `mi = lo + hi + 1 >> 1`. But why do we do this? Let\\'s say we have `lo = 0` and `hi = 1` and both indices satisfy the requirment. For `bisect_left` we want to get `0` and for `bisect_right` we want `1`. While `lo + hi >> 1 = 1 // 2 = 0`, `lo + hi + 1 >> 1 = 2 // 2 = 1` and forgetting this will also cause infinite loop!\\n\\nTime: `O(N logN)`\\nSpace: `O(N)`\\n\\n```python\\nclass Solution:\\n    def bisect_left(self, P, i, x):\\n        lo, hi = 1, i - 1\\n        while lo < hi:\\n            mi = lo + hi >> 1\\n            if P[mi] <= P[i] - P[mi] <= x:\\n                hi = mi\\n            elif P[i] - P[mi] > x:\\n                lo = mi + 1\\n            elif P[mi] > x:\\n                hi = mi - 1\\n            elif P[mi] > P[i] - P[mi]:\\n                hi = mi - 1        \\n        return lo if P[lo] <= P[i] - P[lo] <= x else 0\\n    \\n    \\n    def bisect_right(self, P, i, x):\\n        lo, hi = 1, i - 1\\n        while lo < hi:\\n            mi = lo + hi + 1 >> 1\\n            if P[mi] <= P[i] - P[mi] <= x:\\n                lo = mi\\n            elif P[i] - P[mi] > x:\\n                lo = mi + 1\\n            elif P[mi] > x:\\n                hi = mi - 1\\n            elif P[mi] > P[i] - P[mi]:\\n                hi = mi - 1\\n        return lo if P[lo] <= P[i] - P[lo] <= x else 0\\n    \\n    \\n    def waysToSplit(self, nums):\\n        ans = 0\\n        P = [0] + list(accumulate(nums))\\n        for i in range(2, len(nums)):\\n            x = P[-1] - P[i]\\n            j = self.bisect_left(P, i, x)\\n            k = self.bisect_right(P, i, x)\\n            if j == 0 or k == 0:\\n                continue\\n            ans += k - j + 1\\n            ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def bisect_left(self, P, i, x):\\n        lo, hi = 1, i - 1\\n        while lo < hi:\\n            mi = lo + hi >> 1\\n            if P[mi] <= P[i] - P[mi] <= x:\\n                hi = mi\\n            elif P[i] - P[mi] > x:\\n                lo = mi + 1\\n            elif P[mi] > x:\\n                hi = mi - 1\\n            elif P[mi] > P[i] - P[mi]:\\n                hi = mi - 1        \\n        return lo if P[lo] <= P[i] - P[lo] <= x else 0\\n    \\n    \\n    def bisect_right(self, P, i, x):\\n        lo, hi = 1, i - 1\\n        while lo < hi:\\n            mi = lo + hi + 1 >> 1\\n            if P[mi] <= P[i] - P[mi] <= x:\\n                lo = mi\\n            elif P[i] - P[mi] > x:\\n                lo = mi + 1\\n            elif P[mi] > x:\\n                hi = mi - 1\\n            elif P[mi] > P[i] - P[mi]:\\n                hi = mi - 1\\n        return lo if P[lo] <= P[i] - P[lo] <= x else 0\\n    \\n    \\n    def waysToSplit(self, nums):\\n        ans = 0\\n        P = [0] + list(accumulate(nums))\\n        for i in range(2, len(nums)):\\n            x = P[-1] - P[i]\\n            j = self.bisect_left(P, i, x)\\n            k = self.bisect_right(P, i, x)\\n            if j == 0 or k == 0:\\n                continue\\n            ans += k - j + 1\\n            ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209135,
                "title": "simple-o-n-time-solution-without-binary-search-python",
                "content": "```\\nclass Solution:\\n    def waysToSplit(self, nums):\\n        ans = 0\\n        psum = [nums[0]]\\n        for i in range(1,len(nums)):\\n            psum.append(psum[-1] + nums[i])\\n        i = 0\\n        j = 1\\n        k = 1\\n        while(i<len(psum)-1):\\n            j = max(i+1,j)\\n            while(j<len(psum)-1):\\n                if psum[j]-psum[i] - (psum[i])>=0:\\n                    break \\n                j+=1\\n            k = max(j,k)\\n            while(k<len(psum)-1):\\n                if psum[-1] - psum[k] - (psum[k]-psum[i])<0:\\n                    break \\n                k+=1\\n            ans+=(k-j)\\n            i+=1\\n        return ans%(1000000007)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums):\\n        ans = 0\\n        psum = [nums[0]]\\n        for i in range(1,len(nums)):\\n            psum.append(psum[-1] + nums[i])\\n        i = 0\\n        j = 1\\n        k = 1\\n        while(i<len(psum)-1):\\n            j = max(i+1,j)\\n            while(j<len(psum)-1):\\n                if psum[j]-psum[i] - (psum[i])>=0:\\n                    break \\n                j+=1\\n            k = max(j,k)\\n            while(k<len(psum)-1):\\n                if psum[-1] - psum[k] - (psum[k]-psum[i])<0:\\n                    break \\n                k+=1\\n            ans+=(k-j)\\n            i+=1\\n        return ans%(1000000007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178236,
                "title": "3-pointers-o-n-time-o-1-space-oop-python",
                "content": "For the three segments [s1,s2,s3], keep 3 pointers :\\n1.  end of s1 / begining of s2\\n2.  minimum end of s2 such sum(s2) >= sum(s1)\\n3.  maximum end of S2 such sum(s2) <=sum(s3)\\n\\n```\\nclass sumPart:\\n    def __init__(self, s:int, e:int, su:0) -> None:\\n        self.start = s\\n        self.end =e\\n        self.sum =su\\n    def print(self, tag:str = \\'\\'):\\n        print(tag,self.start,self.end,self.sum)\\n\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        limit = 10**9 + 7\\n        if len(nums) <3:\\n            return 0\\n        s = sum(nums)\\n        r=0\\n        s1 = sumPart(0,1,nums[0])\\n        s2 = sumPart(1,2,nums[1])\\n        while s2.end<len(nums) and s2.sum<s1.sum:\\n            s2.sum+=nums[s2.end]\\n            s2.end+=1\\n        s3 = sumPart(len(nums)-1,len(nums),nums[-1])\\n        while s3.start>s2.end and s3.sum*2< (s-s1.sum):\\n            s3.start-=1\\n            s3.sum+=nums[s3.start]\\n            \\n        while  s2.end < len(nums):# s1.sum<=s2.sum: # and s2.sum<=s3.sum s3.start>=s2.end and\\n            r+=max(s3.start-s2.end+1,0)\\n            r%=limit\\n            s1.sum+=nums[s1.end]\\n            s1.end+=1\\n            s2.sum-=nums[s2.start]\\n            s2.start+=1\\n            while s2.end < len(nums) and (s2.sum< s1.sum or s2.end==s2.start):\\n                s2.sum+=nums[s2.end]\\n                s2.end+=1\\n            while s3.start<len(nums)-1 and (s3.sum-nums[s3.start])*2>= (s-s1.sum) :\\n                s3.sum-=nums[s3.start]\\n                s3.start+=1\\n            \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass sumPart:\\n    def __init__(self, s:int, e:int, su:0) -> None:\\n        self.start = s\\n        self.end =e\\n        self.sum =su\\n    def print(self, tag:str = \\'\\'):\\n        print(tag,self.start,self.end,self.sum)\\n\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        limit = 10**9 + 7\\n        if len(nums) <3:\\n            return 0\\n        s = sum(nums)\\n        r=0\\n        s1 = sumPart(0,1,nums[0])\\n        s2 = sumPart(1,2,nums[1])\\n        while s2.end<len(nums) and s2.sum<s1.sum:\\n            s2.sum+=nums[s2.end]\\n            s2.end+=1\\n        s3 = sumPart(len(nums)-1,len(nums),nums[-1])\\n        while s3.start>s2.end and s3.sum*2< (s-s1.sum):\\n            s3.start-=1\\n            s3.sum+=nums[s3.start]\\n            \\n        while  s2.end < len(nums):# s1.sum<=s2.sum: # and s2.sum<=s3.sum s3.start>=s2.end and\\n            r+=max(s3.start-s2.end+1,0)\\n            r%=limit\\n            s1.sum+=nums[s1.end]\\n            s1.end+=1\\n            s2.sum-=nums[s2.start]\\n            s2.start+=1\\n            while s2.end < len(nums) and (s2.sum< s1.sum or s2.end==s2.start):\\n                s2.sum+=nums[s2.end]\\n                s2.end+=1\\n            while s3.start<len(nums)-1 and (s3.sum-nums[s3.start])*2>= (s-s1.sum) :\\n                s3.sum-=nums[s3.start]\\n                s3.start+=1\\n            \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073788,
                "title": "o-1-space-complexity-without-modity-original-nums",
                "content": "it is very similar like this solution ,but i calculate the sum to avoid modify origianal nums.\\nhttps://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/999257/C%2B%2BJavaPython-O(n)-with-picture\\n```java\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n=nums.length;\\n        int j=-1,k=-1,si=0,sj=0,sk=0,ans=0,mod=(int)1e9+7;\\n        int sum=0;\\n        for (int num:nums) sum+=num;\\n        for (int i=0;i<n-2;i++){\\n            si+=nums[i];\\n            while (j<=i || (j<n-1 && sj-si<si)) \\n                sj+=nums[++j];\\n            while (k<j || (k<n-1 && sum-sk>=sk-si)) \\n                sk+=nums[++k];\\n            ans=(ans+k-j)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```java\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n=nums.length;\\n        int j=-1,k=-1,si=0,sj=0,sk=0,ans=0,mod=(int)1e9+7;\\n        int sum=0;\\n        for (int num:nums) sum+=num;\\n        for (int i=0;i<n-2;i++){\\n            si+=nums[i];\\n            while (j<=i || (j<n-1 && sj-si<si)) \\n                sj+=nums[++j];\\n            while (k<j || (k<n-1 && sum-sk>=sk-si)) \\n                sk+=nums[++k];\\n            ans=(ans+k-j)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000615,
                "title": "javascript-go-3-pointers-time-o-n-space-o-1",
                "content": "Simple solution to find the first index and last index of the middle section\\n```javascript\\nvar waysToSplit = function(nums) {\\n    const mod = 1000000007;\\n    const lastIndex = nums.length - 2;\\n    const total = nums.reduce((sum, num) => sum + num)\\n\\n    let midLeftPtr = -1;\\n    let midRightPtr = -1;\\n    \\n    let leftSum = 0;\\n    let midLeftSum = 0;\\n    let midRightSum = 0;\\n    \\n    let numWaysToSplit = 0;\\n    \\n    for (let leftPtr = 0; leftPtr < nums.length; leftPtr++) {\\n        leftSum += nums[leftPtr];        \\n        midLeftSum -= nums[leftPtr];\\n        midRightSum -= nums[leftPtr];\\n\\n       // find the first index that satisfies the middle sum\\n\\t   // being greater than or equal to the left sum\\n        while (midLeftPtr <= lastIndex && \\n               (midLeftPtr <= leftPtr || midLeftSum < leftSum)) {\\n            midLeftPtr++;\\n            midLeftSum += nums[midLeftPtr]\\n        }\\n\\n        // find the first index that makes the middle sum greater than the right sum\\n        while (midRightPtr <= lastIndex && \\n               (midLeftPtr > midRightPtr || midRightSum <= total - midRightSum - leftSum)) {\\n            midRightPtr++\\n            midRightSum += nums[midRightPtr]\\n        }\\n        numWaysToSplit = (numWaysToSplit + midRightPtr - midLeftPtr) % mod;\\n    }\\n    return numWaysToSplit\\n};\\n```\\n```go\\n/////////////////////////////////////////////////////////////////////////////////////////////////////\\n/////////////////////////////////////////////////////////////////////////////////////////////////////\\n/////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n\\nfunc waysToSplit(nums []int) int {\\n    mod := 1000000007\\n    lastIdx := len(nums) - 2\\n    \\n    \\n    total, leftSum, midLeftSum, midRightSum := 0, 0, 0, 0\\n    for _, num := range nums {\\n        total += num\\n    }\\n    \\n    midLeftIdx, midRightIdx := -1, -1\\n    \\n    numWaysToSplit := 0\\n    for leftIdx := 0; leftIdx < lastIdx; leftIdx++ {\\n        leftSum += nums[leftIdx]\\n        midLeftSum -= nums[leftIdx];\\n        midRightSum -= nums[leftIdx];\\n\\n        // find the first index that the middle section is valid\\n        for (midLeftIdx <= lastIdx && \\n               (midLeftIdx <= leftIdx || midLeftSum < leftSum)) {\\n            midLeftIdx++;\\n            midLeftSum += nums[midLeftIdx]\\n        }\\n\\n        // find the first index that makes the comparison between the\\n        // middle and right index invalid\\n        for (midRightIdx <= lastIdx && \\n               (midLeftIdx > midRightIdx || midRightSum <= total - midRightSum - leftSum)) {\\n            midRightIdx++\\n            midRightSum += nums[midRightIdx]\\n        }\\n        numWaysToSplit = (numWaysToSplit + midRightIdx - midLeftIdx) % mod;\\n    }\\n    return numWaysToSplit\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go"
                ],
                "code": "```javascript\\nvar waysToSplit = function(nums) {\\n    const mod = 1000000007;\\n    const lastIndex = nums.length - 2;\\n    const total = nums.reduce((sum, num) => sum + num)\\n\\n    let midLeftPtr = -1;\\n    let midRightPtr = -1;\\n    \\n    let leftSum = 0;\\n    let midLeftSum = 0;\\n    let midRightSum = 0;\\n    \\n    let numWaysToSplit = 0;\\n    \\n    for (let leftPtr = 0; leftPtr < nums.length; leftPtr++) {\\n        leftSum += nums[leftPtr];        \\n        midLeftSum -= nums[leftPtr];\\n        midRightSum -= nums[leftPtr];\\n\\n       // find the first index that satisfies the middle sum\\n\\t   // being greater than or equal to the left sum\\n        while (midLeftPtr <= lastIndex && \\n               (midLeftPtr <= leftPtr || midLeftSum < leftSum)) {\\n            midLeftPtr++;\\n            midLeftSum += nums[midLeftPtr]\\n        }\\n\\n        // find the first index that makes the middle sum greater than the right sum\\n        while (midRightPtr <= lastIndex && \\n               (midLeftPtr > midRightPtr || midRightSum <= total - midRightSum - leftSum)) {\\n            midRightPtr++\\n            midRightSum += nums[midRightPtr]\\n        }\\n        numWaysToSplit = (numWaysToSplit + midRightPtr - midLeftPtr) % mod;\\n    }\\n    return numWaysToSplit\\n};\\n```\n```go\\n/////////////////////////////////////////////////////////////////////////////////////////////////////\\n/////////////////////////////////////////////////////////////////////////////////////////////////////\\n/////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n\\nfunc waysToSplit(nums []int) int {\\n    mod := 1000000007\\n    lastIdx := len(nums) - 2\\n    \\n    \\n    total, leftSum, midLeftSum, midRightSum := 0, 0, 0, 0\\n    for _, num := range nums {\\n        total += num\\n    }\\n    \\n    midLeftIdx, midRightIdx := -1, -1\\n    \\n    numWaysToSplit := 0\\n    for leftIdx := 0; leftIdx < lastIdx; leftIdx++ {\\n        leftSum += nums[leftIdx]\\n        midLeftSum -= nums[leftIdx];\\n        midRightSum -= nums[leftIdx];\\n\\n        // find the first index that the middle section is valid\\n        for (midLeftIdx <= lastIdx && \\n               (midLeftIdx <= leftIdx || midLeftSum < leftSum)) {\\n            midLeftIdx++;\\n            midLeftSum += nums[midLeftIdx]\\n        }\\n\\n        // find the first index that makes the comparison between the\\n        // middle and right index invalid\\n        for (midRightIdx <= lastIdx && \\n               (midLeftIdx > midRightIdx || midRightSum <= total - midRightSum - leftSum)) {\\n            midRightIdx++\\n            midRightSum += nums[midRightIdx]\\n        }\\n        numWaysToSplit = (numWaysToSplit + midRightIdx - midLeftIdx) % mod;\\n    }\\n    return numWaysToSplit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999171,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size(), mod = 1e9 + 7;\\n        vector<int> prefix(n, 0);\\n        long count = 0;\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = nums[i] + prefix[i - 1];\\n        }\\n     \\n        for (int i = 0; i < n - 2; i++) {\\n            int left = prefix[i];\\n            int remain = prefix[n - 1] - left;\\n            if (remain < left * 2) break;\\n            int leftPtr = lower_bound(prefix.begin() + i + 1, prefix.end() - 1, left * 2) - prefix.begin();\\n            int rightPtr = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, left + remain / 2) - prefix.begin() - 1;\\n            if (rightPtr - leftPtr + 1 > 0) count += rightPtr - leftPtr + 1;\\n        }\\n        \\n        return count % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size(), mod = 1e9 + 7;\\n        vector<int> prefix(n, 0);\\n        long count = 0;\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = nums[i] + prefix[i - 1];\\n        }\\n     \\n        for (int i = 0; i < n - 2; i++) {\\n            int left = prefix[i];\\n            int remain = prefix[n - 1] - left;\\n            if (remain < left * 2) break;\\n            int leftPtr = lower_bound(prefix.begin() + i + 1, prefix.end() - 1, left * 2) - prefix.begin();\\n            int rightPtr = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, left + remain / 2) - prefix.begin() - 1;\\n            if (rightPtr - leftPtr + 1 > 0) count += rightPtr - leftPtr + 1;\\n        }\\n        \\n        return count % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999150,
                "title": "easy-double-binary-search-straightforward-solution",
                "content": "I liked this question, Used double binary search for first time !!!!\\n\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long n=nums.size(), M=1000000007;\\n        vector<long> pref(n);\\n        pref[0]=nums[0];\\n        \\n        for(long i=1; i<n; ++i) pref[i]=pref[i-1]+nums[i];\\n        \\n        long res=0;\\n        \\n        for(long i=0; i<n-2; ++i){\\n\\t\\t\\t//lsum is sum of left segment\\n            long lsum=pref[i];\\n\\t\\t\\t//mr is end point of middle segment\\n            long mr= lower_bound(pref.begin(), pref.end(), 2*lsum)-pref.begin();\\n            mr=max(mr, i+1);\\n            if(mr>=n-1) continue;\\n            \\n\\t\\t\\t//Binary search for possible values of mr such that Sum(mid)<=Sum(right)\\n            long l=mr, r=n-2, ans=0;\\n            while(l<=r){\\n                long mid=(l+r)/2;\\n                long Sm= pref[mid]-lsum;\\n                long Sr= pref[n-1]-pref[mid];\\n                \\n                if(Sm<=Sr) { ans=max(ans, mid); l=mid+1; }\\n                else r=mid-1;\\n            }\\n            // cout<<lsum<<\" \"<<mr<<\" \"<<ans<<endl;\\n            if(ans>=mr) res+=ans-mr+1;\\n            res%=M;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCode is self explanatory, I guess.\\nAnyways, You can always raise your doubts in comments.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long n=nums.size(), M=1000000007;\\n        vector<long> pref(n);\\n        pref[0]=nums[0];\\n        \\n        for(long i=1; i<n; ++i) pref[i]=pref[i-1]+nums[i];\\n        \\n        long res=0;\\n        \\n        for(long i=0; i<n-2; ++i){\\n\\t\\t\\t//lsum is sum of left segment\\n            long lsum=pref[i];\\n\\t\\t\\t//mr is end point of middle segment\\n            long mr= lower_bound(pref.begin(), pref.end(), 2*lsum)-pref.begin();\\n            mr=max(mr, i+1);\\n            if(mr>=n-1) continue;\\n            \\n\\t\\t\\t//Binary search for possible values of mr such that Sum(mid)<=Sum(right)\\n            long l=mr, r=n-2, ans=0;\\n            while(l<=r){\\n                long mid=(l+r)/2;\\n                long Sm= pref[mid]-lsum;\\n                long Sr= pref[n-1]-pref[mid];\\n                \\n                if(Sm<=Sr) { ans=max(ans, mid); l=mid+1; }\\n                else r=mid-1;\\n            }\\n            // cout<<lsum<<\" \"<<mr<<\" \"<<ans<<endl;\\n            if(ans>=mr) res+=ans-mr+1;\\n            res%=M;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355293,
                "title": "c-prefix-sum-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i] = pref[i-1]+nums[i];\\n        }\\n        int ans=0;\\n        for(int i=n-1;i>=2;i--)\\n        {\\n            int l = 1,r = i-1;\\n            int sum3 = pref[n-1]-pref[i-1];\\n            int idx1 = -1,idx2 = -1;\\n            while(l<=r)\\n            {\\n                int mid = (l+r)/2;\\n                int sum1 = pref[mid-1];\\n                int sum2 = pref[i-1]-sum1;\\n                if(sum1<=sum2 && sum2<=sum3 && sum1<=sum3)\\n                {\\n                    idx1 = mid;\\n                    l = mid+1;\\n                }\\n                else if(sum1>sum2)\\n                r = mid-1;\\n                else\\n                l = mid+1;\\n            }\\n            l = 1,r= i-1;\\n            while(l<=r)\\n            {\\n                int mid = (l+r)/2;\\n                int sum1 = pref[mid-1];\\n                int sum2 = pref[i-1]-sum1;\\n                if(sum1<=sum2 && sum2<=sum3 && sum1<=sum3)\\n                {\\n                    idx2 = mid;\\n                    r = mid-1;\\n                }\\n                else if(sum1>sum2)\\n                r = mid-1;\\n                else \\n                l = mid+1;\\n            }\\n            if(idx1!=idx2 && idx1!=-1 && idx2!=-1)\\n            {\\n                ans = (ans+((idx1-idx2)+1))%mod;\\n            }\\n            else if(idx1!=-1 || idx2!=-1)\\n            {\\n                ans = (ans+1)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pref(n);\\n        pref[0] = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pref[i] = pref[i-1]+nums[i];\\n        }\\n        int ans=0;\\n        for(int i=n-1;i>=2;i--)\\n        {\\n            int l = 1,r = i-1;\\n            int sum3 = pref[n-1]-pref[i-1];\\n            int idx1 = -1,idx2 = -1;\\n            while(l<=r)\\n            {\\n                int mid = (l+r)/2;\\n                int sum1 = pref[mid-1];\\n                int sum2 = pref[i-1]-sum1;\\n                if(sum1<=sum2 && sum2<=sum3 && sum1<=sum3)\\n                {\\n                    idx1 = mid;\\n                    l = mid+1;\\n                }\\n                else if(sum1>sum2)\\n                r = mid-1;\\n                else\\n                l = mid+1;\\n            }\\n            l = 1,r= i-1;\\n            while(l<=r)\\n            {\\n                int mid = (l+r)/2;\\n                int sum1 = pref[mid-1];\\n                int sum2 = pref[i-1]-sum1;\\n                if(sum1<=sum2 && sum2<=sum3 && sum1<=sum3)\\n                {\\n                    idx2 = mid;\\n                    r = mid-1;\\n                }\\n                else if(sum1>sum2)\\n                r = mid-1;\\n                else \\n                l = mid+1;\\n            }\\n            if(idx1!=idx2 && idx1!=-1 && idx2!=-1)\\n            {\\n                ans = (ans+((idx1-idx2)+1))%mod;\\n            }\\n            else if(idx1!=-1 || idx2!=-1)\\n            {\\n                ans = (ans+1)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147756,
                "title": "python-two-pointer-with-prefix-sum",
                "content": "# Intuition\\nSplitting array into three subarrays, but mainly from [lzl124631x, Explanation.](https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/solutions/999795/c-3-pointers-o-n-time-o-1-space/)\\n\\n***Check out above solution, and check code below for commented code explanation.***\\n\\n# Approach: *Two Pointer with Prefix Sum*\\n\\n# Complexity: \\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        i = 0\\n        j = 0\\n        k = 0\\n        mod = (10 ** 9) + 7\\n        result = 0\\n\\n        # Things to remember, \\n        # i will be pointing to index of end of the left subarray\\n        # j will be pointing to index of start of the mid subarray\\n        # k will be pointing to index of end of the right subarray\\n\\n        # Now, How to get subarray sum for left, mid and right subarray,\\n        # we can create prefix sum array\\n\\n        prefixSum = nums.copy()\\n        for i in range(1, len(nums)):\\n            prefixSum[i] += prefixSum[i - 1]\\n\\n        # Now how to get left subarray sum,\\n        # Simple, since i points to end of left subarray\\n        # left subarray sum = prefixSum[i]\\n\\n        # Now, how to get mid subarray sum\\n        # mid subarray sum = prefixSum[i] - left subarray sum\\n        \\n        # How, to get right subarray sum\\n        # right subarray sum = prefixSum[-1] - prefixSum[k], since k points to end of mid subarray\\n\\n        # Whole purpose is to expand left subarray and mid subarray\\n        for i in range(len(prefixSum)):\\n            # left subarray sum\\n            left = prefixSum[i]\\n            # Where to start, j, either from its current position but it must be greater than i, as it is start of mid subarray\\n            j = max(i + 1, j)\\n            # Now, we will increase j pointer, until we get a mid subarray sum greater than left subarray sum\\n            # Logic:? j points to start of the mid, leftSum <= midSum\\n            # prefixSum[j] - left(left subarray sum) should be less than leftSum\\n            while j < len(prefixSum) and prefixSum[j] - left < left:\\n                j += 1\\n            # No num left for right\\n            if j >= len(prefixSum):\\n                break\\n            # Need to find right subarray sum\\n            # Logic, Since, k is the end of mid subarray,\\n            # right subarray sum should be greater than mid subarray sum\\n            # right > mid\\n            # prefixSum[-1] - prefixSum[k] >= prefixSum[k] - prefixSum[i]\\n            k = max(j, k)\\n            while k < len(prefixSum) - 1 and prefixSum[-1] - prefixSum[k] >= prefixSum[k] - prefixSum[i]:\\n                k += 1\\n            # What will be the result, Number of mid subarrays we can create\\n            # So, it will be number of elements in midSubarray, i,e end point of midSubarray (k) - start point of the midSubarray\\n            # Number of possible middle subarrays is k - j\\n            result = (result + k - j) % mod\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        i = 0\\n        j = 0\\n        k = 0\\n        mod = (10 ** 9) + 7\\n        result = 0\\n\\n        # Things to remember, \\n        # i will be pointing to index of end of the left subarray\\n        # j will be pointing to index of start of the mid subarray\\n        # k will be pointing to index of end of the right subarray\\n\\n        # Now, How to get subarray sum for left, mid and right subarray,\\n        # we can create prefix sum array\\n\\n        prefixSum = nums.copy()\\n        for i in range(1, len(nums)):\\n            prefixSum[i] += prefixSum[i - 1]\\n\\n        # Now how to get left subarray sum,\\n        # Simple, since i points to end of left subarray\\n        # left subarray sum = prefixSum[i]\\n\\n        # Now, how to get mid subarray sum\\n        # mid subarray sum = prefixSum[i] - left subarray sum\\n        \\n        # How, to get right subarray sum\\n        # right subarray sum = prefixSum[-1] - prefixSum[k], since k points to end of mid subarray\\n\\n        # Whole purpose is to expand left subarray and mid subarray\\n        for i in range(len(prefixSum)):\\n            # left subarray sum\\n            left = prefixSum[i]\\n            # Where to start, j, either from its current position but it must be greater than i, as it is start of mid subarray\\n            j = max(i + 1, j)\\n            # Now, we will increase j pointer, until we get a mid subarray sum greater than left subarray sum\\n            # Logic:? j points to start of the mid, leftSum <= midSum\\n            # prefixSum[j] - left(left subarray sum) should be less than leftSum\\n            while j < len(prefixSum) and prefixSum[j] - left < left:\\n                j += 1\\n            # No num left for right\\n            if j >= len(prefixSum):\\n                break\\n            # Need to find right subarray sum\\n            # Logic, Since, k is the end of mid subarray,\\n            # right subarray sum should be greater than mid subarray sum\\n            # right > mid\\n            # prefixSum[-1] - prefixSum[k] >= prefixSum[k] - prefixSum[i]\\n            k = max(j, k)\\n            while k < len(prefixSum) - 1 and prefixSum[-1] - prefixSum[k] >= prefixSum[k] - prefixSum[i]:\\n                k += 1\\n            # What will be the result, Number of mid subarrays we can create\\n            # So, it will be number of elements in midSubarray, i,e end point of midSubarray (k) - start point of the midSubarray\\n            # Number of possible middle subarrays is k - j\\n            result = (result + k - j) % mod\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036333,
                "title": "clean-and-easy-to-understand-solution-java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intution to this problem is to observe that instead of iterating over every case and finding the sum of the three splits, we can do binary search to find the first and last case which satisfies the given conditions. The difference between the first and the last case will be the number of splits possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[1, 2, 4, 5, 6]\\nLet this be the input.\\nFirst we will find the prefix sum of this array to access sum of the splits in O(1) complexity.\\n\\n[1, 3, 7, 12, 18]\\nthen we will iterate over the array till len - 3 index, because we will require atleast two index len - 2 and len - 1 for middle and last split\\n\\ntwo pointers j and k can be used to satisfy the conditions:\\n1. nums[j] - nums[i] >= nums[i]\\n2. nums[k] - nums[i] > nums[n - 1] - nums[k]\\n\\nj and k are found using binary search\\nRange j - k, is the accepted range.\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        long res = 0;\\n        // finding prefix sum\\n        for(int i = 1; i < n; i++) nums[i] += nums[i - 1];\\n        for(int i = 0; i < n - 2; i++){\\n            // j to k will be the range for which we get good split\\n            // 0 - i, first.... i - j/k, second..... j/k - n - 1, thrid\\n            int j = i + 1;\\n            int right = n - 2;\\n            // this binary search will satisfy the condition for first and second splits\\n            while(j <= right){\\n                int mid = (j + right)/2;\\n                if(nums[mid] - nums[i] < nums[i]) j = mid + 1;\\n                else right = mid - 1; \\n            }\\n            int k = j;\\n            right = n - 2;\\n            // this BS will satisfy the condition for second and thrid splits\\n            while(k <= right){\\n                int mid = (k + right)/2;\\n                if(nums[mid] - nums[i] <= nums[n - 1] - nums[mid]) k = mid + 1;\\n                else right = mid - 1; \\n            }\\n            // now we can simply add the range k - j into our result\\n            res = (res + k - j) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\n\\nThank you\\nUpvote if found helpful\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        long res = 0;\\n        // finding prefix sum\\n        for(int i = 1; i < n; i++) nums[i] += nums[i - 1];\\n        for(int i = 0; i < n - 2; i++){\\n            // j to k will be the range for which we get good split\\n            // 0 - i, first.... i - j/k, second..... j/k - n - 1, thrid\\n            int j = i + 1;\\n            int right = n - 2;\\n            // this binary search will satisfy the condition for first and second splits\\n            while(j <= right){\\n                int mid = (j + right)/2;\\n                if(nums[mid] - nums[i] < nums[i]) j = mid + 1;\\n                else right = mid - 1; \\n            }\\n            int k = j;\\n            right = n - 2;\\n            // this BS will satisfy the condition for second and thrid splits\\n            while(k <= right){\\n                int mid = (k + right)/2;\\n                if(nums[mid] - nums[i] <= nums[n - 1] - nums[mid]) k = mid + 1;\\n                else right = mid - 1; \\n            }\\n            // now we can simply add the range k - j into our result\\n            res = (res + k - j) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857785,
                "title": "clean-java-binary-search-o-n-logn",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = (int) (1e9 + 7);\\n    public int waysToSplit(int[] nums) {\\n        if (nums == null || nums.length < 3 ) {\\n            return 0;\\n        }\\n        int n = nums.length;\\n        int[] prefixSum = new int[n];\\n        int curSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            curSum += nums[i];\\n            prefixSum[i] = curSum;\\n        }\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int part1 = prefixSum[i];\\n            int left = i + 1;\\n            int right = n - 2;\\n\\n            int cut1 = -1;\\n            int cut2 = -1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                if (part2 >= part1) {  \\n                // cut1 should be as left as possible\\n                    cut1 = mid;\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            left = i + 1;\\n            right = n - 2;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                int part3 = prefixSum[n - 1] - prefixSum[mid];\\n                if (part3 >= part2) {\\n                // cut2 should be as right as possible\\n                    cut2 = mid;\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } \\n\\n            if (cut1 == -1 || cut2 == -1 || cut1 > cut2) {\\n                continue;\\n            }\\n            int curcnt = cut2 - cut1 + 1;\\n            res += curcnt;\\n            res %= MOD;\\n\\n        } \\n        return (int) res;\\n\\n    }\\n}\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = (int) (1e9 + 7);\\n    public int waysToSplit(int[] nums) {\\n        if (nums == null || nums.length < 3 ) {\\n            return 0;\\n        }\\n        int n = nums.length;\\n        int[] prefixSum = new int[n];\\n        int curSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            curSum += nums[i];\\n            prefixSum[i] = curSum;\\n        }\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int part1 = prefixSum[i];\\n            int left = i + 1;\\n            int right = n - 2;\\n\\n            int cut1 = -1;\\n            int cut2 = -1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                if (part2 >= part1) {  \\n                // cut1 should be as left as possible\\n                    cut1 = mid;\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            left = i + 1;\\n            right = n - 2;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                int part3 = prefixSum[n - 1] - prefixSum[mid];\\n                if (part3 >= part2) {\\n                // cut2 should be as right as possible\\n                    cut2 = mid;\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } \\n\\n            if (cut1 == -1 || cut2 == -1 || cut1 > cut2) {\\n                continue;\\n            }\\n            int curcnt = cut2 - cut1 + 1;\\n            res += curcnt;\\n            res %= MOD;\\n\\n        } \\n        return (int) res;\\n\\n    }\\n}\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833557,
                "title": "python-o-n-2-o-nlogn-well-commented-solution",
                "content": "# **1. BRUTE FORCE - O(N^2) - TLE**\\n\\n```\\ndef waysToSplit(self, nums: List[int]) -> int:    \\n\\n\\tways = 0      \\n\\n\\t# Since there are three subarrays\\n\\t# It means, basically, there are two boundaries. \\n\\t# left | mid | right => Here, each pipe (|) is a boundary\\n\\n\\t# Wherever \"left\" subarray ends, let\\'s say that index is \"i\"\\n\\t# Now for every \"i\", we can try to find the index where \"mid\" subarray ends\\n\\t# Such that, the condition given in problem is satisfied\\n\\tn = len(nums)\\n\\n\\t# First, we convert the given array into a prefix sum array\\n\\tfor i in range(1, n): nums[i] = nums[i - 1] + nums[i]\\n\\n\\t# The prefix sum array will help in such a way that\\n\\n\\t# Suppose the \"left\" subarray ends at index \"left\"\\n\\t# Suppose the \"mid\" subarray starts at index \"left + 1\" and ends at index \"mid\"\\n\\t# And finally, suppose the \"right\" subarray starts at index \"mid + 1\" and ends at index \"right\"\\n\\n\\t# To find the sum of \"mid\" subarray, all we need to do is nums[mid] - nums[left]\\n\\t# To find sum of \"left\" subarray, we just do nums[left]\\n\\t# To find sum of \"right\" subarray, we just do nums[right] - nums[mid]\\n\\n\\t# For every i (index where \"left\" subarray ends)\\n\\t# Since \"mid\" and \"right\" subarrays need to have at least one element\\n\\t# The last index of \"left\" subarray can be up to \"n-3\" index\\n\\n\\tfor i in range(n-2):\\n\\t\\t# Each \"j\" index is the index at which \"mid\" subarray ends\\n\\t\\tfor j in range(i + 1, n):\\n\\t\\t\\tleftSubarraySum = nums[i]\\n\\t\\t\\tmidSubarraySum = nums[j] - nums[i]\\n\\t\\t\\trightSubarraySum = nums[n - 1] - nums[j]\\n\\n\\t\\t\\tif (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum): \\n\\t\\t\\t\\tways += 1\\n\\n\\treturn ways % 1000000007\\n```\\n\\n\\n# **2. BINARY SEARCH - O(NLogN)**\\n\\n```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n        \\n        # Why did the Brute Force solution gave TLE?\\n        # Because for each \"i\", we have to go through each possible \"j\"\\n        # Instead of this, what if we can find the leftmost valid \"j\" and rightmost valid \"j\"\\n        # In that way, the number of ways for that \"i\" is simply \"rightmostIndex - leftmostIndex + 1\"\\n        # ANd that\\'s where the Binary Search approach comes into picture.\\n        \\n        n = len(nums)\\n        \\n        # First, we convert the given array into a prefix sum array\\n        for i in range(1, n): nums[i] = nums[i - 1] + nums[i]\\n        \\n        ways = 0\\n        \\n        # Here, each \"i\" is the last index of \"left\" subarray\\n        # So, for every possible \"i\" value, we try to see how many ways are there to split\\n\\t\\t# Since \"mid\" and \"right\" subarrays need to have at least one element\\n\\t\\t# The last index of \"left\" subarray can be up to \"n-3\" index\\n        for i in range(n-2):\\n            \\n            # For each \"i\", we will see what can be the leftmost valid position of \"mid\" subarray\\'s right boundary\\n            # That is, how much left we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            # Since the \"mid\" subarray starts where the \"left\" subarray ends\\n            # It means, start is \"i + 1\" since till \"i\" we have the \"left\" subarray\\n            \\n            start = i + 1\\n            \\n            # Since we want the right subarray to have at least one element\\n            # The maximum index on right till where we can extend the \"mid\" subarray is (n - 2)\\n            end = n - 2\\n            \\n            leftmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                leftSubarraySum = nums[i]\\n                midSubarraySum = nums[mid] - nums[i]\\n                rightSubarraySum = nums[n - 1] - nums[mid]\\n                \\n                # if at \"mid\" the left subarray sum is <= mid subarray sum\\n                # And the mid subarray sum is <= right subarray sum\\n                # Then this is one possible way to split\\n                # But we are looking for the leftmost valid position of \"mid\" subarray\\'s boundary\\n                # So keep searching on left side   \\n                if (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum):\\n                    leftmostIndex = mid\\n                    end = mid - 1\\n                # If the leftsubarray sum is greater than mid subarray sum\\n                # We need to increase the size of mid subarray so that its sum is bigger\\n                # That is, its boundary should be placed at an index more than \"mid\"\\n                # That\\'s why we do start = mid + 1\\n                elif leftSubarraySum > midSubarraySum:\\n                    start = mid + 1      \\n                # Otherwise, we can shift the boundary to left of mid as the leftsubarray sum is <= midsubarray sum\\n                else: end = mid - 1\\n            \\n            # If leftmostIndex is -1, no need to continue further. We can skip this iteration\\n            if leftmostIndex == -1: continue\\n            \\n            # *********************************************************************************\\n                                                      \\n            # Now, for each \"left\" boundary index \"i\", we will see what can be the rightmost valid position of \"mid\" index\\n            # That is, how much right we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            start = i + 1\\n            end = n - 2\\n            \\n            rightmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                leftSubarraySum = nums[i]\\n                midSubarraySum = nums[mid] - nums[i]\\n                rightSubarraySum = nums[n - 1] - nums[mid]\\n                \\n                # if at \"mid\" the left subarray sum is <= mid subarray sum\\n                # And the mid subarray sum is <= right subarray sum\\n                # Then this is one possible way to split\\n                # But we are looking for the rightmost valid position of \"mid\" subarray\\'s boundary\\n                # So keep searching on right side   \\n                if (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum):\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                # If the leftsubarray sum is greater than mid subarray sum\\n                # We need to increase the size of mid subarray so that its sum is bigger\\n                # That is, its boundary should be placed at an index more than \"mid\"\\n                # That\\'s why we do start = mid + 1\\n                elif leftSubarraySum > midSubarraySum:\\n                    start = mid + 1      \\n                # Otherwise, we can shift the boundary to left of mid as the leftsubarray sum is <= midsubarray sum\\n                else: end = mid - 1\\n            \\n            \\n            if rightmostIndex != -1: \\n                ways += (rightmostIndex - leftmostIndex + 1)\\n\\n        return ways % 1000000007\\n```\\n\\n\\n\\n# **3. BINARY SEARCH - O(NLogN) - MORE READABLE CODE**\\n\\nInstead of writing the Binary Search logic for rightmost index again, we can create a separate helper method that takes care of both leftmost and rightmost index search.\\n\\n\\n```\\nclass Solution:\\n    \\n    # Helper method for Binary Search\\n    def binarySearch(self, i, start, end, nums, isLeftSearch):\\n        n = len(nums)\\n        \\n        index = -1\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n                \\n            leftSubarraySum = nums[i]\\n            midSubarraySum = nums[mid] - nums[i]\\n            rightSubarraySum = nums[n - 1] - nums[mid]\\n                \\n\\n            if (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum):\\n                    index = mid\\n                    if isLeftSearch: end = mid - 1\\n                    else: start = mid + 1\\n            elif leftSubarraySum > midSubarraySum:\\n                start = mid + 1      \\n            else: end = mid - 1\\n                \\n        return index\\n        \\n        \\n    \\n    def waysToSplit(self, nums: List[int]) -> int:\\n        \\n        # Why did the Brute Force solution gave TLE?\\n        # Because for each \"i\", we have to go through each possible \"j\"\\n        # Instead of this, what if we can find the leftmost valid \"j\" and rightmost valid \"j\"\\n        # In that way, the number of ways for that \"i\" is simply \"rightmostIndex - leftmostIndex + 1\"\\n        # ANd that\\'s where the Binary Search approach comes into picture.\\n        \\n        n = len(nums)\\n        \\n        # First, we convert the given array into a prefix sum array\\n        for i in range(1, n): nums[i] = nums[i - 1] + nums[i]\\n        \\n        ways = 0\\n        \\n        # Here, each \"i\" is the last index of \"left\" subarray\\n        # So, for every possible \"i\" value, we try to see how many ways are there to split\\n        for i in range(n - 2):\\n            \\n            # For each \"i\", we will see what can be the leftmost valid position of \"mid\" subarray\\'s right boundary\\n            # That is, how much left we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            leftmostIndex = self.binarySearch(i, i + 1, n - 2, nums, True)\\n\\n            # If leftmostIndex is -1, no need to continue further. We can skip this iteration\\n            if leftmostIndex == -1: continue\\n                                    \\n            # Now, for each \"left\" boundary index \"i\", we will see what can be the rightmost valid position of \"mid\" index\\n            # That is, how much right we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            rightmostIndex = self.binarySearch(i, i + 1, n - 2, nums, False)\\n            \\n            if rightmostIndex != -1: ways += (rightmostIndex - leftmostIndex + 1)\\n\\n        return ways % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef waysToSplit(self, nums: List[int]) -> int:    \\n\\n\\tways = 0      \\n\\n\\t# Since there are three subarrays\\n\\t# It means, basically, there are two boundaries. \\n\\t# left | mid | right => Here, each pipe (|) is a boundary\\n\\n\\t# Wherever \"left\" subarray ends, let\\'s say that index is \"i\"\\n\\t# Now for every \"i\", we can try to find the index where \"mid\" subarray ends\\n\\t# Such that, the condition given in problem is satisfied\\n\\tn = len(nums)\\n\\n\\t# First, we convert the given array into a prefix sum array\\n\\tfor i in range(1, n): nums[i] = nums[i - 1] + nums[i]\\n\\n\\t# The prefix sum array will help in such a way that\\n\\n\\t# Suppose the \"left\" subarray ends at index \"left\"\\n\\t# Suppose the \"mid\" subarray starts at index \"left + 1\" and ends at index \"mid\"\\n\\t# And finally, suppose the \"right\" subarray starts at index \"mid + 1\" and ends at index \"right\"\\n\\n\\t# To find the sum of \"mid\" subarray, all we need to do is nums[mid] - nums[left]\\n\\t# To find sum of \"left\" subarray, we just do nums[left]\\n\\t# To find sum of \"right\" subarray, we just do nums[right] - nums[mid]\\n\\n\\t# For every i (index where \"left\" subarray ends)\\n\\t# Since \"mid\" and \"right\" subarrays need to have at least one element\\n\\t# The last index of \"left\" subarray can be up to \"n-3\" index\\n\\n\\tfor i in range(n-2):\\n\\t\\t# Each \"j\" index is the index at which \"mid\" subarray ends\\n\\t\\tfor j in range(i + 1, n):\\n\\t\\t\\tleftSubarraySum = nums[i]\\n\\t\\t\\tmidSubarraySum = nums[j] - nums[i]\\n\\t\\t\\trightSubarraySum = nums[n - 1] - nums[j]\\n\\n\\t\\t\\tif (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum): \\n\\t\\t\\t\\tways += 1\\n\\n\\treturn ways % 1000000007\\n```\n```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n        \\n        # Why did the Brute Force solution gave TLE?\\n        # Because for each \"i\", we have to go through each possible \"j\"\\n        # Instead of this, what if we can find the leftmost valid \"j\" and rightmost valid \"j\"\\n        # In that way, the number of ways for that \"i\" is simply \"rightmostIndex - leftmostIndex + 1\"\\n        # ANd that\\'s where the Binary Search approach comes into picture.\\n        \\n        n = len(nums)\\n        \\n        # First, we convert the given array into a prefix sum array\\n        for i in range(1, n): nums[i] = nums[i - 1] + nums[i]\\n        \\n        ways = 0\\n        \\n        # Here, each \"i\" is the last index of \"left\" subarray\\n        # So, for every possible \"i\" value, we try to see how many ways are there to split\\n\\t\\t# Since \"mid\" and \"right\" subarrays need to have at least one element\\n\\t\\t# The last index of \"left\" subarray can be up to \"n-3\" index\\n        for i in range(n-2):\\n            \\n            # For each \"i\", we will see what can be the leftmost valid position of \"mid\" subarray\\'s right boundary\\n            # That is, how much left we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            # Since the \"mid\" subarray starts where the \"left\" subarray ends\\n            # It means, start is \"i + 1\" since till \"i\" we have the \"left\" subarray\\n            \\n            start = i + 1\\n            \\n            # Since we want the right subarray to have at least one element\\n            # The maximum index on right till where we can extend the \"mid\" subarray is (n - 2)\\n            end = n - 2\\n            \\n            leftmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                leftSubarraySum = nums[i]\\n                midSubarraySum = nums[mid] - nums[i]\\n                rightSubarraySum = nums[n - 1] - nums[mid]\\n                \\n                # if at \"mid\" the left subarray sum is <= mid subarray sum\\n                # And the mid subarray sum is <= right subarray sum\\n                # Then this is one possible way to split\\n                # But we are looking for the leftmost valid position of \"mid\" subarray\\'s boundary\\n                # So keep searching on left side   \\n                if (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum):\\n                    leftmostIndex = mid\\n                    end = mid - 1\\n                # If the leftsubarray sum is greater than mid subarray sum\\n                # We need to increase the size of mid subarray so that its sum is bigger\\n                # That is, its boundary should be placed at an index more than \"mid\"\\n                # That\\'s why we do start = mid + 1\\n                elif leftSubarraySum > midSubarraySum:\\n                    start = mid + 1      \\n                # Otherwise, we can shift the boundary to left of mid as the leftsubarray sum is <= midsubarray sum\\n                else: end = mid - 1\\n            \\n            # If leftmostIndex is -1, no need to continue further. We can skip this iteration\\n            if leftmostIndex == -1: continue\\n            \\n            # *********************************************************************************\\n                                                      \\n            # Now, for each \"left\" boundary index \"i\", we will see what can be the rightmost valid position of \"mid\" index\\n            # That is, how much right we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            start = i + 1\\n            end = n - 2\\n            \\n            rightmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                leftSubarraySum = nums[i]\\n                midSubarraySum = nums[mid] - nums[i]\\n                rightSubarraySum = nums[n - 1] - nums[mid]\\n                \\n                # if at \"mid\" the left subarray sum is <= mid subarray sum\\n                # And the mid subarray sum is <= right subarray sum\\n                # Then this is one possible way to split\\n                # But we are looking for the rightmost valid position of \"mid\" subarray\\'s boundary\\n                # So keep searching on right side   \\n                if (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum):\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                # If the leftsubarray sum is greater than mid subarray sum\\n                # We need to increase the size of mid subarray so that its sum is bigger\\n                # That is, its boundary should be placed at an index more than \"mid\"\\n                # That\\'s why we do start = mid + 1\\n                elif leftSubarraySum > midSubarraySum:\\n                    start = mid + 1      \\n                # Otherwise, we can shift the boundary to left of mid as the leftsubarray sum is <= midsubarray sum\\n                else: end = mid - 1\\n            \\n            \\n            if rightmostIndex != -1: \\n                ways += (rightmostIndex - leftmostIndex + 1)\\n\\n        return ways % 1000000007\\n```\n```\\nclass Solution:\\n    \\n    # Helper method for Binary Search\\n    def binarySearch(self, i, start, end, nums, isLeftSearch):\\n        n = len(nums)\\n        \\n        index = -1\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n                \\n            leftSubarraySum = nums[i]\\n            midSubarraySum = nums[mid] - nums[i]\\n            rightSubarraySum = nums[n - 1] - nums[mid]\\n                \\n\\n            if (leftSubarraySum <= midSubarraySum) and (midSubarraySum <= rightSubarraySum):\\n                    index = mid\\n                    if isLeftSearch: end = mid - 1\\n                    else: start = mid + 1\\n            elif leftSubarraySum > midSubarraySum:\\n                start = mid + 1      \\n            else: end = mid - 1\\n                \\n        return index\\n        \\n        \\n    \\n    def waysToSplit(self, nums: List[int]) -> int:\\n        \\n        # Why did the Brute Force solution gave TLE?\\n        # Because for each \"i\", we have to go through each possible \"j\"\\n        # Instead of this, what if we can find the leftmost valid \"j\" and rightmost valid \"j\"\\n        # In that way, the number of ways for that \"i\" is simply \"rightmostIndex - leftmostIndex + 1\"\\n        # ANd that\\'s where the Binary Search approach comes into picture.\\n        \\n        n = len(nums)\\n        \\n        # First, we convert the given array into a prefix sum array\\n        for i in range(1, n): nums[i] = nums[i - 1] + nums[i]\\n        \\n        ways = 0\\n        \\n        # Here, each \"i\" is the last index of \"left\" subarray\\n        # So, for every possible \"i\" value, we try to see how many ways are there to split\\n        for i in range(n - 2):\\n            \\n            # For each \"i\", we will see what can be the leftmost valid position of \"mid\" subarray\\'s right boundary\\n            # That is, how much left we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            leftmostIndex = self.binarySearch(i, i + 1, n - 2, nums, True)\\n\\n            # If leftmostIndex is -1, no need to continue further. We can skip this iteration\\n            if leftmostIndex == -1: continue\\n                                    \\n            # Now, for each \"left\" boundary index \"i\", we will see what can be the rightmost valid position of \"mid\" index\\n            # That is, how much right we can keep the right boundary of \"mid\" subarray\\n            # Such that the condition is still true\\n            \\n            rightmostIndex = self.binarySearch(i, i + 1, n - 2, nums, False)\\n            \\n            if rightmostIndex != -1: ways += (rightmostIndex - leftmostIndex + 1)\\n\\n        return ways % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294814,
                "title": "o-n-runtime-o-1-space-algorithm-explained",
                "content": "The basic idea of the algorithm is to iterate on possible end_of_first_range [1:n-2].\\nAnd during the iteration to maintain the following paramters:\\n* smallest_indx_for_end_of_second_range which stands for the minimal indx for which the second range ends and holds that the second range sum is geq of the currrent first range sum\\n* biggest_indx_for_end_of_second_range  which stands for the maximal indx for which the second range ends and holds that the second range sum is leq of the yielded third range sum\\n\\nobviously  every possible indx for end of second range in  [smallest_indx_for_end_of_second_range, biggest_indx_for_end_of_second_range] is possible for the current end_of_first_range so we simply mainatin res += the length of [smallest_indx_for_end_of_second_range,  biggest_indx_for_end_of_second_range] (0 if smallest_indx_for_end_of_second_range > biggest_indx_for_end_of_second_range)\\n\\nSo now we need an algorithm to maintain smallest_indx_for_end_of_second_range, biggest_indx_for_end_of_second_range.\\nFor this we simply observe that they are allways advancing right (towards the end of the array). why?\\n\\n* smallest_indx_for_end_of_second_range  advances only towards right bcs the first does not get smaller\\n* biggest_indx_for_end_of_second_range advances only towards right bcs the previous maximal second range does not gets bigger when his first element is advanced forward \\n\\n* we can maintain those indexes and the relevant partial sums in a constant amount of variables (hence O(1) memory)\\n* we only iterate all our indexes(constant amount) forward, hence O(n) time complexity. \\n\\nThe code below implements the above algorithm (not in a very elegant way, I must admit :-))\\n\\n\\n```\\nclass Solution(object):\\n    def waysToSplit(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        totalSum = sum(nums)        \\n        firstRangeSum = nums[0]\\n        \\n        smallestIndxForEndOfSecond = 1\\n        smallestSecondRangeSum = nums[1]\\n        while True:\\n            if smallestSecondRangeSum >= firstRangeSum:\\n                break\\n            smallestIndxForEndOfSecond += 1\\n            if smallestIndxForEndOfSecond == len(nums) - 1:\\n                return 0\\n            smallestSecondRangeSum += nums[smallestIndxForEndOfSecond]\\n        \\n        biggestIndxForEndOfSecond = len(nums) - 2\\n        biggestSecondRangeSum = totalSum - nums[0] - nums[-1]\\n        while True:\\n            if totalSum - firstRangeSum - biggestSecondRangeSum >= biggestSecondRangeSum:\\n                break\\n            biggestSecondRangeSum -= nums[biggestIndxForEndOfSecond]                \\n            biggestIndxForEndOfSecond -= 1\\n            if biggestIndxForEndOfSecond == 0:\\n                return 0\\n        \\n        \\n        res += ((biggestIndxForEndOfSecond - smallestIndxForEndOfSecond) + 1)\\n        \\n        for firstRangeEnd in xrange(1, len(nums) - 2):\\n            firstRangeSum += nums[firstRangeEnd]\\n            smallestSecondRangeSum -= nums[firstRangeEnd]\\n            while True:\\n                if smallestSecondRangeSum >= firstRangeSum:\\n                    if smallestIndxForEndOfSecond == firstRangeEnd:\\n                        smallestIndxForEndOfSecond += 1\\n                    break\\n                smallestIndxForEndOfSecond += 1                    \\n                if smallestIndxForEndOfSecond == len(nums) - 1:\\n                    return res % (10 ** 9 + 7)\\n                smallestSecondRangeSum += nums[smallestIndxForEndOfSecond] \\n            \\n\\n            biggestSecondRangeSum -= nums[firstRangeEnd]\\n            while (biggestIndxForEndOfSecond < len(nums) - 2) and (biggestSecondRangeSum + nums[biggestIndxForEndOfSecond + 1]) <= totalSum - firstRangeSum - (biggestSecondRangeSum + nums[biggestIndxForEndOfSecond + 1]):\\n                biggestIndxForEndOfSecond += 1\\n                biggestSecondRangeSum += nums[biggestIndxForEndOfSecond]\\n            if biggestIndxForEndOfSecond == firstRangeEnd:\\n                return res % (10 ** 9 + 7)\\n            \\n            if biggestIndxForEndOfSecond >= smallestIndxForEndOfSecond:\\n                res += ((biggestIndxForEndOfSecond - smallestIndxForEndOfSecond) + 1)\\n        \\n        return res % (10 ** 9 + 7)\\n            \\n\\n                    \\n            \\n        \\n            \\n\\n            \\n        \\n        \\n        \\n        \\n        \\n\\n            \\n        \\n                    \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def waysToSplit(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        totalSum = sum(nums)        \\n        firstRangeSum = nums[0]\\n        \\n        smallestIndxForEndOfSecond = 1\\n        smallestSecondRangeSum = nums[1]\\n        while True:\\n            if smallestSecondRangeSum >= firstRangeSum:\\n                break\\n            smallestIndxForEndOfSecond += 1\\n            if smallestIndxForEndOfSecond == len(nums) - 1:\\n                return 0\\n            smallestSecondRangeSum += nums[smallestIndxForEndOfSecond]\\n        \\n        biggestIndxForEndOfSecond = len(nums) - 2\\n        biggestSecondRangeSum = totalSum - nums[0] - nums[-1]\\n        while True:\\n            if totalSum - firstRangeSum - biggestSecondRangeSum >= biggestSecondRangeSum:\\n                break\\n            biggestSecondRangeSum -= nums[biggestIndxForEndOfSecond]                \\n            biggestIndxForEndOfSecond -= 1\\n            if biggestIndxForEndOfSecond == 0:\\n                return 0\\n        \\n        \\n        res += ((biggestIndxForEndOfSecond - smallestIndxForEndOfSecond) + 1)\\n        \\n        for firstRangeEnd in xrange(1, len(nums) - 2):\\n            firstRangeSum += nums[firstRangeEnd]\\n            smallestSecondRangeSum -= nums[firstRangeEnd]\\n            while True:\\n                if smallestSecondRangeSum >= firstRangeSum:\\n                    if smallestIndxForEndOfSecond == firstRangeEnd:\\n                        smallestIndxForEndOfSecond += 1\\n                    break\\n                smallestIndxForEndOfSecond += 1                    \\n                if smallestIndxForEndOfSecond == len(nums) - 1:\\n                    return res % (10 ** 9 + 7)\\n                smallestSecondRangeSum += nums[smallestIndxForEndOfSecond] \\n            \\n\\n            biggestSecondRangeSum -= nums[firstRangeEnd]\\n            while (biggestIndxForEndOfSecond < len(nums) - 2) and (biggestSecondRangeSum + nums[biggestIndxForEndOfSecond + 1]) <= totalSum - firstRangeSum - (biggestSecondRangeSum + nums[biggestIndxForEndOfSecond + 1]):\\n                biggestIndxForEndOfSecond += 1\\n                biggestSecondRangeSum += nums[biggestIndxForEndOfSecond]\\n            if biggestIndxForEndOfSecond == firstRangeEnd:\\n                return res % (10 ** 9 + 7)\\n            \\n            if biggestIndxForEndOfSecond >= smallestIndxForEndOfSecond:\\n                res += ((biggestIndxForEndOfSecond - smallestIndxForEndOfSecond) + 1)\\n        \\n        return res % (10 ** 9 + 7)\\n            \\n\\n                    \\n            \\n        \\n            \\n\\n            \\n        \\n        \\n        \\n        \\n        \\n\\n            \\n        \\n                    \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184215,
                "title": "c-prefixsum",
                "content": "TC: O(n logn logn)\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long const mod = 1e9 + 7;\\n        int n = nums.size();\\n        vector<long long> prefix(nums.size());\\n        prefix[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        long long count = 0;\\n        for(int i = 0;i<prefix.size();i++)\\n        {\\n            int left = lower_bound(prefix.begin(), prefix.end(), 2*prefix[i]) - prefix.begin();\\n            if(left<=i) left = i+1;\\n            int start = left;\\n            if(left==prefix.size()) break;\\n            int right = prefix.size()-1;\\n            int ans = left;\\n            while(left<=right)\\n            {\\n                int mid = (left+(right-left)/2);\\n                int right_val = prefix[n-1]-prefix[mid];\\n                int left_val = prefix[mid]-prefix[i];\\n                if(mid==n-1) break;\\n                if(right_val >= left_val)\\n                {\\n                    ans = mid;\\n                    left = mid+1;\\n                }\\n                else right = mid-1;\\n            }\\n            if(ans==left) continue;\\n            ans = ans-start + 1;\\n            count+=ans;\\n        }\\n        return count%mod;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long const mod = 1e9 + 7;\\n        int n = nums.size();\\n        vector<long long> prefix(nums.size());\\n        prefix[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2123352,
                "title": "c-prefix-sum-and-binary-search-with-explanation",
                "content": "* **IDEA**\\n* Iterate at every index `i` in nums array and keep the left porition upto ith index(`i` included).\\n* Now we want to find the middle portion and right portion such that `left <= middle` and `middle  <= right`.\\n* Find the ending index of middle array- `middleStart` (in prefix sum array ), which would be at least `2*prefixSum[i]`.(Because when we find the actual sum of middle array we would be subtracting the left sum part which is not a part of middle array. Therefore, the middleSum Should be atleast twice the left sum).Middle array cannot end before this index because then left would be smaller than middle sum. Therefore , middle sum has to include the middleStart position atleast.   \\n* Now the index which has to be included in middle array to satisfy `leftSum <= middleSum` has been determined.\\n* Now assume you are given an array and you have to find the number of positions such that sum of left part <= sum of right part. This can be easily determined by binary Search. These Positions will be the possible ending positions of middle array. Keep Adding these positions to ways .   \\n\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7 ;\\n    int ways = 0 ;\\n    vector<int>pref,suff ;\\n    \\n    void Build_Prefix(vector<int>&nums){\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            if(!i) pref.push_back(nums[i]) ;\\n            else pref.push_back(pref.back() + nums[i]) ;\\n        }\\n    }\\n    \\n    void Build_Suffix(vector<int>&nums){\\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            if(i == nums.size() - 1) suff.push_back(nums[i]) ;\\n            else suff.push_back(suff.back() + nums[i]) ;\\n        }\\n        reverse(begin(suff),end(suff)) ;\\n    }\\n    \\n    int countWays(vector<int>&pref , vector<int>&suff , int middleStart , int left ){\\n        int idx = -1 ;\\n        int lo = middleStart , hi = pref.size() - 2 ;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo) / 2 ;\\n            //if left sum at mid position is less than equal to right sum then move forward\\n            //because we want to find max position upto which condition is satisfied\\n            if(pref[mid] - left <= suff[mid + 1]){\\n                idx = mid ; \\n                lo = mid + 1 ;\\n            } else hi = mid - 1 ;\\n        }\\n        \\n        if(idx == -1) return 0 ;\\n        //Number of positions where middle array can end and condition will still be satisfied \\n        return idx - middleStart + 1 ;\\n        \\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        Build_Prefix(nums) ; Build_Suffix(nums) ;\\n        \\n        for(int i = 0 ; i < pref.size() ; ++i ){\\n            int left = pref[i] , least = 2*left ;\\n            int middleStart = lower_bound(begin(pref) + i + 1,end(pref),least) - begin(pref) ;\\n            ways =  (ways % MOD + countWays(pref,suff,middleStart,left) % MOD) % MOD ;\\n        }\\n        \\n        return ways ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7 ;\\n    int ways = 0 ;\\n    vector<int>pref,suff ;\\n    \\n    void Build_Prefix(vector<int>&nums){\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            if(!i) pref.push_back(nums[i]) ;\\n            else pref.push_back(pref.back() + nums[i]) ;\\n        }\\n    }\\n    \\n    void Build_Suffix(vector<int>&nums){\\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            if(i == nums.size() - 1) suff.push_back(nums[i]) ;\\n            else suff.push_back(suff.back() + nums[i]) ;\\n        }\\n        reverse(begin(suff),end(suff)) ;\\n    }\\n    \\n    int countWays(vector<int>&pref , vector<int>&suff , int middleStart , int left ){\\n        int idx = -1 ;\\n        int lo = middleStart , hi = pref.size() - 2 ;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo) / 2 ;\\n            //if left sum at mid position is less than equal to right sum then move forward\\n            //because we want to find max position upto which condition is satisfied\\n            if(pref[mid] - left <= suff[mid + 1]){\\n                idx = mid ; \\n                lo = mid + 1 ;\\n            } else hi = mid - 1 ;\\n        }\\n        \\n        if(idx == -1) return 0 ;\\n        //Number of positions where middle array can end and condition will still be satisfied \\n        return idx - middleStart + 1 ;\\n        \\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        Build_Prefix(nums) ; Build_Suffix(nums) ;\\n        \\n        for(int i = 0 ; i < pref.size() ; ++i ){\\n            int left = pref[i] , least = 2*left ;\\n            int middleStart = lower_bound(begin(pref) + i + 1,end(pref),least) - begin(pref) ;\\n            ways =  (ways % MOD + countWays(pref,suff,middleStart,left) % MOD) % MOD ;\\n        }\\n        \\n        return ways ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921018,
                "title": "c-linear-solution-first-divide-position-any-second-one-is-in-a-range",
                "content": "April 6, 2022\\n**Introduction**\\nI came cross this algorithm and read votrubac\\'s solution, but I did not understand, so I took 10 minutes to convert his Java code to C# code, and then asked myself a few times during those 15 minutes, why it is a linear solution, why it is (j - k)? What is the special for the range?\\n\\n**Analysis by votrubac | My quick study**\\nInput: nums = [1,2,2,2,5,0]\\nOutput: 3\\nExplanation: There are three good ways of splitting nums:\\n[1] [2] [2,2,5,0]\\n[1] [2,2] [2,5,0]\\n[1,2] [2,2] [5,0]\\n\\nThe first subarray can start from index = 0, and stop at any position with the condition: i < length - 2. \\nSecond array position ends where? We have to find the minimum index to make sure that sum of second subarray is bigger than the first leftmost subarray\\'s sum. \\n\\nThird array position starts where? What is maximum start position for the third array? Skip this discussion for my own analysis. \\n\\nBased on the above analysis, the second array minimum end position and third subarray last start position is total count of ways to divide. \\n\\nRead more carefully about the analysis provided by votrubac in the following:\\nFirst, we prepare the prefix sum array, so that we can compute subarray sums in O(1). Then, we move the boundary of the first subarray left to right. This is the first pointer - i.\\nFor each point i, we find the minimum (j) and maximum (k) boundaries of the second subarray:\\n```\\n* nums[j] >= 2 * nums[i]\\n* nums[sz - 1] - nums[k] >= nums[k] - nums[i]\\n```\\nNote that in the code and examples below, k points to the element after the second array. In other words, it marks the start of the (shortest) third subarray. This makes the logic a bit simpler.\\n\\nTime complexity: O(N)\\n\\n**My thought process | Not good enough | Ensure linear solution is correct!**\\nBrute force solution - it is easy, two position to determine, so time complexity should be O(N^2). \\n\\nHow to find optimal one? What is optimal time complexity? O(N) or O(NlogN)?\\n\\nI did not come out my own option solution, and I thought about using prefix sum array first, and then think about how to find maximum end position of second subarray using binary search, bigggest start position of third subarray using binary search. \\n\\nIt seems to be O(NlogN) best approach. \\n\\nI came cross this discuss post in votrubac linear solution:\\n**\"..to realize that j and k will only move forward, which result in a linear-time solution..\" ---The key point of the solution. I like it.**\\nIn other words, the following statement for loop in terms of i will take O(N) time.\\n```\\nfor (int i = 0, j = 0, k = 0; i < length - 2; ++i)\\n```\\nInside for loop, while loop for j also takes O(N) time, since j will only increase, not go back to 0 for next iteration in for loop. So j iteration steps also is O(N)\\n```\\nwhile (j <= i || (j < length - 1 && nums[j] < nums[i] * 2))\\n```\\nThe above statement, i = 0, j will be a number; next iteration i = 1, j will start from previous number and continue to increment one by one. \\n\\nInside for loop, while loop for k also takes O(N) time. Same argument as j. \\n```\\nwhile (k < j || (k < length - 1 && nums[k] - nums[i] <= nums[length - 1] - nums[k]))\\n```\\n\\n\\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1712_ways_to_split\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/999257/C%2B%2BJavaPython-O(n)-with-picture\\n        /// time complexity: O(N)\\n        /// </summary>\\n        /// <param name=\"nums\"></param>\\n        /// <returns></returns>\\n        public int WaysToSplit(int[] nums)\\n        {\\n            var length = nums.Length;\\n            var count = 0;\\n\\n            for (int i = 1; i < length; ++i)\\n            {\\n                nums[i] += nums[i - 1];\\n            }\\n\\n            // i < j < k\\n            for (int i = 0, j = 0, k = 0; i < length - 2; ++i)\\n            {\\n                // j - maximum count: O(N) - make sure that j > i, but nums[j] >= nums[i] * 2\\n                while (j <= i || (j < length - 1 && nums[j] < nums[i] * 2))\\n                {\\n                    ++j;\\n                }\\n\\n                // k - make sure that k >= j, but rightmost subarray\\'s sum is bigger than second one\\n                while (k < j || (k < length - 1 && nums[k] - nums[i] <= nums[length - 1] - nums[k]))\\n                {\\n                    ++k;\\n                }\\n\\n                // find k - j ways to divide the way into three subarrays. \\n                // because if the second array is stopped between any index position from j to k, it will work. \\n                count = (count + k - j) % 1000000007;\\n            }\\n\\n            return count;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n* nums[j] >= 2 * nums[i]\\n* nums[sz - 1] - nums[k] >= nums[k] - nums[i]\\n```\n```\\nfor (int i = 0, j = 0, k = 0; i < length - 2; ++i)\\n```\n```\\nwhile (j <= i || (j < length - 1 && nums[j] < nums[i] * 2))\\n```\n```\\nwhile (k < j || (k < length - 1 && nums[k] - nums[i] <= nums[length - 1] - nums[k]))\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1712_ways_to_split\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/999257/C%2B%2BJavaPython-O(n)-with-picture\\n        /// time complexity: O(N)\\n        /// </summary>\\n        /// <param name=\"nums\"></param>\\n        /// <returns></returns>\\n        public int WaysToSplit(int[] nums)\\n        {\\n            var length = nums.Length;\\n            var count = 0;\\n\\n            for (int i = 1; i < length; ++i)\\n            {\\n                nums[i] += nums[i - 1];\\n            }\\n\\n            // i < j < k\\n            for (int i = 0, j = 0, k = 0; i < length - 2; ++i)\\n            {\\n                // j - maximum count: O(N) - make sure that j > i, but nums[j] >= nums[i] * 2\\n                while (j <= i || (j < length - 1 && nums[j] < nums[i] * 2))\\n                {\\n                    ++j;\\n                }\\n\\n                // k - make sure that k >= j, but rightmost subarray\\'s sum is bigger than second one\\n                while (k < j || (k < length - 1 && nums[k] - nums[i] <= nums[length - 1] - nums[k]))\\n                {\\n                    ++k;\\n                }\\n\\n                // find k - j ways to divide the way into three subarrays. \\n                // because if the second array is stopped between any index position from j to k, it will work. \\n                count = (count + k - j) % 1000000007;\\n            }\\n\\n            return count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887770,
                "title": "help-for-84-87",
                "content": "stuck at 84/87 where\\nOutput:\\n999949971\\nExpected:\\n999849973\\n\\nit is the case with many 0s\\nnot sure are there any logic error with my code ?\\n\\n```class Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long long mod = 1e9 + 7;\\n        int len = nums.size();\\n        vector<long long> presum(len, 0);\\n        presum[0] = nums[0];\\n        long long sum = nums[0];\\n        for(int idx = 1; idx < len; idx++) {\\n            presum[idx] = nums[idx] + presum[idx-1];\\n            sum += nums[idx];\\n            \\n        }\\n        long long ans = 0;\\n        for(int endIdx = 0; endIdx < len-2; endIdx++) {\\n            int leftPart = presum[endIdx];\\n            \\n            //find the first left where middle larger than left\\n            int left = endIdx + 1;\\n            int right = len - 1;\\n            while(left + 1 < right) {\\n                int mid = left + (right - left) / 2;\\n                int midSum = presum[mid] - leftPart;\\n                if(midSum < leftPart) {\\n                    left = mid;\\n                }\\n                else {\\n                    right = mid;\\n                }\\n            }\\n            int midPoint = -1;\\n            if(presum[left] - leftPart >= leftPart) {\\n                midPoint = left;\\n            } \\n            else if(presum[right] - leftPart >= leftPart) {\\n                midPoint = right;\\n            }\\n            \\n            if(midPoint == -1) {\\n                break;\\n            }\\n            \\n            left = midPoint;\\n            right = len - 1;\\n            while(left + 1 < right) {\\n                \\n                int mid = left + (right - left) / 2;\\n                int midSum = presum[mid] - leftPart;\\n                int rightSum = sum - presum[mid];\\n                if(midSum > rightSum) {\\n                    right = mid;\\n                }\\n                else {\\n                    left = mid;\\n                }\\n            }\\n            \\n            int rightPoint = -1;\\n            if(sum - presum[right] >= presum[right] - leftPart) {\\n                rightPoint = right;\\n            }\\n            else if(sum - presum[left] >= presum[left] - leftPart) {\\n                rightPoint = left;\\n            }\\n            \\n            if(rightPoint != -1) {\\n                ans = ans + rightPoint - midPoint + 1;\\n                \\n            }\\n            \\n        }\\n        return int(ans % mod);\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```class Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        long long mod = 1e9 + 7;\\n        int len = nums.size();\\n        vector<long long> presum(len, 0);\\n        presum[0] = nums[0];\\n        long long sum = nums[0];\\n        for(int idx = 1; idx < len; idx++) {\\n            presum[idx] = nums[idx] + presum[idx-1];\\n            sum += nums[idx];\\n            \\n        }\\n        long long ans = 0;\\n        for(int endIdx = 0; endIdx < len-2; endIdx++) {\\n            int leftPart = presum[endIdx];\\n            \\n            //find the first left where middle larger than left\\n            int left = endIdx + 1;\\n            int right = len - 1;\\n            while(left + 1 < right) {\\n                int mid = left + (right - left) / 2;\\n                int midSum = presum[mid] - leftPart;\\n                if(midSum < leftPart) {\\n                    left = mid;\\n                }\\n                else {\\n                    right = mid;\\n                }\\n            }\\n            int midPoint = -1;\\n            if(presum[left] - leftPart >= leftPart) {\\n                midPoint = left;\\n            } \\n            else if(presum[right] - leftPart >= leftPart) {\\n                midPoint = right;\\n            }\\n            \\n            if(midPoint == -1) {\\n                break;\\n            }\\n            \\n            left = midPoint;\\n            right = len - 1;\\n            while(left + 1 < right) {\\n                \\n                int mid = left + (right - left) / 2;\\n                int midSum = presum[mid] - leftPart;\\n                int rightSum = sum - presum[mid];\\n                if(midSum > rightSum) {\\n                    right = mid;\\n                }\\n                else {\\n                    left = mid;\\n                }\\n            }\\n            \\n            int rightPoint = -1;\\n            if(sum - presum[right] >= presum[right] - leftPart) {\\n                rightPoint = right;\\n            }\\n            else if(sum - presum[left] >= presum[left] - leftPart) {\\n                rightPoint = left;\\n            }\\n            \\n            if(rightPoint != -1) {\\n                ans = ans + rightPoint - midPoint + 1;\\n                \\n            }\\n            \\n        }\\n        return int(ans % mod);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419357,
                "title": "c-o-n-log-n-prefix-sums-binary-search",
                "content": "```\\n\\tint waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int pref[n];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                pref[i]=nums[i];\\n            }else{\\n                pref[i]=nums[i]+pref[i-1];\\n            }\\n        }\\n        int ans=0,i2=0,mod=1e9+7;\\n        for(int j=1;j+1<n;j++){\\n            while(i2+1<j && pref[i2+1]<=pref[j]-pref[i2+1]){\\n                i2++;\\n            }\\n            if(pref[n-1]-pref[j]<pref[j]-pref[i2]){\\n                continue;\\n            }\\n            if(pref[j]-pref[i2]<pref[i2]){\\n                continue;\\n            }\\n            int lo=-1,hi=i2;\\n            while(hi-lo>1){\\n                int mid=(lo+hi)/2;\\n                if(pref[j]-pref[mid]<=(pref[n-1]-pref[j])){\\n                    hi=mid;\\n                }else{\\n                    lo=mid;\\n                }\\n            }\\n            ans=(ans+i2-hi+1)%mod;\\n        }\\n        return ans;\\n    }`\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int pref[n];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                pref[i]=nums[i];\\n            }else{\\n                pref[i]=nums[i]+pref[i-1];\\n            }\\n        }\\n        int ans=0,i2=0,mod=1e9+7;\\n        for(int j=1;j+1<n;j++){\\n            while(i2+1<j && pref[i2+1]<=pref[j]-pref[i2+1]){\\n                i2++;\\n            }\\n            if(pref[n-1]-pref[j]<pref[j]-pref[i2]){\\n                continue;\\n            }\\n            if(pref[j]-pref[i2]<pref[i2]){\\n                continue;\\n            }\\n            int lo=-1,hi=i2;\\n            while(hi-lo>1){\\n                int mid=(lo+hi)/2;\\n                if(pref[j]-pref[mid]<=(pref[n-1]-pref[j])){\\n                    hi=mid;\\n                }else{\\n                    lo=mid;\\n                }\\n            }\\n            ans=(ans+i2-hi+1)%mod;\\n        }\\n        return ans;\\n    }`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1294741,
                "title": "simple-greedy-prefix-sum-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int sum=0;\\n        \\n        vector<int>pre(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pre[i]=sum;\\n        }\\n        \\n        long long int ans=0,left,rem,a,b,k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          left=pre[i];\\n          rem=pre[nums.size()-1]-left;\\n          a=lower_bound(pre.begin()+i+1,pre.end(),2*left)-pre.begin();\\n          b=upper_bound(pre.begin()+i+1,pre.begin()+nums.size()-1,left+rem/2)-pre.begin();\\n            \\n            ans+=max(k,(b-a));\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int sum=0;\\n        \\n        vector<int>pre(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pre[i]=sum;\\n        }\\n        \\n        long long int ans=0,left,rem,a,b,k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          left=pre[i];\\n          rem=pre[nums.size()-1]-left;\\n          a=lower_bound(pre.begin()+i+1,pre.end(),2*left)-pre.begin();\\n          b=upper_bound(pre.begin()+i+1,pre.begin()+nums.size()-1,left+rem/2)-pre.begin();\\n            \\n            ans+=max(k,(b-a));\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161823,
                "title": "t-o-nlogn-s-o-n-explained-soln",
                "content": "* Since we need to divide the arr into 3 parts so that \\n * sum of left <= sum of middle <= sum of right\\n * \\n * first optimization to save a lot of time is calculating the prefix sum in O(n) time\\n * which gives us sum of values b/w any 2 index in just O(1) time.\\n * \\n * now our problem can be re-written as below\\n * find i & j index such that\\n * prefixSum[i] <= prefixSum[j]-prefixSum[i] <= prefixSum[n-1]-prefixSum[j]\\n * \\n * so bascially we need to iterate i thru [1..n-2] we need atleast 1 values for mid & rt sub-array\\n * & for each index i, we need to find l & r such that\\n *      min index l such that sum of mid-array is greater or equal to left-sub-array)\\n *      max index r such that sum of mid-array is smaller than or equal to sum of rt-sub-array)\\n * \\n * since prefix sum is sorted we can use binary search to find our \\'l\\' & \\'r\\' index\\n * at the end we return count % mod.\\n```\\npublic class Solution {\\n    // Time O(nlogn) || Space O(n), n = length of \\'nums\\'\\n    public int WaysToSplit(int[] nums) {\\n        int n = nums.Length, count = 0, l, r;\\n        long leftSum, remainingSum;\\n\\n        long[] prefixSum = new long[n + 1];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            leftSum = prefixSum[i];\\n            remainingSum = prefixSum[n-1] - leftSum;\\n            if (prefixSum[n-1] < leftSum * 3) break;    // to divide array into 3 equal parts total sum should be >= thrice the sum of left-sub-array\\n\\n            l = SearchLeft(i + 1, leftSum);             // min index l such that sum of mid-array is greater or equal to left-sub-array)\\n            r = SearchRight(i + 1, remainingSum / 2);   // max index r such that sum of mid-array is smaller than or equal to sum of rt-sub-array)\\n\\n            count += 1 + r - l;\\n            count %= 1000000007;\\n        }\\n        return (int)count;\\n\\n\\n        // local func\\n        int SearchLeft(int idx, long target)\\n        {\\n            int mid, left = idx, rt = n - 2;\\n            while (left < rt)\\n            {\\n                mid = left + ((rt - left) / 2);\\n                if (prefixSum[mid] - leftSum >= target)\\n                    rt = mid;\\n                else\\n                    left = mid + 1;\\n            }\\n            return left;\\n        }\\n        int SearchRight(int idx, long target)\\n        {\\n            int mid, left = idx, rt = n - 2;\\n            while (left < rt)\\n            {\\n                mid = left + (1 + rt - left) / 2;\\n                if (prefixSum[mid] - leftSum <= target)\\n                    left = mid;\\n                else\\n                    rt = mid - 1;\\n            }\\n            return rt;\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/46e2c26e-9673-40e3-baff-e31ae1b73c73_1618600262.2265222.png)\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    // Time O(nlogn) || Space O(n), n = length of \\'nums\\'\\n    public int WaysToSplit(int[] nums) {\\n        int n = nums.Length, count = 0, l, r;\\n        long leftSum, remainingSum;\\n\\n        long[] prefixSum = new long[n + 1];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            leftSum = prefixSum[i];\\n            remainingSum = prefixSum[n-1] - leftSum;\\n            if (prefixSum[n-1] < leftSum * 3) break;    // to divide array into 3 equal parts total sum should be >= thrice the sum of left-sub-array\\n\\n            l = SearchLeft(i + 1, leftSum);             // min index l such that sum of mid-array is greater or equal to left-sub-array)\\n            r = SearchRight(i + 1, remainingSum / 2);   // max index r such that sum of mid-array is smaller than or equal to sum of rt-sub-array)\\n\\n            count += 1 + r - l;\\n            count %= 1000000007;\\n        }\\n        return (int)count;\\n\\n\\n        // local func\\n        int SearchLeft(int idx, long target)\\n        {\\n            int mid, left = idx, rt = n - 2;\\n            while (left < rt)\\n            {\\n                mid = left + ((rt - left) / 2);\\n                if (prefixSum[mid] - leftSum >= target)\\n                    rt = mid;\\n                else\\n                    left = mid + 1;\\n            }\\n            return left;\\n        }\\n        int SearchRight(int idx, long target)\\n        {\\n            int mid, left = idx, rt = n - 2;\\n            while (left < rt)\\n            {\\n                mid = left + (1 + rt - left) / 2;\\n                if (prefixSum[mid] - leftSum <= target)\\n                    left = mid;\\n                else\\n                    rt = mid - 1;\\n            }\\n            return rt;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036535,
                "title": "great-question-own-binary-search-explained",
                "content": "\\ntime : O(nlogn) space: O(n)\\nInspiration from @ye15[ post](https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/999157/Python3-binary-search-and-2-pointer)\\n\\n**Own binary search**\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<int>&presum, int idx, int sum, bool flag){\\n        \\n        // just for readability\\n        int leftsum, rightsum;\\n        if(flag)leftsum = sum;\\n        else rightsum = sum;\\n        \\n        int low = idx, high = presum.size()-1, index = -1;\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            int midsum = presum[mid];\\n            if(flag){\\n                if(leftsum <= midsum){\\n                    index = mid;\\n                    high = mid-1;\\n                }\\n                else low = mid+1;\\n            }\\n            else{\\n                if(midsum <= rightsum){\\n                    index = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid-1;\\n            }\\n        }        \\n        return index;\\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int>presum(n, nums[0]);\\n        for(int i = 1; i < n; ++i) presum[i] = presum[i-1] + nums[i];\\n        \\n        int res = 0, MOD = 1e9+7;\\n        for(int i = 0; i < n; ++i){\\n            \\n            // first cut at index just after i, and second cut at j where j in [l,r]\\n            // Hence, presum[i] <= presum[j] - presum[i] <= presum[n-1] - presum[j]\\n            \\n            // 1st condition: 2*presum[i] <= presum[j]\\n            int l = binarySearch(presum, i+1, 2*presum[i], true); \\n            \\n            // 2nd condition: 2*presum[j] <= presum[n-1] + presum[i]\\n            int r = binarySearch(presum, i+1, (presum[n-1] + presum[i])/2, false); \\n            \\n            if(l == -1 || r == -1)continue;\\n            \\n            r = min(r, n-2); // if r >= n-1, then rightsum partition will be empty\\n            l = max(i+1, l); // if l <= i, then midsum partition will be empty \\n            \\n            // r-l+1 indicates total no of partitions possible after fixing i or leftsum\\n            res = (res + max(0, r-l+1)) %MOD;            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nRuntime: 284 ms (better)\\n\\n\\n**Binary search stl**\\n```\\n// time : O(nlogn) space: O(n)\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int>presum(n, nums[0]);\\n        for(int i = 1; i < n; ++i) presum[i] = presum[i-1] + nums[i];\\n        \\n        int res = 0, MOD = 1e9+7;\\n        for(int i = 0; i < n; ++i){\\n            \\n            // first cut at index just after i, and second cut at j where j in [l,r]\\n            // Hence, presum[i] <= presum[j] - presum[i] <= presum[n-1] - presum[j]\\n            \\n            // 1st condition: 2*presum[i] <= presum[j]\\n            int l = lower_bound(presum.begin()+i+1, presum.end(), 2*presum[i]) - presum.begin(); \\n            \\n            // 2nd condition: 2*presum[j] <= presum[n-1] + presum[i]\\n            int r = upper_bound(presum.begin()+i+1, presum.begin()+n-1, (presum[n-1] + presum[i])/2) - presum.begin(); \\n            \\n            r--;\\n            \\n            // r-l+1 indicates total no of partitions possible after fixing i or leftsum\\n            res = (res + max(0, r-l+1)) %MOD;            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nRuntime: 436 ms",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<int>&presum, int idx, int sum, bool flag){\\n        \\n        // just for readability\\n        int leftsum, rightsum;\\n        if(flag)leftsum = sum;\\n        else rightsum = sum;\\n        \\n        int low = idx, high = presum.size()-1, index = -1;\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            int midsum = presum[mid];\\n            if(flag){\\n                if(leftsum <= midsum){\\n                    index = mid;\\n                    high = mid-1;\\n                }\\n                else low = mid+1;\\n            }\\n            else{\\n                if(midsum <= rightsum){\\n                    index = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid-1;\\n            }\\n        }        \\n        return index;\\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int>presum(n, nums[0]);\\n        for(int i = 1; i < n; ++i) presum[i] = presum[i-1] + nums[i];\\n        \\n        int res = 0, MOD = 1e9+7;\\n        for(int i = 0; i < n; ++i){\\n            \\n            // first cut at index just after i, and second cut at j where j in [l,r]\\n            // Hence, presum[i] <= presum[j] - presum[i] <= presum[n-1] - presum[j]\\n            \\n            // 1st condition: 2*presum[i] <= presum[j]\\n            int l = binarySearch(presum, i+1, 2*presum[i], true); \\n            \\n            // 2nd condition: 2*presum[j] <= presum[n-1] + presum[i]\\n            int r = binarySearch(presum, i+1, (presum[n-1] + presum[i])/2, false); \\n            \\n            if(l == -1 || r == -1)continue;\\n            \\n            r = min(r, n-2); // if r >= n-1, then rightsum partition will be empty\\n            l = max(i+1, l); // if l <= i, then midsum partition will be empty \\n            \\n            // r-l+1 indicates total no of partitions possible after fixing i or leftsum\\n            res = (res + max(0, r-l+1)) %MOD;            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\n// time : O(nlogn) space: O(n)\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int>presum(n, nums[0]);\\n        for(int i = 1; i < n; ++i) presum[i] = presum[i-1] + nums[i];\\n        \\n        int res = 0, MOD = 1e9+7;\\n        for(int i = 0; i < n; ++i){\\n            \\n            // first cut at index just after i, and second cut at j where j in [l,r]\\n            // Hence, presum[i] <= presum[j] - presum[i] <= presum[n-1] - presum[j]\\n            \\n            // 1st condition: 2*presum[i] <= presum[j]\\n            int l = lower_bound(presum.begin()+i+1, presum.end(), 2*presum[i]) - presum.begin(); \\n            \\n            // 2nd condition: 2*presum[j] <= presum[n-1] + presum[i]\\n            int r = upper_bound(presum.begin()+i+1, presum.begin()+n-1, (presum[n-1] + presum[i])/2) - presum.begin(); \\n            \\n            r--;\\n            \\n            // r-l+1 indicates total no of partitions possible after fixing i or leftsum\\n            res = (res + max(0, r-l+1)) %MOD;            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008581,
                "title": "binary-search-solution-c-o-nlogn",
                "content": "```\\nconst int MOD = (int)(1e9) + 7 ;\\nclass Solution {\\npublic:\\n    vector<int> getPrefix(vector<int> &a, int &n){\\n        vector<int> prefix(n, 0) ; prefix[0] = a[0] ;\\n        for(int i = 1 ; i < n ; i++) prefix[i] = prefix[i-1] + a[i] ;\\n        return prefix ;\\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        int len = nums.size(), res = 0 ;\\n        vector<int> prefix = getPrefix(nums, len) ;\\n        for(int i = 0 ; i <= len - 1 ; i++){\\n            int cur = prefix[i] ;\\n            int mnMid = cur ;\\n            int mxMid = ( prefix[len-1] - cur ) / 2 ;\\n            if( cur > mxMid ) break ;\\n            int j = lower_bound(prefix.begin() + i + 1, prefix.end() - 1, cur + mnMid ) - prefix.begin() ;\\n            int k = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, cur + mxMid ) - prefix.begin() - 1 ;\\n            res = ( res + k - j + 1 ) % MOD ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MOD = (int)(1e9) + 7 ;\\nclass Solution {\\npublic:\\n    vector<int> getPrefix(vector<int> &a, int &n){\\n        vector<int> prefix(n, 0) ; prefix[0] = a[0] ;\\n        for(int i = 1 ; i < n ; i++) prefix[i] = prefix[i-1] + a[i] ;\\n        return prefix ;\\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        int len = nums.size(), res = 0 ;\\n        vector<int> prefix = getPrefix(nums, len) ;\\n        for(int i = 0 ; i <= len - 1 ; i++){\\n            int cur = prefix[i] ;\\n            int mnMid = cur ;\\n            int mxMid = ( prefix[len-1] - cur ) / 2 ;\\n            if( cur > mxMid ) break ;\\n            int j = lower_bound(prefix.begin() + i + 1, prefix.end() - 1, cur + mnMid ) - prefix.begin() ;\\n            int k = upper_bound(prefix.begin() + i + 1, prefix.end() - 1, cur + mxMid ) - prefix.begin() - 1 ;\\n            res = ( res + k - j + 1 ) % MOD ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007070,
                "title": "cpp-simple-to-understand-using-prefix-sum-and-binary-search",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int s = nums.size();\\n        vector<int> sum(s, 0);\\n        long ans = 0;\\n        sum[0] = nums[0];\\n        // get the prefix Sum\\n        for(int i = 1; i<s; i++) {\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n            \\n        // Ex: [1,2,2,2,5,0]: A possible cut: [1,2] [2,2], [5,0] --> here the array sum is in sorted order: 3,4,5 so we apply binary search on prefix sum array\\n        \\n        for(int i = 0; i<s; i++) {\\n            \\n            //1. the minimum sum of middle array can be sum[i]. So we find the first index j at which the sum is >= sum[i]\\n             int a1 = binarySearch1(i+1, s-1, i, sum);\\n             if(a1 == -1) continue;\\n            \\n            //2. the max sum of middle arr can be reminSum/2. So we find the first index k at which the sum <= remainingSum/2\\n            int a2 = binarySearch2(i+1, s-1, i, s, sum);\\n            if(a2 == -1 || a2 < a1) continue;\\n            if(a2 == s-1) a2 -= 1;\\n            \\n            //3. Now the indices range [a1 a2] are the ways we can break the array. Store it in ans \\n          \\n            ans += (a2-a1+1);\\n        }\\n        \\n        return ans%(1000000007);\\n    }\\n    \\n    int binarySearch1(int left, int right, int i, vector<int>& sum) {\\n\\n         int ans1 = -1;\\n        while(left<=right) {\\n            int mid = left + (right-left)/2;\\n            \\n            if(sum[mid]-sum[i] >= sum[i]) {\\n                // possible ans\\n                ans1 = mid;\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return ans1;\\n    }\\n    \\n    int binarySearch2(int left, int right, int i, int sz, vector<int>& sum) {\\n\\n        int ans2 = -1;\\n        while(left<=right) {\\n            int mid = left + (right-left)/2;\\n            \\n            if(sum[mid]-sum[i] <= (sum[sz-1] - sum[i])/2) {\\n                //possible ans\\n                ans2 = mid;\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return ans2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int s = nums.size();\\n        vector<int> sum(s, 0);\\n        long ans = 0;\\n        sum[0] = nums[0];\\n        // get the prefix Sum\\n        for(int i = 1; i<s; i++) {\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n            \\n        // Ex: [1,2,2,2,5,0]: A possible cut: [1,2] [2,2], [5,0] --> here the array sum is in sorted order: 3,4,5 so we apply binary search on prefix sum array\\n        \\n        for(int i = 0; i<s; i++) {\\n            \\n            //1. the minimum sum of middle array can be sum[i]. So we find the first index j at which the sum is >= sum[i]\\n             int a1 = binarySearch1(i+1, s-1, i, sum);\\n             if(a1 == -1) continue;\\n            \\n            //2. the max sum of middle arr can be reminSum/2. So we find the first index k at which the sum <= remainingSum/2\\n            int a2 = binarySearch2(i+1, s-1, i, s, sum);\\n            if(a2 == -1 || a2 < a1) continue;\\n            if(a2 == s-1) a2 -= 1;\\n            \\n            //3. Now the indices range [a1 a2] are the ways we can break the array. Store it in ans \\n          \\n            ans += (a2-a1+1);\\n        }\\n        \\n        return ans%(1000000007);\\n    }\\n    \\n    int binarySearch1(int left, int right, int i, vector<int>& sum) {\\n\\n         int ans1 = -1;\\n        while(left<=right) {\\n            int mid = left + (right-left)/2;\\n            \\n            if(sum[mid]-sum[i] >= sum[i]) {\\n                // possible ans\\n                ans1 = mid;\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        return ans1;\\n    }\\n    \\n    int binarySearch2(int left, int right, int i, int sz, vector<int>& sum) {\\n\\n        int ans2 = -1;\\n        while(left<=right) {\\n            int mid = left + (right-left)/2;\\n            \\n            if(sum[mid]-sum[i] <= (sum[sz-1] - sum[i])/2) {\\n                //possible ans\\n                ans2 = mid;\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return ans2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005689,
                "title": "java-o-n-sliding-window",
                "content": "```\\nclass Solution {\\n    static final int MOD=1000000007;\\n    public int waysToSplit(int[] nums) {\\n        var len=nums.length;\\n        for(int i=1;i<len;i++) {\\n            nums[i]+=nums[i-1];\\n        }\\n        int l=0,r=0,cnt=0;\\n        for(int i=0;i<len;i++) {\\n            l=Math.max(i+1,l);\\n            while(l<len&&nums[l]-nums[i]<nums[i]) l++;\\n            r=Math.max(l,r);\\n            while(r<len-1&&nums[len-1]-nums[r]>=nums[r]-nums[i]) r++;\\n            cnt+=r-l;\\n            cnt%=MOD;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static final int MOD=1000000007;\\n    public int waysToSplit(int[] nums) {\\n        var len=nums.length;\\n        for(int i=1;i<len;i++) {\\n            nums[i]+=nums[i-1];\\n        }\\n        int l=0,r=0,cnt=0;\\n        for(int i=0;i<len;i++) {\\n            l=Math.max(i+1,l);\\n            while(l<len&&nums[l]-nums[i]<nums[i]) l++;\\n            r=Math.max(l,r);\\n            while(r<len-1&&nums[len-1]-nums[r]>=nums[r]-nums[i]) r++;\\n            cnt+=r-l;\\n            cnt%=MOD;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001351,
                "title": "binary-search-prefixsum-python-java",
                "content": "**Java Solution**\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int ans=0;\\n        int MOD = (int) (1e9 + 7);\\n        for(int i=1; i<nums.length; i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        for(int i=0; i<nums.length-1; i++){\\n            if (nums[i]>nums[nums.length-1]-nums[i])  break;\\n            int l=findind(nums, i, nums[i], true);\\n            int r=findind(nums, i, nums[i], false);\\n            if (l==-1 || r==-1) continue;\\n            ans = (ans + (r - l + 1) % MOD) % MOD;\\n        }\\n        return ans;\\n    }\\n    \\n    public int findind(int[] nums, int ind, int lsum, boolean goleft){\\n        int l=ind+1,r=nums.length-1, ans=-1;\\n        int N=nums.length;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            int msum=nums[m]-lsum,rsum=nums[N-1]-nums[m];\\n            if(m==N-1) break;\\n            if (lsum<=msum && msum<=rsum){\\n                ans=m;\\n                if (goleft) r=m-1;\\n                else l=m+1;\\n            }\\n            else if (msum>rsum) r=m-1;\\n            else  l=m+1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Python Solution**\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        ans=0\\n        def find_ind(ind,lsum,goleft):\\n            l,r,ans=ind+1,len(nums)-1,-1\\n            while l<=r:\\n                m=(l+r)//2\\n                msum,rsum=nums[m]-lsum,nums[-1]-nums[m]\\n                if m==len(nums)-1: break\\n                if lsum<=msum<=rsum:\\n                    ans=m\\n                    if goleft: r=m-1\\n                    else: l=m+1\\n                elif msum>rsum:\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return ans\\n        for i in range(1,len(nums)): nums[i]+=nums[i-1]\\n        for i in range(len(nums)-1):\\n            if nums[i]>(nums[-1]-nums[i]): break\\n            l,r=find_ind(i,nums[i],True),find_ind(i,nums[i],False)\\n            if l==-1 or r==-1: continue\\n            ans+=r-l+1\\n        return ans%1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int ans=0;\\n        int MOD = (int) (1e9 + 7);\\n        for(int i=1; i<nums.length; i++){\\n            nums[i]+=nums[i-1];\\n        }\\n        for(int i=0; i<nums.length-1; i++){\\n            if (nums[i]>nums[nums.length-1]-nums[i])  break;\\n            int l=findind(nums, i, nums[i], true);\\n            int r=findind(nums, i, nums[i], false);\\n            if (l==-1 || r==-1) continue;\\n            ans = (ans + (r - l + 1) % MOD) % MOD;\\n        }\\n        return ans;\\n    }\\n    \\n    public int findind(int[] nums, int ind, int lsum, boolean goleft){\\n        int l=ind+1,r=nums.length-1, ans=-1;\\n        int N=nums.length;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            int msum=nums[m]-lsum,rsum=nums[N-1]-nums[m];\\n            if(m==N-1) break;\\n            if (lsum<=msum && msum<=rsum){\\n                ans=m;\\n                if (goleft) r=m-1;\\n                else l=m+1;\\n            }\\n            else if (msum>rsum) r=m-1;\\n            else  l=m+1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        ans=0\\n        def find_ind(ind,lsum,goleft):\\n            l,r,ans=ind+1,len(nums)-1,-1\\n            while l<=r:\\n                m=(l+r)//2\\n                msum,rsum=nums[m]-lsum,nums[-1]-nums[m]\\n                if m==len(nums)-1: break\\n                if lsum<=msum<=rsum:\\n                    ans=m\\n                    if goleft: r=m-1\\n                    else: l=m+1\\n                elif msum>rsum:\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return ans\\n        for i in range(1,len(nums)): nums[i]+=nums[i-1]\\n        for i in range(len(nums)-1):\\n            if nums[i]>(nums[-1]-nums[i]): break\\n            l,r=find_ind(i,nums[i],True),find_ind(i,nums[i],False)\\n            if l==-1 or r==-1: continue\\n            ans+=r-l+1\\n        return ans%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000008,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int s = 0;\\n        for (int x : nums) {\\n            s += x;\\n        }\\n        const int n = nums.size();\\n        long long r  = 0;\\n        for (int i = 0, s1 = 0, s2 = 0, s3 = s, num2 = 0, num3 = n; i < n; ++i) {\\n            s1 += nums[i];\\n            for (; num2 < n && (num2 <= i + 1 || s2 - s1 < s1); s2 += nums[num2++])\\n            ;\\n            if (num2 <= i + 1 || s2 - s1 < s1) break;\\n            for (; num3 > 1 && s - s1 - s3 + nums[n - num3] <= s3 - nums[n - num3]; s3 -= nums[n - num3--])\\n            ;\\n            if (num3 >= n - i - 1) break;\\n            // x >= num2 - 1\\n            // x  <= n - num3 - 2\\n            r += max(n - num3 - num2 + 1, 0);\\n        }\\n        return r % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int s = 0;\\n        for (int x : nums) {\\n            s += x;\\n        }\\n        const int n = nums.size();\\n        long long r  = 0;\\n        for (int i = 0, s1 = 0, s2 = 0, s3 = s, num2 = 0, num3 = n; i < n; ++i) {\\n            s1 += nums[i];\\n            for (; num2 < n && (num2 <= i + 1 || s2 - s1 < s1); s2 += nums[num2++])\\n            ;\\n            if (num2 <= i + 1 || s2 - s1 < s1) break;\\n            for (; num3 > 1 && s - s1 - s3 + nums[n - num3] <= s3 - nums[n - num3]; s3 -= nums[n - num3--])\\n            ;\\n            if (num3 >= n - i - 1) break;\\n            // x >= num2 - 1\\n            // x  <= n - num3 - 2\\n            r += max(n - num3 - num2 + 1, 0);\\n        }\\n        return r % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999428,
                "title": "java-3-pointer-o-n",
                "content": "```\\nclass Solution {\\n    int MOD = 1_000_000_007;\\n     public int waysToSplit(int[] nums) {\\n        final int N = nums.length;\\n        int[] prefix = new int[N];\\n         prefix[0]=nums[0];\\n        for (int i = 1; i < N; i++) {\\n          prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        long res = 0;\\n        int i1 = 1;\\n        int i2 = 1;\\n        for(int i=0;i<N-2;i++){\\n            int left = prefix[i];\\n            i1 = Math.max(i1,i+1);\\n            while(i1<N-1&&prefix[i1]-left<left){\\n                i1++;\\n            }\\n            \\n            while(i2<N-1&&prefix[N-1]-prefix[i2]>=prefix[i2]-left){\\n                i2++;\\n            }\\n            if(i2>i1&&i1<N-1){\\n                res += (long) (i2 - i1);\\n            }\\n            \\n        } \\n        return (int) (res % MOD);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1_000_000_007;\\n     public int waysToSplit(int[] nums) {\\n        final int N = nums.length;\\n        int[] prefix = new int[N];\\n         prefix[0]=nums[0];\\n        for (int i = 1; i < N; i++) {\\n          prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        long res = 0;\\n        int i1 = 1;\\n        int i2 = 1;\\n        for(int i=0;i<N-2;i++){\\n            int left = prefix[i];\\n            i1 = Math.max(i1,i+1);\\n            while(i1<N-1&&prefix[i1]-left<left){\\n                i1++;\\n            }\\n            \\n            while(i2<N-1&&prefix[N-1]-prefix[i2]>=prefix[i2]-left){\\n                i2++;\\n            }\\n            if(i2>i1&&i1<N-1){\\n                res += (long) (i2 - i1);\\n            }\\n            \\n        } \\n        return (int) (res % MOD);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999223,
                "title": "python-binary-search-o-nlogn",
                "content": "Our goal is to find two indices i,j, such that 0 <= i < j < n-1, and sum(nums[0:i+1]) <= sum(nums[i+1:j+1]) <= sum(nums[j+1:]). in fact, let s be the prefix sum array, it is same as the following inequalities:\\n\\ns[i] <= s[j] - s[i]\\ns[j] - s[i] <= s[n-1] - s[j]\\nor\\ns[j] >= 2\\\\*s[i]\\n s[j] <=(s[i] + s[n-1]) / 2\\n \\nWe can use another array s to keep track of prefix sum of nums. Notice that \\n1. for each i, nums[i] >= 0, so s is non-decreasing. \\n2. for fixed i, since s is non-decreasing, we want to find boundaries of j, on one hand, we want j to be as small as possible (left bound) but keep the mid part sum greater or equal than left sum. On the other hand, we want j to be as large as possible (right bound) but in the meantime keep the right part sum greater or equal than mid sum. \\n\\nFor each i, we do binary search for j twice, j_small and j_big based on above inequalities. Add j_big - j_small to our result.\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n\\t\\t# let s be the prefix sum of nums, s[i] is the prefix sum of nums[0:i+1]\\n        # iterate i from 0 to n-3, find smallest j such that si <= sj - si\\n        # and biggest j such that sj - si <= sn-1 - sj\\n        MOD = 10**9+7\\n        n = len(nums)\\n        s = [0 for _ in range(n)]\\n        cur = 0\\n        # prefix sum\\n        for i in range(n):\\n            cur += nums[i]\\n            s[i] = cur\\n        res = 0\\n        for i in range(n-2):\\n            j_small = max(bisect.bisect_left(s, 2*s[i]), i+1)\\n            j_big = min(bisect.bisect_right(s, (s[i] + s[n-1])/2), n-1)\\n            # print(j_small)\\n            # print(j_big)\\n            if j_small <= j_big:\\n                res = (res + j_big - j_small) % MOD\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n\\t\\t# let s be the prefix sum of nums, s[i] is the prefix sum of nums[0:i+1]\\n        # iterate i from 0 to n-3, find smallest j such that si <= sj - si\\n        # and biggest j such that sj - si <= sn-1 - sj\\n        MOD = 10**9+7\\n        n = len(nums)\\n        s = [0 for _ in range(n)]\\n        cur = 0\\n        # prefix sum\\n        for i in range(n):\\n            cur += nums[i]\\n            s[i] = cur\\n        res = 0\\n        for i in range(n-2):\\n            j_small = max(bisect.bisect_left(s, 2*s[i]), i+1)\\n            j_big = min(bisect.bisect_right(s, (s[i] + s[n-1])/2), n-1)\\n            # print(j_small)\\n            # print(j_big)\\n            if j_small <= j_big:\\n                res = (res + j_big - j_small) % MOD\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999213,
                "title": "python-binary-search-o-n-logn",
                "content": "**Binary Search Solution:**\\nFirst we need to build a prefix array which represent the prefix_sum of each index.\\n\\nThen we needs to cut the array into 3 pieces and each piece len > 0,\\nSo we have two cut index\\n\\nUse the second cut index and make it as `j`,  for each j we need to find the range of the first cut index, which in my code represented as `lo and hi`, the way to find `lo and hi` is by using binary search.\\n\\nTime Complexity O(n logn)\\nSpace Complexity O(n)\\n\\nIf you like my post, please upvote it :)\\n\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        ans, mod = 0, 10**9+7\\n        prefix, prefixs = 0,  [0]*len(nums)\\n        for i in range(len(nums)):\\n            prefix += nums[i]\\n            prefixs[i] = prefix\\n    \\n        j = len(nums)-2\\n    \\n        while j >= 2 and prefixs[len(nums)-1] - prefixs[j] < prefix//3:\\n            j -= 1\\n        while j >= 1:\\n            last = prefixs[len(nums)-1]-prefixs[j]\\n            rem = prefixs[j]\\n            hi = bisect.bisect_right(prefixs, rem//2, 0, j-1)\\n            if prefixs[hi] > rem//2: hi -= 1\\n            lo = bisect.bisect_left(prefixs, rem-last, 0, hi)\\n            if prefixs[lo] < rem-last: lo += 1\\n            if j >= hi >= lo >= 0 and last >= prefixs[len(nums)-1]-last-prefixs[lo]:\\n                ans += hi-lo+1\\n                ans %= mod\\n            j -= 1\\n    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        ans, mod = 0, 10**9+7\\n        prefix, prefixs = 0,  [0]*len(nums)\\n        for i in range(len(nums)):\\n            prefix += nums[i]\\n            prefixs[i] = prefix\\n    \\n        j = len(nums)-2\\n    \\n        while j >= 2 and prefixs[len(nums)-1] - prefixs[j] < prefix//3:\\n            j -= 1\\n        while j >= 1:\\n            last = prefixs[len(nums)-1]-prefixs[j]\\n            rem = prefixs[j]\\n            hi = bisect.bisect_right(prefixs, rem//2, 0, j-1)\\n            if prefixs[hi] > rem//2: hi -= 1\\n            lo = bisect.bisect_left(prefixs, rem-last, 0, hi)\\n            if prefixs[lo] < rem-last: lo += 1\\n            if j >= hi >= lo >= 0 and last >= prefixs[len(nums)-1]-last-prefixs[lo]:\\n                ans += hi-lo+1\\n                ans %= mod\\n            j -= 1\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999156,
                "title": "2-pointers-solution-tle-for-python-c",
                "content": "I see a post using 2 pointer solution with JAVA.\\nBut my below 2 pointer solution with both Python & C# got TLE.\\nPlease advise.\\n```\\nclass Solution:\\n    def waysToSplit(self, n: List[int]) -> int:\\n        s = [n[0]]\\n        for i in range(1, len(n)):\\n            s.append(s[-1]+n[i])\\n        l,m,r=0,1,len(n)-1\\n        lastm = 0\\n        res = 0\\n        while l<r:\\n            while l<r and s[l]>s[-1]-s[r-1]:\\n                r -= 1\\n            if l==r:\\n                break\\n            m = lastm if lastm>l+1 else l+1\\n            while s[l]>s[m]-s[l] and m<r:\\n                m += 1\\n            if m==r:\\n                l+=1\\n                continue\\n            lastm = m\\n            while m<r and s[m]-s[l]<=s[-1]-s[m]:\\n                res += 1\\n                m += 1\\n            l += 1\\n        return res%1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, n: List[int]) -> int:\\n        s = [n[0]]\\n        for i in range(1, len(n)):\\n            s.append(s[-1]+n[i])\\n        l,m,r=0,1,len(n)-1\\n        lastm = 0\\n        res = 0\\n        while l<r:\\n            while l<r and s[l]>s[-1]-s[r-1]:\\n                r -= 1\\n            if l==r:\\n                break\\n            m = lastm if lastm>l+1 else l+1\\n            while s[l]>s[m]-s[l] and m<r:\\n                m += 1\\n            if m==r:\\n                l+=1\\n                continue\\n            lastm = m\\n            while m<r and s[m]-s[l]<=s[-1]-s[m]:\\n                res += 1\\n                m += 1\\n            l += 1\\n        return res%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999144,
                "title": "c-3-pointer-o-n-binary-search-o-n-logn",
                "content": "create prefix sum array\\nleft (0,i)\\nmiddle(i+1,r)\\nright (r+1,n-1)\\nchoose only that  range in middle that satify both middle<=right and left<=middle\\n\\nfinding pointers via binarySearch\\n\\n    int waysToSplit(vector<int>& nums) {\\n        #define MOD 1000000007\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n            nums[i]+=nums[i-1];\\n        int ans=0;\\n        int beta,alpha;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int left=nums[i];\\n            int low=i+1;\\n            int high=n-2;\\n    \\n            while(high-low>1)\\n            {\\n                int mid=(high+low)>>1;\\n                int right=nums[n-1]-nums[mid];\\n                int middle=nums[mid]-left;\\n                if(right>=middle) low=mid;\\n                else high=mid;\\n            }\\n            if(nums[n-1]+left>=2*nums[high]) beta=high;\\n            else if(nums[n-1]+left>=2*nums[low]) beta=low;\\n            else beta=-1;\\n            if(beta>=0)    \\n            {\\n                low=i+1;\\n                high=beta;\\n                while(high-low>1)\\n                {\\n                 int mid=(high+low)>>1;\\n                 int middle=nums[mid]-left;\\n                 if(middle>=left) high=mid;\\n                 else low=mid;\\n                }\\n                if(nums[low]>=2*left) alpha=low;\\n                else if(nums[high]>=2*left) alpha=high;\\n                else alpha=-1;\\n            }\\n            if(beta>=0 && alpha>=0)\\n            {   \\n                ans+=(beta-alpha+1)%MOD;\\n                ans%=MOD;\\n            }\\n            //cout<<i<<\" alpha:\"<<alpha<<\" beta:\"<<beta<<endl;\\n        }\\n        return ans;\\n    }\\n\\nnotice:\\nfor pointer alpha middle>=left so if left increases middle will increase via increasing alpha\\nfor pointer beta middle<=right if left increases middle will decrease ,so to increase middle for fixed left beta needs to be increased. therefore in each left update new aplha and beta will be greate than equal to prev values. Hence problems can be reduced to O(n)\\n\\n    int waysToSplit(vector<int>& nums) {\\n        #define MOD 1000000007\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n            nums[i]+=nums[i-1];\\n        int ans=0;\\n        int alpha=1;\\n        int beta=1;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int left=nums[i];\\n            alpha=max(alpha,i+1);\\n            while(alpha<n-1)\\n            {\\n               int middle=nums[alpha]-left;\\n               if(middle<left)  alpha++;\\n               else break;\\n            }\\n            beta=max(alpha,beta);\\n            while(beta<n-1)\\n            {\\n               int middle=nums[beta]-left;\\n               int right=nums[n-1]-nums[beta];\\n               if(middle<=right) beta++;\\n               else break;\\n            }\\n            if(nums[n-1]-nums[beta]<nums[beta]-left || beta==n-1) beta--;\\n            if(beta<n-1 && alpha<n-1 && beta>=alpha && nums[alpha]>=2*left && nums[n-1]+left>=2*nums[beta] )\\n            {   \\n                ans+=(beta-alpha+1)%MOD;\\n                ans%=MOD;\\n            }\\n            //cout<<\"i: \"<<i<<\" alpha:\"<<alpha<<\" beta:\"<<beta<<endl;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "create prefix sum array\\nleft (0,i)\\nmiddle(i+1,r)\\nright (r+1,n-1)\\nchoose only that  range in middle that satify both middle<=right and left<=middle\\n\\nfinding pointers via binarySearch\\n\\n    int waysToSplit(vector<int>& nums) {\\n        #define MOD 1000000007\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n            nums[i]+=nums[i-1];\\n        int ans=0;\\n        int beta,alpha;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int left=nums[i];\\n            int low=i+1;\\n            int high=n-2;\\n    \\n            while(high-low>1)\\n            {\\n                int mid=(high+low)>>1;\\n                int right=nums[n-1]-nums[mid];\\n                int middle=nums[mid]-left;\\n                if(right>=middle) low=mid;\\n                else high=mid;\\n            }\\n            if(nums[n-1]+left>=2*nums[high]) beta=high;\\n            else if(nums[n-1]+left>=2*nums[low]) beta=low;\\n            else beta=-1;\\n            if(beta>=0)    \\n            {\\n                low=i+1;\\n                high=beta;\\n                while(high-low>1)\\n                {\\n                 int mid=(high+low)>>1;\\n                 int middle=nums[mid]-left;\\n                 if(middle>=left) high=mid;\\n                 else low=mid;\\n                }\\n                if(nums[low]>=2*left) alpha=low;\\n                else if(nums[high]>=2*left) alpha=high;\\n                else alpha=-1;\\n            }\\n            if(beta>=0 && alpha>=0)\\n            {   \\n                ans+=(beta-alpha+1)%MOD;\\n                ans%=MOD;\\n            }\\n            //cout<<i<<\" alpha:\"<<alpha<<\" beta:\"<<beta<<endl;\\n        }\\n        return ans;\\n    }\\n\\nnotice:\\nfor pointer alpha middle>=left so if left increases middle will increase via increasing alpha\\nfor pointer beta middle<=right if left increases middle will decrease ,so to increase middle for fixed left beta needs to be increased. therefore in each left update new aplha and beta will be greate than equal to prev values. Hence problems can be reduced to O(n)\\n\\n    int waysToSplit(vector<int>& nums) {\\n        #define MOD 1000000007\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n            nums[i]+=nums[i-1];\\n        int ans=0;\\n        int alpha=1;\\n        int beta=1;\\n        for(int i=0;i<n-2;i++)\\n        {\\n            int left=nums[i];\\n            alpha=max(alpha,i+1);\\n            while(alpha<n-1)\\n            {\\n               int middle=nums[alpha]-left;\\n               if(middle<left)  alpha++;\\n               else break;\\n            }\\n            beta=max(alpha,beta);\\n            while(beta<n-1)\\n            {\\n               int middle=nums[beta]-left;\\n               int right=nums[n-1]-nums[beta];\\n               if(middle<=right) beta++;\\n               else break;\\n            }\\n            if(nums[n-1]-nums[beta]<nums[beta]-left || beta==n-1) beta--;\\n            if(beta<n-1 && alpha<n-1 && beta>=alpha && nums[alpha]>=2*left && nums[n-1]+left>=2*nums[beta] )\\n            {   \\n                ans+=(beta-alpha+1)%MOD;\\n                ans%=MOD;\\n            }\\n            //cout<<\"i: \"<<i<<\" alpha:\"<<alpha<<\" beta:\"<<beta<<endl;\\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 999124,
                "title": "accepted-c-solution-with-binary-search",
                "content": "Idea:\\n1)Calculate prefix sums\\n2) Foreach possible border \\'i\\' of left subarray we can find lowest (\\'left\\') and highest (\\'right\\') possible index of middle subarray border.\\n3) Answer = sum of (right - left + 1) for all i\\n\\n```\\n public class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n\\n        public int WaysToSplit(int[] nums)\\n        {\\n            checked\\n            {\\n                long[] sums = new long[nums.Length];\\n                sums[0] = nums[0];\\n                for (int i = 1; i < nums.Length; i++)\\n                {\\n                    sums[i] = sums[i - 1] + nums[i];\\n                }\\n\\n                int res = 0;\\n\\n                for (int i = 0; i < nums.Length; i++)\\n                {\\n                    int l = i + 1;\\n                    //-2 because third subarray should be also non-empty\\n                    int r = nums.Length - 2;\\n\\n                    if (l > r)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int left = -1;\\n                    int right = -1;\\n\\n                    while (r - l > 1)\\n                    {\\n                        int mid = l + (r - l) / 2;\\n                        if (sums[mid] - sums[i] < sums[i])\\n                        {\\n                            l = mid;\\n                        }\\n                        else\\n                        {\\n                            r = mid;\\n                        }\\n                    }\\n\\n\\n                    if (sums[l] - sums[i] >= sums[i])\\n                    {\\n                        left = l;\\n                    }\\n                    else\\n                    {\\n                        if (sums[r] - sums[i] >= sums[i])\\n                        {\\n                            left = r;\\n                        }\\n                    }\\n\\n\\n                    l = i + 1;\\n                    r = nums.Length - 2;\\n\\n                    long second = 0;\\n                    long third = 0;\\n\\n                    while (r - l > 1)\\n                    {\\n                        int mid = l + (r - l) / 2;\\n                        second = sums[mid] - sums[i];\\n                        third = sums[nums.Length - 1] - sums[mid];\\n\\n                        if (second <= third)\\n                        {\\n                            l = mid;\\n                        }\\n                        else\\n                        {\\n                            r = mid;\\n                        }\\n                    }\\n\\n                    second = sums[r] - sums[i];\\n                    third = sums[nums.Length - 1] - sums[r];\\n\\n                    if (second <= third)\\n                    {\\n                        right = r;\\n                    }\\n                    else\\n                    {\\n                        second = sums[l] - sums[i];\\n                        third = sums[nums.Length - 1] - sums[l];\\n\\n                        if (second <= third)\\n                        {\\n                            right = l;\\n                        }\\n                    }\\n\\n\\n                    if (right >= 0 && left >= 0)\\n                    {\\n                        res += Math.Max(0, right - left + 1);\\n                        res %= MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n public class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n\\n        public int WaysToSplit(int[] nums)\\n        {\\n            checked\\n            {\\n                long[] sums = new long[nums.Length];\\n                sums[0] = nums[0];\\n                for (int i = 1; i < nums.Length; i++)\\n                {\\n                    sums[i] = sums[i - 1] + nums[i];\\n                }\\n\\n                int res = 0;\\n\\n                for (int i = 0; i < nums.Length; i++)\\n                {\\n                    int l = i + 1;\\n                    //-2 because third subarray should be also non-empty\\n                    int r = nums.Length - 2;\\n\\n                    if (l > r)\\n                    {\\n                        continue;\\n                    }\\n\\n                    int left = -1;\\n                    int right = -1;\\n\\n                    while (r - l > 1)\\n                    {\\n                        int mid = l + (r - l) / 2;\\n                        if (sums[mid] - sums[i] < sums[i])\\n                        {\\n                            l = mid;\\n                        }\\n                        else\\n                        {\\n                            r = mid;\\n                        }\\n                    }\\n\\n\\n                    if (sums[l] - sums[i] >= sums[i])\\n                    {\\n                        left = l;\\n                    }\\n                    else\\n                    {\\n                        if (sums[r] - sums[i] >= sums[i])\\n                        {\\n                            left = r;\\n                        }\\n                    }\\n\\n\\n                    l = i + 1;\\n                    r = nums.Length - 2;\\n\\n                    long second = 0;\\n                    long third = 0;\\n\\n                    while (r - l > 1)\\n                    {\\n                        int mid = l + (r - l) / 2;\\n                        second = sums[mid] - sums[i];\\n                        third = sums[nums.Length - 1] - sums[mid];\\n\\n                        if (second <= third)\\n                        {\\n                            l = mid;\\n                        }\\n                        else\\n                        {\\n                            r = mid;\\n                        }\\n                    }\\n\\n                    second = sums[r] - sums[i];\\n                    third = sums[nums.Length - 1] - sums[r];\\n\\n                    if (second <= third)\\n                    {\\n                        right = r;\\n                    }\\n                    else\\n                    {\\n                        second = sums[l] - sums[i];\\n                        third = sums[nums.Length - 1] - sums[l];\\n\\n                        if (second <= third)\\n                        {\\n                            right = l;\\n                        }\\n                    }\\n\\n\\n                    if (right >= 0 && left >= 0)\\n                    {\\n                        res += Math.Max(0, right - left + 1);\\n                        res %= MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999110,
                "title": "java-binary-search-solution",
                "content": "```\\npublic int waysToSplit(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        long mod=(long)1e9+7;\\n        long res=0;\\n        for(int i=0;i<nums.length;i++){\\n            int first=nums[i];\\n            int lowerBound=2*nums[i];\\n            int higherBound=(nums[nums.length-1]+nums[i])/2;\\n            if(lowerBound>higherBound) continue;\\n            int left=binarySearch1(nums,lowerBound);\\n            int right=binarySearch2(nums,higherBound);\\n\\t\\t\\t// following two lines are for edge cases\\n            if(left<=i) left=i+1;\\n            if(right==nums.length-1) right--;\\n            if(right<left) continue;\\n            res=(res+(right-left+1)%mod)%mod;\\n        }\\n        return (int)res;\\n    }\\n    \\n    int binarySearch1(int[] nums,int target){\\n        int lo=0,hi=nums.length;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(nums[mid]==target) hi=mid;\\n            else if(nums[mid]<target) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo;\\n    }\\n    \\n    int binarySearch2(int[] nums,int target){\\n        int lo=0,hi=nums.length;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(nums[mid]==target) lo=mid+1;\\n            else if(nums[mid]<target) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int waysToSplit(int[] nums) {\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i-1]+nums[i];\\n        }\\n        long mod=(long)1e9+7;\\n        long res=0;\\n        for(int i=0;i<nums.length;i++){\\n            int first=nums[i];\\n            int lowerBound=2*nums[i];\\n            int higherBound=(nums[nums.length-1]+nums[i])/2;\\n            if(lowerBound>higherBound) continue;\\n            int left=binarySearch1(nums,lowerBound);\\n            int right=binarySearch2(nums,higherBound);\\n\\t\\t\\t// following two lines are for edge cases\\n            if(left<=i) left=i+1;\\n            if(right==nums.length-1) right--;\\n            if(right<left) continue;\\n            res=(res+(right-left+1)%mod)%mod;\\n        }\\n        return (int)res;\\n    }\\n    \\n    int binarySearch1(int[] nums,int target){\\n        int lo=0,hi=nums.length;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(nums[mid]==target) hi=mid;\\n            else if(nums[mid]<target) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo;\\n    }\\n    \\n    int binarySearch2(int[] nums,int target){\\n        int lo=0,hi=nums.length;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(nums[mid]==target) lo=mid+1;\\n            else if(nums[mid]<target) lo=mid+1;\\n            else hi=mid;\\n        }\\n        return lo-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999109,
                "title": "nlogn-binary-search-with-explaination",
                "content": "we just need find two indexes x, y to make [0, x) ,[x, y), [y, n) satisified. 0 != x && x != y && and y != n\\n\\nwe have to do iteration from 1 to n - 1 for x, but for y, we can use binary search\\n\\nwhen y is decided, we need to know how many y\\'s in current x.\\n\\nwe need do another binary search\\n\\nfor example [1, 2, 2, 2, 5]\\nwe know x = 1, y = 2, and sum1 = 1 sum2 = 2 sum3 = 9, and we know (9 - 2) / 2 = 3 we and move y NO bigger than 3\\n\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(const vector<int>& nums) {\\n        static const int mod = 1e9 + 7;\\n        int n = nums.size(), res = 0;\\n        vector<int> acc{0};\\n        partial_sum(nums.begin(), nums.end(), back_inserter(acc));\\n        for (int x = 1; x <= n - 2; ++x) {\\n            int sum1 = acc[x] - acc.front();\\n            int sum2low = acc[x] + sum1;\\n            int y = lower_bound(acc.begin() + x, acc.end() - 1, sum2low) - acc.begin();\\n            if (y == x && y < n) ++y;\\n            int sum2 = acc[y] - acc[x];\\n            int sum3 = acc.back() - acc[y];\\n            if (sum3 < sum2) continue;\\n            int range = (sum3 - sum2) / 2 + acc[y];\\n            int lasty = upper_bound(acc.begin() + y, acc.end() - 1, range) - acc.begin();\\n            res += lasty - y;\\n            if (res >= mod) res -= mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(const vector<int>& nums) {\\n        static const int mod = 1e9 + 7;\\n        int n = nums.size(), res = 0;\\n        vector<int> acc{0};\\n        partial_sum(nums.begin(), nums.end(), back_inserter(acc));\\n        for (int x = 1; x <= n - 2; ++x) {\\n            int sum1 = acc[x] - acc.front();\\n            int sum2low = acc[x] + sum1;\\n            int y = lower_bound(acc.begin() + x, acc.end() - 1, sum2low) - acc.begin();\\n            if (y == x && y < n) ++y;\\n            int sum2 = acc[y] - acc[x];\\n            int sum3 = acc.back() - acc[y];\\n            if (sum3 < sum2) continue;\\n            int range = (sum3 - sum2) / 2 + acc[y];\\n            int lasty = upper_bound(acc.begin() + y, acc.end() - 1, range) - acc.begin();\\n            res += lasty - y;\\n            if (res >= mod) res -= mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074510,
                "title": "solution-with-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int WaysToSplit(int[] nums) {\\n        int n = nums.Length;\\n        int cut = 1;\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        int[] accu = new int[n];\\n        long tot = 0;\\n\\n        int tmp = 0;\\n        for(int i=0; i<n; ++i){\\n            tmp += nums[i];\\n            accu[i] = tmp;\\n        }\\n\\n        int start=1, end = start;\\n        for(int i=0; i<n-2; ++i){\\n            cut = Math.Max(start, i+1);\\n            while(cut<n-1 && accu[cut]-accu[i] < accu[i]){\\n                cut++;\\n            }\\n\\n            if(cut == n-1){\\n                break;\\n            }\\n\\n            start = cut;\\n\\n            cut = Math.Max(end, start);\\n            while(cut < n-1 && accu[n-1]-accu[cut] >= accu[cut]-accu[i]){\\n                cut++;    \\n            }\\n\\n            end = cut - 1;\\n            tot += end - start + 1;\\n            tot %= mod;\\n        }\\n\\n        return (int)tot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int WaysToSplit(int[] nums) {\\n        int n = nums.Length;\\n        int cut = 1;\\n        int mod = (int)Math.Pow(10, 9) + 7;\\n        int[] accu = new int[n];\\n        long tot = 0;\\n\\n        int tmp = 0;\\n        for(int i=0; i<n; ++i){\\n            tmp += nums[i];\\n            accu[i] = tmp;\\n        }\\n\\n        int start=1, end = start;\\n        for(int i=0; i<n-2; ++i){\\n            cut = Math.Max(start, i+1);\\n            while(cut<n-1 && accu[cut]-accu[i] < accu[i]){\\n                cut++;\\n            }\\n\\n            if(cut == n-1){\\n                break;\\n            }\\n\\n            start = cut;\\n\\n            cut = Math.Max(end, start);\\n            while(cut < n-1 && accu[n-1]-accu[cut] >= accu[cut]-accu[i]){\\n                cut++;    \\n            }\\n\\n            end = cut - 1;\\n            tot += end - start + 1;\\n            tot %= mod;\\n        }\\n\\n        return (int)tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976298,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def waysToSplit(self, nums: List[int]) -> int:\\n    kMod = 1_000_000_007\\n    n = len(nums)\\n    ans = 0\\n    prefix = list(itertools.accumulate(nums))\\n\\n    # Find the first index j s.t.\\n    # Mid = prefix[j] - prefix[i] >= left = prefix[i]\\n    def firstGreaterEqual(i: int) -> int:\\n      l = i + 1\\n      r = n - 1\\n      while l < r:\\n        m = (l + r) // 2\\n        if prefix[m] - prefix[i] >= prefix[i]:\\n          r = m\\n        else:\\n          l = m + 1\\n      return l\\n\\n    # Find the first index k s.t.\\n    # Mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\\n    def firstGreater(i: int) -> int:\\n      l = i + 1\\n      r = n - 1\\n      while l < r:\\n        m = (l + r) // 2\\n        if prefix[m] - prefix[i] > prefix[-1] - prefix[m]:\\n          r = m\\n        else:\\n          l = m + 1\\n      return l\\n\\n    for i in range(n - 2):\\n      j = firstGreaterEqual(i)\\n      if j == n - 1:\\n        break\\n      mid = prefix[j] - prefix[i]\\n      right = prefix[-1] - prefix[j]\\n      if mid > right:\\n        continue\\n      k = firstGreater(i)\\n      ans = (ans + k - j) % kMod\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def waysToSplit(self, nums: List[int]) -> int:\\n    kMod = 1_000_000_007\\n    n = len(nums)\\n    ans = 0\\n    prefix = list(itertools.accumulate(nums))\\n\\n    # Find the first index j s.t.\\n    # Mid = prefix[j] - prefix[i] >= left = prefix[i]\\n    def firstGreaterEqual(i: int) -> int:\\n      l = i + 1\\n      r = n - 1\\n      while l < r:\\n        m = (l + r) // 2\\n        if prefix[m] - prefix[i] >= prefix[i]:\\n          r = m\\n        else:\\n          l = m + 1\\n      return l\\n\\n    # Find the first index k s.t.\\n    # Mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\\n    def firstGreater(i: int) -> int:\\n      l = i + 1\\n      r = n - 1\\n      while l < r:\\n        m = (l + r) // 2\\n        if prefix[m] - prefix[i] > prefix[-1] - prefix[m]:\\n          r = m\\n        else:\\n          l = m + 1\\n      return l\\n\\n    for i in range(n - 2):\\n      j = firstGreaterEqual(i)\\n      if j == n - 1:\\n        break\\n      mid = prefix[j] - prefix[i]\\n      right = prefix[-1] - prefix[j]\\n      if mid > right:\\n        continue\\n      k = firstGreater(i)\\n      ans = (ans + k - j) % kMod\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844748,
                "title": "prefix-sum-binary-search-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    int mod = 1e9+7;\\n    int right_bound(int l, int h, int &x,int &y, int &i, vector<int> &pre)\\n    {\\n        int rb = i;\\n\\n        while(l<=h)\\n        {\\n            int mid = l+(h-l)/2;\\n\\n            if(y-pre[mid] >= pre[mid]-x)\\n            {\\n                rb = mid;\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                h = mid-1;\\n            }\\n        }\\n\\n        return rb;\\n    }\\n\\n    int left_bound(int l, int h, int &x,int &y, int &i, vector<int> &pre)\\n    {\\n        int lb = n;\\n\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n\\n            if(pre[mid] - x >= x)\\n            {\\n                lb = mid;\\n                h = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return lb;\\n    }\\n\\n    int waysToSplit(vector<int>& nums) \\n    {\\n        n = nums.size();\\n\\n        vector<int> pre(n, 0);\\n\\n        pre[0] = nums[0];\\n\\n        for(int i=1; i<n; i++)\\n        {\\n            pre[i] = pre[i-1]+nums[i];\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int x = pre[i];\\n            int y = pre[n-1];\\n\\n            int l=i+1, h=n-2;\\n            \\n            int lb = left_bound(l, h, x, y, i, pre);\\n            int rb = right_bound(l, h, x, y, i, pre);\\n\\n            if(rb>=lb)\\n                ans = (ans+(rb-lb+1))%mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    int mod = 1e9+7;\\n    int right_bound(int l, int h, int &x,int &y, int &i, vector<int> &pre)\\n    {\\n        int rb = i;\\n\\n        while(l<=h)\\n        {\\n            int mid = l+(h-l)/2;\\n\\n            if(y-pre[mid] >= pre[mid]-x)\\n            {\\n                rb = mid;\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                h = mid-1;\\n            }\\n        }\\n\\n        return rb;\\n    }\\n\\n    int left_bound(int l, int h, int &x,int &y, int &i, vector<int> &pre)\\n    {\\n        int lb = n;\\n\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n\\n            if(pre[mid] - x >= x)\\n            {\\n                lb = mid;\\n                h = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n\\n        return lb;\\n    }\\n\\n    int waysToSplit(vector<int>& nums) \\n    {\\n        n = nums.size();\\n\\n        vector<int> pre(n, 0);\\n\\n        pre[0] = nums[0];\\n\\n        for(int i=1; i<n; i++)\\n        {\\n            pre[i] = pre[i-1]+nums[i];\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int x = pre[i];\\n            int y = pre[n-1];\\n\\n            int l=i+1, h=n-2;\\n            \\n            int lb = left_bound(l, h, x, y, i, pre);\\n            int rb = right_bound(l, h, x, y, i, pre);\\n\\n            if(rb>=lb)\\n                ans = (ans+(rb-lb+1))%mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833800,
                "title": "c-easy-lower-bound-upper-bound-bs",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        vector<int>pre(n,0);\\n        pre[0] = nums[0];\\n\\n        for(int i = 1;i<n;i++)\\n        {\\n            pre[i] = pre[i-1]+nums[i];\\n        }\\n        int i = 0,ans = 0, mod = 1e9+7;\\n       \\n        while(i<n)\\n        {\\n\\n            int mid = 2*pre[i];\\n            int left = lower_bound(pre.begin()+i+1,pre.end(),mid) - pre.begin();\\n\\n            if(left >= n-1) \\n            {\\n                i++;\\n                continue;\\n            }\\n\\n            int find = (pre[n-1]+pre[i])/2;\\n\\n            int right = upper_bound(pre.begin()+left,pre.end()-1,find) - pre.begin()-1;\\n\\n            if(right >= n-1)\\n            {\\n                i++;\\n                continue;\\n            }\\n                        \\n            ans = (ans+(right-left+1))%mod;\\n             \\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n\\n        vector<int>pre(n,0);\\n        pre[0] = nums[0];\\n\\n        for(int i = 1;i<n;i++)\\n        {\\n            pre[i] = pre[i-1]+nums[i];\\n        }\\n        int i = 0,ans = 0, mod = 1e9+7;\\n       \\n        while(i<n)\\n        {\\n\\n            int mid = 2*pre[i];\\n            int left = lower_bound(pre.begin()+i+1,pre.end(),mid) - pre.begin();\\n\\n            if(left >= n-1) \\n            {\\n                i++;\\n                continue;\\n            }\\n\\n            int find = (pre[n-1]+pre[i])/2;\\n\\n            int right = upper_bound(pre.begin()+left,pre.end()-1,find) - pre.begin()-1;\\n\\n            if(right >= n-1)\\n            {\\n                i++;\\n                continue;\\n            }\\n                        \\n            ans = (ans+(right-left+1))%mod;\\n             \\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816572,
                "title": "java-binary-search-and-clean-code",
                "content": "# Approach\\n1. Compute the prefix sum for the array of nums\\n2. You need to find all possible segments s1,s2,s3 where sum(s1) <= sum(s2) <= sum(s3)\\n3. For each segment s1 = [0, a] ([0,0],[0,1],[0..n-3] )\\n4. Try to find the shortest next segment whose sum is AT LEAST equal to current segment.\\n    - As you have prefixSum, you just need to find the value/index of s1Sum * 2\\n    - Make sure you find the shortest one, as you might have edge cases like 3,3,0,0,0\\n    - When you have segment[3] (index 0), the shortest next segment is [3](index 1).\\n    - If you use binary search, move high to pivot -1 if rollingSum[pivot] >= target\\n5. Now you need to find the average of totalSum - s1 OR s2 + s3.\\n    - Knowing the average index, you know that you can increase s2 up and including the average\\n    - EG: [4,2,2,3,1,1,1,1,12,12] , prefixSum = [4,6,8,11,12,13,14,15,27,39]\\n    - s1 = [4] (index 0)\\n    - s2 = [2,2] (index 1,2)\\n    - average of s2 + s3 = (2+2+3+1+1+1+1+12+12)/2 = 17 + 4 (sum of first segment) = 21\\n    - 21 is found at index 7 (15).\\n    - This means that segment2 can grow from index [1,2] to index [1,7]: [1,2],[1,3],[1,4]..[1,7] => 6 segments\\n    - It can grow because the sum of s2 will not go OVER the half of the remaining sum of totalSum - s1.\\n    - At index 7 s2 will have a sum of 11 and s3 = 24.\\n    - If we attempt to increase s2 once more, we get sum of 23 and s3 = 12, which is not respecing the rules.\\n6. Apply #3 and #4 #5 for each s1 starting from [0,0] .. [0,n-2]\\n7. Also, apply some basic logic: if sum(s1) goes over a third of totalSum OR s2 > s3 => break. \\n\\n# Complexity\\n- Time complexity:$$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int[] rollingSum = getRollingSum(nums);\\n        int ways = 0;\\n        int sum = 0;\\n        int thirdTotal = rollingSum[rollingSum.length - 1];\\n        for (int i = 0; i < nums.length - 2 && sum <= thirdTotal; i++) {\\n            sum += nums[i];\\n            ways = (ways + findWaysToSplit(sum, i+1, rollingSum, rollingSum.length)) % 1_000_000_007;\\n        }\\n        return ways;\\n    }\\n\\n    private int findWaysToSplit(int sum, int from, int[] rollingSum, int l) {\\n        if (sum * 2 > rollingSum[l - 1] - sum) {\\n            return 0;\\n        }\\n        int midSegmentStart = findLeftMost(from, l - 2, sum * 2, rollingSum);\\n        // edge case: [3,2,100,0,0]: midsegment is greater than 3 (2+100) but is also greater than s3 (0,0)\\n        if (rollingSum[midSegmentStart] - sum > rollingSum[l - 1] - rollingSum[midSegmentStart]) {\\n            return 0;\\n        }\\n        int averageIndex = findRightMost(midSegmentStart, l - 2,  sum + (rollingSum[l - 1] - sum) / 2, rollingSum);\\n        // find if we can leverage or not the averageIndex\\n        if (rollingSum[averageIndex] - sum > rollingSum[l -1] - rollingSum[averageIndex]) {\\n            return 0;\\n        }\\n        // else we are good to compute sum\\n        return (averageIndex - midSegmentStart) + 1;\\n    }\\n\\n    private int findLeftMost(int left, int right, int target, int[] rollingSum) {\\n        if (target == 0) {\\n            return left;\\n        }\\n        int pivot;\\n        while (left <= right) {\\n            pivot = left + (right - left) / 2;\\n            if (rollingSum[pivot] >= target) {\\n                right = pivot - 1;\\n            } else {\\n                left = pivot + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private int findRightMost(int left, int right, int target, int[] rollingSum) {\\n        int pivot;\\n        while (left < right) {\\n            pivot = left + (right - left) / 2;\\n            if (rollingSum[pivot] <= target) {\\n                left = pivot + 1;\\n            } else {\\n                right = pivot - 1;\\n            }\\n        }\\n        return rollingSum[left] > target ? left - 1 : left;\\n    }\\n\\n    private int[] getRollingSum(int[] nums) {\\n        int[] rollingSum = new int[nums.length];\\n        int prevSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            rollingSum[i] = prevSum + nums[i];\\n            prevSum = rollingSum[i];\\n        }\\n        return rollingSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int[] rollingSum = getRollingSum(nums);\\n        int ways = 0;\\n        int sum = 0;\\n        int thirdTotal = rollingSum[rollingSum.length - 1];\\n        for (int i = 0; i < nums.length - 2 && sum <= thirdTotal; i++) {\\n            sum += nums[i];\\n            ways = (ways + findWaysToSplit(sum, i+1, rollingSum, rollingSum.length)) % 1_000_000_007;\\n        }\\n        return ways;\\n    }\\n\\n    private int findWaysToSplit(int sum, int from, int[] rollingSum, int l) {\\n        if (sum * 2 > rollingSum[l - 1] - sum) {\\n            return 0;\\n        }\\n        int midSegmentStart = findLeftMost(from, l - 2, sum * 2, rollingSum);\\n        // edge case: [3,2,100,0,0]: midsegment is greater than 3 (2+100) but is also greater than s3 (0,0)\\n        if (rollingSum[midSegmentStart] - sum > rollingSum[l - 1] - rollingSum[midSegmentStart]) {\\n            return 0;\\n        }\\n        int averageIndex = findRightMost(midSegmentStart, l - 2,  sum + (rollingSum[l - 1] - sum) / 2, rollingSum);\\n        // find if we can leverage or not the averageIndex\\n        if (rollingSum[averageIndex] - sum > rollingSum[l -1] - rollingSum[averageIndex]) {\\n            return 0;\\n        }\\n        // else we are good to compute sum\\n        return (averageIndex - midSegmentStart) + 1;\\n    }\\n\\n    private int findLeftMost(int left, int right, int target, int[] rollingSum) {\\n        if (target == 0) {\\n            return left;\\n        }\\n        int pivot;\\n        while (left <= right) {\\n            pivot = left + (right - left) / 2;\\n            if (rollingSum[pivot] >= target) {\\n                right = pivot - 1;\\n            } else {\\n                left = pivot + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private int findRightMost(int left, int right, int target, int[] rollingSum) {\\n        int pivot;\\n        while (left < right) {\\n            pivot = left + (right - left) / 2;\\n            if (rollingSum[pivot] <= target) {\\n                left = pivot + 1;\\n            } else {\\n                right = pivot - 1;\\n            }\\n        }\\n        return rollingSum[left] > target ? left - 1 : left;\\n    }\\n\\n    private int[] getRollingSum(int[] nums) {\\n        int[] rollingSum = new int[nums.length];\\n        int prevSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            rollingSum[i] = prevSum + nums[i];\\n            prevSum = rollingSum[i];\\n        }\\n        return rollingSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676435,
                "title": "c-prefix-sum-binary-search",
                "content": "# Intuition\\nwe use for-loop to divide the array into two non-decreasing parts\\nand then we use binary search to find the range of (middle part) indexes that we can cut at such that it satisfies our condition\\n\\nin the for-loop we iterate from 0 to (n-3)th element such that last two elements are left alone. for every i, we count the number of ways subarray(i+1,n-3) can be cut to get a middle part\\n\\nmx= is the max index at which we can cut\\nmn= is the minimum index at which we can make a cut\\n\\nthus we can make a cut on any index that lies between mn and mx  \\n\\n\\n- Time complexity: O(nlogn)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> psum(n,0);\\n        psum[0]=nums[0];\\n        for(int i=1;i<n;i++) psum[i]=psum[i-1]+nums[i];\\n        int ways=0;\\n        for(int i=0;i<n-2;i++){\\n            int x=psum[i];\\n            int mx=-1, mn=-1;\\n            int l=i+1, r=n-2;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(psum[mid]-x > psum[n-1]-psum[mid]) r=mid-1;\\n                else{\\n                    if(psum[mid]-x >= x) mx=mid;\\n                    l=mid+1;\\n                }\\n            }\\n            l=i+1, r=n-2;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(psum[mid]-x > psum[n-1]-psum[mid]) r=mid-1;\\n                else{\\n                    if(psum[mid]-x >= x){\\n                        mn=mid;\\n                        r=mid-1;\\n                    }else l=mid+1;\\n                }\\n            }\\n            if(mx!=-1 && mn!=-1) ways+=(mx-mn+1);\\n            ways%=mod;\\n        }\\n        return ways;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> psum(n,0);\\n        psum[0]=nums[0];\\n        for(int i=1;i<n;i++) psum[i]=psum[i-1]+nums[i];\\n        int ways=0;\\n        for(int i=0;i<n-2;i++){\\n            int x=psum[i];\\n            int mx=-1, mn=-1;\\n            int l=i+1, r=n-2;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(psum[mid]-x > psum[n-1]-psum[mid]) r=mid-1;\\n                else{\\n                    if(psum[mid]-x >= x) mx=mid;\\n                    l=mid+1;\\n                }\\n            }\\n            l=i+1, r=n-2;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(psum[mid]-x > psum[n-1]-psum[mid]) r=mid-1;\\n                else{\\n                    if(psum[mid]-x >= x){\\n                        mn=mid;\\n                        r=mid-1;\\n                    }else l=mid+1;\\n                }\\n            }\\n            if(mx!=-1 && mn!=-1) ways+=(mx-mn+1);\\n            ways%=mod;\\n        }\\n        return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668136,
                "title": "python3-following-hints",
                "content": "# Code\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        MOD = 1_000_000_007\\n        prefix = []\\n        \\n        curSum = 0\\n        for n in nums:\\n            curSum += n\\n            prefix.append(curSum)\\n\\n        ans = 0\\n        for j in range(N-1, 1, -1):\\n            right_val = prefix[N-1]-prefix[j-1]\\n            if right_val*2 < curSum-right_val: continue\\n\\n            # binary search to find left most i\\n            left_most = float(\\'inf\\')\\n            lo = 1\\n            hi = j-1\\n\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                mid_val = prefix[j-1] - prefix[mid-1]\\n                left_val = prefix[mid-1]\\n\\n                if left_val <= mid_val and mid_val <= right_val:\\n                    left_most = mid\\n                    hi = mid-1\\n                elif mid_val > right_val:\\n                    lo = mid+1\\n                else: # left_val > mid_val:\\n                    hi = mid-1\\n\\n            # binary search to find right most i\\n            right_most = -float(\\'inf\\')\\n            lo = 1\\n            hi = j-1\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                mid_val = prefix[j-1] - prefix[mid-1]\\n                left_val = prefix[mid-1]\\n\\n                if left_val <= mid_val and mid_val <= right_val:\\n                    right_most = mid\\n                    lo = mid+1\\n                elif mid_val > right_val:\\n                    lo = mid+1\\n                else: # left_val > mid_val:\\n                    hi = mid-1\\n \\n            ans = (ans + max(0, right_most - left_most + 1)) % MOD\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        MOD = 1_000_000_007\\n        prefix = []\\n        \\n        curSum = 0\\n        for n in nums:\\n            curSum += n\\n            prefix.append(curSum)\\n\\n        ans = 0\\n        for j in range(N-1, 1, -1):\\n            right_val = prefix[N-1]-prefix[j-1]\\n            if right_val*2 < curSum-right_val: continue\\n\\n            # binary search to find left most i\\n            left_most = float(\\'inf\\')\\n            lo = 1\\n            hi = j-1\\n\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                mid_val = prefix[j-1] - prefix[mid-1]\\n                left_val = prefix[mid-1]\\n\\n                if left_val <= mid_val and mid_val <= right_val:\\n                    left_most = mid\\n                    hi = mid-1\\n                elif mid_val > right_val:\\n                    lo = mid+1\\n                else: # left_val > mid_val:\\n                    hi = mid-1\\n\\n            # binary search to find right most i\\n            right_most = -float(\\'inf\\')\\n            lo = 1\\n            hi = j-1\\n            while lo <= hi:\\n                mid = (lo + hi) // 2\\n                mid_val = prefix[j-1] - prefix[mid-1]\\n                left_val = prefix[mid-1]\\n\\n                if left_val <= mid_val and mid_val <= right_val:\\n                    right_most = mid\\n                    lo = mid+1\\n                elif mid_val > right_val:\\n                    lo = mid+1\\n                else: # left_val > mid_val:\\n                    hi = mid-1\\n \\n            ans = (ans + max(0, right_most - left_most + 1)) % MOD\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633572,
                "title": "1712-ways-to-split-array-into-three-subarrays",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\n/*\\nFirst, we prepare the prefix sum array, so that we can compute subarray sums. Then, we move the boundary of the first subarray left to right. This is the first pointer: i.\\n\\nFor each point i, we find the minimum (j) and maximum (k) boundaries of the second subarray.\\n\\nFinal thing is to realize that j and k will only move forward, which result in a linear-time solution: O(N).\\n*/\\n\\nclass Solution {\\n    let mod = Int(pow(Double(10), Double(9))) + 7\\n    \\n    func waysToSplit(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var result = 0\\n        var prefixSum = Array(repeating: 0, count: n)\\n\\n        prefixSum[0] = nums[0]\\n        for i in 1..<n {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i]\\n        }\\n\\n        // i is the end of left subarray\\n        // j is the min end of mid subarray\\n        // k is the max end of mid subarray\\n        var j = 0\\n        var k = 0\\n        for i in 0..<(n - 2) {\\n            // j must always be greater than i, right subarray should have at least 1 element, so j < n - 1\\n            // while the accumulated in left subarray is bigger than the accumulated in the mid subarray\\n            while j <= i || (j < n - 1 && prefixSum[j] - prefixSum[i] < prefixSum[i]) {\\n                // Inequality is strict lesser because we want the minimum (first) end of the mid subarray\\n                j += 1\\n            }\\n\\n            // k must always be greater equal to j, right subarray should have at least 1 element, so k < n - 1\\n            // while the accumulated in right subarray is bigger or equal than the accumulated in the mid subarray\\n            while k < j || ((k < n - 1) && prefixSum[k] - prefixSum[i] <= prefixSum[n - 1] - prefixSum[k]) {\\n                // Inequality is lesser because we want the maximum (last) end of the mid subarray\\n                k += 1\\n            }\\n\\n            // after the above while loop, \\n            // the condition (k < n - 1 && prefixSum[k] - prefixSum[i] <= prefixSum[n - 1] - prefixSum[k]) is not met\\n            // so we should decrement k by 1\\n            k -= 1\\n            result = (result + k - j + 1) % mod\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/*\\nFirst, we prepare the prefix sum array, so that we can compute subarray sums. Then, we move the boundary of the first subarray left to right. This is the first pointer: i.\\n\\nFor each point i, we find the minimum (j) and maximum (k) boundaries of the second subarray.\\n\\nFinal thing is to realize that j and k will only move forward, which result in a linear-time solution: O(N).\\n*/\\n\\nclass Solution {\\n    let mod = Int(pow(Double(10), Double(9))) + 7\\n    \\n    func waysToSplit(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var result = 0\\n        var prefixSum = Array(repeating: 0, count: n)\\n\\n        prefixSum[0] = nums[0]\\n        for i in 1..<n {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i]\\n        }\\n\\n        // i is the end of left subarray\\n        // j is the min end of mid subarray\\n        // k is the max end of mid subarray\\n        var j = 0\\n        var k = 0\\n        for i in 0..<(n - 2) {\\n            // j must always be greater than i, right subarray should have at least 1 element, so j < n - 1\\n            // while the accumulated in left subarray is bigger than the accumulated in the mid subarray\\n            while j <= i || (j < n - 1 && prefixSum[j] - prefixSum[i] < prefixSum[i]) {\\n                // Inequality is strict lesser because we want the minimum (first) end of the mid subarray\\n                j += 1\\n            }\\n\\n            // k must always be greater equal to j, right subarray should have at least 1 element, so k < n - 1\\n            // while the accumulated in right subarray is bigger or equal than the accumulated in the mid subarray\\n            while k < j || ((k < n - 1) && prefixSum[k] - prefixSum[i] <= prefixSum[n - 1] - prefixSum[k]) {\\n                // Inequality is lesser because we want the maximum (last) end of the mid subarray\\n                k += 1\\n            }\\n\\n            // after the above while loop, \\n            // the condition (k < n - 1 && prefixSum[k] - prefixSum[i] <= prefixSum[n - 1] - prefixSum[k]) is not met\\n            // so we should decrement k by 1\\n            k -= 1\\n            result = (result + k - j + 1) % mod\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600260,
                "title": "very-easy-solution-in-binary-search-c-python",
                "content": "**IN C++**\\n```\\n1. class Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int solve(vector<int> &pre , int tar , bool left){\\n        int i = 0;\\n        int j = pre.size();\\n        while(j > i){\\n            int mid = (i+j)/2;\\n            if(left == true){\\n                if(pre[mid] < tar){\\n                    i = mid + 1;\\n                } \\n                else j = mid;\\n            }\\n            else{\\n                if(pre[mid] <= tar){\\n                    i = mid + 1;\\n                }\\n                else j = mid;\\n            }\\n        }\\n        return j;\\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>pre(n , 0);\\n        pre[0] = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n        long long ans = 0;\\n        for( int i = 0 ; i < n ; i++){\\n            int lower = solve(pre , pre[i] * 2 , true);\\n            int upper = solve(pre ,(pre[i] + pre[n-1])/2 , false);\\n            ans += max(0 , min(upper , n-1) - max(i+1 , lower));\\n        }\\n        return ans %  mod;\\n    }\\n};\\n```\\n**IN PYTHON**\\n```\\n2.class Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        ans = 0\\n        for i in range(1 , len(prefix) - 2):\\n            lower = bisect_left(prefix , prefix[i] * 2)\\n            upper = bisect_right(prefix , (prefix[-1] + prefix[i]) // 2 )\\n            ans += max(0 , min(upper , len(prefix)-1) - max(i + 1 , lower))\\n        return ans % mod\\n```\\n**PLEASE UPVOTE IF YOU NEED HELPFUL**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n1. class Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int solve(vector<int> &pre , int tar , bool left){\\n        int i = 0;\\n        int j = pre.size();\\n        while(j > i){\\n            int mid = (i+j)/2;\\n            if(left == true){\\n                if(pre[mid] < tar){\\n                    i = mid + 1;\\n                } \\n                else j = mid;\\n            }\\n            else{\\n                if(pre[mid] <= tar){\\n                    i = mid + 1;\\n                }\\n                else j = mid;\\n            }\\n        }\\n        return j;\\n    }\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>pre(n , 0);\\n        pre[0] = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n        long long ans = 0;\\n        for( int i = 0 ; i < n ; i++){\\n            int lower = solve(pre , pre[i] * 2 , true);\\n            int upper = solve(pre ,(pre[i] + pre[n-1])/2 , false);\\n            ans += max(0 , min(upper , n-1) - max(i+1 , lower));\\n        }\\n        return ans %  mod;\\n    }\\n};\\n```\n```\\n2.class Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        ans = 0\\n        for i in range(1 , len(prefix) - 2):\\n            lower = bisect_left(prefix , prefix[i] * 2)\\n            upper = bisect_right(prefix , (prefix[-1] + prefix[i]) // 2 )\\n            ans += max(0 , min(upper , len(prefix)-1) - max(i + 1 , lower))\\n        return ans % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598319,
                "title": "c-binary-search-solution-with-explanation",
                "content": "\\n# Code first\\n```\\npublic class Solution {\\n    public int modulo = 1000000007;\\n    public int WaysToSplit(int[] nums) {\\n        int n = nums.Length;\\n        int ans = 0;\\n        // Construct sum array\\n        int[] sum = new int[n];\\n        sum[0]=nums[0];\\n        for (int i=1; i<n; i++) sum[i]=sum[i-1]+nums[i];\\n        // main phase, each pos1 means 1st possible cut\\n        int pos1 = 0;\\n        while (sum[pos1]*2<=sum[n-1] && pos1<n-1){\\n            int way = Way2Phase(sum, pos1);\\n            pos1++;\\n            ans = AddModulo(ans, way);\\n        }\\n        return ans;\\n    }\\n\\n    public int AddModulo(int sum, int add){\\n        return (sum+add)%modulo;\\n    }\\n\\n    public int Way2Phase(int[] sum, int pos1){\\n        // BS for the left 2nd possible cut\\n        int l = pos1+1, r = sum.Length-1;\\n        while (r-l>1){\\n            int mid = (r+l)/2;\\n            if ( sum[mid]-sum[pos1] < sum[pos1] ) l = mid;\\n            else r = mid;\\n        }\\n        if ( sum[l]-sum[pos1] < sum[pos1] ) l = r;\\n        // BS for the right 2nd possible cut    \\n        r = l;\\n        int rr = sum.Length-1;\\n        while (rr-r>1){\\n            int mid = (rr+r)/2;\\n            if ( sum[mid]-sum[pos1] <= sum[sum.Length-1]-sum[mid] ) r = mid;\\n            else rr = mid;\\n        }\\n        if ( sum[r]-sum[pos1] <= sum[sum.Length-1]-sum[r] ) r = rr;\\n        // The answer is difference between cut positions\\n        return r-l;\\n    }\\n}\\n```\\n\\n# Intuition\\nI am not sure the solution is intuitive. Follow approach section and ask me questions if it is not clear.\\n\\n# Approach\\n1. We will traverse all the aray from left to the right with 1st cut position.\\n2. For each 1st cut position we hafe to find possible \\'left\\' second cut position and \\'right\\' second cut position.\\n3. To do so we will use binary search.\\n4. To use BS we need to constract a sum array, keeping track on every sum accumulated for every index.\\n5. Difference between \\'left\\' and \\'right\\' positions for second cut is an addition for the task answer for current first cut position.\\n6. We will update the sum in modulo while traversing the array. I use a seperate function for it for convenience/readability only.\\n\\n# Complexity\\n- Time complexity: O( n*log(n) )\\n\\n- Space complexity: O(n)",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int modulo = 1000000007;\\n    public int WaysToSplit(int[] nums) {\\n        int n = nums.Length;\\n        int ans = 0;\\n        // Construct sum array\\n        int[] sum = new int[n];\\n        sum[0]=nums[0];\\n        for (int i=1; i<n; i++) sum[i]=sum[i-1]+nums[i];\\n        // main phase, each pos1 means 1st possible cut\\n        int pos1 = 0;\\n        while (sum[pos1]*2<=sum[n-1] && pos1<n-1){\\n            int way = Way2Phase(sum, pos1);\\n            pos1++;\\n            ans = AddModulo(ans, way);\\n        }\\n        return ans;\\n    }\\n\\n    public int AddModulo(int sum, int add){\\n        return (sum+add)%modulo;\\n    }\\n\\n    public int Way2Phase(int[] sum, int pos1){\\n        // BS for the left 2nd possible cut\\n        int l = pos1+1, r = sum.Length-1;\\n        while (r-l>1){\\n            int mid = (r+l)/2;\\n            if ( sum[mid]-sum[pos1] < sum[pos1] ) l = mid;\\n            else r = mid;\\n        }\\n        if ( sum[l]-sum[pos1] < sum[pos1] ) l = r;\\n        // BS for the right 2nd possible cut    \\n        r = l;\\n        int rr = sum.Length-1;\\n        while (rr-r>1){\\n            int mid = (rr+r)/2;\\n            if ( sum[mid]-sum[pos1] <= sum[sum.Length-1]-sum[mid] ) r = mid;\\n            else rr = mid;\\n        }\\n        if ( sum[r]-sum[pos1] <= sum[sum.Length-1]-sum[r] ) r = rr;\\n        // The answer is difference between cut positions\\n        return r-l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559479,
                "title": "252ms-binary-search-and-prefix-sum-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    int waysToSplit(vector<int>& a) {\\n      int n=a.size(),mod=1e9+7,ans=0;\\n        vector<int>pre(n);\\n        pre[0]=a[0];\\n        for(int i=1;i<n;i++) pre[i]=pre[i-1]+a[i];\\n         \\n         int sum;\\n         sum=pre[n-1]/3;\\n         \\n         int ind=0;\\n         ind=upper_bound(pre.begin(),pre.end(),sum)-pre.begin();\\n         ind--;\\n         ind=min(n-3,ind);\\n        int low=0,mid;\\n        cout<<ind<<\" \\\\n\";\\n        while(low<=ind)\\n        {\\n          sum=pre[n-1]-pre[low];\\n          sum/=2;\\n          sum+=pre[low];\\n         int mma=upper_bound(pre.begin(),pre.end(),sum)-pre.begin();\\n          mma--;\\n        mma=min(n-2,mma);\\n       int mmi=lower_bound(pre.begin(),pre.end(),2*pre[low])-pre.begin();\\n         mmi=max(low+1,mmi);\\n         if(mma>=mmi)\\n        //  if(mmi<=low) mmi=low+1;\\n       \\n        //  if(mma<=low) mma=low+1;\\n        // cout<<mma<<\" \"<<mmi<<\" \\\\n\";\\n         ans=ans%mod+(mma-mmi+1)%mod;\\n          low++;\\n        }\\n        return ans%mod<0?0:ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int waysToSplit(vector<int>& a) {\\n      int n=a.size(),mod=1e9+7,ans=0;\\n        vector<int>pre(n);\\n        pre[0]=a[0];\\n        for(int i=1;i<n;i++) pre[i]=pre[i-1]+a[i];\\n         \\n         int sum;\\n         sum=pre[n-1]/3;\\n         \\n         int ind=0;\\n         ind=upper_bound(pre.begin(),pre.end(),sum)-pre.begin();\\n         ind--;\\n         ind=min(n-3,ind);\\n        int low=0,mid;\\n        cout<<ind<<\" \\\\n\";\\n        while(low<=ind)\\n        {\\n          sum=pre[n-1]-pre[low];\\n          sum/=2;\\n          sum+=pre[low];\\n         int mma=upper_bound(pre.begin(),pre.end(),sum)-pre.begin();\\n          mma--;\\n        mma=min(n-2,mma);\\n       int mmi=lower_bound(pre.begin(),pre.end(),2*pre[low])-pre.begin();\\n         mmi=max(low+1,mmi);\\n         if(mma>=mmi)\\n        //  if(mmi<=low) mmi=low+1;\\n       \\n        //  if(mma<=low) mma=low+1;\\n        // cout<<mma<<\" \"<<mmi<<\" \\\\n\";\\n         ans=ans%mod+(mma-mmi+1)%mod;\\n          low++;\\n        }\\n        return ans%mod<0?0:ans%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3439188,
                "title": "easy-to-redo-binary-search",
                "content": "Convert `nums` into prefix sum. Then for the `num[last position]` of the first, second and third subarray we have the relationship:\\n\\n$$second - first \\\\ge first$$\\nand\\n$$third - second \\\\ge second - first$$\\n\\nSo \\n$$2first \\\\le second \\\\le \\\\frac{first+third}{2}$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(1, n): \\n            nums[i] += nums[i-1]\\n\\n        res = 0\\n        for i in range(n):\\n            lo = bisect_left(nums, 2*nums[i])\\n            hi = bisect_right(nums, (nums[i] + nums[-1]) / 2)\\n            if hi >= n: hi = n-1\\n            if lo <= i: lo = i+1\\n            if lo < hi: res += hi - lo\\n        return res % 1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(1, n): \\n            nums[i] += nums[i-1]\\n\\n        res = 0\\n        for i in range(n):\\n            lo = bisect_left(nums, 2*nums[i])\\n            hi = bisect_right(nums, (nums[i] + nums[-1]) / 2)\\n            if hi >= n: hi = n-1\\n            if lo <= i: lo = i+1\\n            if lo < hi: res += hi - lo\\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427363,
                "title": "java-easy-solution-with-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to find the maximum number of ways to split an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum and Binary Search.\\n\\n# Full explanation in the code\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int total = 0, n = nums.length;\\n        for (int num: nums)\\n            total+=num;\\n        \\n        // If there are less than three numbers, there is no way to split the array.\\n        if(n <= 2)\\n            return 0;\\n        \\n        int modulo = (int)1e9+7;\\n        int ways = 0;\\n        int leftSum = 0, mid = nums[0], rightSum = nums[0]+nums[1];\\n        int i=0, j=1, k=2;\\n        while(i<n){\\n            // Increment left sum and move i pointer.(that make leftSum)\\n            leftSum += nums[i++];\\n\\n            // Move j pointer until mid sum is less than or equal to twice left sum.\\n            //meaning make midSum untill sufficient amount is reached >leftSum*2\\n            //leftSum*2 bcz we are not seprating sums by index we are geeting continous sum\\n            while(j<n && (mid < (leftSum<<1) || j == i))\\n                mid += nums[j++];\\n            \\n            // If j reaches the end or mid sum is greater than twice the remaining sum, break out of the loop.\\n            if(j == n || 3*mid > 2*total)\\n                break;\\n            \\n            // Move k pointer until rightSum is less than or equal to the remaining sum.\\n            //now make rightSum from remainig eles\\n            while(k<n && total-rightSum >= rightSum-leftSum){\\n                rightSum += nums[k++];\\n            }\\n\\n            // Add the number of valid splits to the total number of ways.\\n            ways += k-j;\\n            ways %= modulo;\\n        }\\n\\n        return ways;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int total = 0, n = nums.length;\\n        for (int num: nums)\\n            total+=num;\\n        \\n        // If there are less than three numbers, there is no way to split the array.\\n        if(n <= 2)\\n            return 0;\\n        \\n        int modulo = (int)1e9+7;\\n        int ways = 0;\\n        int leftSum = 0, mid = nums[0], rightSum = nums[0]+nums[1];\\n        int i=0, j=1, k=2;\\n        while(i<n){\\n            // Increment left sum and move i pointer.(that make leftSum)\\n            leftSum += nums[i++];\\n\\n            // Move j pointer until mid sum is less than or equal to twice left sum.\\n            //meaning make midSum untill sufficient amount is reached >leftSum*2\\n            //leftSum*2 bcz we are not seprating sums by index we are geeting continous sum\\n            while(j<n && (mid < (leftSum<<1) || j == i))\\n                mid += nums[j++];\\n            \\n            // If j reaches the end or mid sum is greater than twice the remaining sum, break out of the loop.\\n            if(j == n || 3*mid > 2*total)\\n                break;\\n            \\n            // Move k pointer until rightSum is less than or equal to the remaining sum.\\n            //now make rightSum from remainig eles\\n            while(k<n && total-rightSum >= rightSum-leftSum){\\n                rightSum += nums[k++];\\n            }\\n\\n            // Add the number of valid splits to the total number of ways.\\n            ways += k-j;\\n            ways %= modulo;\\n        }\\n\\n        return ways;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404080,
                "title": "swift-prefix-sum-and-two-pointer",
                "content": "# Code\\n```\\nclass Solution {\\n    func waysToSplit(_ nums: [Int]) -> Int {\\n        var s: [Int] = [0]\\n        var ss = 0\\n        for n in nums {\\n            ss += n\\n            s.append(ss)\\n        }\\n        //print(s,ss, s.count)\\n        var ret = 0\\n        var js = 2\\n        var je = 2\\n        for i in 1..<(nums.count-1) {\\n            if ss >= s[i]*3 {\\n                if js <= i { js = i+1 }\\n                while js < s.count-1 && s[js] < s[i]*2 {\\n                    js += 1\\n                }\\n                while je < s.count-1 && ss-s[je] >= s[je]-s[i] {\\n                    je += 1\\n                } \\n                ret += je-js\\n                ret %= 1000000007\\n            }\\n        }\\n        return ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func waysToSplit(_ nums: [Int]) -> Int {\\n        var s: [Int] = [0]\\n        var ss = 0\\n        for n in nums {\\n            ss += n\\n            s.append(ss)\\n        }\\n        //print(s,ss, s.count)\\n        var ret = 0\\n        var js = 2\\n        var je = 2\\n        for i in 1..<(nums.count-1) {\\n            if ss >= s[i]*3 {\\n                if js <= i { js = i+1 }\\n                while js < s.count-1 && s[js] < s[i]*2 {\\n                    js += 1\\n                }\\n                while je < s.count-1 && ss-s[je] >= s[je]-s[i] {\\n                    je += 1\\n                } \\n                ret += je-js\\n                ret %= 1000000007\\n            }\\n        }\\n        return ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403420,
                "title": "simple-solution-with-recurrsion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n\\n  int count = 0;\\n  public int waysToSplit(int[] nums) {\\n    int[] prefix = new int[nums.length];\\n    prefix[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n      prefix[i] += prefix[i - 1] + nums[i];\\n    }\\n    // num=.   1,2,2,2,5,0\\n    // prefix= 1,3,5,7,12,12\\n    split(nums, prefix, 0, 0, 0);\\n    return count;\\n  }\\n\\n  public void split(int[] nums, int[] prefix, int previousSplitStartIndex, int previousSplitLastIndex, int splitIndex) {\\n\\n    int previousSplitSum = 0;\\n    if (splitIndex!=0) {\\n      previousSplitSum = sum(prefix, previousSplitStartIndex, previousSplitLastIndex-1);\\n    }\\n\\n    if(splitIndex==2) {\\n      if(previousSplitSum <= sum(prefix, previousSplitLastIndex, nums.length-1)) {\\n        count++;\\n      }\\n      return;\\n    }\\n\\n    for (int i = previousSplitLastIndex; i < nums.length; i++) {\\n      if (previousSplitSum <= sum(prefix, previousSplitLastIndex, i)) {\\n        split(nums, prefix, previousSplitLastIndex, i+1, splitIndex+1);\\n      }\\n    }\\n\\n  }\\n\\n  int sum(int[] prefix, int start, int end) {\\n    return prefix[end] - (start>0 ?  prefix[start-1] : 0);   \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  int count = 0;\\n  public int waysToSplit(int[] nums) {\\n    int[] prefix = new int[nums.length];\\n    prefix[0] = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n      prefix[i] += prefix[i - 1] + nums[i];\\n    }\\n    // num=.   1,2,2,2,5,0\\n    // prefix= 1,3,5,7,12,12\\n    split(nums, prefix, 0, 0, 0);\\n    return count;\\n  }\\n\\n  public void split(int[] nums, int[] prefix, int previousSplitStartIndex, int previousSplitLastIndex, int splitIndex) {\\n\\n    int previousSplitSum = 0;\\n    if (splitIndex!=0) {\\n      previousSplitSum = sum(prefix, previousSplitStartIndex, previousSplitLastIndex-1);\\n    }\\n\\n    if(splitIndex==2) {\\n      if(previousSplitSum <= sum(prefix, previousSplitLastIndex, nums.length-1)) {\\n        count++;\\n      }\\n      return;\\n    }\\n\\n    for (int i = previousSplitLastIndex; i < nums.length; i++) {\\n      if (previousSplitSum <= sum(prefix, previousSplitLastIndex, i)) {\\n        split(nums, prefix, previousSplitLastIndex, i+1, splitIndex+1);\\n      }\\n    }\\n\\n  }\\n\\n  int sum(int[] prefix, int start, int end) {\\n    return prefix[end] - (start>0 ?  prefix[start-1] : 0);   \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401234,
                "title": "very-simple-python-bisect-solution-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        sum_nums = list(itertools.accumulate(nums))\\n        length = len(nums)\\n        index = bisect_right(sum_nums, sum_nums[-1]/3, lo = 0, hi = length - 2)\\n        ans = 0\\n        for i in range(index):\\n            medium = (sum_nums[-1] + sum_nums[i]) >> 1\\n            left_index = bisect_left(sum_nums, 2 * sum_nums[i], lo = i + 1, hi = length - 1)\\n            right_index = bisect_right(sum_nums, medium, lo = i + 1, hi = length - 1)\\n            ans = (ans + right_index - left_index) % 1000000007\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        sum_nums = list(itertools.accumulate(nums))\\n        length = len(nums)\\n        index = bisect_right(sum_nums, sum_nums[-1]/3, lo = 0, hi = length - 2)\\n        ans = 0\\n        for i in range(index):\\n            medium = (sum_nums[-1] + sum_nums[i]) >> 1\\n            left_index = bisect_left(sum_nums, 2 * sum_nums[i], lo = i + 1, hi = length - 1)\\n            right_index = bisect_right(sum_nums, medium, lo = i + 1, hi = length - 1)\\n            ans = (ans + right_index - left_index) % 1000000007\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398712,
                "title": "simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++) {\\n            pre[i] = nums[i]+pre[i-1];\\n        }\\n        int ans = 0;\\n        int mid,max_mid;\\n        for(int i=0;i<n-2;i++) {\\n            mid = lower_bound(pre.begin()+i+1,pre.end(),2*pre[i])-pre.begin();\\n            int rem = pre[n-1]-pre[i];\\n            max_mid = upper_bound(pre.begin()+i+1,pre.begin()+n-1,pre[i]+rem/2)-pre.begin();\\n            ans+=max(0,max_mid-mid);\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n);\\n        pre[0] = nums[0];\\n        for(int i=1;i<n;i++) {\\n            pre[i] = nums[i]+pre[i-1];\\n        }\\n        int ans = 0;\\n        int mid,max_mid;\\n        for(int i=0;i<n-2;i++) {\\n            mid = lower_bound(pre.begin()+i+1,pre.end(),2*pre[i])-pre.begin();\\n            int rem = pre[n-1]-pre[i];\\n            max_mid = upper_bound(pre.begin()+i+1,pre.begin()+n-1,pre[i]+rem/2)-pre.begin();\\n            ans+=max(0,max_mid-mid);\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395214,
                "title": "rather-simple-solution-which-doesn-t-rely-on-mathematics",
                "content": "# Intuition\\nThe base inituition is based on other solutions, however they all made some mathematical assumptions which I think are personally too hard for me to think during the interview.\\n\\nThe intuition is simple expand middle array as long as possible to calculate all combinations\\n\\n# Approach\\n\\nEach iteration gives us the end index of left array i.e. 0..1\\n\\nThen we need to calculate bounds of middle array j...k\\n\\nTo calculate j we need to calculate sub array after i where sum of array i..j is equal to or greater than 0..i which is `find_j`\\n\\nThen we calculate start of right array such that if sum of right array is greater or equal to j..k-1. If we found such array we try to short the array through binary search which is `find_k`\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef ways_to_split(nums)\\n    ans = 0\\n    prefix_arr = [nums[0]]\\n    \\n    for i in (1...nums.size) do\\n        prefix_arr[i] = nums[i] + prefix_arr[i-1]\\n    end\\n    #puts prefix_arr.inspect\\n\\n    for i in (0...nums.size) do\\n        j = find_j(prefix_arr, i)\\n        k = find_k(prefix_arr, i, j)\\n        #puts \"j: #{j}, k: #{k}\"\\n        ans += k - j if k > -1 && j > -1\\n    end\\n\\n  \\n    ans % 1_000_000_007\\nend\\ndef find_j(prefix_arr, i)\\n    x = i + 1\\n    y = prefix_arr.size - 1\\n    ans = -1\\n    while x <= y  do\\n        mid = (x + y) / 2\\n        left_sum = prefix_arr[i]\\n        right_sum = prefix_arr[mid] - left_sum\\n        #puts \"mid: #{mid}, right_sum: #{right_sum}, left_sum: #{left_sum}\"\\n        if right_sum >= left_sum\\n            y = mid - 1\\n            ans = mid\\n        else\\n            x = mid + 1\\n        end\\n    end\\n    ans\\nend\\n\\ndef find_k(prefix_arr, i, j)\\n    x = j + 1\\n    y = prefix_arr.size - 1\\n    ans = -1\\n    while x <= y  do\\n        mid = (x + y) / 2\\n        left_sum = prefix_arr[mid-1] - prefix_arr[i]\\n        right_sum = prefix_arr[prefix_arr.size-1] - prefix_arr[mid-1]\\n        #puts \"mid: #{mid}, right_sum: #{right_sum}, left_sum: #{left_sum}\"\\n        if right_sum >= left_sum\\n            x = mid + 1\\n            ans = mid\\n        else\\n           y = mid - 1\\n        end\\n    end\\n    ans\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef ways_to_split(nums)\\n    ans = 0\\n    prefix_arr = [nums[0]]\\n    \\n    for i in (1...nums.size) do\\n        prefix_arr[i] = nums[i] + prefix_arr[i-1]\\n    end\\n    #puts prefix_arr.inspect\\n\\n    for i in (0...nums.size) do\\n        j = find_j(prefix_arr, i)\\n        k = find_k(prefix_arr, i, j)\\n        #puts \"j: #{j}, k: #{k}\"\\n        ans += k - j if k > -1 && j > -1\\n    end\\n\\n  \\n    ans % 1_000_000_007\\nend\\ndef find_j(prefix_arr, i)\\n    x = i + 1\\n    y = prefix_arr.size - 1\\n    ans = -1\\n    while x <= y  do\\n        mid = (x + y) / 2\\n        left_sum = prefix_arr[i]\\n        right_sum = prefix_arr[mid] - left_sum\\n        #puts \"mid: #{mid}, right_sum: #{right_sum}, left_sum: #{left_sum}\"\\n        if right_sum >= left_sum\\n            y = mid - 1\\n            ans = mid\\n        else\\n            x = mid + 1\\n        end\\n    end\\n    ans\\nend\\n\\ndef find_k(prefix_arr, i, j)\\n    x = j + 1\\n    y = prefix_arr.size - 1\\n    ans = -1\\n    while x <= y  do\\n        mid = (x + y) / 2\\n        left_sum = prefix_arr[mid-1] - prefix_arr[i]\\n        right_sum = prefix_arr[prefix_arr.size-1] - prefix_arr[mid-1]\\n        #puts \"mid: #{mid}, right_sum: #{right_sum}, left_sum: #{left_sum}\"\\n        if right_sum >= left_sum\\n            x = mid + 1\\n            ans = mid\\n        else\\n           y = mid - 1\\n        end\\n    end\\n    ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3391049,
                "title": "c-concise-o-nlogn-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        int mod = 1e9 + 7;\\n        vector<int> prefixSum(n, 0);\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        int result = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            int leftSum = prefixSum[i];\\n            int remaining = prefixSum[n - 1] - leftSum;\\n            int maxMidSum = remaining / 2;\\n            int midStart = lower_bound(prefixSum.begin() + i + 1, prefixSum.begin() + n - 1, prefixSum[i] + leftSum) - prefixSum.begin();\\n            int midEnd = upper_bound(prefixSum.begin() + i + 1, prefixSum.begin() + n - 1, prefixSum[i] + maxMidSum) - prefixSum.begin();\\n            result = (result + max(0, midEnd - midStart) % mod) % mod;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        int mod = 1e9 + 7;\\n        vector<int> prefixSum(n, 0);\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\\n        }\\n        int result = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            int leftSum = prefixSum[i];\\n            int remaining = prefixSum[n - 1] - leftSum;\\n            int maxMidSum = remaining / 2;\\n            int midStart = lower_bound(prefixSum.begin() + i + 1, prefixSum.begin() + n - 1, prefixSum[i] + leftSum) - prefixSum.begin();\\n            int midEnd = upper_bound(prefixSum.begin() + i + 1, prefixSum.begin() + n - 1, prefixSum[i] + maxMidSum) - prefixSum.begin();\\n            result = (result + max(0, midEnd - midStart) % mod) % mod;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382043,
                "title": "hard-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=(int)1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>prefix(nums.size(),0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n              prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            //first group is till ith index so prefix[i]\\n            int left=i+1,right=n-2;\\n            int ans1=-1,ans2=-1;\\n            while(right>=left){\\n                int mid=(right-left)/2+left;\\n                if(prefix[mid]>=2*prefix[i]){\\n                    ans1=mid;\\n                    right=mid-1;\\n                }\\n                else{\\n                    left=mid+1;\\n                }\\n            }\\n            left=i+1,right=n-2;\\n            while(right>=left){\\n                int mid=(right-left)/2+left;\\n                if(prefix[n-1]-prefix[mid]>=prefix[mid]-prefix[i]){\\n                    ans2=mid;\\n                    left=mid+1;\\n                }\\n                else{\\n                    right=mid-1;\\n                }\\n            }\\n            if(ans1>ans2 || ans1==-1 || ans2==-1){\\n                continue;\\n            }\\n           // else{\\n                ans=(ans%mod+(ans2-ans1+1)%mod)%mod;\\n            \\n           \\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=(int)1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>prefix(nums.size(),0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n              prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            //first group is till ith index so prefix[i]\\n            int left=i+1,right=n-2;\\n            int ans1=-1,ans2=-1;\\n            while(right>=left){\\n                int mid=(right-left)/2+left;\\n                if(prefix[mid]>=2*prefix[i]){\\n                    ans1=mid;\\n                    right=mid-1;\\n                }\\n                else{\\n                    left=mid+1;\\n                }\\n            }\\n            left=i+1,right=n-2;\\n            while(right>=left){\\n                int mid=(right-left)/2+left;\\n                if(prefix[n-1]-prefix[mid]>=prefix[mid]-prefix[i]){\\n                    ans2=mid;\\n                    left=mid+1;\\n                }\\n                else{\\n                    right=mid-1;\\n                }\\n            }\\n            if(ans1>ans2 || ans1==-1 || ans2==-1){\\n                continue;\\n            }\\n           // else{\\n                ans=(ans%mod+(ans2-ans1+1)%mod)%mod;\\n            \\n           \\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364038,
                "title": "c-binary-search-prefix-sum-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i =1;i<n;i++)\\n        nums[i] += nums[i-1];\\n\\n        int left =0;\\n        int mid =1;\\n        int right =0;\\n        int count =0;\\n\\n        while(left<n-2){\\n            mid = max(mid,left+1);\\n\\n        while(mid<n-1 && nums[mid]<2*nums[left])\\n            mid++;\\n\\n        right = max(mid,right);\\n\\n        while(right<n-1 && nums[right]-nums[left]<=nums[n-1]-nums[right])\\n         right++;\\n\\n        count = (count+right-mid)%1000000007;\\n\\n        left++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i =1;i<n;i++)\\n        nums[i] += nums[i-1];\\n\\n        int left =0;\\n        int mid =1;\\n        int right =0;\\n        int count =0;\\n\\n        while(left<n-2){\\n            mid = max(mid,left+1);\\n\\n        while(mid<n-1 && nums[mid]<2*nums[left])\\n            mid++;\\n\\n        right = max(mid,right);\\n\\n        while(right<n-1 && nums[right]-nums[left]<=nums[n-1]-nums[right])\\n         right++;\\n\\n        count = (count+right-mid)%1000000007;\\n\\n        left++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352596,
                "title": "258-ms",
                "content": "```ruby\\ndef ways_to_split a\\n    r = s = i = j = k = 0\\n    zm2 = (z = a.size) - 2\\n    a.map! { s += _1 }\\n    while i < zm2\\n        l = a[i]\\n        j = i + 1 if j <= i\\n        i += 1\\n        j += 1 while j < z && l > a[j] - l\\n        break if j > zm2\\n        next if a[j] - l > s - a[j]\\n        k = j if k < j\\n        k += 1 while k < zm2 && a[k + 1] - l <= s - a[k + 1]\\n        r += k - j + 1\\n    end\\n    r % 1_000_000_007\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef ways_to_split a\\n    r = s = i = j = k = 0\\n    zm2 = (z = a.size) - 2\\n    a.map! { s += _1 }\\n    while i < zm2\\n        l = a[i]\\n        j = i + 1 if j <= i\\n        i += 1\\n        j += 1 while j < z && l > a[j] - l\\n        break if j > zm2\\n        next if a[j] - l > s - a[j]\\n        k = j if k < j\\n        k += 1 while k < zm2 && a[k + 1] - l <= s - a[k + 1]\\n        r += k - j + 1\\n    end\\n    r % 1_000_000_007\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3332932,
                "title": "easiest-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = (int) (1e9 + 7);\\n    public int waysToSplit(int[] nums) {\\n        if (nums == null || nums.length < 3 ) {\\n            return 0;\\n        }\\n        int n = nums.length;\\n        int[] prefixSum = new int[n];\\n        int curSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            curSum += nums[i];\\n            prefixSum[i] = curSum;\\n        }\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int part1 = prefixSum[i];\\n            int left = i + 1;\\n            int right = n - 2;\\n\\n            int cut1 = -1;\\n            int cut2 = -1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                if (part2 >= part1) {  \\n                // cut1 should be as left as possible\\n                    cut1 = mid;\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            left = i + 1;\\n            right = n - 2;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                int part3 = prefixSum[n - 1] - prefixSum[mid];\\n                if (part3 >= part2) {\\n                // cut2 should be as right as possible\\n                    cut2 = mid;\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } \\n\\n            if (cut1 == -1 || cut2 == -1 || cut1 > cut2) {\\n                continue;\\n            }\\n            int curcnt = cut2 - cut1 + 1;\\n            res += curcnt;\\n            res %= MOD;\\n\\n        } \\n        return (int) res;\\n\\n    }\\n}\\n        \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = (int) (1e9 + 7);\\n    public int waysToSplit(int[] nums) {\\n        if (nums == null || nums.length < 3 ) {\\n            return 0;\\n        }\\n        int n = nums.length;\\n        int[] prefixSum = new int[n];\\n        int curSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            curSum += nums[i];\\n            prefixSum[i] = curSum;\\n        }\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int part1 = prefixSum[i];\\n            int left = i + 1;\\n            int right = n - 2;\\n\\n            int cut1 = -1;\\n            int cut2 = -1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                if (part2 >= part1) {  \\n                // cut1 should be as left as possible\\n                    cut1 = mid;\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            left = i + 1;\\n            right = n - 2;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                int part2 = prefixSum[mid] - part1;\\n                int part3 = prefixSum[n - 1] - prefixSum[mid];\\n                if (part3 >= part2) {\\n                // cut2 should be as right as possible\\n                    cut2 = mid;\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } \\n\\n            if (cut1 == -1 || cut2 == -1 || cut1 > cut2) {\\n                continue;\\n            }\\n            int curcnt = cut2 - cut1 + 1;\\n            res += curcnt;\\n            res %= MOD;\\n\\n        } \\n        return (int) res;\\n\\n    }\\n}\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331896,
                "title": "c-solution-using-binary-search-and-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size(), ans = 0, mod = 1e9+7;\\n        for(auto i=1;i<n;i++){\\n            nums[i] += nums[i-1];\\n        }\\n        for(auto i=0;i<n;i++){\\n            int low = lower_bound(nums.begin()+i+1,nums.end(),(2*nums[i])) - nums.begin();\\n            int high = upper_bound(nums.begin()+i+1,nums.end()-1,nums[i]+(nums[n-1]-nums[i])/2) - nums.begin();\\n            ans = (ans+max(0,high-low)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size(), ans = 0, mod = 1e9+7;\\n        for(auto i=1;i<n;i++){\\n            nums[i] += nums[i-1];\\n        }\\n        for(auto i=0;i<n;i++){\\n            int low = lower_bound(nums.begin()+i+1,nums.end(),(2*nums[i])) - nums.begin();\\n            int high = upper_bound(nums.begin()+i+1,nums.end()-1,nums[i]+(nums[n-1]-nums[i])/2) - nums.begin();\\n            ans = (ans+max(0,high-low)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331627,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def waysToSplit(nums: Array[Int]): Int = {\\n        val len = nums.length\\n      val prefix = Array.ofDim[Int](len+1)\\n      for(i<- 0 until len) prefix(i+1) = prefix(i) + nums(i)\\n      var res:Long = 0\\n      var i1 = len-2\\n      var i2 = len-2\\n      for (j<-len-1 to 2 by -1) {\\n        val right = prefix(len)-prefix(j)\\n        while (i1 > 0 && prefix(j)-prefix(i1) <=right) i1-=1\\n        i2 = math.min(i2,j-1)\\n        while (i2>0 && prefix(i2)>prefix(j)-prefix(i2)) i2 -= 1\\n        if (i2 > i1 && i1 >=0) res += (i2-i1)\\n      }\\n      (res%1_000_000_007).toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def waysToSplit(nums: Array[Int]): Int = {\\n        val len = nums.length\\n      val prefix = Array.ofDim[Int](len+1)\\n      for(i<- 0 until len) prefix(i+1) = prefix(i) + nums(i)\\n      var res:Long = 0\\n      var i1 = len-2\\n      var i2 = len-2\\n      for (j<-len-1 to 2 by -1) {\\n        val right = prefix(len)-prefix(j)\\n        while (i1 > 0 && prefix(j)-prefix(i1) <=right) i1-=1\\n        i2 = math.min(i2,j-1)\\n        while (i2>0 && prefix(i2)>prefix(j)-prefix(i2)) i2 -= 1\\n        if (i2 > i1 && i1 >=0) res += (i2-i1)\\n      }\\n      (res%1_000_000_007).toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3272011,
                "title": "python-step-by-step-prefix-sum-two-pointers-binary-search-solution",
                "content": "# Intuition\\n1. Create Prefix Sum Array\\n2. Start iterating over nums\\n3. Check whether the *i-th* element is a valid first split pointer\\n4. Find if there exist valid second split pointers for the first one from step 3\\n\\n# Approach\\nPrefix Sum + Two Pointers + Binary Search\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n\\n        result = 0\\n\\n        # Create prefix sum array \\n        prefix_sum = [nums[0]]\\n        for i in range(1, len(nums)):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n        total = prefix_sum[-1]\\n\\n        # For every potential first pointer get acceptable middle pointers\\n        for first_pointer in range(len(prefix_sum) - 1):\\n\\n            if prefix_sum[first_pointer] > total - prefix_sum[first_pointer]:\\n                # we cannot create a good split\\n                continue\\n            min_second_pointer = self._find_min_max_second_pointer(\\n                first_pointer,\\n                prefix_sum,\\n                mode=\"min\"\\n            )\\n            max_second_pointer = self._find_min_max_second_pointer(\\n                first_pointer,\\n                prefix_sum,\\n                mode=\"max\"\\n            )\\n\\n            if min_second_pointer is None or max_second_pointer is None:\\n                continue\\n            result += max_second_pointer - min_second_pointer + 1\\n                    \\n        return result  % 1_000_000_007\\n\\n    def _find_min_max_second_pointer(self, first_pointer, prefix_sum, mode):\\n\\n        second_pointer = None\\n        left_summ = prefix_sum[first_pointer] # constant because we already have first pointer\\n\\n        left, right = first_pointer, len(prefix_sum) - 1\\n        switch_id = -1 if mode == \"min\" else 1\\n        # Stoping criteria: if left_summ <= mid_summ <= right_summ and id + swith_id make this equation False\\n\\n        while left < right:\\n            mid_id = left + (right-left) // 2\\n            right_summ = prefix_sum[-1] - prefix_sum[mid_id]\\n            mid_summ = prefix_sum[-1] - (left_summ + right_summ)\\n\\n            if mid_summ < left_summ:\\n                left = mid_id + 1\\n                continue\\n\\n            elif mid_summ > right_summ:\\n                right = mid_id\\n                continue\\n\\n            else: # (left_summ <= mid_summ <= right_summ): we found valid second pointer \\n                #  check whether it is the minum / maximum valid or just \\n                #  a valid one\\n                new_id = mid_id + switch_id\\n                new_right = prefix_sum[-1] - prefix_sum[new_id]\\n                new_mid = prefix_sum[-1] - (left_summ + new_right)\\n                if (new_id == first_pointer) or (new_id == len(prefix_sum) - 1):\\n                    # current mid_id is the closest to first_pointer or to the end of nums\\n                    return mid_id\\n                if mode == \"min\":\\n                    if left_summ > new_mid: # new_id is not a valid second pointer\\n                        return mid_id\\n                    right = mid_id # new_id is a valid second pointer; continue searching\\n\\n                else: # mode == \"max\"\\n                    if new_mid > new_right: # new_id is not a valid second pointer\\n                        return mid_id\\n                    left = mid_id + 1 # new_id is a valid second pointer; continue searching\\n\\n        return second_pointer\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```python []\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n\\n        result = 0\\n\\n        # Create prefix sum array \\n        prefix_sum = [nums[0]]\\n        for i in range(1, len(nums)):\\n            prefix_sum.append(prefix_sum[-1] + nums[i])\\n        total = prefix_sum[-1]\\n\\n        # For every potential first pointer get acceptable middle pointers\\n        for first_pointer in range(len(prefix_sum) - 1):\\n\\n            if prefix_sum[first_pointer] > total - prefix_sum[first_pointer]:\\n                # we cannot create a good split\\n                continue\\n            min_second_pointer = self._find_min_max_second_pointer(\\n                first_pointer,\\n                prefix_sum,\\n                mode=\"min\"\\n            )\\n            max_second_pointer = self._find_min_max_second_pointer(\\n                first_pointer,\\n                prefix_sum,\\n                mode=\"max\"\\n            )\\n\\n            if min_second_pointer is None or max_second_pointer is None:\\n                continue\\n            result += max_second_pointer - min_second_pointer + 1\\n                    \\n        return result  % 1_000_000_007\\n\\n    def _find_min_max_second_pointer(self, first_pointer, prefix_sum, mode):\\n\\n        second_pointer = None\\n        left_summ = prefix_sum[first_pointer] # constant because we already have first pointer\\n\\n        left, right = first_pointer, len(prefix_sum) - 1\\n        switch_id = -1 if mode == \"min\" else 1\\n        # Stoping criteria: if left_summ <= mid_summ <= right_summ and id + swith_id make this equation False\\n\\n        while left < right:\\n            mid_id = left + (right-left) // 2\\n            right_summ = prefix_sum[-1] - prefix_sum[mid_id]\\n            mid_summ = prefix_sum[-1] - (left_summ + right_summ)\\n\\n            if mid_summ < left_summ:\\n                left = mid_id + 1\\n                continue\\n\\n            elif mid_summ > right_summ:\\n                right = mid_id\\n                continue\\n\\n            else: # (left_summ <= mid_summ <= right_summ): we found valid second pointer \\n                #  check whether it is the minum / maximum valid or just \\n                #  a valid one\\n                new_id = mid_id + switch_id\\n                new_right = prefix_sum[-1] - prefix_sum[new_id]\\n                new_mid = prefix_sum[-1] - (left_summ + new_right)\\n                if (new_id == first_pointer) or (new_id == len(prefix_sum) - 1):\\n                    # current mid_id is the closest to first_pointer or to the end of nums\\n                    return mid_id\\n                if mode == \"min\":\\n                    if left_summ > new_mid: # new_id is not a valid second pointer\\n                        return mid_id\\n                    right = mid_id # new_id is a valid second pointer; continue searching\\n\\n                else: # mode == \"max\"\\n                    if new_mid > new_right: # new_id is not a valid second pointer\\n                        return mid_id\\n                    left = mid_id + 1 # new_id is a valid second pointer; continue searching\\n\\n        return second_pointer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224790,
                "title": "prefix-sum-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]*len(nums)\\n        summ = 0\\n        for i in range(len(nums)):\\n            summ += nums[i]\\n            prefix[i] = summ\\n        \\n        result = 0\\n        total = summ\\n        for p1 in range(len(nums)-2):\\n            left = prefix[p1]\\n            if 2*left > total - left:\\n                break\\n            \\n            p21 = -1\\n            l, r = p1+2, len(nums)-1\\n            while l <= r:\\n                m = l + (r - l)//2\\n                right = total - prefix[m-1]\\n                mid = prefix[m-1] - left\\n                if left <= mid <= right:\\n                    p21 = m\\n                    r = m - 1\\n                else:\\n                    if left > mid:\\n                        l = m + 1\\n                    else:\\n                        r = m - 1\\n            \\n            p22 = -1\\n            l, r = p1+2, len(nums)-1\\n            while l <= r:\\n                m = l + (r - l)//2\\n                right = total - prefix[m-1]\\n                mid = prefix[m-1] - left\\n                if left <= mid <= right:\\n                    p22 = m\\n                    l = m + 1\\n                else:\\n                    if left > mid:\\n                        l = m + 1\\n                    else:\\n                        r = m - 1\\n\\n            if p21 != -1:\\n                result = (result + p22 - p21 + 1) % 1_000_000_007\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]*len(nums)\\n        summ = 0\\n        for i in range(len(nums)):\\n            summ += nums[i]\\n            prefix[i] = summ\\n        \\n        result = 0\\n        total = summ\\n        for p1 in range(len(nums)-2):\\n            left = prefix[p1]\\n            if 2*left > total - left:\\n                break\\n            \\n            p21 = -1\\n            l, r = p1+2, len(nums)-1\\n            while l <= r:\\n                m = l + (r - l)//2\\n                right = total - prefix[m-1]\\n                mid = prefix[m-1] - left\\n                if left <= mid <= right:\\n                    p21 = m\\n                    r = m - 1\\n                else:\\n                    if left > mid:\\n                        l = m + 1\\n                    else:\\n                        r = m - 1\\n            \\n            p22 = -1\\n            l, r = p1+2, len(nums)-1\\n            while l <= r:\\n                m = l + (r - l)//2\\n                right = total - prefix[m-1]\\n                mid = prefix[m-1] - left\\n                if left <= mid <= right:\\n                    p22 = m\\n                    l = m + 1\\n                else:\\n                    if left > mid:\\n                        l = m + 1\\n                    else:\\n                        r = m - 1\\n\\n            if p21 != -1:\\n                result = (result + p22 - p21 + 1) % 1_000_000_007\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216217,
                "title": "c-o-nlogn-prefixsum-lower-bound-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> vsum = {0};\\n        for(auto x:nums) vsum.push_back(vsum.back() + x);\\n        long long res = 0, mod = 1e9+7, sum = vsum.back();\\n        for(int i=1;i<vsum.size();i++){\\n            int left = vsum[i], lower = left + left, upper = (sum-left)/2 + left;\\n            auto it1 = lower_bound(vsum.begin()+i+1, vsum.end(), lower);\\n            auto it2 = upper_bound(vsum.begin()+i+1, vsum.end()-1, upper);\\n            res += max<int>(0, it2 - it1);\\n        }\\n        return res % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> vsum = {0};\\n        for(auto x:nums) vsum.push_back(vsum.back() + x);\\n        long long res = 0, mod = 1e9+7, sum = vsum.back();\\n        for(int i=1;i<vsum.size();i++){\\n            int left = vsum[i], lower = left + left, upper = (sum-left)/2 + left;\\n            auto it1 = lower_bound(vsum.begin()+i+1, vsum.end(), lower);\\n            auto it2 = upper_bound(vsum.begin()+i+1, vsum.end()-1, upper);\\n            res += max<int>(0, it2 - it1);\\n        }\\n        return res % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206811,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    \\n\\nint waysToSplit(vector<int> &nums)\\n{\\n    int cnt = 0, n = nums.size(), j=0, k=0;\\n    vector<int> prefixSum(n, 0);\\n    prefixSum[0] = nums[0];\\n    for (int i = 1; i < n; ++i)\\n    {\\n        prefixSum[i] = prefixSum[i - 1] + nums[i];\\n    }\\n    /*\\n    1  2  2  2  5  0\\n    1  3  5  7 12 12\\n    */\\n    int totalSum = accumulate(nums.begin(), nums.end(), 0);\\n    for (int i = 0; i < n - 2; ++i)\\n    {\\n        if(j<=i) j=i+1;\\n        while (j < n - 1 && prefixSum[i] > prefixSum[j] - prefixSum[i])\\n        {\\n            j++;\\n        }\\n        if(k<j)\\n        k = j;\\n        while (k < n - 1 && prefixSum[k] - prefixSum[i] <= prefixSum[n - 1] - prefixSum[k])\\n        {\\n            k++;\\n        }\\n        cnt=(cnt+k-j)%mod;\\n    }\\n    return cnt;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    \\n\\nint waysToSplit(vector<int> &nums)\\n{\\n    int cnt = 0, n = nums.size(), j=0, k=0;\\n    vector<int> prefixSum(n, 0);\\n    prefixSum[0] = nums[0];\\n    for (int i = 1; i < n; ++i)\\n    {\\n        prefixSum[i] = prefixSum[i - 1] + nums[i];\\n    }\\n    /*\\n    1  2  2  2  5  0\\n    1  3  5  7 12 12\\n    */\\n    int totalSum = accumulate(nums.begin(), nums.end(), 0);\\n    for (int i = 0; i < n - 2; ++i)\\n    {\\n        if(j<=i) j=i+1;\\n        while (j < n - 1 && prefixSum[i] > prefixSum[j] - prefixSum[i])\\n        {\\n            j++;\\n        }\\n        if(k<j)\\n        k = j;\\n        while (k < n - 1 && prefixSum[k] - prefixSum[i] <= prefixSum[n - 1] - prefixSum[k])\\n        {\\n            k++;\\n        }\\n        cnt=(cnt+k-j)%mod;\\n    }\\n    return cnt;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165363,
                "title": "c-simple-solution-prefixsum-binary-search-o-nlog-n",
                "content": "\\n\\n# Code\\n```\\n#define MX 1000000007\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        vector<int>prefixSum(n,0);\\n        prefixSum[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefixSum[i]=prefixSum[i-1]+nums[i];\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int low=i+1,high=n-2,l=-1,r=-1,mid;\\n            //calculating left most valid partiton\\n\\n            while(low<=high)\\n            {\\n                mid=(low+high)/2;\\n                if(prefixSum[i]<=prefixSum[mid]-prefixSum[i])\\n                {\\n                    l=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    low=mid+1;\\n                }\\n            }\\n             //calculating right most valid partiton\\n            low=i+1,high=n-2;\\n            while(low<=high)\\n            {\\n                mid=(low+high)/2;\\n                if(prefixSum[mid]-prefixSum[i]<=prefixSum[n-1]-prefixSum[mid])\\n                {\\n                    r=mid;\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    high=mid-1;\\n                }\\n            }\\n            if(l==-1||r==-1||l>r)\\n            continue;\\n            res=(res+(r-l+1))%MX;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MX 1000000007\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        vector<int>prefixSum(n,0);\\n        prefixSum[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            prefixSum[i]=prefixSum[i-1]+nums[i];\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int low=i+1,high=n-2,l=-1,r=-1,mid;\\n            //calculating left most valid partiton\\n\\n            while(low<=high)\\n            {\\n                mid=(low+high)/2;\\n                if(prefixSum[i]<=prefixSum[mid]-prefixSum[i])\\n                {\\n                    l=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    low=mid+1;\\n                }\\n            }\\n             //calculating right most valid partiton\\n            low=i+1,high=n-2;\\n            while(low<=high)\\n            {\\n                mid=(low+high)/2;\\n                if(prefixSum[mid]-prefixSum[i]<=prefixSum[n-1]-prefixSum[mid])\\n                {\\n                    r=mid;\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    high=mid-1;\\n                }\\n            }\\n            if(l==-1||r==-1||l>r)\\n            continue;\\n            res=(res+(r-l+1))%MX;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131783,
                "title": "swift-prefixsum",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlgN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nextension Array {\\n    func scan<T>(initial: T, _ f: (T, Element)->T) -> [T] {\\n        self.reduce(into: [initial]) { (listSofar, next) in\\n            let lastElement = listSofar.last!\\n            listSofar += [f(lastElement, next)]\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    func waysToSplit(_ nums: [Int]) -> Int {\\n        let MOD = 1000_000_007\\n        let prefixSum = Array(nums.scan(initial: 0, +).dropFirst())\\n\\n        var cnt = 0\\n\\n        func searchBoundary(leftSum: Int, from idx: Int, left: Bool) -> Int {\\n            var res = -1\\n            var l = idx, r = nums.count - 2\\n            while l <= r {\\n                let m = (l + r) / 2\\n                \\n                // [idx...m], [m + 1...n-1]\\n                let middleSum = prefixSum[m] - prefixSum[idx - 1]\\n                let rightSum = prefixSum.last! - prefixSum[m]\\n\\n                if middleSum >= leftSum, rightSum >= middleSum {\\n                    res = m\\n                    if left {\\n                        r = m - 1\\n                    } else {\\n                        l = m + 1\\n                    }\\n                } else if middleSum < leftSum {\\n                    l = m + 1\\n                } else {\\n                    r = m - 1\\n                }\\n            }\\n            return res\\n        }\\n\\n        for i in 1..<prefixSum.count {\\n            let leftSum = prefixSum[i - 1]\\n            let remainSum = prefixSum.last! - leftSum\\n\\n            if remainSum < leftSum * 2 {\\n                break\\n            }\\n\\n            let l = searchBoundary(leftSum: leftSum, from: i, left: true)\\n            let r = searchBoundary(leftSum: leftSum, from: i, left: false)\\n\\n            if l == -1 || r == -1 {\\n                continue;\\n            }\\n\\n            cnt = (cnt + (r - l + 1)) % MOD;\\n        }\\n\\n        return cnt\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nextension Array {\\n    func scan<T>(initial: T, _ f: (T, Element)->T) -> [T] {\\n        self.reduce(into: [initial]) { (listSofar, next) in\\n            let lastElement = listSofar.last!\\n            listSofar += [f(lastElement, next)]\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    func waysToSplit(_ nums: [Int]) -> Int {\\n        let MOD = 1000_000_007\\n        let prefixSum = Array(nums.scan(initial: 0, +).dropFirst())\\n\\n        var cnt = 0\\n\\n        func searchBoundary(leftSum: Int, from idx: Int, left: Bool) -> Int {\\n            var res = -1\\n            var l = idx, r = nums.count - 2\\n            while l <= r {\\n                let m = (l + r) / 2\\n                \\n                // [idx...m], [m + 1...n-1]\\n                let middleSum = prefixSum[m] - prefixSum[idx - 1]\\n                let rightSum = prefixSum.last! - prefixSum[m]\\n\\n                if middleSum >= leftSum, rightSum >= middleSum {\\n                    res = m\\n                    if left {\\n                        r = m - 1\\n                    } else {\\n                        l = m + 1\\n                    }\\n                } else if middleSum < leftSum {\\n                    l = m + 1\\n                } else {\\n                    r = m - 1\\n                }\\n            }\\n            return res\\n        }\\n\\n        for i in 1..<prefixSum.count {\\n            let leftSum = prefixSum[i - 1]\\n            let remainSum = prefixSum.last! - leftSum\\n\\n            if remainSum < leftSum * 2 {\\n                break\\n            }\\n\\n            let l = searchBoundary(leftSum: leftSum, from: i, left: true)\\n            let r = searchBoundary(leftSum: leftSum, from: i, left: false)\\n\\n            if l == -1 || r == -1 {\\n                continue;\\n            }\\n\\n            cnt = (cnt + (r - l + 1)) % MOD;\\n        }\\n\\n        return cnt\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130871,
                "title": "prefix-sum-method",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlgN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        const int MOD = 1e9+7;\\n        int n = nums.size();\\n        \\n        vector<int> prefixSum(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = nums[i] + (i > 0 ? prefixSum[i - 1] : 0);\\n        }\\n        \\n        // starting from idx, find an index which makes left <= middle <= right\\n        // O(lgN)\\n        auto searchBoundary = [&](int leftSum, int idx, bool searchLeft) {\\n            int res = -1;\\n            \\n            // at least one element remain for right sum\\n            int l = idx, r = n - 2;\\n            \\n            while (l <= r) {\\n                int m = l + (r - l) / 2;\\n                \\n                // [idx...m], [m + 1 ... n - 1]\\n                int middleSum = prefixSum[m] - prefixSum[idx - 1];\\n                int rightSum = prefixSum[n - 1] - prefixSum[m];\\n                \\n                if (middleSum >= leftSum && rightSum >= middleSum) {\\n                    res = m;\\n                    if (searchLeft) {\\n                        // try to lower m\\n                        r = m - 1;\\n                    } else {\\n                        l = m + 1;\\n                    }\\n                } else if (middleSum < leftSum) {\\n                    // middlesum is too small, try to expand middle part.\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n            \\n            return res;\\n        };\\n        \\n        \\n        // O(N)\\n        int cnt = 0;\\n        for (int i = 1; i < n; i++) {\\n            \\n            // sum[0...i-1]\\n            int leftSum = prefixSum[i - 1];\\n            \\n            // sum[i...n-1]\\n            int remainSum = prefixSum[n - 1] - prefixSum[i - 1];\\n            \\n            // remain sum is not enough for leftsum + middlesum\\n            if (remainSum < leftSum * 2) {\\n                break;\\n            }\\n            \\n            // search left and right boundary whose value is greater than or equal to left sum\\n            int left = searchBoundary(leftSum, i, true);\\n            int right = searchBoundary(leftSum, i, false);\\n            \\n            if (left == -1 || right == -1) {\\n                continue;\\n            }\\n            \\n            cnt = (cnt + (right - left + 1)) % MOD;\\n        }\\n        return cnt;\\n\\n        // overall time complexity: O(NlgN)\\n        // overall space complexity: O(N)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        const int MOD = 1e9+7;\\n        int n = nums.size();\\n        \\n        vector<int> prefixSum(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = nums[i] + (i > 0 ? prefixSum[i - 1] : 0);\\n        }\\n        \\n        // starting from idx, find an index which makes left <= middle <= right\\n        // O(lgN)\\n        auto searchBoundary = [&](int leftSum, int idx, bool searchLeft) {\\n            int res = -1;\\n            \\n            // at least one element remain for right sum\\n            int l = idx, r = n - 2;\\n            \\n            while (l <= r) {\\n                int m = l + (r - l) / 2;\\n                \\n                // [idx...m], [m + 1 ... n - 1]\\n                int middleSum = prefixSum[m] - prefixSum[idx - 1];\\n                int rightSum = prefixSum[n - 1] - prefixSum[m];\\n                \\n                if (middleSum >= leftSum && rightSum >= middleSum) {\\n                    res = m;\\n                    if (searchLeft) {\\n                        // try to lower m\\n                        r = m - 1;\\n                    } else {\\n                        l = m + 1;\\n                    }\\n                } else if (middleSum < leftSum) {\\n                    // middlesum is too small, try to expand middle part.\\n                    l = m + 1;\\n                } else {\\n                    r = m - 1;\\n                }\\n            }\\n            \\n            return res;\\n        };\\n        \\n        \\n        // O(N)\\n        int cnt = 0;\\n        for (int i = 1; i < n; i++) {\\n            \\n            // sum[0...i-1]\\n            int leftSum = prefixSum[i - 1];\\n            \\n            // sum[i...n-1]\\n            int remainSum = prefixSum[n - 1] - prefixSum[i - 1];\\n            \\n            // remain sum is not enough for leftsum + middlesum\\n            if (remainSum < leftSum * 2) {\\n                break;\\n            }\\n            \\n            // search left and right boundary whose value is greater than or equal to left sum\\n            int left = searchBoundary(leftSum, i, true);\\n            int right = searchBoundary(leftSum, i, false);\\n            \\n            if (left == -1 || right == -1) {\\n                continue;\\n            }\\n            \\n            cnt = (cnt + (right - left + 1)) % MOD;\\n        }\\n        return cnt;\\n\\n        // overall time complexity: O(NlgN)\\n        // overall space complexity: O(N)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130325,
                "title": "ways-to-split-into-three-subsequence-c-easy-approach-fast-simple",
                "content": "**IF YOU LIKE, PLEASE UPVOTE. IT HELPS\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int> pre(n,0);\\n           pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        pre[i]=pre[i-1]+nums[i];\\n        int mod=1e9+7;\\n        // 1 3 5 7 12 12 \\n        for(int i=0;i<n;i++)\\n        {\\n           int low=lower_bound(pre.begin()+i+1,pre.end(),2*pre[i])-pre.begin();//it will return min boundary if we have middle subarray sum equal to first sub array sum(we are checking 2*pre[i] because it is prefix sum and we do not have to conside first subarray sum i.e pre[i])\\n           int up=upper_bound(pre.begin()+i+1,pre.begin()+n-1,pre[i]+((pre[n-1]-pre[i])/2))-pre.begin();//max for second subarray will (remaing part)/2 \\n           ans+=(max(0,(up-low)))%mod;\\n           ans=ans%mod;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int> pre(n,0);\\n           pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        pre[i]=pre[i-1]+nums[i];\\n        int mod=1e9+7;\\n        // 1 3 5 7 12 12 \\n        for(int i=0;i<n;i++)\\n        {\\n           int low=lower_bound(pre.begin()+i+1,pre.end(),2*pre[i])-pre.begin();//it will return min boundary if we have middle subarray sum equal to first sub array sum(we are checking 2*pre[i] because it is prefix sum and we do not have to conside first subarray sum i.e pre[i])\\n           int up=upper_bound(pre.begin()+i+1,pre.begin()+n-1,pre[i]+((pre[n-1]-pre[i])/2))-pre.begin();//max for second subarray will (remaing part)/2 \\n           ans+=(max(0,(up-low)))%mod;\\n           ans=ans%mod;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063735,
                "title": "c-and-binary-search",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int WaysToSplit(int[] nums) {\\n        var res = 0;\\n        var mod = 1000000007;\\n        var n = nums.Length;\\n\\n        for (var i = 1; i < n; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n\\n        for (var i = 0; i < n - 2; i++) {\\n            var start = -1;\\n            var end = -1;\\n\\n            var lo = i + 1;\\n            var hi = n - 2;\\n\\n            while (lo <= hi) {\\n                var mid = lo + (hi - lo) / 2;\\n\\n                if (nums[mid] - nums[i] >= nums[i]) {\\n                    start = mid;\\n                    hi = mid - 1;\\n                } else {\\n                    lo = mid + 1;\\n                }\\n            }\\n\\n            if (start == -1) continue;\\n            hi = n - 2;\\n\\n            while (lo <= hi) {\\n                var mid = lo + (hi - lo) / 2;\\n\\n                if (nums[mid] - nums[i] > nums[n - 1] - nums[mid]) {\\n                    hi = mid - 1;\\n                } else {\\n                    end = mid;\\n                    lo = mid + 1;\\n                }\\n            }\\n\\n            if (end == -1) continue;\\n            res = (res + (end - start + 1)) % mod;\\n        }        \\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int WaysToSplit(int[] nums) {\\n        var res = 0;\\n        var mod = 1000000007;\\n        var n = nums.Length;\\n\\n        for (var i = 1; i < n; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n\\n        for (var i = 0; i < n - 2; i++) {\\n            var start = -1;\\n            var end = -1;\\n\\n            var lo = i + 1;\\n            var hi = n - 2;\\n\\n            while (lo <= hi) {\\n                var mid = lo + (hi - lo) / 2;\\n\\n                if (nums[mid] - nums[i] >= nums[i]) {\\n                    start = mid;\\n                    hi = mid - 1;\\n                } else {\\n                    lo = mid + 1;\\n                }\\n            }\\n\\n            if (start == -1) continue;\\n            hi = n - 2;\\n\\n            while (lo <= hi) {\\n                var mid = lo + (hi - lo) / 2;\\n\\n                if (nums[mid] - nums[i] > nums[n - 1] - nums[mid]) {\\n                    hi = mid - 1;\\n                } else {\\n                    end = mid;\\n                    lo = mid + 1;\\n                }\\n            }\\n\\n            if (end == -1) continue;\\n            res = (res + (end - start + 1)) % mod;\\n        }        \\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032698,
                "title": "java-binary-search-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSum of Subarray -> prefixSum, then binary search the potential min max pivot that can form leftSum <= midSum <= rightSum  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can just use the origin array to form a prefix array to avoid extra space complexity.  \\n2. During a linear scan leftSum = `prefix[i]`, midSum = `prefix[mid] - leftSum`, *Here always remember don\\'t use perfix[left] because left is changing during your binary search and leftSum is fixed*. You can get rightSum with the same approach easily.  \\n3. Move pivot  \\n- If we wanna get the shortest midSum, when we have a correct answer, move right index to left  \\n- If we wanna get a largest midSum, move left to right\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```java\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int mod = 1_000_000_007;\\n        int length = nums.length;\\n        for (int i = 1; i < length; i ++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        int max = nums[length - 1];\\n\\n        int result = 0;\\n        for (int i = 0; i < length; i ++) {\\n            int leftSum = nums[i];\\n            if (leftSum > (max - leftSum) / 2) break;\\n            int minIndex = binarySearch(nums, i + 1, length - 2, leftSum, max, true);\\n            int maxIndex = binarySearch(nums, i + 1, length - 2, leftSum, max, false);\\n            // System.out.println(\"--------\");\\n            // System.out.println(i);\\n            // System.out.println(minIndex);\\n            // System.out.println(maxIndex);\\n            if (minIndex == -1 || maxIndex == -1) continue;\\n            result = (result + (maxIndex - minIndex + 1) % mod) % mod;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int binarySearch(int[] nums, int left, int right, int leftSum, int max, boolean searchMin) {\\n        int result = -1;\\n        int leftIndex = left - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int midSum = nums[mid] - nums[leftIndex];\\n            int rightSum = max - nums[mid];\\n            if (midSum >= leftSum && rightSum >= midSum) {\\n                result = mid;\\n                if (searchMin) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else if (midSum < leftSum) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int mod = 1_000_000_007;\\n        int length = nums.length;\\n        for (int i = 1; i < length; i ++) {\\n            nums[i] = nums[i - 1] + nums[i];\\n        }\\n        int max = nums[length - 1];\\n\\n        int result = 0;\\n        for (int i = 0; i < length; i ++) {\\n            int leftSum = nums[i];\\n            if (leftSum > (max - leftSum) / 2) break;\\n            int minIndex = binarySearch(nums, i + 1, length - 2, leftSum, max, true);\\n            int maxIndex = binarySearch(nums, i + 1, length - 2, leftSum, max, false);\\n            // System.out.println(\"--------\");\\n            // System.out.println(i);\\n            // System.out.println(minIndex);\\n            // System.out.println(maxIndex);\\n            if (minIndex == -1 || maxIndex == -1) continue;\\n            result = (result + (maxIndex - minIndex + 1) % mod) % mod;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int binarySearch(int[] nums, int left, int right, int leftSum, int max, boolean searchMin) {\\n        int result = -1;\\n        int leftIndex = left - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int midSum = nums[mid] - nums[leftIndex];\\n            int rightSum = max - nums[mid];\\n            if (midSum >= leftSum && rightSum >= midSum) {\\n                result = mid;\\n                if (searchMin) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else if (midSum < leftSum) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014078,
                "title": "python-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [nums[0]]\\n        for i in range(1,len(nums)): prefix.append(prefix[-1] + nums[i])\\n        res = 0\\n\\n        if prefix[-1] == 0: return int(((len(nums)-2) + 1)*((len(nums)-2)/2)) % 1000000007\\n\\n        for i in range(1,len(nums)-1):\\n            bound_2 = prefix[i-1] * 2\\n            min_index = bisect.bisect_left(prefix,bound_2,lo = i)\\n            \\n            if min_index >= len(prefix) or prefix[min_index] - prefix[i-1] > prefix[-1] - prefix[min_index]: continue\\n            \\n            bound_3 = prefix[min_index] + ((prefix[-1] - prefix[min_index]) - (prefix[min_index] - prefix[i-1]))/2\\n            \\n            max_index = bisect.bisect_right(prefix,bound_3,lo = min_index+1)\\n            \\n            if max_index >= len(prefix): continue\\n\\n            res += max(max_index-min_index,0)\\n\\n        return res % 1000000007\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [nums[0]]\\n        for i in range(1,len(nums)): prefix.append(prefix[-1] + nums[i])\\n        res = 0\\n\\n        if prefix[-1] == 0: return int(((len(nums)-2) + 1)*((len(nums)-2)/2)) % 1000000007\\n\\n        for i in range(1,len(nums)-1):\\n            bound_2 = prefix[i-1] * 2\\n            min_index = bisect.bisect_left(prefix,bound_2,lo = i)\\n            \\n            if min_index >= len(prefix) or prefix[min_index] - prefix[i-1] > prefix[-1] - prefix[min_index]: continue\\n            \\n            bound_3 = prefix[min_index] + ((prefix[-1] - prefix[min_index]) - (prefix[min_index] - prefix[i-1]))/2\\n            \\n            max_index = bisect.bisect_right(prefix,bound_3,lo = min_index+1)\\n            \\n            if max_index >= len(prefix): continue\\n\\n            res += max(max_index-min_index,0)\\n\\n        return res % 1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990381,
                "title": "simplest-easiest-and-shortest-solution-binary-search-solution",
                "content": "class Solution {\\npublic:\\n    \\n    int waysToSplit(vector<int>& v) {\\n        int n=v.size(),ans=0;\\n        int mod = 1e9+7;\\n        for(int i = 1; i < n; i++) v[i]+= v[i-1];\\n        int sum=v[n-1];\\n        for(int i = 0; i < n && v[i]<=sum/3; i++) {\\n            int x= lower_bound(v.begin() + i + 1, v.end(), v[i]+v[i]) - v.begin();\\n            int y = upper_bound(v.begin() +i + 1, v.end()-1,(sum-v[i])/2+v[i])-v.begin()-1;\\n            ans+= (y- x + 1);\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int waysToSplit(vector<int>& v) {\\n        int n=v.size(),ans=0;\\n        int mod = 1e9+7;\\n        for(int i = 1; i < n; i++) v[i]+= v[i-1];\\n        int sum=v[n-1];\\n        for(int i = 0; i < n && v[i]<=sum/3; i++) {\\n            int x= lower_bound(v.begin() + i + 1, v.end(), v[i]+v[i]) - v.begin();\\n            int y = upper_bound(v.begin() +i + 1, v.end()-1,(sum-v[i])/2+v[i])-v.begin()-1;\\n            ans+= (y- x + 1);\\n            ans%=mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2930721,
                "title": "python-two-pointers-o-n",
                "content": "\\n# Code\\n```\\nfrom itertools import accumulate\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        acc = list(accumulate(nums))\\n        res = j = k = 0\\n        for i in range(n):\\n            j = max(j, i+1)\\n            while j < n and 2*acc[i] > acc[j]: j += 1\\n            k = max(k, j)\\n            while k < n and 2*acc[k] <= acc[i] + acc[-1]: k += 1\\n            res += k - j if k < n else max(k - 1 - j, 0)\\n        return res % MOD\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        acc = list(accumulate(nums))\\n        res = j = k = 0\\n        for i in range(n):\\n            j = max(j, i+1)\\n            while j < n and 2*acc[i] > acc[j]: j += 1\\n            k = max(k, j)\\n            while k < n and 2*acc[k] <= acc[i] + acc[-1]: k += 1\\n            res += k - j if k < n else max(k - 1 - j, 0)\\n        return res % MOD\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930576,
                "title": "python-binary-search-o-nlogn",
                "content": "# Code\\n```\\nfrom itertools import accumulate\\nfrom bisect import bisect_right\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        acc = list(accumulate(nums))\\n        if acc[-1] == acc[0]:\\n            return (n-1)*(n-2)//2%MOD\\n        res = 0\\n        for i in range(n):\\n            j = bisect_left(acc, 2*acc[i])\\n            k = bisect_right(acc, (acc[-1]+acc[i])//2)\\n            res += max(0, k - max(i+1,j))\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nfrom bisect import bisect_right\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        acc = list(accumulate(nums))\\n        if acc[-1] == acc[0]:\\n            return (n-1)*(n-2)//2%MOD\\n        res = 0\\n        for i in range(n):\\n            j = bisect_left(acc, 2*acc[i])\\n            k = bisect_right(acc, (acc[-1]+acc[i])//2)\\n            res += max(0, k - max(i+1,j))\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839926,
                "title": "linear-search-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrecalculate prefix sum to compute the sum of intervals between `i` and `j` in linear time. Let `N = len(nums)`, suppose `num` is cut into intervals: `nums[:i]`, `nums[i: j]`, and `nums[j:]`, The sum between index `i` and `j-1` is `prefix_sum[j] - prefix_sum[i]` (Note that prefix_sum has addtional `0` at the begining). \\n\\nLinear search: For `i` between `1` and `N-2`, check if `j` between `i+1` and `N-1` satisfy the condition.\\n\\nBinary search: It is easy to see for each `i`, if `j1` and `j2` satisfy the condition, all intervals between `j1` and `j2` also satisfy the condition. So For `i` between `1` and `N-2`, find the left most `j_left` and right most `j_right` that satisfy the condition and add all intervals between `j_left` and `j_right`.\\n\\n\\n# Code\\nLinear search:\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix_sum = [0]\\n        for n in nums:\\n            prefix_sum.append(prefix_sum[-1] + n)\\n        res = 0\\n        for i in range(1, len(nums) - 1):\\n            for j in range(i+1, len(nums)):\\n                left = prefix_sum[i] - prefix_sum[0]\\n                mid = prefix_sum[j] - prefix_sum[i]\\n                right = prefix_sum[-1] - prefix_sum[j]\\n                #print(i, j, left, mid, right)\\n                if left <= mid <= right:\\n                    res += 1\\n                elif mid > right:\\n                    break\\n\\n        return res\\n```\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n\\nBinary search:\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix_sum = [0]\\n        for n in nums:\\n            prefix_sum.append(prefix_sum[-1] + n)\\n        if prefix_sum[-1] == 0:\\n            return (1 + len(nums) - 2) * (len(nums) -2) // 2 % 1_000_000_007\\n        res = 0\\n        for i in range(1, len(nums) - 1):\\n            left_sum = prefix_sum[i] - prefix_sum[0]\\n            left, right = i + 1, len(nums) - 1\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\\n                if mid_sum >= left_sum:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            if prefix_sum[right] - prefix_sum[i] >= left_sum:\\n                left_j = right\\n            else:\\n                continue\\n\\n            left, right = left_j, len(nums) - 1\\n            while left < right:\\n                mid = left + (right - left + 1) // 2\\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\\n                right_sum = prefix_sum[-1] - prefix_sum[mid]\\n                if mid_sum <= right_sum:\\n                    left = mid\\n                else:\\n                    right = mid - 1\\n            if prefix_sum[-1] - prefix_sum[left] >= prefix_sum[left] - prefix_sum[i]:\\n                right_j = left\\n                res = (res + right_j - left_j + 1) % 1_000_000_007\\n\\n        return res\\n\\n```\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(Nlog(N))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix_sum = [0]\\n        for n in nums:\\n            prefix_sum.append(prefix_sum[-1] + n)\\n        res = 0\\n        for i in range(1, len(nums) - 1):\\n            for j in range(i+1, len(nums)):\\n                left = prefix_sum[i] - prefix_sum[0]\\n                mid = prefix_sum[j] - prefix_sum[i]\\n                right = prefix_sum[-1] - prefix_sum[j]\\n                #print(i, j, left, mid, right)\\n                if left <= mid <= right:\\n                    res += 1\\n                elif mid > right:\\n                    break\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix_sum = [0]\\n        for n in nums:\\n            prefix_sum.append(prefix_sum[-1] + n)\\n        if prefix_sum[-1] == 0:\\n            return (1 + len(nums) - 2) * (len(nums) -2) // 2 % 1_000_000_007\\n        res = 0\\n        for i in range(1, len(nums) - 1):\\n            left_sum = prefix_sum[i] - prefix_sum[0]\\n            left, right = i + 1, len(nums) - 1\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\\n                if mid_sum >= left_sum:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            if prefix_sum[right] - prefix_sum[i] >= left_sum:\\n                left_j = right\\n            else:\\n                continue\\n\\n            left, right = left_j, len(nums) - 1\\n            while left < right:\\n                mid = left + (right - left + 1) // 2\\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\\n                right_sum = prefix_sum[-1] - prefix_sum[mid]\\n                if mid_sum <= right_sum:\\n                    left = mid\\n                else:\\n                    right = mid - 1\\n            if prefix_sum[-1] - prefix_sum[left] >= prefix_sum[left] - prefix_sum[i]:\\n                right_j = left\\n                res = (res + right_j - left_j + 1) % 1_000_000_007\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808581,
                "title": "rust-solution-using-binary-search",
                "content": "# Code\\n```\\nconst MOD:usize = 1_000_000_007;\\nimpl Solution {\\n  pub fn ways_to_split(nums: Vec<i32>) -> i32 {\\n      let n = nums.len();\\n      let mut result = 0;\\n      let mut memo = vec![0;n+1];\\n      for i in 0..n {\\n        memo[i+1] = nums[i] as isize + memo[i];\\n      }\\n\\n      for i in 2..n {\\n        let lv = memo[i-1];\\n        if memo[n-1] - lv < lv { continue }\\n        let mut left = i;\\n        let mut right = n+1;\\n        while left < right {\\n          let mid = (left+right)/2;\\n          let cv = memo[mid] - lv;\\n          if lv <= cv {\\n            right = mid;\\n          } else {\\n            left = mid+1;\\n          }\\n        }\\n        if left == n { continue }\\n        let min_ci = left;\\n        let min_cv = memo[min_ci] - lv;\\n        if min_cv < lv { continue }\\n\\n        let max_rv = memo[n] - memo[min_ci];\\n        if max_rv < min_cv { continue }\\n\\n        let mut left = min_ci;\\n        let mut right = n;\\n        while left+1 < right {\\n          let mid = (left+right)/2;\\n          let rv = memo[n] - memo[mid];\\n          let cv = memo[mid] - lv;\\n          if cv <= rv {\\n            left = mid;\\n          } else {\\n            right = mid;\\n          }\\n        }\\n        let max_ci = left;\\n        result += max_ci - min_ci + 1;\\n        result %= MOD;\\n      }\\n\\n      result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search"
                ],
                "code": "```\\nconst MOD:usize = 1_000_000_007;\\nimpl Solution {\\n  pub fn ways_to_split(nums: Vec<i32>) -> i32 {\\n      let n = nums.len();\\n      let mut result = 0;\\n      let mut memo = vec![0;n+1];\\n      for i in 0..n {\\n        memo[i+1] = nums[i] as isize + memo[i];\\n      }\\n\\n      for i in 2..n {\\n        let lv = memo[i-1];\\n        if memo[n-1] - lv < lv { continue }\\n        let mut left = i;\\n        let mut right = n+1;\\n        while left < right {\\n          let mid = (left+right)/2;\\n          let cv = memo[mid] - lv;\\n          if lv <= cv {\\n            right = mid;\\n          } else {\\n            left = mid+1;\\n          }\\n        }\\n        if left == n { continue }\\n        let min_ci = left;\\n        let min_cv = memo[min_ci] - lv;\\n        if min_cv < lv { continue }\\n\\n        let max_rv = memo[n] - memo[min_ci];\\n        if max_rv < min_cv { continue }\\n\\n        let mut left = min_ci;\\n        let mut right = n;\\n        while left+1 < right {\\n          let mid = (left+right)/2;\\n          let rv = memo[n] - memo[mid];\\n          let cv = memo[mid] - lv;\\n          if cv <= rv {\\n            left = mid;\\n          } else {\\n            right = mid;\\n          }\\n        }\\n        let max_ci = left;\\n        result += max_ci - min_ci + 1;\\n        result %= MOD;\\n      }\\n\\n      result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807704,
                "title": "java-binary-search-solution",
                "content": "## Unable to figure out the mistake in this solution. Can you guys help?\\n```\\n TreeMap<Integer, Integer> map = new TreeMap<>();\\n        Integer st_sum, end_sum;\\n        int sum=0, ls=0, temp_sum, si, ei;\\n        long ans = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            sum += nums[i];\\n            if(!map.containsKey(sum)) {\\n                map.put(sum, i);\\n            }\\n        }\\n        // System.out.println(map);\\n        for(int i=0; i<nums.length; i++) {\\n            ls += nums[i];\\n            \\n            st_sum = map.ceilingKey(2*ls);\\n            if(st_sum == null) {\\n                break;\\n            }else si = map.get(st_sum);\\n            si = Math.max(i+1, si);\\n            \\n            end_sum = (sum+ls)/2;\\n            end_sum = map.floorKey(end_sum);\\n            if(end_sum == null) {\\n                ei = i+1;\\n            }else ei = map.get(end_sum);\\n            int k=ei+1;\\n            while(k<nums.length && nums[k]==0) {\\n                k++;\\n            }\\n            System.out.println(si + \" \" + k);\\n            \\n            if(k>si) ans += k-si;\\n            else break;\\n        \\n        }\\n        \\n        return (int) (ans%1000000007);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n TreeMap<Integer, Integer> map = new TreeMap<>();\\n        Integer st_sum, end_sum;\\n        int sum=0, ls=0, temp_sum, si, ei;\\n        long ans = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            sum += nums[i];\\n            if(!map.containsKey(sum)) {\\n                map.put(sum, i);\\n            }\\n        }\\n        // System.out.println(map);\\n        for(int i=0; i<nums.length; i++) {\\n            ls += nums[i];\\n            \\n            st_sum = map.ceilingKey(2*ls);\\n            if(st_sum == null) {\\n                break;\\n            }else si = map.get(st_sum);\\n            si = Math.max(i+1, si);\\n            \\n            end_sum = (sum+ls)/2;\\n            end_sum = map.floorKey(end_sum);\\n            if(end_sum == null) {\\n                ei = i+1;\\n            }else ei = map.get(end_sum);\\n            int k=ei+1;\\n            while(k<nums.length && nums[k]==0) {\\n                k++;\\n            }\\n            System.out.println(si + \" \" + k);\\n            \\n            if(k>si) ans += k-si;\\n            else break;\\n        \\n        }\\n        \\n        return (int) (ans%1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758554,
                "title": "c-prefixsum-binarysearch-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefixSum(n);\\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        }\\n        long output = 0l;\\n        for(int i = 0; i<n-2; i++) {\\n            int lo = i, hi = n-2;\\n            int sumLeft = prefixSum[i];\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                int sumMid = prefixSum[mid] - sumLeft;\\n                int sumRight = prefixSum[n-1] - sumMid - sumLeft;\\n                if (sumRight >= sumMid && sumMid >= sumLeft) {\\n                    hi = mid;\\n                } else if (sumRight < sumMid) {\\n                    hi = mid-1;\\n                } else if(sumMid < sumLeft) {\\n                    lo = mid;\\n                }\\n            }\\n            int j = lo+1;\\n            int sumMid = prefixSum[j] - sumLeft;\\n            int sumRight = prefixSum[n-1] - sumMid - sumLeft;\\n            if(sumMid < sumLeft || sumRight < sumMid)\\n                continue;\\n             lo = i+1; hi = n-1;\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                int sumMid = prefixSum[mid] - sumLeft;\\n                int sumRight = prefixSum[n-1] - sumMid - sumLeft;\\n                if (sumRight >= sumMid && sumMid >= sumLeft) {\\n                    lo = mid;\\n                } else if (sumRight < sumMid) {\\n                    hi = mid;\\n                } else if(sumMid < sumLeft) {\\n                    lo = mid+1;\\n                }\\n            }\\n            int k = hi-1;\\n            \\n            output = (output + (k-j+1))%M;\\n\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefixSum(n);\\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        }\\n        long output = 0l;\\n        for(int i = 0; i<n-2; i++) {\\n            int lo = i, hi = n-2;\\n            int sumLeft = prefixSum[i];\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                int sumMid = prefixSum[mid] - sumLeft;\\n                int sumRight = prefixSum[n-1] - sumMid - sumLeft;\\n                if (sumRight >= sumMid && sumMid >= sumLeft) {\\n                    hi = mid;\\n                } else if (sumRight < sumMid) {\\n                    hi = mid-1;\\n                } else if(sumMid < sumLeft) {\\n                    lo = mid;\\n                }\\n            }\\n            int j = lo+1;\\n            int sumMid = prefixSum[j] - sumLeft;\\n            int sumRight = prefixSum[n-1] - sumMid - sumLeft;\\n            if(sumMid < sumLeft || sumRight < sumMid)\\n                continue;\\n             lo = i+1; hi = n-1;\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                int sumMid = prefixSum[mid] - sumLeft;\\n                int sumRight = prefixSum[n-1] - sumMid - sumLeft;\\n                if (sumRight >= sumMid && sumMid >= sumLeft) {\\n                    lo = mid;\\n                } else if (sumRight < sumMid) {\\n                    hi = mid;\\n                } else if(sumMid < sumLeft) {\\n                    lo = mid+1;\\n                }\\n            }\\n            int k = hi-1;\\n            \\n            output = (output + (k-j+1))%M;\\n\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731099,
                "title": "java-solution-using-binary-search",
                "content": "# Intuition\\nI have to say this problem is not Medium at all. The idea about using Binary Search is not hard, yet to pass all the test cases, I have to spend 1 hr working on this.\\n\\n# Approach\\nFirst, we need to keep the left sum fixed. Then we find the leftmost middle position that left <= mid and the rightmost middle position that mid >= right.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        for(int i = 0; i < n; i++){\\n            prefix[i] = nums[i] + (i > 0 ? prefix[i-1] : 0);\\n        }\\n        //Binary search the range in which left will be <= than mid\\n        //For each of that left, binary search the range in which mid will be <= right (add the range to the result)\\n        long result = 0;\\n        long MOD = 1000000007;\\n\\n        for(int i = 0; i < n-2; i++){\\n            //Calculate by the range which mid <= right - the range which left <= mid\\n            //Find the leftmost pos that mid >= left\\n            //FInd the rightmost pos that mid <= right\\n            int left = findLeftMid(i+1, n-1, prefix, prefix[i]);\\n            int right = findRightMid(i+1, n-1, prefix);\\n            if(left != -1 && right != -1 && right >= left){\\n                //System.out.println(i + \" \" + left + \" \" + right);\\n                int temp =  right - left + 1;\\n                //System.out.println(temp);\\n                result += ((long) temp % MOD);\\n                result %= MOD;\\n            }\\n        }\\n        return (int) result;\\n    }\\n    public int findLeftMid(int start, int end, int[] prefix, int threshold){\\n        int left = start;\\n        int right = end - 1;\\n\\n        while(right - left > 1){\\n            int mid = left + (right - left)/2;\\n            int sum = prefix[mid] - (start == 0 ? 0 : prefix[start-1]);\\n            if(threshold <= sum){\\n                right = mid;\\n            }else{ //threshold > sum\\n                left = mid;\\n            }\\n        }\\n        if(threshold <= prefix[left] - (start == 0 ? 0 : prefix[start-1])){\\n            return left;\\n        }\\n        if(threshold <= prefix[right] - (start == 0 ? 0 : prefix[start-1])){\\n            return right;\\n        }\\n        return -1;\\n    }\\n\\n    public int findRightMid(int start, int end, int[] prefix){\\n        int left = start;\\n        int right = end - 1;\\n\\n        while(right - left > 1){\\n            int mid = left + (right - left)/2;\\n            int leftSum = prefix[mid] - (start == 0 ? 0 : prefix[start-1]);\\n            int rightSum = prefix[end] - prefix[mid];\\n            if(leftSum <= rightSum){\\n                left = mid;\\n            }else{ //leftSum > rightSum\\n                right = mid;\\n            }\\n        }\\n        int leftSum = prefix[right] - (start == 0 ? 0 : prefix[start-1]);\\n        int rightSum = prefix[end] - prefix[right];\\n        if(leftSum <= rightSum){\\n            return right;\\n        }\\n        leftSum = prefix[left] - (start == 0 ? 0 : prefix[start-1]);\\n        rightSum = prefix[end] - prefix[left];\\n        if(leftSum <= rightSum){\\n            return left;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        for(int i = 0; i < n; i++){\\n            prefix[i] = nums[i] + (i > 0 ? prefix[i-1] : 0);\\n        }\\n        //Binary search the range in which left will be <= than mid\\n        //For each of that left, binary search the range in which mid will be <= right (add the range to the result)\\n        long result = 0;\\n        long MOD = 1000000007;\\n\\n        for(int i = 0; i < n-2; i++){\\n            //Calculate by the range which mid <= right - the range which left <= mid\\n            //Find the leftmost pos that mid >= left\\n            //FInd the rightmost pos that mid <= right\\n            int left = findLeftMid(i+1, n-1, prefix, prefix[i]);\\n            int right = findRightMid(i+1, n-1, prefix);\\n            if(left != -1 && right != -1 && right >= left){\\n                //System.out.println(i + \" \" + left + \" \" + right);\\n                int temp =  right - left + 1;\\n                //System.out.println(temp);\\n                result += ((long) temp % MOD);\\n                result %= MOD;\\n            }\\n        }\\n        return (int) result;\\n    }\\n    public int findLeftMid(int start, int end, int[] prefix, int threshold){\\n        int left = start;\\n        int right = end - 1;\\n\\n        while(right - left > 1){\\n            int mid = left + (right - left)/2;\\n            int sum = prefix[mid] - (start == 0 ? 0 : prefix[start-1]);\\n            if(threshold <= sum){\\n                right = mid;\\n            }else{ //threshold > sum\\n                left = mid;\\n            }\\n        }\\n        if(threshold <= prefix[left] - (start == 0 ? 0 : prefix[start-1])){\\n            return left;\\n        }\\n        if(threshold <= prefix[right] - (start == 0 ? 0 : prefix[start-1])){\\n            return right;\\n        }\\n        return -1;\\n    }\\n\\n    public int findRightMid(int start, int end, int[] prefix){\\n        int left = start;\\n        int right = end - 1;\\n\\n        while(right - left > 1){\\n            int mid = left + (right - left)/2;\\n            int leftSum = prefix[mid] - (start == 0 ? 0 : prefix[start-1]);\\n            int rightSum = prefix[end] - prefix[mid];\\n            if(leftSum <= rightSum){\\n                left = mid;\\n            }else{ //leftSum > rightSum\\n                right = mid;\\n            }\\n        }\\n        int leftSum = prefix[right] - (start == 0 ? 0 : prefix[start-1]);\\n        int rightSum = prefix[end] - prefix[right];\\n        if(leftSum <= rightSum){\\n            return right;\\n        }\\n        leftSum = prefix[left] - (start == 0 ? 0 : prefix[start-1]);\\n        rightSum = prefix[end] - prefix[left];\\n        if(leftSum <= rightSum){\\n            return left;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705778,
                "title": "running-binary-search-over-prefix-sum-to-find-left-and-right-wall-of-the-second-segment",
                "content": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        \\n\\t\\t#Logic ->\\n\\t\\t#           Firstly we only iterate over len(nums)-2 as we want the rest 2 arrays be non-empty\\n\\t\\t#           First we create a prefix array\\n\\t\\t#           We iterate over the prefix array\\n\\t\\t#           We check if the right sum is less than the left sum if it is means the last two arrays\\n\\t\\t#           sum will not be per req of the qns so we quit and return as it will only decrease over next iter\\n\\t\\t#            We then look for left wall and right wall over the right sum\\n\\t\\t#            In left wall we are looking for the lowest sum such that it is atleast greater than the first array sum\\n\\t\\t#            In right wall we are looking for the lowest right sum such that it is atleast greater than the second sum\\n\\t\\t#            then the count will be the difference between right and left wall\\n\\t\\t#            left wall and right wall are the boundaries for second segment\\n\\t\\t#            as the sum to the right of the right wall will always be greater than the sum of second segment\\n\\t\\t#            and the sum in the first segment will always be lesser than the the rest two segmenents\\n\\t\\t#            then the second segment can be on n numbers which is right - left\\n\\t\\t\\n\\t\\t\\n\\t\\t#find the first wall which is going to be the start of the second segment\\n        def leftWall(target,low,high,array):\\n            \\n            while low <= high:\\n                \\n                m       = (low + high ) // 2\\n                leftSum = array[m] - target\\n                \\n                if leftSum >= target:\\n                    high  = m -1 \\n                else:\\n                    low = m + 1\\n            \\n            return high\\n            \\n\\t\\t#find the second wall which is going to be the end of the second segment\\n        def rightWall(target,total,low,high,array):\\n            \\n            while low <= high:\\n                \\n                m = (low+high) // 2\\n                leftSum  = array[m] - target\\n                rightSum = total - array[m]\\n                \\n\\t\\t\\t\\t#deals incase of arrays filled with only 0 since last array cannot be empty\\n\\t\\t\\t\\t#in case of arrays with all 0s we will have an edge case \\n\\t\\t\\t\\t#as leftsum and rightsum will always be equal and we will end up going to the last index\\n\\t\\t\\t\\t#which renders third segment empty so to handle that we have this condition\\n                if leftSum == 0 and rightSum == 0 and high == len(array) - 1:\\n                    return high - 1\\n                elif rightSum < leftSum:\\n                    high = m - 1\\n                else:\\n                    low = m + 1\\n            \\n            return high\\n            \\n        \\n        prefix = []\\n        p      = 0\\n        total  = sum(nums)\\n        for n in nums:\\n            p += n\\n            prefix.append(p)\\n                            \\n        count = 0\\n        \\n        for lefty in range(len(prefix)-2):\\n            \\n            left  = prefix[lefty]\\n            right = total - left\\n            \\n            if right // 2 < left:\\n                break\\n            \\n            r = rightWall(left,total,lefty+1,len(prefix)-1,prefix) \\n            l = leftWall(left,lefty+1,len(prefix)-1,prefix)\\n            \\n            count += r-l\\n            \\n        \\n        return count % 1000000007\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        \\n\\t\\t#Logic ->\\n\\t\\t#           Firstly we only iterate over len(nums)-2 as we want the rest 2 arrays be non-empty\\n\\t\\t#           First we create a prefix array\\n\\t\\t#           We iterate over the prefix array\\n\\t\\t#           We check if the right sum is less than the left sum if it is means the last two arrays\\n\\t\\t#           sum will not be per req of the qns so we quit and return as it will only decrease over next iter\\n\\t\\t#            We then look for left wall and right wall over the right sum\\n\\t\\t#            In left wall we are looking for the lowest sum such that it is atleast greater than the first array sum\\n\\t\\t#            In right wall we are looking for the lowest right sum such that it is atleast greater than the second sum\\n\\t\\t#            then the count will be the difference between right and left wall\\n\\t\\t#            left wall and right wall are the boundaries for second segment\\n\\t\\t#            as the sum to the right of the right wall will always be greater than the sum of second segment\\n\\t\\t#            and the sum in the first segment will always be lesser than the the rest two segmenents\\n\\t\\t#            then the second segment can be on n numbers which is right - left\\n\\t\\t\\n\\t\\t\\n\\t\\t#find the first wall which is going to be the start of the second segment\\n        def leftWall(target,low,high,array):\\n            \\n            while low <= high:\\n                \\n                m       = (low + high ) // 2\\n                leftSum = array[m] - target\\n                \\n                if leftSum >= target:\\n                    high  = m -1 \\n                else:\\n                    low = m + 1\\n            \\n            return high\\n            \\n\\t\\t#find the second wall which is going to be the end of the second segment\\n        def rightWall(target,total,low,high,array):\\n            \\n            while low <= high:\\n                \\n                m = (low+high) // 2\\n                leftSum  = array[m] - target\\n                rightSum = total - array[m]\\n                \\n\\t\\t\\t\\t#deals incase of arrays filled with only 0 since last array cannot be empty\\n\\t\\t\\t\\t#in case of arrays with all 0s we will have an edge case \\n\\t\\t\\t\\t#as leftsum and rightsum will always be equal and we will end up going to the last index\\n\\t\\t\\t\\t#which renders third segment empty so to handle that we have this condition\\n                if leftSum == 0 and rightSum == 0 and high == len(array) - 1:\\n                    return high - 1\\n                elif rightSum < leftSum:\\n                    high = m - 1\\n                else:\\n                    low = m + 1\\n            \\n            return high\\n            \\n        \\n        prefix = []\\n        p      = 0\\n        total  = sum(nums)\\n        for n in nums:\\n            p += n\\n            prefix.append(p)\\n                            \\n        count = 0\\n        \\n        for lefty in range(len(prefix)-2):\\n            \\n            left  = prefix[lefty]\\n            right = total - left\\n            \\n            if right // 2 < left:\\n                break\\n            \\n            r = rightWall(left,total,lefty+1,len(prefix)-1,prefix) \\n            l = leftWall(left,lefty+1,len(prefix)-1,prefix)\\n            \\n            count += r-l\\n            \\n        \\n        return count % 1000000007\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703405,
                "title": "binary-search-on-prefix-sum-explained-python",
                "content": "O(n^2) approach is kinda obvious, just consider every subarray as middle and increment the count if valid.\\n\\nConsider every i in range(0, n-2) as the left subarray\\nthen find the closest idx k such that sum(i+1, k) >= sum(i)\\nalso find the furthest idx k such that sum(i+1, k)<= sum(k, n-1)\\n\\nclosest and furthest idx represent min and max boundary of middle for the current left subarray.\\n\\nBoundaries can be found using binary search on prefix sum array\\n\\nIf you think about it, the boundaries ONLY MOVE FORWARD as i increases, so you can actually maintain two pointers to represent boundary of middle and complete the full solution in O(n) rather than O(nlogn).\\n```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n    Sums = list(accumulate(nums))\\n    ans = 0\\n    for i in range(len(nums)-2):\\n        left = bisect_left(Sums, 2*Sums[i])\\n        left = max(i+1, left)\\n        \\n        right = bisect_right(Sums, (Sums[-1] - Sums[i])/2 + Sums[i])\\n        right = min(len(nums)-1, right)\\n        \\n        if right > left:\\n            ans += right - left\\n    return ans % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n    Sums = list(accumulate(nums))\\n    ans = 0\\n    for i in range(len(nums)-2):\\n        left = bisect_left(Sums, 2*Sums[i])\\n        left = max(i+1, left)\\n        \\n        right = bisect_right(Sums, (Sums[-1] - Sums[i])/2 + Sums[i])\\n        right = min(len(nums)-1, right)\\n        \\n        if right > left:\\n            ans += right - left\\n    return ans % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2688856,
                "title": "python-double-binary-search",
                "content": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        ps=[nums[0]]\\n        for i in range(1,len(nums)):ps.append(ps[-1]+nums[i])\\n        ans=0\\n        for i in range(len(nums)-1):\\n            if ps[i]*3>ps[-1]:break\\n            l,r,x=i,len(nums),float(\\'inf\\')\\n            while l<=r:\\n                m=(l+r)//2\\n                if m>=len(ps):break\\n                ms=ps[m]-ps[i]\\n                rs=ps[-1]-(ms+ps[i])\\n                if ms<=rs and ms>=ps[i]:\\n                    x=min(x,m)\\n                    r=m-1\\n                elif ms<ps[i]:\\n                    l=m+1\\n                else:\\n                    r=m-1\\n\\n            if x==i:x+=1\\n            l,r,y=i,len(nums),-float(\\'inf\\')\\n            while l<=r:\\n                m=(l+r)//2\\n                if m>=len(ps):break\\n                ms=ps[m]-ps[i]\\n                rs=ps[-1]-(ms+ps[i])\\n                if ms<=rs and ms>=ps[i]:\\n                    y=max(y,m)\\n                    l=m+1\\n                elif ms<ps[i]:\\n                    l=m+1\\n                else:\\n                    r=m-1\\n            if y==len(nums)-1:y-=1\\n            if x==float(\\'inf\\') or y==-float(\\'inf\\'):continue\\n            ans+=((y-x)+1)\\n        return ans%((10**9)+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        ps=[nums[0]]\\n        for i in range(1,len(nums)):ps.append(ps[-1]+nums[i])\\n        ans=0\\n        for i in range(len(nums)-1):\\n            if ps[i]*3>ps[-1]:break\\n            l,r,x=i,len(nums),float(\\'inf\\')\\n            while l<=r:\\n                m=(l+r)//2\\n                if m>=len(ps):break\\n                ms=ps[m]-ps[i]\\n                rs=ps[-1]-(ms+ps[i])\\n                if ms<=rs and ms>=ps[i]:\\n                    x=min(x,m)\\n                    r=m-1\\n                elif ms<ps[i]:\\n                    l=m+1\\n                else:\\n                    r=m-1\\n\\n            if x==i:x+=1\\n            l,r,y=i,len(nums),-float(\\'inf\\')\\n            while l<=r:\\n                m=(l+r)//2\\n                if m>=len(ps):break\\n                ms=ps[m]-ps[i]\\n                rs=ps[-1]-(ms+ps[i])\\n                if ms<=rs and ms>=ps[i]:\\n                    y=max(y,m)\\n                    l=m+1\\n                elif ms<ps[i]:\\n                    l=m+1\\n                else:\\n                    r=m-1\\n            if y==len(nums)-1:y-=1\\n            if x==float(\\'inf\\') or y==-float(\\'inf\\'):continue\\n            ans+=((y-x)+1)\\n        return ans%((10**9)+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683878,
                "title": "go-o-n",
                "content": "You can see the Java solution in [this link](https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/999257/C%2B%2BJavaPython-O(n)-with-picture), translated into go language and made minor changes below.\\n\\n```\\nfunc WaysToSplit(nums []int) int {\\n\\n\\tsize := len(nums)\\n\\tresult := 0\\n\\n\\tif size < 3 {\\n\\t\\treturn result\\n\\t}\\n\\n\\tmodValue := 1_000_000_007\\n\\n\\tfor i := 1; i < size; i++ {\\n\\t\\tnums[i] += nums[i-1]\\n\\t}\\n\\n\\ti := 0\\n\\tj := 1\\n\\tk := 1\\n\\tfor ; i < size-2; i++ {\\n\\t\\tif j < i+1 {\\n\\t\\t\\tj = i + 1\\n\\t\\t}\\n\\n\\t\\tfor j < size-1 && nums[i]*2 > nums[j] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\n\\t\\tif k < j {\\n\\t\\t\\tk = j\\n\\t\\t}\\n\\n\\t\\tfor k < size-1 && nums[size-1]-nums[k] >= nums[k]-nums[i] {\\n\\t\\t\\tk++\\n\\t\\t}\\n\\n\\t\\tresult = (result + k - j) % modValue\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc WaysToSplit(nums []int) int {\\n\\n\\tsize := len(nums)\\n\\tresult := 0\\n\\n\\tif size < 3 {\\n\\t\\treturn result\\n\\t}\\n\\n\\tmodValue := 1_000_000_007\\n\\n\\tfor i := 1; i < size; i++ {\\n\\t\\tnums[i] += nums[i-1]\\n\\t}\\n\\n\\ti := 0\\n\\tj := 1\\n\\tk := 1\\n\\tfor ; i < size-2; i++ {\\n\\t\\tif j < i+1 {\\n\\t\\t\\tj = i + 1\\n\\t\\t}\\n\\n\\t\\tfor j < size-1 && nums[i]*2 > nums[j] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\n\\t\\tif k < j {\\n\\t\\t\\tk = j\\n\\t\\t}\\n\\n\\t\\tfor k < size-1 && nums[size-1]-nums[k] >= nums[k]-nums[i] {\\n\\t\\t\\tk++\\n\\t\\t}\\n\\n\\t\\tresult = (result + k - j) % modValue\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2680163,
                "title": "c-my-submission-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> pf;\\n        int res=0;\\n        pf.resize(nums.size(),0);\\n        pf[0] = nums[0];\\n        \\n        for(int i=1;i<pf.size();i++)\\n            pf[i]= pf[i-1]+nums[i];\\n        \\n        int S,L;\\n        S=pf[pf.size()-1];\\n        \\n        for(int i=0;i<(nums.size()-2);i++)\\n        {\\n            L=pf[i];\\n            \\n            vector<int>::iterator a,b;\\n            \\n            a=upper_bound(pf.begin()+i+1,pf.end(),(S+L)/2);\\n            if(pf[pf.size()-1]==0)\\n                a-=1;\\n            \\n            b=lower_bound(pf.begin()+i+1,pf.end(),2*L);\\n            \\n            \\n            if(a == pf.end() || b == pf.end() || b>=a)\\n                continue;\\n            \\n            res += (a-b);\\n            res=res%(1000000000+7);\\n        }\\n        return res;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int> pf;\\n        int res=0;\\n        pf.resize(nums.size(),0);\\n        pf[0] = nums[0];\\n        \\n        for(int i=1;i<pf.size();i++)\\n            pf[i]= pf[i-1]+nums[i];\\n        \\n        int S,L;\\n        S=pf[pf.size()-1];\\n        \\n        for(int i=0;i<(nums.size()-2);i++)\\n        {\\n            L=pf[i];\\n            \\n            vector<int>::iterator a,b;\\n            \\n            a=upper_bound(pf.begin()+i+1,pf.end(),(S+L)/2);\\n            if(pf[pf.size()-1]==0)\\n                a-=1;\\n            \\n            b=lower_bound(pf.begin()+i+1,pf.end(),2*L);\\n            \\n            \\n            if(a == pf.end() || b == pf.end() || b>=a)\\n                continue;\\n            \\n            res += (a-b);\\n            res=res%(1000000000+7);\\n        }\\n        return res;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667607,
                "title": "please-explain-what-mistake-i-ve-made",
                "content": "// class Solution {\\n// public:\\n//     int waysToSplit(vector<int>& nums) {\\n//         int n=nums.size(),mod=1e9+7;\\n//         vector<int> sum(n+1,0);\\n//         for(int i=1;i<=n;i++){\\n//             sum[i]=sum[i-1]+nums[i-1];\\n//         }\\n//         long right,left;\\n//         long sum1,ans=0,last=sum.back();\\n//         for(int i=1;i<=n-2;i++){\\n//             sum1=sum[i];\\n//             int l=i+1,r=n;\\n//             while(l<r){\\n//                 int mid=(l+r)/2;\\n//                 if(sum[mid]>=2*sum1){\\n//                     r=mid;\\n//                 }else{\\n//                     l=mid+1;\\n//                 }\\n                \\n//             }\\n//             left=l;\\n//             r=n;\\n//             while(l<=r){\\n//                 int mid=(l+r)/2; \\n//                 if(2*sum[mid]-sum1<=last){\\n//                     l=mid+1;\\n//                 }else{\\n//                     r=mid-1;\\n//                 }\\n//             }\\n//             right=r;\\n//             ans=(ans+right-left+1)%mod;\\n//         }\\n//         return ans%mod;\\n//     }\\n// };",
                "solutionTags": [],
                "code": "class Solution {\\n// public:\\n//     int waysToSplit(vector<int>& nums) {\\n//         int n=nums.size(),mod=1e9+7;\\n//         vector<int> sum(n+1,0);\\n//         for(int i=1;i<=n;i++){\\n//             sum[i]=sum[i-1]+nums[i-1];\\n//         }",
                "codeTag": "Java"
            },
            {
                "id": 2616039,
                "title": "simple-java-solution-with-explanation-prefix-sum-with-binary-search",
                "content": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        // find the prefix sum of the input array\\n        for (int i = 1; i < nums.length; i++) nums[i] += nums[i-1];\\n        // store the total sum of the array\\n        int totalSum = nums[nums.length - 1];\\n        long count = 0l;\\n        // for every possible [left sub-array], find the range possible for [mid sub-array]\\n        for (int i = 0; i <= nums.length - 3; i++) {\\n            // the [mid sub-array] sum cannot be lesser than the current [left sub-array] sum\\n            int midRangeLeft = nums[i] * 2;\\n            // the [mid sub-array] sum cannot be greater than the [right sub-array] sum\\n            int midRangeRight = nums[i] + ((totalSum - nums[i]) / 2);\\n            if (midRangeLeft <= midRangeRight) {\\n                // perform a binary search to find the left and right extremes of the [mid sub-array]\\n                long leftIndex = getCeilingIndex(nums, midRangeLeft, i + 1);\\n                long rightIndex = getFloorIndex(nums, midRangeRight,  i + 1);\\n                // if the extremes are valid, compute the count of possible triplets and add to answer\\n                if (leftIndex != -1 && rightIndex != -1) {\\n                    count = (count + (rightIndex - leftIndex + 1)) % 1_000_000_007l;\\n                }\\n            }\\n        }\\n        return (int)count;\\n    }\\n    \\n    // find the left-most index arr[i] which is >= target element after arr[left]\\n    int getCeilingIndex(int[] arr, int target, int left) {\\n        int ans = -1, right = arr.length - 2;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] >= target) {\\n                ans = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // find the right-most index arr[i] which is <= target element after arr[left]\\n    int getFloorIndex(int[] arr, int target, int left) {\\n        int ans = -1, right = arr.length - 2;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] <= target) {\\n                ans = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        // find the prefix sum of the input array\\n        for (int i = 1; i < nums.length; i++) nums[i] += nums[i-1];\\n        // store the total sum of the array\\n        int totalSum = nums[nums.length - 1];\\n        long count = 0l;\\n        // for every possible [left sub-array], find the range possible for [mid sub-array]\\n        for (int i = 0; i <= nums.length - 3; i++) {\\n            // the [mid sub-array] sum cannot be lesser than the current [left sub-array] sum\\n            int midRangeLeft = nums[i] * 2;\\n            // the [mid sub-array] sum cannot be greater than the [right sub-array] sum\\n            int midRangeRight = nums[i] + ((totalSum - nums[i]) / 2);\\n            if (midRangeLeft <= midRangeRight) {\\n                // perform a binary search to find the left and right extremes of the [mid sub-array]\\n                long leftIndex = getCeilingIndex(nums, midRangeLeft, i + 1);\\n                long rightIndex = getFloorIndex(nums, midRangeRight,  i + 1);\\n                // if the extremes are valid, compute the count of possible triplets and add to answer\\n                if (leftIndex != -1 && rightIndex != -1) {\\n                    count = (count + (rightIndex - leftIndex + 1)) % 1_000_000_007l;\\n                }\\n            }\\n        }\\n        return (int)count;\\n    }\\n    \\n    // find the left-most index arr[i] which is >= target element after arr[left]\\n    int getCeilingIndex(int[] arr, int target, int left) {\\n        int ans = -1, right = arr.length - 2;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] >= target) {\\n                ans = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // find the right-most index arr[i] which is <= target element after arr[left]\\n    int getFloorIndex(int[] arr, int target, int left) {\\n        int ans = -1, right = arr.length - 2;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid] <= target) {\\n                ans = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553569,
                "title": "c-two-pointers",
                "content": "For an index i, we divide right array from i->n and find the limits of mid array from 0->i\\nThe left and right limits are the min value we can give to mid array and max value we can give to \\nmid array. Can be done using two pointers. One for the left limit and one for right limit.\\nIf our mid exceeds right, then we need to increase our max limit pointer forward so that left array\\nis given some value from mid. Now till the left array does not exceed mid array value we increase our\\nmin limit pointer. \\nThe answer for each index is max of min limit - max limit  and 0.\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll M = 1e9+7;\\n        int n = nums.size();\\n        ll total = accumulate(nums.begin(), nums.end(), 0);\\n        // 0->left limit, left limit -> right limit, left limit -> i, right limit -> i\\n        ll left1 = nums[0], left2 = nums[0], mid1 = 0, mid2 = 0;\\n        int low = 0, high = 0;\\n        ll ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            mid1 += nums[i];\\n            mid2 += nums[i];\\n            while(mid1 > (total-mid1-left1) && low < i){\\n                left1 += nums[++low];\\n                mid1 -= nums[low];\\n            }\\n            while(left2 <= mid2 && high < i){\\n                left2 += nums[++high];\\n                mid2 -= nums[high];\\n            }\\n            ans += max<ll>(high-low,0);\\n            ans %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        ll M = 1e9+7;\\n        int n = nums.size();\\n        ll total = accumulate(nums.begin(), nums.end(), 0);\\n        // 0->left limit, left limit -> right limit, left limit -> i, right limit -> i\\n        ll left1 = nums[0], left2 = nums[0], mid1 = 0, mid2 = 0;\\n        int low = 0, high = 0;\\n        ll ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            mid1 += nums[i];\\n            mid2 += nums[i];\\n            while(mid1 > (total-mid1-left1) && low < i){\\n                left1 += nums[++low];\\n                mid1 -= nums[low];\\n            }\\n            while(left2 <= mid2 && high < i){\\n                left2 += nums[++high];\\n                mid2 -= nums[high];\\n            }\\n            ans += max<ll>(high-low,0);\\n            ans %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547886,
                "title": "c-easy-to-read-prefix-sum-lower-bound",
                "content": "```\\nconstexpr int mod = (int)1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n);\\n        for (int i = 0; i < n; ++i) {\\n            pre[i] += i == 0 ? 0 : pre[i-1];\\n            pre[i] += nums[i];\\n        }\\n        int total = pre[n-1];\\n        \\n        int ret = 0;\\n        // i is the inclusive last element of the 1st block\\n        for (int i = 0; i < n-2; ++i) {\\n\\t\\t\\t// the 1st block can only be a third of the total\\n            if (pre[i]*3 > total) break;\\n\\t\\t\\t// for the 2nd block, the lowest end value is two times the 1st block\\'s value\\n            int low = 2 * pre[i];\\n\\t\\t\\t// the remaining total not used in the first block gets split up between the 2nd and 3rd block\\n\\t\\t\\t// the first bad value is where the 2nd block has more value than the 3rd block\\n            int high_bad = pre[i] + (total - pre[i]) / 2 + 1;\\n            \\n\\t\\t\\t// search for the first good element that comes after 1st block\\'s end\\n            auto left = lower_bound(pre.begin()+i+1, pre.end(), low);\\n\\t\\t\\t// 2nd block lower end was too big!\\n            if (*left >= high_bad) continue;\\n\\t\\t\\t\\n\\t\\t\\t// we know left is a legal end for 2nd block\\n\\t\\t\\t// now search for the first too-big end (that can\\'t be the last element)\\n            auto right = lower_bound(left+1, pre.end()-1, high_bad);\\n\\t\\t\\t\\n            ret = (ret + distance(left, right)) % mod;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nconstexpr int mod = (int)1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n);\\n        for (int i = 0; i < n; ++i) {\\n            pre[i] += i == 0 ? 0 : pre[i-1];\\n            pre[i] += nums[i];\\n        }\\n        int total = pre[n-1];\\n        \\n        int ret = 0;\\n        // i is the inclusive last element of the 1st block\\n        for (int i = 0; i < n-2; ++i) {\\n\\t\\t\\t// the 1st block can only be a third of the total\\n            if (pre[i]*3 > total) break;\\n\\t\\t\\t// for the 2nd block, the lowest end value is two times the 1st block\\'s value\\n            int low = 2 * pre[i];\\n\\t\\t\\t// the remaining total not used in the first block gets split up between the 2nd and 3rd block\\n\\t\\t\\t// the first bad value is where the 2nd block has more value than the 3rd block\\n            int high_bad = pre[i] + (total - pre[i]) / 2 + 1;\\n            \\n\\t\\t\\t// search for the first good element that comes after 1st block\\'s end\\n            auto left = lower_bound(pre.begin()+i+1, pre.end(), low);\\n\\t\\t\\t// 2nd block lower end was too big!\\n            if (*left >= high_bad) continue;\\n\\t\\t\\t\\n\\t\\t\\t// we know left is a legal end for 2nd block\\n\\t\\t\\t// now search for the first too-big end (that can\\'t be the last element)\\n            auto right = lower_bound(left+1, pre.end()-1, high_bad);\\n\\t\\t\\t\\n            ret = (ret + distance(left, right)) % mod;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544353,
                "title": "c-prefix-sum-binary-search",
                "content": "UPVOTE IF YOU LIKE \\n```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int>sums(nums.size());\\n        sums[0]=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            sums[i]+=sums[i-1]+nums[i];\\n        }\\n        int ans=0;\\n        for(int i=1;i<n-1;i++){\\n            int minInd=-1,maxInd=-1;\\n            int target=sums[n-1]-sums[i];\\n                int l=0,h=i;\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if(sums[i]-sums[mid]>=sums[mid]){\\n                        maxInd=mid;\\n                        l=mid+1;\\n                    }\\n                    else{\\n                        h=mid-1;\\n                    }\\n                }\\n                if(maxInd!=-1&&sums[i]-sums[maxInd]>target) maxInd=-1;\\n                l=0,h=i;\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if(sums[i]-sums[mid]<=target){\\n                        minInd=mid;\\n                        h=mid-1;\\n                    }\\n                    else{\\n                        l=mid+1;\\n                    }\\n                }\\n                if(minInd!=-1&&maxInd!=-1){\\n                    if(maxInd==i) ans-=1;\\n                    ans=(ans+maxInd-minInd+1)%1000000007;\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        vector<int>sums(nums.size());\\n        sums[0]=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            sums[i]+=sums[i-1]+nums[i];\\n        }\\n        int ans=0;\\n        for(int i=1;i<n-1;i++){\\n            int minInd=-1,maxInd=-1;\\n            int target=sums[n-1]-sums[i];\\n                int l=0,h=i;\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if(sums[i]-sums[mid]>=sums[mid]){\\n                        maxInd=mid;\\n                        l=mid+1;\\n                    }\\n                    else{\\n                        h=mid-1;\\n                    }\\n                }\\n                if(maxInd!=-1&&sums[i]-sums[maxInd]>target) maxInd=-1;\\n                l=0,h=i;\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if(sums[i]-sums[mid]<=target){\\n                        minInd=mid;\\n                        h=mid-1;\\n                    }\\n                    else{\\n                        l=mid+1;\\n                    }\\n                }\\n                if(minInd!=-1&&maxInd!=-1){\\n                    if(maxInd==i) ans-=1;\\n                    ans=(ans+maxInd-minInd+1)%1000000007;\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414263,
                "title": "c",
                "content": "```\\n\\n\\nint waysToSplit(int* nums, int numsSize){\\n    int i;\\n    int* prefix = malloc(numsSize * sizeof(int));\\n    int* surfix = malloc(numsSize * sizeof(int));\\n    prefix[0] = nums[0];\\n    surfix[numsSize-1] = nums[numsSize-1];\\n    int mod = 1e9 + 7;\\n    for(i = 1; i < numsSize; i++){\\n        prefix[i] = nums[i] + prefix[i-1];\\n        surfix[numsSize -1 - i] = nums[numsSize -1 - i] + surfix[numsSize - i];\\n    }\\n\\n    int L, M, R;  //L: sum of left , M: sum of middle, R: sum of right \\n    int ans = 0;\\n    int left, right, mid, Ls, Lm;  //Ls: most left cut of first cut;   Lm: most right cut of first cut \\n    for(i = (numsSize - 1); i >=2; i--){\\n        R = surfix[i];\\n        if(2* R < prefix[i-1])\\n            continue;\\n        //Find Ls,\\n        left = 0; right = i - 2;\\n        while(left < right){\\n            mid = (left + right)/2;\\n            M = prefix[i-1] - prefix[mid];\\n            L = prefix[mid];\\n            //if(M <= R && L <= M)\\n            if(L >= (prefix[numsSize-1] - 2*R))\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        M = prefix[i-1] - prefix[left];\\n        L = prefix[left];\\n\\n        if(M <= R && L <= M)\\n            Ls = left;\\n        else\\n            continue;\\n        //Find Lm\\n        left = Ls; right = i - 2;\\n        while((left + 1) < right){\\n            mid = (left + right)/2;\\n            M = prefix[i-1] - prefix[mid];\\n            L = prefix[mid];\\n            if(L <= M)\\n                left = mid;\\n            else\\n                right = mid -1;\\n        } \\n        M = prefix[i-1] - prefix[right];\\n        L = prefix[right];        \\n        if(L <= M)\\n            Lm = right;  \\n        else \\n            Lm = left;\\n\\n        ans = (ans + (Lm - Ls) + 1)%mod;\\n    }\\n    free(prefix);\\n    free(surfix);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint waysToSplit(int* nums, int numsSize){\\n    int i;\\n    int* prefix = malloc(numsSize * sizeof(int));\\n    int* surfix = malloc(numsSize * sizeof(int));\\n    prefix[0] = nums[0];\\n    surfix[numsSize-1] = nums[numsSize-1];\\n    int mod = 1e9 + 7;\\n    for(i = 1; i < numsSize; i++){\\n        prefix[i] = nums[i] + prefix[i-1];\\n        surfix[numsSize -1 - i] = nums[numsSize -1 - i] + surfix[numsSize - i];\\n    }\\n\\n    int L, M, R;  //L: sum of left , M: sum of middle, R: sum of right \\n    int ans = 0;\\n    int left, right, mid, Ls, Lm;  //Ls: most left cut of first cut;   Lm: most right cut of first cut \\n    for(i = (numsSize - 1); i >=2; i--){\\n        R = surfix[i];\\n        if(2* R < prefix[i-1])\\n            continue;\\n        //Find Ls,\\n        left = 0; right = i - 2;\\n        while(left < right){\\n            mid = (left + right)/2;\\n            M = prefix[i-1] - prefix[mid];\\n            L = prefix[mid];\\n            //if(M <= R && L <= M)\\n            if(L >= (prefix[numsSize-1] - 2*R))\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        M = prefix[i-1] - prefix[left];\\n        L = prefix[left];\\n\\n        if(M <= R && L <= M)\\n            Ls = left;\\n        else\\n            continue;\\n        //Find Lm\\n        left = Ls; right = i - 2;\\n        while((left + 1) < right){\\n            mid = (left + right)/2;\\n            M = prefix[i-1] - prefix[mid];\\n            L = prefix[mid];\\n            if(L <= M)\\n                left = mid;\\n            else\\n                right = mid -1;\\n        } \\n        M = prefix[i-1] - prefix[right];\\n        L = prefix[right];        \\n        if(L <= M)\\n            Lm = right;  \\n        else \\n            Lm = left;\\n\\n        ans = (ans + (Lm - Ls) + 1)%mod;\\n    }\\n    free(prefix);\\n    free(surfix);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2342471,
                "title": "python-binary-search-partial-sum",
                "content": "(1) first we precompute the partial sum;\\n(2) iterate each item of the partial sum arry, which starts from the first left index of middle segment;\\n(3) note no need to consider the middle seg if the partial sum >avg, illegal;\\n(4) use binary search to locate the possible range of the right index of middle segment;\\n(5) minimum is to equal or larger than the first segment ;\\n(6) max is to less than the third segment;\\n\\n```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        ps=[0]\\n        n=len(nums)\\n        for i,c in enumerate(nums):\\n            ps.append(ps[-1]+c)\\n        res=0\\n        avg=ps[-1]/3\\n        if ps[-1]==0:\\n            res=(n-2)*(n-1)//2\\n            return res%mod\\n        for i in range(1,n+1-2):\\n            x=ps[i]\\n            if x>avg:break\\n            left=bisect.bisect_left(ps,2*x, lo=i+1)\\n            right=bisect.bisect_right(ps,(ps[-1]+x)/2,lo=left)\\n            if left<right:\\n                res+=right-left\\n        return res%mod\\n",
                "solutionTags": [],
                "code": "(1) first we precompute the partial sum;\\n(2) iterate each item of the partial sum arry, which starts from the first left index of middle segment;\\n(3) note no need to consider the middle seg if the partial sum >avg, illegal;\\n(4) use binary search to locate the possible range of the right index of middle segment;\\n(5) minimum is to equal or larger than the first segment ;\\n(6) max is to less than the third segment;\\n\\n```\\ndef waysToSplit(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        ps=[0]\\n        n=len(nums)\\n        for i,c in enumerate(nums):\\n            ps.append(ps[-1]+c)\\n        res=0\\n        avg=ps[-1]/3\\n        if ps[-1]==0:\\n            res=(n-2)*(n-1)//2\\n            return res%mod\\n        for i in range(1,n+1-2):\\n            x=ps[i]\\n            if x>avg:break\\n            left=bisect.bisect_left(ps,2*x, lo=i+1)\\n            right=bisect.bisect_right(ps,(ps[-1]+x)/2,lo=left)\\n            if left<right:\\n                res+=right-left\\n        return res%mod\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2332567,
                "title": "lower-bound",
                "content": "class Solution {\\npublic:\\n\\n\\n    int waysToSplit(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<int> v(n);\\n        v[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            v[i]=nums[i]+v[i-1];\\n        \\n        int ans=0;\\n        int mod=1e9+7;\\n        for(int i=1;i<n-1;i++){\\n            auto l=v.begin();\\n            auto h=v.begin()+i;\\n            \\n            auto a=upper_bound(l , h , v[i]/2);\\n            auto b=lower_bound(l , h , 2*v[i]-v[n-1]);\\n            ans+=(a-b)>0?(a-b):0;\\n            //cout<<(b-a)<<endl;\\n            ans%=mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int waysToSplit(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<int> v(n);\\n        v[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            v[i]=nums[i]+v[i-1];\\n        \\n        int ans=0;\\n        int mod=1e9+7;\\n        for(int i=1;i<n-1;i++){\\n            auto l=v.begin();\\n            auto h=v.begin()+i;\\n            \\n            auto a=upper_bound(l , h , v[i]/2);\\n            auto b=lower_bound(l , h , 2*v[i]-v[n-1]);\\n            ans+=(a-b)>0?(a-b):0;\\n            //cout<<(b-a)<<endl;\\n            ans%=mod;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2296750,
                "title": "python-simple-binary-search",
                "content": "\\n    def waysToSplit(self, nums):\\n        ans, count = [0], 0\\n        \\n        for i in nums:\\n            ans.append(ans[-1] + i)\\n        \\n        for i in range(1,len(ans)):\\n            j = bisect.bisect_left(ans, 2*ans[i])\\n            k = bisect.bisect_right(ans, (ans[i] + ans[-1])//2)\\n            count += max(0, min(len(nums), k) - max(i+1, j))\\n        \\n        return count%(10**9+7)",
                "solutionTags": [],
                "code": "\\n    def waysToSplit(self, nums):\\n        ans, count = [0], 0\\n        \\n        for i in nums:\\n            ans.append(ans[-1] + i)\\n        \\n        for i in range(1,len(ans)):\\n            j = bisect.bisect_left(ans, 2*ans[i])\\n            k = bisect.bisect_right(ans, (ans[i] + ans[-1])//2)\\n            count += max(0, min(len(nums), k) - max(i+1, j))\\n        \\n        return count%(10**9+7)",
                "codeTag": "Python3"
            },
            {
                "id": 2275414,
                "title": "that-s-hard",
                "content": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        int MOD= 1_000_000_007;\\n        int[] prefixSum = new int[n];\\n        long res = 0l;\\n        prefixSum[0] = nums[0];\\n        for(int i=1;i<n;i++) prefixSum[i] += prefixSum[i-1]+nums[i];\\n        for(int i=1;i<n-1;i++){\\n            int left = bs(prefixSum,true,i,prefixSum[i-1]);\\n            int right = bs(prefixSum,false,i,prefixSum[i-1]);\\n            if(left == -1 || right == -1) continue;\\n            res = (res + (right-left+1)%MOD)%MOD;\\n        }\\n        return (int)res;\\n    }\\n    private int bs(int[] A, boolean leftSearch, int index,int leftSum){\\n        int lo = index, hi=A.length-2,res=-1;\\n        while(lo<=hi){\\n            int m = (lo+hi)/2;\\n            int midSum = A[m]-leftSum;\\n            int rightSum = A[A.length-1] - A[m];\\n            if(leftSum<=midSum && midSum<=rightSum){\\n                res = m;\\n                if(leftSearch) hi = m-1;\\n                else lo=m+1;\\n            }\\n            else if(midSum>rightSum) hi=m-1;\\n            else lo=m+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        int n = nums.length;\\n        int MOD= 1_000_000_007;\\n        int[] prefixSum = new int[n];\\n        long res = 0l;\\n        prefixSum[0] = nums[0];\\n        for(int i=1;i<n;i++) prefixSum[i] += prefixSum[i-1]+nums[i];\\n        for(int i=1;i<n-1;i++){\\n            int left = bs(prefixSum,true,i,prefixSum[i-1]);\\n            int right = bs(prefixSum,false,i,prefixSum[i-1]);\\n            if(left == -1 || right == -1) continue;\\n            res = (res + (right-left+1)%MOD)%MOD;\\n        }\\n        return (int)res;\\n    }\\n    private int bs(int[] A, boolean leftSearch, int index,int leftSum){\\n        int lo = index, hi=A.length-2,res=-1;\\n        while(lo<=hi){\\n            int m = (lo+hi)/2;\\n            int midSum = A[m]-leftSum;\\n            int rightSum = A[A.length-1] - A[m];\\n            if(leftSum<=midSum && midSum<=rightSum){\\n                res = m;\\n                if(leftSearch) hi = m-1;\\n                else lo=m+1;\\n            }\\n            else if(midSum>rightSum) hi=m-1;\\n            else lo=m+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263262,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public static final int MOD = (int)Math.pow(10,9)+7;\\n    public int waysToSplit(int[] nums) {\\n        int sum = 0;\\n        for (int num: nums)\\n            sum+=num;\\n        long result = 0;\\n        int len = nums.length;\\n        int[] prefixSum = new int[len];\\n        prefixSum[0]=nums[0];\\n        for(int i =1; i <len -1; i++){\\n            prefixSum[i]=prefixSum[i-1]+nums[i];\\n            if (2*prefixSum[i]-sum <= prefixSum[i]/2){\\n                int low = 0, high = i-1;\\n                while(low <= high){\\n                    int mid = low + (high - low)/2;\\n                    if (prefixSum[mid] >= 2*prefixSum[i]-sum)\\n                        high=mid-1;\\n                    else\\n                        low=mid+1;\\n                }\\n                int left = low;\\n                low=0; high = i-1;\\n                while(low <= high){\\n                    int mid = low +(high - low)/2;\\n                    if (prefixSum[mid] > prefixSum[i]/2)\\n                        high = mid -1;\\n                    else\\n                        low = mid +1;\\n                }\\n                int right = high;\\n                result = (result +(right - left + 1))%MOD;\\n            }\\n        }\\n        return (int)result;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static final int MOD = (int)Math.pow(10,9)+7;\\n    public int waysToSplit(int[] nums) {\\n        int sum = 0;\\n        for (int num: nums)\\n            sum+=num;\\n        long result = 0;\\n        int len = nums.length;\\n        int[] prefixSum = new int[len];\\n        prefixSum[0]=nums[0];\\n        for(int i =1; i <len -1; i++){\\n            prefixSum[i]=prefixSum[i-1]+nums[i];\\n            if (2*prefixSum[i]-sum <= prefixSum[i]/2){\\n                int low = 0, high = i-1;\\n                while(low <= high){\\n                    int mid = low + (high - low)/2;\\n                    if (prefixSum[mid] >= 2*prefixSum[i]-sum)\\n                        high=mid-1;\\n                    else\\n                        low=mid+1;\\n                }\\n                int left = low;\\n                low=0; high = i-1;\\n                while(low <= high){\\n                    int mid = low +(high - low)/2;\\n                    if (prefixSum[mid] > prefixSum[i]/2)\\n                        high = mid -1;\\n                    else\\n                        low = mid +1;\\n                }\\n                int right = high;\\n                result = (result +(right - left + 1))%MOD;\\n            }\\n        }\\n        return (int)result;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262961,
                "title": "too-hard-to-understand-from-tutorials-as-well",
                "content": "Refer explanation from here : \\nhttps://leetcode.com/problems/ways-to-split-array-into-three-subarrays/discuss/1447421/Python-3-or-Binary-Search-or-Explanation\\n\\nCode - \\n\\n```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        \\n        int res = 0, n = nums.length ;\\n        \\n        for(int i = 1 ; i < n ; i++ )\\n                nums[i] += nums[i-1];\\n        \\n        \\n        for(int i = 0; i <=  n - 3 ; i++ ){\\n            int l = i + 1 , r = n - 2, m;\\n            int ans = -1;\\n            \\n            while(l <= r){\\n                m = l + (r - l )/2;\\n                if(nums[m] >= 2L* nums[i] ){\\n                    ans = m;\\n                    r = m -1;\\n                }else{\\n                    l = m +1;\\n                }\\n            }\\n            \\n            if(ans == -1)continue;\\n            \\n            l = ans; r = n - 2;\\n            int ans2 = -1;\\n            \\n            while(l <= r){\\n                m = l + (r - l )/2;\\n                \\n                if(nums[n-1] + nums[i] >= 2*nums[m]  ){\\n                    ans2 = m;\\n                    l  = m + 1;\\n                }else{\\n                    r = m - 1; \\n                }\\n            }\\n            if(ans2 == -1)continue;\\n            \\n            res = (res + ans2 - ans + 1)%1000000007;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        \\n        int res = 0, n = nums.length ;\\n        \\n        for(int i = 1 ; i < n ; i++ )\\n                nums[i] += nums[i-1];\\n        \\n        \\n        for(int i = 0; i <=  n - 3 ; i++ ){\\n            int l = i + 1 , r = n - 2, m;\\n            int ans = -1;\\n            \\n            while(l <= r){\\n                m = l + (r - l )/2;\\n                if(nums[m] >= 2L* nums[i] ){\\n                    ans = m;\\n                    r = m -1;\\n                }else{\\n                    l = m +1;\\n                }\\n            }\\n            \\n            if(ans == -1)continue;\\n            \\n            l = ans; r = n - 2;\\n            int ans2 = -1;\\n            \\n            while(l <= r){\\n                m = l + (r - l )/2;\\n                \\n                if(nums[n-1] + nums[i] >= 2*nums[m]  ){\\n                    ans2 = m;\\n                    l  = m + 1;\\n                }else{\\n                    r = m - 1; \\n                }\\n            }\\n            if(ans2 == -1)continue;\\n            \\n            res = (res + ans2 - ans + 1)%1000000007;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245163,
                "title": "c-fastest-solution-binary-search-stars-and-bars-o-n-log-n",
                "content": "\\n```\\n//aproch is simple\\n//for every index from i=0 to i<=n-3;\\n//step1:  find the leftmost index to right of index i for whic condition hold;\\n//step2 :find right rightmost index to right of i for which condition hold\\n//ans+=rightmost-leftmost+1;\\n//finalans sum of all ans\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int find_ans(int s,int e,vector<int>&prefix,int sum,int n){\\n        int left=s;\\n        int right=e;\\n        \\n        int ans=1e8;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            int sum1=prefix[mid+1]-prefix[left];\\n            int sum2=prefix[n]-prefix[mid+1];\\n            if(sum1>=sum){\\n                if(sum1<=sum2){\\n                    e=mid-1;\\n                    ans=min(ans,mid);\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n       int find_ans2(int s,int e,vector<int>&prefix,int sum,int n){\\n        int left=s;\\n        int right=e;     \\n         int ans=-1;\\n    \\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            int sum1=prefix[mid+1]-prefix[left];\\n            int sum2=prefix[n]-prefix[mid+1];\\n            if(sum1>=sum){\\n                if(sum1<=sum2){\\n                    s=mid+1;\\n                    ans=max(ans,mid);\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int waysToSplit(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        vector<int>prefix(n+1,0);\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        for(int i=0;i<=n-3;i++){\\n            int sum=prefix[i+1]-prefix[0];\\n            int op1=find_ans(i+1,n-2,prefix,sum,n);\\n            int op2=find_ans2(i+1,n-2,prefix,sum,n);\\n        \\n            if(op1!=(int)1e8 and op2!=-1){\\n                if(op1>i and op1<n-1 and op2<n-1 and op2>=op1){\\n                    int val=op2-op1+1;\\n                    ans+=val;\\n                    ans%=mod;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\n//aproch is simple\\n//for every index from i=0 to i<=n-3;\\n//step1:  find the leftmost index to right of index i for whic condition hold;\\n//step2 :find right rightmost index to right of i for which condition hold\\n//ans+=rightmost-leftmost+1;\\n//finalans sum of all ans\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int find_ans(int s,int e,vector<int>&prefix,int sum,int n){\\n        int left=s;\\n        int right=e;\\n        \\n        int ans=1e8;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            int sum1=prefix[mid+1]-prefix[left];\\n            int sum2=prefix[n]-prefix[mid+1];\\n            if(sum1>=sum){\\n                if(sum1<=sum2){\\n                    e=mid-1;\\n                    ans=min(ans,mid);\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n       int find_ans2(int s,int e,vector<int>&prefix,int sum,int n){\\n        int left=s;\\n        int right=e;     \\n         int ans=-1;\\n    \\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            int sum1=prefix[mid+1]-prefix[left];\\n            int sum2=prefix[n]-prefix[mid+1];\\n            if(sum1>=sum){\\n                if(sum1<=sum2){\\n                    s=mid+1;\\n                    ans=max(ans,mid);\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int waysToSplit(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        vector<int>prefix(n+1,0);\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        for(int i=0;i<=n-3;i++){\\n            int sum=prefix[i+1]-prefix[0];\\n            int op1=find_ans(i+1,n-2,prefix,sum,n);\\n            int op2=find_ans2(i+1,n-2,prefix,sum,n);\\n        \\n            if(op1!=(int)1e8 and op2!=-1){\\n                if(op1>i and op1<n-1 and op2<n-1 and op2>=op1){\\n                    int val=op2-op1+1;\\n                    ans+=val;\\n                    ans%=mod;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240565,
                "title": "java-detailed-explanation-binary-search-2pointer",
                "content": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        /*\\n          s=s1+s2\\n          s2=s-s1 >= s1\\n             s/2 >=s1 \\n             s-s1 <= right\\n             s-right <= s1 <= s/2\\n              \\n        */\\n        \\n        int s=0;\\n        for(int i=0;i<nums.length;i++)\\n            s +=nums[i];\\n        \\n        int mod=(int)Math.pow(10,9)+7;\\n        \\n        long res=0;\\n        int[]prefix=new int[nums.length];\\n        prefix[0]=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n            \\n            if(2*prefix[i]-s <= prefix[i]/2){\\n                \\n            int l=0;\\n            int h=i-1;\\n            int ans1;int ans2;\\n            \\n            while(l<=h){\\n                int mid=(l+h)/2;\\n                \\n                if(prefix[mid] >= 2*prefix[i]-s)\\n                     h=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            ans1=l;    \\n            \\n            l=0;\\n            h=i-1;\\n            while(l<=h){\\n               int mid=(l+h)/2;\\n                \\n                if(prefix[mid] > prefix[i]/2)\\n                     h=mid-1;\\n                else\\n                    l=mid+1;\\n            \\n            }\\n            ans2=h;\\n            res=(res+(ans2-ans1+1))%mod;}\\n        }\\n        return (int)res;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int waysToSplit(int[] nums) {\\n        /*\\n          s=s1+s2\\n          s2=s-s1 >= s1\\n             s/2 >=s1 \\n             s-s1 <= right\\n             s-right <= s1 <= s/2\\n              \\n        */\\n        \\n        int s=0;\\n        for(int i=0;i<nums.length;i++)\\n            s +=nums[i];\\n        \\n        int mod=(int)Math.pow(10,9)+7;\\n        \\n        long res=0;\\n        int[]prefix=new int[nums.length];\\n        prefix[0]=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n            \\n            if(2*prefix[i]-s <= prefix[i]/2){\\n                \\n            int l=0;\\n            int h=i-1;\\n            int ans1;int ans2;\\n            \\n            while(l<=h){\\n                int mid=(l+h)/2;\\n                \\n                if(prefix[mid] >= 2*prefix[i]-s)\\n                     h=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            ans1=l;    \\n            \\n            l=0;\\n            h=i-1;\\n            while(l<=h){\\n               int mid=(l+h)/2;\\n                \\n                if(prefix[mid] > prefix[i]/2)\\n                     h=mid-1;\\n                else\\n                    l=mid+1;\\n            \\n            }\\n            ans2=h;\\n            res=(res+(ans2-ans1+1))%mod;}\\n        }\\n        return (int)res;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232069,
                "title": "js-bs-prefix-sum",
                "content": "```\\nvar waysToSplit = function (nums) {\\n\\tlet rightSum = 0, leftMostOfLeftWall, rightMostOfLeftWall, count = 0;\\n\\tconst mod = 10 ** 9 + 7,\\n\\t\\tpreSum = [0],\\n\\t\\tbs = (low, high, direction) => {\\n\\t\\t\\t//direction 1 = right, 0=left \\n\\t\\t\\tlet mid;\\n\\t\\t\\tconst highPreSum = preSum[high + 1],\\n\\t\\t\\t\\tcheck = () =>\\n\\t\\t\\t\\t\\tdirection\\n\\t\\t\\t\\t\\t\\t? highPreSum - preSum[mid] >= preSum[mid]\\n\\t\\t\\t\\t\\t\\t: rightSum < highPreSum - preSum[mid];\\n\\t\\t\\twhile (low < high) {\\n\\t\\t\\t\\tmid = (low + high) >>> 1;\\n\\t\\t\\t\\tcheck() ? (low = mid + 1) : (high = mid);\\n\\t\\t\\t}\\n\\t\\t\\tdirection\\n\\t\\t\\t\\t? highPreSum - preSum[low] < preSum[low] && low--\\n\\t\\t\\t\\t: rightSum < highPreSum - preSum[low] && low++;\\n\\t\\t\\treturn low;\\n\\t\\t};\\n\\tfor (const num of nums) preSum.push(preSum[preSum.length - 1] + num);\\n\\n\\tfor (let i = nums.length - 1; i > 1; i--) {\\n\\t\\trightSum += nums[i];\\n\\t\\tleftMostOfLeftWall = bs(1, i - 1, 0);\\n\\t\\tif (\\n\\t\\t\\tleftMostOfLeftWall === i ||\\n\\t\\t\\tpreSum[leftMostOfLeftWall] > preSum[i] - preSum[leftMostOfLeftWall]\\n\\t\\t)\\n\\t\\t\\tcontinue;\\n\\t\\trightMostOfLeftWall = bs(leftMostOfLeftWall, i - 1, 1);\\n\\t\\tcount = (count + rightMostOfLeftWall - leftMostOfLeftWall + 1) % mod;\\n\\t}\\n\\treturn count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nvar waysToSplit = function (nums) {\\n\\tlet rightSum = 0, leftMostOfLeftWall, rightMostOfLeftWall, count = 0;\\n\\tconst mod = 10 ** 9 + 7,\\n\\t\\tpreSum = [0],\\n\\t\\tbs = (low, high, direction) => {\\n\\t\\t\\t//direction 1 = right, 0=left \\n\\t\\t\\tlet mid;\\n\\t\\t\\tconst highPreSum = preSum[high + 1],\\n\\t\\t\\t\\tcheck = () =>\\n\\t\\t\\t\\t\\tdirection\\n\\t\\t\\t\\t\\t\\t? highPreSum - preSum[mid] >= preSum[mid]\\n\\t\\t\\t\\t\\t\\t: rightSum < highPreSum - preSum[mid];\\n\\t\\t\\twhile (low < high) {\\n\\t\\t\\t\\tmid = (low + high) >>> 1;\\n\\t\\t\\t\\tcheck() ? (low = mid + 1) : (high = mid);\\n\\t\\t\\t}\\n\\t\\t\\tdirection\\n\\t\\t\\t\\t? highPreSum - preSum[low] < preSum[low] && low--\\n\\t\\t\\t\\t: rightSum < highPreSum - preSum[low] && low++;\\n\\t\\t\\treturn low;\\n\\t\\t};\\n\\tfor (const num of nums) preSum.push(preSum[preSum.length - 1] + num);\\n\\n\\tfor (let i = nums.length - 1; i > 1; i--) {\\n\\t\\trightSum += nums[i];\\n\\t\\tleftMostOfLeftWall = bs(1, i - 1, 0);\\n\\t\\tif (\\n\\t\\t\\tleftMostOfLeftWall === i ||\\n\\t\\t\\tpreSum[leftMostOfLeftWall] > preSum[i] - preSum[leftMostOfLeftWall]\\n\\t\\t)\\n\\t\\t\\tcontinue;\\n\\t\\trightMostOfLeftWall = bs(leftMostOfLeftWall, i - 1, 1);\\n\\t\\tcount = (count + rightMostOfLeftWall - leftMostOfLeftWall + 1) % mod;\\n\\t}\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204074,
                "title": "c-code-sets-prefix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int waysToSplit(vector<int>& v) {\\n        int i;\\n        int n=v.size();\\n        vector<int> pre(n,0);\\n        \\n        \\n        bool flag=false;\\n        pre[0]=v[0];\\n        int full=v[0];\\n        \\n        if (v[0]!=0){\\n            flag=true;\\n        }\\n        \\n        for (i=1; i<n; i++){\\n            pre[i]=pre[i-1]+v[i];\\n            full+=v[i];\\n            if (v[i]!=0){\\n                flag=true;\\n            }\\n        }\\n        \\n        \\n        if (!flag){\\n            int ans=0;\\n            \\n            for (i=1; i<n-1; i++){\\n                ans=(ans%mod + i%mod)%mod;\\n            }\\n         return ans;\\n        }\\n        int ans=0,sum=0;\\n        \\n        for (i=0; i<n; i++){\\n           sum+=v[i];\\n           int rem=full-sum;\\n           int partition=rem/2;\\n           \\n\\n            \\n           auto it=upper_bound(pre.begin(),pre.end(),sum+partition);\\n           auto it1=lower_bound(pre.begin(),pre.end(),2*sum);\\n            \\n           if (it!=pre.end()){\\n               if (it1-pre.begin()>it-pre.begin()){\\n                   continue;\\n               }\\n               \\n               int curr1=it-pre.begin();\\n               int curr2=it1-pre.begin();\\n\\n               int idx=(curr1-max(curr2,i+1));\\n               ans=(ans%mod + idx%mod)%mod;\\n           }\\n           \\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int waysToSplit(vector<int>& v) {\\n        int i;\\n        int n=v.size();\\n        vector<int> pre(n,0);\\n        \\n        \\n        bool flag=false;\\n        pre[0]=v[0];\\n        int full=v[0];\\n        \\n        if (v[0]!=0){\\n            flag=true;\\n        }\\n        \\n        for (i=1; i<n; i++){\\n            pre[i]=pre[i-1]+v[i];\\n            full+=v[i];\\n            if (v[i]!=0){\\n                flag=true;\\n            }\\n        }\\n        \\n        \\n        if (!flag){\\n            int ans=0;\\n            \\n            for (i=1; i<n-1; i++){\\n                ans=(ans%mod + i%mod)%mod;\\n            }\\n         return ans;\\n        }\\n        int ans=0,sum=0;\\n        \\n        for (i=0; i<n; i++){\\n           sum+=v[i];\\n           int rem=full-sum;\\n           int partition=rem/2;\\n           \\n\\n            \\n           auto it=upper_bound(pre.begin(),pre.end(),sum+partition);\\n           auto it1=lower_bound(pre.begin(),pre.end(),2*sum);\\n            \\n           if (it!=pre.end()){\\n               if (it1-pre.begin()>it-pre.begin()){\\n                   continue;\\n               }\\n               \\n               int curr1=it-pre.begin();\\n               int curr2=it1-pre.begin();\\n\\n               int idx=(curr1-max(curr2,i+1));\\n               ans=(ans%mod + idx%mod)%mod;\\n           }\\n           \\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121847,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\n        public int WaysToSplit(int[] nums)\\n        {\\n            int n = nums.Length;\\n            int[] arr = new int[n];//create prefixSum array\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                sum+=nums[i];\\n                arr[i] = sum;\\n            }\\n            long res = 0;\\n            long mod = 10_0000_0007;\\n\\t\\t\\t//find index i and j , than sum of [0,i]<= (i,j]<=(j,n-1]\\n\\t\\t\\t//equal to prefix array : arr[i]<=arr[j]-arr[i]<=arr[n-1]-arr[j]\\n            for(int i = 0; i < n - 2; i++)\\n            {\\n\\t\\t\\t    //skip three invalid condition\\n                if (arr[i] > sum / 3)\\n                    break;\\n                if (arr[i + 1] - arr[i] > sum - arr[i + 1])\\n                    break;\\n                if (arr[i] > arr[n - 2] - arr[i])\\n                    break;\\n\\n                int left1 = i + 1;\\n                int right1 = n - 2;\\n                while (left1 < right1)\\n                {\\n                    int mid1 = (left1 + right1) / 2;\\n                    if (arr[mid1] - arr[i] >= arr[i])\\n                    {\\n                        right1 = mid1;\\n                    }\\n                    else\\n                    {\\n                        left1 = mid1+1;\\n                    }\\n                }\\n\\t\\t\\t\\t//search valid index left1, that arr[left1]-arr[i]>=arr[i]\\n                if (arr[left1] - arr[i] < arr[i]) continue;\\n\\n                int left2 = i + 1;\\n                int right2 = n - 2;\\n                while (left2 < right2)\\n                {\\n                    int mid2 = (left2+ right2+1) / 2;//select the right side center\\n                    if (sum - arr[mid2] >= arr[mid2] - arr[i])\\n                    {\\n                        left2 = mid2;\\n                    }\\n                    else\\n                    {\\n                        right2= mid2-1;\\n                    }\\n                }\\n\\t\\t\\t\\t//valid index left2 meet the condition: sum-arr[left2] < arr[left2] - arr[i]\\n                if (sum-arr[left2] < arr[left2] - arr[i]) continue;\\n\\n                res += left2 - left1 + 1;// add range count [left1,left2]\\n                res %= mod;\\n            }\\n            return (int)(res % mod);\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int WaysToSplit(int[] nums)\\n        {\\n            int n = nums.Length;\\n            int[] arr = new int[n];//create prefixSum array\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                sum+=nums[i];\\n                arr[i] = sum;\\n            }\\n            long res = 0;\\n            long mod = 10_0000_0007;\\n\\t\\t\\t//find index i and j , than sum of [0,i]<= (i,j]<=(j,n-1]\\n\\t\\t\\t//equal to prefix array : arr[i]<=arr[j]-arr[i]<=arr[n-1]-arr[j]\\n            for(int i = 0; i < n - 2; i++)\\n            {\\n\\t\\t\\t    //skip three invalid condition\\n                if (arr[i] > sum / 3)\\n                    break;\\n                if (arr[i + 1] - arr[i] > sum - arr[i + 1])\\n                    break;\\n                if (arr[i] > arr[n - 2] - arr[i])\\n                    break;\\n\\n                int left1 = i + 1;\\n                int right1 = n - 2;\\n                while (left1 < right1)\\n                {\\n                    int mid1 = (left1 + right1) / 2;\\n                    if (arr[mid1] - arr[i] >= arr[i])\\n                    {\\n                        right1 = mid1;\\n                    }\\n                    else\\n                    {\\n                        left1 = mid1+1;\\n                    }\\n                }\\n\\t\\t\\t\\t//search valid index left1, that arr[left1]-arr[i]>=arr[i]\\n                if (arr[left1] - arr[i] < arr[i]) continue;\\n\\n                int left2 = i + 1;\\n                int right2 = n - 2;\\n                while (left2 < right2)\\n                {\\n                    int mid2 = (left2+ right2+1) / 2;//select the right side center\\n                    if (sum - arr[mid2] >= arr[mid2] - arr[i])\\n                    {\\n                        left2 = mid2;\\n                    }\\n                    else\\n                    {\\n                        right2= mid2-1;\\n                    }\\n                }\\n\\t\\t\\t\\t//valid index left2 meet the condition: sum-arr[left2] < arr[left2] - arr[i]\\n                if (sum-arr[left2] < arr[left2] - arr[i]) continue;\\n\\n                res += left2 - left1 + 1;// add range count [left1,left2]\\n                res %= mod;\\n            }\\n            return (int)(res % mod);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104697,
                "title": "javascript-prefix-sum-binary-search-550ms",
                "content": "```\\n////////////////////////////////////////////////////// Template ///////////////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst mod = 1e9 + 7;\\nconst waysToSplit = (a) => {\\n    let n = a.length, pre = preSum(a), bi = new Bisect();\\n    let res = 0;\\n    for (let i = 1; i < n; i++) {\\n        let lsum = subArraySum(pre, 0, i - 1), mrSum = subArraySum(pre, i, n - 1); // mid right total sum\\n        let min = bi.bisect_left(pre, 2 * lsum, i + 1); // lower_bound search [low = i+1, end]\\n        let max = bi.bisect_left(pre, parseInt(mrSum / 2) + lsum + 1, i + 1);\\n        max = Math.min(max, n);\\n        let len = max - min;\\n        res += Math.max(0, len);\\n    }\\n    return res % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n////////////////////////////////////////////////////// Template ///////////////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst mod = 1e9 + 7;\\nconst waysToSplit = (a) => {\\n    let n = a.length, pre = preSum(a), bi = new Bisect();\\n    let res = 0;\\n    for (let i = 1; i < n; i++) {\\n        let lsum = subArraySum(pre, 0, i - 1), mrSum = subArraySum(pre, i, n - 1); // mid right total sum\\n        let min = bi.bisect_left(pre, 2 * lsum, i + 1); // lower_bound search [low = i+1, end]\\n        let max = bi.bisect_left(pre, parseInt(mrSum / 2) + lsum + 1, i + 1);\\n        max = Math.min(max, n);\\n        let len = max - min;\\n        res += Math.max(0, len);\\n    }\\n    return res % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100921,
                "title": "prefix-sum-2-times-binary-search-little-optimisation-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    \\n    \\n    \\n    int bSearch2(int low , int high , vector<int> &sum )\\n    {\\n        int count = 0;\\n        int rightMostValue = sum[high];\\n        int low_=low;\\n        int mid;\\n        \\n        while(low <= high)\\n        {\\n            mid = (low+high)/2;\\n            \\n            if(mid<=0) return count;\\n            \\n            if(  (rightMostValue - sum[mid-1]) >= sum[mid-1]  )\\n            {\\n                count = max(count , (mid-low_+1));\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int bSearch(int low , int high , vector<int> &sum , int rightSum)\\n    {\\n        int mid;\\n        int rightMostIndex = high;\\n        int lowestIndex = -1;\\n        int count = 0;\\n        \\n        while(low<=high)\\n        {\\n        \\n            mid = (low+high)/2;\\n\\n            \\n            int midSum = sum[rightMostIndex]-sum[mid-1];\\n            int leftSum = sum[mid-1];\\n            \\n            if(midSum>rightSum)low=mid+1;\\n            else\\n            {\\n                if(leftSum<=midSum)\\n                {\\n                    \\n                    if(lowestIndex==-1) lowestIndex = mid;\\n                    else lowestIndex = min(lowestIndex , mid);\\n                    \\n                }\\n                high = mid-1;\\n            }\\n            \\n        }\\n        \\n        if(lowestIndex != -1)count = bSearch2(lowestIndex , rightMostIndex , sum);\\n        return count; \\n    }\\n    int waysToSplit(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> sum(n,0);\\n        \\n        sum[0]=nums[0];\\n        \\n        for(int i=1 ; i<n ; i++)\\n            sum[i]+=(sum[i-1]+nums[i]);\\n        \\n        int count = 0;\\n        \\n        for(int i=n-1 ; i>=2 ; i--)\\n        {\\n            if(i==2)\\n            {\\n                if(nums[0]<=nums[1] && (sum[n-1]-sum[1])>=nums[1]) count++;\\n            }\\n            else count += bSearch(1,i-1,sum,sum[n-1]-sum[i-1]);\\n            \\n            count%=1000000007;\\n        }\\n        \\n        return count;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    \\n    \\n    int bSearch2(int low , int high , vector<int> &sum )\\n    {\\n        int count = 0;\\n        int rightMostValue = sum[high];\\n        int low_=low;\\n        int mid;\\n        \\n        while(low <= high)\\n        {\\n            mid = (low+high)/2;\\n            \\n            if(mid<=0) return count;\\n            \\n            if(  (rightMostValue - sum[mid-1]) >= sum[mid-1]  )\\n            {\\n                count = max(count , (mid-low_+1));\\n                low = mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2074135,
                "title": "python-easy-solution-100",
                "content": "\\t* class Solution:\\n\\t\\tdef waysToSplit(self, nums: List[int]) -> int:      \\n\\t\\t\\tn, MOD = len(nums), 10**9+7\\n\\t\\t\\tarr = [0  for _ in range(n+1)]\\n\\t\\t\\tfor i, val in enumerate(nums, 1):\\n\\t\\t\\t\\tarr[i] = arr[i-1] + val\\n\\t\\t\\t\\t\\n\\t\\t\\tj = k = ans = 0\\n\\t\\t\\tfor i in range(1, n-1):\\n\\t\\t\\t\\tj = max(j, i+1)\\n\\t\\t\\t\\twhile j < n-1 and arr[j]-arr[i] < arr[i]: j += 1\\n\\t\\t\\t\\tk = max(k, j)\\n\\t\\t\\t\\twhile k < n-1 and arr[n]-arr[k+1] >= arr[k+1]-arr[i]: k += 1\\n\\t\\t\\t\\tif arr[i] > arr[j]-arr[i]: break\\n\\t\\t\\t\\tif arr[j]-arr[i] > arr[n]-arr[j]: continue\\n\\t\\t\\t\\tif (ans+k-j+1) > MOD:\\n\\t\\t\\t\\t\\tans=(ans+k-j+1) - MOD;\\n\\t\\t\\t\\telse:                \\n\\t\\t\\t\\t\\tans =(ans+k-j+1)  \\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t* class Solution:\\n\\t\\tdef waysToSplit(self, nums: List[int]) -> int:      \\n\\t\\t\\tn, MOD = len(nums), 10**9+7\\n\\t\\t\\tarr = [0  for _ in range(n+1)]\\n\\t\\t\\tfor i, val in enumerate(nums, 1):\\n\\t\\t\\t\\tarr[i] = arr[i-1] + val\\n\\t\\t\\t\\t\\n\\t\\t\\tj = k = ans = 0\\n\\t\\t\\tfor i in range(1, n-1):\\n\\t\\t\\t\\tj = max(j, i+1)\\n\\t\\t\\t\\twhile j < n-1 and arr[j]-arr[i] < arr[i]: j += 1\\n\\t\\t\\t\\tk = max(k, j)\\n\\t\\t\\t\\twhile k < n-1 and arr[n]-arr[k+1] >= arr[k+1]-arr[i]: k += 1\\n\\t\\t\\t\\tif arr[i] > arr[j]-arr[i]: break\\n\\t\\t\\t\\tif arr[j]-arr[i] > arr[n]-arr[j]: continue\\n\\t\\t\\t\\tif (ans+k-j+1) > MOD:\\n\\t\\t\\t\\t\\tans=(ans+k-j+1) - MOD;\\n\\t\\t\\t\\telse:                \\n\\t\\t\\t\\t\\tans =(ans+k-j+1)  \\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2009810,
                "title": "c-solution",
                "content": "```\\n#define max(a, b) (a > b ? a : b)\\n\\nint waysToSplit(int* nums, int numsSize){\\n    int n = numsSize;\\n    for(int i = 1; i < n; i++)\\n        nums[i] += nums[i - 1];\\n    int left  = 0, mid = 1, right = 2, count = 0;\\n    while(left < n - 2)\\n    {\\n        mid = max(mid, left + 1);\\n        while(mid < n - 1 && nums[mid] < 2 * nums[left])\\n            mid++;\\n        right = max(mid, right);\\n        while(right < n - 1 && nums[right] - nums[left] <= nums[n - 1] - nums[right])\\n            right++;\\n        count = (count + right - mid) % 1000000007;\\n        left++;\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define max(a, b) (a > b ? a : b)\\n\\nint waysToSplit(int* nums, int numsSize){\\n    int n = numsSize;\\n    for(int i = 1; i < n; i++)\\n        nums[i] += nums[i - 1];\\n    int left  = 0, mid = 1, right = 2, count = 0;\\n    while(left < n - 2)\\n    {\\n        mid = max(mid, left + 1);\\n        while(mid < n - 1 && nums[mid] < 2 * nums[left])\\n            mid++;\\n        right = max(mid, right);\\n        while(right < n - 1 && nums[right] - nums[left] <= nums[n - 1] - nums[right])\\n            right++;\\n        count = (count + right - mid) % 1000000007;\\n        left++;\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987215,
                "title": "easiest-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        presum = [0 for i in range(n)]\\n        presum[0] = nums[0]\\n        for i in range(1,n):\\n            presum[i] = presum[i-1] + nums[i]\\n            \\n        ans = 0\\n        mod = int(1e9+7)\\n        ts = presum[-1]\\n        for i in range(n-2):\\n            ways = self.count(i,nums,presum,ts)\\n            ans += ways\\n        return ans%mod\\n    \\n    def count(self,s,nums,ps,ts):\\n        l = s + 1\\n        u = len(nums)-1\\n        ans = 0\\n        while l <= u:\\n            mid = (l+u) >> 1\\n            #print(\"mid is\", mid)\\n            midsum = ps[mid] - ps[s]\\n            rightrsum = ts - ps[mid]\\n            if midsum <= rightrsum and midsum >= ps[s]:\\n                ans = mid\\n                #print(mid)\\n                l = mid+1\\n            elif midsum > rightrsum:\\n                u = mid-1\\n            else:\\n                l = mid+1\\n        if ans == len(nums)-1:       # Base case for handling all zeros\\n            ans -= 1\\n        if ans == 0:return 0\\n        minidx = s+1\\n        l = s+1\\n        u = ans\\n        while l <= u:\\n            mid = (l+u) >> 1\\n            midsum = ps[mid] - ps[s]\\n            if midsum >= ps[s]:\\n                minidx = mid\\n                u = mid-1\\n            else:\\n                l = mid+1\\n        return ans - minidx + 1",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        presum = [0 for i in range(n)]\\n        presum[0] = nums[0]\\n        for i in range(1,n):\\n            presum[i] = presum[i-1] + nums[i]\\n            \\n        ans = 0\\n        mod = int(1e9+7)\\n        ts = presum[-1]\\n        for i in range(n-2):\\n            ways = self.count(i,nums,presum,ts)\\n            ans += ways\\n        return ans%mod\\n    \\n    def count(self,s,nums,ps,ts):\\n        l = s + 1\\n        u = len(nums)-1\\n        ans = 0\\n        while l <= u:\\n            mid = (l+u) >> 1\\n            #print(\"mid is\", mid)\\n            midsum = ps[mid] - ps[s]\\n            rightrsum = ts - ps[mid]\\n            if midsum <= rightrsum and midsum >= ps[s]:\\n                ans = mid\\n                #print(mid)\\n                l = mid+1\\n            elif midsum > rightrsum:\\n                u = mid-1\\n            else:\\n                l = mid+1\\n        if ans == len(nums)-1:       # Base case for handling all zeros\\n            ans -= 1\\n        if ans == 0:return 0\\n        minidx = s+1\\n        l = s+1\\n        u = ans\\n        while l <= u:\\n            mid = (l+u) >> 1\\n            midsum = ps[mid] - ps[s]\\n            if midsum >= ps[s]:\\n                minidx = mid\\n                u = mid-1\\n            else:\\n                l = mid+1\\n        return ans - minidx + 1",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570283,
                "content": [
                    {
                        "username": "banty",
                        "content": "IMO the difficulty level is not justified. It would be really hard for me to come up with Binary search solution in an interview"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "My code passed 85/88 testcases, I am getting wrong answer in one of test case where all the elements are zero. I don\\'t understand why my code fails, can anyone figure it out why the below code fails, when all the values are zero. Please suggest necessary modifications.\\n```\\nclass Solution {\\nprivate :\\n   int binarySearch(vector<int> &prefix,int ind,bool flag)\\n   {\\n       int n = prefix.size();\\n       int low = ind+1,high = n-1,ans = -1;\\n       int leftSum,midSum,rightSum,mid;\\n       while(low <= high)\\n       {\\n           mid = low + (high - low)/2;\\n           leftSum = prefix[ind];\\n           midSum = prefix[mid] - prefix[ind];\\n           rightSum = prefix[n-1] - prefix[mid];\\n           if( midSum < leftSum) low = mid+1;\\n           else if( rightSum < midSum) high = mid-1;\\n           else \\n           {\\n               ans = mid;\\n               flag ? high = mid-1 : low = mid+1;\\n           }\\n       }\\n       return ans;\\n   } \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n           prefix[i] = prefix[i-1] + nums[i];\\n        int validSplits = 0, mod = 1e9 +7;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int first = binarySearch(prefix,i,true);\\n            int last = binarySearch(prefix,i,false);\\n            if(first == -1 || last == -1) continue;\\n            else \\n               validSplits = (validSplits + (last - first + 1))%mod;\\n        }\\n        return validSplits;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@nganhanh911](/nganhanh911) Many Thanks, what a stupid mistake I made. "
                    },
                    {
                        "username": "nganhanh911",
                        "content": "For the binarySearch function, high should be n-2 instead of n-1 because you are finding the middle position, which cannot be at n-1. "
                    },
                    {
                        "username": "Tim_P",
                        "content": "Hi guys,\\n\\nHow much time should it take me to think and write this during an interview?\\nIs it a reasonable question for an interview? Do you thin it\\'s really of \"medium\" difficulty?\\n\\nI got to an O(n^2) solution relatively quickly, but it exceeded the time limit.\\nI couldn\\'t come up with a better solution, so I\\'ve read the hints, and giving it another try, but I have to admit I\\'m struggling with it   :("
                    },
                    {
                        "username": "sumdeb",
                        "content": "This should be a hard problem and not really an ideal thing to ask in an interview. "
                    },
                    {
                        "username": "Getafix",
                        "content": "C++ using bounds on a sorted cumulative sum array\n ```class Solution {\npublic:\n    int waysToSplit(vector<int>& nums) {\n        vector<int>sums(nums.size());\n        int total = 0;\n        for(int i= 0; i< nums.size(); i++){\n          total += nums[i]; \n          sums[i] = total;\n        }\n        int ret = 0;\n        int M = 1000000007;\n        for(int p=0; p<sums.size(); p++){\n          int X = sums[p];\n          auto it = lower_bound(sums.begin()+p+1,sums.end(), 2*X);\n          int rem = (total - sums[p])/2;\n          auto it2 = upper_bound(it,sums.end()-1, X+rem);\n          int d1 = distance(it,sums.end()), d2 = distance(it2,sums.end());\n          if(d1 > d2)ret = (ret + d1-d2)%M;\n        }\n        return ret ;\n    }\n};```"
                    },
                    {
                        "username": "wxzhang3",
                        "content": "Hi everyone, when I tried to solve this problem using code as follows, before the shile loop, I drirectly assign object j=i+1 and k=j,the code is LTE, but if I assigned j and k=0 at the start and change the first while to: while j<=i or  (j<n-1 and 2*preSum[i]>preSum[j]) and the second while condition to: \\nwhile k<j or (k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]), it is acceptted. Does anyone know what happened here?  Thanks a lot!\\n        res=0\\n        n=len(nums)\\n        preSum=list(accumulate(nums))\\n        j=0\\n        k=0\\n        for i in range(n-2):\\n            j=i+1\\n            while j<n-1 and 2*preSum[i]>preSum[j]:\\n                j+=1\\n             k=j\\n            while k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]:\\n                k+=1\\n            res=(res+k-j)%(10**9+7)\\n\\n        \\n        return res"
                    }
                ]
            },
            {
                "id": 1694020,
                "content": [
                    {
                        "username": "banty",
                        "content": "IMO the difficulty level is not justified. It would be really hard for me to come up with Binary search solution in an interview"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "My code passed 85/88 testcases, I am getting wrong answer in one of test case where all the elements are zero. I don\\'t understand why my code fails, can anyone figure it out why the below code fails, when all the values are zero. Please suggest necessary modifications.\\n```\\nclass Solution {\\nprivate :\\n   int binarySearch(vector<int> &prefix,int ind,bool flag)\\n   {\\n       int n = prefix.size();\\n       int low = ind+1,high = n-1,ans = -1;\\n       int leftSum,midSum,rightSum,mid;\\n       while(low <= high)\\n       {\\n           mid = low + (high - low)/2;\\n           leftSum = prefix[ind];\\n           midSum = prefix[mid] - prefix[ind];\\n           rightSum = prefix[n-1] - prefix[mid];\\n           if( midSum < leftSum) low = mid+1;\\n           else if( rightSum < midSum) high = mid-1;\\n           else \\n           {\\n               ans = mid;\\n               flag ? high = mid-1 : low = mid+1;\\n           }\\n       }\\n       return ans;\\n   } \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n           prefix[i] = prefix[i-1] + nums[i];\\n        int validSplits = 0, mod = 1e9 +7;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int first = binarySearch(prefix,i,true);\\n            int last = binarySearch(prefix,i,false);\\n            if(first == -1 || last == -1) continue;\\n            else \\n               validSplits = (validSplits + (last - first + 1))%mod;\\n        }\\n        return validSplits;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@nganhanh911](/nganhanh911) Many Thanks, what a stupid mistake I made. "
                    },
                    {
                        "username": "nganhanh911",
                        "content": "For the binarySearch function, high should be n-2 instead of n-1 because you are finding the middle position, which cannot be at n-1. "
                    },
                    {
                        "username": "Tim_P",
                        "content": "Hi guys,\\n\\nHow much time should it take me to think and write this during an interview?\\nIs it a reasonable question for an interview? Do you thin it\\'s really of \"medium\" difficulty?\\n\\nI got to an O(n^2) solution relatively quickly, but it exceeded the time limit.\\nI couldn\\'t come up with a better solution, so I\\'ve read the hints, and giving it another try, but I have to admit I\\'m struggling with it   :("
                    },
                    {
                        "username": "sumdeb",
                        "content": "This should be a hard problem and not really an ideal thing to ask in an interview. "
                    },
                    {
                        "username": "Getafix",
                        "content": "C++ using bounds on a sorted cumulative sum array\n ```class Solution {\npublic:\n    int waysToSplit(vector<int>& nums) {\n        vector<int>sums(nums.size());\n        int total = 0;\n        for(int i= 0; i< nums.size(); i++){\n          total += nums[i]; \n          sums[i] = total;\n        }\n        int ret = 0;\n        int M = 1000000007;\n        for(int p=0; p<sums.size(); p++){\n          int X = sums[p];\n          auto it = lower_bound(sums.begin()+p+1,sums.end(), 2*X);\n          int rem = (total - sums[p])/2;\n          auto it2 = upper_bound(it,sums.end()-1, X+rem);\n          int d1 = distance(it,sums.end()), d2 = distance(it2,sums.end());\n          if(d1 > d2)ret = (ret + d1-d2)%M;\n        }\n        return ret ;\n    }\n};```"
                    },
                    {
                        "username": "wxzhang3",
                        "content": "Hi everyone, when I tried to solve this problem using code as follows, before the shile loop, I drirectly assign object j=i+1 and k=j,the code is LTE, but if I assigned j and k=0 at the start and change the first while to: while j<=i or  (j<n-1 and 2*preSum[i]>preSum[j]) and the second while condition to: \\nwhile k<j or (k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]), it is acceptted. Does anyone know what happened here?  Thanks a lot!\\n        res=0\\n        n=len(nums)\\n        preSum=list(accumulate(nums))\\n        j=0\\n        k=0\\n        for i in range(n-2):\\n            j=i+1\\n            while j<n-1 and 2*preSum[i]>preSum[j]:\\n                j+=1\\n             k=j\\n            while k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]:\\n                k+=1\\n            res=(res+k-j)%(10**9+7)\\n\\n        \\n        return res"
                    }
                ]
            },
            {
                "id": 1652477,
                "content": [
                    {
                        "username": "banty",
                        "content": "IMO the difficulty level is not justified. It would be really hard for me to come up with Binary search solution in an interview"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "My code passed 85/88 testcases, I am getting wrong answer in one of test case where all the elements are zero. I don\\'t understand why my code fails, can anyone figure it out why the below code fails, when all the values are zero. Please suggest necessary modifications.\\n```\\nclass Solution {\\nprivate :\\n   int binarySearch(vector<int> &prefix,int ind,bool flag)\\n   {\\n       int n = prefix.size();\\n       int low = ind+1,high = n-1,ans = -1;\\n       int leftSum,midSum,rightSum,mid;\\n       while(low <= high)\\n       {\\n           mid = low + (high - low)/2;\\n           leftSum = prefix[ind];\\n           midSum = prefix[mid] - prefix[ind];\\n           rightSum = prefix[n-1] - prefix[mid];\\n           if( midSum < leftSum) low = mid+1;\\n           else if( rightSum < midSum) high = mid-1;\\n           else \\n           {\\n               ans = mid;\\n               flag ? high = mid-1 : low = mid+1;\\n           }\\n       }\\n       return ans;\\n   } \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n           prefix[i] = prefix[i-1] + nums[i];\\n        int validSplits = 0, mod = 1e9 +7;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int first = binarySearch(prefix,i,true);\\n            int last = binarySearch(prefix,i,false);\\n            if(first == -1 || last == -1) continue;\\n            else \\n               validSplits = (validSplits + (last - first + 1))%mod;\\n        }\\n        return validSplits;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@nganhanh911](/nganhanh911) Many Thanks, what a stupid mistake I made. "
                    },
                    {
                        "username": "nganhanh911",
                        "content": "For the binarySearch function, high should be n-2 instead of n-1 because you are finding the middle position, which cannot be at n-1. "
                    },
                    {
                        "username": "Tim_P",
                        "content": "Hi guys,\\n\\nHow much time should it take me to think and write this during an interview?\\nIs it a reasonable question for an interview? Do you thin it\\'s really of \"medium\" difficulty?\\n\\nI got to an O(n^2) solution relatively quickly, but it exceeded the time limit.\\nI couldn\\'t come up with a better solution, so I\\'ve read the hints, and giving it another try, but I have to admit I\\'m struggling with it   :("
                    },
                    {
                        "username": "sumdeb",
                        "content": "This should be a hard problem and not really an ideal thing to ask in an interview. "
                    },
                    {
                        "username": "Getafix",
                        "content": "C++ using bounds on a sorted cumulative sum array\n ```class Solution {\npublic:\n    int waysToSplit(vector<int>& nums) {\n        vector<int>sums(nums.size());\n        int total = 0;\n        for(int i= 0; i< nums.size(); i++){\n          total += nums[i]; \n          sums[i] = total;\n        }\n        int ret = 0;\n        int M = 1000000007;\n        for(int p=0; p<sums.size(); p++){\n          int X = sums[p];\n          auto it = lower_bound(sums.begin()+p+1,sums.end(), 2*X);\n          int rem = (total - sums[p])/2;\n          auto it2 = upper_bound(it,sums.end()-1, X+rem);\n          int d1 = distance(it,sums.end()), d2 = distance(it2,sums.end());\n          if(d1 > d2)ret = (ret + d1-d2)%M;\n        }\n        return ret ;\n    }\n};```"
                    },
                    {
                        "username": "wxzhang3",
                        "content": "Hi everyone, when I tried to solve this problem using code as follows, before the shile loop, I drirectly assign object j=i+1 and k=j,the code is LTE, but if I assigned j and k=0 at the start and change the first while to: while j<=i or  (j<n-1 and 2*preSum[i]>preSum[j]) and the second while condition to: \\nwhile k<j or (k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]), it is acceptted. Does anyone know what happened here?  Thanks a lot!\\n        res=0\\n        n=len(nums)\\n        preSum=list(accumulate(nums))\\n        j=0\\n        k=0\\n        for i in range(n-2):\\n            j=i+1\\n            while j<n-1 and 2*preSum[i]>preSum[j]:\\n                j+=1\\n             k=j\\n            while k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]:\\n                k+=1\\n            res=(res+k-j)%(10**9+7)\\n\\n        \\n        return res"
                    }
                ]
            },
            {
                "id": 1575561,
                "content": [
                    {
                        "username": "banty",
                        "content": "IMO the difficulty level is not justified. It would be really hard for me to come up with Binary search solution in an interview"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "My code passed 85/88 testcases, I am getting wrong answer in one of test case where all the elements are zero. I don\\'t understand why my code fails, can anyone figure it out why the below code fails, when all the values are zero. Please suggest necessary modifications.\\n```\\nclass Solution {\\nprivate :\\n   int binarySearch(vector<int> &prefix,int ind,bool flag)\\n   {\\n       int n = prefix.size();\\n       int low = ind+1,high = n-1,ans = -1;\\n       int leftSum,midSum,rightSum,mid;\\n       while(low <= high)\\n       {\\n           mid = low + (high - low)/2;\\n           leftSum = prefix[ind];\\n           midSum = prefix[mid] - prefix[ind];\\n           rightSum = prefix[n-1] - prefix[mid];\\n           if( midSum < leftSum) low = mid+1;\\n           else if( rightSum < midSum) high = mid-1;\\n           else \\n           {\\n               ans = mid;\\n               flag ? high = mid-1 : low = mid+1;\\n           }\\n       }\\n       return ans;\\n   } \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n           prefix[i] = prefix[i-1] + nums[i];\\n        int validSplits = 0, mod = 1e9 +7;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int first = binarySearch(prefix,i,true);\\n            int last = binarySearch(prefix,i,false);\\n            if(first == -1 || last == -1) continue;\\n            else \\n               validSplits = (validSplits + (last - first + 1))%mod;\\n        }\\n        return validSplits;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@nganhanh911](/nganhanh911) Many Thanks, what a stupid mistake I made. "
                    },
                    {
                        "username": "nganhanh911",
                        "content": "For the binarySearch function, high should be n-2 instead of n-1 because you are finding the middle position, which cannot be at n-1. "
                    },
                    {
                        "username": "Tim_P",
                        "content": "Hi guys,\\n\\nHow much time should it take me to think and write this during an interview?\\nIs it a reasonable question for an interview? Do you thin it\\'s really of \"medium\" difficulty?\\n\\nI got to an O(n^2) solution relatively quickly, but it exceeded the time limit.\\nI couldn\\'t come up with a better solution, so I\\'ve read the hints, and giving it another try, but I have to admit I\\'m struggling with it   :("
                    },
                    {
                        "username": "sumdeb",
                        "content": "This should be a hard problem and not really an ideal thing to ask in an interview. "
                    },
                    {
                        "username": "Getafix",
                        "content": "C++ using bounds on a sorted cumulative sum array\n ```class Solution {\npublic:\n    int waysToSplit(vector<int>& nums) {\n        vector<int>sums(nums.size());\n        int total = 0;\n        for(int i= 0; i< nums.size(); i++){\n          total += nums[i]; \n          sums[i] = total;\n        }\n        int ret = 0;\n        int M = 1000000007;\n        for(int p=0; p<sums.size(); p++){\n          int X = sums[p];\n          auto it = lower_bound(sums.begin()+p+1,sums.end(), 2*X);\n          int rem = (total - sums[p])/2;\n          auto it2 = upper_bound(it,sums.end()-1, X+rem);\n          int d1 = distance(it,sums.end()), d2 = distance(it2,sums.end());\n          if(d1 > d2)ret = (ret + d1-d2)%M;\n        }\n        return ret ;\n    }\n};```"
                    },
                    {
                        "username": "wxzhang3",
                        "content": "Hi everyone, when I tried to solve this problem using code as follows, before the shile loop, I drirectly assign object j=i+1 and k=j,the code is LTE, but if I assigned j and k=0 at the start and change the first while to: while j<=i or  (j<n-1 and 2*preSum[i]>preSum[j]) and the second while condition to: \\nwhile k<j or (k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]), it is acceptted. Does anyone know what happened here?  Thanks a lot!\\n        res=0\\n        n=len(nums)\\n        preSum=list(accumulate(nums))\\n        j=0\\n        k=0\\n        for i in range(n-2):\\n            j=i+1\\n            while j<n-1 and 2*preSum[i]>preSum[j]:\\n                j+=1\\n             k=j\\n            while k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]:\\n                k+=1\\n            res=(res+k-j)%(10**9+7)\\n\\n        \\n        return res"
                    }
                ]
            },
            {
                "id": 1991764,
                "content": [
                    {
                        "username": "banty",
                        "content": "IMO the difficulty level is not justified. It would be really hard for me to come up with Binary search solution in an interview"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "My code passed 85/88 testcases, I am getting wrong answer in one of test case where all the elements are zero. I don\\'t understand why my code fails, can anyone figure it out why the below code fails, when all the values are zero. Please suggest necessary modifications.\\n```\\nclass Solution {\\nprivate :\\n   int binarySearch(vector<int> &prefix,int ind,bool flag)\\n   {\\n       int n = prefix.size();\\n       int low = ind+1,high = n-1,ans = -1;\\n       int leftSum,midSum,rightSum,mid;\\n       while(low <= high)\\n       {\\n           mid = low + (high - low)/2;\\n           leftSum = prefix[ind];\\n           midSum = prefix[mid] - prefix[ind];\\n           rightSum = prefix[n-1] - prefix[mid];\\n           if( midSum < leftSum) low = mid+1;\\n           else if( rightSum < midSum) high = mid-1;\\n           else \\n           {\\n               ans = mid;\\n               flag ? high = mid-1 : low = mid+1;\\n           }\\n       }\\n       return ans;\\n   } \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n           prefix[i] = prefix[i-1] + nums[i];\\n        int validSplits = 0, mod = 1e9 +7;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int first = binarySearch(prefix,i,true);\\n            int last = binarySearch(prefix,i,false);\\n            if(first == -1 || last == -1) continue;\\n            else \\n               validSplits = (validSplits + (last - first + 1))%mod;\\n        }\\n        return validSplits;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@nganhanh911](/nganhanh911) Many Thanks, what a stupid mistake I made. "
                    },
                    {
                        "username": "nganhanh911",
                        "content": "For the binarySearch function, high should be n-2 instead of n-1 because you are finding the middle position, which cannot be at n-1. "
                    },
                    {
                        "username": "Tim_P",
                        "content": "Hi guys,\\n\\nHow much time should it take me to think and write this during an interview?\\nIs it a reasonable question for an interview? Do you thin it\\'s really of \"medium\" difficulty?\\n\\nI got to an O(n^2) solution relatively quickly, but it exceeded the time limit.\\nI couldn\\'t come up with a better solution, so I\\'ve read the hints, and giving it another try, but I have to admit I\\'m struggling with it   :("
                    },
                    {
                        "username": "sumdeb",
                        "content": "This should be a hard problem and not really an ideal thing to ask in an interview. "
                    },
                    {
                        "username": "Getafix",
                        "content": "C++ using bounds on a sorted cumulative sum array\n ```class Solution {\npublic:\n    int waysToSplit(vector<int>& nums) {\n        vector<int>sums(nums.size());\n        int total = 0;\n        for(int i= 0; i< nums.size(); i++){\n          total += nums[i]; \n          sums[i] = total;\n        }\n        int ret = 0;\n        int M = 1000000007;\n        for(int p=0; p<sums.size(); p++){\n          int X = sums[p];\n          auto it = lower_bound(sums.begin()+p+1,sums.end(), 2*X);\n          int rem = (total - sums[p])/2;\n          auto it2 = upper_bound(it,sums.end()-1, X+rem);\n          int d1 = distance(it,sums.end()), d2 = distance(it2,sums.end());\n          if(d1 > d2)ret = (ret + d1-d2)%M;\n        }\n        return ret ;\n    }\n};```"
                    },
                    {
                        "username": "wxzhang3",
                        "content": "Hi everyone, when I tried to solve this problem using code as follows, before the shile loop, I drirectly assign object j=i+1 and k=j,the code is LTE, but if I assigned j and k=0 at the start and change the first while to: while j<=i or  (j<n-1 and 2*preSum[i]>preSum[j]) and the second while condition to: \\nwhile k<j or (k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]), it is acceptted. Does anyone know what happened here?  Thanks a lot!\\n        res=0\\n        n=len(nums)\\n        preSum=list(accumulate(nums))\\n        j=0\\n        k=0\\n        for i in range(n-2):\\n            j=i+1\\n            while j<n-1 and 2*preSum[i]>preSum[j]:\\n                j+=1\\n             k=j\\n            while k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]:\\n                k+=1\\n            res=(res+k-j)%(10**9+7)\\n\\n        \\n        return res"
                    }
                ]
            },
            {
                "id": 1738943,
                "content": [
                    {
                        "username": "banty",
                        "content": "IMO the difficulty level is not justified. It would be really hard for me to come up with Binary search solution in an interview"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "My code passed 85/88 testcases, I am getting wrong answer in one of test case where all the elements are zero. I don\\'t understand why my code fails, can anyone figure it out why the below code fails, when all the values are zero. Please suggest necessary modifications.\\n```\\nclass Solution {\\nprivate :\\n   int binarySearch(vector<int> &prefix,int ind,bool flag)\\n   {\\n       int n = prefix.size();\\n       int low = ind+1,high = n-1,ans = -1;\\n       int leftSum,midSum,rightSum,mid;\\n       while(low <= high)\\n       {\\n           mid = low + (high - low)/2;\\n           leftSum = prefix[ind];\\n           midSum = prefix[mid] - prefix[ind];\\n           rightSum = prefix[n-1] - prefix[mid];\\n           if( midSum < leftSum) low = mid+1;\\n           else if( rightSum < midSum) high = mid-1;\\n           else \\n           {\\n               ans = mid;\\n               flag ? high = mid-1 : low = mid+1;\\n           }\\n       }\\n       return ans;\\n   } \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n           prefix[i] = prefix[i-1] + nums[i];\\n        int validSplits = 0, mod = 1e9 +7;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int first = binarySearch(prefix,i,true);\\n            int last = binarySearch(prefix,i,false);\\n            if(first == -1 || last == -1) continue;\\n            else \\n               validSplits = (validSplits + (last - first + 1))%mod;\\n        }\\n        return validSplits;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@nganhanh911](/nganhanh911) Many Thanks, what a stupid mistake I made. "
                    },
                    {
                        "username": "nganhanh911",
                        "content": "For the binarySearch function, high should be n-2 instead of n-1 because you are finding the middle position, which cannot be at n-1. "
                    },
                    {
                        "username": "Tim_P",
                        "content": "Hi guys,\\n\\nHow much time should it take me to think and write this during an interview?\\nIs it a reasonable question for an interview? Do you thin it\\'s really of \"medium\" difficulty?\\n\\nI got to an O(n^2) solution relatively quickly, but it exceeded the time limit.\\nI couldn\\'t come up with a better solution, so I\\'ve read the hints, and giving it another try, but I have to admit I\\'m struggling with it   :("
                    },
                    {
                        "username": "sumdeb",
                        "content": "This should be a hard problem and not really an ideal thing to ask in an interview. "
                    },
                    {
                        "username": "Getafix",
                        "content": "C++ using bounds on a sorted cumulative sum array\n ```class Solution {\npublic:\n    int waysToSplit(vector<int>& nums) {\n        vector<int>sums(nums.size());\n        int total = 0;\n        for(int i= 0; i< nums.size(); i++){\n          total += nums[i]; \n          sums[i] = total;\n        }\n        int ret = 0;\n        int M = 1000000007;\n        for(int p=0; p<sums.size(); p++){\n          int X = sums[p];\n          auto it = lower_bound(sums.begin()+p+1,sums.end(), 2*X);\n          int rem = (total - sums[p])/2;\n          auto it2 = upper_bound(it,sums.end()-1, X+rem);\n          int d1 = distance(it,sums.end()), d2 = distance(it2,sums.end());\n          if(d1 > d2)ret = (ret + d1-d2)%M;\n        }\n        return ret ;\n    }\n};```"
                    },
                    {
                        "username": "wxzhang3",
                        "content": "Hi everyone, when I tried to solve this problem using code as follows, before the shile loop, I drirectly assign object j=i+1 and k=j,the code is LTE, but if I assigned j and k=0 at the start and change the first while to: while j<=i or  (j<n-1 and 2*preSum[i]>preSum[j]) and the second while condition to: \\nwhile k<j or (k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]), it is acceptted. Does anyone know what happened here?  Thanks a lot!\\n        res=0\\n        n=len(nums)\\n        preSum=list(accumulate(nums))\\n        j=0\\n        k=0\\n        for i in range(n-2):\\n            j=i+1\\n            while j<n-1 and 2*preSum[i]>preSum[j]:\\n                j+=1\\n             k=j\\n            while k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]:\\n                k+=1\\n            res=(res+k-j)%(10**9+7)\\n\\n        \\n        return res"
                    }
                ]
            },
            {
                "id": 1711488,
                "content": [
                    {
                        "username": "banty",
                        "content": "IMO the difficulty level is not justified. It would be really hard for me to come up with Binary search solution in an interview"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "First start with creating a prefix sum array.\\nOur aim to to split array into two parts in sucah a way that sums of the three parts are non decreasing.\\nWe are using for loop to make the partition of the firs part, and then using binary search to find the max and min 2nd seperation that will sastify the condition.\\n\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int waysToSplit(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=1;i<n;i++) arr[i]+=arr[i-1]; // creating the prefix sum array\\n    int ans=0;\\n    for(int i=0;i<n-2;i++){ // for loop for making the first partition\\n        int a=arr[i],mx=-1,mn=-1;\\n        int l=i+1,r=n-2;\\n        while(l<=r){ // binary search to find the max 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mx=m;\\n                    l=m+1;\\n                }\\n                else l=m+1;\\n            }\\n        }\\n        l = i+1; r=n-2;\\n         while(l<=r){ // binary search to find the min 2nd partition \\n            int m= l +(r-l)/2;\\n            if(arr[m]-a > arr[n-1]-arr[m]){\\n                r=m-1;\\n            }\\n            else{\\n                if(arr[m]-a >= a){\\n                    mn=m;\\n                    r=m-1;\\n                }\\n                else l = m+1;\\n            }\\n        }\\n        if(mx!=-1 and mn!=-1) ans+=(mx-mn+1); \\n\\t\\t/* any length of 2nd partion between \\n\\t\\tmx and mn will satisfy this condition, \\n\\t\\ttotal number of ways is (mx-mn+1);*/\\n\\t\\t\\n        ans%=mod;\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "My code passed 85/88 testcases, I am getting wrong answer in one of test case where all the elements are zero. I don\\'t understand why my code fails, can anyone figure it out why the below code fails, when all the values are zero. Please suggest necessary modifications.\\n```\\nclass Solution {\\nprivate :\\n   int binarySearch(vector<int> &prefix,int ind,bool flag)\\n   {\\n       int n = prefix.size();\\n       int low = ind+1,high = n-1,ans = -1;\\n       int leftSum,midSum,rightSum,mid;\\n       while(low <= high)\\n       {\\n           mid = low + (high - low)/2;\\n           leftSum = prefix[ind];\\n           midSum = prefix[mid] - prefix[ind];\\n           rightSum = prefix[n-1] - prefix[mid];\\n           if( midSum < leftSum) low = mid+1;\\n           else if( rightSum < midSum) high = mid-1;\\n           else \\n           {\\n               ans = mid;\\n               flag ? high = mid-1 : low = mid+1;\\n           }\\n       }\\n       return ans;\\n   } \\npublic:\\n    int waysToSplit(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix(n);\\n        prefix[0] = nums[0];\\n        for(int i=1; i<n; i++)\\n           prefix[i] = prefix[i-1] + nums[i];\\n        int validSplits = 0, mod = 1e9 +7;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int first = binarySearch(prefix,i,true);\\n            int last = binarySearch(prefix,i,false);\\n            if(first == -1 || last == -1) continue;\\n            else \\n               validSplits = (validSplits + (last - first + 1))%mod;\\n        }\\n        return validSplits;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@nganhanh911](/nganhanh911) Many Thanks, what a stupid mistake I made. "
                    },
                    {
                        "username": "nganhanh911",
                        "content": "For the binarySearch function, high should be n-2 instead of n-1 because you are finding the middle position, which cannot be at n-1. "
                    },
                    {
                        "username": "Tim_P",
                        "content": "Hi guys,\\n\\nHow much time should it take me to think and write this during an interview?\\nIs it a reasonable question for an interview? Do you thin it\\'s really of \"medium\" difficulty?\\n\\nI got to an O(n^2) solution relatively quickly, but it exceeded the time limit.\\nI couldn\\'t come up with a better solution, so I\\'ve read the hints, and giving it another try, but I have to admit I\\'m struggling with it   :("
                    },
                    {
                        "username": "sumdeb",
                        "content": "This should be a hard problem and not really an ideal thing to ask in an interview. "
                    },
                    {
                        "username": "Getafix",
                        "content": "C++ using bounds on a sorted cumulative sum array\n ```class Solution {\npublic:\n    int waysToSplit(vector<int>& nums) {\n        vector<int>sums(nums.size());\n        int total = 0;\n        for(int i= 0; i< nums.size(); i++){\n          total += nums[i]; \n          sums[i] = total;\n        }\n        int ret = 0;\n        int M = 1000000007;\n        for(int p=0; p<sums.size(); p++){\n          int X = sums[p];\n          auto it = lower_bound(sums.begin()+p+1,sums.end(), 2*X);\n          int rem = (total - sums[p])/2;\n          auto it2 = upper_bound(it,sums.end()-1, X+rem);\n          int d1 = distance(it,sums.end()), d2 = distance(it2,sums.end());\n          if(d1 > d2)ret = (ret + d1-d2)%M;\n        }\n        return ret ;\n    }\n};```"
                    },
                    {
                        "username": "wxzhang3",
                        "content": "Hi everyone, when I tried to solve this problem using code as follows, before the shile loop, I drirectly assign object j=i+1 and k=j,the code is LTE, but if I assigned j and k=0 at the start and change the first while to: while j<=i or  (j<n-1 and 2*preSum[i]>preSum[j]) and the second while condition to: \\nwhile k<j or (k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]), it is acceptted. Does anyone know what happened here?  Thanks a lot!\\n        res=0\\n        n=len(nums)\\n        preSum=list(accumulate(nums))\\n        j=0\\n        k=0\\n        for i in range(n-2):\\n            j=i+1\\n            while j<n-1 and 2*preSum[i]>preSum[j]:\\n                j+=1\\n             k=j\\n            while k<n-1 and preSum[-1]-preSum[k]>=preSum[k]-preSum[i]:\\n                k+=1\\n            res=(res+k-j)%(10**9+7)\\n\\n        \\n        return res"
                    }
                ]
            }
        ]
    }
]