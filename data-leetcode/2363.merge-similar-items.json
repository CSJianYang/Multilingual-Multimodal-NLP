[
    {
        "title": "Merge Similar Items",
        "question_content": "You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:\n\n\titems[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.\n\tThe value of each item in items is unique.\n\nReturn a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.\nNote: ret should be returned in ascending order by value.\n&nbsp;\nExample 1:\n\nInput: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\nOutput: [[1,6],[3,9],[4,5]]\nExplanation: \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.\nThe item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.\nThe item with value = 4 occurs in items1 with weight = 5, total weight = 5.  \nTherefore, we return [[1,6],[3,9],[4,5]].\n\nExample 2:\n\nInput: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\nOutput: [[1,4],[2,4],[3,4]]\nExplanation: \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.\nThe item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.\nThe item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.\nTherefore, we return [[1,4],[2,4],[3,4]].\nExample 3:\n\nInput: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\nOutput: [[1,7],[2,4],[7,1]]\nExplanation:\nThe item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. \nThe item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. \nThe item with value = 7 occurs in items2 with weight = 1, total weight = 1.\nTherefore, we return [[1,7],[2,4],[7,1]].\n\n&nbsp;\nConstraints:\n\n\t1 <= items1.length, items2.length <= 1000\n\titems1[i].length == items2[i].length == 2\n\t1 <= valuei, weighti <= 1000\n\tEach valuei in items1 is unique.\n\tEach valuei in items2 is unique.",
        "solutions": [
            {
                "id": 2388803,
                "title": "c-solution-easy-explanation-using-map",
                "content": "Yr humain kya krna h jo bhi value 1st list main h or 2nd list main unko add krna h or jo kisi ek main  h unko as it is daal dena h \\ntoh hum kya karenge map banayenge value->weight ka jo humain yeh krke de dega \\ntoh phle list ke iteams map main daal do phir items2 se check krlo agar value present h toh uska weight add krdo nai toh as it is map main daal do or end main map se value vector main daalke return  krdo\\n\\n**please do upvote**\\n\\n```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        map<int,int> m;\\n        for(int i=0;i<items1.size();i++)\\n        {\\n            m[items1[i][0]]=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++)\\n        {\\n            if(m.find(items2[i][0])!=m.end())\\n            {\\n                m[items2[i][0]]+=items2[i][1];\\n            }\\n            else\\n            {\\n                m[items2[i][0]]=items2[i][1];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto it : m)\\n        {\\n            ans.push_back({it.first,it.second});\\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        map<int,int> m;\\n        for(int i=0;i<items1.size();i++)\\n        {\\n            m[items1[i][0]]=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++)\\n        {\\n            if(m.find(items2[i][0])!=m.end())\\n            {\\n                m[items2[i][0]]+=items2[i][1];\\n            }\\n            else\\n            {\\n                m[items2[i][0]]=items2[i][1];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto it : m)\\n        {\\n            ans.push_back({it.first,it.second});\\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388276,
                "title": "java-python-3-treemap-w-brief-explanation-and-analysis",
                "content": "Use TreeMap to accumulate the weights of items with same value.\\n\\n```java\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        for (int[] it : items1) {\\n            cnt.merge(it[0], it[1], Integer::sum);\\n        }\\n        for (int[] it : items2) {\\n            cnt.merge(it[0], it[1], Integer::sum);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (var e : cnt.entrySet()) {\\n            ans.add(Arrays.asList(e.getKey(), e.getValue()));\\n        }\\n        return ans;\\n    }\\n```\\n\\nJava 8 Stream code - inspired by **@climberig**\\n\\n```java\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        Stream.of(items1).forEach(item -> cnt.put(item[0], item[1]));\\n        Stream.of(items2).forEach(item -> cnt.merge(item[0], item[1], Integer::sum));\\n        return cnt.entrySet().stream().map(e -> Arrays.asList(e.getKey(), e.getValue())).collect(Collectors.toList());\\n    }\\n```\\n\\n----\\n\\nUse `Counter` to accumulate the weights of items with same value, then sort the `(key value)` mappings.\\n```python\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        cnt = Counter()\\n        for v, w in items1 + items2:\\n            cnt[v] += w\\n        return sorted(cnt.items())\\n```\\n**@stefan4trivia**\\'s very clean code:\\n```python\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        cnt = Counter(dict(items1))\\n        cnt += Counter(dict(items2))\\n        return sorted(cnt.items())\\n```\\n1 liner - inspired by **@stefan4trivia**:\\n\\n```python\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        return sorted((Counter(dict(items1)) + Counter(dict(items2))).items())\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)`, where `n = items1.length + items2.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        for (int[] it : items1) {\\n            cnt.merge(it[0], it[1], Integer::sum);\\n        }\\n        for (int[] it : items2) {\\n            cnt.merge(it[0], it[1], Integer::sum);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (var e : cnt.entrySet()) {\\n            ans.add(Arrays.asList(e.getKey(), e.getValue()));\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        Stream.of(items1).forEach(item -> cnt.put(item[0], item[1]));\\n        Stream.of(items2).forEach(item -> cnt.merge(item[0], item[1], Integer::sum));\\n        return cnt.entrySet().stream().map(e -> Arrays.asList(e.getKey(), e.getValue())).collect(Collectors.toList());\\n    }\\n```\n```python\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        cnt = Counter()\\n        for v, w in items1 + items2:\\n            cnt[v] += w\\n        return sorted(cnt.items())\\n```\n```python\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        cnt = Counter(dict(items1))\\n        cnt += Counter(dict(items2))\\n        return sorted(cnt.items())\\n```\n```python\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        return sorted((Counter(dict(items1)) + Counter(dict(items2))).items())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2388386,
                "title": "count-array-most-easy-java-solution-faster-than-100",
                "content": "```\\npublic List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n         List<List<Integer>> ans=new ArrayList<>();\\n        int count[]=new int[1005];\\n        for(int arr[]:items1) count[arr[0]]+=arr[1];  // treat value as index and  weight as value\\n        for(int arr[]:items2) count[arr[0]]+=arr[1]; // treat value as index and  weight as value\\n        for(int i=0; i<count.length; i++){ if(count[i]==0) continue;\\n\\t\\t\\tans.add(Arrays.asList(i,count[i]));// now just simply add the answer and store value as index and weight as value in pair\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n         List<List<Integer>> ans=new ArrayList<>();\\n        int count[]=new int[1005];\\n        for(int arr[]:items1) count[arr[0]]+=arr[1];  // treat value as index and  weight as value\\n        for(int arr[]:items2) count[arr[0]]+=arr[1]; // treat value as index and  weight as value\\n        for(int i=0; i<count.length; i++){ if(count[i]==0) continue;\\n\\t\\t\\tans.add(Arrays.asList(i,count[i]));// now just simply add the answer and store value as index and weight as value in pair\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3190948,
                "title": "best-2-c-solution-ever-sorting-hash-table-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array + Hash Table(Ordered map).\\n2. Solved using Array + Sorting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN + MlogM), Because we are doing N+M iteration for inserting elements in ordered map\\n    and Ordered map takes logrithmic time for insertion. where N is the size of items1 and M is the size of the\\n    items2.\\n\\n    Space Complexity : O(N+M), Hash Table(Ordered map) space. In worst case if all the elements of both items1\\n    and items2 are different.\\n\\n    Solved using Array + Hash Table(Ordered map).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> output;\\n        map<int, int> map;\\n        for(auto item : items1){\\n            map[item[0]] += item[1];\\n        }\\n        for(auto item : items2){\\n            map[item[0]] += item[1];\\n        }\\n        for(auto item : map){\\n            output.push_back({item.first, item.second});\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN + MlogM), Because sorting of items1 will cost NlogN and sorting of items2 will cost\\n    MlogM. where N is the size of items1 and M is the size of the items2.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> output;\\n        sort(items1.begin(), items1.end());\\n        sort(items2.begin(), items2.end());\\n        int i=0, j=0;\\n        while(i < items1.size() && j < items2.size()){\\n            if(items1[i][0] == items2[j][0]){\\n                output.push_back({items1[i][0], items1[i][1] + items2[j][1]});\\n                i++; j++;\\n            }\\n            else if(items1[i][0] < items2[j][0]){\\n                output.push_back(items1[i]);\\n                i++;\\n            }\\n            else{\\n                output.push_back(items2[j]);\\n                j++;\\n            }\\n        }\\n        while(i < items1.size()){\\n            output.push_back(items1[i]);\\n            i++;\\n        }\\n        while(j < items2.size()){\\n            output.push_back(items2[j]);\\n            j++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN + MlogM), Because we are doing N+M iteration for inserting elements in ordered map\\n    and Ordered map takes logrithmic time for insertion. where N is the size of items1 and M is the size of the\\n    items2.\\n\\n    Space Complexity : O(N+M), Hash Table(Ordered map) space. In worst case if all the elements of both items1\\n    and items2 are different.\\n\\n    Solved using Array + Hash Table(Ordered map).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> output;\\n        map<int, int> map;\\n        for(auto item : items1){\\n            map[item[0]] += item[1];\\n        }\\n        for(auto item : items2){\\n            map[item[0]] += item[1];\\n        }\\n        for(auto item : map){\\n            output.push_back({item.first, item.second});\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN + MlogM), Because sorting of items1 will cost NlogN and sorting of items2 will cost\\n    MlogM. where N is the size of items1 and M is the size of the items2.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> output;\\n        sort(items1.begin(), items1.end());\\n        sort(items2.begin(), items2.end());\\n        int i=0, j=0;\\n        while(i < items1.size() && j < items2.size()){\\n            if(items1[i][0] == items2[j][0]){\\n                output.push_back({items1[i][0], items1[i][1] + items2[j][1]});\\n                i++; j++;\\n            }\\n            else if(items1[i][0] < items2[j][0]){\\n                output.push_back(items1[i]);\\n                i++;\\n            }\\n            else{\\n                output.push_back(items2[j]);\\n                j++;\\n            }\\n        }\\n        while(i < items1.size()){\\n            output.push_back(items1[i]);\\n            i++;\\n        }\\n        while(j < items2.size()){\\n            output.push_back(items2[j]);\\n            j++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391669,
                "title": "java-stream",
                "content": "```\\npublic List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        Stream.of(items1, items2)\\n                .flatMap(Stream::of)\\n                .forEach(item -> map.put(item[0], map.getOrDefault(item[0], 0) + item[1]));\\n\\n        return map.entrySet().stream()\\n                .map(entry -> List.of(entry.getKey(), entry.getValue()))\\n                .collect(Collectors.toList());\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        Stream.of(items1, items2)\\n                .flatMap(Stream::of)\\n                .forEach(item -> map.put(item[0], map.getOrDefault(item[0], 0) + item[1]));\\n\\n        return map.entrySet().stream()\\n                .map(entry -> List.of(entry.getKey(), entry.getValue()))\\n                .collect(Collectors.toList());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388269,
                "title": "group-by-values-with-intuition",
                "content": "**Intuition**: \\n\\n   Basically the question is telling for grouping `weightsum with their values`.\\n   The above statement gives intuition of using a data structure which uses key value pair. Whats the answer for that??\\n   The answer is yes `map` or `hashmap`. \\n\\t\\n   - So we will just add the add the weights to the weights of their corresponding value as key in map\\n   - Now we need keys in sorted order of values, so we will use map over hashmap.\\n   - Just extract pairs of value and sum of weights in the form of 2D array. \\n\\n# Similar to [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)\\n  \\n# C++   \\n     vector<vector<int>> mergeSimilarItems(vector<vector<int>>& a, vector<vector<int>>& b) {\\n        map<int,int> mp;\\n        for(auto i:a) mp[i[0]]+= i[1];\\n        for(auto i:b) mp[i[0]]+= i[1];\\n        vector<vector<int>> v;\\n        for(auto i:mp) v.push_back({i.first,i.second});\\n        return v;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Intuition**: \\n\\n   Basically the question is telling for grouping `weightsum with their values`.\\n   The above statement gives intuition of using a data structure which uses key value pair. Whats the answer for that??\\n   The answer is yes `map` or `hashmap`. \\n\\t\\n   - So we will just add the add the weights to the weights of their corresponding value as key in map\\n   - Now we need keys in sorted order of values, so we will use map over hashmap.\\n   - Just extract pairs of value and sum of weights in the form of 2D array. \\n\\n# Similar to [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)\\n  \\n# C++   \\n     vector<vector<int>> mergeSimilarItems(vector<vector<int>>& a, vector<vector<int>>& b) {\\n        map<int,int> mp;\\n        for(auto i:a) mp[i[0]]+= i[1];\\n        for(auto i:b) mp[i[0]]+= i[1];\\n        vector<vector<int>> v;\\n        for(auto i:mp) v.push_back({i.first,i.second});\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2388802,
                "title": "python-simple-python-solution-using-hashmap",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 138 ms, faster than 15.38% of Python3 online submissions for Merge Similar Items.\\n# Memory Usage: 14.8 MB, less than 53.85% of Python3 online submissions for Merge Similar Items.\\n\\n\\tclass Solution:\\n\\t\\tdef mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n\\n\\t\\t\\tmerge_item = items1 + items2\\n\\n\\t\\t\\td = defaultdict(int)\\n\\n\\t\\t\\tfor i in merge_item:\\n\\t\\t\\t\\tvalue,weight = i\\n\\t\\t\\t\\td[value] = d[value] + weight\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor j in sorted(d):\\n\\t\\t\\t\\tresult.append([j,d[j]])\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 138 ms, faster than 15.38% of Python3 online submissions for Merge Similar Items.\\n# Memory Usage: 14.8 MB, less than 53.85% of Python3 online submissions for Merge Similar Items.\\n\\n\\tclass Solution:\\n\\t\\tdef mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n\\n\\t\\t\\tmerge_item = items1 + items2\\n\\n\\t\\t\\td = defaultdict(int)\\n\\n\\t\\t\\tfor i in merge_item:\\n\\t\\t\\t\\tvalue,weight = i\\n\\t\\t\\t\\td[value] = d[value] + weight\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor j in sorted(d):\\n\\t\\t\\t\\tresult.append([j,d[j]])\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2388677,
                "title": "one-liner",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def mergeSimilarItems(self, i1: List[List[int]], i2: List[List[int]]) -> List[List[int]]:\\n        return sorted((Counter({i[0] : i[1] for i in i1}) + Counter({i[0] : i[1] for i in i2})).items())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def mergeSimilarItems(self, i1: List[List[int]], i2: List[List[int]]) -> List[List[int]]:\\n        return sorted((Counter({i[0] : i[1] for i in i1}) + Counter({i[0] : i[1] for i in i2})).items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388239,
                "title": "java-clean-simple-treemap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        for (var item : items1)\\n            map.put(item[0], item[1]);\\n\\n        for (var item : items2) {\\n            map.putIfAbsent(item[0], 0);\\n            map.put(item[0], map.get(item[0]) + item[1]);\\n        }\\n\\n        for (var item : map.keySet()) {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(item);\\n            list.add(map.get(item));\\n            result.add(list);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        for (var item : items1)\\n            map.put(item[0], item[1]);\\n\\n        for (var item : items2) {\\n            map.putIfAbsent(item[0], 0);\\n            map.put(item[0], map.get(item[0]) + item[1]);\\n        }\\n\\n        for (var item : map.keySet()) {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(item);\\n            list.add(map.get(item));\\n            result.add(list);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388245,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> m;\\n        \\n        for(auto v : items1) m[v[0]] += v[1];\\n        for(auto v : items2) m[v[0]] += v[1];\\n        \\n        vector<vector<int>> ans;\\n        for(auto i : m) ans.push_back({i.first, i.second});\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> m;\\n        \\n        for(auto v : items1) m[v[0]] += v[1];\\n        for(auto v : items2) m[v[0]] += v[1];\\n        \\n        vector<vector<int>> ans;\\n        for(auto i : m) ans.push_back({i.first, i.second});\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388127,
                "title": "c-simple-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        map<int,int> mp;                  // create a map for store value and their corresponding weight\\n        \\n        // store items1 value and their added weight\\n        for(auto it:items1)\\n        {\\n            mp[it[0]] += it[1];\\n        }\\n        \\n        // store items1 value and their added weight\\n        for(auto it:items2)\\n        {\\n            mp[it[0]] += it[1];\\n        }\\n        \\n        // store the answer\\n        vector<vector<int>> ans;\\n        for(auto it:mp)\\n        {\\n            ans.push_back({it.first,it.second});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        map<int,int> mp;                  // create a map for store value and their corresponding weight\\n        \\n        // store items1 value and their added weight\\n        for(auto it:items1)\\n        {\\n            mp[it[0]] += it[1];\\n        }\\n        \\n        // store items1 value and their added weight\\n        for(auto it:items2)\\n        {\\n            mp[it[0]] += it[1];\\n        }\\n        \\n        // store the answer\\n        vector<vector<int>> ans;\\n        for(auto it:mp)\\n        {\\n            ans.push_back({it.first,it.second});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390150,
                "title": "short-javascript-solution-using-a-map-object",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n\\n**Note:** To save about 4 lines of code, a ternary operator can be used in places of the if-else statement found within the for loop.\\n```\\nconst mergeSimilarItems = (items1, items2) => {\\n    let vwMap = new Map() //vw abbreviates value weight\\n\\n    for (let [value, weight] of items1.concat(items2)) {\\n        if (!vwMap.has(value)) {\\n            vwMap.set(value, weight)\\n        } else {\\n            vwMap.set(value, vwMap.get(value) + weight)\\n        }\\n    }\\n\\n    return Array.from(vwMap.entries()).sort((a,b) => a[0] - b[0])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mergeSimilarItems = (items1, items2) => {\\n    let vwMap = new Map() //vw abbreviates value weight\\n\\n    for (let [value, weight] of items1.concat(items2)) {\\n        if (!vwMap.has(value)) {\\n            vwMap.set(value, weight)\\n        } else {\\n            vwMap.set(value, vwMap.get(value) + weight)\\n        }\\n    }\\n\\n    return Array.from(vwMap.entries()).sort((a,b) => a[0] - b[0])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388275,
                "title": "python-easy-approaches",
                "content": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        \\n        \\n        hashset = {}\\n\\n        for i in range(len(items1)):\\n            if items1[i][0] in hashset:\\n                hashset[items1[i][0]] += items1[i][1]\\n            else:\\n                hashset[items1[i][0]] = items1[i][1]\\n\\n        for i in range(len(items2)):\\n            if items2[i][0] in hashset:\\n                hashset[items2[i][0]] += items2[i][1]\\n            else:\\n                hashset[items2[i][0]] = items2[i][1]\\n        \\n        ans = []\\n\\n        for i in sorted(hashset):\\n            ans.append([i, hashset[i]])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        \\n        \\n        hashset = {}\\n\\n        for i in range(len(items1)):\\n            if items1[i][0] in hashset:\\n                hashset[items1[i][0]] += items1[i][1]\\n            else:\\n                hashset[items1[i][0]] = items1[i][1]\\n\\n        for i in range(len(items2)):\\n            if items2[i][0] in hashset:\\n                hashset[items2[i][0]] += items2[i][1]\\n            else:\\n                hashset[items2[i][0]] = items2[i][1]\\n        \\n        ans = []\\n\\n        for i in sorted(hashset):\\n            ans.append([i, hashset[i]])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421396,
                "title": "python-elegant-short-hashmap-sorting",
                "content": "```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O((n+m)*log(n+m))\\n\\tMemory: O(n+m)\\n\\t\"\"\"\\n\\n\\tdef mergeSimilarItems(self, first: List[List[int]], second: List[List[int]]) -> List[List[int]]:\\n\\t\\tmerged = defaultdict(int)\\n\\n\\t\\tfor value, weight in first + second:\\n\\t\\t\\tmerged[value] += weight\\n\\n\\t\\treturn sorted(merged.items())\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O((n+m)*log(n+m))\\n\\tMemory: O(n+m)\\n\\t\"\"\"\\n\\n\\tdef mergeSimilarItems(self, first: List[List[int]], second: List[List[int]]) -> List[List[int]]:\\n\\t\\tmerged = defaultdict(int)\\n\\n\\t\\tfor value, weight in first + second:\\n\\t\\t\\tmerged[value] += weight\\n\\n\\t\\treturn sorted(merged.items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414993,
                "title": "super-easy-javascript-solution",
                "content": "```js\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    const map = {};\\n    const items = [...items1, ...items2];\\n    \\n    for (const [val, weight] of items) {\\n        if (map[val]) {\\n            map[val] += weight;\\n        } else {\\n            map[val] = weight;   \\n        }\\n    }\\n    \\n    return Object.entries(map);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    const map = {};\\n    const items = [...items1, ...items2];\\n    \\n    for (const [val, weight] of items) {\\n        if (map[val]) {\\n            map[val] += weight;\\n        } else {\\n            map[val] = weight;   \\n        }\\n    }\\n    \\n    return Object.entries(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388868,
                "title": "c-bucket-sort-19ms-o-n-time-o-1-space",
                "content": "The input range is quite limited and all the weights are greater than zero, with that we can just use a simple bucket sort. This is faster than inserting into a ```map<int, int>```.\\n\\n```\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        array<int, 1024> w = {};\\n        for (const auto& e : items1) w[e[0]] = e[1];\\n        for (const auto& e : items2) w[e[0]] += e[1];\\n        vector<vector<int>> ans;\\n        ans.reserve(size(items1) + size(items2));\\n        for (int i = 0; i < size(w); ++i) {\\n            if (w[i]) {\\n                ans.push_back({i, w[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nI should likley explain O(1) space. The extra space doesn\\'t depened on the size of the input, we only use 4k regardless.",
                "solutionTags": [
                    "C"
                ],
                "code": "```map<int, int>```\n```\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        array<int, 1024> w = {};\\n        for (const auto& e : items1) w[e[0]] = e[1];\\n        for (const auto& e : items2) w[e[0]] += e[1];\\n        vector<vector<int>> ans;\\n        ans.reserve(size(items1) + size(items2));\\n        for (int i = 0; i < size(w); ++i) {\\n            if (w[i]) {\\n                ans.push_back({i, w[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388241,
                "title": "javascript-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    const ans = {};\\n    \\n    const items = [...items1, ...items2];\\n    \\n    for (let [v, w] of items) {\\n        if (ans[v]) {\\n            ans[v] += w;\\n        } else {\\n            ans[v] = w;\\n        }\\n    }\\n    \\n    return Object.entries(ans);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    const ans = {};\\n    \\n    const items = [...items1, ...items2];\\n    \\n    for (let [v, w] of items) {\\n        if (ans[v]) {\\n            ans[v] += w;\\n        } else {\\n            ans[v] = w;\\n        }\\n    }\\n    \\n    return Object.entries(ans);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388214,
                "title": "using-java-treemap",
                "content": "\\n    class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer,Integer> m1=new HashMap<>();\\n        Map<Integer,Integer> m2=new HashMap<>();\\n        Map<Integer,Integer> m3=new TreeMap<>();\\n        for(int p[]:items1){\\n            m1.put(p[0],p[1]);\\n        }\\n        for(int p[]:items2){\\n            m2.put(p[0],p[1]);\\n        }\\n        for(int t1:m1.keySet()){\\n            int t3=m1.get(t1);\\n            int t4=m2.getOrDefault(t1,0);\\n            if(m2.containsKey(t1))m2.remove(t1);\\n            m3.put(t1,(t3+t4));\\n        }\\n        if(m2.size()!=0){\\n        for(int t1:m2.keySet()){\\n            m3.put(t1,m2.get(t1));\\n        }\\n        }\\n        List<List<Integer>> l=new ArrayList<>();\\n        \\n        for(int t1:m3.keySet()){\\n            List<Integer> l1=new ArrayList<>();\\n            l1.add(t1);\\n            l1.add(m3.get(t1));\\n            l.add(l1);\\n        }\\n        return l;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer,Integer> m1=new HashMap<>();\\n        Map<Integer,Integer> m2=new HashMap<>();\\n        Map<Integer,Integer> m3=new TreeMap<>();\\n        for(int p[]:items1){\\n            m1.put(p[0],p[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2388111,
                "title": "very-simple-and-easy-to-understand-c-solution-using-map",
                "content": "<b>Up vote if you like the solution \\n```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n    vector<vector<int>> ans;\\n    map<int, int> mp;\\n    for(auto i:items1) mp[i[0]] += i[1];\\n    for(auto i:items2) mp[i[0]] += i[1];\\n    for(auto m: mp )  ans.push_back({m.first, m.second});\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n    vector<vector<int>> ans;\\n    map<int, int> mp;\\n    for(auto i:items1) mp[i[0]] += i[1];\\n    for(auto i:items2) mp[i[0]] += i[1];\\n    for(auto m: mp )  ans.push_back({m.first, m.second});\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109258,
                "title": "dictionary-and-simple-sorting-solution",
                "content": "# Intuition\\n# Please Upvote My Solution \\n\\n# Approach\\nDictionary and Sorting\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        lst=[]\\n        di={}\\n        for i in items1:\\n            if i[0] not in di:\\n                di[i[0]]=i[1]\\n        for i in items2:\\n            if i[0] in di:\\n                di[i[0]]+=i[1]\\n            else:\\n                di[i[0]]=i[1]\\n        for i,j in di.items():\\n            lst.append([i,j])\\n        lst.sort()\\n        return lst\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        lst=[]\\n        di={}\\n        for i in items1:\\n            if i[0] not in di:\\n                di[i[0]]=i[1]\\n        for i in items2:\\n            if i[0] in di:\\n                di[i[0]]+=i[1]\\n            else:\\n                di[i[0]]=i[1]\\n        for i,j in di.items():\\n            lst.append([i,j])\\n        lst.sort()\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693280,
                "title": "java-solution-using-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int[] i : items1) {\\n            if (map.containsKey(i[0])) {\\n                map.put(i[0], map.get(i[0]) + i[1]);\\n            } else {\\n                map.put(i[0], i[1]);\\n            }\\n        }\\n        for (int[] i : items2) {\\n            if (map.containsKey(i[0])) {\\n                map.put(i[0], map.get(i[0]) + i[1]);\\n            } else {\\n                map.put(i[0], i[1]);\\n            }\\n        }\\n        List<List<Integer>> list = new ArrayList<>(map.keySet().size());\\n        for (Integer key : map.keySet()) {\\n            List<Integer> l = new ArrayList<>(2);\\n            l.add(key);\\n            l.add(map.get(key));\\n            list.add(l);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int[] i : items1) {\\n            if (map.containsKey(i[0])) {\\n                map.put(i[0], map.get(i[0]) + i[1]);\\n            } else {\\n                map.put(i[0], i[1]);\\n            }\\n        }\\n        for (int[] i : items2) {\\n            if (map.containsKey(i[0])) {\\n                map.put(i[0], map.get(i[0]) + i[1]);\\n            } else {\\n                map.put(i[0], i[1]);\\n            }\\n        }\\n        List<List<Integer>> list = new ArrayList<>(map.keySet().size());\\n        for (Integer key : map.keySet()) {\\n            List<Integer> l = new ArrayList<>(2);\\n            l.add(key);\\n            l.add(map.get(key));\\n            list.add(l);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418452,
                "title": "c-solution-no-need-map-just-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<int> temp(1001, 0);\\n        int lower = INT_MAX, upper = INT_MIN;\\n        for(int i = 0; i < items1.size(); ++i){\\n            temp[items1[i][0]] += items1[i][1];\\n            if(lower > items1[i][0]) lower = items1[i][0];\\n            if(upper < items1[i][0]) upper = items1[i][0];\\n        }\\n        for(int i = 0; i < items2.size(); ++i){\\n            temp[items2[i][0]] += items2[i][1];\\n            if(lower > items2[i][0]) lower = items2[i][0];\\n            if(upper < items2[i][0]) upper = items2[i][0];\\n        }\\n        vector<vector<int>> res;\\n        for(int i = lower; i <= upper; ++i){\\n            if(temp[i] != 0)\\n                res.push_back({i, temp[i]});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<int> temp(1001, 0);\\n        int lower = INT_MAX, upper = INT_MIN;\\n        for(int i = 0; i < items1.size(); ++i){\\n            temp[items1[i][0]] += items1[i][1];\\n            if(lower > items1[i][0]) lower = items1[i][0];\\n            if(upper < items1[i][0]) upper = items1[i][0];\\n        }\\n        for(int i = 0; i < items2.size(); ++i){\\n            temp[items2[i][0]] += items2[i][1];\\n            if(lower > items2[i][0]) lower = items2[i][0];\\n            if(upper < items2[i][0]) upper = items2[i][0];\\n        }\\n        vector<vector<int>> res;\\n        for(int i = lower; i <= upper; ++i){\\n            if(temp[i] != 0)\\n                res.push_back({i, temp[i]});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389655,
                "title": "easy-c-go-with-the-flow-no-extra-space-needed-clean-code-o-nlogn-tc-o-1-sc",
                "content": "The code looks lengthy but it\\'s good for explanation. \\n**Approach:** When we compare two arrays (or vectors), we think sort because it makes comparison easy. After sorting compare the \\'values\\' one by one. If same then push the sum of weights else decide which one to push.\\n*The correct idea is to push the smaller one* (say from items2) since you might be able to compare the larger one with current from items1.\\nRest of the code is explained with comments.\\nLet me know your views in the comments :)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> result;\\n        // sort both items \\n        sort (items1.begin(), items1.end());\\n        sort (items2.begin(), items2.end());\\n        \\n        int i = 0, j = 0;      // \\'i\\' for items1 and \\'j\\' for items2\\n        while (i < items1.size() || j < items2.size()) {        // if one reaches the end; we\\'ll manage the one which didn\\'t\\n            \\n            if (i >= items1.size() && j < items2.size())    // when we have reached end of one of them, we push leftovers from other\\n                while (j < items2.size()) {\\n                    result.push_back( {items2[j][0], items2[j][1]} );\\n                    j++;\\n                }\\n            \\n            else if (i < items1.size() && j >= items2.size())   // what if the other one reached the end? ...\\n                while (i < items1.size()) {\\n                    result.push_back( {items1[i][0], items1[i][1]} );\\n                    i++;\\n                }\\n        \\n            if (i >= items1.size() && j >= items2.size())   // as soon as we reach the end for both\\n                break;                                      // we break\\n            \\n            // now base/edge cases are over\\n            if (i < items1.size() && j < items2.size() && items1[i][0] == items2[j][0]) {   // if the values are equal\\n                result.push_back( {items1[i][0], items1[i][1]+items2[j][1]} );       // we push the value of anyone with sum of weights\\n                i++;\\n                j++;\\n            }\\n            // otherwise\\n            else if (i < items1.size() && j < items2.size() && items1[i][0] != items2[j][0]) { // in this case we choose which to push\\n                    // here\\'s the catch, we push the samller one\\n                if (items1[i][0] > items2[j][0]){      \\n                    result.push_back( {items2[j][0], items2[j][1]} );\\n                    j++;\\n                }\\n                else {\\n                    result.push_back( {items1[i][0], items1[i][1]} );\\n                    i++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> result;\\n        // sort both items \\n        sort (items1.begin(), items1.end());\\n        sort (items2.begin(), items2.end());\\n        \\n        int i = 0, j = 0;      // \\'i\\' for items1 and \\'j\\' for items2\\n        while (i < items1.size() || j < items2.size()) {        // if one reaches the end; we\\'ll manage the one which didn\\'t\\n            \\n            if (i >= items1.size() && j < items2.size())    // when we have reached end of one of them, we push leftovers from other\\n                while (j < items2.size()) {\\n                    result.push_back( {items2[j][0], items2[j][1]}",
                "codeTag": "Java"
            },
            {
                "id": 2389415,
                "title": "easy-c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        unordered_map<int,int>mp;\\n        vector<vector<int>>v;\\n        for(auto i:items1){\\n            mp[i[0]]=i[1];\\n        }\\n        for(auto j:items2){\\n            mp[j[0]]+=j[1];\\n        }\\n        for(auto m:mp){\\n            v.push_back({m.first,m.second});\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        unordered_map<int,int>mp;\\n        vector<vector<int>>v;\\n        for(auto i:items1){\\n            mp[i[0]]=i[1];\\n        }\\n        for(auto j:items2){\\n            mp[j[0]]+=j[1];\\n        }\\n        for(auto m:mp){\\n            v.push_back({m.first,m.second});\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389053,
                "title": "c-simple-easy-to-understand-basic-hash-map",
                "content": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        unordered_map<int,int>mp;\\n        vector<vector<int>>ret;\\n        for(int i=0;i<items1.size();i++){\\n            mp[items1[i][0]]+=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            mp[items2[i][0]]+=items2[i][1];\\n        }\\n        for(auto i:mp){\\n            vector<int>temp;\\n            temp.push_back(i.first);\\n            temp.push_back(i.second);\\n            ret.push_back(temp);\\n        }\\n        sort(ret.begin(),ret.end());\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        unordered_map<int,int>mp;\\n        vector<vector<int>>ret;\\n        for(int i=0;i<items1.size();i++){\\n            mp[items1[i][0]]+=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            mp[items2[i][0]]+=items2[i][1];\\n        }\\n        for(auto i:mp){\\n            vector<int>temp;\\n            temp.push_back(i.first);\\n            temp.push_back(i.second);\\n            ret.push_back(temp);\\n        }\\n        sort(ret.begin(),ret.end());\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388345,
                "title": "c-group-by-key-add-values",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<int> v(1001,0);\\n        for(auto it:items1)\\n        {\\n            v[it[0]]+=it[1];\\n        }\\n         for(auto it:items2)\\n        {\\n            v[it[0]]+=it[1];\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<=1000;i++)\\n        {\\n            if(v[i])\\n                res.push_back({i,v[i]});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<int> v(1001,0);\\n        for(auto it:items1)\\n        {\\n            v[it[0]]+=it[1];\\n        }\\n         for(auto it:items2)\\n        {\\n            v[it[0]]+=it[1];\\n        }\\n        vector<vector<int>> res;\\n        for(int i=0;i<=1000;i++)\\n        {\\n            if(v[i])\\n                res.push_back({i,v[i]});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388102,
                "title": "otimize-easy-clean-code",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<List<Integer>> ret = new ArrayList<>();\\n        for(int[] i : items1){\\n            map.put(i[0],i[1]);\\n        }\\n        \\n        for(int[] i : items2){\\n            if(map.containsKey(i[0])){\\n                map.put(i[0],map.get(i[0]) + i[1]);\\n            }else{\\n                map.put(i[0],i[1]);\\n            }\\n        }\\n        \\n        for(int i : map.keySet()){\\n            ArrayList<Integer> set = new ArrayList<>();\\n            set.add(i);\\n            set.add(map.get(i));\\n            ret.add(set);\\n        }\\n        \\n        Collections.sort(ret, (a,b) -> a.get(0) - b.get(0));\\n        return ret;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        List<List<Integer>> ret = new ArrayList<>();\\n        for(int[] i : items1){\\n            map.put(i[0],i[1]);\\n        }\\n        \\n        for(int[] i : items2){\\n            if(map.containsKey(i[0])){\\n                map.put(i[0],map.get(i[0]) + i[1]);\\n            }else{\\n                map.put(i[0],i[1]);\\n            }\\n        }\\n        \\n        for(int i : map.keySet()){\\n            ArrayList<Integer> set = new ArrayList<>();\\n            set.add(i);\\n            set.add(map.get(i));\\n            ret.add(set);\\n        }\\n        \\n        Collections.sort(ret, (a,b) -> a.get(0) - b.get(0));\\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021528,
                "title": "c-maps-shortest-and-easiest-code",
                "content": "\\n\\n# Approach\\n- Since we need to return the answer in ascending order ,so we will use ordered map.\\n- Store the 2d array \"items1\" in the map by iterating it.\\n- Similarly iterate through the 2nd 2d array \"items2\" while iterating,since it doesn\\'t store duplicate values, so it will add the weight of value of \"items1\" in the same weight of value of \"items2\".\\n- Then at last put all this values and weights present in map \"m\" in the 2d array \"ans\".\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n **O(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>m;\\n        vector<vector<int>>ans;\\n\\n        for(auto a : items1){\\n            m[a[0]] += a[1];\\n        }\\n        for(auto a : items2){\\n            m[a[0]] +=a[1];\\n        }\\n        for(auto i : m){\\n            ans.push_back({i.first,i.second});\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>m;\\n        vector<vector<int>>ans;\\n\\n        for(auto a : items1){\\n            m[a[0]] += a[1];\\n        }\\n        for(auto a : items2){\\n            m[a[0]] +=a[1];\\n        }\\n        for(auto i : m){\\n            ans.push_back({i.first,i.second});\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444016,
                "title": "java-easy-treemap-solution-no-sorting-required-for-beginners-explained",
                "content": "# Approach\\n- create a TreeMap for serialized key value storage.\\n- Iterate through items1 and add all the item numbers as keys and the quantity as the corresponding value.\\n- Then iterate through items2 and for the repeated keys already stored in the TreeMap, update the quantity by adding the additional quantities.\\n- Then simply add these values into <List<List<Integer>>> Arraylist for the return statement\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n\\n- Space complexity: O(m+n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        int m = items1.length;\\n        int n = items2.length;\\n        \\n        // Automatic sorting of the Objects --> TreeMap\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        // Adding all the (object, quantity) into the treemap from items1\\n\\n        for(int i = 0;i<m;i++){\\n\\n            map.put(items1[i][0],items1[i][1]);\\n\\n        }\\n\\n        // Adding all the items2 (object, quantity) into treemap and for the repeating objects, new quantity = old quantity + current quantity\\n\\n\\n        for(int i = 0;i<n;i++){\\n\\n            if( map.containsKey(items2[i][0]) ){\\n\\n                int value = map.get(items2[i][0]);\\n                value = value + items2[i][1];\\n                map.put(items2[i][0],value);\\n\\n            }else{\\n\\n                map.put(items2[i][0],items2[i][1]);\\n\\n            }\\n\\n        }\\n\\n        List<List<Integer>> ret = new ArrayList<>();\\n\\n        // Transfering all the (Object, Quantity) objects in our TreeMap into the required format --> List<List<Integer>>\\n\\n        for(int value: map.keySet()){\\n\\n            List<Integer> list = new ArrayList<>();\\n            list.add(value);\\n            list.add(map.get(value));\\n            ret.add(list);\\n\\n        }\\n\\n        return ret;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        int m = items1.length;\\n        int n = items2.length;\\n        \\n        // Automatic sorting of the Objects --> TreeMap\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        // Adding all the (object, quantity) into the treemap from items1\\n\\n        for(int i = 0;i<m;i++){\\n\\n            map.put(items1[i][0],items1[i][1]);\\n\\n        }\\n\\n        // Adding all the items2 (object, quantity) into treemap and for the repeating objects, new quantity = old quantity + current quantity\\n\\n\\n        for(int i = 0;i<n;i++){\\n\\n            if( map.containsKey(items2[i][0]) ){\\n\\n                int value = map.get(items2[i][0]);\\n                value = value + items2[i][1];\\n                map.put(items2[i][0],value);\\n\\n            }else{\\n\\n                map.put(items2[i][0],items2[i][1]);\\n\\n            }\\n\\n        }\\n\\n        List<List<Integer>> ret = new ArrayList<>();\\n\\n        // Transfering all the (Object, Quantity) objects in our TreeMap into the required format --> List<List<Integer>>\\n\\n        for(int value: map.keySet()){\\n\\n            List<Integer> list = new ArrayList<>();\\n            list.add(value);\\n            list.add(map.get(value));\\n            ret.add(list);\\n\\n        }\\n\\n        return ret;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266902,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void mergeMap(int [][]items,Map<Integer,Integer>map){\\n        for(int[]item:items){\\n            int val=item[0];\\n            int weight=item[1];\\n            map.put(val,map.getOrDefault(val,0)+weight);\\n        }\\n    }\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Map<Integer,Integer>map=new TreeMap<>();\\n        mergeMap(items1,map);\\n        mergeMap(items2,map);\\n        for(Integer val: map.keySet()){\\n            List<Integer> temp=new ArrayList<>();\\n            temp.add(val);\\n            temp.add(map.get(val));\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void mergeMap(int [][]items,Map<Integer,Integer>map){\\n        for(int[]item:items){\\n            int val=item[0];\\n            int weight=item[1];\\n            map.put(val,map.getOrDefault(val,0)+weight);\\n        }\\n    }\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Map<Integer,Integer>map=new TreeMap<>();\\n        mergeMap(items1,map);\\n        mergeMap(items2,map);\\n        for(Integer val: map.keySet()){\\n            List<Integer> temp=new ArrayList<>();\\n            temp.add(val);\\n            temp.add(map.get(val));\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942493,
                "title": "java-solution-without-treemap-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        // based on the constraint 1 <= value[i], weight[i] <= 1000\\n        final int[] cache = new int[1001];\\n        for (int[] item : items1) {\\n            cache[item[0]] = item[1];\\n        }\\n\\n        for (int[] item : items2) {\\n            cache[item[0]] += item[1];\\n        }\\n\\n        final List<List<Integer>> result = new ArrayList<>(items1.length);\\n        for (int i = 0; i < 1001; i++) {\\n            if (cache[i] > 0) {\\n                final List<Integer> pair = new ArrayList<>(2);\\n                pair.add(i);\\n                pair.add(cache[i]);\\n                result.add(pair);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        // based on the constraint 1 <= value[i], weight[i] <= 1000\\n        final int[] cache = new int[1001];\\n        for (int[] item : items1) {\\n            cache[item[0]] = item[1];\\n        }\\n\\n        for (int[] item : items2) {\\n            cache[item[0]] += item[1];\\n        }\\n\\n        final List<List<Integer>> result = new ArrayList<>(items1.length);\\n        for (int i = 0; i < 1001; i++) {\\n            if (cache[i] > 0) {\\n                final List<Integer> pair = new ArrayList<>(2);\\n                pair.add(i);\\n                pair.add(cache[i]);\\n                result.add(pair);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918635,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> mp;\\n        for(auto x: items1) mp[x[0]] += x[1];\\n        for(auto x: items2) mp[x[0]] += x[1];\\n        vector<vector<int>> ans;\\n        for(auto x: mp) {\\n            ans.push_back({x.first, x.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> mp;\\n        for(auto x: items1) mp[x[0]] += x[1];\\n        for(auto x: items2) mp[x[0]] += x[1];\\n        vector<vector<int>> ans;\\n        for(auto x: mp) {\\n            ans.push_back({x.first, x.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775202,
                "title": "c-using-sorteddictionary",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> MergeSimilarItems(int[][] items1, int[][] items2) {\\n        var counts = new SortedDictionary<int, int>();\\n        AddWeights(items1, counts);\\n        AddWeights(items2, counts);\\n        \\n        var ret = new List<IList<int>>();\\n        foreach(var kvp in counts)\\n        {\\n            ret.Add(new List<int>(){kvp.Key, kvp.Value});\\n        }\\n        return ret;\\n    }\\n\\n    void AddWeights(int[][] items1, SortedDictionary<int, int> counts)\\n    {\\n        foreach(var itm in items1)\\n        {\\n            if(!counts.ContainsKey(itm[0]))\\n            {\\n                counts[itm[0]]=0;\\n            }\\n            counts[itm[0]]+=itm[1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> MergeSimilarItems(int[][] items1, int[][] items2) {\\n        var counts = new SortedDictionary<int, int>();\\n        AddWeights(items1, counts);\\n        AddWeights(items2, counts);\\n        \\n        var ret = new List<IList<int>>();\\n        foreach(var kvp in counts)\\n        {\\n            ret.Add(new List<int>(){kvp.Key, kvp.Value});\\n        }\\n        return ret;\\n    }\\n\\n    void AddWeights(int[][] items1, SortedDictionary<int, int> counts)\\n    {\\n        foreach(var itm in items1)\\n        {\\n            if(!counts.ContainsKey(itm[0]))\\n            {\\n                counts[itm[0]]=0;\\n            }\\n            counts[itm[0]]+=itm[1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770562,
                "title": "python-98-94-faster-solution",
                "content": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        for i in items1:\\n            d[i[0]] = i[1]\\n        for i in items2:\\n            if i[0] in d:\\n                d[i[0]] += i[1]\\n            else:\\n                d[i[0]] = i[1]\\n        ans = []\\n        for i in d:\\n            temp = [i, d[i]]\\n            ans.append(temp)\\n        ans.sort()\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        for i in items1:\\n            d[i[0]] = i[1]\\n        for i in items2:\\n            if i[0] in d:\\n                d[i[0]] += i[1]\\n            else:\\n                d[i[0]] = i[1]\\n        ans = []\\n        for i in d:\\n            temp = [i, d[i]]\\n            ans.append(temp)\\n        ans.sort()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395559,
                "title": "simple-c-solution-hashmaps-easy-understanding",
                "content": "**Solution** -->\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> map;\\n        for(int i=0;i<items1.size();i++){\\n            map[items1[i][0]]+=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            map[items2[i][0]]+=items2[i][1];\\n        }\\n        vector<vector<int>> ans;\\n        for (auto i : map){\\n            vector<int> temp;\\n            temp.push_back(i.first);\\n            temp.push_back(i.second);\\n            ans.push_back(temp);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> map;\\n        for(int i=0;i<items1.size();i++){\\n            map[items1[i][0]]+=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            map[items2[i][0]]+=items2[i][1];\\n        }\\n        vector<vector<int>> ans;\\n        for (auto i : map){\\n            vector<int> temp;\\n            temp.push_back(i.first);\\n            temp.push_back(i.second);\\n            ans.push_back(temp);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388497,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>mp;\\n        for(auto i:items1)\\n        {\\n            mp[i[0]]+=i[1];\\n        }\\n        for(auto i:items2)\\n        {\\n            mp[i[0]]+=i[1];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto i:mp)\\n        {\\n            ans.push_back({i.first,i.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>mp;\\n        for(auto i:items1)\\n        {\\n            mp[i[0]]+=i[1];\\n        }\\n        for(auto i:items2)\\n        {\\n            mp[i[0]]+=i[1];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto i:mp)\\n        {\\n            ans.push_back({i.first,i.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388223,
                "title": "java-o-nlogn",
                "content": "```Java \\nclass Solution \\n{\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) \\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(items1, (a, b) -> Integer.compare(a[0], b[0]));\\n        Arrays.sort(items2, (a, b) -> Integer.compare(a[0], b[0]));\\n        int i = 0;\\n        int j = 0;\\n        while(i < items1.length && j < items2.length)\\n        {\\n            //System.out.println(\"i= \" + i + \", j =\" + j);\\n            if(items1[i][0] == items2[j][0])\\n            {\\n                //System.out.println(\"1-> \" +Arrays.toString(items1[i]));\\n                //System.out.println(\"1-> \" +Arrays.toString(items2[j]));\\n                List<Integer> val = new ArrayList<>();\\n                int weights = items1[i][1] + items2[j][1];\\n                val.add(items1[i][0]);\\n                val.add(weights);\\n                ans.add(val);\\n                i++;\\n                j++;\\n            }\\n            else if(items1[i][0] < items2[j][0])\\n            {\\n                //System.out.println(\"2-> \" +Arrays.toString(items1[i]));\\n                List<Integer> val = new ArrayList<>();\\n                val.add(items1[i][0]);\\n                val.add(items1[i][1]);\\n                ans.add(val);\\n                i++;\\n            }\\n            else if(items1[i][0] > items2[j][0])\\n            {\\n                //System.out.println(\"3-> \" + Arrays.toString(items2[j]));\\n                List<Integer> val = new ArrayList<>();\\n                val.add(items2[j][0]);\\n                val.add(items2[j][1]);\\n                ans.add(val);\\n                j++;\\n            }\\n            //System.out.println(ans);\\n        }\\n        while(i < items1.length)\\n        {\\n            List<Integer> val = new ArrayList<>();\\n            val.add(items1[i][0]);\\n            val.add(items1[i][1]);\\n            ans.add(val);\\n            i++;\\n        }\\n        while(j < items2.length)\\n        {\\n            List<Integer> val = new ArrayList<>();\\n            val.add(items2[j][0]);\\n            val.add(items2[j][1]);\\n            ans.add(val);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```Java \\nclass Solution \\n{\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) \\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(items1, (a, b) -> Integer.compare(a[0], b[0]));\\n        Arrays.sort(items2, (a, b) -> Integer.compare(a[0], b[0]));\\n        int i = 0;\\n        int j = 0;\\n        while(i < items1.length && j < items2.length)\\n        {\\n            //System.out.println(\"i= \" + i + \", j =\" + j);\\n            if(items1[i][0] == items2[j][0])\\n            {\\n                //System.out.println(\"1-> \" +Arrays.toString(items1[i]));\\n                //System.out.println(\"1-> \" +Arrays.toString(items2[j]));\\n                List<Integer> val = new ArrayList<>();\\n                int weights = items1[i][1] + items2[j][1];\\n                val.add(items1[i][0]);\\n                val.add(weights);\\n                ans.add(val);\\n                i++;\\n                j++;\\n            }\\n            else if(items1[i][0] < items2[j][0])\\n            {\\n                //System.out.println(\"2-> \" +Arrays.toString(items1[i]));\\n                List<Integer> val = new ArrayList<>();\\n                val.add(items1[i][0]);\\n                val.add(items1[i][1]);\\n                ans.add(val);\\n                i++;\\n            }\\n            else if(items1[i][0] > items2[j][0])\\n            {\\n                //System.out.println(\"3-> \" + Arrays.toString(items2[j]));\\n                List<Integer> val = new ArrayList<>();\\n                val.add(items2[j][0]);\\n                val.add(items2[j][1]);\\n                ans.add(val);\\n                j++;\\n            }\\n            //System.out.println(ans);\\n        }\\n        while(i < items1.length)\\n        {\\n            List<Integer> val = new ArrayList<>();\\n            val.add(items1[i][0]);\\n            val.add(items1[i][1]);\\n            ans.add(val);\\n            i++;\\n        }\\n        while(j < items2.length)\\n        {\\n            List<Integer> val = new ArrayList<>();\\n            val.add(items2[j][0]);\\n            val.add(items2[j][1]);\\n            ans.add(val);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388178,
                "title": "java-treemap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        \\n        TreeMap<Integer,Integer> map =new TreeMap<>();\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        \\n        if(items1.length ==0 && items2.length ==0)\\n        return result;\\n        \\n       \\n        \\n        for(int[] i: items1){\\n        \\n            map.put(i[0],i[1]);\\n        }\\n        \\n        for(int[] i: items2){\\n        \\n            if(map.containsKey(i[0])){\\n                \\n            map.put(i[0],map.get(i[0])+i[1]);  \\n                \\n            }else{\\n                \\n               map.put(i[0],i[1]); \\n            }     \\n        }\\n        \\n        for(int key:map.keySet()){\\n            List<Integer> list=new ArrayList<>();\\n            list.add(key);\\n            list.add(map.get(key));\\n            result.add(list);\\n        }\\n        \\n      \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        \\n        TreeMap<Integer,Integer> map =new TreeMap<>();\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        \\n        if(items1.length ==0 && items2.length ==0)\\n        return result;\\n        \\n       \\n        \\n        for(int[] i: items1){\\n        \\n            map.put(i[0],i[1]);\\n        }\\n        \\n        for(int[] i: items2){\\n        \\n            if(map.containsKey(i[0])){\\n                \\n            map.put(i[0],map.get(i[0])+i[1]);  \\n                \\n            }else{\\n                \\n               map.put(i[0],i[1]); \\n            }     \\n        }\\n        \\n        for(int key:map.keySet()){\\n            List<Integer> list=new ArrayList<>();\\n            list.add(key);\\n            list.add(map.get(key));\\n            result.add(list);\\n        }\\n        \\n      \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388147,
                "title": "c-simplest-solution-brute-force",
                "content": "```vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map< int, int> ump;\\n        for(auto v: items1) \\n            ump[v[0]] += v[1];\\n        \\n        for(auto v: items2) \\n            ump[v[0]] += v[1];\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(auto it: ump) {\\n            ans.push_back({it.first, it.second});\\n        }\\n        return ans;\\n    }```",
                "solutionTags": [
                    "C"
                ],
                "code": "```vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map< int, int> ump;\\n        for(auto v: items1) \\n            ump[v[0]] += v[1];\\n        \\n        for(auto v: items2) \\n            ump[v[0]] += v[1];\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(auto it: ump) {\\n            ans.push_back({it.first, it.second});\\n        }\\n        return ans;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643387,
                "title": "java-easiest-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        // Update map for items1\\n        for (int[] item : items1) {\\n            int value = item[0];\\n            int weight = item[1];\\n            \\n            map.put(value, map.getOrDefault(value, 0) + weight);\\n        }\\n        \\n        // Update map for items2\\n        for (int[] item : items2) {\\n            int value = item[0];\\n            int weight = item[1];\\n            \\n            map.put(value, map.getOrDefault(value, 0) + weight);\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // Add entries from map to the result\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int value = entry.getKey();\\n            int weight = entry.getValue();\\n            \\n            List<Integer> item = new ArrayList<>();\\n            item.add(value);\\n            item.add(weight);\\n            \\n            result.add(item);\\n        }\\n        \\n        // Sort the result in ascending order based on value\\n        Collections.sort(result, (a, b) -> a.get(0) - b.get(0));\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        // Update map for items1\\n        for (int[] item : items1) {\\n            int value = item[0];\\n            int weight = item[1];\\n            \\n            map.put(value, map.getOrDefault(value, 0) + weight);\\n        }\\n        \\n        // Update map for items2\\n        for (int[] item : items2) {\\n            int value = item[0];\\n            int weight = item[1];\\n            \\n            map.put(value, map.getOrDefault(value, 0) + weight);\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // Add entries from map to the result\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int value = entry.getKey();\\n            int weight = entry.getValue();\\n            \\n            List<Integer> item = new ArrayList<>();\\n            item.add(value);\\n            item.add(weight);\\n            \\n            result.add(item);\\n        }\\n        \\n        // Sort the result in ascending order based on value\\n        Collections.sort(result, (a, b) -> a.get(0) - b.get(0));\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596081,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        items1.sort()\\n        items2.sort()\\n        res=[]\\n        i,j=0,0\\n        while(i<len(items1) and j<len(items2)):\\n            if items1[i][0]==items2[j][0]:\\n                res.append([items1[i][0],items1[i][1]+items2[j][1]])\\n                i+=1\\n                j+=1\\n            elif items1[i][0]<items2[j][0]:\\n                res.append(items1[i])\\n                i+=1\\n            elif items1[i][0]>items2[j][0]:\\n                res.append(items2[j])\\n                j+=1\\n                \\n        if i==len(items1):\\n            while(j<len(items2)):\\n                res.append(items2[j])\\n                j+=1\\n                \\n        if j==len(items2):\\n            while(i<len(items1)):\\n                res.append(items1[i])\\n                i+=1\\n                \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        items1.sort()\\n        items2.sort()\\n        res=[]\\n        i,j=0,0\\n        while(i<len(items1) and j<len(items2)):\\n            if items1[i][0]==items2[j][0]:\\n                res.append([items1[i][0],items1[i][1]+items2[j][1]])\\n                i+=1\\n                j+=1\\n            elif items1[i][0]<items2[j][0]:\\n                res.append(items1[i])\\n                i+=1\\n            elif items1[i][0]>items2[j][0]:\\n                res.append(items2[j])\\n                j+=1\\n                \\n        if i==len(items1):\\n            while(j<len(items2)):\\n                res.append(items2[j])\\n                j+=1\\n                \\n        if j==len(items2):\\n            while(i<len(items1)):\\n                res.append(items1[i])\\n                i+=1\\n                \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587815,
                "title": "c-two-vector-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeeded to know, the basics of vector and array.\\n\\n# Approach\\nGet the map of items of second vector in arr.\\nGoing through the first array and getting the values from the mapped one.\\nAfter all, checking for unputted values from the array map.\\nAt last sort the ans i.e, first vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        int arr[1001] = {0};\\n        // retriving the elements from the second array\\n        for(int i=0; i<items2.size(); i++)\\n            arr[items2[i][0]] = items2[i][1];\\n        \\n        // adding up the value;\\n        for(int i=0; i<items1.size(); i++){\\n            int target = items1[i][0];\\n            if(arr[target] == 0)\\n                continue;\\n            \\n            items1[i][1] += arr[target];\\n            arr[target] = 0;\\n        }\\n        // getting the remaining values from the array\\n        for(int i=0; i<=1000; i++){\\n            if(arr[i] == 0)\\n                continue;\\n            items1.push_back({i, arr[i]});\\n        }\\n        // sorting the answer vector\\n        sort(items1.begin(), items1.end());\\n        return items1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        int arr[1001] = {0};\\n        // retriving the elements from the second array\\n        for(int i=0; i<items2.size(); i++)\\n            arr[items2[i][0]] = items2[i][1];\\n        \\n        // adding up the value;\\n        for(int i=0; i<items1.size(); i++){\\n            int target = items1[i][0];\\n            if(arr[target] == 0)\\n                continue;\\n            \\n            items1[i][1] += arr[target];\\n            arr[target] = 0;\\n        }\\n        // getting the remaining values from the array\\n        for(int i=0; i<=1000; i++){\\n            if(arr[i] == 0)\\n                continue;\\n            items1.push_back({i, arr[i]});\\n        }\\n        // sorting the answer vector\\n        sort(items1.begin(), items1.end());\\n        return items1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402113,
                "title": "merge-similar-items-javascript-new-map",
                "content": "```\\nvar mergeSimilarItems = function(items1, items2) {\\n    map = new Map()\\n\\n    for (item of items1) {\\n        map.set(item[0], item[1])\\n    }\\n\\n    for (item of items2) {\\n        if (map.get(item[0]) != undefined) \\n            map.set(item[0], item[1] + map.get(item[0]))\\n        else \\n            map.set(item[0], item[1])\\n    }    \\n\\n    return [...map].sort((a, b) => a[0] - b[0])    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar mergeSimilarItems = function(items1, items2) {\\n    map = new Map()\\n\\n    for (item of items1) {\\n        map.set(item[0], item[1])\\n    }\\n\\n    for (item of items2) {\\n        if (map.get(item[0]) != undefined) \\n            map.set(item[0], item[1] + map.get(item[0]))\\n        else \\n            map.set(item[0], item[1])\\n    }    \\n\\n    return [...map].sort((a, b) => a[0] - b[0])    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353156,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n  N: Total number of elements\\n  \\n- Space complexity: O(M)\\n  M: Number of distinct elements\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n\\n    map<int, int> m;\\n    int n1=items1.size();\\n    for (auto i = 0; i < n1; i++)\\n        m[items1[i][0]] = items1[i][1];\\n\\n    int n2=items2.size();\\n    for (int j = 0; j < n2; j++)\\n        m[items2[j][0]] += items2[j][1];\\n\\n    vector<vector<int>> ans;\\n    for(auto e:m)\\n        ans.push_back({e.first,e.second});\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n\\n    map<int, int> m;\\n    int n1=items1.size();\\n    for (auto i = 0; i < n1; i++)\\n        m[items1[i][0]] = items1[i][1];\\n\\n    int n2=items2.size();\\n    for (int j = 0; j < n2; j++)\\n        m[items2[j][0]] += items2[j][1];\\n\\n    vector<vector<int>> ans;\\n    for(auto e:m)\\n        ans.push_back({e.first,e.second});\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332567,
                "title": "hashmap-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        a, c, b =  defaultdict(int), [], items1 + items2\\n        for j in b:\\n            if j[0] not in a:  a[j[0]] = j[1]\\n            else: a[j[0]] = a[j[0]] + j[1]\\n        for i in sorted(a): c.append([i,a[i]])\\n        return c\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        a, c, b =  defaultdict(int), [], items1 + items2\\n        for j in b:\\n            if j[0] not in a:  a[j[0]] = j[1]\\n            else: a[j[0]] = a[j[0]] + j[1]\\n        for i in sorted(a): c.append([i,a[i]])\\n        return c\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280523,
                "title": "merge-similar-items-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        int i, j, flag=0;\\n        for(i=0 ; i<items2.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<items1.size() ; j++)\\n            {\\n                if(items1[j][0]==items2[i][0])\\n                {\\n                    items1[j][1] += items2[i][1];\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                items1.push_back(items2[i]);\\n            }\\n        }\\n        sort(items1.begin(), items1.end());\\n        return items1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        int i, j, flag=0;\\n        for(i=0 ; i<items2.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<items1.size() ; j++)\\n            {\\n                if(items1[j][0]==items2[i][0])\\n                {\\n                    items1[j][1] += items2[i][1];\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                items1.push_back(items2[i]);\\n            }\\n        }\\n        sort(items1.begin(), items1.end());\\n        return items1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001063,
                "title": "2-pointers-solution-with-presort",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    items1.sort(([v1], [v2]) => v1 - v2);\\n    items2.sort(([v1], [v2]) => v1 - v2);\\n\\n    let i = 0;\\n    let j = 0;\\n    const res = [];\\n\\n    while (i < items1.length && j < items2.length) {\\n        const [v1, w1] = items1[i];\\n        const [v2, w2] = items2[j];\\n\\n        if (v1 === v2) {\\n            res.push([v1, w1 + w2]);\\n            i++;\\n            j++;\\n        } else if (v1 < v2) {\\n            res.push([v1, w1]);\\n            i++;\\n        } else {\\n            res.push([v2, w2]);\\n            j++;\\n        }\\n    }\\n    while (i < items1.length) {\\n        res.push(items1[i]);\\n        i++;\\n    }\\n    while (j < items2.length) {\\n        res.push(items2[j]);\\n        j++;\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    items1.sort(([v1], [v2]) => v1 - v2);\\n    items2.sort(([v1], [v2]) => v1 - v2);\\n\\n    let i = 0;\\n    let j = 0;\\n    const res = [];\\n\\n    while (i < items1.length && j < items2.length) {\\n        const [v1, w1] = items1[i];\\n        const [v2, w2] = items2[j];\\n\\n        if (v1 === v2) {\\n            res.push([v1, w1 + w2]);\\n            i++;\\n            j++;\\n        } else if (v1 < v2) {\\n            res.push([v1, w1]);\\n            i++;\\n        } else {\\n            res.push([v2, w2]);\\n            j++;\\n        }\\n    }\\n    while (i < items1.length) {\\n        res.push(items1[i]);\\n        i++;\\n    }\\n    while (j < items2.length) {\\n        res.push(items2[j]);\\n        j++;\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900219,
                "title": "33ms-40-go-solution",
                "content": "```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) (ans [][]int) {\\n  hm := make(map[int]int)\\n\\n  for _, item := range items1 {\\n    hm[item[0]] += item[1]\\n  }\\n  for _, item := range items2 {\\n    hm[item[0]] += item[1]\\n  }\\n\\n  for k, v := range hm {\\n    ans = append(ans, []int{k, v})\\n  }\\n\\n  sort.Slice(ans, func(i, j int) bool {\\n    return ans[i][0] < ans[j][0]\\n  })\\n\\n  return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) (ans [][]int) {\\n  hm := make(map[int]int)\\n\\n  for _, item := range items1 {\\n    hm[item[0]] += item[1]\\n  }\\n  for _, item := range items2 {\\n    hm[item[0]] += item[1]\\n  }\\n\\n  for k, v := range hm {\\n    ans = append(ans, []int{k, v})\\n  }\\n\\n  sort.Slice(ans, func(i, j int) bool {\\n    return ans[i][0] < ans[j][0]\\n  })\\n\\n  return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886651,
                "title": "my-solution-using-treemap-java",
                "content": "- 49/49 cases passed (9 ms)\\n- Your runtime beats 83.91 % of java submissions\\n- Your memory usage beats 88.97 % of java submissions (43.2 MB)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer,Integer> hm=new TreeMap<>();\\n        List<List<Integer>> out=new ArrayList<>();\\n\\n        for(int[] i:items1)\\n            hm.put(i[0], i[1]);\\n        for(int[] i:items2)\\n            hm.put(i[0], i[1]+hm.getOrDefault(i[0], 0));\\n\\n        for(Integer i :hm.keySet())\\n            out.add(Arrays.asList(i,hm.get(i)));\\n        \\n            \\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer,Integer> hm=new TreeMap<>();\\n        List<List<Integer>> out=new ArrayList<>();\\n\\n        for(int[] i:items1)\\n            hm.put(i[0], i[1]);\\n        for(int[] i:items2)\\n            hm.put(i[0], i[1]+hm.getOrDefault(i[0], 0));\\n\\n        for(Integer i :hm.keySet())\\n            out.add(Arrays.asList(i,hm.get(i)));\\n        \\n            \\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878796,
                "title": "basic-approach-brute-force-python3",
                "content": "# BASIC APPROACH || BRUTE FORCE || PYTHON3\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        ans=[]\\n        dicc={}\\n\\n        for i in range(len(items1)):\\n            if items1[i][0] not in dicc:\\n                dicc[items1[i][0]]=items1[i][1]\\n            else:\\n                dicc[items1[i][0]]+=items1[i][1]\\n        \\n        for j in range(len(items2)):\\n            if items2[j][0] not in dicc:\\n                dicc[items2[j][0]]=items2[j][1]\\n            else:\\n                dicc[items2[j][0]]+=items2[j][1]\\n        \\n        for k,v in dicc.items():\\n            ans.append([k,v])\\n        ans.sort()\\n        \\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        ans=[]\\n        dicc={}\\n\\n        for i in range(len(items1)):\\n            if items1[i][0] not in dicc:\\n                dicc[items1[i][0]]=items1[i][1]\\n            else:\\n                dicc[items1[i][0]]+=items1[i][1]\\n        \\n        for j in range(len(items2)):\\n            if items2[j][0] not in dicc:\\n                dicc[items2[j][0]]=items2[j][1]\\n            else:\\n                dicc[items2[j][0]]+=items2[j][1]\\n        \\n        for k,v in dicc.items():\\n            ans.append([k,v])\\n        ans.sort()\\n        \\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789563,
                "title": "2-solution-with-without-map-60-and-95-faster-easy-understanding",
                "content": "```\\n///With Map\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Map<Integer,List<Integer>> map = new TreeMap<>();\\n        for(int A[]:items1){\\n            List<Integer> l = map.get(A[0]);\\n            if(l==null){\\n                l = new ArrayList<>();\\n                l.add(A[0]);\\n                l.add(A[1]);\\n            }\\n            else\\n            {\\n                l.set(1,l.get(1)+A[1]);\\n            }\\n            \\n            map.put(A[0],l);\\n        }\\n        \\n        for(int A[]:items2){\\n            List<Integer> l = map.get(A[0]);\\n            if(l==null){\\n                l = new ArrayList<>();\\n                l.add(A[0]);\\n                l.add(A[1]);\\n            }\\n            else\\n            {\\n                l.set(1,l.get(1)+A[1]);\\n            }\\n            \\n            map.put(A[0],l);\\n        }\\n        \\n        for(int i:map.keySet()) \\n            ans.add(map.get(i));\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n\\n////Without Map\\n//Note here max Item value is 1000\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        int resultSet[] = new int[1001];\\n        for(int A[]:items1)\\n            resultSet[A[0]]  += A[1];\\n        \\n        for(int A[]:items2)\\n            resultSet[A[0]]  += A[1];\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list;\\n        for(int i=1;i<1001;i++){\\n            if(resultSet[i]>0){\\n                list = new ArrayList<>();\\n                list.add(i);\\n                list.add(resultSet[i]);\\n                result.add(list);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n///With Map\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Map<Integer,List<Integer>> map = new TreeMap<>();\\n        for(int A[]:items1){\\n            List<Integer> l = map.get(A[0]);\\n            if(l==null){\\n                l = new ArrayList<>();\\n                l.add(A[0]);\\n                l.add(A[1]);\\n            }\\n            else\\n            {\\n                l.set(1,l.get(1)+A[1]);\\n            }\\n            \\n            map.put(A[0],l);\\n        }\\n        \\n        for(int A[]:items2){\\n            List<Integer> l = map.get(A[0]);\\n            if(l==null){\\n                l = new ArrayList<>();\\n                l.add(A[0]);\\n                l.add(A[1]);\\n            }\\n            else\\n            {\\n                l.set(1,l.get(1)+A[1]);\\n            }\\n            \\n            map.put(A[0],l);\\n        }\\n        \\n        for(int i:map.keySet()) \\n            ans.add(map.get(i));\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n\\n////Without Map\\n//Note here max Item value is 1000\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        int resultSet[] = new int[1001];\\n        for(int A[]:items1)\\n            resultSet[A[0]]  += A[1];\\n        \\n        for(int A[]:items2)\\n            resultSet[A[0]]  += A[1];\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list;\\n        for(int i=1;i<1001;i++){\\n            if(resultSet[i]>0){\\n                list = new ArrayList<>();\\n                list.add(i);\\n                list.add(resultSet[i]);\\n                result.add(list);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679781,
                "title": "easy-to-understand-simple-hashing",
                "content": "\\n<!-- We can simply create a hash table and iterate over to both the matrices and at the value as index we add the weigth to that particular index -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<int>v(1001,0);\\n        for(int i=0;i<items1.size();i++){\\n            int ind=items1[i][0];\\n            int val=items1[i][1];\\n            v[ind]+=val;\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            int ind=items2[i][0];\\n            int val=items2[i][1];\\n            v[ind]+=val;\\n        }\\n\\n        vector<vector<int>>res;\\n       \\n        for(int i=0;i<v.size();i++){\\n\\n            if(v[i]!=0){\\n                vector<int>t;\\n                int val=i;\\n                int wt=v[i];\\n                t.push_back(val);\\n                t.push_back(wt);\\n                res.push_back(t);\\n            }\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<int>v(1001,0);\\n        for(int i=0;i<items1.size();i++){\\n            int ind=items1[i][0];\\n            int val=items1[i][1];\\n            v[ind]+=val;\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            int ind=items2[i][0];\\n            int val=items2[i][1];\\n            v[ind]+=val;\\n        }\\n\\n        vector<vector<int>>res;\\n       \\n        for(int i=0;i<v.size();i++){\\n\\n            if(v[i]!=0){\\n                vector<int>t;\\n                int val=i;\\n                int wt=v[i];\\n                t.push_back(val);\\n                t.push_back(wt);\\n                res.push_back(t);\\n            }\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636380,
                "title": "use-map-properties",
                "content": "```\\n  vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        for(auto it:items1){\\n            m[it[0]] += it[1];\\n        }\\n        for(auto it:items2){\\n            m[it[0]] +=it[1];\\n        }\\n        vector<vector<int>> ans;\\n        for(auto it:m){\\n            ans.push_back({it.first,it.second});\\n        }\\n        return ans;\\n            \\n        }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        for(auto it:items1){\\n            m[it[0]] += it[1];\\n        }\\n        for(auto it:items2){\\n            m[it[0]] +=it[1];\\n        }\\n        vector<vector<int>> ans;\\n        for(auto it:m){\\n            ans.push_back({it.first,it.second});\\n        }\\n        return ans;\\n            \\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632645,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> mp;\\n        \\n        for(int i = 0; i < items1.size(); i++)\\n            mp[items1[i][0]] += items1[i][1];\\n        for(int i = 0; i < items2.size(); i++)\\n            mp[items2[i][0]] += items2[i][1];\\n        \\n        vector<vector<int>> ret;\\n        \\n        for(auto it = mp.begin(); it != mp.end(); ++it)\\n            ret.push_back({it->first, it->second});\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> mp;\\n        \\n        for(int i = 0; i < items1.size(); i++)\\n            mp[items1[i][0]] += items1[i][1];\\n        for(int i = 0; i < items2.size(); i++)\\n            mp[items2[i][0]] += items2[i][1];\\n        \\n        vector<vector<int>> ret;\\n        \\n        for(auto it = mp.begin(); it != mp.end(); ++it)\\n            ret.push_back({it->first, it->second});\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599043,
                "title": "efficient-java-solution-uses-an-array-as-a-map",
                "content": "Key insights here are that the weight is always above zero, and value can\\'t be more than 1000.\\nThis means that we can easily use a sparse array as a map.\\nThe key of the \"map\" is the item value, and also the index into the array.\\nThe value of the \"map\" is the item weight, where zero denotes an empty slot.\\nNote that in this approach, the \"map\" is inherently sorted by key.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        int[] map = new int[1000];\\n        \\n\\t\\t// Populate map with weights from items1.\\n        for (int[] item : items1) {\\n            map[item[0]-1] = item[1];\\n        }\\n        \\n\\t\\t// Add weights from items2. Note that the current weight will be zero if it wasn\\'t populated above.\\n        for (int[] item : items2) {\\n            map[item[0]-1] = map[item[0]-1] + item[1];\\n        }\\n        \\n        List<List<Integer>> ret = new ArrayList<>(items1.length + items2.length);\\n\\t\\t// Infer value from array index and add pair to list if weight is non-zero.\\n        for (int i = 0; i < map.length; i++) {\\n            if (map[i] > 0) {\\n                ret.add(List.of(i+1, map[i]));\\n            }\\n        }\\n        return ret;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        int[] map = new int[1000];\\n        \\n\\t\\t// Populate map with weights from items1.\\n        for (int[] item : items1) {\\n            map[item[0]-1] = item[1];\\n        }\\n        \\n\\t\\t// Add weights from items2. Note that the current weight will be zero if it wasn\\'t populated above.\\n        for (int[] item : items2) {\\n            map[item[0]-1] = map[item[0]-1] + item[1];\\n        }\\n        \\n        List<List<Integer>> ret = new ArrayList<>(items1.length + items2.length);\\n\\t\\t// Infer value from array index and add pair to list if weight is non-zero.\\n        for (int i = 0; i < map.length; i++) {\\n            if (map[i] > 0) {\\n                ret.add(List.of(i+1, map[i]));\\n            }\\n        }\\n        return ret;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587066,
                "title": "c-easy-to-understand-75-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        map<int, int> m;\\n        \\n        for(auto& x : items1){\\n            \\n            m[x[0]] += x[1];\\n            \\n        }\\n        \\n        for(auto& x : items2){\\n            \\n            m[x[0]] += x[1];\\n            \\n        }\\n        \\n        for(auto x : m){\\n            \\n            ans.push_back({x.first, x.second});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        map<int, int> m;\\n        \\n        for(auto& x : items1){\\n            \\n            m[x[0]] += x[1];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2579895,
                "title": "cpp-hashmap-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n       int n1=items1.size(),n2=items2.size(),i;\\n        unordered_map<int,int>m;\\n        vector<int>v;\\n        vector<vector<int>>ans;\\n         for(i=0;i<n1;i++)\\n            m[items1[i][0]]+=items1[i][1];\\n         for(i=0;i<n2;i++)\\n            m[items2[i][0]]+=items2[i][1];\\n        for(auto i:m){\\n            v.push_back(i.first);\\n            v.push_back(i.second);\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n       int n1=items1.size(),n2=items2.size(),i;\\n        unordered_map<int,int>m;\\n        vector<int>v;\\n        vector<vector<int>>ans;\\n         for(i=0;i<n1;i++)\\n            m[items1[i][0]]+=items1[i][1];\\n         for(i=0;i<n2;i++)\\n            m[items2[i][0]]+=items2[i][1];\\n        for(auto i:m){\\n            v.push_back(i.first);\\n            v.push_back(i.second);\\n            ans.push_back(v);\\n            v.clear();\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554921,
                "title": "easy-clear-solution",
                "content": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        map<int, int> m;\\n        \\n        for(auto& x : items1){\\n            \\n            m[x[0]] += x[1];\\n            \\n        }\\n        \\n        for(auto& x : items2){\\n            \\n            m[x[0]] += x[1];\\n            \\n        }\\n        \\n        for(auto x : m){\\n            \\n            ans.push_back({x.first, x.second});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        map<int, int> m;\\n        \\n        for(auto& x : items1){\\n            \\n            m[x[0]] += x[1];\\n            \\n        }\\n        \\n        for(auto& x : items2){\\n            \\n            m[x[0]] += x[1];\\n            \\n        }\\n        \\n        for(auto x : m){\\n            \\n            ans.push_back({x.first, x.second});\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553937,
                "title": "java-solution-using-maps-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Map<Integer,Integer> map = new TreeMap<>();\\n        for(int[] i : items1){\\n            map.put(i[0],map.getOrDefault(i[0],0)+i[1]);\\n        }\\n        for(int[] i : items2){\\n            map.put(i[0],map.getOrDefault(i[0],0)+i[1]);\\n        }\\n        for(Map.Entry<Integer,Integer> i : map.entrySet()){\\n            ans.add(Arrays.asList(i.getKey(),i.getValue()));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Map<Integer,Integer> map = new TreeMap<>();\\n        for(int[] i : items1){\\n            map.put(i[0],map.getOrDefault(i[0],0)+i[1]);\\n        }\\n        for(int[] i : items2){\\n            map.put(i[0],map.getOrDefault(i[0],0)+i[1]);\\n        }\\n        for(Map.Entry<Integer,Integer> i : map.entrySet()){\\n            ans.add(Arrays.asList(i.getKey(),i.getValue()));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548679,
                "title": "c-map-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> mp;\\n        for(int i = 0 ;i < items1.size(); i++)\\n        {\\n            mp[items1[i][0]] = items1[i][1];\\n        }\\n        for(int i = 0 ;i < items2.size(); i++)\\n        {\\n           if(mp.count(items2[i][0]) == 0)\\n               mp[items2[i][0]] = items2[i][1];\\n            else\\n                mp[items2[i][0]] += items2[i][1];\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i : mp)\\n            ans.push_back({i.first, i.second});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> mp;\\n        for(int i = 0 ;i < items1.size(); i++)\\n        {\\n            mp[items1[i][0]] = items1[i][1];\\n        }\\n        for(int i = 0 ;i < items2.size(); i++)\\n        {\\n           if(mp.count(items2[i][0]) == 0)\\n               mp[items2[i][0]] = items2[i][1];\\n            else\\n                mp[items2[i][0]] += items2[i][1];\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i : mp)\\n            ans.push_back({i.first, i.second});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497049,
                "title": "easy-100-java-solution",
                "content": "# About Me\\n\\n<p align=\"center\">\\n  <a href=\"https://github.com/professorDeveloper\"><img src=\"https://readme-typing-svg.herokuapp.com?font=Time+New+Roman&color=%23C8BE25&size=25&center=true&vCenter=true&width=500&height=100&lines=I+am+Hud+Azamov;I+am+Mobile+Developer;Hello+LeetCode;Mobile+Programmer;I+am+from+Uzbekistan;My+best+code+Kotlin;\\uD83C\\uDF31+I\\u2019m+currently+learning+Flutter;\\uD83D\\uDC6F+I\\u2019m+looking+to+collaborate+with+other+content+creators\"></a>\\n</p>\\n\\n![image](https://assets.leetcode.com/users/images/f6435dcc-81b3-437b-8464-2d897a484fac_1661712938.9733615.gif)\\n\\n# Java solution\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        int[] valueWeight = new int[1001];\\n        addValueWeight(valueWeight, items1);\\n        addValueWeight(valueWeight, items2);\\n        for (int i = 0; i < valueWeight.length; i++) {\\n            if (valueWeight[i] > 0) {\\n                answer.add(List.of(i, valueWeight[i]));\\n            }\\n        }\\n        return answer;\\n    }\\n    private void addValueWeight(int[] valueWeight, int[][] items) {\\n        for(int[] item : items) {\\n            valueWeight[item[0]] += item[1];\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        int[] valueWeight = new int[1001];\\n        addValueWeight(valueWeight, items1);\\n        addValueWeight(valueWeight, items2);\\n        for (int i = 0; i < valueWeight.length; i++) {\\n            if (valueWeight[i] > 0) {\\n                answer.add(List.of(i, valueWeight[i]));\\n            }\\n        }\\n        return answer;\\n    }\\n    private void addValueWeight(int[] valueWeight, int[][] items) {\\n        for(int[] item : items) {\\n            valueWeight[item[0]] += item[1];\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497026,
                "title": "1-0-0-java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        int[] valueWeight = new int[1001];\\n        addValueWeight(valueWeight, items1);\\n        addValueWeight(valueWeight, items2);\\n        for (int i = 0; i < valueWeight.length; i++) {\\n            if (valueWeight[i] > 0) {\\n                answer.add(List.of(i, valueWeight[i]));\\n            }\\n        }\\n        return answer;\\n    }\\n    private void addValueWeight(int[] valueWeight, int[][] items) {\\n        for(int[] item : items) {\\n            valueWeight[item[0]] += item[1];\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        int[] valueWeight = new int[1001];\\n        addValueWeight(valueWeight, items1);\\n        addValueWeight(valueWeight, items2);\\n        for (int i = 0; i < valueWeight.length; i++) {\\n            if (valueWeight[i] > 0) {\\n                answer.add(List.of(i, valueWeight[i]));\\n            }\\n        }\\n        return answer;\\n    }\\n    private void addValueWeight(int[] valueWeight, int[][] items) {\\n        for(int[] item : items) {\\n            valueWeight[item[0]] += item[1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488923,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& arr1, vector<vector<int>>& arr2) {\\n         map<int,int>mp;    //value -->sum of that all values weight\\n    \\n        for(int i=0;i<arr1.size();i++)\\n        {\\n           vector<int>temp=arr1[i];\\n           int val=temp[0];\\n           int wt=temp[1];\\n\\n           mp[val]=mp[val]+wt;\\n        }\\n        for(int i=0;i<arr2.size();i++)\\n        {\\n           vector<int>temp=arr2[i];\\n           int val=temp[0];\\n           int wt=temp[1];\\n\\n           mp[val]=mp[val]+wt;\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            ans.push_back({it->first,it->second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& arr1, vector<vector<int>>& arr2) {\\n         map<int,int>mp;    //value -->sum of that all values weight\\n    \\n        for(int i=0;i<arr1.size();i++)\\n        {\\n           vector<int>temp=arr1[i];\\n           int val=temp[0];\\n           int wt=temp[1];\\n\\n           mp[val]=mp[val]+wt;\\n        }\\n        for(int i=0;i<arr2.size();i++)\\n        {\\n           vector<int>temp=arr2[i];\\n           int val=temp[0];\\n           int wt=temp[1];\\n\\n           mp[val]=mp[val]+wt;\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            ans.push_back({it->first,it->second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480956,
                "title": "python-3-line-solution-counter-update",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        \\n        c = Counter(dict(items1))\\n        \\n        c.update(dict(items2))\\n        \\n        return sorted(c.items(), key=lambda x : x[0])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        \\n        c = Counter(dict(items1))\\n        \\n        c.update(dict(items2))\\n        \\n        return sorted(c.items(), key=lambda x : x[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454685,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> l = new LinkedList<>();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<items1.length;i++){\\n            map.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i=0;i<items2.length;i++){\\n            if(map.containsKey(items2[i][0])){\\n                int val= map.get(items2[i][0]);\\n                map.put(items2[i][0], val+items2[i][1]);\\n            }\\n            else{\\n                map.put(items2[i][0],items2[i][1]);\\n            }\\n        }\\n        for(Map.Entry<Integer, Integer> entry: map.entrySet()){\\n            l.add(Arrays.asList(entry.getKey(), entry.getValue()));\\n        }\\n         l.sort((l1, l2) -> l1.get(0).compareTo(l2.get(0)));\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> l = new LinkedList<>();\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<items1.length;i++){\\n            map.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i=0;i<items2.length;i++){\\n            if(map.containsKey(items2[i][0])){\\n                int val= map.get(items2[i][0]);\\n                map.put(items2[i][0], val+items2[i][1]);\\n            }\\n            else{\\n                map.put(items2[i][0],items2[i][1]);\\n            }\\n        }\\n        for(Map.Entry<Integer, Integer> entry: map.entrySet()){\\n            l.add(Arrays.asList(entry.getKey(), entry.getValue()));\\n        }\\n         l.sort((l1, l2) -> l1.get(0).compareTo(l2.get(0)));\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434510,
                "title": "easy-short-fast-solution-treemap",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        List<List<Integer>> ans = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        for (int[] i: items1) map.put(i[0], i[1]);\\n\\n        for (int[] i: items2) map.merge(i[0], i[1], Integer::sum);\\n\\n        for(int i: map.keySet()) ans.add(Arrays.asList(i, map.get(i)));\\n\\n        return ans;",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431864,
                "title": "using-quicksort-4ms-43-2mb",
                "content": "\\n\\tpublic List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        //sort\\n        quickSort(items1);\\n        quickSort(items2);\\n        //itorate\\n        int items1Index=0,items2Index=0;\\n        while(items1Index < items1.length || items2Index < items2.length){\\n            List<Integer> temp = new ArrayList<>();\\n            if(items1Index == items1.length){\\n                temp.add(items2[items2Index][0]);\\n                temp.add(items2[items2Index++][1]);\\n                res.add(temp);\\n            } else if(items2Index == items2.length){\\n                temp.add(items1[items1Index][0]);\\n                temp.add(items1[items1Index++][1]);\\n                res.add(temp);\\n            } else {\\n                if(items1[items1Index][0] == items2[items2Index][0]){\\n                    temp.add(items1[items1Index][0]);\\n                    temp.add(items1[items1Index++][1] + items2[items2Index++][1]);\\n                    res.add(temp);\\n                } else if(items1[items1Index][0] < items2[items2Index][0]){\\n                    temp.add(items1[items1Index][0]);\\n                    temp.add(items1[items1Index++][1]);\\n                    res.add(temp);\\n                } else {\\n                    temp.add(items2[items2Index][0]);\\n                    temp.add(items2[items2Index++][1]);\\n                    res.add(temp);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static void quickSort(int arr[][]){\\n        quickSortPri(arr,0,arr.length-1);\\n    }\\n\\n    private static void quickSortPri(int arr[][],int _left,int _right){\\n        int left = _left;\\n        int right = _right;\\n        int[] temp;\\n        if(left <= right){\\n            temp = arr[left];\\n            while(left != right){\\n\\n                while(right > left && arr[right][0] >= temp[0])\\n                    right --;\\n                arr[left] = arr[right];\\n\\n                while(left < right && arr[left][0] <= temp[0])\\n                    left ++;\\n                arr[right] = arr[left];\\n\\n            }\\n            arr[right] = temp;\\n            quickSortPri(arr,_left,left-1);\\n            quickSortPri(arr, right+1,_right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\tpublic List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        //sort\\n        quickSort(items1);\\n        quickSort(items2);\\n        //itorate\\n        int items1Index=0,items2Index=0;\\n        while(items1Index < items1.length || items2Index < items2.length){\\n            List<Integer> temp = new ArrayList<>();\\n            if(items1Index == items1.length){\\n                temp.add(items2[items2Index][0]);\\n                temp.add(items2[items2Index++][1]);\\n                res.add(temp);\\n            } else if(items2Index == items2.length){\\n                temp.add(items1[items1Index][0]);\\n                temp.add(items1[items1Index++][1]);\\n                res.add(temp);\\n            } else {\\n                if(items1[items1Index][0] == items2[items2Index][0]){\\n                    temp.add(items1[items1Index][0]);\\n                    temp.add(items1[items1Index++][1] + items2[items2Index++][1]);\\n                    res.add(temp);\\n                } else if(items1[items1Index][0] < items2[items2Index][0]){\\n                    temp.add(items1[items1Index][0]);\\n                    temp.add(items1[items1Index++][1]);\\n                    res.add(temp);\\n                } else {\\n                    temp.add(items2[items2Index][0]);\\n                    temp.add(items2[items2Index++][1]);\\n                    res.add(temp);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static void quickSort(int arr[][]){\\n        quickSortPri(arr,0,arr.length-1);\\n    }\\n\\n    private static void quickSortPri(int arr[][],int _left,int _right){\\n        int left = _left;\\n        int right = _right;\\n        int[] temp;\\n        if(left <= right){\\n            temp = arr[left];\\n            while(left != right){\\n\\n                while(right > left && arr[right][0] >= temp[0])\\n                    right --;\\n                arr[left] = arr[right];\\n\\n                while(left < right && arr[left][0] <= temp[0])\\n                    left ++;\\n                arr[right] = arr[left];\\n\\n            }\\n            arr[right] = temp;\\n            quickSortPri(arr,_left,left-1);\\n            quickSortPri(arr, right+1,_right);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2426372,
                "title": "c-well-commented-100-fast-maps",
                "content": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        map<int,int> m;//declare map\\n        vector<vector<int>> ans;\\n\\n    \\n        for(int i=0;i<items1.size();i++) //put every item of item1 in map\\n            m[items1[i][0]]=items1[i][1];\\n        \\n        for(int i=0;i<items2.size();i++)//for every element in item 2\\n            if(m.find(items2[i][0])!=m.end())//if it is already present in item1\\n                m[items2[i][0]]+=items2[i][1];//simply add it to existing value\\n            else\\n                m[items2[i][0]]=items2[i][1];//else add as new value\\n            \\n        \\n        for(auto it : m)\\n            ans.push_back({it.first,it.second});//simply print the map\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        map<int,int> m;//declare map\\n        vector<vector<int>> ans;\\n\\n    \\n        for(int i=0;i<items1.size();i++) //put every item of item1 in map\\n            m[items1[i][0]]=items1[i][1];\\n        \\n        for(int i=0;i<items2.size();i++)//for every element in item 2\\n            if(m.find(items2[i][0])!=m.end())//if it is already present in item1\\n                m[items2[i][0]]+=items2[i][1];//simply add it to existing value\\n            else\\n                m[items2[i][0]]=items2[i][1];//else add as new value\\n            \\n        \\n        for(auto it : m)\\n            ans.push_back({it.first,it.second});//simply print the map\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417622,
                "title": "100-fast-java-solution-with-treemap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> l = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i<items1.length; i++){\\n             map.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i = 0; i<items2.length; i++){\\n            int index = items2[i][0];\\n            int val = items2[i][1];\\n            map.put(index,map.getOrDefault(index,0)+val);\\n        }\\n        for(var i: map.entrySet()){\\n            l.add(Arrays.asList(i.getKey(), i.getValue()));\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> l = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i<items1.length; i++){\\n             map.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i = 0; i<items2.length; i++){\\n            int index = items2[i][0];\\n            int val = items2[i][1];\\n            map.put(index,map.getOrDefault(index,0)+val);\\n        }\\n        for(var i: map.entrySet()){\\n            l.add(Arrays.asList(i.getKey(), i.getValue()));\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406550,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function (items1, items2) {\\n  const result = {};\\n\\n  for (const [key, value] of [...items1, ...items2]) {\\n    result[key] = result[key] ? result[key] + value : value;\\n  }\\n\\n  return Object.entries(result);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function (items1, items2) {\\n  const result = {};\\n\\n  for (const [key, value] of [...items1, ...items2]) {\\n    result[key] = result[key] ? result[key] + value : value;\\n  }\\n\\n  return Object.entries(result);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406041,
                "title": "swift-simple-with-dictionary-100-faster",
                "content": "```\\nclass Solution {\\n    func mergeSimilarItems(_ items1: [[Int]], _ items2: [[Int]]) -> [[Int]] {\\n        \\n        var answer: [[Int]] = []\\n        let dict = Dictionary((items1+items2).map { ($0[0], $0[1]) } , uniquingKeysWith: +)\\n\\n        dict.sorted{ $0.key < $1.key }.forEach {\\n            answer.append([$0.key, $0.value])\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mergeSimilarItems(_ items1: [[Int]], _ items2: [[Int]]) -> [[Int]] {\\n        \\n        var answer: [[Int]] = []\\n        let dict = Dictionary((items1+items2).map { ($0[0], $0[1]) } , uniquingKeysWith: +)\\n\\n        dict.sorted{ $0.key < $1.key }.forEach {\\n            answer.append([$0.key, $0.value])\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403629,
                "title": "simple-java-solution-using-treemap",
                "content": "class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for(int[] arr : items1){\\n            if(!map.containsKey(arr[0])){\\n                map.put(arr[0], arr[1]);\\n            } else{\\n                Integer i = map.get(arr[0]);\\n                map.put(arr[0], arr[1]+i);\\n            }\\n        }\\n        \\n        for(int[] arr : items2){\\n            if(!map.containsKey(arr[0])){\\n                map.put(arr[0], arr[1]);\\n            } else{\\n                Integer i = map.get(arr[0]);\\n                map.put(arr[0], arr[1]+i);\\n            }\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        map.forEach( (k,v) -> {\\n            List<Integer> ls = new ArrayList<>();\\n            ls.add(k);\\n            ls.add(v);\\n            res.add(ls);\\n        });\\n        \\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for(int[] arr : items1){\\n            if(!map.containsKey(arr[0])){\\n                map.put(arr[0], arr[1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2400445,
                "title": "java-easy-commented",
                "content": "```\\nclass Solution {\\n    // frequency array means taking into account how many times an value has occured \\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        List<List<Integer>> ret = new ArrayList<>();\\n        int max = Integer.MIN_VALUE;\\n        \\n        // first find out the largest value out of both the matrices; to take it as frequency array size\\n        for(int i = 0; i < items1.length; i++){\\n            max = Math.max(max, items1[i][0]);\\n        }\\n        for(int i = 0; i < items2.length; i++){\\n            max = Math.max(max, items2[i][0]);\\n        }\\n        \\n        int[] arr = new int[max + 1]; // make an array of that max value (max + 1);\\n        \\n        \\n        // now add the weights in the (value)index of the array\\n        for(int i = 0; i < items1.length; i++){\\n            arr[items1[i][0]] += items1[i][1];\\n        }\\n        for(int i = 0; i < items2.length; i++){\\n            arr[items2[i][0]] += items2[i][1];\\n        }\\n        \\n        \\n        // now we traverse from start to get elements in order, and if the array value is not equal to 0, \\n        //  we add the index & value pair in our resultant arraylist\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] != 0){\\n                List<Integer> ne = new ArrayList<>();\\n                ne.add(i);\\n                ne.add(arr[i]);\\n                ret.add(ne);\\n                \\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // frequency array means taking into account how many times an value has occured \\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        \\n        List<List<Integer>> ret = new ArrayList<>();\\n        int max = Integer.MIN_VALUE;\\n        \\n        // first find out the largest value out of both the matrices; to take it as frequency array size\\n        for(int i = 0; i < items1.length; i++){\\n            max = Math.max(max, items1[i][0]);\\n        }\\n        for(int i = 0; i < items2.length; i++){\\n            max = Math.max(max, items2[i][0]);\\n        }\\n        \\n        int[] arr = new int[max + 1]; // make an array of that max value (max + 1);\\n        \\n        \\n        // now add the weights in the (value)index of the array\\n        for(int i = 0; i < items1.length; i++){\\n            arr[items1[i][0]] += items1[i][1];\\n        }\\n        for(int i = 0; i < items2.length; i++){\\n            arr[items2[i][0]] += items2[i][1];\\n        }\\n        \\n        \\n        // now we traverse from start to get elements in order, and if the array value is not equal to 0, \\n        //  we add the index & value pair in our resultant arraylist\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] != 0){\\n                List<Integer> ne = new ArrayList<>();\\n                ne.add(i);\\n                ne.add(arr[i]);\\n                ret.add(ne);\\n                \\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399098,
                "title": "very-easy-c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        \\n        map<int,int>mp;\\n        for(int i=0;i<items1.size();i++){\\n            mp[items1[i][0]]=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            if(mp.find(items2[i][0])!=mp.end()){\\n                mp[items2[i][0]]+=items2[i][1];\\n            }\\n            else{\\n                mp[items2[i][0]]=items2[i][1];\\n            }\\n           \\n        }\\n        vector<vector<int>>ans;\\n         for(auto it:mp){\\n                ans.push_back({it.first,it.second});\\n            }\\n            return ans;\\n        }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        \\n        map<int,int>mp;\\n        for(int i=0;i<items1.size();i++){\\n            mp[items1[i][0]]=items1[i][1];\\n        }\\n        for(int i=0;i<items2.size();i++){\\n            if(mp.find(items2[i][0])!=mp.end()){\\n                mp[items2[i][0]]+=items2[i][1];\\n            }\\n            else{\\n                mp[items2[i][0]]=items2[i][1];\\n            }\\n           \\n        }\\n        vector<vector<int>>ans;\\n         for(auto it:mp){\\n                ans.push_back({it.first,it.second});\\n            }\\n            return ans;\\n        }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399049,
                "title": "c-maps-eazy",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\t\\n\\t\\tvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int , int> mp;\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i=0 ;i<items1.size() ;i++){ \\n            int val = items1[i][0];\\n            mp[val] = items1[i][1]; \\n        }\\n        \\n        for(int i = 0 ; i<items2.size() ; i++ ){ \\n            int val = items2[i][0];\\n            mp[val] += items2[i][1];   \\n        }\\n        \\n        for(auto i : mp){\\n            ans.push_back({i.first,i.second});\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\t\\n\\t\\tvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int , int> mp;\\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i=0 ;i<items1.size() ;i++){ \\n            int val = items1[i][0];\\n            mp[val] = items1[i][1]; \\n        }\\n        \\n        for(int i = 0 ; i<items2.size() ; i++ ){ \\n            int val = items2[i][0];\\n            mp[val] += items2[i][1];   \\n        }\\n        \\n        for(auto i : mp){\\n            ans.push_back({i.first,i.second});\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2398818,
                "title": "c-easy-solution-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mp;\\n        for(int i=0;i<items1.size();i++){\\n            mp[items1[i][0]] += items1[i][1]; \\n        }\\n        \\n        for(int i=0;i<items2.size();i++){\\n            mp[items2[i][0]] +=items2[i][1] ;\\n        }\\n        \\n        vector<int> v;\\n        vector<vector<int>>res;\\n        for(auto it: mp){\\n            v.push_back(it.first);\\n            v.push_back(it.second);\\n            res.push_back(v);\\n            v.clear();\\n        }\\n        \\n        return res;\\n      \\n    \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mp;\\n        for(int i=0;i<items1.size();i++){\\n            mp[items1[i][0]] += items1[i][1]; \\n        }\\n        \\n        for(int i=0;i<items2.size();i++){\\n            mp[items2[i][0]] +=items2[i][1] ;\\n        }\\n        \\n        vector<int> v;\\n        vector<vector<int>>res;\\n        for(auto it: mp){\\n            v.push_back(it.first);\\n            v.push_back(it.second);\\n            res.push_back(v);\\n            v.clear();\\n        }\\n        \\n        return res;\\n      \\n    \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398152,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> list =new  ArrayList<List<Integer>>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int[] x:items1)\\n        {\\n            map.put(x[0],x[1]);\\n        }\\n        for(int[] x:items2)\\n        {\\n            if(map.get(x[0])!=null)\\n            map.put(x[0],map.get(x[0])+x[1]);\\n            else\\n            map.put(x[0],x[1]);\\n        }\\n        for(int i=0;i<map.values().size();i++)\\n            list.add(new ArrayList<Integer>());\\n        int i=0;\\n        ArrayList<Integer> keys = new ArrayList<>(map.keySet());\\n        Collections.sort(keys);\\n        for(int x:keys)\\n        {\\n            list.get(i).add(x);\\n            list.get(i).add(map.get(x));\\n            i++;\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> list =new  ArrayList<List<Integer>>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int[] x:items1)\\n        {\\n            map.put(x[0],x[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2397128,
                "title": "golang-solution-18ms-100",
                "content": "Runtime: 18 ms, faster than 100.00% of Go online submissions for Merge Similar Items.\\nMemory Usage: 6.6 MB, less than 100.00% of Go online submissions for Merge Similar Items.\\n\\n```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) [][]int {\\n    m := make(map[int]int)\\n    for _, items := range items1 {\\n        if v, ok := m[items[0]]; ok {\\n            m[items[0]] = v + items[1]\\n        } else {\\n            m[items[0]] = items[1]\\n        }\\n    }\\n    for _, items := range items2 {\\n        if v, ok := m[items[0]]; ok {\\n            m[items[0]] = v + items[1]\\n        } else {\\n            m[items[0]] = items[1]\\n        }\\n    }\\n    ans := make([][]int, 0, len(m))\\n    for k, v := range m {\\n        t := []int{k, v}\\n        ans = append(ans, t)\\n    }\\n    sort.Slice(ans, func(i, j int) bool { return ans[i][0] < ans[j][0] })\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) [][]int {\\n    m := make(map[int]int)\\n    for _, items := range items1 {\\n        if v, ok := m[items[0]]; ok {\\n            m[items[0]] = v + items[1]\\n        } else {\\n            m[items[0]] = items[1]\\n        }\\n    }\\n    for _, items := range items2 {\\n        if v, ok := m[items[0]]; ok {\\n            m[items[0]] = v + items[1]\\n        } else {\\n            m[items[0]] = items[1]\\n        }\\n    }\\n    ans := make([][]int, 0, len(m))\\n    for k, v := range m {\\n        t := []int{k, v}\\n        ans = append(ans, t)\\n    }\\n    sort.Slice(ans, func(i, j int) bool { return ans[i][0] < ans[j][0] })\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2395642,
                "title": "fastest-easy-java-solution-using-hashmap-lamda",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> llist = new ArrayList<>();\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int arr[]:items1){\\n            hmap.put(arr[0],arr[1]);\\n        }\\n        for(int arr[]:items2){\\n            if(hmap.containsKey(arr[0]))\\n            {\\n                int weight = hmap.get(arr[0]) + arr[1];\\n                hmap.put(arr[0],weight);\\n            }\\n            else{\\n                hmap.put(arr[0],arr[1]);\\n            }\\n        }\\n        for(int key:hmap.keySet()){\\n            List<Integer> list = new ArrayList<>();\\n            list.add(key);\\n            list.add(hmap.get(key));\\n            llist.add(list);\\n        }\\n        llist.sort((x, y) -> {\\n            for (int i = 0; i < Math.min(x.size(), y.size()); i++) {\\n                if (x.get(i) != y.get(i)) {\\n                    return x.get(i) - y.get(i);\\n                }\\n            }\\n            return x.size() - y.size();\\n        });\\n        return llist;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> llist = new ArrayList<>();\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int arr[]:items1){\\n            hmap.put(arr[0],arr[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2392297,
                "title": "easy-intuitive-code",
                "content": "```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) [][]int {\\n    hashMap := make(map[int]int, 1000)\\n    for _, val := range items1 {\\n        value, weight := val[0], val[1]\\n        hashMap[value] = weight\\n    }\\n    for _, val := range items2 {\\n        value, weight := val[0], val[1]\\n        if prevWeight, ok := hashMap[value]; ok {\\n            hashMap[value] = prevWeight + weight\\n        }else{\\n            hashMap[value] = weight\\n        }\\n    }\\n    returnValue := make([][]int, 0, len(hashMap))\\n    for key, val := range hashMap {\\n        returnValue = append(returnValue, []int{key, val})\\n    }\\n    sort.Slice(returnValue, func(i, j int) bool {\\n        return returnValue[i][0] < returnValue[j][0]\\n    })\\n    return returnValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) [][]int {\\n    hashMap := make(map[int]int, 1000)\\n    for _, val := range items1 {\\n        value, weight := val[0], val[1]\\n        hashMap[value] = weight\\n    }\\n    for _, val := range items2 {\\n        value, weight := val[0], val[1]\\n        if prevWeight, ok := hashMap[value]; ok {\\n            hashMap[value] = prevWeight + weight\\n        }else{\\n            hashMap[value] = weight\\n        }\\n    }\\n    returnValue := make([][]int, 0, len(hashMap))\\n    for key, val := range hashMap {\\n        returnValue = append(returnValue, []int{key, val})\\n    }\\n    sort.Slice(returnValue, func(i, j int) bool {\\n        return returnValue[i][0] < returnValue[j][0]\\n    })\\n    return returnValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391774,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        a=sorted(items1+items2)\\n        s=[]\\n        if len(a)==2:\\n            for i in range(len(a)):\\n                if a[i-1][0]==a[i][0]:\\n                    a[i-1][1]=a[i-1][1]+a[i][1]\\n                    a=sorted(a)\\n                    if a[i-1] not in s:\\n                        s.append(a[i-1])\\n                elif a[i-1][0]!=a[i][0]:\\n                    a=sorted(a)\\n                    if a[i-1] not in s:\\n                        s.append(a[i-1])\\n        else:\\n            for i in range(len(a)):\\n                if a[i][0]==a[i-1][0]:\\n                    a[i][1],a[i-1][1]=a[i-1][1]+a[i][1],a[i-1][1]+a[i][1]\\n            for i in range(len(a)):\\n                if a[i] not in s:\\n                    s.append(a[i])\\n        return sorted(s)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        a=sorted(items1+items2)\\n        s=[]\\n        if len(a)==2:\\n            for i in range(len(a)):\\n                if a[i-1][0]==a[i][0]:\\n                    a[i-1][1]=a[i-1][1]+a[i][1]\\n                    a=sorted(a)\\n                    if a[i-1] not in s:\\n                        s.append(a[i-1])\\n                elif a[i-1][0]!=a[i][0]:\\n                    a=sorted(a)\\n                    if a[i-1] not in s:\\n                        s.append(a[i-1])\\n        else:\\n            for i in range(len(a)):\\n                if a[i][0]==a[i-1][0]:\\n                    a[i][1],a[i-1][1]=a[i-1][1]+a[i][1],a[i-1][1]+a[i][1]\\n            for i in range(len(a)):\\n                if a[i] not in s:\\n                    s.append(a[i])\\n        return sorted(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391558,
                "title": "c-map-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n         map < int , int > mpp;\\n    \\n        for ( int i = 0 ; i < items1.size() ; i++ )\\n        {\\n            mpp[items1[i][0]] = items1[i][1];  \\n        }\\n        for ( int i = 0 ; i < items2.size() ; i++ )\\n        {\\n            mpp[items2[i][0]] += items2[i][1];  \\n        }\\n        \\n        vector < vector < int > > ans;\\n        \\n        for ( auto i : mpp ) {   \\n            vector < int > v;\\n            v.push_back(i.first);\\n            v.push_back(i.second);\\n            ans.push_back(v);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n         map < int , int > mpp;\\n    \\n        for ( int i = 0 ; i < items1.size() ; i++ )\\n        {\\n            mpp[items1[i][0]] = items1[i][1];  \\n        }\\n        for ( int i = 0 ; i < items2.size() ; i++ )\\n        {\\n            mpp[items2[i][0]] += items2[i][1];  \\n        }\\n        \\n        vector < vector < int > > ans;\\n        \\n        for ( auto i : mpp ) {   \\n            vector < int > v;\\n            v.push_back(i.first);\\n            v.push_back(i.second);\\n            ans.push_back(v);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389503,
                "title": "100-best-space",
                "content": "class Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        merge_item = items1 + items2\\n        d ={}\\n        for i in merge_item:\\n            if i[0] not in d:\\n                d[i[0]]=i[1]\\n            else:\\n                d[i[0]]=i[1]+d[i[0]]\\n        r = []\\n        for i in sorted(d):\\n            r.append([i,d[i]])\\n        return r\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        merge_item = items1 + items2\\n        d ={}",
                "codeTag": "Java"
            },
            {
                "id": 2389318,
                "title": "c-3-line-code-simple-approach",
                "content": "![image](https://assets.leetcode.com/users/images/7d5edded-013f-4102-b1bf-82f3142e18df_1659812119.7522228.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> mergeSimilarItems(vector<vector<int>>& i1, vector<vector<int>>& i2) {\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tfor(auto i:i1) mp[i[0]]+=i[1];\\n\\t\\t\\tfor(auto i:i2) mp[i[0]]+=i[1];\\n\\t\\t\\tfor(auto i:mp) ans.push_back({i.first,i.second});\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> mergeSimilarItems(vector<vector<int>>& i1, vector<vector<int>>& i2) {\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tfor(auto i:i1) mp[i[0]]+=i[1];\\n\\t\\t\\tfor(auto i:i2) mp[i[0]]+=i[1];\\n\\t\\t\\tfor(auto i:mp) ans.push_back({i.first,i.second}",
                "codeTag": "Java"
            },
            {
                "id": 2389227,
                "title": "c-easy-code-hashmap-implementation",
                "content": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n\\tunordered_map<int, int>mp;\\n\\tfor (int i = 0; i < items1.size(); i++) {\\n\\t\\tmp.insert({items1[i][0], items1[i][1]});\\n\\t}\\n\\tfor (int i = 0; i < items2.size(); i++) {\\n\\t\\tif (mp.find(items2[i][0]) != mp.end()) {\\n\\t\\t\\tauto it = mp[items2[i][0]];\\n\\t\\t\\tit = it + items2[i][1];\\n\\t\\t\\tmp[items2[i][0]] = it;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmp.insert({items2[i][0], items2[i][1]});\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>>ans;\\n\\tfor (auto it : mp) {\\n\\t\\tvector<int>v;\\n\\t\\tv.push_back(it.first);\\n\\t\\tv.push_back(it.second);\\n\\t\\tans.push_back(v);\\n\\t}\\n    sort(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n\\tunordered_map<int, int>mp;\\n\\tfor (int i = 0; i < items1.size(); i++) {\\n\\t\\tmp.insert({items1[i][0], items1[i][1]});\\n\\t}\\n\\tfor (int i = 0; i < items2.size(); i++) {\\n\\t\\tif (mp.find(items2[i][0]) != mp.end()) {\\n\\t\\t\\tauto it = mp[items2[i][0]];\\n\\t\\t\\tit = it + items2[i][1];\\n\\t\\t\\tmp[items2[i][0]] = it;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmp.insert({items2[i][0], items2[i][1]});\\n\\t\\t}\\n\\t}\\n\\tvector<vector<int>>ans;\\n\\tfor (auto it : mp) {\\n\\t\\tvector<int>v;\\n\\t\\tv.push_back(it.first);\\n\\t\\tv.push_back(it.second);\\n\\t\\tans.push_back(v);\\n\\t}\\n    sort(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389183,
                "title": "c-hashmap-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        for(auto x:items1)\\n        {\\n            m[x[0]]+=x[1];\\n        }\\n        for(auto x:items2)\\n        {\\n            m[x[0]]+=x[1];\\n        }\\n        vector<vector<int>> res;\\n        for(auto x:m)\\n            res.push_back({x.first,x.second});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        for(auto x:items1)\\n        {\\n            m[x[0]]+=x[1];\\n        }\\n        for(auto x:items2)\\n        {\\n            m[x[0]]+=x[1];\\n        }\\n        vector<vector<int>> res;\\n        for(auto x:m)\\n            res.push_back({x.first,x.second});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388701,
                "title": "c-easy-with-comments-and-explanation",
                "content": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n//             We Keep the bigger vector as item1 because we will store our result in this only and will also return it.\\n\\t\\t  if(items1.size()<items2.size())\\n\\t\\t\\t\\treturn mergeSimilarItems(items2,items1);\\n\\n\\t\\t\\t\\tint i=0,j=0,n1=items1.size(),n2=items2.size();\\n//             Sorting both the vectors on the basis of first element.\\n\\t\\tsort(items1.begin(),items1.end());   \\n\\t\\tsort(items2.begin(),items2.end());\\n\\n//             We will Traverse until the any vector is finished.\\n//             During traversal of vectors we check if any item matches then we add its weight to item1\\'s corresponding element.\\n//            if item2 element is more than item1 we increase the pointer of item1, because maybe the next element of item1 is equal to item1,\\n//             But if item1 is greater than item2 we add item2 to item1 and increase the counter for item2.\\n\\t\\twhile(i<n1 && j<n2)\\n\\t\\t{\\n\\t\\t\\t\\tif(items1[i][0]==items2[j][0])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\titems1[i][1]+=items2[j][1];\\n\\t\\t\\t\\t\\t\\ti++,j++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(items1[i][0]>items2[j][0])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\titems1.push_back(items2[j]);\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\n//             If remaining items2 are left to be inserted\\n\\t\\twhile(j<n2)\\n\\t\\t{\\n\\t\\t\\t\\titems1.push_back(items2[j]);\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\t// sorting because ans is required in sortede order\\n\\t\\tsort(items1.begin(),items1.end());\\n\\t\\treturn items1;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n//             We Keep the bigger vector as item1 because we will store our result in this only and will also return it.\\n\\t\\t  if(items1.size()<items2.size())\\n\\t\\t\\t\\treturn mergeSimilarItems(items2,items1);\\n\\n\\t\\t\\t\\tint i=0,j=0,n1=items1.size(),n2=items2.size();\\n//             Sorting both the vectors on the basis of first element.\\n\\t\\tsort(items1.begin(),items1.end());   \\n\\t\\tsort(items2.begin(),items2.end());\\n\\n//             We will Traverse until the any vector is finished.\\n//             During traversal of vectors we check if any item matches then we add its weight to item1\\'s corresponding element.\\n//            if item2 element is more than item1 we increase the pointer of item1, because maybe the next element of item1 is equal to item1,\\n//             But if item1 is greater than item2 we add item2 to item1 and increase the counter for item2.\\n\\t\\twhile(i<n1 && j<n2)\\n\\t\\t{\\n\\t\\t\\t\\tif(items1[i][0]==items2[j][0])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\titems1[i][1]+=items2[j][1];\\n\\t\\t\\t\\t\\t\\ti++,j++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(items1[i][0]>items2[j][0])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\titems1.push_back(items2[j]);\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\n//             If remaining items2 are left to be inserted\\n\\t\\twhile(j<n2)\\n\\t\\t{\\n\\t\\t\\t\\titems1.push_back(items2[j]);\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\t// sorting because ans is required in sortede order\\n\\t\\tsort(items1.begin(),items1.end());\\n\\t\\treturn items1;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388629,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn merge_similar_items(items1: Vec<Vec<i32>>, items2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut btm = std::collections::BTreeMap::new();\\n        items1\\n            .iter()\\n            .chain(items2.iter())\\n            .for_each(|pair| *btm.entry(pair[0]).or_insert(0) += pair[1]);\\n        btm.into_iter()\\n            .map(|(key, value)| vec![key, value])\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn merge_similar_items(items1: Vec<Vec<i32>>, items2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut btm = std::collections::BTreeMap::new();\\n        items1\\n            .iter()\\n            .chain(items2.iter())\\n            .for_each(|pair| *btm.entry(pair[0]).or_insert(0) += pair[1]);\\n        btm.into_iter()\\n            .map(|(key, value)| vec![key, value])\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388492,
                "title": "c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        sort(begin(nums1),end(nums1)) ;\\n        sort(begin(nums2),end(nums2)) ;\\n        \\n        vector<vector<int>> ans ;\\n        \\n        int i = 0 , j = 0 ;\\n        while(i < size(nums1) and j < size(nums2)){\\n            int v1 = nums1[i][0] , w1 = nums1[i][1] ;\\n            int v2 = nums2[j][0] , w2 = nums2[j][1] ;\\n            \\n            if(v1 < v2) ans.push_back({v1,w1}) , ++i ;\\n            else if(v1 > v2) ans.push_back({v2,w2}) , ++j ;\\n            else ans.push_back({v1,w1+w2}) , ++i, ++j ;\\n        }\\n        \\n        while(i < size(nums1)) ans.push_back({nums1[i][0] ,nums1[i][1]}), ++i ;\\n        while(j < size(nums2)) ans.push_back({nums2[j][0],nums2[j][1]}) , ++j ; \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        sort(begin(nums1),end(nums1)) ;\\n        sort(begin(nums2),end(nums2)) ;\\n        \\n        vector<vector<int>> ans ;\\n        \\n        int i = 0 , j = 0 ;\\n        while(i < size(nums1) and j < size(nums2)){\\n            int v1 = nums1[i][0] , w1 = nums1[i][1] ;\\n            int v2 = nums2[j][0] , w2 = nums2[j][1] ;\\n            \\n            if(v1 < v2) ans.push_back({v1,w1}) , ++i ;\\n            else if(v1 > v2) ans.push_back({v2,w2}) , ++j ;\\n            else ans.push_back({v1,w1+w2}) , ++i, ++j ;\\n        }\\n        \\n        while(i < size(nums1)) ans.push_back({nums1[i][0] ,nums1[i][1]}), ++i ;\\n        while(j < size(nums2)) ans.push_back({nums2[j][0],nums2[j][1]}) , ++j ; \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388420,
                "title": "cpp-easy-solution-with-explanation-easy-to-understand-with-map",
                "content": "**Explanation**\\n\\n***Step:--***\\n* create a map for store value and their corresponding weight\\n* store items1 value and their added weight\\n* store items2 value and their added weight\\n* store the value in vector\\n\\n**Easy Solution With MAP**\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> m;\\n        for(auto v : items1) \\n\\t\\t{\\n\\t\\tm[v[0]] += v[1];\\n\\t\\t}\\n        for(auto v : items2)\\n\\t\\t{\\n\\t\\tm[v[0]] += v[1];\\n\\t\\t}\\n        vector<vector<int>> ans;\\n        for(auto i : m) \\n\\t\\t{\\n\\t\\tans.push_back({i.first, i.second});\\n\\t\\t}\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int, int> m;\\n        for(auto v : items1) \\n\\t\\t{\\n\\t\\tm[v[0]] += v[1];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2388411,
                "title": "rust-hashmap",
                "content": "~~~\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn merge_similar_items(items1: Vec<Vec<i32>>, items2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut mp: HashMap<i32, i32> = HashMap::new();\\n        \\n        for p in items1 {\\n            *mp.entry(p[0]).or_default() += p[1];\\n        }\\n        \\n        for p in items2 {\\n            *mp.entry(p[0]).or_default() += p[1];\\n        }\\n        \\n        let mut ret: Vec<Vec<i32>> = vec![];\\n        \\n        for (key, value) in mp {\\n            ret.push(vec![key, value]);\\n        }\\n        ret.sort();\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn merge_similar_items(items1: Vec<Vec<i32>>, items2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut mp: HashMap<i32, i32> = HashMap::new();\\n        \\n        for p in items1 {\\n            *mp.entry(p[0]).or_default() += p[1];\\n        }\\n        \\n        for p in items2 {\\n            *mp.entry(p[0]).or_default() += p[1];\\n        }\\n        \\n        let mut ret: Vec<Vec<i32>> = vec![];\\n        \\n        for (key, value) in mp {\\n            ret.push(vec![key, value]);\\n        }\\n        ret.sort();\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2388395,
                "title": "hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        vector<vector<int>> ans;\\n        for(auto &v: items1){\\n            m[v[0]]+=v[1];\\n        }\\n        for(auto &v: items2){\\n            m[v[0]]+=v[1];\\n        }\\n        for(auto &p: m){\\n            ans.push_back({p.first,p.second});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        vector<vector<int>> ans;\\n        for(auto &v: items1){\\n            m[v[0]]+=v[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2388392,
                "title": "simple-solution-using-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mpp ;\\n        \\n        for(int i=0; i<items1.size(); i++){\\n            mpp[items1[i][0]] = items1[i][1] ;\\n        }\\n        \\n        for(int i=0; i<items2.size(); i++){\\n            if(mpp.find(items2[i][0]) != mpp.end()){\\n                mpp[items2[i][0]] += items2[i][1] ;\\n            }\\n            else{\\n                mpp[items2[i][0]] = items2[i][1] ;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans ;\\n        \\n        for(auto it: mpp){\\n            int i= it.first ;\\n            int j = it.second ;\\n            \\n            ans.push_back({i, j}) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mpp ;\\n        \\n        for(int i=0; i<items1.size(); i++){\\n            mpp[items1[i][0]] = items1[i][1] ;\\n        }\\n        \\n        for(int i=0; i<items2.size(); i++){\\n            if(mpp.find(items2[i][0]) != mpp.end()){\\n                mpp[items2[i][0]] += items2[i][1] ;\\n            }\\n            else{\\n                mpp[items2[i][0]] = items2[i][1] ;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans ;\\n        \\n        for(auto it: mpp){\\n            int i= it.first ;\\n            int j = it.second ;\\n            \\n            ans.push_back({i, j}) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388273,
                "title": "o-1-space-two-pointers-solution",
                "content": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n\\n        sort(items1.begin(), items1.end());\\n        sort(items2.begin(), items2.end());\\n   \\n        int m = items1.size(), n = items2.size();\\n        vector<vector<int>> res;\\n        int i = 0, j = 0;\\n        while (i < m && j < n) {\\n            if (items1[i][0] == items2[j][0]) {\\n                res.push_back({items1[i][0],items1[i][1]+items2[j][1]});\\n                i++;\\n                j++;\\n            }\\n            else if (items1[i][0] < items2[j][0]) {\\n                res.push_back(items1[i]);\\n                i++;\\n            }\\n            else if (items1[i][0] > items2[j][0]) {\\n                res.push_back(items2[j]);\\n                j++;\\n            }\\n        }\\n        \\n        while (i < m) {\\n            res.push_back(items1[i]);\\n                i++;\\n        }\\n        while (j < n) {\\n            res.push_back(items2[j]);\\n                j++;\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n\\n        sort(items1.begin(), items1.end());\\n        sort(items2.begin(), items2.end());\\n   \\n        int m = items1.size(), n = items2.size();\\n        vector<vector<int>> res;\\n        int i = 0, j = 0;\\n        while (i < m && j < n) {\\n            if (items1[i][0] == items2[j][0]) {\\n                res.push_back({items1[i][0],items1[i][1]+items2[j][1]});\\n                i++;\\n                j++;\\n            }\\n            else if (items1[i][0] < items2[j][0]) {\\n                res.push_back(items1[i]);\\n                i++;\\n            }\\n            else if (items1[i][0] > items2[j][0]) {\\n                res.push_back(items2[j]);\\n                j++;\\n            }\\n        }\\n        \\n        while (i < m) {\\n            res.push_back(items1[i]);\\n                i++;\\n        }\\n        while (j < n) {\\n            res.push_back(items2[j]);\\n                j++;\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388179,
                "title": "python-simple-solution-with-hash-map",
                "content": "We\\'ll keep track of a hash map, `m`, where `m[v] = w` means that the sum of all weights for objects with value `v` is `w`. We\\'ll return a list of all `[v, w]` sorted in order of `v`.\\n\\nO(N * lg(N)) time complexity due to the sorting, O(N) space.\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        allItems = items1 + items2\\n        m = {}\\n        for v,w in allItems:\\n            m[v] = m.get(v, 0) + w\\n                \\n        return sorted([v, m[v]] for v in m)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        allItems = items1 + items2\\n        m = {}\\n        for v,w in allItems:\\n            m[v] = m.get(v, 0) + w\\n                \\n        return sorted([v, m[v]] for v in m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388135,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> answer;\\n        map<int, int> count;\\n        for (auto i : items1) {\\n            count[i[0]] = i[1]; \\n        }\\n        for (auto i : items2) {\\n            count[i[0]] += i[1];\\n        }\\n        for (auto [key, value] : count) {\\n            answer.push_back({key, value});\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> answer;\\n        map<int, int> count;\\n        for (auto i : items1) {\\n            count[i[0]] = i[1]; \\n        }\\n        for (auto i : items2) {\\n            count[i[0]] += i[1];\\n        }\\n        for (auto [key, value] : count) {\\n            answer.push_back({key, value});\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091191,
                "title": "easy-java-solution-using-treemap-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        TreeMap<Integer, Integer> mp = new TreeMap<>();\\n        for(int i=0; i<items1.length; i++){\\n            mp.put(items1[i][0], items1[i][1]);\\n        }\\n        for(int i=0; i<items2.length; i++){\\n            mp.put(items2[i][0], mp.getOrDefault(items2[i][0],0)+items2[i][1]);\\n        }\\n        for(int key : mp.keySet()){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(key);\\n            temp.add(mp.get(key));\\n            list.add(temp);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        TreeMap<Integer, Integer> mp = new TreeMap<>();\\n        for(int i=0; i<items1.length; i++){\\n            mp.put(items1[i][0], items1[i][1]);\\n        }\\n        for(int i=0; i<items2.length; i++){\\n            mp.put(items2[i][0], mp.getOrDefault(items2[i][0],0)+items2[i][1]);\\n        }\\n        for(int key : mp.keySet()){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(key);\\n            temp.add(mp.get(key));\\n            list.add(temp);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089746,
                "title": "simple-hash-approach-python3-beats-85-25",
                "content": "> **If You like the Solution, Don\\'t Forget To Upvote Me, Please Upvote! \\uD83D\\uDE4F**\\n\\n\\n---\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        z = {}\\n        for x in items1+items2:\\n            if x[0] in z:\\n                z[x[0]]+=x[1]\\n            else:\\n                z[x[0]]=x[1]\\n        return sorted(list(map(list, z.items())), key=lambda a1:a1[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        z = {}\\n        for x in items1+items2:\\n            if x[0] in z:\\n                z[x[0]]+=x[1]\\n            else:\\n                z[x[0]]=x[1]\\n        return sorted(list(map(list, z.items())), key=lambda a1:a1[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089265,
                "title": "best-easily-understandable-code-for-beginner-using-hashmap",
                "content": "# Intuition\\nAs a beginner whenever i need to keep count i think of hashmap . \\n# Approach\\n1.add 1st array value into hasmap .\\n2.for 2nd array check if entry exists then add 1s+2nd array weight i;e ->   int weight=h.getOrDefault(value,0)+item[1];\\n3.Now our Hasmap is completed add its values to ArrayList using Hashmap iteration method i;e for(Map.Entry<Integer,Integer> e:_name_.entrySet())\\n4.in that loop create another list_temp for every set \\n5.add  list_temp to res list \\n6.for sorting use collections.sort(res,(a,b) -> a.get(0).compareTo(b.get(0)));\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        for(int [] item:items1)\\n        {\\n            int value=item[0];\\n            int  weight=item[1];\\n            h.put(value,weight);\\n        }\\n        for(int [] item:items2)\\n        {\\n            int value=item[0];\\n            int weight=h.getOrDefault(value,0)+item[1];\\n            h.put(value,weight);\\n        }\\n         List<List<Integer>> res=new ArrayList<>();\\n         \\n        //  List<Integer> l2=new ArrayList<>();\\n         for(Map.Entry<Integer,Integer> e:h.entrySet())\\n         {\\n           List<Integer> l1=new ArrayList<>();\\n           l1.add(e.getKey());\\n           l1.add(e.getValue());\\n           res.add(l1);\\n         }\\n         Collections.sort(res, (a, b) -> a.get(0).compareTo(b.get(0)));\\n        \\n\\n         return res;\\n\\n\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        for(int [] item:items1)\\n        {\\n            int value=item[0];\\n            int  weight=item[1];\\n            h.put(value,weight);\\n        }\\n        for(int [] item:items2)\\n        {\\n            int value=item[0];\\n            int weight=h.getOrDefault(value,0)+item[1];\\n            h.put(value,weight);\\n        }\\n         List<List<Integer>> res=new ArrayList<>();\\n         \\n        //  List<Integer> l2=new ArrayList<>();\\n         for(Map.Entry<Integer,Integer> e:h.entrySet())\\n         {\\n           List<Integer> l1=new ArrayList<>();\\n           l1.add(e.getKey());\\n           l1.add(e.getValue());\\n           res.add(l1);\\n         }\\n         Collections.sort(res, (a, b) -> a.get(0).compareTo(b.get(0)));\\n        \\n\\n         return res;\\n\\n\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087562,
                "title": "best-solution-using-hash-map-in-c",
                "content": "\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map <int, int> mp;\\n        for(int i = 0; i < items1.size(); i++) {\\n            mp[items1[i][0]] = items1[i][1];\\n        }\\n        for(int i = 0; i < items2.size(); i++) {\\n            mp[items2[i][0]] += items2[i][1];\\n        }\\n        vector <int> s;\\n        for(auto i: mp) {\\n            s.push_back(i.first);\\n        }\\n        vector<vector<int>> v1(s.size());\\n        for(int i = 0; i < mp.size(); i++) {\\n            v1[i].push_back(s[i]);\\n            v1[i].push_back(mp[s[i]]);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map <int, int> mp;\\n        for(int i = 0; i < items1.size(); i++) {\\n            mp[items1[i][0]] = items1[i][1];\\n        }\\n        for(int i = 0; i < items2.size(); i++) {\\n            mp[items2[i][0]] += items2[i][1];\\n        }\\n        vector <int> s;\\n        for(auto i: mp) {\\n            s.push_back(i.first);\\n        }\\n        vector<vector<int>> v1(s.size());\\n        for(int i = 0; i < mp.size(); i++) {\\n            v1[i].push_back(s[i]);\\n            v1[i].push_back(mp[s[i]]);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086449,
                "title": "simplest-solution-using-counter",
                "content": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        cnt = Counter(dict(items1))\\n        cnt.update(dict(items2))\\n        return sorted(cnt.items())      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        cnt = Counter(dict(items1))\\n        cnt.update(dict(items2))\\n        return sorted(cnt.items())      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084876,
                "title": "c-code-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mp;\\n        vector<vector<int>> res;\\n        for(int i=0;i<items1.size();i++)\\n        mp[items1[i][0]]+=items1[i][1];\\n\\n        for(int i=0;i<items2.size();i++)\\n        mp[items2[i][0]]+=items2[i][1];\\n        for(auto it : mp){\\n            vector<int> re;\\n            re.push_back(it.first);\\n            re.push_back(it.second);\\n            res.push_back(re);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mp;\\n        vector<vector<int>> res;\\n        for(int i=0;i<items1.size();i++)\\n        mp[items1[i][0]]+=items1[i][1];\\n\\n        for(int i=0;i<items2.size();i++)\\n        mp[items2[i][0]]+=items2[i][1];\\n        for(auto it : mp){\\n            vector<int> re;\\n            re.push_back(it.first);\\n            re.push_back(it.second);\\n            res.push_back(re);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084742,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\nMap\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    const arr = [];\\n    const map1 = new Map();\\n    items1.forEach((val)=>{\\n        map1.set(val[0],val[1]);\\n    });\\n    items2.forEach((val) => {\\n        if(map1.has(val[0])){\\n            arr.push([val[0],val[1] + map1.get(val[0])]);\\n            map1.delete(val[0]);\\n        }else{\\n            arr.push([val[0],val[1]]);\\n        }\\n    });\\n    for(const [k,v] of map1.entries()){\\n        arr.push([k,v]);\\n    }\\n    arr.sort((a,b)=>a[0]-b[0]);\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function(items1, items2) {\\n    const arr = [];\\n    const map1 = new Map();\\n    items1.forEach((val)=>{\\n        map1.set(val[0],val[1]);\\n    });\\n    items2.forEach((val) => {\\n        if(map1.has(val[0])){\\n            arr.push([val[0],val[1] + map1.get(val[0])]);\\n            map1.delete(val[0]);\\n        }else{\\n            arr.push([val[0],val[1]]);\\n        }\\n    });\\n    for(const [k,v] of map1.entries()){\\n        arr.push([k,v]);\\n    }\\n    arr.sort((a,b)=>a[0]-b[0]);\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071717,
                "title": "c-my-solution-using-array-not-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeats 93.06%of users with C#\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> MergeSimilarItems(int[][] items1, int[][] items2) {\\n        int[] seat = new int[1001];\\n        List<int[]> result = new List<int[]>();\\n        \\n        foreach(var item in items1){\\n            seat[item[0]] += item[1];\\n        }\\n        \\n        foreach(var item in items2){\\n            seat[item[0]] += item[1];\\n        }\\n        \\n        for(int i = 1; i < seat.Length; i++) {\\n            if(seat[i] != 0) {\\n                result.Add(new int[] { i, seat[i] });\\n            }\\n        }\\n        \\n        IList<IList<int>> resultList = result.Cast<IList<int>>().ToList();\\n        return resultList;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> MergeSimilarItems(int[][] items1, int[][] items2) {\\n        int[] seat = new int[1001];\\n        List<int[]> result = new List<int[]>();\\n        \\n        foreach(var item in items1){\\n            seat[item[0]] += item[1];\\n        }\\n        \\n        foreach(var item in items2){\\n            seat[item[0]] += item[1];\\n        }\\n        \\n        for(int i = 1; i < seat.Length; i++) {\\n            if(seat[i] != 0) {\\n                result.Add(new int[] { i, seat[i] });\\n            }\\n        }\\n        \\n        IList<IList<int>> resultList = result.Cast<IList<int>>().ToList();\\n        return resultList;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057147,
                "title": "java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n     HashMap<Integer,Integer>map=new HashMap<>();\\n     List<List<Integer>>li=new ArrayList<>();\\n     for(int i=0;i<items1.length;i++)\\n     {\\n         if(map.containsKey(items1[i][0]))\\n         {\\n             map.put(items1[i][0],map.get(items1[i][0])+items1[i][1]);\\n         }\\n         else\\n         {\\n             map.put(items1[i][0],items1[i][1]);\\n         }\\n     }\\n     for(int i=0;i<items2.length;i++)\\n     {\\n         if(map.containsKey(items2[i][0]))\\n         {\\n             map.put(items2[i][0],map.get(items2[i][0])+items2[i][1]);\\n         }\\n         else\\n         {\\n             map.put(items2[i][0],items2[i][1]);\\n         }\\n     }\\n     for(int c:map.keySet())\\n     {\\n         List<Integer>list=new ArrayList<>();\\n         list.add(c);\\n         list.add(map.get(c));\\n         li.add(list);\\n     }\\n     Collections.sort(li,new Comparator<List<Integer>>(){\\n     @Override\\n     public int compare(List<Integer>val1,List<Integer>val2){\\n         return val1.get(0).compareTo(val2.get(0));\\n     }\\n    });\\n    return li;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n     HashMap<Integer,Integer>map=new HashMap<>();\\n     List<List<Integer>>li=new ArrayList<>();\\n     for(int i=0;i<items1.length;i++)\\n     {\\n         if(map.containsKey(items1[i][0]))\\n         {\\n             map.put(items1[i][0],map.get(items1[i][0])+items1[i][1]);\\n         }\\n         else\\n         {\\n             map.put(items1[i][0],items1[i][1]);\\n         }\\n     }\\n     for(int i=0;i<items2.length;i++)\\n     {\\n         if(map.containsKey(items2[i][0]))\\n         {\\n             map.put(items2[i][0],map.get(items2[i][0])+items2[i][1]);\\n         }\\n         else\\n         {\\n             map.put(items2[i][0],items2[i][1]);\\n         }\\n     }\\n     for(int c:map.keySet())\\n     {\\n         List<Integer>list=new ArrayList<>();\\n         list.add(c);\\n         list.add(map.get(c));\\n         li.add(list);\\n     }\\n     Collections.sort(li,new Comparator<List<Integer>>(){\\n     @Override\\n     public int compare(List<Integer>val1,List<Integer>val2){\\n         return val1.get(0).compareTo(val2.get(0));\\n     }\\n    });\\n    return li;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056456,
                "title": "using-hash-table",
                "content": "# Intuition\\nUsing Dictionary\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d={}\\n        l=[]\\n        for i in range(len(items1)):\\n            if items1[i][0] not in d:\\n                d[items1[i][0]]=items1[i][1]\\n            else:\\n                d[items1[i][0]]+=items1[i][1]\\n        \\n        for i in range(len(items2)):\\n            if items2[i][0] not in d:\\n                d[items2[i][0]]=items2[i][1]\\n            else:\\n                d[items2[i][0]]+=items2[i][1]\\n        for i,k in d.items():\\n            l.append([i,k])\\n        return sorted(l)\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d={}\\n        l=[]\\n        for i in range(len(items1)):\\n            if items1[i][0] not in d:\\n                d[items1[i][0]]=items1[i][1]\\n            else:\\n                d[items1[i][0]]+=items1[i][1]\\n        \\n        for i in range(len(items2)):\\n            if items2[i][0] not in d:\\n                d[items2[i][0]]=items2[i][1]\\n            else:\\n                d[items2[i][0]]+=items2[i][1]\\n        for i,k in d.items():\\n            l.append([i,k])\\n        return sorted(l)\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051015,
                "title": "easy-python-solution-python",
                "content": "# EASY PYTHON SOLUTION || PYTHON || \\u270C \\u270C\\n# Runtime\\n- 115ms\\n- Beats 89.81%of users with Python3\\n# Memory\\n- 17.19MB\\n- Beats 60.64%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        itemDic = {}\\n    \\n        for i in range(0,len(items1)):\\n            if items1[i][0] in itemDic:\\n                itemDic[items1[i][0]]+=items1[i][1]\\n            else:\\n                itemDic[items1[i][0]] = items1[i][1]\\n        #FOR 2ND ITEM LISTS\\n        for i in range(0,len(items2)):\\n            if items2[i][0] in itemDic:\\n                itemDic[items2[i][0]]+=items2[i][1]\\n            else:\\n                itemDic[items2[i][0]] = items2[i][1]\\n        \\n        itemDic=dict(sorted(itemDic.items()))\\n     \\n        return [[num,count] for num,count in itemDic.items()]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        itemDic = {}\\n    \\n        for i in range(0,len(items1)):\\n            if items1[i][0] in itemDic:\\n                itemDic[items1[i][0]]+=items1[i][1]\\n            else:\\n                itemDic[items1[i][0]] = items1[i][1]\\n        #FOR 2ND ITEM LISTS\\n        for i in range(0,len(items2)):\\n            if items2[i][0] in itemDic:\\n                itemDic[items2[i][0]]+=items2[i][1]\\n            else:\\n                itemDic[items2[i][0]] = items2[i][1]\\n        \\n        itemDic=dict(sorted(itemDic.items()))\\n     \\n        return [[num,count] for num,count in itemDic.items()]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048843,
                "title": "python-3-solution-with-step-by-step-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        # Create an empty dictionary to store the counts of items based on their values.\\n        valueCount = {}\\n        \\n        # Create an empty list to store the merged results.\\n        ret = []\\n\\n        # Loop through the first list of items (items1).\\n        for i in range(len(items1)):\\n            # Store the count of the item with its value as the key in the dictionary.\\n            valueCount[items1[i][0]] = items1[i][1]\\n\\n        # Loop through the second list of items (items2).\\n        for j in range(len(items2)):\\n            # Check if the value of the current item in items2 exists in the dictionary.\\n            if items2[j][0] in valueCount: \\n                # If it exists, add the count of the item from items2 to the existing count.\\n                valueCount[items2[j][0]] += items2[j][1]\\n            else: \\n                # If it doesn\\'t exist, create a new entry in the dictionary.\\n                valueCount[items2[j][0]] = items2[j][1]\\n\\n        # Sort the keys of the dictionary in ascending order.\\n        for key in sorted(valueCount.keys()):\\n            # Append the sorted keys and their corresponding counts to the result list.\\n            ret.append([key, valueCount[key]])\\n\\n        # Return the merged and sorted list of items.\\n        return ret\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        # Create an empty dictionary to store the counts of items based on their values.\\n        valueCount = {}\\n        \\n        # Create an empty list to store the merged results.\\n        ret = []\\n\\n        # Loop through the first list of items (items1).\\n        for i in range(len(items1)):\\n            # Store the count of the item with its value as the key in the dictionary.\\n            valueCount[items1[i][0]] = items1[i][1]\\n\\n        # Loop through the second list of items (items2).\\n        for j in range(len(items2)):\\n            # Check if the value of the current item in items2 exists in the dictionary.\\n            if items2[j][0] in valueCount: \\n                # If it exists, add the count of the item from items2 to the existing count.\\n                valueCount[items2[j][0]] += items2[j][1]\\n            else: \\n                # If it doesn\\'t exist, create a new entry in the dictionary.\\n                valueCount[items2[j][0]] = items2[j][1]\\n\\n        # Sort the keys of the dictionary in ascending order.\\n        for key in sorted(valueCount.keys()):\\n            # Append the sorted keys and their corresponding counts to the result list.\\n            ret.append([key, valueCount[key]])\\n\\n        # Return the merged and sorted list of items.\\n        return ret\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048148,
                "title": "i-am-just-posting-cuz-i-wanna-see-what-others-did",
                "content": "# Intuition\\nTo do this question you just need to know the different types of datastructures in python. The merge bit can be made with a double loop but i think listcomprehension is better for memory. \\n# Approach\\nIn essence, this code is accumulating the weights associated with each unique value in the items1 list by using a dictionary (item_dict) to keep track of these accumulations. If a value is encountered multiple times in the items1 list, its associated weight values are added together in the dictionary. If a value is encountered for the first time, it is added as a new key with its weight as the initial value in the dictionary. \\n# Complexity\\n- Time complexity:\\nno clue\\n\\n- Space complexity:\\nno clue\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        item_dict = {}  # Use a dictionary to store items with the same value\\n        \\n        for item in items1:\\n            value, weight = item\\n            if value in item_dict:\\n                item_dict[value] += weight\\n            else:\\n                item_dict[value] = weight\\n\\n        for item in items2:\\n            value, weight = item\\n            if value in item_dict:\\n                item_dict[value] += weight\\n            else:\\n                item_dict[value] = weight\\n        \\n        merged_items = [[value, weight] for value, weight in item_dict.items()]\\n        merged_items.sort()\\n        \\n        return merged_items\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        item_dict = {}  # Use a dictionary to store items with the same value\\n        \\n        for item in items1:\\n            value, weight = item\\n            if value in item_dict:\\n                item_dict[value] += weight\\n            else:\\n                item_dict[value] = weight\\n\\n        for item in items2:\\n            value, weight = item\\n            if value in item_dict:\\n                item_dict[value] += weight\\n            else:\\n                item_dict[value] = weight\\n        \\n        merged_items = [[value, weight] for value, weight in item_dict.items()]\\n        merged_items.sort()\\n        \\n        return merged_items\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043959,
                "title": "c-map-fast-and-easy",
                "content": "# Intuition\\nThe intuition behind this solution is to merge two sets of vectors, `t1` and `t2`, by summing up the second integer in each sub-vector based on the common first integer (key).\\n\\n# Approach\\n1. Initialize an `std::map<int, int>` called `mp` to store the merged results, where the key represents the first integer from the sub-vector, and the value represents the sum of the second integers.\\n\\n2. Iterate through the sub-vectors in `t1` and populate the `mp` map with the key-value pairs from `t1`.\\n\\n3. Iterate through the sub-vectors in `t2`. If an item with the same key already exists in `mp`, add the second integer to the existing value. If not, create a new entry in `mp` with the key and value from `t2`.\\n\\n4. Create a new vector of vectors called `ans` to store the merged results.\\n\\n5. Iterate through the `mp` map and construct sub-vectors using `std::initializer_list<int>`. Each sub-vector contains the key (first integer) and the corresponding value (sum of second integers).\\n\\n6. Return the `ans` vector containing the merged results.\\n\\n# Complexity\\n- Time complexity:\\n   O(n + m), where n is the size of `t1` and m is the size of `t2`. We iterate through both vectors once.\\n\\n- Space complexity:\\nO(n), where n is the number of unique keys in `t1` and `t2`. We use the `mp` map to store these unique keys.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& t1, vector<vector<int>>& t2) {\\n        map<int, int>mp;\\n        for(auto &u: t1 ){\\n            mp[u[0]] = u[1];\\n        }\\n\\n        for(auto &u: t2){\\n            if(mp[u[0]]){\\n                mp[u[0]] +=u[1];\\n            }else{\\n                mp[u[0]] = u[1];\\n            }\\n        }\\n\\n       vector<vector<int>>ans;\\n\\n        for(auto &u: mp){\\n            ans.emplace_back(initializer_list<int>{u.first, u.second});\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& t1, vector<vector<int>>& t2) {\\n        map<int, int>mp;\\n        for(auto &u: t1 ){\\n            mp[u[0]] = u[1];\\n        }\\n\\n        for(auto &u: t2){\\n            if(mp[u[0]]){\\n                mp[u[0]] +=u[1];\\n            }else{\\n                mp[u[0]] = u[1];\\n            }\\n        }\\n\\n       vector<vector<int>>ans;\\n\\n        for(auto &u: mp){\\n            ans.emplace_back(initializer_list<int>{u.first, u.second});\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038390,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        l =[]\\n        for i in items1:\\n            d[i[0]] = i[1]\\n\\n        for i in items2:\\n            if i[0] in d:\\n                d[i[0]] += i[1]\\n            else:\\n                d[i[0]] = i[1]\\n\\n        for i,j in d.items():\\n            l.append([i,j])\\n\\n        return sorted(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        l =[]\\n        for i in items1:\\n            d[i[0]] = i[1]\\n\\n        for i in items2:\\n            if i[0] in d:\\n                d[i[0]] += i[1]\\n            else:\\n                d[i[0]] = i[1]\\n\\n        for i,j in d.items():\\n            l.append([i,j])\\n\\n        return sorted(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034929,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction mergeSimilarItems(items1: number[][], items2: number[][]): number[][] {\\n    let map = new Map()\\n    for (let i = 0; i < items1.length; i++) {\\n        map.set(items1[i][0], items1[i][1])\\n    }\\n    for (let i = 0; i < items2.length; i++) {\\n        if (map.has(items2[i][0])) {\\n            map.set(items2[i][0], map.get(items2[i][0]) + items2[i][1])\\n        } else {\\n            map.set(items2[i][0], items2[i][1])\\n        }\\n    }\\n    return Array.from(map.entries()).sort(([a], [b]) => a - b)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mergeSimilarItems(items1: number[][], items2: number[][]): number[][] {\\n    let map = new Map()\\n    for (let i = 0; i < items1.length; i++) {\\n        map.set(items1[i][0], items1[i][1])\\n    }\\n    for (let i = 0; i < items2.length; i++) {\\n        if (map.has(items2[i][0])) {\\n            map.set(items2[i][0], map.get(items2[i][0]) + items2[i][1])\\n        } else {\\n            map.set(items2[i][0], items2[i][1])\\n        }\\n    }\\n    return Array.from(map.entries()).sort(([a], [b]) => a - b)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015364,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nfunction mergeSimilarItems(items1: number[][], items2: number[][]): number[][] {\\n    const arr: number[][] = [...items1, ...items2].sort((a, b) => a[0] - b[0]);\\n    const mergedArr: any = {};\\n    for (let item of arr) {\\n        const [key] = item;\\n        if(mergedArr[key]) continue;\\n        const filterArr = arr.filter(a => a[0] === key);\\n        if (filterArr.length < 2) mergedArr[key] = filterArr[0];\\n        else{\\n            const sum = filterArr.reduce((total, val) => total += val[1], 0);\\n            mergedArr[key] = [key, sum];\\n        }\\n    }\\n    return Object.values(mergedArr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction mergeSimilarItems(items1: number[][], items2: number[][]): number[][] {\\n    const arr: number[][] = [...items1, ...items2].sort((a, b) => a[0] - b[0]);\\n    const mergedArr: any = {};\\n    for (let item of arr) {\\n        const [key] = item;\\n        if(mergedArr[key]) continue;\\n        const filterArr = arr.filter(a => a[0] === key);\\n        if (filterArr.length < 2) mergedArr[key] = filterArr[0];\\n        else{\\n            const sum = filterArr.reduce((total, val) => total += val[1], 0);\\n            mergedArr[key] = [key, sum];\\n        }\\n    }\\n    return Object.values(mergedArr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010913,
                "title": "faster-than-90-o-nlog-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n)) due to sorted method\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        di1 = {item[0]: item[1] for item in items1}\\n        di2 = {item[0]: item[1] for item in items2}\\n        d = {}\\n        keys = list(set(list(di1.keys()) + list(di2.keys())))\\n        for key in keys:\\n            if key in di1 and key in di2:\\n                d[key] = di1[key] + di2[key]\\n            elif key in di1 and key not in di2:\\n                d[key] = di1[key]\\n            else:\\n                d[key] = di2[key]\\n        return sorted([[key, d[key]] for key in d])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        di1 = {item[0]: item[1] for item in items1}\\n        di2 = {item[0]: item[1] for item in items2}\\n        d = {}\\n        keys = list(set(list(di1.keys()) + list(di2.keys())))\\n        for key in keys:\\n            if key in di1 and key in di2:\\n                d[key] = di1[key] + di2[key]\\n            elif key in di1 and key not in di2:\\n                d[key] = di1[key]\\n            else:\\n                d[key] = di2[key]\\n        return sorted([[key, d[key]] for key in d])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999277,
                "title": "beats-97-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        for(int i=0;i<items1.size();i++){\\n            m[items1[i][0]]+=items1[i][1];\\n        }\\n           for(int i=0;i<items2.size();i++){\\n            m[items2[i][0]]+=items2[i][1];\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: m)\\n        {\\n        ans.push_back({i.first,i.second});\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> m;\\n        for(int i=0;i<items1.size();i++){\\n            m[items1[i][0]]+=items1[i][1];\\n        }\\n           for(int i=0;i<items2.size();i++){\\n            m[items2[i][0]]+=items2[i][1];\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: m)\\n        {\\n        ans.push_back({i.first,i.second});\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996653,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        weights = {}\\n        for item in (items1 + items2):\\n            value, weight = item[0], item[1]\\n            weights[value] = weights.get(value, 0) + weight\\n\\n        return sorted(list(weights.items()))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        weights = {}\\n        for item in (items1 + items2):\\n            value, weight = item[0], item[1]\\n            weights[value] = weights.get(value, 0) + weight\\n\\n        return sorted(list(weights.items()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980248,
                "title": "c-hashmap-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mp;\\n        for (auto val: items1){\\n            mp[val[0]]= val[1];\\n        }\\n        for (auto val: items2){\\n            mp[val[0]]= mp[val[0]]+val[1];\\n        }\\n        vector<vector<int>> ans;\\n        for (auto val: mp){\\n            vector<int> v= {val.first,val.second};\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int> mp;\\n        for (auto val: items1){\\n            mp[val[0]]= val[1];\\n        }\\n        for (auto val: items2){\\n            mp[val[0]]= mp[val[0]]+val[1];\\n        }\\n        vector<vector<int>> ans;\\n        for (auto val: mp){\\n            vector<int> v= {val.first,val.second};\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978564,
                "title": "python-simple-solution-using-dictionary-without-nested-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        out_dict = {}\\n        out_list = []\\n        for i,j in items1:\\n            if i in out_dict:\\n                out_dict[i] += j\\n            else:\\n                out_dict[i] = j\\n\\n        for i,j in items2:\\n            if i in out_dict:\\n                out_dict[i] += j\\n            else:\\n                out_dict[i] = j\\n            \\n        for i in sorted(out_dict):\\n            out_list.append([i,out_dict[i]])\\n\\n        return out_list\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        out_dict = {}\\n        out_list = []\\n        for i,j in items1:\\n            if i in out_dict:\\n                out_dict[i] += j\\n            else:\\n                out_dict[i] = j\\n\\n        for i,j in items2:\\n            if i in out_dict:\\n                out_dict[i] += j\\n            else:\\n                out_dict[i] = j\\n            \\n        for i in sorted(out_dict):\\n            out_list.append([i,out_dict[i]])\\n\\n        return out_list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971831,
                "title": "using-unordered-map-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first create an unordered_map<int, int> named valueToWeight to store the accumulated weights for each unique value.\\n\\nWe iterate through both items1 and items2 arrays, accumulating weights based on their values in the valueToWeight map.\\n\\nAfter accumulating the weights, we create the final result by iterating through the valueToWeight map and pushing the value-weight pairs into the ret vector.\\n\\nFinally, we sort the ret vector based on the value using the sort function.\\n\\nThe main function demonstrates how to use the groupItemsWithSum function with example input and prints the resulting grouped and sorted items.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>>ans;\\n       unordered_map<int,int>mp;\\n       for(auto items:items1)\\n       {\\n           int val=items[0];\\n           int wt=items[1];\\n           mp[val]+=wt;\\n       }\\n        for(auto items:items2)\\n       {\\n           int val=items[0];\\n           int wt=items[1];\\n           mp[val]+=wt;\\n       }\\n       for(auto it:mp)\\n       {\\n           ans.push_back({it.first,it.second});\\n       }\\n       sort(ans.begin(),ans.end());\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>>ans;\\n       unordered_map<int,int>mp;\\n       for(auto items:items1)\\n       {\\n           int val=items[0];\\n           int wt=items[1];\\n           mp[val]+=wt;\\n       }\\n        for(auto items:items2)\\n       {\\n           int val=items[0];\\n           int wt=items[1];\\n           mp[val]+=wt;\\n       }\\n       for(auto it:mp)\\n       {\\n           ans.push_back({it.first,it.second});\\n       }\\n       sort(ans.begin(),ans.end());\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962866,
                "title": "beginner-friendly",
                "content": "# Intuition\\n\"In this solution, we use a map, which is like a special container that stores items uniquely based on their \\'keys.\\' Think of it as a collection of unique labels (keys) and their associated values. By using a map, we can efficiently group items with the same label together. This allows us to merge similar items from two input vectors easily. The keys in the map represent the labels we want to merge, and the values associated with those keys are the sum of the corresponding items. This approach simplifies the task and is beginner-friendly because it automatically ensures that each label appears only once in the final result.\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n+m+nlogn)\\n\\n- Space complexity:\\n\\'ans\\' is a vector of vectors, and its space complexity depends on the number of distinct keys in the unordered_map. In the worst case, there can be n + m distinct keys.\\n\\n\\'mp\\' is an unordered_map that stores the keys and their corresponding values. In the worst case, it can contain n + m key-value pairs.\\n\\nSo, the space complexity of your solution is O(n + m) as well.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& i1, vector<vector<int>>& i2) {\\n        vector<vector<int>>ans;\\n        unordered_map<int,int>mp;\\n        int n=i1.size();\\n        for(int i=0;i<i1.size();i++){\\n            if(mp.find(i1[i][0]) != mp.end()){\\n                mp[i1[i][0]]+=i1[i][1];\\n            }\\n            else{\\n                mp[i1[i][0]]=i1[i][1];\\n            }\\n        }\\n        for(int i=0;i<i2.size();i++){\\n            if(mp.find(i2[i][0]) != mp.end()){\\n                mp[i2[i][0]]+=i2[i][1];\\n            }\\n            else{\\n                mp[i2[i][0]]=i2[i][1];\\n            }\\n        }\\n        for(auto it:mp){\\n            ans.push_back({it.first,it.second});\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sort",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& i1, vector<vector<int>>& i2) {\\n        vector<vector<int>>ans;\\n        unordered_map<int,int>mp;\\n        int n=i1.size();\\n        for(int i=0;i<i1.size();i++){\\n            if(mp.find(i1[i][0]) != mp.end()){\\n                mp[i1[i][0]]+=i1[i][1];\\n            }\\n            else{\\n                mp[i1[i][0]]=i1[i][1];\\n            }\\n        }\\n        for(int i=0;i<i2.size();i++){\\n            if(mp.find(i2[i][0]) != mp.end()){\\n                mp[i2[i][0]]+=i2[i][1];\\n            }\\n            else{\\n                mp[i2[i][0]]=i2[i][1];\\n            }\\n        }\\n        for(auto it:mp){\\n            ans.push_back({it.first,it.second});\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953528,
                "title": "o-n-beats-95-86-memory-also-o-n-beats-77-24",
                "content": "```\\nvar mergeSimilarItems = function(items1, items2) {\\n    items1.push(...items2)\\n    const arr = []\\n    \\n    for (const item of items1) {\\n        if (arr[item[0]]) {\\n            arr[item[0]] += item[1]\\n        } else {\\n            arr[item[0]] = item[1]\\n        }\\n    }\\n    \\n    const res = []\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i]) {\\n            res.push([i, arr[i]])\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeSimilarItems = function(items1, items2) {\\n    items1.push(...items2)\\n    const arr = []\\n    \\n    for (const item of items1) {\\n        if (arr[item[0]]) {\\n            arr[item[0]] += item[1]\\n        } else {\\n            arr[item[0]] = item[1]\\n        }\\n    }\\n    \\n    const res = []\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i]) {\\n            res.push([i, arr[i]])\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951410,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>>v;\\n        map<int,int>m;\\n        for(auto item:items1){\\n            m[item[0]]+=item[1];\\n        }\\n        for(auto item:items2){\\n            m[item[0]]+=item[1];\\n        }\\n        for(auto const&p:m){\\n           /* vector<int>vp;\\n            vp.push_back(p.first);\\n            vp.push_back(p.second);*/\\n            v.push_back({p.first,p.second});\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>>v;\\n        map<int,int>m;\\n        for(auto item:items1){\\n            m[item[0]]+=item[1];\\n        }\\n        for(auto item:items2){\\n            m[item[0]]+=item[1];\\n        }\\n        for(auto const&p:m){\\n           /* vector<int>vp;\\n            vp.push_back(p.first);\\n            vp.push_back(p.second);*/\\n            v.push_back({p.first,p.second});\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949512,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        int[][] arr = new int[1001][2];\\n        for (int[] i : items1) {\\n            arr[i[0]][1] += i[1];\\n        }\\n\\n        for (int[] i : items2) {\\n            arr[i[0]][1] += i[1];\\n        }\\n        for (int i = 1; i <= 1000; i++) {\\n            if (arr[i][1] > 0) {\\n                output.add(List.of(i, arr[i][1]));\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        int[][] arr = new int[1001][2];\\n        for (int[] i : items1) {\\n            arr[i[0]][1] += i[1];\\n        }\\n\\n        for (int[] i : items2) {\\n            arr[i[0]][1] += i[1];\\n        }\\n        for (int i = 1; i <= 1000; i++) {\\n            if (arr[i][1] > 0) {\\n                output.add(List.of(i, arr[i][1]));\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939511,
                "title": "easy-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n       map<int,int>mp;\\n       for(int i=0;i<items1.size();i++){\\n           mp[items1[i][0]]=items1[i][1];\\n       } \\n       for(int i=0;i<items2.size();i++){\\n           if(mp.find(items2[i][0]) !=mp.end()){\\n               mp[items2[i][0]]+=items2[i][1];\\n           }\\n           else{\\n               mp[items2[i][0]]=items2[i][1];\\n           }\\n       }\\n       vector<vector<int>> ans;\\n       for (auto x:mp){\\n           ans.push_back({x.first,x.second});\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n       map<int,int>mp;\\n       for(int i=0;i<items1.size();i++){\\n           mp[items1[i][0]]=items1[i][1];\\n       } \\n       for(int i=0;i<items2.size();i++){\\n           if(mp.find(items2[i][0]) !=mp.end()){\\n               mp[items2[i][0]]+=items2[i][1];\\n           }\\n           else{\\n               mp[items2[i][0]]=items2[i][1];\\n           }\\n       }\\n       vector<vector<int>> ans;\\n       for (auto x:mp){\\n           ans.push_back({x.first,x.second});\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937977,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<items1.length;i++){\\n            map.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i=0;i<items2.length;i++){\\n            if(map.containsKey(items2[i][0]))\\n                map.put(items2[i][0],map.get(items2[i][0])+items2[i][1]);\\n            else\\n                map.put(items2[i][0],items2[i][1]);\\n        }\\n        List<List<Integer>> list=new ArrayList<>();\\n        int arr[]=new int[map.size()];\\n        int k=0;\\n        for(int i:map.keySet()){\\n            arr[k++]=i;\\n        }\\n        Arrays.sort(arr);\\n        for(int i:arr)\\n            list.add(Arrays.asList(i,map.get(i)));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<items1.length;i++){\\n            map.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i=0;i<items2.length;i++){\\n            if(map.containsKey(items2[i][0]))\\n                map.put(items2[i][0],map.get(items2[i][0])+items2[i][1]);\\n            else\\n                map.put(items2[i][0],items2[i][1]);\\n        }\\n        List<List<Integer>> list=new ArrayList<>();\\n        int arr[]=new int[map.size()];\\n        int k=0;\\n        for(int i:map.keySet()){\\n            arr[k++]=i;\\n        }\\n        Arrays.sort(arr);\\n        for(int i:arr)\\n            list.add(Arrays.asList(i,map.get(i)));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923308,
                "title": "2ms-easy-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        int[] map = new int[1001];\\n        for(int[] item: items1) {\\n            map[item[0]] += item[1];\\n        }\\n\\n        List<List<Integer>> res = new ArrayList();\\n        for(int[] item: items2) {\\n            map[item[0]] += item[1];\\n        }\\n\\n        for(int i = 1;i<=1000; i++) {\\n            if(map[i] > 0) res.add(List.of(i, map[i]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        int[] map = new int[1001];\\n        for(int[] item: items1) {\\n            map[item[0]] += item[1];\\n        }\\n\\n        List<List<Integer>> res = new ArrayList();\\n        for(int[] item: items2) {\\n            map[item[0]] += item[1];\\n        }\\n\\n        for(int i = 1;i<=1000; i++) {\\n            if(map[i] > 0) res.add(List.of(i, map[i]));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915940,
                "title": "javascript-100",
                "content": "Your runtime beats 100 % of javascript submissions\\nYour memory usage beats 62.86 % of javascript submissions (49.4 MB)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function (items1, items2) {\\n    const map = new Map();\\n    items1.push(...items2);\\n    for (let i = 0; i < items1.length; i++) {\\n        map.set(items1[i][0], (map.get(items1[i][0]) || 0) + items1[i][1]);\\n    }\\n    return new Array(...map.entries()).sort((a, b) => a[0] - b[0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} items1\\n * @param {number[][]} items2\\n * @return {number[][]}\\n */\\nvar mergeSimilarItems = function (items1, items2) {\\n    const map = new Map();\\n    items1.push(...items2);\\n    for (let i = 0; i < items1.length; i++) {\\n        map.set(items1[i][0], (map.get(items1[i][0]) || 0) + items1[i][1]);\\n    }\\n    return new Array(...map.entries()).sort((a, b) => a[0] - b[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914540,
                "title": "it-s-super-easy-buddy-try-it-yourself",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>mp;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<items1.size();i++){\\n                if(mp.find(items1[i][0])!=mp.end()){\\n                    auto t=mp.find(items1[i][0]);\\n                    t->second+=items1[i][1];\\n                }\\n                else{\\n                    mp[items1[i][0]]=items1[i][1];\\n                }\\n        }\\n        for(int i=0;i<items2.size();i++){\\n                if(mp.find(items2[i][0])!=mp.end()){\\n                    auto t=mp.find(items2[i][0]);\\n                    t->second+=items2[i][1];\\n                }\\n                else{\\n                    mp[items2[i][0]]=items2[i][1];\\n                }\\n        }\\n        for(auto itr=mp.begin();itr!=mp.end();itr++){\\n            vector<int>t(2);\\n            t[0]=itr->first;\\n            t[1]=itr->second;\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>mp;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<items1.size();i++){\\n                if(mp.find(items1[i][0])!=mp.end()){\\n                    auto t=mp.find(items1[i][0]);\\n                    t->second+=items1[i][1];\\n                }\\n                else{\\n                    mp[items1[i][0]]=items1[i][1];\\n                }\\n        }\\n        for(int i=0;i<items2.size();i++){\\n                if(mp.find(items2[i][0])!=mp.end()){\\n                    auto t=mp.find(items2[i][0]);\\n                    t->second+=items2[i][1];\\n                }\\n                else{\\n                    mp[items2[i][0]]=items2[i][1];\\n                }\\n        }\\n        for(auto itr=mp.begin();itr!=mp.end();itr++){\\n            vector<int>t(2);\\n            t[0]=itr->first;\\n            t[1]=itr->second;\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909544,
                "title": "100-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> output;\\n        map<int,int> mp;\\n        for(auto item : items1)\\n        mp[item[0]] += item[1];\\n        for(auto item : items2)\\n        mp[item[0]] += item[1];\\n\\n        for(auto item : mp)\\n        output.push_back({item.first,item.second});\\n        \\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>> output;\\n        map<int,int> mp;\\n        for(auto item : items1)\\n        mp[item[0]] += item[1];\\n        for(auto item : items2)\\n        mp[item[0]] += item[1];\\n\\n        for(auto item : mp)\\n        output.push_back({item.first,item.second});\\n        \\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906157,
                "title": "easy-solution-4-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k) -> k is number of unique values in items1 + items2\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        items = defaultdict(int)\\n        for v, w in items1 + items2:\\n            items[v] += w\\n        return [[k, items[k]] for k in sorted(items.keys())]\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        items = defaultdict(int)\\n        for v, w in items1 + items2:\\n            items[v] += w\\n        return [[k, items[k]] for k in sorted(items.keys())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905972,
                "title": "hash-and-sort-beats-100",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n# @param {Integer[][]} items1\\n# @param {Integer[][]} items2\\n# @return {Integer[][]}\\ndef merge_similar_items(items1, items2)\\n    # We are merging arrays two arrays, items1 and items2.\\n    # When merging if an item has the same value, we combine the weight.\\n\\n    hash = {}\\n    items1.each do |item|\\n        if hash[item[0]]\\n            hash[item[0]] = hash[item[0]] + item[1]\\n        else\\n            hash[item[0]] = item[1]\\n        end\\n    end\\n\\n    items2.each do |item|\\n        if hash[item[0]]\\n            hash[item[0]] = hash[item[0]] + item[1]\\n        else\\n            hash[item[0]] = item[1]\\n        end\\n    end\\n\\n    answer = []\\n    hash.keys.each do |key|\\n        answer << [key, hash[key]]\\n    end\\n\\n    answer.sort{|a,b| a[0]<=>b[0]}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} items1\\n# @param {Integer[][]} items2\\n# @return {Integer[][]}\\ndef merge_similar_items(items1, items2)\\n    # We are merging arrays two arrays, items1 and items2.\\n    # When merging if an item has the same value, we combine the weight.\\n\\n    hash = {}\\n    items1.each do |item|\\n        if hash[item[0]]\\n            hash[item[0]] = hash[item[0]] + item[1]\\n        else\\n            hash[item[0]] = item[1]\\n        end\\n    end\\n\\n    items2.each do |item|\\n        if hash[item[0]]\\n            hash[item[0]] = hash[item[0]] + item[1]\\n        else\\n            hash[item[0]] = item[1]\\n        end\\n    end\\n\\n    answer = []\\n    hash.keys.each do |key|\\n        answer << [key, hash[key]]\\n    end\\n\\n    answer.sort{|a,b| a[0]<=>b[0]}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3905465,
                "title": "python-simple-solution-using-hashmap-95-beats",
                "content": "# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        def wcount(arr: list[int]):\\n            for pair in arr:\\n                if pair[0] not in d:\\n                    d[pair[0]] = pair[1]\\n                else:\\n                    d[pair[0]] += pair[1] \\n        d = {}\\n        wcount(items1)\\n        wcount(items2)\\n        return sorted(d.items(), key=lambda x: x[0])\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        def wcount(arr: list[int]):\\n            for pair in arr:\\n                if pair[0] not in d:\\n                    d[pair[0]] = pair[1]\\n                else:\\n                    d[pair[0]] += pair[1] \\n        d = {}\\n        wcount(items1)\\n        wcount(items2)\\n        return sorted(d.items(), key=lambda x: x[0])\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899514,
                "title": "using-simple-aprroch-to-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# **O**(N+KlogK)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **O**(K)\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        value_weights={}\\n        for value,weight in items1+items2:\\n            if value in value_weights:\\n                value_weights[value] +=weight\\n            else:\\n                value_weights[value]= weight\\n\\n        ret=[[value, weight] for value, weight in value_weights.items()]\\n        ret.sort(key=lambda x: x[0])\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        value_weights={}\\n        for value,weight in items1+items2:\\n            if value in value_weights:\\n                value_weights[value] +=weight\\n            else:\\n                value_weights[value]= weight\\n\\n        ret=[[value, weight] for value, weight in value_weights.items()]\\n        ret.sort(key=lambda x: x[0])\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884250,
                "title": "merge-similar-items",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<items1.length;i++)\\n        {\\n            hm.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i=0;i<items2.length;i++)\\n        {\\n            if(hm.containsKey(items2[i][0]))\\n            hm.put(items2[i][0],hm.get(items2[i][0])+items2[i][1]);\\n            else\\n            hm.put(items2[i][0],items2[i][1]);\\n        }\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n        {\\n            arr.add(e.getKey());\\n        }\\n        Collections.sort(arr);\\n        List<List<Integer>> arr1 = new ArrayList<>();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ArrayList<Integer> ar = new ArrayList<Integer>();\\n            ar.add(arr.get(i));\\n            ar.add(hm.get(arr.get(i)));\\n            arr1.add(ar); \\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\\n        for(int i=0;i<items1.length;i++)\\n        {\\n            hm.put(items1[i][0],items1[i][1]);\\n        }\\n        for(int i=0;i<items2.length;i++)\\n        {\\n            if(hm.containsKey(items2[i][0]))\\n            hm.put(items2[i][0],hm.get(items2[i][0])+items2[i][1]);\\n            else\\n            hm.put(items2[i][0],items2[i][1]);\\n        }\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(Map.Entry<Integer,Integer> e:hm.entrySet())\\n        {\\n            arr.add(e.getKey());\\n        }\\n        Collections.sort(arr);\\n        List<List<Integer>> arr1 = new ArrayList<>();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            ArrayList<Integer> ar = new ArrayList<Integer>();\\n            ar.add(arr.get(i));\\n            ar.add(hm.get(arr.get(i)));\\n            arr1.add(ar); \\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877394,
                "title": "simple-elegant-go-o-n-m-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: O(m + n) where m and n are length of item lists\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/a3cf2267-d34e-41df-9624-4ea538add937_1691419714.5792408.png)\\n\\n# Code\\n```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) [][]int {\\n    tmp := make([]int, 1001)\\n    for i := 0; i < len(items1); i++ { tmp[items1[i][0]] += items1[i][1] }\\n    for i := 0; i < len(items2); i++ { tmp[items2[i][0]] += items2[i][1] }\\n\\n    result := [][]int{}\\n    for i := 0; i < len(tmp); i++ {\\n        if tmp[i] > 0 {\\n            result = append(result, []int{i, tmp[i]})\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeSimilarItems(items1 [][]int, items2 [][]int) [][]int {\\n    tmp := make([]int, 1001)\\n    for i := 0; i < len(items1); i++ { tmp[items1[i][0]] += items1[i][1] }\\n    for i := 0; i < len(items2); i++ { tmp[items2[i][0]] += items2[i][1] }\\n\\n    result := [][]int{}\\n    for i := 0; i < len(tmp); i++ {\\n        if tmp[i] > 0 {\\n            result = append(result, []int{i, tmp[i]})\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871121,
                "title": "using-maps-o-n-m-time-and-o-n-m-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStep1 : Iterate in first array and store key and weights.\\nstep2 : Iterate in Second array and if key is already present in array then sum up their value with existing weight. Otherwise do add it in map;\\nstep 3 ; iterate in map and copy all key val in vector and then return the vectore\\n\\n\\n# Complexity\\n- Time complexity: O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        // getting size\\n        int n = items1.size(); \\n        int l = items2.size();\\n        vector<vector<int>> ans;\\n\\n        // creating map to store key and weights\\n        map<int , int> m;\\n\\n        Iterate in first array and store key and weights.\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            m[items1[i][0]]=items1[i][1];\\n        }\\n \\n        // Iterate in Second array and if key is already present in array then sum up their value with existing weight. Otherwise do add it in map;\\n        for(int i=0 ; i<l; i++)\\n        {\\n            if(m.find(items2[i][0])!=m.end())\\n            {\\n                m[items2[i][0]]+=items2[i][1];\\n            }\\n            else\\n             m[items2[i][0]]=items2[i][1];\\n\\n        }\\n \\n        //iterate in map and copy all key val in vector and then return the vectore\\n        for(auto i : m)\\n        {\\n           vector<int> v; \\n           v.push_back(i.first);\\n           v.push_back(i.second);\\n           ans.push_back(v);\\n\\n        }\\n          return ans;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        // getting size\\n        int n = items1.size(); \\n        int l = items2.size();\\n        vector<vector<int>> ans;\\n\\n        // creating map to store key and weights\\n        map<int , int> m;\\n\\n        Iterate in first array and store key and weights.\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            m[items1[i][0]]=items1[i][1];\\n        }\\n \\n        // Iterate in Second array and if key is already present in array then sum up their value with existing weight. Otherwise do add it in map;\\n        for(int i=0 ; i<l; i++)\\n        {\\n            if(m.find(items2[i][0])!=m.end())\\n            {\\n                m[items2[i][0]]+=items2[i][1];\\n            }\\n            else\\n             m[items2[i][0]]=items2[i][1];\\n\\n        }\\n \\n        //iterate in map and copy all key val in vector and then return the vectore\\n        for(auto i : m)\\n        {\\n           vector<int> v; \\n           v.push_back(i.first);\\n           v.push_back(i.second);\\n           ans.push_back(v);\\n\\n        }\\n          return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870231,
                "title": "easy-approach-with-basic-python-syntax-solution-which-beats-over-90-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        dicti = {}\\n        arr = []\\n        ret = []\\n        for i in range(len(items1)):\\n            dicti[items1[i][0]] = items1[i][1]\\n            arr.append(items1[i][0])\\n        for j in range(len(items2)):\\n            if(items2[j][0] not in dicti.keys()):\\n                dicti[items2[j][0]] = items2[j][1]\\n                arr.append(items2[j][0])\\n            else:\\n                dicti[items2[j][0]] = dicti[items2[j][0]] + items2[j][1]\\n        arr.sort()\\n        for k in range(len(arr)):\\n            ret.append([arr[k],dicti[arr[k]]])\\n        return ret\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        dicti = {}\\n        arr = []\\n        ret = []\\n        for i in range(len(items1)):\\n            dicti[items1[i][0]] = items1[i][1]\\n            arr.append(items1[i][0])\\n        for j in range(len(items2)):\\n            if(items2[j][0] not in dicti.keys()):\\n                dicti[items2[j][0]] = items2[j][1]\\n                arr.append(items2[j][0])\\n            else:\\n                dicti[items2[j][0]] = dicti[items2[j][0]] + items2[j][1]\\n        arr.sort()\\n        for k in range(len(arr)):\\n            ret.append([arr[k],dicti[arr[k]]])\\n        return ret\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863764,
                "title": "best-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n\\n       Arrays.sort(items1, Comparator.comparingInt(arr -> arr[0]));\\n        Arrays.sort(items2, Comparator.comparingInt(arr -> arr[0]));\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < items1.length && j < items2.length) {\\n            int firstColItem1 = items1[i][0];\\n            int firstColItem2 = items2[j][0];\\n\\n            if (firstColItem1 == firstColItem2) {\\n                int sum = items1[i][1] + items2[j][1];\\n                List<Integer> tempList = new ArrayList<>();\\n                tempList.add(firstColItem1);\\n                tempList.add(sum);\\n                ans.add(tempList);\\n                i++;\\n                j++;\\n            } else if (firstColItem1 < firstColItem2) {\\n                List<Integer> tempList = new ArrayList<>();\\n                tempList.add(firstColItem1);\\n                tempList.add(items1[i][1]);\\n                ans.add(tempList);\\n                i++;\\n            } else {\\n                List<Integer> tempList = new ArrayList<>();\\n                tempList.add(firstColItem2);\\n                tempList.add(items2[j][1]);\\n                ans.add(tempList);\\n                j++;\\n            }\\n        }\\n\\n        // Add remaining elements from items1\\n        while (i < items1.length) {\\n            List<Integer> tempList = new ArrayList<>();\\n            tempList.add(items1[i][0]);\\n            tempList.add(items1[i][1]);\\n            ans.add(tempList);\\n            i++;\\n        }\\n\\n        // Add remaining elements from items2\\n        while (j < items2.length) {\\n            List<Integer> tempList = new ArrayList<>();\\n            tempList.add(items2[j][0]);\\n            tempList.add(items2[j][1]);\\n            ans.add(tempList);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n\\n       Arrays.sort(items1, Comparator.comparingInt(arr -> arr[0]));\\n        Arrays.sort(items2, Comparator.comparingInt(arr -> arr[0]));\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < items1.length && j < items2.length) {\\n            int firstColItem1 = items1[i][0];\\n            int firstColItem2 = items2[j][0];\\n\\n            if (firstColItem1 == firstColItem2) {\\n                int sum = items1[i][1] + items2[j][1];\\n                List<Integer> tempList = new ArrayList<>();\\n                tempList.add(firstColItem1);\\n                tempList.add(sum);\\n                ans.add(tempList);\\n                i++;\\n                j++;\\n            } else if (firstColItem1 < firstColItem2) {\\n                List<Integer> tempList = new ArrayList<>();\\n                tempList.add(firstColItem1);\\n                tempList.add(items1[i][1]);\\n                ans.add(tempList);\\n                i++;\\n            } else {\\n                List<Integer> tempList = new ArrayList<>();\\n                tempList.add(firstColItem2);\\n                tempList.add(items2[j][1]);\\n                ans.add(tempList);\\n                j++;\\n            }\\n        }\\n\\n        // Add remaining elements from items1\\n        while (i < items1.length) {\\n            List<Integer> tempList = new ArrayList<>();\\n            tempList.add(items1[i][0]);\\n            tempList.add(items1[i][1]);\\n            ans.add(tempList);\\n            i++;\\n        }\\n\\n        // Add remaining elements from items2\\n        while (j < items2.length) {\\n            List<Integer> tempList = new ArrayList<>();\\n            tempList.add(items2[j][0]);\\n            tempList.add(items2[j][1]);\\n            ans.add(tempList);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862380,
                "title": "easy-solution-java-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n = items1.length;\\n        int m = items2.length;\\n\\n        if (n == 0 && m == 0)\\n            return res;\\n\\n        for (int[] i : items1) {\\n            map.put(i[0], map.getOrDefault(i[0], 0) + i[1]);\\n        }\\n\\n        for (int[] i : items2) {\\n            map.put(i[0], map.getOrDefault(i[0], 0) + i[1]);\\n        }\\n\\n        for (int j : map.keySet()) {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(j);\\n            list.add(map.get(j));\\n            res.add(list);\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        int n = items1.length;\\n        int m = items2.length;\\n\\n        if (n == 0 && m == 0)\\n            return res;\\n\\n        for (int[] i : items1) {\\n            map.put(i[0], map.getOrDefault(i[0], 0) + i[1]);\\n        }\\n\\n        for (int[] i : items2) {\\n            map.put(i[0], map.getOrDefault(i[0], 0) + i[1]);\\n        }\\n\\n        for (int j : map.keySet()) {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(j);\\n            list.add(map.get(j));\\n            res.add(list);\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860286,
                "title": "a-simple-sort-beats-92-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n\\n        items1=items1+items2\\n        items1.sort()\\n        items2=[]\\n        items2.append(items1[0])\\n\\n        for i in range(1,len(items1)):\\n            if items1[i][0]==items2[-1][0]:\\n                ub=items1[i][1]+items2[-1][1]         \\n                items2[-1][1]=ub\\n            else:\\n                items2.append(items1[i])\\n\\n\\n        return items2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n\\n        items1=items1+items2\\n        items1.sort()\\n        items2=[]\\n        items2.append(items1[0])\\n\\n        for i in range(1,len(items1)):\\n            if items1[i][0]==items2[-1][0]:\\n                ub=items1[i][1]+items2[-1][1]         \\n                items2[-1][1]=ub\\n            else:\\n                items2.append(items1[i])\\n\\n\\n        return items2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847540,
                "title": "easy-cpp-beats-98-in-time-hash-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>>ret;\\n        map<int,int>mp;\\n        for(auto it:items1){\\n            mp[it[0]]+=it[1];\\n        }\\n        for(auto it:items2){\\n            mp[it[0]]+=it[1];\\n        }\\n        for(auto it:mp){\\n            ret.push_back({it.first,it.second});\\n        }\\n        return ret;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        vector<vector<int>>ret;\\n        map<int,int>mp;\\n        for(auto it:items1){\\n            mp[it[0]]+=it[1];\\n        }\\n        for(auto it:items2){\\n            mp[it[0]]+=it[1];\\n        }\\n        for(auto it:mp){\\n            ret.push_back({it.first,it.second});\\n        }\\n        return ret;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847418,
                "title": "simple-c-solution-using-map-hash-table-o-n",
                "content": "# Intuition\\nThis solution is uses map in cpp\\n\\n# Approach\\n1. Add items 1 key value pair in a map.\\n2. Iterate over item2 and add the value for the keys available into the map.\\n3. clear the items1 data to reuse it.\\n4. iterate over the map in ascending order and insert it into items1.\\n5. return items1.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n     map<int,int> ht;\\n     for(auto item:items1)\\n     {\\n        ht[item[0]] = item[1];\\n     }\\n     for(auto item:items2)\\n     {\\n        ht[item[0]] += item[1];\\n     }\\n     items1.clear();\\n     for(auto i=ht.begin();i!=ht.end();i++)\\n     {\\n         items1.push_back({i->first,i->second});\\n     }\\n    return items1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n     map<int,int> ht;\\n     for(auto item:items1)\\n     {\\n        ht[item[0]] = item[1];\\n     }\\n     for(auto item:items2)\\n     {\\n        ht[item[0]] += item[1];\\n     }\\n     items1.clear();\\n     for(auto i=ht.begin();i!=ht.end();i++)\\n     {\\n         items1.push_back({i->first,i->second});\\n     }\\n    return items1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846025,
                "title": "using-merge-sort-29ms-96-beats-no-extra-space",
                "content": "# Intuition\\nUsing Merge Sort\\n\\n# Approach\\nsimilar to merge sort agorithm.\\n\\n# Complexity\\n- Time complexity:\\nO(max(items1.size(),items2.size())log(max(items1.size(),items2.size())))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n       sort(items1.begin(),items1.end());\\n       sort(items2.begin(),items2.end());\\n       int n=items1.size(),m=items2.size();\\n       int i=0,j=0;\\n       while(i<n&&j<m)\\n       {\\n           if(items1[i][0]==items2[j][0])\\n           {\\n               items1[i][1]+=items2[j][1];\\n               i++;\\n               j++;\\n           }\\n           else if(items1[i][0]<items2[j][0])\\n           {\\n               i++;\\n           }\\n           else\\n           {\\n               items1.push_back(items2[j]);\\n               j++;\\n           }\\n       }\\n       while(j<m)\\n       {\\n           items1.push_back(items2[j]);\\n           j++;\\n       }\\n       sort(items1.begin(),items1.end());\\n       return items1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n       sort(items1.begin(),items1.end());\\n       sort(items2.begin(),items2.end());\\n       int n=items1.size(),m=items2.size();\\n       int i=0,j=0;\\n       while(i<n&&j<m)\\n       {\\n           if(items1[i][0]==items2[j][0])\\n           {\\n               items1[i][1]+=items2[j][1];\\n               i++;\\n               j++;\\n           }\\n           else if(items1[i][0]<items2[j][0])\\n           {\\n               i++;\\n           }\\n           else\\n           {\\n               items1.push_back(items2[j]);\\n               j++;\\n           }\\n       }\\n       while(j<m)\\n       {\\n           items1.push_back(items2[j]);\\n           j++;\\n       }\\n       sort(items1.begin(),items1.end());\\n       return items1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845913,
                "title": "python-fast-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        c = collections.defaultdict()\\n        for i in items1:\\n            c[i[0]] = c.get(i[0], 0) + i[1]\\n        for i in items2:\\n            c[i[0]] = c.get(i[0], 0) + i[1]\\n        ret = []\\n        for k, v in c.items():\\n            ret.append([k, v])\\n        return sorted(ret, key=lambda x:x[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        c = collections.defaultdict()\\n        for i in items1:\\n            c[i[0]] = c.get(i[0], 0) + i[1]\\n        for i in items2:\\n            c[i[0]] = c.get(i[0], 0) + i[1]\\n        ret = []\\n        for k, v in c.items():\\n            ret.append([k, v])\\n        return sorted(ret, key=lambda x:x[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833900,
                "title": "if-you-want-to-gain-braincells-use-this-code",
                "content": "# Intuition\\nim a natural born genius.. just kidding\\n1. intialise a dictionary to get unique values in item 1\\n2. use same dictionary to either add new items from item 2, or add to existing\\n3. zip the keys and values, then sort them. now u have a list of tuples\\n4. either use list comprehension or two nested for loops to get a list of lists\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        #initialise a dictionary\\n        dict={}\\n        for i in items1:\\n            dict[i[0]]=i[1]\\n\\n        for i in items2:\\n            if i[0] in dict:\\n                dict[i[0]]+=i[1] #add\\n            else:\\n                dict[i[0]]=i[1] #if it doesnt exist then we add \\'i\\' as a key and its value is the pairing\\n        #so now we need to convert dictionary into a list of lists\\n        output_tup=sorted(list(zip(dict.keys(),dict.values())))\\n        output_listout=[]\\n\\n        #convert to list of tuples to list of lists\\n        for i in output_tup:\\n            output_listin=[]\\n            for j in range(2):\\n                output_listin.append(i[j]) #\\n            output_listout.append(output_listin)\\n\\n        return output_listout\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        #initialise a dictionary\\n        dict={}\\n        for i in items1:\\n            dict[i[0]]=i[1]\\n\\n        for i in items2:\\n            if i[0] in dict:\\n                dict[i[0]]+=i[1] #add\\n            else:\\n                dict[i[0]]=i[1] #if it doesnt exist then we add \\'i\\' as a key and its value is the pairing\\n        #so now we need to convert dictionary into a list of lists\\n        output_tup=sorted(list(zip(dict.keys(),dict.values())))\\n        output_listout=[]\\n\\n        #convert to list of tuples to list of lists\\n        for i in output_tup:\\n            output_listin=[]\\n            for j in range(2):\\n                output_listin.append(i[j]) #\\n            output_listout.append(output_listin)\\n\\n        return output_listout\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830777,
                "title": "java-using-counting-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        int[] iw = new int[1001];\\n        for(int[] it : items1) {\\n            int val = it[0];\\n            int val1 = it[1];\\n            iw[val] += val1;\\n        }\\n\\n        for(int[] it : items2) {\\n            int val = it[0];\\n            int val1 = it[1];\\n            iw[val] += val1;\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for(int i=1;i<1001;i++) {\\n           if(iw[i] != 0) {\\n               List<Integer> temp = new ArrayList<>();\\n               temp.add(i);\\n               temp.add(iw[i]);\\n               ans.add(temp);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> mergeSimilarItems(int[][] items1, int[][] items2) {\\n        int[] iw = new int[1001];\\n        for(int[] it : items1) {\\n            int val = it[0];\\n            int val1 = it[1];\\n            iw[val] += val1;\\n        }\\n\\n        for(int[] it : items2) {\\n            int val = it[0];\\n            int val1 = it[1];\\n            iw[val] += val1;\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        for(int i=1;i<1001;i++) {\\n           if(iw[i] != 0) {\\n               List<Integer> temp = new ArrayList<>();\\n               temp.add(i);\\n               temp.add(iw[i]);\\n               ans.add(temp);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821019,
                "title": "c-easy-map-solution-beats-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        vector<vector<int>> res;\\n        map<int,int> res1;\\n        int i;\\n        for(i=0;i<items1.size();i++)\\n            res1[items1[i][0]]=items1[i][1];\\n        for(i=0;i<items2.size();i++)\\n            res1[items2[i][0]]+=items2[i][1];\\n        for(auto x:res1)\\n            res.push_back({x.first,x.second});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) \\n    {\\n        vector<vector<int>> res;\\n        map<int,int> res1;\\n        int i;\\n        for(i=0;i<items1.size();i++)\\n            res1[items1[i][0]]=items1[i][1];\\n        for(i=0;i<items2.size();i++)\\n            res1[items2[i][0]]+=items2[i][1];\\n        for(auto x:res1)\\n            res.push_back({x.first,x.second});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816676,
                "title": "swift-one-liner-o-n-time-o-n-space",
                "content": "# Explanation\\nThis solution uses an array instead of a dictionary to avoid having to sort dictionary keys. This reduces the time complexity from $$O(n \\\\log n)$$ to $$O(n)$$. There is a tradeoff though, this solution always uses an array of size 1001 whereas a dictionary might be more memory efficient for small item arrays.\\n\\nThe first `reduce` counts the occurences of each item, it\\'s irrelevant which array they are in so we just concatente the arrays.\\nThen `enumerated` is used to generate tuples with the index and value.\\nNext, `filter` removes all entries with zero counts.\\nFinally `map` is used to transform the tuples into the required two element arrays.\\n\\nLiberal use is made of `lazy` to avoid the memory overhead of intermediate arrays.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$, it could be argued that it is $$O(1)$$ since we use a constant sized array, but that array size is only constant because of the constraint $$N <= 1000$$ so that argument seems a bit dubious.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func mergeSimilarItems(_ items1: [[Int]], _ items2: [[Int]]) -> [[Int]] {\\n         (items1 + items2)\\n            .reduce(into: [Int](repeating: 0, count: 1001)) { $0[$1[0]] += $1[1] }.lazy\\n            .enumerated().lazy\\n            .filter { $0.element > 0 }.lazy\\n            .map { [$0.offset, $0.element ] }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mergeSimilarItems(_ items1: [[Int]], _ items2: [[Int]]) -> [[Int]] {\\n         (items1 + items2)\\n            .reduce(into: [Int](repeating: 0, count: 1001)) { $0[$1[0]] += $1[1] }.lazy\\n            .enumerated().lazy\\n            .filter { $0.element > 0 }.lazy\\n            .map { [$0.offset, $0.element ] }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815001,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>mp;\\n        for(int i=0;i<items1.size();i++)\\n        {\\n            mp[items1[i][0]]=items1[i][1];\\n        }\\n\\n        for(int i=0;i<items2.size();i++)\\n        {\\n            if(mp.find(items2[i][0])!=mp.end())\\n            {\\n                mp[items2[i][0]]+=items2[i][1];\\n            }\\n            else{\\n                mp[items2[i][0]]=items2[i][1];\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:mp)\\n        {\\n            vector<int>temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n        map<int,int>mp;\\n        for(int i=0;i<items1.size();i++)\\n        {\\n            mp[items1[i][0]]=items1[i][1];\\n        }\\n\\n        for(int i=0;i<items2.size();i++)\\n        {\\n            if(mp.find(items2[i][0])!=mp.end())\\n            {\\n                mp[items2[i][0]]+=items2[i][1];\\n            }\\n            else{\\n                mp[items2[i][0]]=items2[i][1];\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:mp)\\n        {\\n            vector<int>temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813353,
                "title": "python3-easy-fast",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(int)\\n        for x,y in items1:\\n            d[x] += y\\n        for x,y in items2:\\n            d[x] += y\\n        res = []\\n        for x,y in d.items():\\n            res.append((x,y))\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(int)\\n        for x,y in items1:\\n            d[x] += y\\n        for x,y in items2:\\n            d[x] += y\\n        res = []\\n        for x,y in d.items():\\n            res.append((x,y))\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1808964,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/"
                    },
                    {
                        "username": "Androw77",
                        "content": "This is very long :/"
                    },
                    {
                        "username": "pratyakshhhh",
                        "content": "It\\'s easy but very lengthy"
                    },
                    {
                        "username": "1tarekhassan1",
                        "content": "this is absolutely not easy"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Anyone please help me In Linq\nWith below Code we can merge the two item  \n```var merge = items1.Union(items2).Select(x => new { Key = x[0], Count = x[1]})```\n![image.png](https://assets.leetcode.com/users/images/4cad61e4-3acb-4fb8-a79a-fade79fb096c_1671187565.4683535.png)\nBut i am not able to figure out how to use Linq \nIn  grouping distinct  key  and \nadd the sum of value if key were previously found\nlike this \n\n![image.png](https://assets.leetcode.com/users/images/da644b89-3158-4232-821e-6a24deaf32c3_1671187889.0772498.png)\n\nedit \nfinally \n```\nvar dict = items1.Union(items2)\n.Select(  x => new { Key = x[0], Count = x[1] } )\n.GroupBy( x => x.Key, (m,n) => new { Key=m, Value=n.Sum( w => w.Count ) } );\n```\n\n![image.png](https://assets.leetcode.com/users/images/5905741d-d1d8-4fc2-872f-bad778981a37_1671192338.6412432.png)"
                    }
                ]
            },
            {
                "id": 2050796,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/"
                    },
                    {
                        "username": "Androw77",
                        "content": "This is very long :/"
                    },
                    {
                        "username": "pratyakshhhh",
                        "content": "It\\'s easy but very lengthy"
                    },
                    {
                        "username": "1tarekhassan1",
                        "content": "this is absolutely not easy"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Anyone please help me In Linq\nWith below Code we can merge the two item  \n```var merge = items1.Union(items2).Select(x => new { Key = x[0], Count = x[1]})```\n![image.png](https://assets.leetcode.com/users/images/4cad61e4-3acb-4fb8-a79a-fade79fb096c_1671187565.4683535.png)\nBut i am not able to figure out how to use Linq \nIn  grouping distinct  key  and \nadd the sum of value if key were previously found\nlike this \n\n![image.png](https://assets.leetcode.com/users/images/da644b89-3158-4232-821e-6a24deaf32c3_1671187889.0772498.png)\n\nedit \nfinally \n```\nvar dict = items1.Union(items2)\n.Select(  x => new { Key = x[0], Count = x[1] } )\n.GroupBy( x => x.Key, (m,n) => new { Key=m, Value=n.Sum( w => w.Count ) } );\n```\n\n![image.png](https://assets.leetcode.com/users/images/5905741d-d1d8-4fc2-872f-bad778981a37_1671192338.6412432.png)"
                    }
                ]
            },
            {
                "id": 2043471,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/"
                    },
                    {
                        "username": "Androw77",
                        "content": "This is very long :/"
                    },
                    {
                        "username": "pratyakshhhh",
                        "content": "It\\'s easy but very lengthy"
                    },
                    {
                        "username": "1tarekhassan1",
                        "content": "this is absolutely not easy"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Anyone please help me In Linq\nWith below Code we can merge the two item  \n```var merge = items1.Union(items2).Select(x => new { Key = x[0], Count = x[1]})```\n![image.png](https://assets.leetcode.com/users/images/4cad61e4-3acb-4fb8-a79a-fade79fb096c_1671187565.4683535.png)\nBut i am not able to figure out how to use Linq \nIn  grouping distinct  key  and \nadd the sum of value if key were previously found\nlike this \n\n![image.png](https://assets.leetcode.com/users/images/da644b89-3158-4232-821e-6a24deaf32c3_1671187889.0772498.png)\n\nedit \nfinally \n```\nvar dict = items1.Union(items2)\n.Select(  x => new { Key = x[0], Count = x[1] } )\n.GroupBy( x => x.Key, (m,n) => new { Key=m, Value=n.Sum( w => w.Count ) } );\n```\n\n![image.png](https://assets.leetcode.com/users/images/5905741d-d1d8-4fc2-872f-bad778981a37_1671192338.6412432.png)"
                    }
                ]
            },
            {
                "id": 2024322,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/"
                    },
                    {
                        "username": "Androw77",
                        "content": "This is very long :/"
                    },
                    {
                        "username": "pratyakshhhh",
                        "content": "It\\'s easy but very lengthy"
                    },
                    {
                        "username": "1tarekhassan1",
                        "content": "this is absolutely not easy"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Anyone please help me In Linq\nWith below Code we can merge the two item  \n```var merge = items1.Union(items2).Select(x => new { Key = x[0], Count = x[1]})```\n![image.png](https://assets.leetcode.com/users/images/4cad61e4-3acb-4fb8-a79a-fade79fb096c_1671187565.4683535.png)\nBut i am not able to figure out how to use Linq \nIn  grouping distinct  key  and \nadd the sum of value if key were previously found\nlike this \n\n![image.png](https://assets.leetcode.com/users/images/da644b89-3158-4232-821e-6a24deaf32c3_1671187889.0772498.png)\n\nedit \nfinally \n```\nvar dict = items1.Union(items2)\n.Select(  x => new { Key = x[0], Count = x[1] } )\n.GroupBy( x => x.Key, (m,n) => new { Key=m, Value=n.Sum( w => w.Count ) } );\n```\n\n![image.png](https://assets.leetcode.com/users/images/5905741d-d1d8-4fc2-872f-bad778981a37_1671192338.6412432.png)"
                    }
                ]
            },
            {
                "id": 1718166,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/"
                    },
                    {
                        "username": "Androw77",
                        "content": "This is very long :/"
                    },
                    {
                        "username": "pratyakshhhh",
                        "content": "It\\'s easy but very lengthy"
                    },
                    {
                        "username": "1tarekhassan1",
                        "content": "this is absolutely not easy"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Anyone please help me In Linq\nWith below Code we can merge the two item  \n```var merge = items1.Union(items2).Select(x => new { Key = x[0], Count = x[1]})```\n![image.png](https://assets.leetcode.com/users/images/4cad61e4-3acb-4fb8-a79a-fade79fb096c_1671187565.4683535.png)\nBut i am not able to figure out how to use Linq \nIn  grouping distinct  key  and \nadd the sum of value if key were previously found\nlike this \n\n![image.png](https://assets.leetcode.com/users/images/da644b89-3158-4232-821e-6a24deaf32c3_1671187889.0772498.png)\n\nedit \nfinally \n```\nvar dict = items1.Union(items2)\n.Select(  x => new { Key = x[0], Count = x[1] } )\n.GroupBy( x => x.Key, (m,n) => new { Key=m, Value=n.Sum( w => w.Count ) } );\n```\n\n![image.png](https://assets.leetcode.com/users/images/5905741d-d1d8-4fc2-872f-bad778981a37_1671192338.6412432.png)"
                    }
                ]
            }
        ]
    }
]