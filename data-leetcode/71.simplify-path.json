[
    {
        "title": "Simplify Path",
        "question_content": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\nIn a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\nThe canonical path should have the following format:\n\n\tThe path starts with a single slash '/'.\n\tAny two directories are separated by a single slash '/'.\n\tThe path does not end with a trailing '/'.\n\tThe path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n\nReturn the simplified canonical path.\n&nbsp;\nExample 1:\n\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation: Note that there is no trailing slash after the last directory name.\n\nExample 2:\n\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\nExample 3:\n\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n\n&nbsp;\nConstraints:\n\n\t1 <= path.length <= 3000\n\tpath consists of English letters, digits, period '.', slash '/' or '_'.\n\tpath is a valid absolute Unix path.",
        "solutions": [
            {
                "id": 1847357,
                "title": "c-easy-stack-simple-explained-algorithm",
                "content": "# 71. Simplify Path\\n**KNOCKCAT**\\n\\nPlease ALso have a look to my Leetcode Repository Link Given Below :)\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](https://github.com/knockcat/Leetcode)     **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n``` ```\\n\\n**EXPLANATION**\\n* Create a **Stack of String** with following condition.\\n\\t* **Iterate the loop till you doesn\\'t reaches the end of string.**\\n\\t* If you **encounter a  \"/\" then ignore it.**\\n\\t* **Create a temp String** & **Iterate the while loop** till you **doesn\\'t find  \"/\"** and **append it to temp**.\\n\\t* Now check if **temp  == \".\"** , t**hen ignore it**.\\n\\t* If **temp == \"..\"** then **pop the element from the stack if it exists.**\\n\\t* If **no of the above 2 matches** **push temp to stack** as you find a valid path.\\n\\t* **Check out temp** string on **basis of above conditions till you doesn\\'t find \"/\".**\\n* \\tNow **add all stack elements** to result as **res = \"/\" + st.top() + res**\\n* \\tIf **res.size() is 0** then **return \"/\"**  if no directory or file is present.\\n* \\tAt last **return res**.\\n\\n```\\nInput: path = \"/../\"\\nOutput: \"/\"\\nInput: path = \"/home//foo/\"\\nOutput: \"/home/foo\"\\n```\\n\\n**ALGORITHM**\\n* By looking at examples we can see that the above **simplification process** just **behaves like a stack**.\\n* **Whenever we encounter any file\\u2019s name**, **we simply push it into the stack**.\\n* when we come across **\\u201D . \\u201D** **we do nothing**\\n* When **we find \\u201C..\\u201D** in our path, **we simply pop the topmost element** as we **have to jump back to parent\\u2019s directory.**\\n* When we **see multiple \\u201C////\\u201D** we **just ignore them** as **they are equivalent to one single \\u201C/\\u201D.** \\n* After **iterating through the whole string** the **elements remaining in the stack** is our **simplified absolute path.**\\n\\n\\n``` ```\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack<string> st;\\n        string res;\\n        \\n        for(int i = 0;  i<path.size(); ++i)\\n        {\\n            if(path[i] == \\'/\\')    \\n                continue;\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last /\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n\\t\\t\\t\\t// add path to temp string\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\")\\n                continue;\\n\\t\\t\\t// pop the top element from stack if exists\\n            else if(temp == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n        \\n\\t\\t// adding all the stack elements to res\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        \\n\\t\\t// if no directory or file is present\\n        if(res.size() == 0)\\n            return \"/\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n```\\nInput: path = \"/../\"\\nOutput: \"/\"\\nInput: path = \"/home//foo/\"\\nOutput: \"/home/foo\"\\n```\n``` ```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack<string> st;\\n        string res;\\n        \\n        for(int i = 0;  i<path.size(); ++i)\\n        {\\n            if(path[i] == \\'/\\')    \\n                continue;\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last /\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n\\t\\t\\t\\t// add path to temp string\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\")\\n                continue;\\n\\t\\t\\t// pop the top element from stack if exists\\n            else if(temp == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n        \\n\\t\\t// adding all the stack elements to res\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        \\n\\t\\t// if no directory or file is present\\n        if(res.size() == 0)\\n            return \"/\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847526,
                "title": "best-explanation-ever-possible-not-a-clickbait",
                "content": "How\\'s going Ladies - n - GentleMen, today we are going to solve another coolest problem i.e. **Simplify Path**\\n\\nAlright, so let\\'s understand this problem with an example :-\\n\\n**Input:** `path = \"/a/./b/../../c/\"`\\n**Output:** `\"/c\"`\\n\\nLet\\'s understand what this mean\\'s, so basically this seems like you a path of your folder, so generically we use this kind of command\\'s in terminal. I hope u know a bit about that. Anyway\\'s let\\'s move further on.\\n\\n* okay, so the first command `/a/` means get into the folder `/a/`\\n\\n\\n* The next command is `/./` means stay over there\\n* The next command is `/b/` means get into the folder `/b/`\\n* The next command is `/../` means come out from the folder `/b/`\\n* The next command is `/../` means come out from the folder `/a/`\\n* Now we are kind of in home directory\\n* The next command is `/c/` means get into the folder `/c/`\\n* And in the output we return what command we left with.\\n\\nLet\\'s understand it a bit visually.\\n* Going to **`/a/./b/`**\\n![image](https://assets.leetcode.com/users/images/fda0afe4-f04d-4ab4-a5e8-950859e88a94_1647224192.301499.png)\\n* Coming out **`/../../`**\\n![image](https://assets.leetcode.com/users/images/d4a78ce7-b5a1-40c6-bf09-39270dd86a90_1647224302.6337845.png)\\n* Going to **`/c/`**\\n![image](https://assets.leetcode.com/users/images/1490e3dd-f3be-4b22-bcc9-0518f99ad38c_1647224553.681243.png)\\n\\nSo, basically what are we doing:-\\n**Pushing** and **Popping** directory names based on rules\\n\\nAnd what are the rules :-\\n1. **/..** come out from the directory\\n2. **/nameOfDirectory** going into directory\\n\\nNow you say, Dude that\\'s A-OK but which Data Structure do we use to solve this problem. Well. i had already gives you a hint if you remember **Pushing** and **Popping**. So where do we Generically used in `Stack` or `Queue`\\n\\nWe\\'ll solve this problem using Stack. But if you want the solution of `Queue` as well, **do lemmino (:**\\n\\nAlright, back to the problem - So, what we can do is by looking at the rules, split the directrory by the slash`/` given and that will give us in the form of array e.g :- **`[a, ., b, .., .., c]`**\\n\\nLet\\'s understand it\\'s working visually:-\\n\\n![image](https://assets.leetcode.com/users/images/2a40a0e0-3a9d-4e4a-bdf6-19f3aada5bea_1647225944.7493086.gif)\\n\\nBut remeber when returning we have to go in the form of reverse order. Because Stack use **LIFO** order and the highest one will comes out. But we need the lowest once first. So, we need to append in the carefull manner.\\n\\n*I hope ladies and gentlemen approach is clear* **Let\\'s code it up**\\n\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** O(N)\\n\\n* **Space Complexity :-** O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25686,
                "title": "java-10-lines-solution-with-stack",
                "content": "Hi guys!\\n\\nThe main idea is to push to the stack every valid file name (not in {\"\",\".\",\"..\"}), popping only if there's smth to pop and we met \"..\". I don't feel like the code below needs any additional comments.\\n\\n    public String simplifyPath(String path) {\\n        Deque<String> stack = new LinkedList<>();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\",\".\",\"\"));\\n        for (String dir : path.split(\"/\")) {\\n            if (dir.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!skip.contains(dir)) stack.push(dir);\\n        }\\n        String res = \"\";\\n        for (String dir : stack) res = \"/\" + dir + res;\\n        return res.isEmpty() ? \"/\" : res;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe main idea is to push to the stack every valid file name (not in {\"\",\".\",\"..\"}), popping only if there's smth to pop and we met \"..\". I don't feel like the code below needs any additional comments.\\n\\n    public String simplifyPath(String path) {\\n        Deque<String> stack = new LinkedList<>();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\",\".\",\"\"));\\n        for (String dir : path.split(\"/\")) {\\n            if (dir.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!skip.contains(dir)) stack.push(dir);\\n        }\\n        String res = \"\";\\n        for (String dir : stack) res = \"/\" + dir + res;\\n        return res.isEmpty() ? \"/\" : res;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 25680,
                "title": "c-10-lines-solution",
                "content": "C++ also have  *getline* which acts like Java's *split*. I guess the code can comment itself.\\n\\n    string simplifyPath(string path) {\\n        string res, tmp;\\n        vector<string> stk;\\n        stringstream ss(path);\\n        while(getline(ss,tmp,'/')) {\\n            if (tmp == \"\" or tmp == \".\") continue;\\n            if (tmp == \"..\" and !stk.empty()) stk.pop_back();\\n            else if (tmp != \"..\") stk.push_back(tmp);\\n        }\\n        for(auto str : stk) res += \"/\"+str;\\n        return res.empty() ? \"/\" : res;\\n    }",
                "solutionTags": [],
                "code": "C++ also have  *getline* which acts like Java's *split*. I guess the code can comment itself.\\n\\n    string simplifyPath(string path) {\\n        string res, tmp;\\n        vector<string> stk;\\n        stringstream ss(path);\\n        while(getline(ss,tmp,'/')) {\\n            if (tmp == \"\" or tmp == \".\") continue;\\n            if (tmp == \"..\" and !stk.empty()) stk.pop_back();\\n            else if (tmp != \"..\") stk.push_back(tmp);\\n        }\\n        for(auto str : stk) res += \"/\"+str;\\n        return res.empty() ? \"/\" : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1050573,
                "title": "python-short-stack-solution-explained",
                "content": "When you see this problem, you should think about stack. Why? Because we have directories and you can go deeper or come back and when you come back, you basically forgot about all element after and stack is ideal simulation of this process. Also in python you can use `.split(\"/\")` function, which will split our string into parts, separated by `/` symbol.\\n\\nSo, the algorithm will look like this:\\n1. If stack is not empty and we meet `..` element, it means, that we need to go one level up, so we just pop element from stack and forgot about it.\\n2. If we have any other element except several cases, we put it to the end of stack. So, what cases we need to avoid: if we meet `.`, it means current directory according to problem description, so we do not need to go deeper; if we meet `..`, and it means that stack is empty, so we already at the top of our path, so we againd do nothing in this case. Finally, we can meet empty string also, it corresponds to case, when we have `//`, then there is empty string between two `/`.\\n3. In the end we reconstruct string from all element, using `/` to join them.\\n\\n**Complexity**: time complexity is `O(n)`, because we only traverse our path once. Space complexity is `O(n)`, because there can be potentially `O(n)` elements inside.\\n\\n```\\nclass Solution:\\n    def simplifyPath(self, path):\\n        stack = []\\n        for elem in path.split(\"/\"):\\n            if stack and elem == \"..\":\\n                stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path):\\n        stack = []\\n        for elem in path.split(\"/\"):\\n            if stack and elem == \"..\":\\n                stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25691,
                "title": "9-lines-of-python-code",
                "content": "    class Solution(object):\\n        def simplifyPath(self, path):\\n            places = [p for p in path.split(\"/\") if p!=\".\" and p!=\"\"]\\n            stack = []\\n            for p in places:\\n                if p == \"..\":\\n                    if len(stack) > 0:\\n                        stack.pop()\\n                else:\\n                    stack.append(p)\\n            return \"/\" + \"/\".join(stack)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def simplifyPath(self, path):\\n            places = [p for p in path.split(\"/\") if p!=\".\" and p!=\"\"]\\n            stack = []\\n            for p in places:\\n                if p == \"..\":\\n                    if len(stack) > 0:\\n                        stack.pop()\\n                else:\\n                    stack.append(p)\\n            return \"/\" + \"/\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 25778,
                "title": "java-easy-to-understand-stack-solution",
                "content": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (int i = 0; i < p.length; i++) {\\n            if (!stack.empty() && p[i].equals(\"..\"))\\n                stack.pop();\\n            else if (!p[i].equals(\".\") && !p[i].equals(\"\") && !p[i].equals(\"..\"))\\n                stack.push(p[i]);\\n        }\\n        List<String> list = new ArrayList(stack);\\n        return \"/\"+String.join(\"/\", list);\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (int i = 0; i < p.length; i++) {\\n            if (!stack.empty() && p[i].equals(\"..\"))\\n                stack.pop();\\n            else if (!p[i].equals(\".\") && !p[i].equals(\"\") && !p[i].equals(\"..\"))\\n                stack.push(p[i]);\\n        }\\n        List<String> list = new ArrayList(stack);\\n        return \"/\"+String.join(\"/\", list);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3407361,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires to convert a given absolute path to a simplified canonical path. The simplified canonical path should have the following format:\\n- The path starts with a single slash \\'/\\'.\\n\\n- Any two directories are separated by a single slash \\'/\\'.\\n\\n- The path does not end with a trailing \\'/\\'.\\n\\n- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period \\'.\\' or double period \\'..\\').\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem can be solved using a stack to keep track of the directories in the path. We split the input path by slash \\'/\\', iterate over the directories, and perform the following operations:\\n\\n- Ignore the current directory \\'.\\' and empty directories.\\n- Go one level up for double period \\'..\\' by popping the top element from the stack if it is not empty.\\n- For any other directory, push it to the stack.\\n- Finally, we join the directories in the stack with slash \\'/\\' and add a slash at the beginning to form the simplified canonical path.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the algorithm is $$O(n)$$, where n is the length of the input path. This is because we iterate over each directory in the path only once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity of the algorithm is $$O(n)$$ where n is the length of\\n\\n \\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>(); // create a stack to keep track of directories\\n        String[] directories = path.split(\"/\"); // split the path by slash \\'/\\'\\n        for (String dir : directories) { // iterate over the directories\\n            if (dir.equals(\".\") || dir.isEmpty()) { // ignore the current directory \\'.\\' and empty directories\\n                continue;\\n            } else if (dir.equals(\"..\")) { // go one level up for double period \\'..\\'\\n                if (!stack.isEmpty()) { // if stack is not empty, pop the top element\\n                    stack.pop();\\n                }\\n            } else { // for any other directory, push it to the stack\\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); // join the directories in the stack with slash \\'/\\' and add a slash at the beginning\\n    }\\n}\\n```\\n```JavaScript []\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const stack = [];\\n    const directories = path.split(\"/\");\\n    for (const dir of directories) {\\n        if (dir === \".\" || !dir) {\\n            continue;\\n        } else if (dir === \"..\") {\\n            if (stack.length > 0) {\\n                stack.pop();\\n            }\\n        } else {\\n            stack.push(dir);\\n        }\\n    }\\n    return \"/\" + stack.join(\"/\");\\n};\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (dir.empty() || dir == \".\") {\\n                continue;\\n            } else if (dir == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(dir);\\n            }\\n        }\\n        string res;\\n        while (!s.empty()) {\\n            res = \"/\" + s.top() + res;\\n            s.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>(); // create a stack to keep track of directories\\n        String[] directories = path.split(\"/\"); // split the path by slash \\'/\\'\\n        for (String dir : directories) { // iterate over the directories\\n            if (dir.equals(\".\") || dir.isEmpty()) { // ignore the current directory \\'.\\' and empty directories\\n                continue;\\n            } else if (dir.equals(\"..\")) { // go one level up for double period \\'..\\'\\n                if (!stack.isEmpty()) { // if stack is not empty, pop the top element\\n                    stack.pop();\\n                }\\n            } else { // for any other directory, push it to the stack\\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); // join the directories in the stack with slash \\'/\\' and add a slash at the beginning\\n    }\\n}\\n```\n```JavaScript []\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const stack = [];\\n    const directories = path.split(\"/\");\\n    for (const dir of directories) {\\n        if (dir === \".\" || !dir) {\\n            continue;\\n        } else if (dir === \"..\") {\\n            if (stack.length > 0) {\\n                stack.pop();\\n            }\\n        } else {\\n            stack.push(dir);\\n        }\\n    }\\n    return \"/\" + stack.join(\"/\");\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (dir.empty() || dir == \".\") {\\n                continue;\\n            } else if (dir == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(dir);\\n            }\\n        }\\n        string res;\\n        while (!s.empty()) {\\n            res = \"/\" + s.top() + res;\\n            s.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406788,
                "title": "image-explanation-simple-easy-concise-stack-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Simplify Path` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/0dcce590-ae89-40a6-81b8-727f896098a7_1681264846.7869709.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/6c0be3d7-dea4-44ec-a4a8-2dccaaa8620b_1681261958.6440732.png)\\n![image.png](https://assets.leetcode.com/users/images/02bb1515-d70c-42dc-973a-fc331bd0a580_1681261967.111279.png)\\n![image.png](https://assets.leetcode.com/users/images/d3e91201-18f5-4795-8b3a-867b24b72210_1681261976.8542857.png)\\n![image.png](https://assets.leetcode.com/users/images/323ca517-6e1b-4add-bc63-31eef7febcf1_1681261985.6800873.png)\\n![image.png](https://assets.leetcode.com/users/images/33c5dffa-174b-448b-a205-cdce9b775339_1681261994.3601491.png)\\n![image.png](https://assets.leetcode.com/users/images/18a44cdd-62af-447a-a754-13d4e7ec1d6a_1681262007.9926193.png)\\n![image.png](https://assets.leetcode.com/users/images/f39db0ae-1a00-4d22-a9e9-434dd10ee4df_1681262020.5986128.png)\\n![image.png](https://assets.leetcode.com/users/images/a1639cf9-ff51-4139-a191-29b7b8f18834_1681262026.56356.png)\\n![image.png](https://assets.leetcode.com/users/images/8016c9ad-edc6-48ae-ae80-2ebfbdd28597_1681262033.6350305.png)\\n![image.png](https://assets.leetcode.com/users/images/e74fbc13-897d-4397-b6ae-90fdc991544a_1681262039.6172855.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dirOrFiles;\\n        stringstream ss(path);\\n        string dirOrFile;\\n        while (getline(ss, dirOrFile, \\'/\\')) {\\n            if (!dirOrFiles.empty() && dirOrFile == \"..\") {\\n                dirOrFiles.pop_back();\\n            } else if (dirOrFile != \".\" && dirOrFile != \"\" && dirOrFile != \"..\") {\\n                dirOrFiles.push_back(dirOrFile);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dirOrFile : dirOrFiles) {\\n            simplified_path += \"/\" + dirOrFile;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dirOrFiles = new ArrayDeque<>();\\n        for (String dirOrFile : path.split(\"/\")) {\\n            if (!dirOrFiles.isEmpty() && dirOrFile.equals(\"..\")) {\\n                dirOrFiles.removeLast();\\n            } else if (!dirOrFile.equals(\".\") && !dirOrFile.equals(\"\") && !dirOrFile.equals(\"..\")) {\\n                dirOrFiles.addLast(dirOrFile);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dirOrFile : dirOrFiles) {\\n            simplified_path.append(\"/\").append(dirOrFile);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dirOrFiles = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dirOrFiles and elem == \"..\":\\n                dirOrFiles.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dirOrFiles.append(elem)\\n                \\n        return \"/\" + \"/\".join(dirOrFiles)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dirOrFiles;\\n        stringstream ss(path);\\n        string dirOrFile;\\n        while (getline(ss, dirOrFile, \\'/\\')) {\\n            if (!dirOrFiles.empty() && dirOrFile == \"..\") {\\n                dirOrFiles.pop_back();\\n            } else if (dirOrFile != \".\" && dirOrFile != \"\" && dirOrFile != \"..\") {\\n                dirOrFiles.push_back(dirOrFile);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dirOrFile : dirOrFiles) {\\n            simplified_path += \"/\" + dirOrFile;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dirOrFiles = new ArrayDeque<>();\\n        for (String dirOrFile : path.split(\"/\")) {\\n            if (!dirOrFiles.isEmpty() && dirOrFile.equals(\"..\")) {\\n                dirOrFiles.removeLast();\\n            } else if (!dirOrFile.equals(\".\") && !dirOrFile.equals(\"\") && !dirOrFile.equals(\"..\")) {\\n                dirOrFiles.addLast(dirOrFile);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dirOrFile : dirOrFiles) {\\n            simplified_path.append(\"/\").append(dirOrFile);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dirOrFiles = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dirOrFiles and elem == \"..\":\\n                dirOrFiles.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dirOrFiles.append(elem)\\n                \\n        return \"/\" + \"/\".join(dirOrFiles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050620,
                "title": "c-stack-o-n-0ms-beats-100-easy-explanation",
                "content": "**EXPLANATION** (Idea is pretty simple)\\n- First make sure the given *path* **starts and ends** with ```\\'/\\'``` if **not** so then **append** a ```\\'/\\'``` at the end of *path*.\\n- Create a **stack of string**.\\n- Initialize **ans** string to ```\"\"``` and start iterating the *path* string from **\\'1\\' index as path[0] will always be ```\\'/\\'```**.\\n- Create a **temp** variable which will keep **substrings** upto ```\\'/\\'```, after that it will be checked with some conditions and then reset it back to ```\"\"```. \\n- In each iteration check whether **```path[i] == \\'/\\'```**, if **true** then check our **temp string** on the basis of below conditions (according to question ) :\\n\\t- If ```temp==\"\" || temp==\".\"``` then **ignore.**\\n\\t- If ```temp==\"..\"``` then **pop the top element from stack if it exists**.\\n\\t- If ```non of above matches``` then **push temp to stack**. \\nAfter checking the above conditions, **reset temp to ```\"\"```**\\n- Finally, after the above loop ends, **pop all the elements of the stack and store it in ans** with a ```\\'/\\'``` in front, shown as follows : ```ans=\"/\"+s.top()+ans```.\\n - Return **ans**\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int n=path.length();\\n        stack<string>s;\\n                \\n        if(path[n-1]!=\\'/\\') // so that initially path always ends with \\'/\\'\\n            path+=\"/\", ++n;\\n            \\n        int i=1; // since path always starts from \\'/\\'\\n        string ans=\"\";\\n        string temp=\"\";\\n        while(i<n){\\n            \\n            if(path[i]==\\'/\\'){ // check only if we encounter \\'/\\'\\n                \\n                if(temp==\"\" || temp==\".\"){\\n                    // ignore\\n                }\\n                else if(temp==\"..\"){\\n                    if(!s.empty()) s.pop(); // pop the top element from stack if exists\\n                }\\n                else{\\n                    s.push(temp); //push the directory or file name to stack\\n                }\\n                \\n                temp=\"\"; // reset temp\\n            }\\n            else{\\n                temp.push_back(path[i]); // else append to temp\\n            }\\n            \\n            ++i; // increment index\\n        }\\n        \\n        while(!s.empty()){ // add all the stack elements\\n            ans=\"/\"+s.top()+ans;\\n            s.pop();\\n        }\\n        \\n        if(ans.length()==0) // if no directory or file is present\\n            ans=\"/\"; // minimum root directory must be present in ans\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**NOTE**\\nBecause of ```ans=\"/\"+s.top()+ans``` , the time complexity will be **O(n^2)**, but it can be further optimized to **O(n) amotized time-complexity** by reversing the stack using another stack and then then appending it to the end of the same memory of the *ans* string, ```ans+=reversed_stack.top()+\"/\"``` as shown below :\\n```\\nans=\"/\";\\n\\nstack<string>reversed_stack;\\n\\nif(s.empty()){\\n    return ans;\\n}\\n\\nwhile(!s.empty()){ // reverse the stack elements\\n    reversed_stack.push(s.top());\\n    s.pop();\\n}\\n\\nwhile(!reversed_stack.empty()){\\n    ans+=reversed_stack.top()+\"/\";\\n    reversed_stack.pop();\\n}\\n\\nreturn ans.substr(0,ans.length()-1);\\n```\\n\\n\\n**TIME COMPLEXITY**\\nO(n) [ Because of the iterating the path string once ]\\n\\n**SPACE COMPLEXITY**\\nO(n+n) [ Because of the above two stacks ]",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\'/\\'```\n```\\'/\\'```\n```\"\"```\n```\\'/\\'```\n```\\'/\\'```\n```\"\"```\n```path[i] == \\'/\\'```\n```temp==\"\" || temp==\".\"```\n```temp==\"..\"```\n```non of above matches```\n```\"\"```\n```\\'/\\'```\n```ans=\"/\"+s.top()+ans```\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int n=path.length();\\n        stack<string>s;\\n                \\n        if(path[n-1]!=\\'/\\') // so that initially path always ends with \\'/\\'\\n            path+=\"/\", ++n;\\n            \\n        int i=1; // since path always starts from \\'/\\'\\n        string ans=\"\";\\n        string temp=\"\";\\n        while(i<n){\\n            \\n            if(path[i]==\\'/\\'){ // check only if we encounter \\'/\\'\\n                \\n                if(temp==\"\" || temp==\".\"){\\n                    // ignore\\n                }\\n                else if(temp==\"..\"){\\n                    if(!s.empty()) s.pop(); // pop the top element from stack if exists\\n                }\\n                else{\\n                    s.push(temp); //push the directory or file name to stack\\n                }\\n                \\n                temp=\"\"; // reset temp\\n            }\\n            else{\\n                temp.push_back(path[i]); // else append to temp\\n            }\\n            \\n            ++i; // increment index\\n        }\\n        \\n        while(!s.empty()){ // add all the stack elements\\n            ans=\"/\"+s.top()+ans;\\n            s.pop();\\n        }\\n        \\n        if(ans.length()==0) // if no directory or file is present\\n            ans=\"/\"; // minimum root directory must be present in ans\\n        \\n        return ans;\\n    }\\n};\\n```\n```ans=\"/\"+s.top()+ans```\n```ans+=reversed_stack.top()+\"/\"```\n```\\nans=\"/\";\\n\\nstack<string>reversed_stack;\\n\\nif(s.empty()){\\n    return ans;\\n}\\n\\nwhile(!s.empty()){ // reverse the stack elements\\n    reversed_stack.push(s.top());\\n    s.pop();\\n}\\n\\nwhile(!reversed_stack.empty()){\\n    ans+=reversed_stack.top()+\"/\";\\n    reversed_stack.pop();\\n}\\n\\nreturn ans.substr(0,ans.length()-1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25779,
                "title": "9-line-python-solution-easy-to-understand",
                "content": "    def simplifyPath(self, path):\\n        stack = []\\n        for token in path.split('/'):\\n            if token in ('', '.'):\\n                pass\\n            elif token == '..':\\n                if stack: stack.pop()\\n            else:\\n                stack.append(token)\\n        return '/' + '/'.join(stack)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    def simplifyPath(self, path):\\n        stack = []\\n        for token in path.split('/'):\\n            if token in ('', '.'):\\n                pass\\n            elif token == '..':\\n                if stack: stack.pop()\\n            else:\\n                stack.append(token)\\n        return '/' + '/'.join(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 3406682,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 10,000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\n# Video Solution\\n\\n**Search \\uD83D\\uDC49 `Simplify Path by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (14).png](https://assets.leetcode.com/users/images/a5f0dbb8-6a74-403e-b875-e24a2ba32966_1681263193.499577.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\n- Initialize an empty stack to hold the directories in the simplified path.\\n- Split the input path string into individual directories using the forward slash (\"/\") as a separator.\\nFor each directory:\\n- If the directory is a parent directory reference (\"..\") and the stack is non-empty, pop the last directory off the stack to remove the preceding directory.\\n- If the directory is not a special directory reference (i.e. neither \".\", \"\" nor \"..\"), append it to the stack.\\n- Construct the simplified path by joining the directories in the stack with forward slashes (\"/\") and adding a leading forward slash (\"/\").\\n\\n\\n# Intuition:\\nThe problem asks us to simplify a path in the Unix-style directory format, which consists of a sequence of directory names separated by forward slashes. The path may contain special directory references, such as \".\" (current directory), \"\" (empty directory), and \"..\" (parent directory). We need to remove any redundant directories and parent directory references to simplify the path.\\n\\nTo solve the problem, we can use a stack to keep track of the directories in the simplified path. We iterate over each directory in the input path and perform the following actions:\\n\\n- If the directory is a parent directory reference (\"..\") and the stack is non-empty, we pop the last directory off the stack to remove the preceding directory.\\n- If the directory is not a special directory reference, we append it to the stack.\\n- We then construct the simplified path by joining the directories in the stack with forward slashes and adding a leading forward slash.\\n- Using a stack allows us to keep track of the directories in the path in a last-in-first-out (LIFO) order, which is convenient for removing parent directory references. By only appending non-special directories to the stack, we can ensure that the simplified path does not contain any redundant directories or empty directory references. - Finally, joining the directories in the stack with forward slashes gives us the simplified path in the correct format.\\n\\n\\n```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dir_stack = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dir_stack and elem == \"..\":\\n                dir_stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dir_stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(dir_stack)\\n\\n```\\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dir_stack = new ArrayDeque<>();\\n        for (String dir : path.split(\"/\")) {\\n            if (!dir_stack.isEmpty() && dir.equals(\"..\")) {\\n                dir_stack.removeLast();\\n            } else if (!dir.equals(\".\") && !dir.equals(\"\") && !dir.equals(\"..\")) {\\n                dir_stack.addLast(dir);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dir : dir_stack) {\\n            simplified_path.append(\"/\").append(dir);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dir_stack;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (!dir_stack.empty() && dir == \"..\") {\\n                dir_stack.pop_back();\\n            } else if (dir != \".\" && dir != \"\" && dir != \"..\") {\\n                dir_stack.push_back(dir);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dir : dir_stack) {\\n            simplified_path += \"/\" + dir;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dir_stack = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dir_stack and elem == \"..\":\\n                dir_stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dir_stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(dir_stack)\\n\\n```\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dir_stack = new ArrayDeque<>();\\n        for (String dir : path.split(\"/\")) {\\n            if (!dir_stack.isEmpty() && dir.equals(\"..\")) {\\n                dir_stack.removeLast();\\n            } else if (!dir.equals(\".\") && !dir.equals(\"\") && !dir.equals(\"..\")) {\\n                dir_stack.addLast(dir);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dir : dir_stack) {\\n            simplified_path.append(\"/\").append(dir);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dir_stack;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (!dir_stack.empty() && dir == \"..\") {\\n                dir_stack.pop_back();\\n            } else if (dir != \".\" && dir != \"\" && dir != \"..\") {\\n                dir_stack.push_back(dir);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dir : dir_stack) {\\n            simplified_path += \"/\" + dir;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25687,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string res, s;\\n        stack<string>stk;\\n        stringstream ss(path);\\n        while(getline(ss, s, '/')) {\\n            if (s == \"\" || s == \".\") continue;\\n            if (s == \"..\" && !stk.empty()) stk.pop();\\n            else if (s != \"..\") stk.push(s);\\n        }\\n        while(!stk.empty()){\\n            res = \"/\"+ stk.top() + res;\\n            stk.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string res, s;\\n        stack<string>stk;\\n        stringstream ss(path);\\n        while(getline(ss, s, '/')) {\\n            if (s == \"\" || s == \".\") continue;\\n            if (s == \"..\" && !stk.empty()) stk.pop();\\n            else if (s != \"..\") stk.push(s);\\n        }\\n        while(!stk.empty()){\\n            res = \"/\"+ stk.top() + res;\\n            stk.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050697,
                "title": "c-simple-and-easy-solution-faster-than-94",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> stack;\\n        string res, temp;\\n        stringstream p(path);\\n        \\n        while (getline(p, temp, \\'/\\')) {\\n            if (temp == \"\" or temp == \".\") continue;\\n            if (!stack.empty() && temp == \"..\")\\n                stack.pop_back();\\n            else if (temp != \"..\")\\n                stack.push_back(temp);\\n        }\\n        \\n        for (auto s : stack)\\n            res += \"/\" + s;\\n        \\n        return stack.empty() ? \"/\" : res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> stack;\\n        string res, temp;\\n        stringstream p(path);\\n        \\n        while (getline(p, temp, \\'/\\')) {\\n            if (temp == \"\" or temp == \".\") continue;\\n            if (!stack.empty() && temp == \"..\")\\n                stack.pop_back();\\n            else if (temp != \"..\")\\n                stack.push_back(temp);\\n        }\\n        \\n        for (auto s : stack)\\n            res += \"/\" + s;\\n        \\n        return stack.empty() ? \"/\" : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500734,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Split commands with `/`\\n2. Use a stack to apply commands\\n``` javascript\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = [];\\n    path = path.split(\\'/\\');\\n    \\n    for (let i=0;i<path.length;i++) {\\n        if (path[i]==\\'.\\' || path[i]==\\'\\') continue;\\n        if (path[i]==\\'..\\') stack.pop();\\n        else stack.push(path[i]);\\n    }\\n    \\n    return \\'/\\'+stack.join(\\'/\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = [];\\n    path = path.split(\\'/\\');\\n    \\n    for (let i=0;i<path.length;i++) {\\n        if (path[i]==\\'.\\' || path[i]==\\'\\') continue;\\n        if (path[i]==\\'..\\') stack.pop();\\n        else stack.push(path[i]);\\n    }\\n    \\n    return \\'/\\'+stack.join(\\'/\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25773,
                "title": "my-o-n-ac-code-just-need-to-handle-two-special-cases",
                "content": " 1. traverse the string to record each folder name.\\n 2. two special cases:\\n\\na.double dot:pop one.\\n  \\nb.single dot: do nothing (don`t push it).\\n\\n\\n\\n\\n    string simplifyPath(string path) {\\n    \\tvector<string>   nameVect;\\n    \\tstring name;\\n    \\t\\n    \\tpath.push_back('/');\\n    \\tfor(int i=0;i<path.size();i++){\\n    \\t\\tif(path[i]=='/'){\\n    \\t\\t\\tif(name.size()==0)continue;\\n    \\t\\t\\tif(name==\"..\"){\\t\\t//special case 1\\uff1adouble dot\\uff0cpop dir\\n    \\t\\t\\t     if(nameVect.size()>0)nameVect.pop_back();\\n    \\t\\t\\t}else if(name==\".\"){//special case 2:singel dot\\uff0cdon`t push\\n    \\t\\t\\t}else{\\t\\t\\t\\n    \\t\\t\\t\\tnameVect.push_back(name);\\n    \\t\\t\\t}\\n    \\t\\t\\tname.clear();\\n    \\t\\t}else{\\n    \\t\\t\\tname.push_back(path[i]);//record the name\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tstring result;\\n    \\tif(nameVect.empty())return \"/\";\\n    \\tfor(int i=0;i<nameVect.size();i++){\\n    \\t\\tresult.append(\"/\"+nameVect[i]);\\n    \\t}\\n    \\treturn result;\\n    }",
                "solutionTags": [],
                "code": " 1. traverse the string to record each folder name.\\n 2. two special cases:\\n\\na.double dot:pop one.\\n  \\nb.single dot: do nothing (don`t push it).\\n\\n\\n\\n\\n    string simplifyPath(string path) {\\n    \\tvector<string>   nameVect;\\n    \\tstring name;\\n    \\t\\n    \\tpath.push_back('/');\\n    \\tfor(int i=0;i<path.size();i++){\\n    \\t\\tif(path[i]=='/'){\\n    \\t\\t\\tif(name.size()==0)continue;\\n    \\t\\t\\tif(name==\"..\"){\\t\\t//special case 1\\uff1adouble dot\\uff0cpop dir\\n    \\t\\t\\t     if(nameVect.size()>0)nameVect.pop_back();\\n    \\t\\t\\t}else if(name==\".\"){//special case 2:singel dot\\uff0cdon`t push\\n    \\t\\t\\t}else{\\t\\t\\t\\n    \\t\\t\\t\\tnameVect.push_back(name);\\n    \\t\\t\\t}\\n    \\t\\t\\tname.clear();\\n    \\t\\t}else{\\n    \\t\\t\\tname.push_back(path[i]);//record the name\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tstring result;\\n    \\tif(nameVect.empty())return \"/\";\\n    \\tfor(int i=0;i<nameVect.size();i++){\\n    \\t\\tresult.append(\"/\"+nameVect[i]);\\n    \\t}\\n    \\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3406777,
                "title": "c-java-python-beginner-friendly-explanation-multiple-testcase-using-stack",
                "content": "# Approach\\n1. Create a Stack of String with following condition.\\n2. Iterate the loop till you doesn\\'t reaches the end of string.\\n3. If you encounter a \"/\" then ignore it.\\n4. Create a temp String & Iterate the while loop till you doesn\\'t find \"/\" and append it to temp.\\n4. Now check if temp == \".\" , then ignore it.\\n5. If temp == \"..\" then pop the element from the stack if it exists.\\n6. If no of the above 2 matches push temp to stack as you find a valid path.\\n7. Check out temp string on basis of above conditions till you doesn\\'t find \"/\".\\n8. Now add all stack elements to result as res = \"/\" + st.top() + res\\n9. If res.size() is 0 then return \"/\" if no directory or file is present.\\nAt last return res.\\n```\\n**See This Testcase for better understanding **\\ninput : \"/home/../foo/\"             output : \"/foo\"\\ninput : \"/home/test/../foo/\"        output : \"/home/foo\"\\ninput : \"/home/...//foo/\"           output : \"/home/.../foo\"\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$\\n\\n```C++ []\\nclass Solution {\\npublic:\\nclass Solution\\n{\\npublic:\\n    string simplifyPath(string path)\\n    {\\n\\n        stack<string> st;\\n        string res;\\n\\n        for (int i = 0; i < path.size(); ++i)\\n        {\\n            if (path[i] == \\'/\\')\\n                continue;\\n            string temp;\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if (temp == \".\")\\n                continue;\\n            else if (temp == \"..\")\\n            {\\n                if (!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(temp);\\n        }\\n\\n        while (!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n\\n        if (res.size() == 0)\\n            return \"/\";\\n\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution\\n{\\npublic\\n    String simplifyPath(String path)\\n    {\\n        Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories)\\n        { \\n            if (dir.equals(\".\") || dir.isEmpty())\\n            { \\n                continue;\\n            }\\n            else if (dir.equals(\"..\"))\\n            { \\n                if (!stack.isEmpty())\\n                { \\n                    stack.pop();\\n                }\\n            }\\n            else\\n            { \\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); \\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n```\\n![Screenshot 2023-04-12 at 11.31.36 AM.png](https://assets.leetcode.com/users/images/69e6623a-6d9d-43dd-8618-c170cb4d1a33_1681279337.5105672.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Stack"
                ],
                "code": "```\\n**See This Testcase for better understanding **\\ninput : \"/home/../foo/\"             output : \"/foo\"\\ninput : \"/home/test/../foo/\"        output : \"/home/foo\"\\ninput : \"/home/...//foo/\"           output : \"/home/.../foo\"\\n```\n```C++ []\\nclass Solution {\\npublic:\\nclass Solution\\n{\\npublic:\\n    string simplifyPath(string path)\\n    {\\n\\n        stack<string> st;\\n        string res;\\n\\n        for (int i = 0; i < path.size(); ++i)\\n        {\\n            if (path[i] == \\'/\\')\\n                continue;\\n            string temp;\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if (temp == \".\")\\n                continue;\\n            else if (temp == \"..\")\\n            {\\n                if (!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(temp);\\n        }\\n\\n        while (!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n\\n        if (res.size() == 0)\\n            return \"/\";\\n\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution\\n{\\npublic\\n    String simplifyPath(String path)\\n    {\\n        Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories)\\n        { \\n            if (dir.equals(\".\") || dir.isEmpty())\\n            { \\n                continue;\\n            }\\n            else if (dir.equals(\"..\"))\\n            { \\n                if (!stack.isEmpty())\\n                { \\n                    stack.pop();\\n                }\\n            }\\n            else\\n            { \\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); \\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493083,
                "title": "java-tc-o-n-sc-o-n-using-stack-stringbuilder",
                "content": "```\\n/**\\n * Time Complexity: O(N)\\n * 1. O(N) - Each character will be traversed once.\\n * 2. O(N) - Each character will be added to StringBuilder.\\n * 3. O(N) - sb.toString()\\n *\\n * Space Complexity: O(N)\\n * 1. StringBuilder can take upto N characters.\\n * 2. Stack will store an integer for each valid directory. (This is also bounded by O(N))\\n *\\n * N = Length of input path.\\n */\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        if (path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        // Stack is used to store the length of StringBuilder until previous directory.\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n        int len = path.length();\\n\\n        while (i < len) {\\n            if (path.charAt(i) == \\'/\\') {\\n                i++;\\n                continue;\\n            }\\n\\n            StringBuilder dir = new StringBuilder();\\n            while (i < len && path.charAt(i) != \\'/\\') {\\n                dir.append(path.charAt(i));\\n                i++;\\n            }\\n\\n            String dirName = dir.toString();\\n            switch (dirName) {\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if (!stack.isEmpty()) {\\n                        sb.setLength(stack.pop());\\n                    }\\n                    break;\\n                default:\\n                    stack.push(sb.length());\\n                    sb.append(\\'/\\').append(dirName);\\n            }\\n        }\\n\\n        return sb.length() != 0 ? sb.toString() : \"/\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(N)\\n * 1. O(N) - Each character will be traversed once.\\n * 2. O(N) - Each character will be added to StringBuilder.\\n * 3. O(N) - sb.toString()\\n *\\n * Space Complexity: O(N)\\n * 1. StringBuilder can take upto N characters.\\n * 2. Stack will store an integer for each valid directory. (This is also bounded by O(N))\\n *\\n * N = Length of input path.\\n */\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        if (path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        // Stack is used to store the length of StringBuilder until previous directory.\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n        int len = path.length();\\n\\n        while (i < len) {\\n            if (path.charAt(i) == \\'/\\') {\\n                i++;\\n                continue;\\n            }\\n\\n            StringBuilder dir = new StringBuilder();\\n            while (i < len && path.charAt(i) != \\'/\\') {\\n                dir.append(path.charAt(i));\\n                i++;\\n            }\\n\\n            String dirName = dir.toString();\\n            switch (dirName) {\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if (!stack.isEmpty()) {\\n                        sb.setLength(stack.pop());\\n                    }\\n                    break;\\n                default:\\n                    stack.push(sb.length());\\n                    sb.append(\\'/\\').append(dirName);\\n            }\\n        }\\n\\n        return sb.length() != 0 ? sb.toString() : \"/\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25704,
                "title": "share-my-8ms-java-solution",
                "content": "\\tpublic String simplifyPath(String path) {\\n\\t\\tString[] dir = path.split(\"/\");\\n\\t\\tString[] stack = new String[dir.length];\\n\\t\\tint ptr = 0;\\n\\t\\tfor(int i = 0; i < dir.length; i++){\\n\\t\\t\\tif(dir[i].equals(\".\") || dir[i].equals(\"\")){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}else if(dir[i].equals(\"..\")){\\n\\t\\t\\t\\tif(ptr > 0) ptr--;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack[ptr] = dir[i];\\n\\t\\t\\t\\tptr++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tStringBuilder result = new StringBuilder();\\n\\t\\tfor(int i = 0; i < ptr; i++){\\n\\t\\t\\tresult.append(\"/\");\\n\\t\\t\\tresult.append(stack[i]);\\n\\t\\t}\\n\\t\\treturn result.length() == 0 ? \"/\" : result.toString();\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic String simplifyPath(String path) {\\n\\t\\tString[] dir = path.split(\"/\");\\n\\t\\tString[] stack = new String[dir.length];\\n\\t\\tint ptr = 0;\\n\\t\\tfor(int i = 0; i < dir.length; i++){\\n\\t\\t\\tif(dir[i].equals(\".\") || dir[i].equals(\"\")){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}else if(dir[i].equals(\"..\")){\\n\\t\\t\\t\\tif(ptr > 0) ptr--;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack[ptr] = dir[i];\\n\\t\\t\\t\\tptr++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tStringBuilder result = new StringBuilder();\\n\\t\\tfor(int i = 0; i < ptr; i++){\\n\\t\\t\\tresult.append(\"/\");\\n\\t\\t\\tresult.append(stack[i]);\\n\\t\\t}\\n\\t\\treturn result.length() == 0 ? \"/\" : result.toString();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3407155,
                "title": "java-explained-with-example-beginner-friendly-stack",
                "content": "# Intuition\\nSince our operations of moving ahead or moving down a directory depend on the current string we see, so data structure that comes to mind is Stack\\n\\nIf you have used linux based system you must be already aware of these\\n- /abc/  --> means get into the folder /abc/\\n- /./  --> \".\" indicates current directory, that is stay where you are\\n- /../ --> \"..\" means step down a directory where you are, equivalent to a back in windows.\\n\\n- Now Lets understand by an **Example**\\n**Input**: \"/a/./b/../../c/\"\\n**Output**: /c\\nWe always start with home directory\\nAfter spilting Array [\"a\", \".\", \"b\", \"..\", \"..\", \"c]\\n\"a\" --> move to /a\\n\".\" --> stay in current directory still in /a\\n\"b\" --> move to directory b i.e /a/b\\n\"..\" --> move back i.e is /a again\\n\"..\" --> move back i.e back to home directory /\\n\"c\" --> move to c directory i.e /c\\nAnswer is /c\\n---\\n\\n# Approach\\n1) Split the input string on basis of \\'/\\'\\nThis will separate all input will also resolve are double \\'//\\' cases(leading to \"\" empty string).\\n2) Now that we got a \\'/\\' speparated string array\\n3) We define a skip set (\"..\", \".\", \"\")\\n- if we encouter \".\" means stay in the current directory\\n- \"\" is a result of // being separated, so skip that\\nI mainted a skip set to write clean code\\n\\n```\\nif(!dir.equals(\"..\") || !dir.equals(\".\") || !dir.equals(\"\"))\\n//instead did this\\nif(!skip.contains(dir))\\n```\\n4) Now we start iterating over array. \\n- If we encouter \"..\" and stack is non empty than we need to pop-out or move backwards\\n- If we encounter anything other than these (\"..\", \".\", \"\") we add to stack\\n5) At end, form a Stringbuilder out of the stack.\\n### Why StringBuilder and not String is being used. [See this](https://leetcode.com/problems/removing-stars-from-a-string/solutions/3402865/java-explained-why-use-stringbuilder-than-string-beginner-friendly/)\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) : Since we are going through all the elements of the string once.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n   public String simplifyPath(String path) {\\n    Stack<String> stack = new Stack<>();\\n    Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n    for (String dir : path.split(\"/\")) {\\n        if (dir.equals(\"..\") && !stack.isEmpty())\\n         stack.pop();\\n        else if (!skip.contains(dir))\\n         stack.push(dir);\\n    }\\n    StringBuilder res = new StringBuilder();\\n    while(!stack.isEmpty()){\\n            res.insert(0,stack.pop()).insert(0,\"/\");\\n        }\\n    return res.isEmpty() ? \"/\" : res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nif(!dir.equals(\"..\") || !dir.equals(\".\") || !dir.equals(\"\"))\\n//instead did this\\nif(!skip.contains(dir))\\n```\n```\\nclass Solution {\\n   public String simplifyPath(String path) {\\n    Stack<String> stack = new Stack<>();\\n    Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n    for (String dir : path.split(\"/\")) {\\n        if (dir.equals(\"..\") && !stack.isEmpty())\\n         stack.pop();\\n        else if (!skip.contains(dir))\\n         stack.push(dir);\\n    }\\n    StringBuilder res = new StringBuilder();\\n    while(!stack.isEmpty()){\\n            res.insert(0,stack.pop()).insert(0,\"/\");\\n        }\\n    return res.isEmpty() ? \"/\" : res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847338,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Python**\\n```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        for p in path.split(\"/\"):\\n            if p == \\'..\\' and len(stack) > 0:\\n                stack.pop()\\n            if p == \\'\\' or p == \\'.\\' or p ==\\'..\\':\\n                continue\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\\n**JavaScript**\\n```\\nvar simplifyPath = function(path) {\\n    path = path.split(\\'/\\');\\n    let stack = [];\\n    for(let p of path){\\n        if(p == \\'.\\' || p == \\'\\') continue;\\n        else if(p == \\'..\\')   stack.pop();\\n        else stack.push(p);\\n    }\\n    return \\'/\\' + stack.join(\\'/\\');\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !stack.isEmpty())    stack.pop();\\n            else if(!skip.contains(dir)) stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        for p in path.split(\"/\"):\\n            if p == \\'..\\' and len(stack) > 0:\\n                stack.pop()\\n            if p == \\'\\' or p == \\'.\\' or p ==\\'..\\':\\n                continue\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\n```\\nvar simplifyPath = function(path) {\\n    path = path.split(\\'/\\');\\n    let stack = [];\\n    for(let p of path){\\n        if(p == \\'.\\' || p == \\'\\') continue;\\n        else if(p == \\'..\\')   stack.pop();\\n        else stack.push(p);\\n    }\\n    return \\'/\\' + stack.join(\\'/\\');\\n};\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !stack.isEmpty())    stack.pop();\\n            else if(!skip.contains(dir)) stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739219,
                "title": "easy-c-solution-using-stl-with-detailed-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using STL functions.\\n- We took a stack to store all the paths. We\\u2019ll have 3 operations to find all the paths:\\n    - `if(temp == \"\" || temp == \".\") continue;` we\\u2019ll ignore all empty or \\u2018.\\u2019 indexs.\\n    - `if(temp != \"..\" ) s.push(temp);` if it\\u2019s not a \\u2018..\\u2019 means it indicates a path, simply push it to stack.\\n    - `else if(!s.empty()) s.pop();` and finally if it\\u2019s \\u2018..\\u2019 means we have to go previous directory, so pop the last path from stack.\\n- If we find the stack is empty that means we\\u2019re in the root directory, so `return \\u201C/\\u201D`.\\n- Now we\\u2019ll add all the paths with a \\u2018/\\u2019. But for stack the last element will be on top. So we need to reverse the stack.\\n- Here we used a trick & added the top element before the current ans, by this top element of the stack will go end every time.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        string ans, temp;\\n        int n = path.size();\\n        stringstream X(path);\\n        \\n        while(getline(X, temp, \\'/\\')){\\n            if(temp == \"\" || temp == \".\") continue;\\n            if(temp != \"..\" ) s.push(temp);\\n            else if(!s.empty()) s.pop();\\n        }\\n        if(s.empty()) return \"/\";\\n        \\n        while(!s.empty()){\\n            ans = \\'/\\' + s.top() + ans;\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        string ans, temp;\\n        int n = path.size();\\n        stringstream X(path);\\n        \\n        while(getline(X, temp, \\'/\\')){\\n            if(temp == \"\" || temp == \".\") continue;\\n            if(temp != \"..\" ) s.push(temp);\\n            else if(!s.empty()) s.pop();\\n        }\\n        if(s.empty()) return \"/\";\\n        \\n        while(!s.empty()){\\n            ans = \\'/\\' + s.top() + ans;\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25794,
                "title": "python-easy-to-understand-solution-with-stack",
                "content": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        parts = path.split(\"/\")\\n        stack = []\\n        for p in parts:\\n            if p in [\\'\\', \\'.\\']:\\n                continue\\n            elif p == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        parts = path.split(\"/\")\\n        stack = []\\n        for p in parts:\\n            if p in [\\'\\', \\'.\\']:\\n                continue\\n            elif p == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847706,
                "title": "easy-java-solution-without-stack",
                "content": "```\\nclass Solution {\\n\\n    public String simplifyPath(String path) {\\n        String[] x = path.split(\"/\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = x.length - 1, sk = 0; i >= 0; i--) {\\n            if (x[i].equals(\".\") || x[i].length() == 0) continue;\\n            if (x[i].equals(\"..\")) sk++;  // increment skip count \\n            else if (sk > 0) sk--;  // skip it\\n            else sb.insert(0, \"/\" + x[i]);  // skip = 0? then add it.\\n        }\\n        if (sb.length() == 0) sb.append(\"/\");\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public String simplifyPath(String path) {\\n        String[] x = path.split(\"/\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = x.length - 1, sk = 0; i >= 0; i--) {\\n            if (x[i].equals(\".\") || x[i].length() == 0) continue;\\n            if (x[i].equals(\"..\")) sk++;  // increment skip count \\n            else if (sk > 0) sk--;  // skip it\\n            else sb.insert(0, \"/\" + x[i]);  // skip = 0? then add it.\\n        }\\n        if (sb.length() == 0) sb.append(\"/\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050559,
                "title": "java-easy-to-read-easy-to-understand",
                "content": "```\\npublic String simplifyPath(String path) {\\n        String[] dirs = path.split(\"/\");\\n        Deque<String> stack = new ArrayDeque<>();\\n        for(String s: dirs) {\\n            if(s.equals(\"\")) continue;\\n            if(s.equals(\".\")) continue;\\n            if(s.equals(\"..\")) stack.pollLast();\\n            else stack.add(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String simplifyPath(String path) {\\n        String[] dirs = path.split(\"/\");\\n        Deque<String> stack = new ArrayDeque<>();\\n        for(String s: dirs) {\\n            if(s.equals(\"\")) continue;\\n            if(s.equals(\".\")) continue;\\n            if(s.equals(\"..\")) stack.pollLast();\\n            else stack.add(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915724,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of path.\\n    //   - space: O(n), where n is the length of path.\\n\\n    func simplifyPath(_ path: String) -> String {\\n        let paths = path.split(separator: \"/\")\\n        \\n        var stack = [String]()\\n        for path in paths {\\n            guard path != \".\", !path.isEmpty else { continue }\\n            \\n            if path == \"..\" {\\n                if !stack.isEmpty {\\n                    stack.removeLast()\\n                }\\n            } else {\\n                stack.append(String(path))\\n            }\\n        }\\n        \\n        return \"/\\\\(stack.joined(separator: \"/\"))\"\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of path.\\n    //   - space: O(n), where n is the length of path.\\n\\n    func simplifyPath(_ path: String) -> String {\\n        let paths = path.split(separator: \"/\")\\n        \\n        var stack = [String]()\\n        for path in paths {\\n            guard path != \".\", !path.isEmpty else { continue }\\n            \\n            if path == \"..\" {\\n                if !stack.isEmpty {\\n                    stack.removeLast()\\n                }\\n            } else {\\n                stack.append(String(path))\\n            }\\n        }\\n        \\n        return \"/\\\\(stack.joined(separator: \"/\"))\"\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550900,
                "title": "python-3-stack-2-solutions",
                "content": "```\\nclass Solution1:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i<len(path):\\n            while i< len(path) and path[i]==\\'/\\':\\n                i+=1\\n            start = i\\n            while i< len(path) and path[i]!=\\'/\\':\\n                i+=1\\n            strr = path[start:i]\\n            if strr == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            elif strr and strr != \\'.\\' :\\n                    stack.append(strr)\\n        if not stack:\\n            return \\'/\\'\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\\n\\n```\\nclass Solution2:\\n    def simplifyPath(self, path: str) -> str:\\n        strs = path.split(\\'/\\')\\n        res = []\\n        for s in strs:\\n            if s == \\'..\\':\\n                if res:\\n                    res.pop()\\n            elif s.isalpha() or (s and s!=\\'.\\'):\\n                res.append(s)\\n        return \\'/\\' + \\'/\\'.join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution1:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i<len(path):\\n            while i< len(path) and path[i]==\\'/\\':\\n                i+=1\\n            start = i\\n            while i< len(path) and path[i]!=\\'/\\':\\n                i+=1\\n            strr = path[start:i]\\n            if strr == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            elif strr and strr != \\'.\\' :\\n                    stack.append(strr)\\n        if not stack:\\n            return \\'/\\'\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\n```\\nclass Solution2:\\n    def simplifyPath(self, path: str) -> str:\\n        strs = path.split(\\'/\\')\\n        res = []\\n        for s in strs:\\n            if s == \\'..\\':\\n                if res:\\n                    res.pop()\\n            elif s.isalpha() or (s and s!=\\'.\\'):\\n                res.append(s)\\n        return \\'/\\' + \\'/\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25725,
                "title": "accepted-solution-using-deque",
                "content": "I think using Deque is probably the most intuitive way to solve this problem.\\n\\n    /**\\n     * Deque of strings (directories).\\n     * iterate path:\\n     *  if \"/\", continue,\\n     *  if \".\", conitnue,\\n     *  if \"..\", poll last,\\n     *  else, add a new directory\\n     * in the end, build result from deque.\\n     */\\n    public String simplifyPath(String path) {\\n        Deque<String> deque = new LinkedList<String>();\\n        String[] splits = path.split(\"/\");\\n        for (String split : splits) {\\n            // CATCH: must use \"equals()\" instead of \"==\",\\n            // because 'split' is a variable!\\n            // Also, 'split' could be empty string.\\n            if (split.equals(\"\"))\\n                continue;\\n            else if (split.equals(\".\"))\\n                continue;\\n            else if (split.equals(\"..\"))\\n                deque.pollLast();\\n            else\\n                deque.addLast(split);\\n        }\\n        StringBuilder builder = new StringBuilder();\\n        while (!deque.isEmpty()) {\\n            String s = deque.pollFirst();\\n            builder.append(\"/\").append(s);\\n        }\\n        if (builder.length() == 0)\\n            return \"/\";\\n        return builder.toString();\\n    }",
                "solutionTags": [],
                "code": "I think using Deque is probably the most intuitive way to solve this problem.\\n\\n    /**\\n     * Deque of strings (directories).\\n     * iterate path:\\n     *  if \"/\", continue,\\n     *  if \".\", conitnue,\\n     *  if \"..\", poll last,\\n     *  else, add a new directory\\n     * in the end, build result from deque.\\n     */\\n    public String simplifyPath(String path) {\\n        Deque<String> deque = new LinkedList<String>();\\n        String[] splits = path.split(\"/\");\\n        for (String split : splits) {\\n            // CATCH: must use \"equals()\" instead of \"==\",\\n            // because 'split' is a variable!\\n            // Also, 'split' could be empty string.\\n            if (split.equals(\"\"))\\n                continue;\\n            else if (split.equals(\".\"))\\n                continue;\\n            else if (split.equals(\"..\"))\\n                deque.pollLast();\\n            else\\n                deque.addLast(split);\\n        }\\n        StringBuilder builder = new StringBuilder();\\n        while (!deque.isEmpty()) {\\n            String s = deque.pollFirst();\\n            builder.append(\"/\").append(s);\\n        }\\n        if (builder.length() == 0)\\n            return \"/\";\\n        return builder.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1847624,
                "title": "c-easy-to-understand-without-getline-or-split-simple-stack",
                "content": "**71. Simplify Path**\\n##### **APPROACH -**\\n*Use a **stack to store the directories**\\nCreate **curr to store the data between two forward slashes**\\nTraverse through the path maintaining the curr\\nWhenever / is encountered **push or pop the stack based upon curr**\\nFinally get the simplified path from the directories left in the stack*\\n\\n**Note: Initially add / to the end of the given path to ensure that the last curr is always considered**\\n\\n<br/>\\n\\n##### **COMPLEXITY -**\\n* **Time Complexity : O(N)**, where N = length of path\\n* **Space Complexity : O(M)**, where M = number of directories in path\\n\\n<br/>\\n\\n##### **CODE -**\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string curr, simplifiedPath;\\n        stack<string> st;\\n        path.push_back(\\'/\\');\\n        \\n        for(char c : path) {\\n            if(c == \\'/\\') {\\n                if(curr.empty())    continue;\\n                else if(curr == \"..\") {\\n                    if(!st.empty())   st.pop();   // go to previous i.e. parent directory \\n                }\\n                else if(curr != \".\")    st.push(curr);   // add the new directory or file \\n                curr = \"\";\\n            }\\n            else\\n                curr.push_back(c);\\n        }\\n        \\n        while(!st.empty()) {\\n            simplifiedPath = \"/\" + st.top() + simplifiedPath;\\n            st.pop();\\n        }\\n        return simplifiedPath.empty() ? \"/\" : simplifiedPath;\\n    }\\n};\\n```\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string curr, simplifiedPath;\\n        stack<string> st;\\n        path.push_back(\\'/\\');\\n        \\n        for(char c : path) {\\n            if(c == \\'/\\') {\\n                if(curr.empty())    continue;\\n                else if(curr == \"..\") {\\n                    if(!st.empty())   st.pop();   // go to previous i.e. parent directory \\n                }\\n                else if(curr != \".\")    st.push(curr);   // add the new directory or file \\n                curr = \"\";\\n            }\\n            else\\n                curr.push_back(c);\\n        }\\n        \\n        while(!st.empty()) {\\n            simplifiedPath = \"/\" + st.top() + simplifiedPath;\\n            st.pop();\\n        }\\n        return simplifiedPath.empty() ? \"/\" : simplifiedPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407303,
                "title": "c-easy-solution-stack-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;   // Stack is going to store folders\\n        string ans=\"\";  // Answer path\\n        for(int i=0;i<path.length();i++){  // Traversing through string\\n            if(path[i] == \\'/\\'){  // We always going to ignore \\'/\\'\\n                continue;\\n            }\\n            string temp=\"\";  // We are gonna store folder names in temp\\n            while(i<path.length() && path[i] != \\'/\\'){  // To store names we use this while loop\\n                temp += path[i];\\n                i++;\\n            }\\n            if(temp == \".\") continue;  // If we get a single \\'.\\' then there is no need of pushing in stamp\\n            else if(temp == \"..\"){  // This means that we have to go up in path\\n                if(!st.empty()) st.pop();  // To go up we have to pop\\n            }\\n            else{\\n                st.push(temp);  // If we get no . or .. that means we got the name of the folder\\n            }           \\n        } \\n        if(st.empty())  ans = \\'/\\';  // If there is nothing in our stack then we just need to return /;\\n        while(!st.empty()){  // If we have something in stack then we have to give in this order \"/home/xyz/abc\" etc\\n            ans = \\'/\\' + st.top() + ans;  // For that I am using this \\n            st.pop();\\n        }       \\n        return ans;  // Returning the resulting string \\n    }\\n};\\n```\\n\\n`If you are still not able to understand and know hindi, then I\\'ll suggest to search \"CodeFreaks Simplify paths\" on Youtube`  \\n\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/d3f17c86-efa7-4873-bd1f-a2564dceb9e6_1681275250.3060498.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;   // Stack is going to store folders\\n        string ans=\"\";  // Answer path\\n        for(int i=0;i<path.length();i++){  // Traversing through string\\n            if(path[i] == \\'/\\'){  // We always going to ignore \\'/\\'\\n                continue;\\n            }\\n            string temp=\"\";  // We are gonna store folder names in temp\\n            while(i<path.length() && path[i] != \\'/\\'){  // To store names we use this while loop\\n                temp += path[i];\\n                i++;\\n            }\\n            if(temp == \".\") continue;  // If we get a single \\'.\\' then there is no need of pushing in stamp\\n            else if(temp == \"..\"){  // This means that we have to go up in path\\n                if(!st.empty()) st.pop();  // To go up we have to pop\\n            }\\n            else{\\n                st.push(temp);  // If we get no . or .. that means we got the name of the folder\\n            }           \\n        } \\n        if(st.empty())  ans = \\'/\\';  // If there is nothing in our stack then we just need to return /;\\n        while(!st.empty()){  // If we have something in stack then we have to give in this order \"/home/xyz/abc\" etc\\n            ans = \\'/\\' + st.top() + ans;  // For that I am using this \\n            st.pop();\\n        }       \\n        return ans;  // Returning the resulting string \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977070,
                "title": "line-by-line-explanation-beats-100-time-and-space-python",
                "content": "Here is Line by line code in \\n**Python :**\\n```\\ndef simplify_path(path):\\n    # Split path into a list of directory names\\n    dirs = path.split(\\'/\\')\\n    # Initialize the stack of directories\\n    stack = []\\n    # Iterate through the directories\\n    for d in dirs:\\n        # Ignore double slashes\\n        if d == \\'\\':\\n            continue\\n        # If it\\'s a double period, pop the top directory from the stack\\n        elif d == \\'..\\':\\n            if stack:\\n                stack.pop()\\n        # If it\\'s a single period or a regular directory name, add it to the stack\\n        elif d != \\'.\\':\\n            stack.append(d)\\n    # Construct the simplified canonical path\\n    simplified_path = \\'/\\' + \\'/\\'.join(stack)\\n    return simplified_path\\n```\\nUpvote if you find it useful",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef simplify_path(path):\\n    # Split path into a list of directory names\\n    dirs = path.split(\\'/\\')\\n    # Initialize the stack of directories\\n    stack = []\\n    # Iterate through the directories\\n    for d in dirs:\\n        # Ignore double slashes\\n        if d == \\'\\':\\n            continue\\n        # If it\\'s a double period, pop the top directory from the stack\\n        elif d == \\'..\\':\\n            if stack:\\n                stack.pop()\\n        # If it\\'s a single period or a regular directory name, add it to the stack\\n        elif d != \\'.\\':\\n            stack.append(d)\\n    # Construct the simplified canonical path\\n    simplified_path = \\'/\\' + \\'/\\'.join(stack)\\n    return simplified_path\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1847554,
                "title": "python-go-stack-array-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/GO] \\uD83C\\uDF1F Stack/Array Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\n```A double period \\'..\\' refers to the directory up a level``` would definitely be a thing we need to solve. We can use stack to implement pop out to up a level\\n\\n**Algo**\\n1. Make path split by \"/\" into pathList\\n2. Iterate through pathList\\n\\t * If current directory == \"\" or directory ==\".\"  We do noops continue to next directory\\n\\t * If directory == \"..\", we have to pop out last member in stack, by doing this we can make path up a level\\n\\t * If it\\'s a directory, append it into stack\\n3. Iterate through stack and combine all directory into a output path\\n\\n**Note** : We implement we call *stack* by array, So we can pop out last element and still can iterate from begining to the end.\\n\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of string\\n* Space: O(N): Iterate through path.split(\\'/\\') take O(N) and Add up res in stack take O(N) => O(2N) = O(N)\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        dirList = []\\n        \\n        for directory in path.split(\\'/\\') :\\n            # Ignore\\n            if not directory or directory == \".\":\\n                continue\\n            # Directory up a level\\n            if directory == \"..\":\\n                if dirList:\\n                    dirList.pop()\\n            # Append it in dirList\\n            else:\\n                dirList.append(directory)\\n                \\n        res = \"/\"\\n        # Make all dir in dirList add in res\\n        for directory in dirList:\\n            res += directory\\n            res += \"/\"\\n        # If res == \"/\" return it else pop out last string\\n        return res[:-1] if res != \"/\" else \"/\"\\n```\\n**Go**\\n```go\\nfunc simplifyPath(path string) string {\\n    pathList := strings.Split(path, \"/\")\\n    dirList := make([]string, 0)\\n    \\n    for _ , dir := range pathList{\\n        // Ignore\\n        if dir == \"\" || dir == \".\"{\\n            continue\\n        }\\n        // Directory up a level\\n        if dir == \"..\"{\\n            if len(dirList) != 0{\\n                dirList = dirList[:len(dirList) - 1]\\n            }\\n        // Append it in dirList\\n        } else {\\n            dirList = append(dirList, dir)\\n        }\\n    }\\n    output := \"/\"\\n    // Make all dir in dirList add in res\\n    for _, dir := range dirList{\\n        output += dir\\n        output += \"/\"\\n    }\\n    // If res == \"/\" return it else pop out last string\\n    if output == \"/\"{\\n        return output\\n    }\\n\\n    return output[:len(output) - 1]\\n}\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```A double period \\'..\\' refers to the directory up a level```\n```python\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        dirList = []\\n        \\n        for directory in path.split(\\'/\\') :\\n            # Ignore\\n            if not directory or directory == \".\":\\n                continue\\n            # Directory up a level\\n            if directory == \"..\":\\n                if dirList:\\n                    dirList.pop()\\n            # Append it in dirList\\n            else:\\n                dirList.append(directory)\\n                \\n        res = \"/\"\\n        # Make all dir in dirList add in res\\n        for directory in dirList:\\n            res += directory\\n            res += \"/\"\\n        # If res == \"/\" return it else pop out last string\\n        return res[:-1] if res != \"/\" else \"/\"\\n```\n```go\\nfunc simplifyPath(path string) string {\\n    pathList := strings.Split(path, \"/\")\\n    dirList := make([]string, 0)\\n    \\n    for _ , dir := range pathList{\\n        // Ignore\\n        if dir == \"\" || dir == \".\"{\\n            continue\\n        }\\n        // Directory up a level\\n        if dir == \"..\"{\\n            if len(dirList) != 0{\\n                dirList = dirList[:len(dirList) - 1]\\n            }\\n        // Append it in dirList\\n        } else {\\n            dirList = append(dirList, dir)\\n        }\\n    }\\n    output := \"/\"\\n    // Make all dir in dirList add in res\\n    for _, dir := range dirList{\\n        output += dir\\n        output += \"/\"\\n    }\\n    // If res == \"/\" return it else pop out last string\\n    if output == \"/\"{\\n        return output\\n    }\\n\\n    return output[:len(output) - 1]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180786,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack <string> st;\\n        for(int i = 0;i<path.size();i++)\\n        {\\n            if(path[i] == \\'/\\')\\n                continue;\\n            string s;\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                s += path[i];\\n                i++;\\n            }\\n            if(s == \".\")\\n                continue;\\n            else if(s == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(s);\\n        }\\n        string res;\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        if(res.size() == 0)\\n            return \"/\";\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack <string> st;\\n        for(int i = 0;i<path.size();i++)\\n        {\\n            if(path[i] == \\'/\\')\\n                continue;\\n            string s;\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                s += path[i];\\n                i++;\\n            }\\n            if(s == \".\")\\n                continue;\\n            else if(s == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(s);\\n        }\\n        string res;\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        if(res.size() == 0)\\n            return \"/\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671723,
                "title": "rust",
                "content": "```rust\\n    pub fn simplify_path(path: String) -> String {\\n        format!(\\n            \"/{}\",\\n            path.split(\\'/\\')\\n                .filter(|&x| x != \"\" && x != \".\")\\n                .fold(vec![], |mut acc, item| {\\n                    if item == \"..\" { acc.pop(); } \\n                    else { acc.push(item); }\\n                    acc\\n                })\\n                .join(\"/\")\\n        )\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n    pub fn simplify_path(path: String) -> String {\\n        format!(\\n            \"/{}\",\\n            path.split(\\'/\\')\\n                .filter(|&x| x != \"\" && x != \".\")\\n                .fold(vec![], |mut acc, item| {\\n                    if item == \"..\" { acc.pop(); } \\n                    else { acc.push(item); }\\n                    acc\\n                })\\n                .join(\"/\")\\n        )\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3021358,
                "title": "some-people-really-like-to-complicate-things",
                "content": "# Intuition\\nDon\\'t overthink. Free your mind https://www.youtube.com/watch?v=5TyHTxANcPw\\n\\n# Approach\\n1. Split array by **/**\\n2. Filter empty elements (empty strings)\\n3. Then follow 2 simple rules\\n    **..** - means we go one directory up, in other words we pop element from the **res** array\\n    **.** - just skip it\\nEverything else push to the **res** array\\nAnd don\\'t forget **/** in the beginning of the response.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst simplifyPath = (path) => {\\n    const res = [];\\n    const arr = path.split(\\'/\\').filter(v => v);\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === \\'..\\') {\\n            res.pop();\\n        } else if (arr[i] === \\'.\\') {\\n            continue;\\n        } else {\\n            res.push(arr[i])\\n        }\\n    }\\n\\n    return \\'/\\' + res.join(\\'/\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst simplifyPath = (path) => {\\n    const res = [];\\n    const arr = path.split(\\'/\\').filter(v => v);\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === \\'..\\') {\\n            res.pop();\\n        } else if (arr[i] === \\'.\\') {\\n            continue;\\n        } else {\\n            res.push(arr[i])\\n        }\\n    }\\n\\n    return \\'/\\' + res.join(\\'/\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702809,
                "title": "c-98-faster-tc-o-n-sc-o-1-no-stack-simple-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        string res; \\n        int n = s.size();\\n        \\n        // If the size is 1, return \\'/\\'\\n        if(n == 1) return \"/\";\\n        \\n        // There might be a case where the absolute path does not end with \\'/\\' , so Add \\'/\\' for simpler calculation\\n        if(s[n - 1] != \\'/\\') s.push_back(\\'/\\');\\n        \\n        // Take temporary string to check for \\'.\\' or \\'..\\' , you may also use temporary integer\\n        string temp = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // There are two cases \\n            // 1) s[i] == \\'/\\'\\n            // 2) s[i] != \\'/\\'\\n            \\n            // We will do operation when ever we reached \\'/\\' except for i = 0\\n            \\n            if(s[i] != \\'/\\'){\\n                // Update the temp string and result string\\n                string t = \"\";\\n                t += s[i];\\n                res += t;\\n                temp += t;\\n                \\n            } else if (i != 0){\\n                // Since we cannot have continuous \\'/\\', if the result string ended with \\'/\\', then continue\\n                if(res.back() == \\'/\\') continue;\\n                \\n                if(temp == \".\"){\\n                    // If there is one \\'.\\', remove last two elements from the result\\n                    res.pop_back();\\n                    res.pop_back();\\n                    \\n                } else if(temp == \"..\"){\\n                    // If there is two \\'..\\', then remove until we remove two \\'/\\' from the result\\n                    int c = 0;\\n                    while(c < 2){\\n                        if(res.back() == \\'/\\') c++;\\n                        if(res.size() == 0) break;\\n                        res.pop_back();\\n                    }\\n                }\\n                // Make temp string as empty\\n                temp = \"\";\\n                res.push_back(\\'/\\');\\n            } else {\\n                // Case when i = 0\\n                res.push_back(s[i]);\\n            }\\n        }\\n        \\n        // Finally remove the last \\'/\\' in the result\\n        if(res.size() > 1) res.pop_back();\\n        return res;\\n    }\\n};\\n```\\n\\nIf you like the Solution , please do \"**UPVOTE**\"",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        string res; \\n        int n = s.size();\\n        \\n        // If the size is 1, return \\'/\\'\\n        if(n == 1) return \"/\";\\n        \\n        // There might be a case where the absolute path does not end with \\'/\\' , so Add \\'/\\' for simpler calculation\\n        if(s[n - 1] != \\'/\\') s.push_back(\\'/\\');\\n        \\n        // Take temporary string to check for \\'.\\' or \\'..\\' , you may also use temporary integer\\n        string temp = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // There are two cases \\n            // 1) s[i] == \\'/\\'\\n            // 2) s[i] != \\'/\\'\\n            \\n            // We will do operation when ever we reached \\'/\\' except for i = 0\\n            \\n            if(s[i] != \\'/\\'){\\n                // Update the temp string and result string\\n                string t = \"\";\\n                t += s[i];\\n                res += t;\\n                temp += t;\\n                \\n            } else if (i != 0){\\n                // Since we cannot have continuous \\'/\\', if the result string ended with \\'/\\', then continue\\n                if(res.back() == \\'/\\') continue;\\n                \\n                if(temp == \".\"){\\n                    // If there is one \\'.\\', remove last two elements from the result\\n                    res.pop_back();\\n                    res.pop_back();\\n                    \\n                } else if(temp == \"..\"){\\n                    // If there is two \\'..\\', then remove until we remove two \\'/\\' from the result\\n                    int c = 0;\\n                    while(c < 2){\\n                        if(res.back() == \\'/\\') c++;\\n                        if(res.size() == 0) break;\\n                        res.pop_back();\\n                    }\\n                }\\n                // Make temp string as empty\\n                temp = \"\";\\n                res.push_back(\\'/\\');\\n            } else {\\n                // Case when i = 0\\n                res.push_back(s[i]);\\n            }\\n        }\\n        \\n        // Finally remove the last \\'/\\' in the result\\n        if(res.size() > 1) res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051414,
                "title": "c-single-pass-solutions-compared-and-explained-100-time-75-space",
                "content": "Nice problem and the first one I did about parsing string(ified) input in a while.\\n\\nTo proceed with it, we will firsst of all declare 2 support variables:\\n* `res` is our accumulator variable, but, just to further optimise and squeeze even more efficiency, we will also use it to create temporary strings;\\n* `tmp` is a vector of strings we will use to store (or pop) our parsed strings as we go.\\n\\nWe will then parse the string character by character, other than the first one (that we know is always going to be `\\'\\\\\\'`, so no point in considering it).\\n\\nLooping from `i` from `1` to the last character (`lmt`), we will:\\n* assign the value of `path[i]` to `c`;\\n* deal with `c`, depending if:\\n\\t* `c != \\'/\\'`, we will append it to `res`;\\n\\t* in any other case and if `i == lmt` (ie: we are parsing the last character - and note that this might happen even if after we appended it to `res` above):\\n\\t* if `res == \"..\"` and we have at least one element in `tmp`, we will pop the last one from it;\\n\\t* if `res` is not empty and `!= \".\"`, we will add it to `tmp`;\\n\\t* reset `res` to be `\"\"`.\\n\\nOnce done, time to finally use `res` for its proper function: if `tmp` is not empty, we will set it to be `\"\"`, `\"/\"` otherwise.\\n\\nWe will then loop through all the strings `w` collected in `tmp` and append `\"/\" + w` to `res`.\\n\\nOnce done, we can return it.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res;\\n        vector<string> tmp;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (tmp.size()) tmp.pop_back();\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp.push_back(res);\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = tmp.size() ? \"\" : \"/\";\\n        for (string w: tmp) res += \"/\" + w;\\n        return res;\\n    }\\n};\\n```\\n\\nCould I be happy with it? Well, no: not a huge fan of stacks and whenever I can, I like to use arrays in their place, provided I can guesstimate their size, as I did with a bit of trial and error, setting `tmp` to be of size `100` with a bit of trial and error; `pos` is our pointer to write in it, initially set to `0` and all the logic is the same, with significantly better performance:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res, tmp[50];\\n        int pos = 0;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (pos) pos--;\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp[pos++] = res;\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = pos ? \"\" : \"/\";\\n        for (int i = 0; i < pos; i++) res += \"/\" + tmp[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res;\\n        vector<string> tmp;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (tmp.size()) tmp.pop_back();\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp.push_back(res);\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = tmp.size() ? \"\" : \"/\";\\n        for (string w: tmp) res += \"/\" + w;\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res, tmp[50];\\n        int pos = 0;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (pos) pos--;\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp[pos++] = res;\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = pos ? \"\" : \"/\";\\n        for (int i = 0; i < pos; i++) res += \"/\" + tmp[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187271,
                "title": "easy-java-solution-using-stack",
                "content": "```\\npublic String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        Stack<String> st = new Stack<>();\\n        for(String s:paths){\\n            if(s.equals(\"\")) continue;\\n            else if(s.equals(\".\")) continue;\\n            else if(s.equals(\"..\")) \\n                if(!st.isEmpty()) st.pop();\\n                else continue;\\n            else st.add(s);\\n        }\\n        return \"/\"+String.join(\"/\", st);\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        Stack<String> st = new Stack<>();\\n        for(String s:paths){\\n            if(s.equals(\"\")) continue;\\n            else if(s.equals(\".\")) continue;\\n            else if(s.equals(\"..\")) \\n                if(!st.isEmpty()) st.pop();\\n                else continue;\\n            else st.add(s);\\n        }\\n        return \"/\"+String.join(\"/\", st);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847420,
                "title": "java-simple-java-code-explained-algorithm-stack",
                "content": "Sample case  2 Explain  ->   ![image](https://assets.leetcode.com/users/images/8cbf8af5-2ad5-4fa8-ba71-f8b077be63a2_1647222748.909183.jpeg)\\n\\n\\n![image](https://assets.leetcode.com/users/images/33223edb-ee01-4b32-ba7c-f3680384d4bd_1647222828.2566357.jpeg)\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        \\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        \\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492803,
                "title": "c-76-ms-manipulate-string-array-from-split-or-80-ms-linkedlist",
                "content": "I originally used a Stack, but realized I had to reverse it, then I switched to a List, but deletions are slow, so I switched to a LinkedList and it is pretty quick and requires no reversal, then I realized you can just manipulate the array returned from the string.Split and keep track of how many tokens in the path.\\n\\n76 ms.\\n```\\n    public string SimplifyPath(string path) {\\n        \\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        int itemCount = 0;\\n        \\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(itemCount > 0) itemCount--;\\n                    break;\\n                default:\\n                    tokens[itemCount++] = tokens[i];\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', tokens, 0, itemCount);\\n    }\\n```\\n\\n80 ms. Linked List\\n\\n```\\n    public string SimplifyPath(string path) {\\n\\t\\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        var answerList = new LinkedList<string>();\\n\\t\\t\\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(answerList.Count > 0) answerList.RemoveLast();\\n                    break;\\n                default:\\n                    answerList.AddLast(tokens[i]);\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', answerList);\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public string SimplifyPath(string path) {\\n        \\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        int itemCount = 0;\\n        \\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(itemCount > 0) itemCount--;\\n                    break;\\n                default:\\n                    tokens[itemCount++] = tokens[i];\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', tokens, 0, itemCount);\\n    }\\n```\n```\\n    public string SimplifyPath(string path) {\\n\\t\\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        var answerList = new LinkedList<string>();\\n\\t\\t\\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(answerList.Count > 0) answerList.RemoveLast();\\n                    break;\\n                default:\\n                    answerList.AddLast(tokens[i]);\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', answerList);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455100,
                "title": "c-stack-solution",
                "content": "We use a stack to store each layer of the directory.\\nWe loop the path and parse each directory separating by `/`\\n\\n- If we get an empty directory or `.`, we do nothing\\n- If we get a `..`, we pop out the top element from the stack (if it is not empty)\\n- If we get anything else, we push the directory to the stack\\n\\nAt the end, we reconstruct the simplified path from the stack and return.\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        int i = 0;\\n        string cur = \"\";\\n        path += \\'/\\';\\n        // loop path and construct stack\\n        while (i < path.size()) {\\n            if (path[i] == \\'/\\') {\\n                if (!cur.empty()) {\\n                    if (cur == \".\") {\\n                        // do nothing\\n                    }\\n                    else if (cur == \"..\") {\\n                        // remove the last dir\\n                        if (!st.empty()) {\\n                            st.pop();\\n                        }\\n                    }\\n                    else {\\n                        // append the cur dir\\n                        st.push(cur);\\n                    }\\n                }\\n                cur.clear();\\n                i += 1;\\n            }\\n            else {\\n                cur += path[i];\\n                i += 1;\\n            }\\n        }\\n        // construct result string from stack\\n        string rst = \"\";\\n        while (!st.empty()) {\\n            rst = \"/\" + st.top() + rst;\\n            st.pop();\\n        }\\n        if (rst.empty()) rst += \\'/\\';\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        int i = 0;\\n        string cur = \"\";\\n        path += \\'/\\';\\n        // loop path and construct stack\\n        while (i < path.size()) {\\n            if (path[i] == \\'/\\') {\\n                if (!cur.empty()) {\\n                    if (cur == \".\") {\\n                        // do nothing\\n                    }\\n                    else if (cur == \"..\") {\\n                        // remove the last dir\\n                        if (!st.empty()) {\\n                            st.pop();\\n                        }\\n                    }\\n                    else {\\n                        // append the cur dir\\n                        st.push(cur);\\n                    }\\n                }\\n                cur.clear();\\n                i += 1;\\n            }\\n            else {\\n                cur += path[i];\\n                i += 1;\\n            }\\n        }\\n        // construct result string from stack\\n        string rst = \"\";\\n        while (!st.empty()) {\\n            rst = \"/\" + st.top() + rst;\\n            st.pop();\\n        }\\n        if (rst.empty()) rst += \\'/\\';\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379753,
                "title": "java-stack-explained-clean",
                "content": "Stack is superb for this problem - in case we go back (up) - just pop from stack. We can tokenize initial path using string.split.\\n\\n```\\n    public String simplifyPath(String path) {\\n        //parse string to initial tokens\\n        String[] vals = path.split(\"/\");\\n        //start iterating on path segments using stack to store results. Most tokens we can simply ignore\\n        Stack<String> s = new Stack();\\n        for (String p : vals) {\\n            //these cases refer to current dir and multiple \"/\"\\n            if (p.length() == 0 || p.equals(\".\"))\\n                continue;\\n            //in case we have to go back - just pop from stack\\n            else if (p.equals(\"..\")) {\\n                if (!s.isEmpty())\\n                    s.pop();\\n            }\\n            //all other cases - push to stack\\n            else\\n                s.push(p);\\n        }\\n        //no build the final path string\\n        String res = \"\";\\n        while (!s.isEmpty()) {\\n            res = \"/\" + s.pop() + res;\\n        }\\n        //in case we haven\\'t met any path segments - return just root folder\\n        return res.length() == 0 ? \"/\" : res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String simplifyPath(String path) {\\n        //parse string to initial tokens\\n        String[] vals = path.split(\"/\");\\n        //start iterating on path segments using stack to store results. Most tokens we can simply ignore\\n        Stack<String> s = new Stack();\\n        for (String p : vals) {\\n            //these cases refer to current dir and multiple \"/\"\\n            if (p.length() == 0 || p.equals(\".\"))\\n                continue;\\n            //in case we have to go back - just pop from stack\\n            else if (p.equals(\"..\")) {\\n                if (!s.isEmpty())\\n                    s.pop();\\n            }\\n            //all other cases - push to stack\\n            else\\n                s.push(p);\\n        }\\n        //no build the final path string\\n        String res = \"\";\\n        while (!s.isEmpty()) {\\n            res = \"/\" + s.pop() + res;\\n        }\\n        //in case we haven\\'t met any path segments - return just root folder\\n        return res.length() == 0 ? \"/\" : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181198,
                "title": "c-easy-to-understand-solution",
                "content": "```\\n    string simplifyPath(string path) {\\n        stack<string> dir;\\n        string res = \"\", val;\\n        istringstream ss(path);\\n        while(getline(ss, val, \\'/\\')){\\n            if(val.size() == 0 || val == \".\")\\n                continue;\\n            if(val == \"..\") {\\n                if(!dir.empty())\\n                    dir.pop();\\n            } else {\\n                dir.push(val);\\n            }\\n        }\\n        \\n        if(dir.empty())\\n            return \"/\";\\n        \\n        while(!dir.empty()){\\n            res = \"/\" + dir.top() + res;\\n            dir.pop();\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    string simplifyPath(string path) {\\n        stack<string> dir;\\n        string res = \"\", val;\\n        istringstream ss(path);\\n        while(getline(ss, val, \\'/\\')){\\n            if(val.size() == 0 || val == \".\")\\n                continue;\\n            if(val == \"..\") {\\n                if(!dir.empty())\\n                    dir.pop();\\n            } else {\\n                dir.push(val);\\n            }\\n        }\\n        \\n        if(dir.empty())\\n            return \"/\";\\n        \\n        while(!dir.empty()){\\n            res = \"/\" + dir.top() + res;\\n            dir.pop();\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 25820,
                "title": "ac-solution-in-java",
                "content": "    public class Solution {\\n        public String simplifyPath(String path) {\\n            Set<String> isSkip = new HashSet<>(Arrays.asList(\"\", \".\", \"..\"));\\n            Deque<String> stack = new ArrayDeque<>();\\n            for (String token : path.split(\"/\")) {\\n                if (token.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n                if (isSkip.contains(token)) continue;\\n                stack.push(token);\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            while (!stack.isEmpty()) {\\n                sb.append(\"/\" + stack.pollLast());\\n            }\\n            return sb.length() == 0 ? \"/\" : sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String simplifyPath(String path) {\\n            Set<String> isSkip = new HashSet<>(Arrays.asList(\"\", \".\", \"..\"));\\n            Deque<String> stack = new ArrayDeque<>();\\n            for (String token : path.split(\"/\")) {\\n                if (token.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n                if (isSkip.contains(token)) continue;\\n                stack.push(token);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3406723,
                "title": "very-simple-and-concise-solution-with-explanation",
                "content": "## Approach \\n\\nIn a Unix-style file system, a period `.` refers to the current directory and a double period `..` refers to the directory up a level. For example, if we are in the directory /a/b/c/d and we want to go up one level, we can use `..` to get to /a/b/c.\\n\\nThe simplified canonical path should start with a single slash `/`, and any two directories should be separated by a single slash `/`. It should not end with a trailing slash `/`, and it should not contain any periods `.` or double periods `..`.\\n\\nTo achieve this, the given solution first creates an empty array called `simplifiedPath` to store the simplified path. It then splits the input `path` into individual directories using the forward slash `/` as a separator, and stores them in an array called `dirs`.\\n\\nThe function then goes through each directory in the `dirs` array using a `for...of` loop. If the directory is an empty string or a period `.`, it skips over it and moves to the next directory. If the directory is a double period `..`, it removes the last directory added to the `simplifiedPath` array using the `pop()` method, effectively moving up one level. If the directory is anything else, it adds it to the `simplifiedPath` array.\\n\\nFinally, the function joins all the directories in the `simplifiedPath` array using the forward slash `/` as a separator, and concatenates it with a single slash `/` at the beginning to create the simplified canonical path. The resulting path is then returned as a string.\\n\\n## JavaScript Solution\\n```\\nvar simplifyPath = function (path) {\\n  const simplifiedPath = [];\\n  const dirs = path.split(\"/\");\\n\\n  for (const dir of dirs) {\\n    if (dir === \"\" || dir === \".\") continue;\\n    dir === \"..\" ? simplifiedPath.pop() : simplifiedPath.push(dir);\\n  }\\n\\n  return \"/\" + simplifiedPath.join(\"/\");\\n};\\n\\n```\\n\\n## Go Solution\\n```go\\nimport \"strings\"\\n\\nfunc simplifyPath(path string) string {\\n\\tsimplifiedPath := make([]string, 0)\\n\\tdirs := strings.Split(path, \"/\")\\n\\n\\tfor _, dir := range dirs {\\n\\t\\tif dir == \"\" || dir == \".\" { continue }\\n\\t\\tif dir != \"..\" {\\n\\t\\t\\tsimplifiedPath = append(simplifiedPath, dir)\\n\\t\\t} else if len(simplifiedPath) > 0 {\\n\\t\\t\\tsimplifiedPath = simplifiedPath[:len(simplifiedPath)-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn \"/\" + strings.Join(simplifiedPath, \"/\")\\n}\\n```\\n\\n## Rust Solution\\n```rust\\nimpl Solution {\\n    pub fn simplify_path(path: String) -> String {\\n        let mut simplified_path = vec![];\\n        for dir in path.split(\\'/\\') {\\n            match dir {\\n                \"\" | \".\" => continue,\\n                \"..\" => { simplified_path.pop(); }\\n                _ => simplified_path.push(dir),\\n            }\\n        }\\n\\n        \"/\".to_owned() + &simplified_path.join(\"/\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String",
                    "Stack"
                ],
                "code": "```\\nvar simplifyPath = function (path) {\\n  const simplifiedPath = [];\\n  const dirs = path.split(\"/\");\\n\\n  for (const dir of dirs) {\\n    if (dir === \"\" || dir === \".\") continue;\\n    dir === \"..\" ? simplifiedPath.pop() : simplifiedPath.push(dir);\\n  }\\n\\n  return \"/\" + simplifiedPath.join(\"/\");\\n};\\n\\n```\n```go\\nimport \"strings\"\\n\\nfunc simplifyPath(path string) string {\\n\\tsimplifiedPath := make([]string, 0)\\n\\tdirs := strings.Split(path, \"/\")\\n\\n\\tfor _, dir := range dirs {\\n\\t\\tif dir == \"\" || dir == \".\" { continue }\\n\\t\\tif dir != \"..\" {\\n\\t\\t\\tsimplifiedPath = append(simplifiedPath, dir)\\n\\t\\t} else if len(simplifiedPath) > 0 {\\n\\t\\t\\tsimplifiedPath = simplifiedPath[:len(simplifiedPath)-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn \"/\" + strings.Join(simplifiedPath, \"/\")\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn simplify_path(path: String) -> String {\\n        let mut simplified_path = vec![];\\n        for dir in path.split(\\'/\\') {\\n            match dir {\\n                \"\" | \".\" => continue,\\n                \"..\" => { simplified_path.pop(); }\\n                _ => simplified_path.push(dir),\\n            }\\n        }\\n\\n        \"/\".to_owned() + &simplified_path.join(\"/\")\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1848456,
                "title": "c-easy-to-understand-using-stack-daily-leetcoding-challenge-march-day-14",
                "content": "// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n\\n**Approach**\\n* Just store the **Folder** names in the stack (string between the 2 slashes) one by one\\n\\n* when we come across \\u201D . \\u201D we do nothing\\n\\n* When we find \\u201C..\\u201D in our path, we simply pop the topmost element as we have to jump back to parent\\u2019s directory according to given condition\\n\\n* When we see multiple \\u201C////\\u201D we just ignore them as they are equivalent to one single \\u201C/\\u201D\\n\\n* After iterating through the whole string the elements remaining in the stack is our answer\\n\\n**Time Complexity   : O(n)**\\n**Space Complexity : O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string> st;                            // created the stack for stroing the Folder names\\n        string ans =\"\";                              // it will store the final ans\\n        \\n        for(int i=0;i<path.size();i++)               // iterate over the whole given string\\n        {\\n            // if it is a backslash then just ignore it because it is not the Folder name\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            // if it is not / then try to store our Folder name till we do not find next /\\n            // store the Folder name in temp string\\n            string temp = \"\";\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n            \\n            // after storing the Folder\\n            // just check the symbols \\n            \\n            // ignoring .\\n            if(temp==\".\")\\n                continue;\\n            \\n            // if it is \\'..\\' move to previous Folder \\n            else if(temp==\"..\")\\n            {\\n                // according to our given condition \\n                // if it is \\'..\\' move to previous Folder\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            \\n            else\\n            {\\n                // else store our all Folder names into the stack\\n                st.push(temp);\\n            }\\n        }\\n        \\n        // store the Folder names from stack to the ans string \\n        // in given firmat \"/Folder_name\"\\n        while(!st.empty())\\n        {\\n            ans = \"/\" + st.top() + ans;            // just following the format\\n            st.pop();\\n        }\\n        \\n        // if there is empty string \\n        if(ans.size() == 0)\\n            return \"/\";\\n        \\n        return ans;\\n    }\\n};\\n```\\n// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string> st;                            // created the stack for stroing the Folder names\\n        string ans =\"\";                              // it will store the final ans\\n        \\n        for(int i=0;i<path.size();i++)               // iterate over the whole given string\\n        {\\n            // if it is a backslash then just ignore it because it is not the Folder name\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            // if it is not / then try to store our Folder name till we do not find next /\\n            // store the Folder name in temp string\\n            string temp = \"\";\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n            \\n            // after storing the Folder\\n            // just check the symbols \\n            \\n            // ignoring .\\n            if(temp==\".\")\\n                continue;\\n            \\n            // if it is \\'..\\' move to previous Folder \\n            else if(temp==\"..\")\\n            {\\n                // according to our given condition \\n                // if it is \\'..\\' move to previous Folder\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            \\n            else\\n            {\\n                // else store our all Folder names into the stack\\n                st.push(temp);\\n            }\\n        }\\n        \\n        // store the Folder names from stack to the ans string \\n        // in given firmat \"/Folder_name\"\\n        while(!st.empty())\\n        {\\n            ans = \"/\" + st.top() + ans;            // just following the format\\n            st.pop();\\n        }\\n        \\n        // if there is empty string \\n        if(ans.size() == 0)\\n            return \"/\";\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050681,
                "title": "python-simple-short-6-line-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        \\n        for d in path.split(\"/\"):\\n            if d == \"..\": \\n                if stack: stack.pop(-1)\\n                    \\n            elif d and d != \".\": stack.append(d)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        \\n        for d in path.split(\"/\"):\\n            if d == \"..\": \\n                if stack: stack.pop(-1)\\n                    \\n            elif d and d != \".\": stack.append(d)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161111,
                "title": "java-string",
                "content": "We build the simplified path from scratch:\\n1. split path by \"/\"\\n2. backtrack if meets \"..\", do nothing if meets \".\" or \"\"\\n3. reconstruct the path by adding \"/\" in between (with heading \"/\")\\n\\n```\\n    public String simplifyPath(String path) {\\n        String[] dirNames = path.split(\"/\");\\n        \\n        // shortest (substitute . or ..)\\n        List<String> simplified = new ArrayList<>();\\n        for (String name : dirNames) {\\n            if (!name.isEmpty() && !name.equals(\".\")) {\\n                if (name.equals(\"..\")) {\\n                    if (!simplified.isEmpty()) {\\n                        simplified.remove(simplified.size() - 1);\\n                    }\\n                } else { \\n                    simplified.add(name);\\n                }\\n            } \\n        }\\n            \\n        // start with /, single / between two directory names\\n        StringBuilder simplifiedPath = new StringBuilder();\\n        for (String name : simplified) {\\n            simplifiedPath.append(\"/\").append(name);\\n        }\\n        \\n        return simplifiedPath.length() == 0 ? \"/\" : simplifiedPath.toString();   \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String simplifyPath(String path) {\\n        String[] dirNames = path.split(\"/\");\\n        \\n        // shortest (substitute . or ..)\\n        List<String> simplified = new ArrayList<>();\\n        for (String name : dirNames) {\\n            if (!name.isEmpty() && !name.equals(\".\")) {\\n                if (name.equals(\"..\")) {\\n                    if (!simplified.isEmpty()) {\\n                        simplified.remove(simplified.size() - 1);\\n                    }\\n                } else { \\n                    simplified.add(name);\\n                }\\n            } \\n        }\\n            \\n        // start with /, single / between two directory names\\n        StringBuilder simplifiedPath = new StringBuilder();\\n        for (String name : simplified) {\\n            simplifiedPath.append(\"/\").append(name);\\n        }\\n        \\n        return simplifiedPath.length() == 0 ? \"/\" : simplifiedPath.toString();   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25781,
                "title": "c-implementation",
                "content": "    class Solution {\\n    public:\\n        string simplifyPath(string path) {\\n            vector<string> st;\\n            vector<string> nodes;\\n            string result;\\n            split(path, '/', nodes);\\n            for(auto node : nodes) {\\n                //empty or only '.' path no change\\n                if(node == \"\" || node == \".\")  continue;\\n                //go back to the upper directory\\n                if(node == \"..\" && !st.empty())  st.pop_back();\\n                //push back the current directory\\n                else if(node != \"..\")  st.push_back(node);\\n            }\\n            for(auto it : st) result += \"/\" + it;\\n            return result.empty() ? \"/\" : result;\\n        }\\n        \\n        void split(string s, char delim, vector<string>& nodes) {\\n            string temp;\\n            stringstream ss(s);\\n            while(getline(ss, temp, delim)) {\\n                nodes.push_back(temp);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string simplifyPath(string path) {\\n            vector<string> st;\\n            vector<string> nodes;\\n            string result;\\n            split(path, '/', nodes);\\n            for(auto node : nodes) {\\n                //empty or only '.' path no change\\n                if(node == \"\" || node == \".\")  continue;\\n                //go back to the upper directory\\n                if(node == \"..\" && !st.empty())  st.pop_back();\\n                //push back the current directory\\n                else if(node != \"..\")  st.push_back(node);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3408365,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        return __import__(\\'os\\').path.abspath(path)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        return __import__(\\'os\\').path.abspath(path)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407238,
                "title": "python-simple-solution-using-stack",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n\\n        # different directories present in the string\\n        temp = path.split(\\'/\\') \\n\\n        for i in temp:\\n            if i != \\'.\\' and i != \\'\\' and i != \\'..\\':\\n                stack.append(i) # add if it is directory\\n\\n            # move to back directory if \\'..\\'\\n            elif i == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n        \\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n\\n        # different directories present in the string\\n        temp = path.split(\\'/\\') \\n\\n        for i in temp:\\n            if i != \\'.\\' and i != \\'\\' and i != \\'..\\':\\n                stack.append(i) # add if it is directory\\n\\n            # move to back directory if \\'..\\'\\n            elif i == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n        \\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406774,
                "title": "java-easy-solution-using-split-method-beginner-friendly-98-faster-code-stringbuilder",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n     public String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        int left = -1, right = 0;\\n        while (right < paths.length) {\\n        \\tif (paths[right].equals(\"..\"))\\n        \\t\\tleft = left == -1 ? -1 : left - 1;\\n        \\telse if (!paths[right].equals(\".\") && !paths[right].equals(\"\"))\\n        \\t\\tpaths[++left] = paths[right];\\n        \\tright++;\\n        }\\n        if (left == -1)\\n        \\treturn \"/\";\\n        StringBuilder buf = new StringBuilder();\\n        for (int i = 0; i <= left; i++)\\n        \\tbuf.append(\\'/\\').append(paths[i]);\\n        return buf.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        int left = -1, right = 0;\\n        while (right < paths.length) {\\n        \\tif (paths[right].equals(\"..\"))\\n        \\t\\tleft = left == -1 ? -1 : left - 1;\\n        \\telse if (!paths[right].equals(\".\") && !paths[right].equals(\"\"))\\n        \\t\\tpaths[++left] = paths[right];\\n        \\tright++;\\n        }\\n        if (left == -1)\\n        \\treturn \"/\";\\n        StringBuilder buf = new StringBuilder();\\n        for (int i = 0; i <= left; i++)\\n        \\tbuf.append(\\'/\\').append(paths[i]);\\n        return buf.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808626,
                "title": "c-easy-solution-stack",
                "content": "**If you like the solution please upvote it.**\\n\\n\\tstring simplifyPath(string path) {\\n        int n = path.size();\\n        if(path.back()!=\\'/\\') {\\n            path.push_back(\\'/\\');\\n            n++;\\n        }\\n        cout << path << \" \" << n << endl;\\n        string temp;\\n        stack<string> st;\\n        int i=1;\\n        while(i<n) {\\n            if(path[i] == \\'/\\') {\\n                if(temp==\"\" || temp==\".\") {\\n                    temp = \"\";\\n                }\\n                else if(temp==\"..\") {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else \\n                    st.push(temp);\\n                temp=\"\";\\n            }\\n            else {\\n                temp.push_back(path[i]);\\n            }\\n            i++;\\n        }\\n        string res=\"\";\\n        while(!st.empty()) {\\n            res = \"/\"+st.top()+res;\\n            st.pop();\\n        }\\n        if(res.length()==0)\\n            res.push_back(\\'/\\');\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "**If you like the solution please upvote it.**\\n\\n\\tstring simplifyPath(string path) {\\n        int n = path.size();\\n        if(path.back()!=\\'/\\') {\\n            path.push_back(\\'/\\');\\n            n++;\\n        }\\n        cout << path << \" \" << n << endl;\\n        string temp;\\n        stack<string> st;\\n        int i=1;\\n        while(i<n) {\\n            if(path[i] == \\'/\\') {\\n                if(temp==\"\" || temp==\".\") {\\n                    temp = \"\";\\n                }\\n                else if(temp==\"..\") {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else \\n                    st.push(temp);\\n                temp=\"\";\\n            }\\n            else {\\n                temp.push_back(path[i]);\\n            }\\n            i++;\\n        }\\n        string res=\"\";\\n        while(!st.empty()) {\\n            res = \"/\"+st.top()+res;\\n            st.pop();\\n        }\\n        if(res.length()==0)\\n            res.push_back(\\'/\\');\\n        return res;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1553245,
                "title": "stack-solution-easy-to-understand-tc-sc-o-n",
                "content": "**71. Simply Path - Solution**\\n\\nPseudo Code:\\nfunction simplyPath (string path)\\n1. Input : *path*\\n2. Declare a stack variable, *s*\\n3.  Declare string variables, *directory* & *result*\\n4.  Add \\'/\\' to path (why: to mark the end of the last directory if the *path* doesn\\'t end with \\'/\\' )\\n5.  Traverse through *path*\\n     a. Let current character be *curr*\\n\\t b.if *curr* is not \\'/\\' , then concatenate *curr* to *directory* (why: Assuming anything that is not \\'/\\' is going to be the directory name, and we handle \".\" , \"..\" accordingly)\\n\\t c. else\\n\\t     &nbsp;&nbsp;&nbsp; - if *directory* is empty or \".\" , then do nothing\\n\\t\\t &nbsp;&nbsp;&nbsp; - else if *directory* = \"..\" , then pop from stack, *s* (why: \"..\" represent directory up a level. so, the last encountered directory is not required)\\n\\t\\t &nbsp;&nbsp;&nbsp; - else push *directory* to the stack, *s* (why: anything non-null string other than \".\" , \"..\" represent a directory)\\n\\t\\t &nbsp;&nbsp;&nbsp; - end if\\n\\t\\t &nbsp;&nbsp;&nbsp; - clear *directory* value (why: to store next directory name)\\n\\t  d. end if\\n6. if stack, *s* is empty return \"/\"\\n7. end if\\n8. while stack, *s* is not empty\\n     a. Replace *result* with \\'/\\' + stack top + *result*\\n     b. pop from stack, *s*\\n9. end while\\n10. return *result*\\n\\n```\\nstring simplifyPath(string path) {\\n        stack<string> s; \\n        string directory, result;\\n        \\n        path+=\\'/\\';               \\n        \\n        for(int i=0;i<path.size();i++){\\n            if(path[i]!=\\'/\\')\\n                directory+=path[i];\\n            else {\\n                  if(directory.length()==0 || directory==\".\") {}\\n                  else if(directory==\"..\") {\\n                     if(!s.empty())\\n                        s.pop();\\n                  }\\n                  else               \\n                     s.push(directory);\\n                  directory=\"\";\\n            }            \\n        }\\n        \\n        if(s.size()==0)\\n            return \"/\";\\n        \\n        while(!s.empty()){\\n            result=\"/\"+s.top()+result;\\n            s.pop();\\n        }\\n        \\n        return result;\\n}\\n```\\nHope it helps!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring simplifyPath(string path) {\\n        stack<string> s; \\n        string directory, result;\\n        \\n        path+=\\'/\\';               \\n        \\n        for(int i=0;i<path.size();i++){\\n            if(path[i]!=\\'/\\')\\n                directory+=path[i];\\n            else {\\n                  if(directory.length()==0 || directory==\".\") {}\\n                  else if(directory==\"..\") {\\n                     if(!s.empty())\\n                        s.pop();\\n                  }\\n                  else               \\n                     s.push(directory);\\n                  directory=\"\";\\n            }            \\n        }\\n        \\n        if(s.size()==0)\\n            return \"/\";\\n        \\n        while(!s.empty()){\\n            result=\"/\"+s.top()+result;\\n            s.pop();\\n        }\\n        \\n        return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051451,
                "title": "go-stack-100-o-n-two-solutions-unit-test",
                "content": "The problem statement asks us to normalize a given path from notation having references to a  current `\".\"` and/or parent `\"..\"` directories to the canonical, absolute path. A given path is a list of directories separated by `\"/\"`, optionally having aforementioned references injected into it. To convert a path into canonical one we can split it by the separator `\"/\"` and normalize split list using _stack_ (basically, truncate split list) to manage references to parent directories `\"..\"` efficiently.\\n\\n    import (\\n    \\t\"strings\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\tstack := []string{}\\n    \\tchunks := strings.Split(path, \"/\")\\n    \\tfor _, chunk := range chunks {\\n    \\t\\tswitch chunk {\\n    \\t\\tcase \".\", \"\":\\n    \\t\\t\\tcontinue\\n    \\t\\tcase \"..\":\\n    \\t\\t\\tif len(stack) > 0 {\\n    \\t\\t\\t\\tstack = stack[:len(stack)-1]\\n    \\t\\t\\t}\\n    \\t\\tdefault:\\n    \\t\\t\\tstack = append(stack, chunk)\\n    \\t\\t}\\n    \\t}\\n    \\treturn \"/\" + strings.Join(stack, \"/\")\\n    }\\n\\n**Complexity:**\\n- Time: 0(n)\\n- Space: 0(n)\\n\\nAnother approach is to (cheat ;) and use standard library: \\n\\n    import (\\n    \\tp \"path\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\treturn p.Clean(path)\\n    }\\n\\nThe code of both approaches covered with unit test is available at the Go playground by the URL https://play.golang.org/p/d9gP8PI5mnj\\n\\nIf you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Go"
                ],
                "code": "The problem statement asks us to normalize a given path from notation having references to a  current `\".\"` and/or parent `\"..\"` directories to the canonical, absolute path. A given path is a list of directories separated by `\"/\"`, optionally having aforementioned references injected into it. To convert a path into canonical one we can split it by the separator `\"/\"` and normalize split list using _stack_ (basically, truncate split list) to manage references to parent directories `\"..\"` efficiently.\\n\\n    import (\\n    \\t\"strings\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\tstack := []string{}\\n    \\tchunks := strings.Split(path, \"/\")\\n    \\tfor _, chunk := range chunks {\\n    \\t\\tswitch chunk {\\n    \\t\\tcase \".\", \"\":\\n    \\t\\t\\tcontinue\\n    \\t\\tcase \"..\":\\n    \\t\\t\\tif len(stack) > 0 {\\n    \\t\\t\\t\\tstack = stack[:len(stack)-1]\\n    \\t\\t\\t}\\n    \\t\\tdefault:\\n    \\t\\t\\tstack = append(stack, chunk)\\n    \\t\\t}\\n    \\t}\\n    \\treturn \"/\" + strings.Join(stack, \"/\")\\n    }\\n\\n**Complexity:**\\n- Time: 0(n)\\n- Space: 0(n)\\n\\nAnother approach is to (cheat ;) and use standard library: \\n\\n    import (\\n    \\tp \"path\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\treturn p.Clean(path)\\n    }\\n\\nThe code of both approaches covered with unit test is available at the Go playground by the URL https://play.golang.org/p/d9gP8PI5mnj\\n\\nIf you like solution and explanations, please **Upvote!**",
                "codeTag": "Python3"
            },
            {
                "id": 1051132,
                "title": "simplify-path-easy-python-solution",
                "content": "```\\ndef simplifyPath(self, path: str) -> str:\\n        \\n        stack = []\\n        \\n        path = path.split(\\'/\\')\\n        \\n        for p in path:\\n            if not p or p==\\'.\\':\\n                continue\\n            elif p==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n                \\n                \\n        root = \"/\"\\n        \\n        return root + \"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef simplifyPath(self, path: str) -> str:\\n        \\n        stack = []\\n        \\n        path = path.split(\\'/\\')\\n        \\n        for p in path:\\n            if not p or p==\\'.\\':\\n                continue\\n            elif p==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n                \\n                \\n        root = \"/\"\\n        \\n        return root + \"/\".join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 225602,
                "title": "c-4ms-beats-100-simple-explanation",
                "content": "## Simplify Path\\n\\n### Approach: 4ms, beats 100%\\nThe approach for this question is really simple. The visited directories are kept track of using a stack. The following rules need to be taken care of:\\n1)Each non empty string between two consecutive \\'/\\' resemble a directory.\\n2)If this string is \\'.\\' then ignore it.\\n3)If this string is \\'..\\' then remove the last opened directory(present working directory) from the top of stack, if the stack is non empty.\\n4)Otherwise, the string resembles a new directory name and hence it is to be pushed into the stack.\\n\\nContinue the above procedure till the entire input path hasnt been traversed. In case the last character of the path is not \\'/\\', we have to check the string constituting the name of the last directory in the path and check if it is \\'.\\', \\'..\\' or something else and operate on it as in the above steps.\\n\\nPop the stack and store the strings in reserse order in the answer string seperated by using \\'/\\' as delimiter. If the answer string is empty then return \"/\", else return the answer string.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string s = \"\";\\n        stack<string> stck;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            char c = path[i];\\n            if(c==\\'/\\')\\n            {\\n                if(s==\"..\")\\n                {\\n                    if(!stck.empty())\\n                    {\\n                    stck.pop();\\n                    s=\"\";\\n                    }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n            s=\"\";\\n            continue;\\n            }\\n            s+=c;\\n        }\\n        if(path[path.size()-1]!=\\'/\\')\\n        {\\n            if(s==\"..\")\\n            {\\n                if(!stck.empty())\\n                {\\n                    stck.pop();\\n                }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n        }\\n        s = \"\";\\n        while(!stck.empty())\\n        {\\n            s = \"/\"+stck.top()+s;\\n            stck.pop();\\n        }\\n        if(s==\"\")\\n        {\\n            return \"/\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string s = \"\";\\n        stack<string> stck;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            char c = path[i];\\n            if(c==\\'/\\')\\n            {\\n                if(s==\"..\")\\n                {\\n                    if(!stck.empty())\\n                    {\\n                    stck.pop();\\n                    s=\"\";\\n                    }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n            s=\"\";\\n            continue;\\n            }\\n            s+=c;\\n        }\\n        if(path[path.size()-1]!=\\'/\\')\\n        {\\n            if(s==\"..\")\\n            {\\n                if(!stck.empty())\\n                {\\n                    stck.pop();\\n                }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n        }\\n        s = \"\";\\n        while(!stck.empty())\\n        {\\n            s = \"/\"+stck.top()+s;\\n            stck.pop();\\n        }\\n        if(s==\"\")\\n        {\\n            return \"/\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25756,
                "title": "my-5ms-java-solution-without-stack-and-deque-beats-98-of-solutions",
                "content": "First to first, there is no stack or deque used in my solution. The only thing I did is just to transfer original string into char array.\\n\\nMy idea is:\\n Key: Use a counter to count how many times \"..\" appears before we handle a normal string of part of the path.\\n\\n1. go through the char array from end to start\\n2. ignore all '/' characters\\n3. get string between '/'\\n4. handle this string in 4 branches:\\n4.a if it is empty or equals to \".\", do nothing\\n4.b if it is equals to \"..\", counter++\\n4.c if the counter is greater than 0, then counter--\\n4.d else ( counter == 0) do concatenation of result with current part of path.\\n\\nMy code: \\n```\\npublic String simplifyPath(String path) {\\n        String ans = \"\";\\n        char[] chars = path.toCharArray();\\n        int i = chars.length - 1;\\n        // a counter to count how many times \"..\" shows up\\n        int count = 0;  \\n        while ( i >=0) {\\n            int j = i;\\n            while( j >= 0 && chars[j] == '/')\\n                j--;\\n            int k = j;\\n            while(k >=0 && chars[k] != '/')\\n                k--;\\n            String part = String.valueOf(chars, k+1, j-k);\\n            if (part.isEmpty() || part.equals(\".\")){\\n                // do nothing\\n            }\\n            // count appearence of \"..\"\\n            else if(part.equals(\"..\")) \\n                count++;\\n           // ignore current part, \\n           //because there is \"..\" after it\\n           else if (count > 0) \\n                count--;\\n           // count == 0, no need to ignore current part \\n           // and do result concatenation\\n            else\\n                ans = \"/\" + part + ans;\\n            i = k;\\n        }\\n        return ans.isEmpty()? \"/\" : ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "First to first, there is no stack or deque used in my solution. The only thing I did is just to transfer original string into char array.\\n\\nMy idea is:\\n Key: Use a counter to count how many times \"..\" appears before we handle a normal string of part of the path.\\n\\n1. go through the char array from end to start\\n2. ignore all '/' characters\\n3. get string between '/'\\n4. handle this string in 4 branches:\\n4.a if it is empty or equals to \".\", do nothing\\n4.b if it is equals to \"..\", counter++\\n4.c if the counter is greater than 0, then counter--\\n4.d else ( counter == 0) do concatenation of result with current part of path.\\n\\nMy code: \\n```\\npublic String simplifyPath(String path) {\\n        String ans = \"\";\\n        char[] chars = path.toCharArray();\\n        int i = chars.length - 1;\\n        // a counter to count how many times \"..\" shows up\\n        int count = 0;  \\n        while ( i >=0) {\\n            int j = i;\\n            while( j >= 0 && chars[j] == '/')\\n                j--;\\n            int k = j;\\n            while(k >=0 && chars[k] != '/')\\n                k--;\\n            String part = String.valueOf(chars, k+1, j-k);\\n            if (part.isEmpty() || part.equals(\".\")){\\n                // do nothing\\n            }\\n            // count appearence of \"..\"\\n            else if(part.equals(\"..\")) \\n                count++;\\n           // ignore current part, \\n           //because there is \"..\" after it\\n           else if (count > 0) \\n                count--;\\n           // count == 0, no need to ignore current part \\n           // and do result concatenation\\n            else\\n                ans = \"/\" + part + ans;\\n            i = k;\\n        }\\n        return ans.isEmpty()? \"/\" : ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25766,
                "title": "java-solution-without-using-build-in-split-function-beats-over-91",
                "content": "When we encounter \"/\", we try to find the next \"/\" and get the string between them. If it equals \"..\" and the stack is not empty, then we pop one element. If it does not equal \".\" and is not empty, then we can push it into the stack.\\n\\n    public class Solution {\\n        public String simplifyPath(String path) {\\n            StringBuilder sb = new StringBuilder();\\n            Stack<String> stack = new Stack<>();\\n            int i = 0, len = path.length();\\n            while (i < len) {\\n                if (path.charAt(i) == '/') {\\n                    int j = i+1;\\n                    while (j < len && path.charAt(j) != '/') {\\n                        j++;\\n                    }\\n                    String current = path.substring(i+1, j);\\n                    if (current.equals(\"..\")) {\\n                        if (!stack.isEmpty()) {\\n                            stack.pop();\\n                        }\\n                    } else {\\n                        if (!current.equals(\".\") && !current.equals(\"\")) {\\n                            stack.push(current);\\n                        }\\n                    }\\n                    i = j;\\n                }\\n            }\\n            for (String s : stack) {\\n                sb.append(\"/\"+s);\\n            }\\n            return sb.length() == 0 ? \"/\" : sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String simplifyPath(String path) {\\n            StringBuilder sb = new StringBuilder();\\n            Stack<String> stack = new Stack<>();\\n            int i = 0, len = path.length();\\n            while (i < len) {\\n                if (path.charAt(i) == '/') {\\n                    int j = i+1;\\n                    while (j < len && path.charAt(j) != '/') {\\n                        j++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3408403,
                "title": "c-solution-with-approach",
                "content": "# \\u2B06\\uFE0FLike|\\uD83C\\uDFAFShare|\\u2B50Favourite\\n\\n# Approach\\n1. Split the path into parts using \\'/\\' as the delimiter.\\n2. Iterate through the parts and push the parts into a stack.\\n3. If the part is \"..\" then pop the stack.\\n4. If the part is \".\" or \"\" then do nothing.\\n5. If the part is anything else then push it into the stack.\\n6. Iterate through the stack and build the result string.\\n7. Return the result string.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of the path.\\n\\n- Space complexity:\\nO(n) where n is the length of the path.\\n\\n# C# Code\\n```\\npublic class Solution \\n{\\n    public string SimplifyPath(string path)\\n    {\\n        var stack = new Stack<string>();\\n        var parts = path.Split(\\'/\\');\\n        foreach (var part in parts)\\n        {\\n            if (part == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    stack.Pop();\\n                }\\n            }\\n            else if (part != \".\" && part != \"\")\\n            {\\n                stack.Push(part);\\n            }\\n        }\\n        var result = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            result.Insert(0, stack.Pop());\\n            result.Insert(0, \"/\");\\n        }\\n        return result.Length == 0 ? \"/\" : result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string SimplifyPath(string path)\\n    {\\n        var stack = new Stack<string>();\\n        var parts = path.Split(\\'/\\');\\n        foreach (var part in parts)\\n        {\\n            if (part == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    stack.Pop();\\n                }\\n            }\\n            else if (part != \".\" && part != \"\")\\n            {\\n                stack.Push(part);\\n            }\\n        }\\n        var result = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            result.Insert(0, stack.Pop());\\n            result.Insert(0, \"/\");\\n        }\\n        return result.Length == 0 ? \"/\" : result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407220,
                "title": "easy-commented-code-in-c-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n      stack<string> st;\\n        string res = \"\";\\n        for(int i = 0;  i < path.length() ; i++)\\n        {\\n            if(path[i] == \\'/\\') continue; // skip it\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i]; // add the current path\\n                i++;\\n            }\\n            if(temp == \".\") continue; // skip again\\n            else if(temp == \"..\") {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n\\n        while(!st.empty()) {\\n            res = \"/\" + st.top() + res; // adding this way, helps us, that we don\\'t need to reverse the string after that\\n            st.pop();\\n        }\\n        \\n        if(res.size() == 0)  return \"/\"; // if no directory is there \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n      stack<string> st;\\n        string res = \"\";\\n        for(int i = 0;  i < path.length() ; i++)\\n        {\\n            if(path[i] == \\'/\\') continue; // skip it\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i]; // add the current path\\n                i++;\\n            }\\n            if(temp == \".\") continue; // skip again\\n            else if(temp == \"..\") {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n\\n        while(!st.empty()) {\\n            res = \"/\" + st.top() + res; // adding this way, helps us, that we don\\'t need to reverse the string after that\\n            st.pop();\\n        }\\n        \\n        if(res.size() == 0)  return \"/\"; // if no directory is there \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407036,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n    \\n        stack=[]\\n        for a in path.split(\\'/\\'):\\n            if a==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n\\n            elif a not in (\\'\\',\\'.\\'):\\n                stack.append(a)\\n\\n\\n        return \"/\"+\"/\".join(stack)                   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n    \\n        stack=[]\\n        for a in path.split(\\'/\\'):\\n            if a==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n\\n            elif a not in (\\'\\',\\'.\\'):\\n                stack.append(a)\\n\\n\\n        return \"/\"+\"/\".join(stack)                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406942,
                "title": "advance-string-manipulations-split-and-iterate-java",
                "content": "# Intuition\\nThe things you need to keep in mind:\\n- The path will be a valid Unix command. Yes you read that right. Unix path command.\\n- Entering \"../\" will change the current directory to it\\'s parent directory.\\n- Entering \"./\" will stay in the same current directory.\\n- Entering \"x\" will visit the child directory named **x**.\\n\\nNow for the output your result must ensure the following things:\\n- The path starts with a single slash \\'/\\'.\\n- Any two directories are separated by a single slash \\'/\\'.\\n- The path does not end with a trailing \\'/\\'.\\n- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period \\'.\\' or double period \\'..\\')\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## The main idea of this solution is to use a stack. How you decide to process the input string is a personal choice.\\n\\nYour mind is telling you to split the path according to **\"/\"**. So, what are you waiting for? Split it!\\nNow the arrays you found. This array will contain paths. Some of them are simple \"xyz\". Some are **\".\"** . Some are **\"..\"** and some are empty **\"\"**. So, based on these elements we will insert the values in an arraylist.\\n- If we encounter \"..\" we pop the last element from the arraylist.\\n- If we encounter \".\", we do nothing.\\n- In other cases, we insert in the arraylist.\\n\\n# Complexity\\n- Time Complexity: $$O(N)$$ if there are $$N$$ characters in the `path` variable. First, we spend $$O(N)$$ trying to split the input path into components and then we process each component one by one which is again an $$O(N)$$ operation.\\n\\n- Space Complexity: $$O(N)$$. Actually, it\\'s $$2N$$ because we have the array that contains the split components and then we have the arraylist stack.\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        // I didn\\'t know yesterday that we could use vars like this!\\n        var dirs = new ArrayList<String>();\\n        for(var dir : path.split(\"/\")) {\\n            if(dir.isEmpty() || dir.equals(\".\")){\\n                continue;\\n            }\\n            if(dir.equals(\"..\")) {\\n                if(!dirs.isEmpty()){\\n                    dirs.remove(dirs.size()-1);\\n                }\\n            }\\n            else {\\n                dirs.add(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", dirs);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        // I didn\\'t know yesterday that we could use vars like this!\\n        var dirs = new ArrayList<String>();\\n        for(var dir : path.split(\"/\")) {\\n            if(dir.isEmpty() || dir.equals(\".\")){\\n                continue;\\n            }\\n            if(dir.equals(\"..\")) {\\n                if(!dirs.isEmpty()){\\n                    dirs.remove(dirs.size()-1);\\n                }\\n            }\\n            else {\\n                dirs.add(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", dirs);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406744,
                "title": "easy-to-understand-code-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path)\\n    {\\n        //\\'/\\' is used as a marker for end of the previous directory\\n        path.push_back(\\'/\\'); \\n        stack<string>st;\\n        //===============================================================================================\\n        string directory = \"\";\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            if (path[i] == \\'/\\') //for every \\'/\\' try to consider the recorded \"directory\"\\n            {\\n                //==========================================================\\n                if (directory == \"..\") //go  back one directory\\n                {\\n                    if (!st.empty()) st.pop();\\n                }\\n                else if (directory != \".\" && directory != \"\")  //if directory is valid string\\n                    st.push(directory);\\n                //==========================================================\\n                //else if (directory == \".\") => do Nothing [stay in curr directory]\\n                //else if (directory == \"/\") => this will occur when there are consecutive \\'/\\' => doNothing\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);\\n        }\\n        //=============================================================================================\\n        string ans = \"\";\\n        while(!st.empty()) \\n        { \\n            ans = \"/\" + st.top() + ans; \\n            st.pop(); \\n        }\\n        //==============================================================================================\\n        return (ans == \"\" ? \"/\" : ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path)\\n    {\\n        //\\'/\\' is used as a marker for end of the previous directory\\n        path.push_back(\\'/\\'); \\n        stack<string>st;\\n        //===============================================================================================\\n        string directory = \"\";\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            if (path[i] == \\'/\\') //for every \\'/\\' try to consider the recorded \"directory\"\\n            {\\n                //==========================================================\\n                if (directory == \"..\") //go  back one directory\\n                {\\n                    if (!st.empty()) st.pop();\\n                }\\n                else if (directory != \".\" && directory != \"\")  //if directory is valid string\\n                    st.push(directory);\\n                //==========================================================\\n                //else if (directory == \".\") => do Nothing [stay in curr directory]\\n                //else if (directory == \"/\") => this will occur when there are consecutive \\'/\\' => doNothing\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);\\n        }\\n        //=============================================================================================\\n        string ans = \"\";\\n        while(!st.empty()) \\n        { \\n            ans = \"/\" + st.top() + ans; \\n            st.pop(); \\n        }\\n        //==============================================================================================\\n        return (ans == \"\" ? \"/\" : ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847723,
                "title": "c-very-easy-logic-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        path.push_back(\\'/\\');   // to handle cases like \"/...\"\\n        \\n        stack<string> st;   // to hold directories\\n        \\n        string directory = \"\";\\n        for(int i=0; i<path.size(); i++) {\\n            \\n            if( path[i] == \\'/\\' ) {      // push valid directories to stack\\n                if( directory == \"..\" && !st.empty() ) st.pop();\\n                else if( directory != \"\" && directory != \".\" && directory != \"..\") st.push(directory);\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);  // adding chars to directory name until finds any \\'/\\' slash\\n        }\\n        \\n        \\n        // now construct the canonical directory\\n        string result = \"\";\\n        while(!st.empty()) {\\n            result = \"/\"+st.top()+result;\\n            st.pop();\\n        }\\n        \\n        if(result==\"\") return \"/\";\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        path.push_back(\\'/\\');   // to handle cases like \"/...\"\\n        \\n        stack<string> st;   // to hold directories\\n        \\n        string directory = \"\";\\n        for(int i=0; i<path.size(); i++) {\\n            \\n            if( path[i] == \\'/\\' ) {      // push valid directories to stack\\n                if( directory == \"..\" && !st.empty() ) st.pop();\\n                else if( directory != \"\" && directory != \".\" && directory != \"..\") st.push(directory);\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);  // adding chars to directory name until finds any \\'/\\' slash\\n        }\\n        \\n        \\n        // now construct the canonical directory\\n        string result = \"\";\\n        while(!st.empty()) {\\n            result = \"/\"+st.top()+result;\\n            st.pop();\\n        }\\n        \\n        if(result==\"\") return \"/\";\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050588,
                "title": "python-stack",
                "content": "The idea is that when we see a `..` we are going up, so the last element should be removed (if it exists), which is implemented by stack.\\n\\n```python\\nclass Solution:\\n    def simplifyPath(self, path):\\n        s = []\\n        for x in path.split(\\'/\\'):\\n            if not x: \\n                continue\\n            elif x == \\'.\\':\\n                continue\\n            elif x == \\'..\\':\\n                if s:\\n                    s.pop()\\n            else:\\n                s.append(x)\\n        return \\'/\\' + \\'/\\'.join(s)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def simplifyPath(self, path):\\n        s = []\\n        for x in path.split(\\'/\\'):\\n            if not x: \\n                continue\\n            elif x == \\'.\\':\\n                continue\\n            elif x == \\'..\\':\\n                if s:\\n                    s.pop()\\n            else:\\n                s.append(x)\\n        return \\'/\\' + \\'/\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200362,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        istringstream ss(path);\\n        string tempPath;\\n        vector<string> stack;\\n        while(getline(ss,tempPath,\\'/\\')){\\n            if(tempPath == \".\" || tempPath.empty()){\\n                continue;\\n            }else if(tempPath == \"..\"){\\n                if(stack.empty() == false)\\n                    stack.pop_back();\\n            }else{\\n                stack.push_back(tempPath);\\n            }\\n        }\\n        \\n        string result;\\n        for(auto &s : stack){\\n            result += \"/\" + s;\\n        }\\n        \\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        istringstream ss(path);\\n        string tempPath;\\n        vector<string> stack;\\n        while(getline(ss,tempPath,\\'/\\')){\\n            if(tempPath == \".\" || tempPath.empty()){\\n                continue;\\n            }else if(tempPath == \"..\"){\\n                if(stack.empty() == false)\\n                    stack.pop_back();\\n            }else{\\n                stack.push_back(tempPath);\\n            }\\n        }\\n        \\n        string result;\\n        for(auto &s : stack){\\n            result += \"/\" + s;\\n        }\\n        \\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25697,
                "title": "3-lines-javascript-don-t-do-this-in-interviews",
                "content": "Standard stack-based solution, compressed just to make it into 3 lines. Don't do this in interviews.\\n```\\nvar simplifyPath = function(path) {\\n    const stack = [], tokens = path.split('/').filter(t => !['/', '', '.'].includes(t));\\n    tokens.forEach(t => t === '..' ? stack.pop() : stack.push(t));\\n    return '/' + stack.join('/');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar simplifyPath = function(path) {\\n    const stack = [], tokens = path.split('/').filter(t => !['/', '', '.'].includes(t));\\n    tokens.forEach(t => t === '..' ? stack.pop() : stack.push(t));\\n    return '/' + stack.join('/');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25814,
                "title": "java-solution-with-one-stack",
                "content": "General idea: Split the string by slash first and then, using a stack to store the name of directory. There are totally 5 situations when looping through the array:\\n\\n - If elem is empty string, then it means we either meet multiple slashes (\"//\", \"///\"...) or it is the start point. For this case, simply ignore and continue;\\n - If elem is \".\", then we have to stay in current directory, as the same as case 1), do nothing and continue;\\n - If elem is \"..\" and stack is not empty, then we have to go back to parent directory. For this case, simply pop the top element from stack;\\n - If elem has a name (\"home\", \"desktop\"...), push it to stack.\\n - For all other cases, do nothing and continue.\\n\\nWhen pop up elem from stack to get result, there is a special case: If stack is empty, then it means input string is \"/../\" or \"/\", or others which lead us staying in current directory. For this case, simply return \"/\".\\n\\n    public class Solution {\\n        public String simplifyPath(String path) {\\n            String[] arr = path.split(\"/\");\\n            Stack<String> stack = new Stack<>();\\n            for (int i = 0; i < arr.length; i++) {\\n                if (\"\".equals(arr[i]) || \".\".equals(arr[i])) continue;\\n                if (\"..\".equals(arr[i]) && !stack.isEmpty()) stack.pop();\\n                else if (!\"..\".equals(arr[i])) stack.push(arr[i]);\\n            }\\n            if (stack.isEmpty()) return \"/\";\\n            String result = \"\";\\n            while (!stack.isEmpty()) result = \"/\" + stack.pop() + result;\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n        public String simplifyPath(String path) {\\n            String[] arr = path.split(\"/\");\\n            Stack<String> stack = new Stack<>();\\n            for (int i = 0; i < arr.length; i++) {\\n                if (\"\".equals(arr[i]) || \".\".equals(arr[i])) continue;\\n                if (\"..\".equals(arr[i]) && !stack.isEmpty()) stack.pop();\\n                else if (!\"..\".equals(arr[i])) stack.push(arr[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25816,
                "title": "my-simple-c-code",
                "content": "    string simplifyPath(string path) {\\n            const char* p = path.c_str();\\n            string res = \"/\";\\n            vector<string> full_path;\\n            char* addr = strtok((char*)p, \"/\");\\n            int cur = 0, size = 0;\\n            while(addr) {\\n                if(strcmp(addr, \".\") == 0) {\\n                }       \\n                else if(strcmp(addr, \"..\") == 0) {\\n                    cur > 0 ? cur-- : cur;\\n                }    \\n                else {\\n                    if(cur == size) {\\n                        full_path.push_back(addr);\\n                        cur++;\\n                        size++;\\n                    }\\n                    else {\\n                        full_path[cur++] = addr;\\n                    }\\n                }     \\n                addr = strtok(NULL, \"/\");\\n            }\\n            for(int i=0; i<cur; i++) {\\n                res = res + full_path[i] + \"/\";\\n            }\\n            return res.size() == 1 ? res : res.substr(0, res.size() - 1);\\n    }",
                "solutionTags": [],
                "code": "    string simplifyPath(string path) {\\n            const char* p = path.c_str();\\n            string res = \"/\";\\n            vector<string> full_path;\\n            char* addr = strtok((char*)p, \"/\");\\n            int cur = 0, size = 0;\\n            while(addr) {\\n                if(strcmp(addr, \".\") == 0) {\\n                }       \\n                else if(strcmp(addr, \"..\") == 0) {\\n                    cur > 0 ? cur-- : cur;\\n                }    \\n                else {\\n                    if(cur == size) {\\n                        full_path.push_back(addr);\\n                        cur++;\\n                        size++;\\n                    }\\n                    else {\\n                        full_path[cur++] = addr;\\n                    }\\n                }     \\n                addr = strtok(NULL, \"/\");\\n            }\\n            for(int i=0; i<cur; i++) {\\n                res = res + full_path[i] + \"/\";\\n            }\\n            return res.size() == 1 ? res : res.substr(0, res.size() - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3767647,
                "title": "java-easy-solution-using-stack",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n      Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories) { \\n            if (dir.equals(\".\") || dir.isEmpty()) continue;\\n            else if (dir.equals(\"..\")) { \\n                if (!stack.isEmpty())\\n                    stack.pop();\\n            }\\n            else\\n                stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);   \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n      Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories) { \\n            if (dir.equals(\".\") || dir.isEmpty()) continue;\\n            else if (dir.equals(\"..\")) { \\n                if (!stack.isEmpty())\\n                    stack.pop();\\n            }\\n            else\\n                stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409586,
                "title": "most-optimal-solution-using-stack-complete-approach-explained",
                "content": "\\n\\n# Approach\\nThe solution first initializes an empty stack to keep track of the directories on the simplified path. It then uses a stringstream to split the input path into individual directory names, and iterates over them one by one.\\n\\nIf the directory name is empty (which can happen due to consecutive slashes in the input path) or equal to \".\", we can skip it and move on to the next directory.\\n\\nIf the directory name is \"..\", we need to move up one level in the directory hierarchy. To do this, we simply pop the last directory from the stack (if it\\'s not empty).\\n\\nIf the directory name is any other valid directory name, we push it onto the stack.\\n\\nOnce we\\'ve processed all the directories on the input path, we need to construct the simplified path by popping the directories from the stack in reverse order and concatenating them with a slash separator. We also need to add a leading slash to the simplified path.\\n\\nIf the stack is empty (which can happen if the input path only contains \".\" or \"..\" directories), we simply return a single slash as the simplified path.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string directory, result;\\n        while (getline(ss, directory, \\'/\\')) {\\n            if (directory == \"\" || directory == \".\") {\\n                continue;\\n            } else if (directory == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(directory);\\n            }\\n        }\\n        while (!s.empty()) {\\n            result = \"/\" + s.top() + result;\\n            s.pop();\\n        }\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string directory, result;\\n        while (getline(ss, directory, \\'/\\')) {\\n            if (directory == \"\" || directory == \".\") {\\n                continue;\\n            } else if (directory == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(directory);\\n            }\\n        }\\n        while (!s.empty()) {\\n            result = \"/\" + s.top() + result;\\n            s.pop();\\n        }\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409341,
                "title": "easy-python-solution-98-runtime",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path=[i for i in path if i and i!=\"/\" and i!=\".\"]\\n        for i in path:\\n            if i==\"..\" and stack:\\n                stack.pop()\\n            elif i!=\"..\":\\n                stack.append(i)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path=[i for i in path if i and i!=\"/\" and i!=\".\"]\\n        for i in path:\\n            if i==\"..\" and stack:\\n                stack.pop()\\n            elif i!=\"..\":\\n                stack.append(i)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409173,
                "title": "java-stack-simplify-path",
                "content": "\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int start = 0;\\n        int end = 0;\\n        while (end < path.length())\\n        {\\n            start = end;\\n            if (path.charAt(end) == \\'.\\') {\\n                start = end;\\n                while (end < path.length() && path.charAt(end) == \\'.\\')\\n                    end++;\\n                if (end - start == 1 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else if (end - start == 2 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    stack.remove(stack.size() - 1);\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else\\n                {\\n                    while (end < path.length() && path.charAt(end) != \\'/\\')\\n                        end++;\\n                    stack.add(path.substring(start,end));\\n                }\\n\\n            }\\n            else if (path.charAt(end) == \\'/\\')\\n            {\\n                if (stack.isEmpty() || !stack.get(stack.size() - 1).equals(\"/\") && end != path.length() - 1)\\n                    stack.add(path.substring(start,end + 1));\\n                end++;\\n            }\\n            else\\n            {\\n                start = end;\\n                while (end < path.length() &&  path.charAt(end) != \\'/\\')\\n                    end++;\\n                if (start != end) stack.add(path.substring(start,end));\\n            }\\n        }\\n        if (stack.isEmpty()) return \"/\";\\n        else if (stack.size() > 1 && stack.get(stack.size() - 1).equals(\"/\")) stack.remove(stack.size() - 1);\\n        StringBuilder srr = new StringBuilder();\\n        for (String d : stack)\\n            srr.append(d);\\n        return srr.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int start = 0;\\n        int end = 0;\\n        while (end < path.length())\\n        {\\n            start = end;\\n            if (path.charAt(end) == \\'.\\') {\\n                start = end;\\n                while (end < path.length() && path.charAt(end) == \\'.\\')\\n                    end++;\\n                if (end - start == 1 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else if (end - start == 2 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    stack.remove(stack.size() - 1);\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else\\n                {\\n                    while (end < path.length() && path.charAt(end) != \\'/\\')\\n                        end++;\\n                    stack.add(path.substring(start,end));\\n                }\\n\\n            }\\n            else if (path.charAt(end) == \\'/\\')\\n            {\\n                if (stack.isEmpty() || !stack.get(stack.size() - 1).equals(\"/\") && end != path.length() - 1)\\n                    stack.add(path.substring(start,end + 1));\\n                end++;\\n            }\\n            else\\n            {\\n                start = end;\\n                while (end < path.length() &&  path.charAt(end) != \\'/\\')\\n                    end++;\\n                if (start != end) stack.add(path.substring(start,end));\\n            }\\n        }\\n        if (stack.isEmpty()) return \"/\";\\n        else if (stack.size() > 1 && stack.get(stack.size() - 1).equals(\"/\")) stack.remove(stack.size() - 1);\\n        StringBuilder srr = new StringBuilder();\\n        for (String d : stack)\\n            srr.append(d);\\n        return srr.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407225,
                "title": "easy-python-solution-using-stacks-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        paths = path.split(\\'/\\')\\n        st = []\\n        for path in paths:\\n            if path != \"\" and path != \"..\" and path !=\".\":\\n                st.append(path)\\n            if path == \"..\" and len(st) > 0:\\n                st.pop()\\n        print(st)\\n        return \"/\"+\"/\".join(st)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        paths = path.split(\\'/\\')\\n        st = []\\n        for path in paths:\\n            if path != \"\" and path != \"..\" and path !=\".\":\\n                st.append(path)\\n            if path == \"..\" and len(st) > 0:\\n                st.pop()\\n        print(st)\\n        return \"/\"+\"/\".join(st)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406726,
                "title": "java-stack-8-lines-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String simplifyPath(String path) {\\n    var stack = new Stack<String>();\\n\\n    for (var s : path.split(\"/\")) {\\n      if (s.equals(\"..\")) {\\n        if (!stack.empty())\\n          stack.pop();\\n      } else if (!s.equals(\".\") && !s.equals(\"\")) {\\n        stack.push(s);\\n      }\\n    }\\n    return \"/\" + String.join(\"/\", stack);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n  public String simplifyPath(String path) {\\n    var stack = new Stack<String>();\\n\\n    for (var s : path.split(\"/\")) {\\n      if (s.equals(\"..\")) {\\n        if (!stack.empty())\\n          stack.pop();\\n      } else if (!s.equals(\".\") && !s.equals(\"\")) {\\n        stack.push(s);\\n      }\\n    }\\n    return \"/\" + String.join(\"/\", stack);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406716,
                "title": "one-liner-two-solutions-14-ms-98-77-easy-to-understand",
                "content": "# Seven-liner\\n\\n14 ms 98.77%\\n\\n```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").reduce(into: [Substring]()) {\\n        switch $1 {\\n        case \".\": return\\n        case \"..\": _ = $0.popLast()\\n        default: $0.append($1)\\n        }\\n    }.joined(separator: \"/\")\\n}\\n```\\n\\n# One-liner\\n\\n14 ms 98.77%\\n\\n```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").filter { $0 != \".\" }.reduce(into: [Substring]()) { if $1 == \"..\" { _ = $0.popLast() } else { $0.append($1) } }.joined(separator: \"/\")\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").reduce(into: [Substring]()) {\\n        switch $1 {\\n        case \".\": return\\n        case \"..\": _ = $0.popLast()\\n        default: $0.append($1)\\n        }\\n    }.joined(separator: \"/\")\\n}\\n```\n```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").filter { $0 != \".\" }.reduce(into: [Substring]()) { if $1 == \"..\" { _ = $0.popLast() } else { $0.append($1) } }.joined(separator: \"/\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406710,
                "title": "10-lines-code-using-stringstream",
                "content": "# **Please Upvote Me \\uD83E\\uDD79**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // creating answer string to store the final ans\\n        string result=\"\", token;\\n\\n        // using stringstream\\n        // << : using to add into the string\\n        // >> : used to read from the string\\n        stringstream ss(path);\\n        vector<string> tokens;\\n\\n        while(getline(ss, token, \\'/\\')){\\n            if(token==\".\" || token==\"\") \\n                continue;\\n            else if(token==\"..\"){\\n                if(tokens.size()!=0)  tokens.pop_back();\\n            }\\n            else{\\n                tokens.push_back(token);\\n            }\\n        }\\n\\n        if(tokens.size()==0) \\n            return \"/\";\\n\\n        for(int i=0; i<tokens.size(); ++i)\\n            result=result+\\'/\\'+tokens[i];\\n            \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // creating answer string to store the final ans\\n        string result=\"\", token;\\n\\n        // using stringstream\\n        // << : using to add into the string\\n        // >> : used to read from the string\\n        stringstream ss(path);\\n        vector<string> tokens;\\n\\n        while(getline(ss, token, \\'/\\')){\\n            if(token==\".\" || token==\"\") \\n                continue;\\n            else if(token==\"..\"){\\n                if(tokens.size()!=0)  tokens.pop_back();\\n            }\\n            else{\\n                tokens.push_back(token);\\n            }\\n        }\\n\\n        if(tokens.size()==0) \\n            return \"/\";\\n\\n        for(int i=0; i<tokens.size(); ++i)\\n            result=result+\\'/\\'+tokens[i];\\n            \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225748,
                "title": "simplifying-unix-style-absolute-paths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we need to construct the simplified canonical path from the input path string. We can use a stack to keep track of the directories on the canonical path as we process the input path string. For each directory name, we need to handle three cases: \".\" (current directory), \"..\" (parent directory), and other directory names.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by initializing an empty stack to store the directories on the canonical path. Then, we split the input path string by slashes (\"/\") to get the individual directory names. For each directory name, we do the following:\\n\\n- If the directory name is \".\", we simply skip it (as it refers to the current directory).\\n- If the directory name is \"..\", we pop the top directory from the stack (as it refers to the parent directory).\\n- Otherwise, we push the directory name onto the stack.\\nAt the end, we can construct the simplified canonical path by joining the directories in the stack with slashes and adding a leading slash.\\n# Complexity\\n- Time complexity: The time complexity of the solution is $$O(n)$$, where n is the length of the input path string, since we need to process each directory name in the path string once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the solution is $$O(n)$$, where n is the length of the input path string, since we need to store the directories on the canonical path in the stack. In the worst case, when all directories in the path string are valid directory names (i.e., no \".\" or \"..\"), the stack can have a maximum size of n/2 (when the input path string has alternating directory names and slashes).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        for directory in path.split(\"/\"):\\n            if directory == \"\" or directory == \".\":\\n                continue\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n        return \"/\" + \"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        for directory in path.split(\"/\"):\\n            if directory == \"\" or directory == \".\":\\n                continue\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171817,
                "title": "c-easy-dequeue-o-n-0ms-beats-100-with-explanation",
                "content": "# Approach\\nWe can iterate over the given string and store the string between two `\\'/\\'` inside a dequeue. This stored string can be one of the 3 possible nature.\\n\\n    1) It can be a normal file or folder name.\\n       In this can we will push it at the back of our dequeue. \\n    2) It can be a \".\"\\n       In this can we will just ignore it.\\n    3) It can be \"..\"\\n       In this can we will pop the latest element from the back of our dequeue if it is not empty.\\n\\n\\nIf after `\\'/\\'` we encounter another `\\'/\\'` we can ignore it. \\n\\nThen, after the iteration of whole string is complete, we will run a while loop till the `dequeue` is not empty to store the string present at the front of our `dequeue` to our answer and then pop that front string from our `dequeue`.\\nAfter each addition of string we will seperate the next one by adding `\\'/\\'`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        deque<string> s;\\n        int i = 0;\\n\\n        while(i<path.size())\\n        {\\n            if(path[i] == \\'/\\')i++;\\n            else\\n            {\\n                string str = \"\";\\n                while(i<path.size() && path[i] != \\'/\\')\\n                {\\n                    str += path[i];i++;\\n                }\\n                if(str == \"..\")\\n                {\\n                    if(!s.empty())s.pop_back();\\n                }\\n                else if(str != \".\") s.push_back(str);\\n            }\\n        }\\n\\n        string ans = \"/\";\\n        while(!s.empty())\\n        {\\n            ans += s.front();\\n            ans += \\'/\\';\\n            s.pop_front();\\n        }\\n        if(ans.size()>1)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        deque<string> s;\\n        int i = 0;\\n\\n        while(i<path.size())\\n        {\\n            if(path[i] == \\'/\\')i++;\\n            else\\n            {\\n                string str = \"\";\\n                while(i<path.size() && path[i] != \\'/\\')\\n                {\\n                    str += path[i];i++;\\n                }\\n                if(str == \"..\")\\n                {\\n                    if(!s.empty())s.pop_back();\\n                }\\n                else if(str != \".\") s.push_back(str);\\n            }\\n        }\\n\\n        string ans = \"/\";\\n        while(!s.empty())\\n        {\\n            ans += s.front();\\n            ans += \\'/\\';\\n            s.pop_front();\\n        }\\n        if(ans.size()>1)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673403,
                "title": "python3-easy-to-understand-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(path):\\n            cur = path[i]\\n            i += 1\\n            if cur == \\'/\\':\\n                while i < len(path) and path[i] == \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n            else:\\n                while i < len(path) and path[i] != \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n                    \\n            if cur == \\'..\\': \\n                if stack: stack.pop()\\n            elif cur[0] != \\'/\\' and cur != \\'.\\': \\n                stack.append(cur)\\n        \\n        res = \\'\\'\\n        for s in stack: res += \\'/\\' + s\\n            \\n        return res if res else \\'/\\'\\n\\n    \\n    \\n    \\n\\'\\'\\'Test Cases:\\n\\n\"/home/\"\\n\"/../\"\\n\"/home//foo/\"\\n\"/a/./b/../../c/\"\\n\"/a//b////c/d//././/..\"\\n\"/...\"\\n\"/..hidden\"\\n\"/a/../../b/../c//.//\"\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(path):\\n            cur = path[i]\\n            i += 1\\n            if cur == \\'/\\':\\n                while i < len(path) and path[i] == \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n            else:\\n                while i < len(path) and path[i] != \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n                    \\n            if cur == \\'..\\': \\n                if stack: stack.pop()\\n            elif cur[0] != \\'/\\' and cur != \\'.\\': \\n                stack.append(cur)\\n        \\n        res = \\'\\'\\n        for s in stack: res += \\'/\\' + s\\n            \\n        return res if res else \\'/\\'\\n\\n    \\n    \\n    \\n\\'\\'\\'Test Cases:\\n\\n\"/home/\"\\n\"/../\"\\n\"/home//foo/\"\\n\"/a/./b/../../c/\"\\n\"/a//b////c/d//././/..\"\\n\"/...\"\\n\"/..hidden\"\\n\"/a/../../b/../c//.//\"\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540337,
                "title": "java-stack-simple",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> st = new Stack();\\n        boolean period = false;\\n        \\n        String[] s = path.split(\"/\");\\n        \\n        for(String str : s){\\n            \\n            if(str.equals(\".\") || str.equals(\"\") || str.equals(\" \"))continue;\\n            \\n            else if(str.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(\"/\" + str);\\n            }\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            \\n            ans = st.pop() + ans;\\n        }\\n       \\n        if(ans.equals(\"\"))return \"/\";\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> st = new Stack();\\n        boolean period = false;\\n        \\n        String[] s = path.split(\"/\");\\n        \\n        for(String str : s){\\n            \\n            if(str.equals(\".\") || str.equals(\"\") || str.equals(\" \"))continue;\\n            \\n            else if(str.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(\"/\" + str);\\n            }\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            \\n            ans = st.pop() + ans;\\n        }\\n       \\n        if(ans.equals(\"\"))return \"/\";\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462799,
                "title": "c-easy-solution-using-stack",
                "content": "**Approach:- \\n1. Iterate over the string .\\n2. if we got \"/\" , continue .\\n3. Now we need a temp string to store the character between  the two \"/\" , so do store in tmp while we didn\\'t get \"/\".\\n4. If we got temp as only single dot(.) , we need to contiue , it can\\'t be included in our answer.\\n5. If we go temp as double dot , in this case we need to pop from the stack if it is not empty  as double dot means a level up for that .\\n6. At last ,if above two conditions doesn\\'t meant , it means we got tmp , it will be included in our answer , so now push into the stack.****\\n\\nIn the stack , we got those string which are in the  path i.e,\\nAs In stack , elements follow LIFO method , but our answer should have value from the starting . \\nNow , we have anyhow need to put in answer from starting..\\nso we will put answer as answer = \"/\" + st.top()+ answer.\\nIt will take O(N+ N) time for resulting string to be return by popping out elements from stack.\\n\\n\\n**Please UPVOTE if find helpful.**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        stack<string>st;\\n        string ans;\\n        int n=s.size();\\n        // Iterating through the string s\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'/\\') continue;\\n            string tmp;\\n            while(i<n && s[i]!=\\'/\\') \\n\\t\\t\\t  tmp+=s[i++];            \\n            if(tmp==\".\") continue;\\n            else if(tmp==\"..\"){\\n                  if(!st.empty()) \\n                      st.pop();\\n            }\\n            else\\n               st.push(tmp);\\n            }\\n        while(!st.empty()){\\n            ans=\"/\"+ st.top()+ans;\\n            st.pop();\\n        }\\n        \\n         if(ans.size()==0)return \"/\";\\n        \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        stack<string>st;\\n        string ans;\\n        int n=s.size();\\n        // Iterating through the string s\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'/\\') continue;\\n            string tmp;\\n            while(i<n && s[i]!=\\'/\\') \\n\\t\\t\\t  tmp+=s[i++];            \\n            if(tmp==\".\") continue;\\n            else if(tmp==\"..\"){\\n                  if(!st.empty()) \\n                      st.pop();\\n            }\\n            else\\n               st.push(tmp);\\n            }\\n        while(!st.empty()){\\n            ans=\"/\"+ st.top()+ans;\\n            st.pop();\\n        }\\n        \\n         if(ans.size()==0)return \"/\";\\n        \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285456,
                "title": "71-simplify-path-c-with-comments-and-explanation",
                "content": "\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring simplifyPath(string path) {\\n\\t\\t\\tstring canonicalPath = \"\"; //for creating the final path / answer\\n\\t\\t\\tstring curr = \"\"; //to build the current directory\\n\\t\\t\\tstack<string> s; //for implementing \"..\" -> POP feature (to go to the directory up a level)\\n\\t\\t\\tpath += \"/\"; //(**IMP) we add this so that the last directory gets added in case the input doesn\\'t end with \"/\"\\n\\t\\t\\t//example for the above case - \"/a//b////c/d//././/..\"\\n\\t\\t\\tfor(int i=0;i<path.length();i++){\\n\\t\\t\\t\\tif(path[i] == \\'/\\'){ //we have some cases when we find \"/\" \\n\\t\\t\\t\\t\\tif(curr == \"..\"){ //here we have to implement pop to to the directory up a level\\n\\t\\t\\t\\t\\t\\tif(!s.empty()) s.pop(); //check if the stack is already empty , in that case no need to do anything\\n\\t\\t\\t\\t\\t} else if(curr != \".\" and curr!= \"\"){ //we do nothing if curr directory which we built is \".\" or is empty\\n\\t\\t\\t\\t\\t\\ts.push(curr); //push the directory into the stack\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr = \"\"; //resetting the curr string after a directory is successfully added into the stack in order to build a new directory\\n\\t\\t\\t\\t} else { //keep building the current string / directory\\n\\t\\t\\t\\t\\tcurr += path[i]; //add the character to build the current directory\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//by here : - Example : IP - \"/home//foo/\" \\n\\t\\t\\t//our stack now contains - |foo | or \"fool\",\"home\" top to down \\n\\t\\t\\t//                         |home|\\n\\t\\t\\t//now we have to start building our final answer , i.e string canonicalPath\\n\\t\\t\\twhile(!s.empty()){\\n\\t\\t\\t\\tcanonicalPath = \"/\"+s.top()+canonicalPath;\\n\\t\\t\\t\\ts.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//incase our final answer is empty, then we add a condition to return \"/\" as the path always starts with a single slash \"/\"\\n\\t\\t\\tif(canonicalPath.length() == 0){\\n\\t\\t\\t\\treturn \"/\";\\n\\t\\t\\t} else { //return our final answer\\n\\t\\t\\t\\treturn canonicalPath;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring simplifyPath(string path) {\\n\\t\\t\\tstring canonicalPath = \"\"; //for creating the final path / answer\\n\\t\\t\\tstring curr = \"\"; //to build the current directory\\n\\t\\t\\tstack<string> s; //for implementing \"..\" -> POP feature (to go to the directory up a level)\\n\\t\\t\\tpath += \"/\"; //(**IMP) we add this so that the last directory gets added in case the input doesn\\'t end with \"/\"\\n\\t\\t\\t//example for the above case - \"/a//b////c/d//././/..\"\\n\\t\\t\\tfor(int i=0;i<path.length();i++){\\n\\t\\t\\t\\tif(path[i] == \\'/\\'){ //we have some cases when we find \"/\" \\n\\t\\t\\t\\t\\tif(curr == \"..\"){ //here we have to implement pop to to the directory up a level\\n\\t\\t\\t\\t\\t\\tif(!s.empty()) s.pop(); //check if the stack is already empty , in that case no need to do anything\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2100643,
                "title": "java-solution-using-stack-explanation",
                "content": "let\\'s assume that the given string is \"/home/foo/./java/../bar/\"\\nfirstly we will go to directory home so i push home to stack \\n<img src = \"https://assets.leetcode.com/users/images/6f8513dc-8d89-44f2-84b8-4b2d28a3587c_1654142299.084013.png\" width = \"600\">\\n\\nthen next i will go to directory foo(inside home) to stack\\n<img src=\"https://assets.leetcode.com/users/images/6ae56263-ff30-4628-a7bc-f06f41b6c2ed_1654142398.4118161.png\" width = \"600\">\\n\\n after that i have \".\" in the string so i simply ignore that and proceed to go to java directory \\n<img src=\"https://assets.leetcode.com/users/images/8efc44e9-5206-4f34-b3f7-4b444bb88f11_1654142455.4679081.png\" width =\"600\" >\\n\\nafter that i see\"..\" which means go 1 step back so i pop out last directory entered\\n<img src=\"https://assets.leetcode.com/users/images/b1af2191-6293-4c21-8935-0a3c927b1acc_1654142508.964751.png\" width = \"600\">\\n\\nfinally i go to bar directory and push it\\n<img src=\"https://assets.leetcode.com/users/images/50406caa-7ae0-457e-bd55-a90ff56c8631_1654142572.1674197.png\" width = \"600\">\\n\\nso in the end i have to pop all the enteries in the stack and the top item should be there at the end of string \\n\\nProcedure - \\n- first get all the substrings within \"/\" \\n- if the substring is \".\" then ignore and if it is \"..\" then pop the last element of stack if stack is not empty!\\n- if the above condition not satisfy then simply push the value into stack\\n- finally pop out last value and add it to answer string as -> ``` answer = \"/\" + top value of stack + answer``` \\n- one cornor case when we haven\\'t pushed anthing into stack then simply return \"/\"\\n\\n**If you find this useful then please upvote**\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stk = new Stack<>();\\n        String ans = \"\";\\n        int record = 0;\\n        for(int i = 0 ; i < path.length(); ++i){\\n            if(path.charAt(i) == \\'/\\')\\n                continue;\\n            String temp = \"\"; // make temp string = 0 everytime\\n            while(i<path.length() && path.charAt(i) != \\'/\\'){\\n                temp += path.charAt(i);\\n                ++i;\\n            }\\n            switch(temp){\\n                case \".\":\\n                    // ++i;\\n                    break;\\n                case \"..\":\\n                    if(!stk.isEmpty()) stk.pop();\\n                    break;\\n                default:\\n                    stk.push(temp);\\n            }\\n        }\\n            \\n        while(!stk.isEmpty()){\\n            ans = \"/\"+ stk.pop() + ans ;\\n        }\\n        return (ans.length() == 0 ) ? \"/\" : ans;\\n    }\\n}\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "``` answer = \"/\" + top value of stack + answer```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stk = new Stack<>();\\n        String ans = \"\";\\n        int record = 0;\\n        for(int i = 0 ; i < path.length(); ++i){\\n            if(path.charAt(i) == \\'/\\')\\n                continue;\\n            String temp = \"\"; // make temp string = 0 everytime\\n            while(i<path.length() && path.charAt(i) != \\'/\\'){\\n                temp += path.charAt(i);\\n                ++i;\\n            }\\n            switch(temp){\\n                case \".\":\\n                    // ++i;\\n                    break;\\n                case \"..\":\\n                    if(!stk.isEmpty()) stk.pop();\\n                    break;\\n                default:\\n                    stk.push(temp);\\n            }\\n        }\\n            \\n        while(!stk.isEmpty()){\\n            ans = \"/\"+ stk.pop() + ans ;\\n        }\\n        return (ans.length() == 0 ) ? \"/\" : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850695,
                "title": "c-superfast-100-faster-solution-using-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string>s;\\n        int n=path.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            string ch=\"\";\\n            bool flag=false;\\n            int c=0;\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                if(path[i]>=\\'a\\' && path[i]<=\\'z\\' || path[i]>=\\'A\\' && path[i]<=\\'Z\\')\\n                {\\n                    flag=true;\\n                }else if(path[i]==\\'.\\')\\n                {\\n                    c++;\\n                }\\n                ch+=path[i];\\n                i++;\\n                // cout<<ch<<endl;\\n            }\\n            if(c==2 && !s.empty())\\n            {\\n                s.pop();\\n            }else if(c>2 || flag)\\n            {\\n                s.push(ch);\\n            }\\n            // i--;\\n        }\\n        if(s.empty())return \"/\";\\n        \\n        string ans=\"\";\\n        stack<string>st;\\n        while(!s.empty())\\n        {\\n            st.push(s.top());\\n            s.pop();\\n        }\\n\\t\\t//make another stack \\n        while(!st.empty())\\n        {\\n            ans+=\\'/\\';\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string>s;\\n        int n=path.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            string ch=\"\";\\n            bool flag=false;\\n            int c=0;\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                if(path[i]>=\\'a\\' && path[i]<=\\'z\\' || path[i]>=\\'A\\' && path[i]<=\\'Z\\')\\n                {\\n                    flag=true;\\n                }else if(path[i]==\\'.\\')\\n                {\\n                    c++;\\n                }\\n                ch+=path[i];\\n                i++;\\n                // cout<<ch<<endl;\\n            }\\n            if(c==2 && !s.empty())\\n            {\\n                s.pop();\\n            }else if(c>2 || flag)\\n            {\\n                s.push(ch);\\n            }\\n            // i--;\\n        }\\n        if(s.empty())return \"/\";\\n        \\n        string ans=\"\";\\n        stack<string>st;\\n        while(!s.empty())\\n        {\\n            st.push(s.top());\\n            s.pop();\\n        }\\n\\t\\t//make another stack \\n        while(!st.empty())\\n        {\\n            ans+=\\'/\\';\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1848608,
                "title": "stack-solution-with-easy-detailed-explanation",
                "content": "[Leetcode](https://leetcode.com/) [71. Simplify Path](https://leetcode.com/problems/simplify-path/).\\n\\n***By Frank Luo***\\n\\n# Intuition  \\n\\nWe can just **simulate** the process from the begin to end.\\n\\nFirst we split the given string $\\\\textit{path}$ into a list of strings by the slash $/$, denoted as `names`. According to the **canonical path** in the problem description, the strings contained in `names` can only be the following:\\n\\n1. empty string;\\n2. a dot `.`;\\n3. two dots `..`;\\n4. a directory name containing only English letters, numbers, or `_`.\\n\\nIf we meet empty string or `.`, we can ignore them because empty string means nothing, and `.` means the current directory itself, so we don\\'t need to change directories.\\n\\nIf we meet `..` or \"directory names\", we can use a **Stack** to maintain each directory name in the path. When we encounter \"two dots\", we need to change the directory to the parent directory. As the stack is not empty, we pop the directory of the stack. When we encounter a \"directory\", we put it to the stack.\\n\\nFinally we need to iterate each string in `names` and do the above. After all operations are completed, we connect the strings from the bottom of the stack to the top of the stack with `/`, and then add `/` at the top to indicate the root directory, and we can get the simplified Canonical path.\\n\\n\\n```java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null || path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        Stack<String> pathStack = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n        path = path.replaceAll(\"\\\\\\\\/\\\\\\\\/\", \"/\");\\n        String[] folders = path.split(\"\\\\\\\\/\");\\n        int len = folders.length;\\n        for (int i = 0; i < len; i++) {\\n            String folder = folders[i];\\n            if (folder.equalsIgnoreCase(\".\")) {\\n                continue;\\n            } else if (folder.equalsIgnoreCase(\"..\")) {\\n                if (!pathStack.empty()) {\\n                    pathStack.pop();\\n                }\\n            } else if (folder.length() > 0) {\\n                pathStack.push(folder);\\n            }\\n        }\\n\\n        ans.append(\\'/\\');\\n        List<String> res = new ArrayList<>();\\n        while (!pathStack.empty()) {\\n            res.add(pathStack.pop());\\n        }\\n\\n        for (int i = res.size() - 1; i >= 0; i--) {\\n            ans.append(res.get(i));\\n            ans.append(\"/\");\\n        }\\n\\n        if (ans.length() > 1 && ans.charAt(ans.length() - 1) == \\'/\\') {\\n            ans.deleteCharAt(ans.length() - 1);\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```\\n\\n\\n```python []\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        ans = []\\n        for p in path.split(\"/\"):\\n            if p == \"..\" and ans:\\n                ans.pop()\\n            elif p not in \"..\":\\n                ans.append(p)\\n        return \"/\" + \"/\".join(ans)\\n```\\n\\n\\n```go []\\nfunc simplifyPath(path string) string {\\n    ans := []string{}\\n    for _, s := range strings.Split(path, \"/\") {\\n        if s != \"\" && s != \".\" && s != \"..\"{\\n            ans = append(ans, s)\\n        } else if s == \"..\" && len(ans) > 0{\\n            ans = ans[:len(ans) - 1]\\n        }\\n    }\\n    return \"/\" + strings.Join(ans, \"/\")\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(N)$.\\n- **Space Complexity**: $O(N)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go",
                    "String",
                    "Stack"
                ],
                "code": "```java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null || path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        Stack<String> pathStack = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n        path = path.replaceAll(\"\\\\\\\\/\\\\\\\\/\", \"/\");\\n        String[] folders = path.split(\"\\\\\\\\/\");\\n        int len = folders.length;\\n        for (int i = 0; i < len; i++) {\\n            String folder = folders[i];\\n            if (folder.equalsIgnoreCase(\".\")) {\\n                continue;\\n            } else if (folder.equalsIgnoreCase(\"..\")) {\\n                if (!pathStack.empty()) {\\n                    pathStack.pop();\\n                }\\n            } else if (folder.length() > 0) {\\n                pathStack.push(folder);\\n            }\\n        }\\n\\n        ans.append(\\'/\\');\\n        List<String> res = new ArrayList<>();\\n        while (!pathStack.empty()) {\\n            res.add(pathStack.pop());\\n        }\\n\\n        for (int i = res.size() - 1; i >= 0; i--) {\\n            ans.append(res.get(i));\\n            ans.append(\"/\");\\n        }\\n\\n        if (ans.length() > 1 && ans.charAt(ans.length() - 1) == \\'/\\') {\\n            ans.deleteCharAt(ans.length() - 1);\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        ans = []\\n        for p in path.split(\"/\"):\\n            if p == \"..\" and ans:\\n                ans.pop()\\n            elif p not in \"..\":\\n                ans.append(p)\\n        return \"/\" + \"/\".join(ans)\\n```\n```go []\\nfunc simplifyPath(path string) string {\\n    ans := []string{}\\n    for _, s := range strings.Split(path, \"/\") {\\n        if s != \"\" && s != \".\" && s != \"..\"{\\n            ans = append(ans, s)\\n        } else if s == \"..\" && len(ans) > 0{\\n            ans = ans[:len(ans) - 1]\\n        }\\n    }\\n    return \"/\" + strings.Join(ans, \"/\")\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848443,
                "title": "c-strtok",
                "content": "```\\nchar * simplifyPath(char * path){\\n    int len = strlen(path) + 1;\\n    char** pathArray = (char**)calloc(len,sizeof(char*)); ;\\n    int idx = 0;\\n    char* p;\\n    p = strtok(path, \"/\");\\n    while (p != NULL) {\\n        if(strcmp(p, \"..\") == 0){\\n            if(idx-1 >= 0) idx -= 1;\\n        }\\n        else if(strcmp(p, \".\") != 0){\\n            pathArray[idx] = (char*)calloc(strlen(p) + 1,sizeof(char)); \\n            strcpy(pathArray[idx], p);\\n            idx += 1;\\n        }\\n        p = strtok(NULL, \"/\");\\t\\t   \\n    }\\n    char* result = (char*)calloc(len,sizeof(char)); \\n    for(int i=0; i<idx; i++){\\n        strcat(result,\"/\");\\n        strcat(result,pathArray[i]);\\n    }\\n    if(idx==0) strcat(result,\"/\");\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * simplifyPath(char * path){\\n    int len = strlen(path) + 1;\\n    char** pathArray = (char**)calloc(len,sizeof(char*)); ;\\n    int idx = 0;\\n    char* p;\\n    p = strtok(path, \"/\");\\n    while (p != NULL) {\\n        if(strcmp(p, \"..\") == 0){\\n            if(idx-1 >= 0) idx -= 1;\\n        }\\n        else if(strcmp(p, \".\") != 0){\\n            pathArray[idx] = (char*)calloc(strlen(p) + 1,sizeof(char)); \\n            strcpy(pathArray[idx], p);\\n            idx += 1;\\n        }\\n        p = strtok(NULL, \"/\");\\t\\t   \\n    }\\n    char* result = (char*)calloc(len,sizeof(char)); \\n    for(int i=0; i<idx; i++){\\n        strcat(result,\"/\");\\n        strcat(result,pathArray[i]);\\n    }\\n    if(idx==0) strcat(result,\"/\");\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848420,
                "title": "faster-than-99-submission",
                "content": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = []\\n    let pathToProcess = path.split(\\'/\\')\\n    for(let path of pathToProcess){\\n        if(path === \\'.\\' || path === \\'\\'){\\n            continue\\n        }\\n        if(path === \\'..\\'){\\n            stack.pop()\\n            continue\\n        }\\n        // console.log(path)\\n        stack.push(path)\\n        \\n    }\\n    return \\'/\\'+stack.join(\\'/\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = []\\n    let pathToProcess = path.split(\\'/\\')\\n    for(let path of pathToProcess){\\n        if(path === \\'.\\' || path === \\'\\'){\\n            continue\\n        }\\n        if(path === \\'..\\'){\\n            stack.pop()\\n            continue\\n        }\\n        // console.log(path)\\n        stack.push(path)\\n        \\n    }\\n    return \\'/\\'+stack.join(\\'/\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848281,
                "title": "solution-swift-simplify-path",
                "content": "```swift\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        var stack: [Substring] = []\\n        \\n        for p in path.split(separator: \"/\") {\\n            if p == \"..\" { stack.popLast() }\\n            else\\n                if p != \".\" { stack.append(p) }\\n        }\\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Note that there is no trailing slash after the last directory name.\\n    func test0() {\\n        let value = solution.simplifyPath(\"/home/\")\\n        XCTAssertEqual(value, \"/home\")\\n    }\\n    \\n    // Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\\n    func test1() {\\n        let value = solution.simplifyPath(\"/../\")\\n        XCTAssertEqual(value, \"/\")\\n    }\\n    \\n    // In the canonical path, multiple consecutive slashes are replaced by a single one.\\n    func test2() {\\n        let value = solution.simplifyPath(\"/home//foo/\")\\n        XCTAssertEqual(value, \"/home/foo\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "String"
                ],
                "code": "```swift\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        var stack: [Substring] = []\\n        \\n        for p in path.split(separator: \"/\") {\\n            if p == \"..\" { stack.popLast() }\\n            else\\n                if p != \".\" { stack.append(p) }\\n        }\\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Note that there is no trailing slash after the last directory name.\\n    func test0() {\\n        let value = solution.simplifyPath(\"/home/\")\\n        XCTAssertEqual(value, \"/home\")\\n    }\\n    \\n    // Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\\n    func test1() {\\n        let value = solution.simplifyPath(\"/../\")\\n        XCTAssertEqual(value, \"/\")\\n    }\\n    \\n    // In the canonical path, multiple consecutive slashes are replaced by a single one.\\n    func test2() {\\n        let value = solution.simplifyPath(\"/home//foo/\")\\n        XCTAssertEqual(value, \"/home/foo\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847792,
                "title": "using-vector-of-strings-clean-and-concise-beginners-level",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> ans;\\n        int n = path.size();\\n        int i =0;\\n        while(i < n){\\n            \\n            string tmp = \"\";\\n            if(path[i] == \\'/\\'){\\n                i++;\\n                continue;\\n            }\\n            while(i < n and path[i] != \\'/\\'){\\n                tmp.push_back(path[i]);\\n                i++;\\n            }\\n            if(tmp == \".\"){\\n                continue;\\n            }else if(tmp == \"..\"){\\n                if(ans.size() > 0) ans.pop_back();\\n            }else{\\n                ans.push_back(tmp);\\n            }\\n        }\\n        string rans=\"\";\\n        if(ans.size() == 0) return \"/\";\\n        for(auto x : ans){\\n            rans = rans + \"/\" + x;\\n        }\\n        return rans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> ans;\\n        int n = path.size();\\n        int i =0;\\n        while(i < n){\\n            \\n            string tmp = \"\";\\n            if(path[i] == \\'/\\'){\\n                i++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1847645,
                "title": "java-using-linkedlist-string-very-easy",
                "content": "The algorithm is simple. \\n* First split the given path with slash (/)\\n* Then itterate over the parts of the string\\n* If the part is not empty or is not dot(\".\") then -\\n\\t* If the part is \"..\" then pop last element from LinkedList\\n\\t* Else add the part into the LinkedList\\n* Join the elements in the LinkedList\\n```java\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        var parts = path.split(\"/\");\\n        var list = new LinkedList<String>();\\n        for (var part : parts) {\\n            if (part != null && !part.isEmpty() && !\".\".equals(part)) {\\n                if (\"..\".equals(part)) {\\n                    list.pollLast();\\n                } else {\\n                    list.add(part);\\n                }\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", list);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String simplifyPath(String path) {\\n        var parts = path.split(\"/\");\\n        var list = new LinkedList<String>();\\n        for (var part : parts) {\\n            if (part != null && !part.isEmpty() && !\".\".equals(part)) {\\n                if (\"..\".equals(part)) {\\n                    list.pollLast();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1847303,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> q = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !q.isEmpty())    q.pop();\\n            else if(!skip.contains(dir)) q.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", q);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> q = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !q.isEmpty())    q.pop();\\n            else if(!skip.contains(dir)) q.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", q);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721754,
                "title": "c-solution-using-stack",
                "content": "\\n\\tstring simplifyPath(string path) {\\n        stack<string> st;\\n        string word=\"\";\\n        if(path[path.size()-1] !=\\'/\\')\\n            path+=\\'/\\';\\n        for(int i=0;i<path.size();i++)\\n        {\\n            if(path[i]==\\'/\\')\\n            {\\n                if(word==\"\" || word==\".\")\\n                {}\\n                else if(word==\"..\")\\n                {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else{\\n                //std::cout<<word;\\n                st.push(word);\\n                }\\n                 word=\"\";\\n            }\\n            else\\n                word+=path[i];\\n        }\\n        if(word.size()>0)\\n            st.push(word);\\n        int n=st.size();\\n        stack<string> st2;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp=st.top();\\n            st.pop();\\n            st2.push(temp);\\n        }\\n        string ans=\"\";\\n        while (!st2.empty())\\n        {\\n            ans+=(\"/\"+st2.top());\\n            //std::cout<<st.top();\\n            st2.pop();\\n        }\\n        if(ans.size()==0)\\n        {ans+=\"/\";\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\nPlease upvote if you find it useful.\\nThanks :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "\\n\\tstring simplifyPath(string path) {\\n        stack<string> st;\\n        string word=\"\";\\n        if(path[path.size()-1] !=\\'/\\')\\n            path+=\\'/\\';\\n        for(int i=0;i<path.size();i++)\\n        {\\n            if(path[i]==\\'/\\')\\n            {\\n                if(word==\"\" || word==\".\")\\n                {}\\n                else if(word==\"..\")\\n                {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else{\\n                //std::cout<<word;\\n                st.push(word);\\n                }\\n                 word=\"\";\\n            }\\n            else\\n                word+=path[i];\\n        }\\n        if(word.size()>0)\\n            st.push(word);\\n        int n=st.size();\\n        stack<string> st2;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp=st.top();\\n            st.pop();\\n            st2.push(temp);\\n        }\\n        string ans=\"\";\\n        while (!st2.empty())\\n        {\\n            ans+=(\"/\"+st2.top());\\n            //std::cout<<st.top();\\n            st2.pop();\\n        }\\n        if(ans.size()==0)\\n        {ans+=\"/\";\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\nPlease upvote if you find it useful.\\nThanks :)",
                "codeTag": "C++"
            },
            {
                "id": 1457918,
                "title": "simple-clean-easy-to-understand-cpp-solution",
                "content": "\\nThe CPP implementation of the approach is given below with the help of stack:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string word=\"\";\\n        stack<string>st;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            while(i<path.size()&&path[i]==\\'/\\')i++;\\n            while(i<path.size()&&path[i]!=\\'/\\')word=word+path[i],i++;\\n           \\n            if(word.size()){\\n            if(word==\".\"){word=\"\";continue;}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n            word=\"\";\\n            }\\n        }\\n        if(word.size()){\\n        if(word==\".\"){word=\"\";}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n        }\\n        string ans=\"\";\\n        while(st.size()){\\n            string ab=st.top();\\n            st.pop();\\n       ans=\"/\"+ab+ans;\\n        }\\n        \\n       \\n         return ans.size()==0?\"/\":ans;   \\n    }\\n};\\n```\\n\\n* If you find my solution easy to understand do Upvote it :)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string word=\"\";\\n        stack<string>st;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            while(i<path.size()&&path[i]==\\'/\\')i++;\\n            while(i<path.size()&&path[i]!=\\'/\\')word=word+path[i],i++;\\n           \\n            if(word.size()){\\n            if(word==\".\"){word=\"\";continue;}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n            word=\"\";\\n            }\\n        }\\n        if(word.size()){\\n        if(word==\".\"){word=\"\";}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n        }\\n        string ans=\"\";\\n        while(st.size()){\\n            string ab=st.top();\\n            st.pop();\\n       ans=\"/\"+ab+ans;\\n        }\\n        \\n       \\n         return ans.size()==0?\"/\":ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313778,
                "title": "python-solution-71-simplified-path",
                "content": "```\\n#Upvote if you find it useful!\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        for x in path.split(\"/\"):\\n            if x==\"..\":\\n                if stack:\\n                    stack.pop()\\n            elif x==\\'.\\' or not x:\\n                continue\\n            else:\\n                stack.append(x)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n#Upvote if you find it useful!\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        for x in path.split(\"/\"):\\n            if x==\"..\":\\n                if stack:\\n                    stack.pop()\\n            elif x==\\'.\\' or not x:\\n                continue\\n            else:\\n                stack.append(x)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306297,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        \\n        int l=0;\\n        int len=path.length();\\n        while(l<len){\\n            \\n            while(l<len and path[l]==\\'/\\')\\n                l++;\\n            string tmp;\\n            while(l<len and path[l]!=\\'/\\')\\n                tmp.push_back(path[l++]);\\n            if(tmp==\".\")\\n                continue;\\n            else if(tmp==\"..\")\\n            {\\n                if(!s.empty())\\n                    s.pop();\\n            }\\n            else if(tmp.length())\\n                s.push(tmp);\\n\\n        }\\n        vector<string> v;\\n    \\n        while(!s.empty())\\n        {\\n            v.push_back(s.top());\\n            s.pop();\\n        }\\n\\n        int sz=v.size();\\n        string ans;\\n\\n        while(sz--)\\n        {\\n            ans+=\"/\";\\n            ans+=v[sz];\\n        }\\n        if(ans.length()==0)\\n            return \"/\";\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        \\n        int l=0;\\n        int len=path.length();\\n        while(l<len){\\n            \\n            while(l<len and path[l]==\\'/\\')\\n                l++;\\n            string tmp;\\n            while(l<len and path[l]!=\\'/\\')\\n                tmp.push_back(path[l++]);\\n            if(tmp==\".\")\\n                continue;\\n            else if(tmp==\"..\")\\n            {\\n                if(!s.empty())\\n                    s.pop();\\n            }\\n            else if(tmp.length())\\n                s.push(tmp);\\n\\n        }\\n        vector<string> v;\\n    \\n        while(!s.empty())\\n        {\\n            v.push_back(s.top());\\n            s.pop();\\n        }\\n\\n        int sz=v.size();\\n        string ans;\\n\\n        while(sz--)\\n        {\\n            ans+=\"/\";\\n            ans+=v[sz];\\n        }\\n        if(ans.length()==0)\\n            return \"/\";\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1258987,
                "title": "c-4-ms-solution-using-stack-with-explanation",
                "content": "```\\nHere we have to insert \\'/\\' at the end of the string if not present because we are going to complete a string when we will find a \\'/ \\'.\\n```class Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string>st;\\n        string s1,s2;\\n        int n=path.size();\\n        if(path[n-1]!=\\'/\\')\\n            path.insert(n,\"/\");\\n        for(int i=1;i<path.size();i++)\\n        {\\n\\t\\t// checking if \\'/ \\' present or not because it will be the end of string.\\n            if(path[i]!=\\'/\\')\\n            {\\n                s1.push_back(path[i]);\\n            }\\n            else\\n            {\\n                if(s1.size()>0)\\n                st.push(s1);\\n                if(s1==\"..\")\\n                {\\n\\t\\t\\t\\t// suppose you have only \"..\" in stack then stack size will be 1 and two times poping will give runtime error\\n\\t\\t\\t\\t//because we have to pop \"..\" and one more top item from stack to go to it`s parent\\n                    if(st.size()>=2)\\n                    {\\n                            st.pop();\\n                            st.pop();\\n                    }\\n                    else\\n                        st.pop();\\n                }\\n                if(s1==\".\")\\n                {\\n                    st.pop();\\n                }\\n                s1.clear();\\n            }\\n        }\\n         if(st.empty())\\n             return \"/\";\\n        while(st.size()>0)\\n        {\\n            s2.insert(0,st.top());\\n            s2.insert(0,\"/\");\\n            st.pop();\\n        }\\n        return s2;\\n    }\\n};\\n# *if you find this solution useful, please upvote*\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nHere we have to insert \\'/\\' at the end of the string if not present because we are going to complete a string when we will find a \\'/ \\'.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185521,
                "title": "short-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string>st;\\n        int i=0, n=path.length();\\n        while(i<n){\\n            string temp;\\n            while(path[i]==\\'/\\' && i<n) i++;\\n            while(path[i]!=\\'/\\' && i<n) temp+=path[i++];\\n            if(temp==\"..\" && !st.empty()) st.pop_back();\\n            else if(temp==\".\" || temp==\"\") continue;\\n            else if(temp!=\"..\") st.push_back(temp);               \\n        }\\n        string res;\\n        for(string s:st) res+= \"/\" + s;\\n        return res.empty() ? \"/\":res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string>st;\\n        int i=0, n=path.length();\\n        while(i<n){\\n            string temp;\\n            while(path[i]==\\'/\\' && i<n) i++;\\n            while(path[i]!=\\'/\\' && i<n) temp+=path[i++];\\n            if(temp==\"..\" && !st.empty()) st.pop_back();\\n            else if(temp==\".\" || temp==\"\") continue;\\n            else if(temp!=\"..\") st.push_back(temp);               \\n        }\\n        string res;\\n        for(string s:st) res+= \"/\" + s;\\n        return res.empty() ? \"/\":res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179620,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        String[] splitString=path.split(\"/+\");\\n        Stack<String> st= new Stack<>();\\n        \\n        for(String s:splitString){\\n            if(st.size()>0 &&  \"..\".equals(s)){\\n                st.pop();\\n            }else if(!Arrays.asList(\"\",\".\",\"..\").contains(s)){ \\n// A list contain [ \" \",\".\",\"..\"] and if a string(s) contain any list element than continue else put into stack..\\n                //  I strongly recommended please dry run this once to know better how it work \\n                st.push(s);\\n            }            \\n            \\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();      \\n                   \\n        for(String s1: st){\\n            sb.append(\"/\").append(s1);\\n        }\\n        \\n        return sb.length()==0 ? \"/\":sb.toString();\\n        \\n        \\n    // In place of line  16 to 22 we can also  use. .... \\n    //    return \"/\" + String.join(\"/\"+st);     \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        String[] splitString=path.split(\"/+\");\\n        Stack<String> st= new Stack<>();\\n        \\n        for(String s:splitString){\\n            if(st.size()>0 &&  \"..\".equals(s)){\\n                st.pop();\\n            }else if(!Arrays.asList(\"\",\".\",\"..\").contains(s)){ \\n// A list contain [ \" \",\".\",\"..\"] and if a string(s) contain any list element than continue else put into stack..\\n                //  I strongly recommended please dry run this once to know better how it work \\n                st.push(s);\\n            }            \\n            \\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();      \\n                   \\n        for(String s1: st){\\n            sb.append(\"/\").append(s1);\\n        }\\n        \\n        return sb.length()==0 ? \"/\":sb.toString();\\n        \\n        \\n    // In place of line  16 to 22 we can also  use. .... \\n    //    return \"/\" + String.join(\"/\"+st);     \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130045,
                "title": "c-100-faster-two-pointers-no-stack",
                "content": "// Two pointers\\n   \\n\\t\\tstring simplifyPath(string path)\\n\\t\\t{\\n\\t\\t\\tstring result;\\n\\n\\t\\t\\tsize_t front = 0;\\n\\t\\t\\tsize_t rear = 0;\\n\\n\\t\\t\\twhile (front < path.length() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trear = path.find(\\'/\\', front + 1);\\n\\n\\t\\t\\t\\tif (rear == path.npos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trear = path.length();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Skip \"//\"\\n\\t\\t\\t\\tif (rear - front > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring s = path.substr(front + 1, rear - front - 1);\\n\\n\\t\\t\\t\\t\\t// Skip \".\"\\n\\t\\t\\t\\t\\tif (!s.empty() && s != \".\")\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t// Handle \"..\"\\n\\t\\t\\t\\t\\t\\tif (s == \"..\")\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (!result.empty())\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresult.erase(result.find_last_of(\\'/\\'));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tresult += \"/\" + s;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfront = rear;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (result.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \"/\";\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "// Two pointers\\n   \\n\\t\\tstring simplifyPath(string path)\\n\\t\\t{\\n\\t\\t\\tstring result;\\n\\n\\t\\t\\tsize_t front = 0;\\n\\t\\t\\tsize_t rear = 0;\\n\\n\\t\\t\\twhile (front < path.length() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trear = path.find(\\'/\\', front + 1);\\n\\n\\t\\t\\t\\tif (rear == path.npos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trear = path.length();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Skip \"//\"\\n\\t\\t\\t\\tif (rear - front > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring s = path.substr(front + 1, rear - front - 1);\\n\\n\\t\\t\\t\\t\\t// Skip \".\"\\n\\t\\t\\t\\t\\tif (!s.empty() && s != \".\")\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t// Handle \"..\"\\n\\t\\t\\t\\t\\t\\tif (s == \"..\")\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (!result.empty())\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresult.erase(result.find_last_of(\\'/\\'));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tresult += \"/\" + s;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfront = rear;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (result.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \"/\";\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1055024,
                "title": "c-solution",
                "content": "```\\nstring simplifyPath(string path) {\\n\\tvector<string> parts {};\\n\\tint i = 0;\\n\\twhile (i < path.size()) {\\n\\t\\tif (path[i] != \\'/\\') {\\n\\t\\t\\tstring cur = \"\";\\n\\t\\t\\twhile (i < path.size() && path[i] != \\'/\\')\\n\\t\\t\\t\\tcur += path[i++];\\n\\t\\t\\tif (cur == \"..\") {\\n\\t\\t\\t\\tif (!parts.empty())\\n\\t\\t\\t\\t\\tparts.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\telse if (cur != \".\")\\n\\t\\t\\t\\tparts.push_back(cur);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ti++;\\n\\t}\\n\\tstring result = \"\";\\n\\tfor (string s : parts)\\n\\t\\tresult += \"/\" + s;\\n\\treturn result.empty() ? \"/\" : result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring simplifyPath(string path) {\\n\\tvector<string> parts {};\\n\\tint i = 0;\\n\\twhile (i < path.size()) {\\n\\t\\tif (path[i] != \\'/\\') {\\n\\t\\t\\tstring cur = \"\";\\n\\t\\t\\twhile (i < path.size() && path[i] != \\'/\\')\\n\\t\\t\\t\\tcur += path[i++];\\n\\t\\t\\tif (cur == \"..\") {\\n\\t\\t\\t\\tif (!parts.empty())\\n\\t\\t\\t\\t\\tparts.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\telse if (cur != \".\")\\n\\t\\t\\t\\tparts.push_back(cur);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ti++;\\n\\t}\\n\\tstring result = \"\";\\n\\tfor (string s : parts)\\n\\t\\tresult += \"/\" + s;\\n\\treturn result.empty() ? \"/\" : result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051006,
                "title": "python-3-two-pointers-o-n",
                "content": "- Split ```path``` by the separator ```/```. Note ```path``` is starting with the separator. So first element of the list is empty string.\\n- Iteratively move fast pointer forward. Slow pointer can be incremented (general case), decremented (```..```) or unchanged (``` ```, ```.```). If it is incremented then copy value from the fast pointer.\\n- Delete unnecessary tail from the list and join all items of the list into a string. \\n\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        arr = path.split(\\'/\\'); j = 1\\n        for a in arr:\\n            if a == \\'..\\':\\n                j = max(1, j-1)\\n            elif a and a != \\'.\\':\\n                arr[j] = a; j += 1\\n        del arr[j:]\\n        \\n        return \\'/\\'.join(arr) or \\'/\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```path```\n```/```\n```path```\n```..```\n``` ```\n```.```\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        arr = path.split(\\'/\\'); j = 1\\n        for a in arr:\\n            if a == \\'..\\':\\n                j = max(1, j-1)\\n            elif a and a != \\'.\\':\\n                arr[j] = a; j += 1\\n        del arr[j:]\\n        \\n        return \\'/\\'.join(arr) or \\'/\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050624,
                "title": "python-by-stack-w-comment",
                "content": "Python by stack\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n\\n        # stack to store directory name\\n        stack = []\\n        \\n        # check each directory name in given path, split by \\'/\\'\\n        for dir_name in path.split(\\'/\\'):\\n            \\n            # do nothing if directory name is either empty string or \\'.\\'\\n            if dir_name == \\'\\' or dir_name == \\'.\\':\\n                continue\\n\\n            # go back to parnet level and pop stack if stack is not empty    \\n            elif dir_name == \\'..\\':    \\n                stack and stack.pop()\\n\\n            # push current directory name into stack                    \\n            else:\\n                stack.append( dir_name )\\n                \\n        return \\'/\\' + \\'/\\'.join( stack )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about stack operation](https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-stacks)\\n\\n[2] [Python official docs about str.split( ... )](https://docs.python.org/3/library/stdtypes.html?highlight=str%20split#str.split)\\n\\n[3] [Python official docs about str.join( ... )](https://docs.python.org/3/library/stdtypes.html?highlight=str%20split#str.split)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n\\n        # stack to store directory name\\n        stack = []\\n        \\n        # check each directory name in given path, split by \\'/\\'\\n        for dir_name in path.split(\\'/\\'):\\n            \\n            # do nothing if directory name is either empty string or \\'.\\'\\n            if dir_name == \\'\\' or dir_name == \\'.\\':\\n                continue\\n\\n            # go back to parnet level and pop stack if stack is not empty    \\n            elif dir_name == \\'..\\':    \\n                stack and stack.pop()\\n\\n            # push current directory name into stack                    \\n            else:\\n                stack.append( dir_name )\\n                \\n        return \\'/\\' + \\'/\\'.join( stack )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750394,
                "title": "simple-c-solution-easy-to-understand-stack-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        path+=\"/\";\\n        string temp=\"\";\\n        for(int i=0;i<path.length();i++){\\n            if(path[i]==\\'/\\'){\\n                if(temp==\"\"||temp==\".\"){\\n                    temp=\"\";\\n                    continue;\\n                }else if(temp==\"..\"){\\n                    if(st.size()){\\n                        st.pop();\\n                    }\\n                    \\n                    temp=\"\";\\n                }else{\\n                    st.push(temp);\\n                    temp=\"\";\\n                }\\n            }else{\\n                temp+=path[i];\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(st.size()){\\n            ans=st.top()+\"/\"+ans;\\n            st.pop();\\n        }\\n        if(ans!=\"\"){\\n            ans.pop_back();\\n        }\\n        ans=\"/\"+ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        path+=\"/\";\\n        string temp=\"\";\\n        for(int i=0;i<path.length();i++){\\n            if(path[i]==\\'/\\'){\\n                if(temp==\"\"||temp==\".\"){\\n                    temp=\"\";\\n                    continue;\\n                }else if(temp==\"..\"){\\n                    if(st.size()){\\n                        st.pop();\\n                    }\\n                    \\n                    temp=\"\";\\n                }else{\\n                    st.push(temp);\\n                    temp=\"\";\\n                }\\n            }else{\\n                temp+=path[i];\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(st.size()){\\n            ans=st.top()+\"/\"+ans;\\n            st.pop();\\n        }\\n        if(ans!=\"\"){\\n            ans.pop_back();\\n        }\\n        ans=\"/\"+ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695975,
                "title": "simple-java-solution-with-list",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        List<String> paths = new ArrayList<>(path.length());\\n        int i = -1;\\n        for(String folder : path.split(\"/\")){\\n            if(folder.equals(\"..\")){\\n                if(!paths.isEmpty()){\\n                    paths.remove(i);\\n                    i --;   \\n                }\\n            }else if(!folder.isEmpty() && !folder.equals(\".\")){\\n                paths.add(folder);\\n                i++;\\n            }\\n            \\n        }\\n        return \"/\"+String.join(\"/\", paths);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        List<String> paths = new ArrayList<>(path.length());\\n        int i = -1;\\n        for(String folder : path.split(\"/\")){\\n            if(folder.equals(\"..\")){\\n                if(!paths.isEmpty()){\\n                    paths.remove(i);\\n                    i --;   \\n                }\\n            }else if(!folder.isEmpty() && !folder.equals(\".\")){\\n                paths.add(folder);\\n                i++;\\n            }\\n            \\n        }\\n        return \"/\"+String.join(\"/\", paths);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601469,
                "title": "easy-to-understand-c-code-using-stack",
                "content": "If there is \\'/\\' then continue no need to push or pop anything. Otherwise make a string until another \\'/\\'.\\n1. If string is \".\" the continue\\n2. If string is \"..\" then pop stack if not empty and continue\\n3. Push the string to the stack\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        \\n        int n=path.length();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            string s=\"\";\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                s=s+path[i];\\n                i++;\\n            }\\n            i--;\\n            \\n            if(s==\".\")\\n                continue;\\n            if(s==\"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                continue;\\n            }\\n            st.push(s);\\n        }\\n        \\n        if(st.empty())\\n            return \"/\";\\n        \\n        string result=\"\";\\n        while(!st.empty())\\n        {\\n            result=\"/\" + st.top() + result;\\n            cout<<st.top()<<\"/\";\\n            st.pop();\\n        }\\n        cout<<endl;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        \\n        int n=path.length();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            string s=\"\";\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                s=s+path[i];\\n                i++;\\n            }\\n            i--;\\n            \\n            if(s==\".\")\\n                continue;\\n            if(s==\"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                continue;\\n            }\\n            st.push(s);\\n        }\\n        \\n        if(st.empty())\\n            return \"/\";\\n        \\n        string result=\"\";\\n        while(!st.empty())\\n        {\\n            result=\"/\" + st.top() + result;\\n            cout<<st.top()<<\"/\";\\n            st.pop();\\n        }\\n        cout<<endl;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 500999,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n        Stack<String> segmentStack = new Stack<>();\\n        for (String segment : path.split(\"/\")) {\\n            if (!segment.isEmpty() && !segment.equals(\".\")) {\\n                if (segment.equals(\"..\")) {\\n                    if (!segmentStack.isEmpty()) {\\n                        segmentStack.pop();\\n                    }\\n                } else {\\n                    segmentStack.push(segment);\\n                }\\n            }\\n        }\\n\\n        if (segmentStack.isEmpty()) {\\n            return \"/\";\\n        }\\n        \\n        Stack<String> reversedStack = new Stack<>();\\n        while (!segmentStack.isEmpty()) {\\n            reversedStack.push(segmentStack.pop());\\n        }\\n        \\n        StringBuilder outputBuilder = new StringBuilder();\\n        while (!reversedStack.isEmpty()) {\\n            outputBuilder.append(\"/\");\\n            outputBuilder.append(reversedStack.pop());\\n        }\\n        \\n        return outputBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n        Stack<String> segmentStack = new Stack<>();\\n        for (String segment : path.split(\"/\")) {\\n            if (!segment.isEmpty() && !segment.equals(\".\")) {\\n                if (segment.equals(\"..\")) {\\n                    if (!segmentStack.isEmpty()) {\\n                        segmentStack.pop();\\n                    }\\n                } else {\\n                    segmentStack.push(segment);\\n                }\\n            }\\n        }\\n\\n        if (segmentStack.isEmpty()) {\\n            return \"/\";\\n        }\\n        \\n        Stack<String> reversedStack = new Stack<>();\\n        while (!segmentStack.isEmpty()) {\\n            reversedStack.push(segmentStack.pop());\\n        }\\n        \\n        StringBuilder outputBuilder = new StringBuilder();\\n        while (!reversedStack.isEmpty()) {\\n            outputBuilder.append(\"/\");\\n            outputBuilder.append(reversedStack.pop());\\n        }\\n        \\n        return outputBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472288,
                "title": "accepted-c-stack-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public string SimplifyPath(string path) \\n    {\\n        string[] pathDir = path.Split(new [] { \\'/\\' });\\n        Stack<string> stack = new Stack<string>();\\n        foreach (string dir in pathDir)\\n        {\\n            if (dir == \".\" || dir.Length == 0) continue;\\n            if (dir == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                    stack.Pop();\\n                continue;\\n            }\\n            stack.Push(dir);\\n        }\\n        \\n        var res = new StringBuilder();\\n        while (stack.Count > 0)\\n            res.Insert(0, \"/\" + stack.Pop());\\n        return res.Length == 0 ? \"/\" : res.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string SimplifyPath(string path) \\n    {\\n        string[] pathDir = path.Split(new [] { \\'/\\' });\\n        Stack<string> stack = new Stack<string>();\\n        foreach (string dir in pathDir)\\n        {\\n            if (dir == \".\" || dir.Length == 0) continue;\\n            if (dir == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                    stack.Pop();\\n                continue;\\n            }\\n            stack.Push(dir);\\n        }\\n        \\n        var res = new StringBuilder();\\n        while (stack.Count > 0)\\n            res.Insert(0, \"/\" + stack.Pop());\\n        return res.Length == 0 ? \"/\" : res.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313909,
                "title": "c-99-beat-iterative-stack-solution-pretty-basic-judge-4-urself",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        vector <string> aList;\\n        \\n        int aPrevIndex = 0;\\n        for (int i=0;i<path.size();i++) {\\n            if (path[i] == \\'/\\') {\\n                if (i > aPrevIndex) {\\n                    aList.push_back(path.substr(aPrevIndex, i - aPrevIndex));\\n                }\\n                aPrevIndex = i + 1;\\n            }\\n        }\\n        \\n        if (path.size() > aPrevIndex) {\\n            aList.push_back(path.substr(aPrevIndex, path.size() - aPrevIndex));\\n        }\\n        \\n        vector <string> aStack;\\n        for (int i=0;i<aList.size();i++) {\\n            if (aList[i] == \".\") { continue; }\\n            if (aList[i] == \"..\") { \\n                if (aStack.empty() == false) {\\n                    aStack.pop_back();\\n                }\\n                continue;\\n            }\\n            if (aList[i].size() > 0) {\\n                aStack.push_back(aList[i]);\\n            }\\n        }\\n        \\n        string aResult = \"/\";\\n        for (int i=0;i<aStack.size();i++) {\\n            aResult += aStack[i];\\n            if (i < (aStack.size() - 1)) {\\n                aResult += \"/\";\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nKaboom, easy solutions. Now you\\'re on the payroll. Lucky ducky.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        vector <string> aList;\\n        \\n        int aPrevIndex = 0;\\n        for (int i=0;i<path.size();i++) {\\n            if (path[i] == \\'/\\') {\\n                if (i > aPrevIndex) {\\n                    aList.push_back(path.substr(aPrevIndex, i - aPrevIndex));\\n                }\\n                aPrevIndex = i + 1;\\n            }\\n        }\\n        \\n        if (path.size() > aPrevIndex) {\\n            aList.push_back(path.substr(aPrevIndex, path.size() - aPrevIndex));\\n        }\\n        \\n        vector <string> aStack;\\n        for (int i=0;i<aList.size();i++) {\\n            if (aList[i] == \".\") { continue; }\\n            if (aList[i] == \"..\") { \\n                if (aStack.empty() == false) {\\n                    aStack.pop_back();\\n                }\\n                continue;\\n            }\\n            if (aList[i].size() > 0) {\\n                aStack.push_back(aList[i]);\\n            }\\n        }\\n        \\n        string aResult = \"/\";\\n        for (int i=0;i<aStack.size();i++) {\\n            aResult += aStack[i];\\n            if (i < (aStack.size() - 1)) {\\n                aResult += \"/\";\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313904,
                "title": "swift-simple-stack-solution-using-all-arrays-o-n-good-speed",
                "content": "```\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        \\n        var list = path.split(separator: \"/\")\\n        print(list)\\n        \\n        var stack = [String]()\\n        \\n        for component in list {\\n            \\n            if component == \".\" { continue }\\n            if component == \"..\" {\\n                if stack.count > 0 { stack.removeLast() }\\n                continue\\n            }\\n            \\n            if component.count > 0 { stack.append(String(component)) }\\n        }\\n        \\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```\\n\\nKaboom, G, you\\'re on the pAyRoLl now BOIIIIIII",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        \\n        var list = path.split(separator: \"/\")\\n        print(list)\\n        \\n        var stack = [String]()\\n        \\n        for component in list {\\n            \\n            if component == \".\" { continue }\\n            if component == \"..\" {\\n                if stack.count > 0 { stack.removeLast() }\\n                continue\\n            }\\n            \\n            if component.count > 0 { stack.append(String(component)) }\\n        }\\n        \\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307383,
                "title": "short-python-o-n-with-explanation",
                "content": "O(n) - every character in path \\nSpace: O(n) - might just have a long directory name piling on to the stack\\nAlgorithm: Keep a stack tracking the directory level, skip over the . and only append directories which are not the . or ..\\nWhen an .. is encountered pop from the stack (go up a level in the hierarchy) only if you have something in the stack, otherwise do nothing (empty stack encountering ..).\\n\\n```\\ndef simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"        \\n        # Splitting is O(n*m) - where m is the length of the character to split, here this is O(n)\\n        plist = path.split(\\'/\\')\\n        stack = []\\n        for directory in plist:\\n            if directory == \".\" or not directory:\\n                continue\\n            # Need this condition nested for case of /../a\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n                \\n        return \"/\" + \"/\".join(stack)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "O(n) - every character in path \\nSpace: O(n) - might just have a long directory name piling on to the stack\\nAlgorithm: Keep a stack tracking the directory level, skip over the . and only append directories which are not the . or ..\\nWhen an .. is encountered pop from the stack (go up a level in the hierarchy) only if you have something in the stack, otherwise do nothing (empty stack encountering ..).\\n\\n```\\ndef simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"        \\n        # Splitting is O(n*m) - where m is the length of the character to split, here this is O(n)\\n        plist = path.split(\\'/\\')\\n        stack = []\\n        for directory in plist:\\n            if directory == \".\" or not directory:\\n                continue\\n            # Need this condition nested for case of /../a\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n                \\n        return \"/\" + \"/\".join(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 175951,
                "title": "one-line-golang-solution-for-fun",
                "content": "```\\nfunc simplifyPath(path string) string {\\n    return filepath.Clean(path);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc simplifyPath(path string) string {\\n    return filepath.Clean(path);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154576,
                "title": "easy-and-clean-to-understand-no-stack-java",
                "content": "Start from the right most directory. If we encounter \\'..\\' we have to skip one directory. As, in linux \\'..\\' is to go one directory up.\\n\\t\\t\\n```\\npublic String simplifyPath(String path) {\\n        String[] temp = path.split(\"/\");\\n        int skip = 0;\\n        String ans = \"\";\\n        \\n        for(int i = temp.length - 1; i >= 0; i-- ){\\n            if(temp[i].equals(\".\") || temp[i].equals(\"\"))\\n                continue;\\n            else if(temp[i].equals(\"..\"))\\n                skip++;\\n            else if(skip > 0)\\n                skip--;\\n            else\\n                ans =  \"/\" + temp[i]  + ans;\\n        }\\n        return ans == \"\" ? \"/\" : ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic String simplifyPath(String path) {\\n        String[] temp = path.split(\"/\");\\n        int skip = 0;\\n        String ans = \"\";\\n        \\n        for(int i = temp.length - 1; i >= 0; i-- ){\\n            if(temp[i].equals(\".\") || temp[i].equals(\"\"))\\n                continue;\\n            else if(temp[i].equals(\"..\"))\\n                skip++;\\n            else if(skip > 0)\\n                skip--;\\n            else\\n                ans =  \"/\" + temp[i]  + ans;\\n        }\\n        return ans == \"\" ? \"/\" : ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25750,
                "title": "5-line-js-solution",
                "content": "```js\\nfunction simplifyPath(path) {\\n    const stack = [];\\n    \\n    for (let p of path.split('/').filter(p => p && p !== '.')) {\\n        p === '..' ? stack.pop() : stack.push(p);\\n    }\\n    \\n    return '/' + stack.join('/');\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction simplifyPath(path) {\\n    const stack = [];\\n    \\n    for (let p of path.split('/').filter(p => p && p !== '.')) {\\n        p === '..' ? stack.pop() : stack.push(p);\\n    }\\n    \\n    return '/' + stack.join('/');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25765,
                "title": "5ms-java-implementation-using-stack-beats-99-63",
                "content": "    public String simplifyPath(String path) {\\n        int len = path.length();\\n        Deque<String> stack = new ArrayDeque<>();\\n        for (int i = 0; i < len; ) {\\n            char c = path.charAt(i);\\n            if (c == '/') { ++i; }  // skip the separator '/'\\n            else if (c == '.') {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                if (j - i == 2 && path.charAt(i + 1) == '.' && !stack.isEmpty()) {  // go up to parent directory\\n                    stack.removeLast();\\n                } else if (j - i > 2) {\\n                    stack.addLast(path.substring(i, j));  // go down to child directory\\n                }\\n                i = j;\\n            } else {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                stack.addLast(path.substring(i, j));  // go down to child directory\\n                i = j;\\n            }\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        for (String dir: stack) { ans.append('/').append(dir); }\\n        if (ans.length() == 0) { return \"/\"; }\\n        return ans.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String simplifyPath(String path) {\\n        int len = path.length();\\n        Deque<String> stack = new ArrayDeque<>();\\n        for (int i = 0; i < len; ) {\\n            char c = path.charAt(i);\\n            if (c == '/') { ++i; }  // skip the separator '/'\\n            else if (c == '.') {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                if (j - i == 2 && path.charAt(i + 1) == '.' && !stack.isEmpty()) {  // go up to parent directory\\n                    stack.removeLast();\\n                } else if (j - i > 2) {\\n                    stack.addLast(path.substring(i, j));  // go down to child directory\\n                }\\n                i = j;\\n            } else {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                stack.addLast(path.substring(i, j));  // go down to child directory\\n                i = j;\\n            }\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        for (String dir: stack) { ans.append('/').append(dir); }\\n        if (ans.length() == 0) { return \"/\"; }\\n        return ans.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25793,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static String simplifyPath(String path) {\\n\\t\\tif (path == null || path.length() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tString[] parts = path.split(\"/\");\\n\\t\\tStack<String> stack = new Stack<>();\\n\\t\\tfor (int i = 0; i < parts.length; i++) {\\n\\t\\t\\tif (parts[i].equals(\".\")||parts[i].equals(\"\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if (parts[i].equals(\"..\")) {\\n\\t\\t\\t\\tif (!stack.isEmpty())\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tstack.push(parts[i]);\\n\\t\\t}\\n\\t\\tif (stack.isEmpty())\\n\\t\\t\\treturn \"/\";\\n\\t\\tString result = \"\";\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tresult = \"/\" + stack.pop() + result;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static String simplifyPath(String path) {\\n\\t\\tif (path == null || path.length() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tString[] parts = path.split(\"/\");\\n\\t\\tStack<String> stack = new Stack<>();\\n\\t\\tfor (int i = 0; i < parts.length; i++) {\\n\\t\\t\\tif (parts[i].equals(\".\")||parts[i].equals(\"\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if (parts[i].equals(\"..\")) {\\n\\t\\t\\t\\tif (!stack.isEmpty())\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tstack.push(parts[i]);\\n\\t\\t}\\n\\t\\tif (stack.isEmpty())\\n\\t\\t\\treturn \"/\";\\n\\t\\tString result = \"\";\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tresult = \"/\" + stack.pop() + result;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 25824,
                "title": "2ms-solution-in-c",
                "content": "    #include<stdlib.h>\\n\\n    char* simplifyPath(char* path) \\n    {\\n        int top = -1;\\n        int i;\\n        int j;\\n    \\n        for(i = 0; path[i] != '\\\\0'; ++i)\\n        {\\n            path[++top] = path[i]; \\n            if(top >= 1 && path[top - 1] == '/' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                top -= 2;\\n            }\\n            else if(top >= 2 && path[top - 2] == '/' && path[top - 1] == '.' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                for(j = top - 3; j >= 0; --j)\\n                {\\n                    if(path[j] == '/') break;\\n                }\\n                if(j < 0)\\n                {\\n                    top = -1;\\n                }\\n                else\\n                {\\n                    top = j - 1;\\n                }\\n            }\\n            else if(path[top] == '/' && path[i + 1] == '/') --top;\\n        }\\n        if(top > 0) \\n        {\\n            if(path[top] == '/') path[top] = '\\\\0';\\n            else path[top + 1] = '\\\\0';\\n        }\\n        else if(top == 0) path[top + 1] = '\\\\0';\\n        else \\n        {\\n            path[0] = '/'; \\n            path[1] = '\\\\0';\\n        }\\n        return path;\\n    }",
                "solutionTags": [],
                "code": "    #include<stdlib.h>\\n\\n    char* simplifyPath(char* path) \\n    {\\n        int top = -1;\\n        int i;\\n        int j;\\n    \\n        for(i = 0; path[i] != '\\\\0'; ++i)\\n        {\\n            path[++top] = path[i]; \\n            if(top >= 1 && path[top - 1] == '/' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                top -= 2;\\n            }\\n            else if(top >= 2 && path[top - 2] == '/' && path[top - 1] == '.' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                for(j = top - 3; j >= 0; --j)\\n                {\\n                    if(path[j] == '/') break;\\n                }\\n                if(j < 0)\\n                {\\n                    top = -1;\\n                }\\n                else\\n                {\\n                    top = j - 1;\\n                }\\n            }\\n            else if(path[top] == '/' && path[i + 1] == '/') --top;\\n        }\\n        if(top > 0) \\n        {\\n            if(path[top] == '/') path[top] = '\\\\0';\\n            else path[top + 1] = '\\\\0';\\n        }\\n        else if(top == 0) path[top + 1] = '\\\\0';\\n        else \\n        {\\n            path[0] = '/'; \\n            path[1] = '\\\\0';\\n        }\\n        return path;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 25826,
                "title": "java-already-has-the-method-string-join",
                "content": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<String>();\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty())\\n                stack.pop();\\n            else if (!s.equals(\".\") && !s.equals(\"..\") && !s.equals(\"\"))\\n                stack.push(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }",
                "solutionTags": [],
                "code": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<String>();\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty())\\n                stack.pop();\\n            else if (!s.equals(\".\") && !s.equals(\"..\") && !s.equals(\"\"))\\n                stack.push(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25741,
                "title": "simple-python-ac-code",
                "content": "    class Solution:\\n    # @param path, a string\\n    # @return a string\\n    def simplifyPath(self, path):\\n        result = []\\n        pathList = path.split('/')\\n        for content in pathList:\\n            if content:\\n                if content == '..':\\n                    try:\\n                        result.pop()\\n                    except:\\n                        result = []\\n                elif content != '.':\\n                    result.append(content)\\n        return '/'+'/'.join(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param path, a string\\n    # @return a string\\n    def simplifyPath(self, path):\\n        result = []\\n        pathList = path.split('/')\\n        for content in pathList:\\n            if content:\\n                if content == '..':\\n                    try:\\n                        result.pop()\\n                    except:\\n                        result = []\\n                elif content != '.':\\n                    result.append(content)\\n        return '/'+'/'.join(result)",
                "codeTag": "Java"
            },
            {
                "id": 4050586,
                "title": "simplify-path-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803142,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415113,
                "title": "o-n-solution-golang",
                "content": "# Intuition\\nWhen thinking of unix path, first data structure comes to mind is `stack` because we can simply push each directory in our stack when we found \"/\" and also pop the directory on \"..\"\\n\\n# Approach\\nFirst of all, we need to implement the `stack` data structure. The simplest way is using Go struct with property `a` type of []string.\\n\\n```go\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n    // implementation here\\n}\\n\\nfunc (st *stack) peek() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) pop() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n    // implementation here\\n}\\n```\\n\\nThen, we implement a special method, `constructAbsolutePath` which joins every string in our stack with `\"/\"`. This is not too difficult to understand right?\\n\\n```go\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n```\\n\\nAfter implementing stack data structure, we are now ready to solve this problem!\\n\\nThe approach is to checking every single charactor in our string, At this point, we have some special charactors the handle.\\n\\nIf we found \"/\", we know that this is the end of directory name. Therefore, we have to push something into out stack. However we **CANNOT** push everything without more check.\\n\\n1. \".\" and \"\"\\n\\n    If the directory to push is \".\" or \"\". That mean nothing to push because \".\" is the current directory and \"\" is a special handle for those absolute path input leading with \"/\".\\n\\n2. \"..\"\\n\\n    \"..\" means you are going back one level from currect directory. This means you have to pop the directory from out stack but only in case stack is **NOT** empty. (you are not going to pop the empty stack)\\n\\nWhen we finish looping through the input string, then we just call the method we have implemented `constructAbsolutePath`.\\n\\nThat\\'s all! Thanks for reading my approach.\\n\\n\\n# Complexity\\n- Time complexity: O(n) where n is the length of input string `path`.\\n\\n- Space complexity: Also O(n).\\n\\n# Code\\n```\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n\\tst.a = append(st.a, x)\\n}\\n\\nfunc (st *stack) peek() string {\\n\\treturn st.a[len(st.a)-1]\\n}\\n\\nfunc (st *stack) pop() string {\\n\\tret := st.peek()\\n\\tst.a = st.a[:len(st.a)-1]\\n\\treturn ret\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n\\treturn len(st.a) == 0\\n}\\n\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n\\nfunc simplifyPath(path string) string {\\n\\t// ensure slash at ending\\n\\tpath += \"/\"\\n\\n\\tst := stack{}\\n\\n\\tchars := strings.Split(path, \"\")\\n\\tdir := \"\"\\n\\tfor _, char := range chars {\\n\\t\\tswitch {\\n\\t\\tcase char == \"/\":\\n\\t\\t\\tswitch dir {\\n\\t\\t\\tcase \".\", \"\":\\n\\t\\t\\t\\t// do nothing\\n\\t\\t\\tcase \"..\":\\n\\t\\t\\t\\tif !st.isEmpty() {\\n\\t\\t\\t\\t\\tst.pop()\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tst.push(dir)\\n\\t\\t\\t}\\n\\t\\t\\tdir = \"\"\\n\\n\\t\\tdefault:\\n\\t\\t\\tdir += char\\n\\t\\t}\\n\\t}\\n\\n\\treturn st.constructAbsolutePath()\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n    // implementation here\\n}\\n\\nfunc (st *stack) peek() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) pop() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n    // implementation here\\n}\\n```\n```go\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n```\n```\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n\\tst.a = append(st.a, x)\\n}\\n\\nfunc (st *stack) peek() string {\\n\\treturn st.a[len(st.a)-1]\\n}\\n\\nfunc (st *stack) pop() string {\\n\\tret := st.peek()\\n\\tst.a = st.a[:len(st.a)-1]\\n\\treturn ret\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n\\treturn len(st.a) == 0\\n}\\n\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n\\nfunc simplifyPath(path string) string {\\n\\t// ensure slash at ending\\n\\tpath += \"/\"\\n\\n\\tst := stack{}\\n\\n\\tchars := strings.Split(path, \"\")\\n\\tdir := \"\"\\n\\tfor _, char := range chars {\\n\\t\\tswitch {\\n\\t\\tcase char == \"/\":\\n\\t\\t\\tswitch dir {\\n\\t\\t\\tcase \".\", \"\":\\n\\t\\t\\t\\t// do nothing\\n\\t\\t\\tcase \"..\":\\n\\t\\t\\t\\tif !st.isEmpty() {\\n\\t\\t\\t\\t\\tst.pop()\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tst.push(dir)\\n\\t\\t\\t}\\n\\t\\t\\tdir = \"\"\\n\\n\\t\\tdefault:\\n\\t\\t\\tdir += char\\n\\t\\t}\\n\\t}\\n\\n\\treturn st.constructAbsolutePath()\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3412890,
                "title": "easy-solution-with-explanation-in-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const res = [];\\n    const arr = path.split(\"/\");\\n    for(let str of arr) {\\n        // when you see .. symbol\\n        // check result array and if it\\'s not empty\\n        // pop the last element\\n        if(str === \"..\") {\\n            if(res.length !== 0) {\\n                res.pop();\\n            }\\n        } \\n        // if you split \"a//b\" the result [\\'a\\',\\'\\',\\'b\\']\\n        // So check the length>=1 and ignore the period\\n        else if(str.length>=1 && str!==\".\") {\\n            res.push(str);\\n        } \\n    }\\n    return \"/\"+res.join(\"/\");\\n};\\n```\\n# If You Like, Please, Upvote!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const res = [];\\n    const arr = path.split(\"/\");\\n    for(let str of arr) {\\n        // when you see .. symbol\\n        // check result array and if it\\'s not empty\\n        // pop the last element\\n        if(str === \"..\") {\\n            if(res.length !== 0) {\\n                res.pop();\\n            }\\n        } \\n        // if you split \"a//b\" the result [\\'a\\',\\'\\',\\'b\\']\\n        // So check the length>=1 and ignore the period\\n        else if(str.length>=1 && str!==\".\") {\\n            res.push(str);\\n        } \\n    }\\n    return \"/\"+res.join(\"/\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411390,
                "title": "easy-to-understand-c-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n     stack<string> st;\\n        for(int i = 0; i < path.size(); ++i) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp;\\n            while(i < path.size() && path[i] != \\'/\\') {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n            }\\n            else st.push(temp);\\n        }\\n        path = \"\";\\n        while(!st.empty()) {\\n            path = \"/\" + st.top() + path;\\n            st.pop();\\n        }\\n        if(path.size() == 0) return \"/\";\\n        return path;}\\n};\\n \\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n     stack<string> st;\\n        for(int i = 0; i < path.size(); ++i) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp;\\n            while(i < path.size() && path[i] != \\'/\\') {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n            }\\n            else st.push(temp);\\n        }\\n        path = \"\";\\n        while(!st.empty()) {\\n            path = \"/\" + st.top() + path;\\n            st.pop();\\n        }\\n        if(path.size() == 0) return \"/\";\\n        return path;}\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410455,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int len = path.length();\\n        stack<string> st;\\n        string ans = \"\";\\n        for(int i=0; i<len; i++) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp = \"\";\\n            while(i < len && path[i] != \\'/\\') temp += path[i++];\\n            if(temp == \".\") continue;\\n            if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n                continue;\\n            }\\n            st.push(temp);\\n        }\\n        while(!st.empty()) {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.size()) return ans;\\n        else return \"/\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int len = path.length();\\n        stack<string> st;\\n        string ans = \"\";\\n        for(int i=0; i<len; i++) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp = \"\";\\n            while(i < len && path[i] != \\'/\\') temp += path[i++];\\n            if(temp == \".\") continue;\\n            if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n                continue;\\n            }\\n            st.push(temp);\\n        }\\n        while(!st.empty()) {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.size()) return ans;\\n        else return \"/\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409893,
                "title": "simplify-path-best-solution-in-c-using-stack",
                "content": "##  PLEASE UPVOTE  \\uD83D\\uDC4D IF SOLUTION HELPED IN ANYWAY\\n\\n# Code :\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n\\n        stack<string> st;\\n        int i=0, j=0;\\n        while(i<path.length())  {\\n            if(path[i] == \\'/\\')  {i++;continue;}\\n            string temp = \"\";\\n            j=i;\\n            while(j<path.length() && path[j] != \\'/\\')   {\\n                temp.push_back(path[j]);\\n                j++;\\n            }\\n            i=j;\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\" && st.empty())   continue;\\n            else if(temp == \"..\" && !st.empty())   st.pop();\\n            else st.push(temp);\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty())  {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.length() == 0)   return \"/\";\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n\\n        stack<string> st;\\n        int i=0, j=0;\\n        while(i<path.length())  {\\n            if(path[i] == \\'/\\')  {i++;continue;}\\n            string temp = \"\";\\n            j=i;\\n            while(j<path.length() && path[j] != \\'/\\')   {\\n                temp.push_back(path[j]);\\n                j++;\\n            }\\n            i=j;\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\" && st.empty())   continue;\\n            else if(temp == \"..\" && !st.empty())   st.pop();\\n            else st.push(temp);\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty())  {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.length() == 0)   return \"/\";\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409788,
                "title": "clever-and-easy-with-stringstream-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stringstream ss(path);\\n        vector<string> stack;\\n        string word;\\n\\n        while(getline(ss, word, \\'/\\')){\\n            if(word.empty() || word == \".\") continue;\\n            if(word == \"..\"){\\n                if(stack.size()) stack.pop_back();\\n                continue;\\n            }\\n            stack.push_back(word);\\n        }\\n\\n        word = \"/\";\\n        for(auto &i: stack) word += i + \"/\";\\n        if(word.size() > 1) word = word.substr(0, word.size() - 1);\\n        return word;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stringstream ss(path);\\n        vector<string> stack;\\n        string word;\\n\\n        while(getline(ss, word, \\'/\\')){\\n            if(word.empty() || word == \".\") continue;\\n            if(word == \"..\"){\\n                if(stack.size()) stack.pop_back();\\n                continue;\\n            }\\n            stack.push_back(word);\\n        }\\n\\n        word = \"/\";\\n        for(auto &i: stack) word += i + \"/\";\\n        if(word.size() > 1) word = word.substr(0, word.size() - 1);\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409752,
                "title": "java-solution-with-simple-explanation",
                "content": "### Stack\\n\\nIdea: First, split array using `/`. Second, iterate array and pop the stack if the path is `..`, push the string while the path is not empty and `.`. Finally, generate result path using string builder.\\n\\n```java\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] pathArray = path.split(\"/\");\\n\\n        for (String s : pathArray) {\\n            if (s.equals(\"..\")) {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n            } else if (s.length() != 0 && !s.equals(\".\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            res.insert(0, \"/\" + stack.pop());\\n        }\\n\\n        return res.toString().length() > 0 ? res.toString() : \"/\";\\n    }\\n}\\n```\\n\\nComplexity Analysis:\\n\\n- Time Complexity: $O(n)$. $n$ is the length of path.\\n- Space Complexity: $O(n)$. Stack costs $O(n)$ space complexity.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] pathArray = path.split(\"/\");\\n\\n        for (String s : pathArray) {\\n            if (s.equals(\"..\")) {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n            } else if (s.length() != 0 && !s.equals(\".\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            res.insert(0, \"/\" + stack.pop());\\n        }\\n\\n        return res.toString().length() > 0 ? res.toString() : \"/\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409708,
                "title": "simple-solution",
                "content": "# Approach\\nThis problem can be solved using only one loop. Firstly, one needs to identify that we need to get directories first and store them in an array so that we can generate our path using it. \\n1) Spliting the path and converting into array using simple .split method will return all the directories in the path including `.` and `..`\\n2) Store your generated path in a stack, so that if a special command e.g `..` is entered we simple remove the last directory from the stack or stay on the same directory for `.` and loop over \\n3) for directory name simple keep pushing it in stack\\n\\n# Code\\n```\\n# @param {String} path\\n# @return {String}\\ndef simplify_path(path)\\n    result = []\\n    directories = path.split(\\'/\\') \\n    directories.each_with_index do |dir, index|\\n        if dir.eql?(\\'.\\') or dir.eql?(\\'\\')\\n            next\\n        elsif dir.eql?(\\'..\\')\\n            result.pop() if result.length > 0\\n        else\\n            result << dir\\n        end\\n    end\\n    \\'/\\' + result.join(\\'/\\')\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} path\\n# @return {String}\\ndef simplify_path(path)\\n    result = []\\n    directories = path.split(\\'/\\') \\n    directories.each_with_index do |dir, index|\\n        if dir.eql?(\\'.\\') or dir.eql?(\\'\\')\\n            next\\n        elsif dir.eql?(\\'..\\')\\n            result.pop() if result.length > 0\\n        else\\n            result << dir\\n        end\\n    end\\n    \\'/\\' + result.join(\\'/\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3409583,
                "title": "beats-100-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        stack<string>st;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            if(temp == \"\" || temp == \".\"){\\n                // continue;\\n            }\\n            else if(temp == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n            i = id;\\n        }\\n        stack<string>st2;\\n        while(!st.empty()){\\n            st2.push(st.top());\\n            st.pop();\\n        }\\n\\n        string ans = \"\";\\n        while(!st2.empty()){\\n            ans+=\"/\";\\n            ans+=st2.top();\\n            st2.pop();\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        stack<string>st;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            if(temp == \"\" || temp == \".\"){\\n                // continue;\\n            }\\n            else if(temp == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n            i = id;\\n        }\\n        stack<string>st2;\\n        while(!st.empty()){\\n            st2.push(st.top());\\n            st.pop();\\n        }\\n\\n        string ans = \"\";\\n        while(!st2.empty()){\\n            ans+=\"/\";\\n            ans+=st2.top();\\n            st2.pop();\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409428,
                "title": "easy-to-understand-c-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        vector<string>v;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            v.push_back(temp);\\n            i = id;\\n        }\\n        stack<string>st;\\n        int sz = v.size();\\n        for(int i=0; i<sz; i++){\\n            if(v[i] == \"\" || v[i] == \".\"){\\n                continue;\\n            }\\n            else if(v[i] == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(v[i]);\\n            }\\n        }\\n        v.clear();\\n        string ans = \"\";\\n        while(!st.empty()){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        sz = v.size();\\n        for(int i=sz-1; i>=0; i--){\\n            ans += \"/\";\\n            ans += v[i];\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        vector<string>v;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            v.push_back(temp);\\n            i = id;\\n        }\\n        stack<string>st;\\n        int sz = v.size();\\n        for(int i=0; i<sz; i++){\\n            if(v[i] == \"\" || v[i] == \".\"){\\n                continue;\\n            }\\n            else if(v[i] == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(v[i]);\\n            }\\n        }\\n        v.clear();\\n        string ans = \"\";\\n        while(!st.empty()){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        sz = v.size();\\n        for(int i=sz-1; i>=0; i--){\\n            ans += \"/\";\\n            ans += v[i];\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409393,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconvert the string to array for easy manulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n\\n    // Split on slash\\n    let s = path.split(\\'/\\');\\n    \\n    // Filter out empty strings\\n    s = s.filter((el)=>el!==\\'\\');\\n    \\n    const answer = [];\\n    \\n    for(const el of s){        \\n        if(el === \\'.\\'){\\n            // do nothing\\n        }else if(el === \\'..\\'){\\n            answer.pop(); // In JavaScript no need to check whether the array is empty or not before popping\\n        }else{\\n            answer.push(el);\\n        }\\n    }\\n    \\n    return \\'/\\' + answer.join(\\'/\\');\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n\\n    // Split on slash\\n    let s = path.split(\\'/\\');\\n    \\n    // Filter out empty strings\\n    s = s.filter((el)=>el!==\\'\\');\\n    \\n    const answer = [];\\n    \\n    for(const el of s){        \\n        if(el === \\'.\\'){\\n            // do nothing\\n        }else if(el === \\'..\\'){\\n            answer.pop(); // In JavaScript no need to check whether the array is empty or not before popping\\n        }else{\\n            answer.push(el);\\n        }\\n    }\\n    \\n    return \\'/\\' + answer.join(\\'/\\');\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409347,
                "title": "very-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String>st=new Stack<>();\\n        \\n        for(int i=0;i<path.length();i++){\\n            if(path.charAt(i)==\\'/\\') continue;\\n\\n            String temp=\"\";\\n            while(i<path.length() && path.charAt(i)!=\\'/\\'){\\n                temp+=path.charAt(i);\\n                i++;\\n            }\\n\\n            if(temp.equals(\".\")) continue;\\n            else if(temp.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n        }\\n        \\n        String ans=\"\";\\n        while(!st.isEmpty()){\\n            ans=\"/\"+st.pop()+ans;\\n        }\\n        if(ans.length()==0) return \"/\";\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String>st=new Stack<>();\\n        \\n        for(int i=0;i<path.length();i++){\\n            if(path.charAt(i)==\\'/\\') continue;\\n\\n            String temp=\"\";\\n            while(i<path.length() && path.charAt(i)!=\\'/\\'){\\n                temp+=path.charAt(i);\\n                i++;\\n            }\\n\\n            if(temp.equals(\".\")) continue;\\n            else if(temp.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n        }\\n        \\n        String ans=\"\";\\n        while(!st.isEmpty()){\\n            ans=\"/\"+st.pop()+ans;\\n        }\\n        if(ans.length()==0) return \"/\";\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409328,
                "title": "java-easy-solutions-99-faster-3-approaches-without-stack-and-using-stack",
                "content": "**PLEASE UPVOTE IF YOU FIND IT USEFUL**\\n\\n# Approach 1\\nUsing Stack and String Split funtion.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) 4ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n       Stack<String> stack=new Stack<>();\\n       String []str=path.split(\"/\");\\n       for(String s: str){\\n           //System.out.println(s);\\n           if(s.equals(\".\") || s.equals(\"\"))continue;\\n           else if(s.equals(\"..\")){if(!stack.isEmpty()) stack.pop();}\\n           else stack.push(s);\\n       }\\n       //System.out.println(stack);\\n       Collections.reverse(stack);\\n       StringBuilder sb=new StringBuilder();\\n       while(!stack.isEmpty()){\\n           sb.append(\"/\");\\n           sb.append(stack.pop());\\n       }\\n       if(sb.length()==0) return \"/\";\\n       return sb.toString();\\n    }\\n}\\n```\\n\\n# Approach 2\\nWithout using Stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) 2ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        char []stack=new char[len];\\n        int i=0;\\n\\t\\t    int j=-1;\\n        while(i<len){\\n            if(j>=0 && (stack[j] == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack[j] == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(j>=0 && dot>0){\\n                    if(stack[j--]==\\'/\\')dot--;\\n                    }\\n                    if(j==-1) j=0;\\n                }\\n            }\\n            else{\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                } \\n        }\\n        if(stack[j]==\\'/\\'&& j>1) j--;\\n\\n        return String.valueOf(stack,0,j+1);\\n  }\\n}\\n```\\n# Approach 3\\nUsing Stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) 12ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        Stack<Character> stack=new Stack<>();\\n        int i=0;\\n        while(i<len){\\n            if(!stack.isEmpty() && (stack.peek() == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack.peek() == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(!stack.isEmpty() && dot>0){\\n                    if(stack.pop()==\\'/\\')dot--;\\n                    }\\n                    if(stack.isEmpty()) stack.push(\\'/\\');\\n                }\\n            }\\n            else{\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                } \\n        }\\n         StringBuilder sb=new StringBuilder();\\n         if(stack.peek()==\\'/\\'&& stack.size()>1) stack.pop();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n\\n        return sb.reverse().toString();\\n}\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n       Stack<String> stack=new Stack<>();\\n       String []str=path.split(\"/\");\\n       for(String s: str){\\n           //System.out.println(s);\\n           if(s.equals(\".\") || s.equals(\"\"))continue;\\n           else if(s.equals(\"..\")){if(!stack.isEmpty()) stack.pop();}\\n           else stack.push(s);\\n       }\\n       //System.out.println(stack);\\n       Collections.reverse(stack);\\n       StringBuilder sb=new StringBuilder();\\n       while(!stack.isEmpty()){\\n           sb.append(\"/\");\\n           sb.append(stack.pop());\\n       }\\n       if(sb.length()==0) return \"/\";\\n       return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        char []stack=new char[len];\\n        int i=0;\\n\\t\\t    int j=-1;\\n        while(i<len){\\n            if(j>=0 && (stack[j] == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack[j] == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(j>=0 && dot>0){\\n                    if(stack[j--]==\\'/\\')dot--;\\n                    }\\n                    if(j==-1) j=0;\\n                }\\n            }\\n            else{\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                } \\n        }\\n        if(stack[j]==\\'/\\'&& j>1) j--;\\n\\n        return String.valueOf(stack,0,j+1);\\n  }\\n}\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        Stack<Character> stack=new Stack<>();\\n        int i=0;\\n        while(i<len){\\n            if(!stack.isEmpty() && (stack.peek() == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack.peek() == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(!stack.isEmpty() && dot>0){\\n                    if(stack.pop()==\\'/\\')dot--;\\n                    }\\n                    if(stack.isEmpty()) stack.push(\\'/\\');\\n                }\\n            }\\n            else{\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                } \\n        }\\n         StringBuilder sb=new StringBuilder();\\n         if(stack.peek()==\\'/\\'&& stack.size()>1) stack.pop();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n\\n        return sb.reverse().toString();\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408323,
                "title": "java-solution-beginer-level-can-understand-upvote-plz",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery java beginer Can understand this intuition..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBeginner Level Approch..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n    Stack<String>stack = new Stack<>();\\n    String res =\"\";\\nfor(int i=0;i<path.length();i++){\\n    if(path.charAt(i)==\\'/\\'){\\n        continue;\\n    }\\n    String temp =\"\";\\n    while(i<path.length() && path.charAt(i) != \\'/\\'){\\n        temp +=path.charAt(i);\\n        ++i;\\n    }\\n       \\n           if(temp.equals(\".\")){\\n               continue;\\n           }else if(temp.equals(\"..\")){\\n               if(!stack.isEmpty())\\n               stack.pop();\\n           }else{\\n               stack.push(temp);\\n           }\\n\\n         }\\n        \\n         while(!stack.isEmpty()){\\n             res = \"/\"+stack.peek()+res;\\n             stack.pop();\\n         }\\n         if(res.length()==0){\\n             return \"/\";\\n         }\\n    return res;\\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n    Stack<String>stack = new Stack<>();\\n    String res =\"\";\\nfor(int i=0;i<path.length();i++){\\n    if(path.charAt(i)==\\'/\\'){\\n        continue;\\n    }\\n    String temp =\"\";\\n    while(i<path.length() && path.charAt(i) != \\'/\\'){\\n        temp +=path.charAt(i);\\n        ++i;\\n    }\\n       \\n           if(temp.equals(\".\")){\\n               continue;\\n           }else if(temp.equals(\"..\")){\\n               if(!stack.isEmpty())\\n               stack.pop();\\n           }else{\\n               stack.push(temp);\\n           }\\n\\n         }\\n        \\n         while(!stack.isEmpty()){\\n             res = \"/\"+stack.peek()+res;\\n             stack.pop();\\n         }\\n         if(res.length()==0){\\n             return \"/\";\\n         }\\n    return res;\\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408035,
                "title": "python-elegant-short-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n```\\nclass Solution:\\n\\n    SEP = \\'/\\'\\n    CURRENT_DIR = \\'.\\'\\n    PARENT_DIR = \\'..\\'\\n\\n    def simplifyPath(self, path: str) -> str:\\n        simplified = []\\n\\n        for directory in path.split(self.SEP):\\n            if not directory or directory == self.CURRENT_DIR:\\n                continue\\n\\n            if directory == self.PARENT_DIR:\\n                if simplified:\\n                    simplified.pop()\\n            else:\\n                simplified.append(directory)\\n\\n        return self.SEP + self.SEP.join(simplified)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    SEP = \\'/\\'\\n    CURRENT_DIR = \\'.\\'\\n    PARENT_DIR = \\'..\\'\\n\\n    def simplifyPath(self, path: str) -> str:\\n        simplified = []\\n\\n        for directory in path.split(self.SEP):\\n            if not directory or directory == self.CURRENT_DIR:\\n                continue\\n\\n            if directory == self.PARENT_DIR:\\n                if simplified:\\n                    simplified.pop()\\n            else:\\n                simplified.append(directory)\\n\\n        return self.SEP + self.SEP.join(simplified)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407966,
                "title": "unlimited-logic-with-stack",
                "content": "\\n\\n# Python Solution With Python\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        res=\"\"\\n        for c in path+\\'/\\':\\n            if c==\\'/\\':\\n                if res==\"..\":\\n                    if stack: stack.pop()\\n                elif res!=\"\" and res!=\\'.\\':\\n                    stack.append(res)\\n                res=\"\"\\n            else:\\n                res+=c\\n        return \"/\"+\"/\".join(stack)\\n```\\n# \\'/\\' is added due to the edges of like \"a/b/c/d///././..\"-->this test case has last two string are \"..\" which removes one element from stack then output gives \"a/b/c\" so we can solve that test case by adding \\'/\\' then output is \"a/b/c/d\"\\n\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        res=\"\"\\n        for c in path+\\'/\\':\\n            if c==\\'/\\':\\n                if res==\"..\":\\n                    if stack: stack.pop()\\n                elif res!=\"\" and res!=\\'.\\':\\n                    stack.append(res)\\n                res=\"\"\\n            else:\\n                res+=c\\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407042,
                "title": "c-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        string ans=\"\";\\n        for(int i=0;i<path.size();i++){\\n            if(path[i]==\\'/\\'){\\n                continue;\\n            }\\n            string temp;\\n            while(i<path.size() && path[i]!=\\'/\\'){\\n                temp+=path[i];\\n                i++;\\n            }\\n            if(temp==\".\"){\\n                continue;\\n            }else if(temp==\"..\"){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=\\'/\\'+st.top()+ans;\\n            st.pop();\\n        }\\n        if(ans.size()==0){\\n            return \"/\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        string ans=\"\";\\n        for(int i=0;i<path.size();i++){\\n            if(path[i]==\\'/\\'){\\n                continue;\\n            }\\n            string temp;\\n            while(i<path.size() && path[i]!=\\'/\\'){\\n                temp+=path[i];\\n                i++;\\n            }\\n            if(temp==\".\"){\\n                continue;\\n            }else if(temp==\"..\"){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=\\'/\\'+st.top()+ans;\\n            st.pop();\\n        }\\n        if(ans.size()==0){\\n            return \"/\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406981,
                "title": "java-stack",
                "content": "# Intuition\\nBetter use \"split\" to make the logic cleaner. My first trial didn\\'t used \"split\" and turnout my logic was messy.\\n\\n# Approach\\nstack\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) -> because of stack\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!(s.equals(\"\") || s.equals(\".\") || s.equals(\"..\"))) stack.add(s);\\n        }\\n\\n        String ans = \"\";\\n        for (String i : stack) {\\n            ans += \"/\" + i;\\n        }\\n        return ans.isEmpty() ? \"/\" : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!(s.equals(\"\") || s.equals(\".\") || s.equals(\"..\"))) stack.add(s);\\n        }\\n\\n        String ans = \"\";\\n        for (String i : stack) {\\n            ans += \"/\" + i;\\n        }\\n        return ans.isEmpty() ? \"/\" : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406944,
                "title": "stack-python-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstack problem \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsplit path and iterate through it \\nhanlding 3 cases \\n1- if cur_val is \"..\" and stack is empty of cur_val is \".\" do nothing and contniue \\n2 - if cur_val is \"..\" and stack , pop last ele from stack\\n3 - otherwise , append val to stack\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path =[p for p in path if p ]\\n        for p in path:\\n            if (len(stack)==0 and p==\"..\") or p ==\".\":\\n                continue \\n            elif p==\"..\" and stack:\\n                stack.pop()\\n            else:\\n                stack.append(p)\\n        return \"/\" + \"/\".join(stack)\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path =[p for p in path if p ]\\n        for p in path:\\n            if (len(stack)==0 and p==\"..\") or p ==\".\":\\n                continue \\n            elif p==\"..\" and stack:\\n                stack.pop()\\n            else:\\n                stack.append(p)\\n        return \"/\" + \"/\".join(stack)\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406773,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def simplifyPath(path: String): String = \\n        path.split(\"/+\").foldLeft(List[String]())((acc, cur) => cur match {\\n            case \"..\" => scala.util.Try(acc.tail).getOrElse(List[String]())\\n            case \".\" | \"\" => acc\\n            case _ => cur +: acc\\n        }).reverse.mkString(\"/\", \"/\", \"\")\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def simplifyPath(path: String): String = \\n        path.split(\"/+\").foldLeft(List[String]())((acc, cur) => cur match {\\n            case \"..\" => scala.util.Try(acc.tail).getOrElse(List[String]())\\n            case \".\" | \"\" => acc\\n            case _ => cur +: acc\\n        }).reverse.mkString(\"/\", \"/\", \"\")\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3406669,
                "title": "daily-leetcoding-challenge-april-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3181590,
                "title": "71-simplify-path-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Split the input string path into a list of directories using .split(\\'/\\').\\n2. Initialize an empty list stack to store the directories.\\n3. Loop through the list of directories.\\n4. If the directory is an empty string or a single period, skip it.\\n5. If the directory is .., pop the last directory from the stack.\\n6. If the directory is a regular directory name, push it to the stack.\\n7. Join the directories in the stack using /.join and add a leading slash.\\n8. Return the simplified path.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        # split the path into a list of directories\\n        dirs = path.split(\\'/\\')\\n        # initialize a stack to store the directories\\n        stack = []\\n        for dir in dirs:\\n            if dir == \\'\\' or dir == \\'.\\':\\n                continue\\n            elif dir == \\'..\\':\\n                if len(stack) > 0:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        # join the directories in the stack and add a leading slash\\n        return \\'/\\' + \\'/\\'.join(stack)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        # split the path into a list of directories\\n        dirs = path.split(\\'/\\')\\n        # initialize a stack to store the directories\\n        stack = []\\n        for dir in dirs:\\n            if dir == \\'\\' or dir == \\'.\\':\\n                continue\\n            elif dir == \\'..\\':\\n                if len(stack) > 0:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        # join the directories in the stack and add a leading slash\\n        return \\'/\\' + \\'/\\'.join(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178616,
                "title": "simple-python-solution",
                "content": "# Complexity\\n- Time complexity: Given `n = len(path)` then complexity is `O(n)`\\n\\n- Space complexity: Given `n = len(path)` then complexity is `O(n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        levels, stack = path.split(\"/\"), []\\n\\n        for l in levels:\\n            if len(l)>0 and l != \\'.\\':\\n                if l == \\'..\\' and stack:\\n                    stack.pop()\\n                else if != \\'..\\':\\n                    stack.append(l)\\n        \\n        return \"/\"+\"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        levels, stack = path.split(\"/\"), []\\n\\n        for l in levels:\\n            if len(l)>0 and l != \\'.\\':\\n                if l == \\'..\\' and stack:\\n                    stack.pop()\\n                else if != \\'..\\':\\n                    stack.append(l)\\n        \\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824793,
                "title": "java-stack-deque",
                "content": "### **Please Upvote** :D\\n##### 1. Using Stack:\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!stack.isEmpty() && s.equals(\"..\")) {\\n                stack.pop();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        if (stack.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : stack) {\\n            sb.append(\\'/\\').append(s);\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### 2. Using Deque:\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dq = new LinkedList<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!dq.isEmpty() && s.equals(\"..\")) {\\n                dq.poll();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                dq.push(s);\\n            }\\n        }\\n\\n        if (dq.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!dq.isEmpty()) {\\n            sb.append(\\'/\\').append(dq.pollLast());\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!stack.isEmpty() && s.equals(\"..\")) {\\n                stack.pop();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        if (stack.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : stack) {\\n            sb.append(\\'/\\').append(s);\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dq = new LinkedList<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!dq.isEmpty() && s.equals(\"..\")) {\\n                dq.poll();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                dq.push(s);\\n            }\\n        }\\n\\n        if (dq.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!dq.isEmpty()) {\\n            sb.append(\\'/\\').append(dq.pollLast());\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725073,
                "title": "java-simple-two-approaches",
                "content": "# Two Approaches \\n\\n**1. Using Stack**\\nTC O(N) & SC O(N)\\n\\n```\\nclass Solution{\\n  public String simplifyPath(String path) {\\n       Stack<String> s=new Stack<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.pop();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.insert(0,s.pop()).insert(0,\"/\");\\n       }\\n       return res.toString();\\n    }\\n}\\n```\\n\\n**2. Using Deque**\\nTC O(N) & SC O(N)\\n\\n```\\nclass Solution{\\n  public static String simplifyPath(String path) {\\n      Deque<String> s=new LinkedList<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.poll();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.append(\"/\").append(s.pollLast());  //pollLast will give u the first element from Dq\\n       }\\n       return res.toString();  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n  public String simplifyPath(String path) {\\n       Stack<String> s=new Stack<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.pop();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.insert(0,s.pop()).insert(0,\"/\");\\n       }\\n       return res.toString();\\n    }\\n}\\n```\n```\\nclass Solution{\\n  public static String simplifyPath(String path) {\\n      Deque<String> s=new LinkedList<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.poll();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.append(\"/\").append(s.pollLast());  //pollLast will give u the first element from Dq\\n       }\\n       return res.toString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715470,
                "title": "made-it-simple-stacks-sliding-window-based-on-hi-malik-solution-c-version",
                "content": "**The Entire idea is**\\n* We have the path\\n* We can split based on / slashes\\n* /a//b/../c/d/ -> a, b, .. , c, d = > We get the directories\\n* Then we need to do only ONE THING\\n* Put things onto stack. \\n* we need to go back that is POP when we see ..\\n* So at last we have the PATH IN STACK.\\n* When we POP And CONTRUCT THE ANS. We need to do in reverse manner.\\n* PATH = / DIRECTORY + OLD PATH\\n\\nHOW WE SPLIT?\\n* We could have used string stream or any other.\\n* But we did manually with sliding window.\\n* i always points to start of string and j points to the end.\\n* whenever u see \\'/\\' its time to enter the directory. Then move to next non slash place.\\n\\n```\\n//TIME : O(N)\\n//SPACE: O(N)\\n\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> arr;\\n        int N = path.size();\\n        int i = 1;\\n        int j = 1;\\n        while(j < N){\\n            if(path[j] == \\'/\\'){\\n                arr.push_back(path.substr(i,j-i));\\n                //now point j to a non /\\n                while(path[j]==\\'/\\'){\\n                    j++;\\n                }\\n                i = j;\\n            }\\n            //else its not / \\n            j++;\\n        }\\n        \\n        if(i<N){\\n            //Edge case = when there is no last back slash\\n            arr.push_back(path.substr(i,j-i));\\n        }\\n        \\n        stack<string> stk;\\n        \\n        for(auto s : arr){\\n            if(stk.size()>0 && s==\"..\") stk.pop(); // as we move one step back in directory\\n            else if(s != \"\" && s!= \".\" && s!=\"..\") stk.push(s);\\n        }\\n        \\n        //edge case = when \"\" path is given\\n        if(stk.empty()) return \"/\";\\n        \\n        //PATH FORMATION\\n        string res=\"\";\\n        while(!stk.empty()){\\n           \\n            res = \\'/\\' + stk.top() + res;\\n            stk.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\n//TIME : O(N)\\n//SPACE: O(N)\\n\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> arr;\\n        int N = path.size();\\n        int i = 1;\\n        int j = 1;\\n        while(j < N){\\n            if(path[j] == \\'/\\'){\\n                arr.push_back(path.substr(i,j-i));\\n                //now point j to a non /\\n                while(path[j]==\\'/\\'){\\n                    j++;\\n                }\\n                i = j;\\n            }\\n            //else its not / \\n            j++;\\n        }\\n        \\n        if(i<N){\\n            //Edge case = when there is no last back slash\\n            arr.push_back(path.substr(i,j-i));\\n        }\\n        \\n        stack<string> stk;\\n        \\n        for(auto s : arr){\\n            if(stk.size()>0 && s==\"..\") stk.pop(); // as we move one step back in directory\\n            else if(s != \"\" && s!= \".\" && s!=\"..\") stk.push(s);\\n        }\\n        \\n        //edge case = when \"\" path is given\\n        if(stk.empty()) return \"/\";\\n        \\n        //PATH FORMATION\\n        string res=\"\";\\n        while(!stk.empty()){\\n           \\n            res = \\'/\\' + stk.top() + res;\\n            stk.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695541,
                "title": "easy-solution-in-c-two-approaches-using-stack",
                "content": "**Happy LeetCoding\\uD83D\\uDCAF\\nPlease Upvote if u liked my Solution\\uD83D\\uDE42**\\n# Code\\n***1st Approach***\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<char> sta;\\n        while(i<size){\\n            if(sta.size()==0){\\n                sta.push(path[i++]);\\n                continue;\\n            }\\n            if((sta.top()==\\'/\\' && path[i]==\\'/\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+1<size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'/\\')||(i+1==size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+2==size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'.\\')||(i+2<size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\' && path[i+1]==\\'.\\' && path[i+2]==\\'/\\')){\\n                sta.pop();\\n                while(sta.size()>0 && sta.top()!=\\'/\\')\\n                    sta.pop();\\n                i+=2;\\n            }\\n            else\\n                sta.push(path[i++]);\\n        }\\n        string ans=\"\";\\n        if(sta.size()==0)\\n            return \"/\";\\n        else if(sta.size()>=2 && sta.top()==\\'/\\')\\n            sta.pop();\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n***2nd Approach(A bit easier)***\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n       int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<string> sta;\\n        while(i<size){\\n            if(path[i]==\\'/\\'){\\n                i++;\\n                continue;\\n            }\\n            string tmp=\"\";\\n            while(i<size && path[i]!=\\'/\\')\\n                tmp+=path[i++];\\n            if(tmp == \".\" || tmp == \"\")\\n                continue;\\n            else if(tmp == \"..\"){\\n                if(sta.size())\\n                    sta.pop();\\n            }\\n            else\\n                sta.push(tmp);\\n        } \\n        if(sta.size()==0)\\n            return \"/\";\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans=\"/\"+sta.top()+ans;\\n            sta.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<char> sta;\\n        while(i<size){\\n            if(sta.size()==0){\\n                sta.push(path[i++]);\\n                continue;\\n            }\\n            if((sta.top()==\\'/\\' && path[i]==\\'/\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+1<size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'/\\')||(i+1==size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+2==size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'.\\')||(i+2<size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\' && path[i+1]==\\'.\\' && path[i+2]==\\'/\\')){\\n                sta.pop();\\n                while(sta.size()>0 && sta.top()!=\\'/\\')\\n                    sta.pop();\\n                i+=2;\\n            }\\n            else\\n                sta.push(path[i++]);\\n        }\\n        string ans=\"\";\\n        if(sta.size()==0)\\n            return \"/\";\\n        else if(sta.size()>=2 && sta.top()==\\'/\\')\\n            sta.pop();\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n       int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<string> sta;\\n        while(i<size){\\n            if(path[i]==\\'/\\'){\\n                i++;\\n                continue;\\n            }\\n            string tmp=\"\";\\n            while(i<size && path[i]!=\\'/\\')\\n                tmp+=path[i++];\\n            if(tmp == \".\" || tmp == \"\")\\n                continue;\\n            else if(tmp == \"..\"){\\n                if(sta.size())\\n                    sta.pop();\\n            }\\n            else\\n                sta.push(tmp);\\n        } \\n        if(sta.size()==0)\\n            return \"/\";\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans=\"/\"+sta.top()+ans;\\n            sta.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659732,
                "title": "simple-cpp-solution-using-stringstream",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        string simplifyPath(string path)\\n        {\\n            vector<string> vec;\\n            vector<string> st;\\n\\n            stringstream s(path);\\t//split function using stringstream\\n            string w;\\n            while (getline(s, w, \\'/\\'))\\n                if (w.size() != 0)\\n                    vec.push_back(w);\\n\\n            for (auto i: vec)\\n            {\\n                if (i == \"..\" && st.size() != 0) st.pop_back();\\n                else if (i != \".\" && i != \"..\") st.push_back(i);\\n            }\\n            w = \"\";\\n            if (st.size() == 0)\\n                w.push_back(\\'/\\');\\n            for (auto i: st)\\n            {\\n                w.push_back(\\'/\\');\\n                w += i;\\n            }\\n\\n            return w;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string simplifyPath(string path)\\n        {\\n            vector<string> vec;\\n            vector<string> st;\\n\\n            stringstream s(path);\\t//split function using stringstream\\n            string w;\\n            while (getline(s, w, \\'/\\'))\\n                if (w.size() != 0)\\n                    vec.push_back(w);\\n\\n            for (auto i: vec)\\n            {\\n                if (i == \"..\" && st.size() != 0) st.pop_back();\\n                else if (i != \".\" && i != \"..\") st.push_back(i);\\n            }\\n            w = \"\";\\n            if (st.size() == 0)\\n                w.push_back(\\'/\\');\\n            for (auto i: st)\\n            {\\n                w.push_back(\\'/\\');\\n                w += i;\\n            }\\n\\n            return w;\\n        }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1861053,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565677,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1860833,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565479,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861113,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574273,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567841,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1572868,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569365,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566708,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861053,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565677,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1860833,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565479,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861113,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574273,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567841,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1572868,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569365,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566708,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861103,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1567840,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861108,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1860920,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1860884,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1568892,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1567186,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1993508,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861426,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861406,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861071,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1860928,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1672377,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1572767,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2059103,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2033835,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2018566,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2007982,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2002807,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1979717,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1912855,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1862055,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861803,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861713,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861635,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861630,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861617,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861393,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861359,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861346,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861266,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861260,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861184,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861101,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861057,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861048,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861046,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861036,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861035,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861004,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1860966,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860952,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860914,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860898,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860878,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860847,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860829,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860810,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860807,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1817683,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            }
        ]
    }
]