[
    {
        "title": "Minimum Number of Moves to Make Palindrome",
        "question_content": "You are given a string s consisting only of lowercase English letters.\nIn one move, you can select any two adjacent characters of s and swap them.\nReturn the minimum number of moves needed to make s a palindrome.\nNote that the input will be generated such that s can always be converted to a palindrome.\n&nbsp;\nExample 1:\n\nInput: s = \"aabb\"\nOutput: 2\nExplanation:\nWe can obtain two palindromes from s, \"abba\" and \"baab\". \n- We can obtain \"abba\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"abba\".\n- We can obtain \"baab\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"baab\".\nThus, the minimum number of moves needed to make s a palindrome is 2.\n\nExample 2:\n\nInput: s = \"letelt\"\nOutput: 2\nExplanation:\nOne of the palindromes we can obtain from s in 2 moves is \"lettel\".\nOne of the ways we can obtain it is \"letelt\" -> \"letetl\" -> \"lettel\".\nOther palindromes such as \"tleelt\" can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 2000\n\ts consists only of lowercase English letters.\n\ts can be converted to a palindrome using a finite number of moves.",
        "solutions": [
            {
                "id": 1847011,
                "title": "c-2-pointers-with-detail-proof-and-explanation",
                "content": "In this post I \\'m not trying to give the most efficient algorithm or the simplest code. I just try to explain the essence of the problem.\\n\\nA palindrome is an axial symmetry string. Every position holds the same letter with its position symmetry. \\n\\n<img src=\"https://assets.leetcode.com/users/images/05b7eb94-bdf5-409a-b96a-6daf13cdbefb_1647201205.0560412.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\n\\nThe most common idea that we can come up with is using two pointers for the left end and right end. If the current two letters are the same, we advance the pointer. If not, we search for the nearest letter that will make them same and swap it. Look at the following example. \\n1. The current two letters \\'a\\' and \\'d\\' are different. \\n2. We need to exchange one of them to be the same with the other. Notice here, you may keep either one of them. Though the final string may be different, the count of moves we spend are equal(you\\'ll see that later). Here let\\'s keep the right end letter \\'d\\' and search for the nearest \\'d\\' from the left end.\\n\\n<img src=\"https://assets.leetcode.com/users/images/7b842f9f-2350-4517-aebf-ee9483ee151b_1647201247.1059253.png\" alt=\"drawing\" width=\"700\"/>\\n\\n3. After we find the nearest \\'d\\', we need to swap it to the 0-position.\\n\\n<img src=\"https://assets.leetcode.com/users/images/3b3270d3-5637-4232-9cc8-c4f5fae42ae1_1647201266.464941.png\" alt=\"drawing\" width=\"700\"/>\\n\\n4. We advance the two pointers and repeat the same steps until the two pointers meet.\\n\\n<img src=\"https://assets.leetcode.com/users/images/d1ef03b5-8b45-4a93-a157-7316f3886cb4_1647201281.6635847.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nI believe the aforementioned method is easy to understand. However, the difficulty is how we can know the method leads to the minimum moves. Can we convert the string to an arbitrary palindrome with minimal moves? If not, what kind of string we can convert to with minimal moves?\\n\\n**The key point is relative order between the letters.**\\n\\nSince the palindrome is axial symmetry, the same letter pair in the left part and right part must have the opposite relative order. So if two letter pairs have the same relative order, you can\\'t avoid swapping them. In the meantime, if two letter pairs already have the opposite relative order, you should avoid swapping them, or you\\'ll introduce redundant moves and lead to non-optimal solution.\\n\\nLet\\'s look at the example now. All the letters in the left part and right part have the same order. \\n\\n<img src=\"https://assets.leetcode.com/users/images/b0cb65ed-38a6-4b55-aa58-d7ebfbc76006_1647201297.2784958.png\" alt=\"drawing\" width=\"700\"/>\\n\\nSo you need to swap letters to make all the letter pairs in left and right opposite.  You don\\'t have to start from the end, and you can convert either left part or right part. Though this can lead to different palindrome, they all cost the same moves. See the below moves which randomly select the letter pair to swap. After 6 moves, it ends with a different palindrome compared to the former solution.\\n\\n<img src=\"https://assets.leetcode.com/users/images/e94bd00b-3354-4107-a134-efe9110d528d_1647201351.8659885.png\" alt=\"drawing\" width=\"300\"/>\\n\\nWhen we say \"randomly\" here, it means the order of the letter pair we swap. In fact, you can see that all the letter pairs we swap are exactly the combination of the 4 letters \\'abcd\\'. That\\'s why we need 6 moves. We swap every letter pair because in this example, all the letter pair from left and right have the same order. So they all need to be swapped once each. \\nLet\\'s look at another example. \\n\\n<img src=\"https://assets.leetcode.com/users/images/0a16b279-dff9-41fb-982a-f46696a80c1e_1647201374.874811.png\" alt=\"drawing\" width=\"700\"/>\\n\\nIn this example, let\\'s compare the letter pairs relative order in left and right side.\\n(a, b) -- (b, a) -- opposite\\n(a, c) -- (c, a) -- opposite\\n(a, d) -- (a, d) -- same\\n(b, c) -- (b, c) -- same\\n(b, d) -- (b, d) -- same\\n(c, d) -- (c, d) -- same\\nSo, we need to swap 4 letter pairs at least.\\n\\nWe see that (a, b) and (a, c) pair already have the opposite order in the left and right side. So they don\\'t need to be swapped again. But for all the other 4 letter pairs, they still need to be swapped. During your solution you should avoid swapping the letter pair that are already in their right order. \\nSee below, you should not try to swap (c,d) first, which will cause (c, a) be swapped. The same with (b, d).\\n\\n<img src=\"https://assets.leetcode.com/users/images/770e6660-c9f2-447b-be4b-44127be57754_1647201397.2791355.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nSo you can swap (a,d) or (b,c) either you like.\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/2545dcef-6b66-4996-bed8-f6c2cb58a7bc_1647201429.7843585.png\" alt=\"drawing\" width=\"500\"/>\\n\\nAfter 4 moves, we get to the end.\\n\\nTill now, let\\'s answer the question posed earlier. What kind of palindrome can we convert to with minimal moves? The answer should be the palindromes that keep the letter pair order which have already met the conditions. \\nIn the above example \"abcdbcad\", palindromes like \"cabddbac\", \"bacddcab\" are definitely impossible with minimal moves to convert to. Because they require to swap (a,c), (a, b) which are already in good state.\\n\\nLet\\'s try a little more tricky example. The letters are not located on their target side. So what we should keep in mind is just do the necessary swap. \\n\\n<img src=\"https://assets.leetcode.com/users/images/43b6273c-3ff4-458d-a93b-f51f15c17eec_1647201462.2549217.png\" alt=\"drawing\" width=\"700\"/>\\n\\nFirst, we need to know which letter belongs to which side. We should choose the closest letters to each side in order to reduce the moves. Green ones belong to the left side while blue ones belong to the right side.\\n\\n<img src=\"https://assets.leetcode.com/users/images/9cdeae3b-e49d-44f7-97b8-488b3c4af38e_1647201475.2718742.png\" alt=\"drawing\" width=\"700\"/>\\n\\nNow, besides keeping the relative orders, we still need to think about the side. We can not avoid the moves that swap all the blue ones to the right of the green ones.\\n\\n<img src=\"https://assets.leetcode.com/users/images/97d0aa9e-c8a5-4748-8112-f1f91df983e8_1647201505.9667459.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nFinally, let\\'s see why the two pointers algorithm work well. See below, if you keep right end \\'d\\' still, you know that all the other letters are to its left. So when you find and swap the nearest \\'d\\' to left end , you are sure that every single swap you make isn\\'t unnecessary, because \\'d\\' should be in front of all of them. \\n\\n<img src=\"https://assets.leetcode.com/users/images/52baf247-4204-45c6-b445-04b31619e35b_1647201520.1659758.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nAfter the whole idea is clear, let\\'s talk a little bit about a special case we need to notice. When the string length is odd, there must be a letter that has no partner. See the following example, the \\'z\\' has no counterpart. So when we try to search \\'z\\' from the left end, we will end up meeting the right end pointer q. In that case, we know \\'z\\' should be the centerpoint of the result. \\n\\n<img src=\"https://assets.leetcode.com/users/images/cd584ade-5e37-4873-b1bc-c8edba1057db_1647201537.4622815.png\" alt=\"drawing\" width=\"700\"/>\\n\\nYou can record the position of \\'z\\' and advance the q pointer. At the end of the whole process, you can swap \\'z\\' to the centerpoint. Notice here, you should avoid trying to swap the \\'z\\' to the center before the whole process ends. That is because at this time you can\\'t guarantee all the swap you do is necessary. See the example below. The green \\'d\\' is swapped to the right side of \\'z\\' which is an unnecessary cost, because it should be on the left size at the end. However, when you do this after the whole process ends, you won\\'t have this problem.\\n<img src=\"https://assets.leetcode.com/users/images/96fe39f1-06bd-4a38-8344-0e643a562187_1653135480.8935752.png\" alt=\"drawing\" width=\"700\"/>\\n\\n```\\nindrome(string s) {\\n     \\n        int l = 0;\\n        int r = s.length() - 1;\\n\\n        int count = 0;\\n        int center_i = -1;\\n        \\n        while (l < r) {\\n            if (s[l] == s[r]) {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n\\n            int k = l + 1;\\n            for (; k < r; k++) {\\n                if (s[k] == s[r]) {\\n                    break;\\n                }\\n            }\\n\\n            if (k == r) {\\n                center_i = r;\\n                r--;\\n                continue;\\n            }\\n\\n            for (int j = k; j > l; j--) {\\n                swapChar(j, j - 1);\\n                count++;\\n            }\\n            \\n            l++;\\n            r--;\\n        }\\n        \\n        if (center_i != -1) {\\n            count += (center_i - s.size() / 2);\\n        } \\n     \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nindrome(string s) {\\n     \\n        int l = 0;\\n        int r = s.length() - 1;\\n\\n        int count = 0;\\n        int center_i = -1;\\n        \\n        while (l < r) {\\n            if (s[l] == s[r]) {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n\\n            int k = l + 1;\\n            for (; k < r; k++) {\\n                if (s[k] == s[r]) {\\n                    break;\\n                }\\n            }\\n\\n            if (k == r) {\\n                center_i = r;\\n                r--;\\n                continue;\\n            }\\n\\n            for (int j = k; j > l; j--) {\\n                swapChar(j, j - 1);\\n                count++;\\n            }\\n            \\n            l++;\\n            r--;\\n        }\\n        \\n        if (center_i != -1) {\\n            count += (center_i - s.size() / 2);\\n        } \\n     \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822174,
                "title": "c-python-short-greedy-solution",
                "content": "# **Explanation**\\nConsidering the first and the last char in final palindrome.\\nIf they are neither the first nor the last char in the initial string,\\nyou must waste some steps:\\nAssume start with \"...a....a..\"\\n\".a.......a.\" can be ealier completed thand \"a.........a\".\\n\\nThen compare the situation \"a....b..a...b\"\\nIt takes same number of steps to \"ab.........ba\" and \"ba.........ab\".\\nSo  we can actually greedy move the characters to match string prefix.\\n\\nOther reference: https://www.codechef.com/problems/ENCD12\\n\\n# **Complexity**\\nTime `O(n^2)`, can be improved to `O(nlogn)` by segment tree\\nSpace `O(n)`\\n\\n**C++**\\n```cpp\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while (s.size()) {   \\n            int i = s.find(s.back());\\n            if (i == s.size() - 1)\\n                res += i / 2;\\n            else\\n                res += i, s.erase(i, 1);\\n            s.pop_back();\\n        }\\n        return res; \\n    }\\n```\\n**Python**\\n```py\\n    def minMovesToMakePalindrome(self, s):\\n        s = list(s)\\n        res = 0\\n        while s:\\n            i = s.index(s[-1])\\n            if i == len(s) - 1:\\n                res += i / 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while (s.size()) {   \\n            int i = s.find(s.back());\\n            if (i == s.size() - 1)\\n                res += i / 2;\\n            else\\n                res += i, s.erase(i, 1);\\n            s.pop_back();\\n        }\\n        return res; \\n    }\\n```\n```py\\n    def minMovesToMakePalindrome(self, s):\\n        s = list(s)\\n        res = 0\\n        while s:\\n            i = s.index(s[-1])\\n            if i == len(s) - 1:\\n                res += i / 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823173,
                "title": "java-c-2-pointers-step-by-step-dry-run-for-easy-explanation",
                "content": "Below is the dry-run and detailed steps using example string \"aletelt\".  Do \"**Upvote**\" if it helps :)  \\n\\t\\n#### \\tComplexity\\n\\tTime: O(n^2), Space: O(n)\\n\\t\\n#### \\tApproach:\\n\\tIntially, steps = 0.\\n\\t* \\tWe will use 2 index pointers initially - \"l\" as Left and \"r\" as right.  \\n\\t* \\t\\'l\\' will move to right and \\'r\\' will move to left in each iteration. ( l -->    <-- r )  \\n\\t* \\tEach time, we want to check whether characters at \"l\" & \"r\" are equal. \\n\\t\\t* \\tIf yes, then we dont need to do anything as both characters on left & right boundry already are palindrome. Hence, we do l++ & r--.\\n\\t\\t* \\tElse, we assign a index pointer \"k\" at same index as \"r\". It\\'s purpose is to find kth index of character matching with (equal to)\\n\\t\\t\\tcharacter at lth index. So,  keep moving this pointer towards left until we find the character.  We did this in code using\\n\\t\\t    method findKthIndexMatchingwithLthIndex().\\n\\t\\t\\t* \\tIf character not found, k index will reach at index of l.  (k==l).\\n\\t\\t\\t* \\tElse, if found, now we want to bring this character to the index of \"r\". Hence keep swapping while(k < r).  \\n\\t* \\tRepeat above steps. \\t\\n        \\n#### \\t\\tExample & Dry-run\\n        \"a   l   e   t   e   l   t\"\\n         l                       r                  // strArr[l] != strArr[r].  initiate index k = r\\n                                 k                  // loop through k using method findKthIndexMatchingwithLthIndex(), until strArr[l] == strArr[k]\\n                                    \\n         \"a   l   e   t   e   l   t\"\\n          l                       r\\n          k                                         // k reached to index l but did not find any index of k which is equal to strArr[l]\\n                                                    // So, now swap strArr[l] & strArr[l+1]   => now steps = 1\\n                                                    \\n         \"l   a   e   t   e   l   t\"                                                              \\n          l                       r                 // strArr[l] != strArr[r].  initiate index k = r\\n                                  k                 // loop through k using method findKthIndexMatchingwithLthIndex(), until strArr[l] == strArr[k]\\n                                  \\n         \"l   a   e   t   e   l   t\"\\n          l                       r\\n                              k                     // reached k, where strArr[l] == strArr[k]   \\n                                                    // Here k != l, so using while loop, keep swapping element at k and k+1, until k < r. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Here \"steps\" will be updated to 2 i.e steps now = 2\\n           \\n          \"l   a   e   t   e   t   l\" \\n           l                       r\\n                                   k                // now do l++ and r--\\n                                   \\n          \"l   a   e   t   e   t   l\" \\n               l               r\\n                               k \\n                                   \\n    Similarly, keep following above steps or below code, below will be rest of the dry run.\\n            \\n           \"l   a   e   t   e   t   l\"              // strArr[l] != strArr[r]\\n                l               r\\n                                k\\n                                \\n           \"l   a   e   t   e   t   l\"          \\n                l               r\\n                k                                   // k reached to index l but did not find any index of k which is equal to str[l]\\n                                                    // So, now swap strArr[l] & strArr[l+1]  => now steps = 3\\n                \\n           \"l   e   a   t   e   t   l\"              // strArr[l] != strArr[r]\\n                l               r     \\n                                k\\n            \\n           \"l   e   a   t   e   t   l\"\\n                l               r      \\n                            k                       // reached k, where strArr[l] == strArr[k]   \\n                                                    // Here k != l, so using while loop, keep swapping element at k and k+1, until k < r. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tHere \"steps\" will be updated to 4 i.e steps now = 4\\n                            \\n           \"l   e   a   t   t   e   l\"\\n                l               r                                  \\n                                k\\n            \\n           \"l   e   a   t   t   e   l\" \\n                    l       r\\n                            k\\n                            \\n           \"l   e   a   t   t   e   l\" \\n                    l       r\\n                    k                               // k reached to index l but did not find any index of k which is equal to str[l]\\n                                                    // So, now swap strArr[l] & strArr[l+1]   => now steps = 5\\n                    \\n           \"l   e   t   a   t   e   l\"              //  We have got palindrome by now\\n                    l       r         \\n                            k\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tDo \"Upvote\" if it helps :) \\n\\t\\t\\n\\t\\t\\n### JAVA code:\\n\\tclass Solution {\\n\\n\\t\\tpublic int minMovesToMakePalindrome(String s) {\\n\\t\\t\\tint len = s.length();\\n\\t\\t\\tchar[] strArr = s.toCharArray();        \\n\\t\\t\\tint steps = 0;\\n\\t\\t\\tint l = 0, r = len-1;                                           // use two pointers l for left and r for right. \\n\\n\\t\\t\\twhile(l < r){            \\n\\t\\t\\t\\tif(strArr[l] == strArr[r]){                                 // Both characters are equal. so keep going futher.\\n\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t}else{                                                      // Both characters are not equal.    \\n\\t\\t\\t\\t\\tint k = r;\\n\\t\\t\\t\\t\\tk = findKthIndexMatchingwithLthIndex(strArr, l, k);     // loop through k, until char at index k = char at index l              \\n\\n\\t\\t\\t\\t\\tif(k == l){                                             // we did not find any char at k = char at index l    \\n\\t\\t\\t\\t\\t\\tswap(strArr, l);\\n\\t\\t\\t\\t\\t\\tsteps++;   \\n\\t\\t\\t\\t\\t}else{                                                  \\n\\t\\t\\t\\t\\t\\twhile(k < r){                                           \\n\\t\\t\\t\\t\\t\\t\\tswap(strArr, k);\\n\\t\\t\\t\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t\\t}                \\n\\t\\t\\t\\t}// end of else\\n\\n\\t\\t\\t}   // end of while\\n\\t\\t\\tSystem.out.println(\"palindrome: \"+String.valueOf(strArr));\\n\\t\\t\\treturn steps;\\n\\n\\t\\t}\\n\\n\\t\\tpublic int findKthIndexMatchingwithLthIndex(char[] strArr, int l, int k){\\n\\t\\t\\twhile(k > l){\\n\\t\\t\\t\\tif(strArr[k] == strArr[l]){  return k;  }                    \\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\n\\t\\tpublic void swap(char[] strArr, int l){\\n\\t\\t\\tif(l+1 < strArr.length){\\n\\t\\t\\t\\tchar tempCh = strArr[l];\\n\\t\\t\\t\\tstrArr[l] = strArr[l+1];\\n\\t\\t\\t\\tstrArr[l+1] = tempCh;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n//\\n//\\n//\\n//\\n\\t\\n### \\tC++ Code:\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minMovesToMakePalindrome(string s) {\\n\\t\\t\\tint len = s.length();\\n\\t\\t\\tstring strArr = s;        \\n\\t\\t\\tint steps = 0;\\n\\t\\t\\tint l = 0, r = len-1;                                           // use two pointers l for left and r for right. \\n\\n\\t\\t\\twhile(l < r){            \\n\\t\\t\\t\\tif(strArr[l] == strArr[r]){                                 // Both characters are equal. so keep going futher.\\n\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t}else{                                                      // Both characters are not equal.    \\n\\t\\t\\t\\t\\tint k = r;\\n\\t\\t\\t\\t\\tk = findKthIndexMatchingwithLthIndex(strArr, l, k);     // loop through k, until char at index k = char at index l              \\n\\n\\t\\t\\t\\t\\tif(k == l){                                             // we did not find any char at k = char at index l    \\n\\t\\t\\t\\t\\t\\tswap(strArr[l], strArr[l+1]);\\n\\t\\t\\t\\t\\t\\tsteps++;   \\n\\t\\t\\t\\t\\t}else{                                                  \\n\\t\\t\\t\\t\\t\\twhile(k < r){                                           \\n\\t\\t\\t\\t\\t\\t\\tswap(strArr[k], strArr[k+1]);\\n\\t\\t\\t\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t\\t}                \\n\\t\\t\\t\\t}   // end of else\\n\\n\\t\\t\\t}   // end of while\\n\\t\\t\\treturn steps;\\n\\t\\t}\\n\\n\\t\\tint findKthIndexMatchingwithLthIndex(string strArr, int l, int k){\\n\\t\\t\\twhile(k > l){\\n\\t\\t\\t\\tif(strArr[k] == strArr[l]){  return k;  }                    \\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\t};\\n\\nDo \"**Upvote**\" if it helps :)  \\nAny suggestions, question, or more optimized solution is welcomed.",
                "solutionTags": [
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic int minMovesToMakePalindrome(String s) {\\n\\t\\t\\tint len = s.length();\\n\\t\\t\\tchar[] strArr = s.toCharArray();        \\n\\t\\t\\tint steps = 0;\\n\\t\\t\\tint l = 0, r = len-1;                                           // use two pointers l for left and r for right. \\n\\n\\t\\t\\twhile(l < r){            \\n\\t\\t\\t\\tif(strArr[l] == strArr[r]){                                 // Both characters are equal. so keep going futher.\\n\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1821967,
                "title": "python-2-solutions-o-n-2-and-o-n-log-n-explained",
                "content": "#### Solution 1\\nThe idea is to greedy construct palindrome, symbol by symbol, using two pointers technique. Imagine that we have `abc...cdeba`. Then for the first two symbols they are already on place. For symbol `c`, we start form the `-3` symbol and look for symbol `c`. When we found it, we do swaps. So, we have `abc...dceba -> abc...decba`. Then we proceed in similar way. \\n\\n#### Complexity\\nIt is `O(n^2)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        l, r, s = 0, len(s) - 1, list(s)\\n        ans = 0\\n        while l < r:\\n            if s[l] != s[r]:\\n                k = r\\n                while k > l and s[k] != s[l]:\\n                    k -= 1\\n                if k == l:\\n                    ans += 1\\n                    s[l], s[l + 1] = s[l + 1], s[l]\\n                else:\\n                    while k < r:\\n                        s[k], s[k + 1] = s[k + 1], s[k]\\n                        k += 1\\n                        ans += 1\\n                    l, r = l + 1, r - 1\\n            else:\\n                l, r = l + 1, r - 1\\n        return ans\\n```\\n\\n#### Solution 2 (advanced)\\nThere is also `O(n log n)` solution, using BIT, similar idea to CF1616E. The idea is to create `P` first: are pairs of indexes for each letter. Imagine, that we have `a` on positions `0, 4, 9, 11`, then we create pairs `[0, 11], [4, 9]`. Then we sort these pairs, because we want to proceed them from left to right.\\n\\nThis solution is inspired by user **TheScrasse** from CodeForces, here is his more detailed explanation:\\n\\nSince it\\'s useless to swap equal characters, you know which pairs of characters will stay on symmetrical positions in the final string, i.e. the i-th leftmost occurrence and the i-th rightmost occurrence of any character `c`. In the string `acabcaaababbc`, for example, you can make these \"symmetrical pairs\": positions `(1, 10), (2, 13), (3, 8), (4, 12), (6, 7), (9, 11)`. The character in position `5` should go in the center of the final string (i.e. position `7`). The symmetrical pairs have to be nested inside each other, in some order. Given two symmetrical pairs, which of them should be located outside the other one? It turns out that the pair that contains the leftmost element should be located outside. In fact, if you want to reach `xyyx`, the initial configurations with `x` on the left (`xxyy, xyxy, xyyx`) require `2, 1, 0` moves respectively, while reaching `yxxy` requires `2, 1, 2` moves respectively. So you can sort the symmetrical pairs by leftmost element and construct the array a such that `ai` is the final position of `si` in the palindromic string (in this case, `[1, 2, 3, 4, 7, 5, 9, 11, 6, 13, 8, 10, 12]`) and the result is the number of inversions of `a`.\\n\\n#### Complexity\\nIt is `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n    \\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n        s = [ord(x) - 95 for x in s]\\n        ans, bit = 0, BIT(n)\\n        if sum(x % 2 == 1 for x in Counter(s).values()) > 1: return -1\\n\\n        idx = defaultdict(list)\\n        for i, c in enumerate(s):\\n            idx[c].append(i)\\n\\n        B, P = [0] * n, []\\n        for c, I in idx.items():\\n            cnt = len(I)\\n            if cnt % 2:\\n                B[I[cnt//2]] = n//2 + 1\\n            for i in range((cnt)//2):\\n                P += [(I[i], I[~i])]\\n\\n        for i, (l, r) in enumerate(sorted(P)):\\n            B[l], B[r] = i + 1, n - i\\n        \\n        for i, b in enumerate(B):\\n            ans += i - bit.query(b)\\n            bit.update(b, 1)\\n        \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please Upvote!",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        l, r, s = 0, len(s) - 1, list(s)\\n        ans = 0\\n        while l < r:\\n            if s[l] != s[r]:\\n                k = r\\n                while k > l and s[k] != s[l]:\\n                    k -= 1\\n                if k == l:\\n                    ans += 1\\n                    s[l], s[l + 1] = s[l + 1], s[l]\\n                else:\\n                    while k < r:\\n                        s[k], s[k + 1] = s[k + 1], s[k]\\n                        k += 1\\n                        ans += 1\\n                    l, r = l + 1, r - 1\\n            else:\\n                l, r = l + 1, r - 1\\n        return ans\\n```\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n    \\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n        s = [ord(x) - 95 for x in s]\\n        ans, bit = 0, BIT(n)\\n        if sum(x % 2 == 1 for x in Counter(s).values()) > 1: return -1\\n\\n        idx = defaultdict(list)\\n        for i, c in enumerate(s):\\n            idx[c].append(i)\\n\\n        B, P = [0] * n, []\\n        for c, I in idx.items():\\n            cnt = len(I)\\n            if cnt % 2:\\n                B[I[cnt//2]] = n//2 + 1\\n            for i in range((cnt)//2):\\n                P += [(I[i], I[~i])]\\n\\n        for i, (l, r) in enumerate(sorted(P)):\\n            B[l], B[r] = i + 1, n - i\\n        \\n        for i, b in enumerate(B):\\n            ans += i - bit.query(b)\\n            bit.update(b, 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821936,
                "title": "list-vs-bit",
                "content": "This question sounds intimidating. Even with 2,000 characters, full search is not practical. Thus, we need to figure out some greedy approach.\\n    \\n**Intuition 1:** It is always cheaper to keep either the left or right character in place, as opposed to moving some other character to the left and right.\\n \\n **Intuition 2:** It actually does not matter whether we keep the left or right character. Consider this example: \\'accabb\\'.\\n - Keep left:  \\'acc*a*bb\\' -> \\'ac*c*bb**a**\\' (2 moves) ->\\'acbb**c**a\\' (2 moves).\\n - Keep right: \\'acca*b*b\\' -> \\'**b**accab\\' (4 moves).\\n \\nA simple quadratic solution is accepted (approach 1), and we can improve it to O(n log n) by collecting indexes for each character, and adjusting them using a mutable prefix sum (approach 2).\\n\\n#### Approach 1: List\\nWe will keep the rigth character and move the first matching character from the left.\\n    \\nNote that it is important to use an efficient data structure here - such as a linked list, so we can modify the string in O(1).\\n\\n**C++**\\n```cpp\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0;\\n    list<char> l(begin(s), end(s));\\n    while(l.size() > 1) {\\n        auto it = begin(l);\\n        int step = 0;\\n        for (; *it != l.back(); ++it)\\n            ++step;\\n        res += step == l.size() - 1 ? step / 2 : step;\\n        if (it != prev(end(l)))\\n            l.erase(it);\\n        l.pop_back();\\n    }\\n    return res;\\n}\\n```\\n#### Approach 2: BIT\\nWe store indexes for each character in a deque `pos`. Then, for each character on the right, we can find the index of the matching character on the left.\\n\\nBut wait, we need to adjust the index - by the count of characters we have used before that index. For that, we use BIT to give us a prefix sum in O(log n).\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 2000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0, sz = s.size();\\n    deque<int> pos[26] = {};\\n    for (int i = 0; i < sz; ++i)\\n        pos[(s[i] - \\'a\\')].push_back(i);\\n    for (int i = sz - 1; i >= 0; --i) {\\n        int idx = s[i] - \\'a\\';\\n        if (!pos[idx].empty()) {\\n            int p = pos[idx].front() - prefix_sum(pos[idx].front());\\n            add(pos[idx].front(), 1);\\n            if (pos[idx].size() > 1)\\n                pos[idx].pop_front();\\n            else\\n                p /= 2;\\n            res += p;\\n            pos[idx].pop_back();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0;\\n    list<char> l(begin(s), end(s));\\n    while(l.size() > 1) {\\n        auto it = begin(l);\\n        int step = 0;\\n        for (; *it != l.back(); ++it)\\n            ++step;\\n        res += step == l.size() - 1 ? step / 2 : step;\\n        if (it != prev(end(l)))\\n            l.erase(it);\\n        l.pop_back();\\n    }\\n    return res;\\n}\\n```\n```cpp\\nconstexpr int static n = 2000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0, sz = s.size();\\n    deque<int> pos[26] = {};\\n    for (int i = 0; i < sz; ++i)\\n        pos[(s[i] - \\'a\\')].push_back(i);\\n    for (int i = sz - 1; i >= 0; --i) {\\n        int idx = s[i] - \\'a\\';\\n        if (!pos[idx].empty()) {\\n            int p = pos[idx].front() - prefix_sum(pos[idx].front());\\n            add(pos[idx].front(), 1);\\n            if (pos[idx].size() > 1)\\n                pos[idx].pop_front();\\n            else\\n                p /= 2;\\n            res += p;\\n            pos[idx].pop_back();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821950,
                "title": "java-solution-using-greedy",
                "content": "If a character is at boundry, there is not point in moving it towards center.\\nAt any given moment, there can be 2 option for making the boundry palindrome.\\nChoose the one with minimum value greedily and keep updating the string.\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count = 0;\\n        \\n        while(s.length() > 2) {\\n            char ch1 = s.charAt(0);\\n            int len = s.length();\\n            char ch2 = s.charAt(len - 1);\\n            \\n            if (ch1 == ch2) {\\n                s = s.substring(1, len - 1);\\n            } else {\\n                int id1 = s.lastIndexOf(ch1);\\n                int id2 = s.indexOf(ch2);\\n                \\n                int steps1 = len - id1 - 1;\\n                int steps2 = id2;\\n                \\n                StringBuilder sb = new StringBuilder();\\n                \\n                if (steps1 > steps2) {\\n                    count += steps2;\\n                    sb.append(s.substring(0, id2));\\n                    sb.append(s.substring(id2 + 1, len - 1));\\n                } else {\\n                    count += steps1;\\n                    sb.append(s.substring(1, id1));\\n                    sb.append(s.substring(id1 + 1));\\n                }\\n                \\n                s = sb.toString();\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count = 0;\\n        \\n        while(s.length() > 2) {\\n            char ch1 = s.charAt(0);\\n            int len = s.length();\\n            char ch2 = s.charAt(len - 1);\\n            \\n            if (ch1 == ch2) {\\n                s = s.substring(1, len - 1);\\n            } else {\\n                int id1 = s.lastIndexOf(ch1);\\n                int id2 = s.indexOf(ch2);\\n                \\n                int steps1 = len - id1 - 1;\\n                int steps2 = id2;\\n                \\n                StringBuilder sb = new StringBuilder();\\n                \\n                if (steps1 > steps2) {\\n                    count += steps2;\\n                    sb.append(s.substring(0, id2));\\n                    sb.append(s.substring(id2 + 1, len - 1));\\n                } else {\\n                    count += steps1;\\n                    sb.append(s.substring(1, id1));\\n                    sb.append(s.substring(id1 + 1));\\n                }\\n                \\n                s = sb.toString();\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821984,
                "title": "python3-2-pointers-solution-explained",
                "content": "```\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \"\"\"\\n        2 pointers, left and right, such that right = n - left - 1\\n        i.e., they are equidistant from both ends\\n        \\n        in a palindromic arrangement of s, s[left] == s[right]\\n\\n        if s[left] and s[right] are not equal:\\n        1. from j = right, check whether there is an element equal to s[left]. \\n           decrement j until an equal element is not found\\n        2. similarly, i = left, check whether there is an element equal to s[right].\\n           increment i until an equal element is not found\\n        3. now we need to decide to either move element at left to element at i, or\\n           element at right to element at j\\n        4. calculate the cost for both possibilities, (i - left and right - j)\\n        5. choose the minimum and move those elements by adjacent swaps\\n        \\n        \\n        \"\"\"\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        \\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                \\n                while s[left] != s[j]:\\n                    j -= 1\\n                    \\n                    \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x] = s[x+1]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x] = s[x-1]\\n                        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \"\"\"\\n        2 pointers, left and right, such that right = n - left - 1\\n        i.e., they are equidistant from both ends\\n        \\n        in a palindromic arrangement of s, s[left] == s[right]\\n\\n        if s[left] and s[right] are not equal:\\n        1. from j = right, check whether there is an element equal to s[left]. \\n           decrement j until an equal element is not found\\n        2. similarly, i = left, check whether there is an element equal to s[right].\\n           increment i until an equal element is not found\\n        3. now we need to decide to either move element at left to element at i, or\\n           element at right to element at j\\n        4. calculate the cost for both possibilities, (i - left and right - j)\\n        5. choose the minimum and move those elements by adjacent swaps\\n        \\n        \\n        \"\"\"\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        \\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                \\n                while s[left] != s[j]:\\n                    j -= 1\\n                    \\n                    \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x] = s[x+1]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x] = s[x-1]\\n                        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822211,
                "title": "two-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n    int left = 0, right = s.size() - 1, ans = 0;\\n    while (left < right) {\\n        int l = left, r = right;\\n        while (s[l] != s[r]) r--;   \\n        if (l == r) {\\n            // here we hit the odd element\\n            swap(s[r], s[r + 1]);\\n            ans++;\\n            continue;\\n        } else {\\n            // normal element\\n            while (r < right) swap(s[r], s[r + 1]), ans++, r++;\\n        }\\n        left++, right--;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n    int left = 0, right = s.size() - 1, ans = 0;\\n    while (left < right) {\\n        int l = left, r = right;\\n        while (s[l] != s[r]) r--;   \\n        if (l == r) {\\n            // here we hit the odd element\\n            swap(s[r], s[r + 1]);\\n            ans++;\\n            continue;\\n        } else {\\n            // normal element\\n            while (r < right) swap(s[r], s[r + 1]), ans++, r++;\\n        }\\n        left++, right--;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822360,
                "title": "c-two-pointer-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822915,
                "title": "python-with-proof-for-why-move-a-from-the-form-of-a-a-to-a-a-works",
                "content": "# Proof\\nProvide with a not very solid but acceptable proof:\\n\\n(1) let\\'s convert the string to an array to \\nexample: `\"abcab\"` -> `[\"a\", \"b\", \"c\", \"a\", \"b\"]`\\n\\n(2) let\\'s only consider to move `first element` to be Palindrome. In our example\\n\\nit will be to move from the form of\\n`[\"a\", ..., \"a\", ...]`\\nlet\\'s assume between first `\"a\"` and last `\"a\"` there are number of x elements and behind last `\"a\"` we have number of y elements\\n`\"a\", ..., \"a\", ...` = `\"a\", arr_with_length_x, \"a\", array_with_length_y`\\n`\"a\", arr_with_length_x, \"a\", array_with_length_y` -> `\"a\", arr_with_length_x, array_with_length_y, \"a\"`\\n\\nAs first `\"a\"` is at start of string so to move last `\"a\"` to the end of string, it takes y moves.\\n\\nLet\\'s consider to make another kinds of `Palindrome`, i.e. we move first `\"a\"` to index d (in the form of `[..., \"a\", ..., \"a\", ...]`)\\n`\"a\", arr_with_length_x, \"a\", array_with_length_y` -> `arr_with_length_d, \"a\", arr_with_length_x_minus_d, arr_with_length_y_minus_d, \"a\", arr_with_length_d`\\nthen for first `\"a\"`, it takes `d` moves and relatively it takes `y-d` moves for last `\"a\"`, thus it is `d`+`y-d` = `y` moves in total\\n\\ni.e. no difference on moves count if just want to make `\"a\"` Palindrome\\n\\n(3) let\\'s compare two kinds forms, which is better? \\n**3.1.** `\"a\", arr_with_length_d, arr_with_length_x_minus_d, arr_with_length_y_minus_d, arr_with_length_d, \"a\"`\\n**3.2.**  `arr_with_length_d, \"a\", arr_with_length_x_minus_d, arr_with_length_y_minus_d, \"a\", arr_with_length_d`\\nIt is obvious 3.1. is better (min moves) coz, from (2) we already proof to move `\"a\"`, 3.1. and 3.2. both takes `y` moves\\nAnd on form of **3.2.**, if to move element in `arr_with_length_d` out of itself , it will defintely pass by `\"a\"` and thus always requires one more extra moves than the **3.1.**\\n\\n## Examples for (3)\\nLet\\'s start with `axxayy`\\n\\n### using 3.1. \\n`axxayy` -> `axxyya` (2 moves)\\nthen this equilvalent to move `xxyy`  to Palindrome\\n\\n`xxyy` -> `xyyx` (2 moves)\\n\\n### using 3.2.\\n`axxayy` -> `xxaayy` (same as 3.1. it is 2 moves as proof in (2))\\nMoving `xxaayy` -> `xyaayx` it takes:\\n`xxaayy` -> `xaayyx` (4moves) when moving x to last, x swap with `a` two times\\n`xaayyx` -> `xyaayx` (2moves) when moving y to index 1,y swaps with `a` two times\\n\\ntotally 6 moves = original 2 moves (same as in `3.1.`) + 4 moves (swaps with by `a` 4 times)\\n# Solution\\nProvide with a recursive solution using above greedy solution\\n\\n```\\nclass Solution(object):\\n    def minMovesToMakePalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count, length_of_s = 0, len(s)\\n        if length_of_s <= 2:\\n            return count\\n        for i in reversed(range(length_of_s)):\\n            if s[i] != s[0]:\\n                continue\\n            if i == 0:\\n\\t\\t\\t\\t# move to middle is a speical case which takes len(s)/2 moves then do recursive for remaining part\\n                count += len(s)/2 + self.minMovesToMakePalindrome(s[1:])  \\n            else:\\n\\t\\t\\t    # this move takes len(s)-1 - i (move from i to last index len(s)-1)and then do recursive for remaining part\\n                count += len(s)-1-i + self.minMovesToMakePalindrome(s[1:i]+s[i+1:])\\n            break\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def minMovesToMakePalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count, length_of_s = 0, len(s)\\n        if length_of_s <= 2:\\n            return count\\n        for i in reversed(range(length_of_s)):\\n            if s[i] != s[0]:\\n                continue\\n            if i == 0:\\n\\t\\t\\t\\t# move to middle is a speical case which takes len(s)/2 moves then do recursive for remaining part\\n                count += len(s)/2 + self.minMovesToMakePalindrome(s[1:])  \\n            else:\\n\\t\\t\\t    # this move takes len(s)-1 - i (move from i to last index len(s)-1)and then do recursive for remaining part\\n                count += len(s)-1-i + self.minMovesToMakePalindrome(s[1:i]+s[i+1:])\\n            break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831890,
                "title": "c-greedy-solution-with-explanation",
                "content": "## Approach:\\nWhen do you say that the string is Palindrome?\\nWhen it reads same forward and backward right.\\nThis is what we will try to do in this approach.\\n\\nWe will go with same approach.\\n- We will go with first half of the elements and see if their corresponding character from last is equal, If it is equal then we move on to next character.\\n- If it is not we will find the pos of the nearest character from right which is same as given character.\\n\\t- Now there are two subcases:\\n\\t- If that position is equal to the idx itself, This means we are at odd index, Reason is since we are given a palindrome is always possible, So if this would not have been the case we would have found the position in right. In this case we will just swap it with the next element and increase the counter. For the sake of understanding, Take example of **\"abb\"** we will make it **\"bab\"** with 1 swap.\\n\\t- If it is not then we have to swap each consecutive element from the position we found from the right, To make characters equal at that particular position.\\n\\n## Code:\\n```\\n int minMovesToMakePalindrome(string s) {\\n        int l,r,n,cnt=0;\\n        n=s.length();\\n        l=0;\\n        r=n-1;\\n        \\n        while(l<r){\\n            if(s[l] == s[r]){\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            int idx=r;\\n            while(idx>l && s[idx] != s[l])\\n                idx--;\\n            \\n            if(idx == l){\\n                // This means odd case, Just swap it with itself and do not need to go further\\n                swap(s[idx], s[idx+1]);\\n                cnt++;\\n                continue;\\n            }\\n            \\n            while(idx<r){\\n                swap(s[idx],s[idx+1]);\\n                cnt++;\\n                idx++;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return cnt;\\n    }\\n```\\n\\n**Hope you like it!!\\nPlease do upvote it if you like it and let me know if there are any mistakes/questions in the comments below \\uD83D\\uDC47\\uD83D\\uDC47 .**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        int l,r,n,cnt=0;\\n        n=s.length();\\n        l=0;\\n        r=n-1;\\n        \\n        while(l<r){\\n            if(s[l] == s[r]){\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            int idx=r;\\n            while(idx>l && s[idx] != s[l])\\n                idx--;\\n            \\n            if(idx == l){\\n                // This means odd case, Just swap it with itself and do not need to go further\\n                swap(s[idx], s[idx+1]);\\n                cnt++;\\n                continue;\\n            }\\n            \\n            while(idx<r){\\n                swap(s[idx],s[idx+1]);\\n                cnt++;\\n                idx++;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2835985,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822089,
                "title": "python-simple-solution-with-graphic-explanation",
                "content": "* start from the first letter. we can tell that its corresponding position is the last index `n - 1`. Search for the right most same letter and swap it to the target position\\n![image](https://assets.leetcode.com/users/images/cbe86863-015a-4862-889e-3b299320e4ab_1646496857.8893888.png)\\n\\n* if we cannot find a same letter, this letter should be placed at center. We can skip it for now.\\n![image](https://assets.leetcode.com/users/images/52746b4e-a196-423d-8d3c-680217980215_1646496883.8686996.png)\\n\\n* keep iterating\\n![image](https://assets.leetcode.com/users/images/6e23cb1f-ef52-4fe6-9d48-f305fc279b43_1646496905.636108.png)\\n\\n* finally, we swap the unique letter to center\\n![image](https://assets.leetcode.com/users/images/6940bb70-abeb-4451-bc9f-b74ecda4bcae_1646496922.0397792.png)\\n\\ncode:\\n```\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n    ans = 0\\n    n = len(s)\\n    target = n - 1 # 0\\'s corresponding index\\n    for i in range(math.ceil(n / 2)):\\n        for j in range(target, i - 1, -1):\\n            # search backward\\n            if j == i:\\n                # occurrance is 1, needs to be placed at center\\n                ans += n // 2 - i\\n            elif s[i] == s[j]:\\n                s = s[:j] + s[j + 1 : target + 1] + s[j] + s[target + 1:]\\n                ans += target - j\\n                target -= 1\\n                break\\n    return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n    ans = 0\\n    n = len(s)\\n    target = n - 1 # 0\\'s corresponding index\\n    for i in range(math.ceil(n / 2)):\\n        for j in range(target, i - 1, -1):\\n            # search backward\\n            if j == i:\\n                # occurrance is 1, needs to be placed at center\\n                ans += n // 2 - i\\n            elif s[i] == s[j]:\\n                s = s[:j] + s[j + 1 : target + 1] + s[j] + s[target + 1:]\\n                ans += target - j\\n                target -= 1\\n                break\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2466919,
                "title": "clean-java-code-with-explanation",
                "content": "* **Check if the character in start and end index are same if yes then decrease the end by 1 and increase the start by 1**\\n*  **Otherwise search for the character similar to the starting index by decrementing the end** \\n*  **If it is seen that on decrementing the end it points to same index as start then swap the character with the  character in the next index and increment the ans count**\\n\\n*   **Otherwise check the last index pointer is less than the ending indx if yes then increase it as well as increase the ans and keep on swapping the last index  pointer with its next position.**\\n\\n***Please Upvote if you like my approach***\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int ans = 0;\\n        \\n        int start = 0 , end = s.length() - 1;\\n        \\n        char ch[] = s.toCharArray();\\n        \\n        while(start < end)\\n        {\\n           \\n            int r = end;\\n            \\n            if(ch[start] == ch[end])\\n            {\\n                start++;\\n                end--;\\n                continue;\\n            }\\n            \\n            while(ch[start] != ch[r])\\n            {\\n                r--; \\n            }// aabb l is pointing at 0 th index while r is pointing to b which is not equal to a so r-- by doing this we are searching whether any a is present there other than the one which l is pointing\\n            \\n            if(start == r) // means no a is present other than first index\\n            {\\n                //swap them\\n               \\n                swap(ch,r,r+1);\\n                ans++;\\n               \\n            }\\n            else \\n            {\\n                while(r<end)\\n                {\\n                    swap(ch,r,r+1);\\n                    ans++;\\n                    r++;\\n                }\\n               \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n    \\n    private void swap(char ch[] , int i , int j)\\n    {\\n        \\n                char c = ch[i];\\n                ch[i] = ch[j];\\n                ch[j] = c;\\n      \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int ans = 0;\\n        \\n        int start = 0 , end = s.length() - 1;\\n        \\n        char ch[] = s.toCharArray();\\n        \\n        while(start < end)\\n        {\\n           \\n            int r = end;\\n            \\n            if(ch[start] == ch[end])\\n            {\\n                start++;\\n                end--;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2266606,
                "title": "c-two-pointer-easy-understanding",
                "content": "class Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int p=0;\\n        int q=n-1;\\n        int ans=0;\\n        int y=-1;\\n        while(p<=q)\\n        {\\n            if(s[p]!=s[q])\\n            {\\n                int temp=q-1;\\n                while(s[temp]!=s[p])\\n                    temp--;\\n                if(temp!=p)\\n                {\\n                    for(int i=temp;i<q;i++)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        ans++;\\n                    }\\n                }\\n                else\\n                {\\n                    y=p;\\n                    q++;\\n                }\\n            }\\n            p++;\\n            q--;\\n        }\\n        if(y!=-1)                          //  If the frequency of a particular letter is odd\\n        {                                    // Only at most one letter can have odd frequency\\n            ans+=abs(s.size()/2-y);     // This is the required swaps to bring that letter to the middle\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int p=0;\\n        int q=n-1;\\n        int ans=0;\\n        int y=-1;\\n        while(p<=q)\\n        {\\n            if(s[p]!=s[q])\\n            {\\n                int temp=q-1;\\n                while(s[temp]!=s[p])\\n                    temp--;\\n                if(temp!=p)\\n                {\\n                    for(int i=temp;i<q;i++)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        ans++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1880549,
                "title": "java-easy-explanation-two-pointer",
                "content": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char []arr=s.toCharArray();\\n        int start=0;\\n        int n=s.length();\\n        int end=s.length()-1;\\n        int res=0;\\n        while(start<end)\\n        {\\n            int k=end;\\n            // if we found pal char \\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n                end--;\\n                continue;   \\n            }\\n            // char is not pal we will search particular char\\n            // towards starting point\\n            // because it is the right way to make min moves\\n            // then we will swap\\n            // and return the answer\\n            while(arr[start]!=arr[k])\\n            {\\n                k--;\\n                \\n            }\\n            if(k==start)\\n            {\\n                res++;\\n                swap(arr,start,start+1);\\n            }\\n            else\\n            {\\n                while(k<end)\\n                {\\n                    res++;\\n                    swap(arr,k,k+1);\\n                    k++;\\n                }\\n            }\\n        }\\n            \\n            return res;\\n    }\\n        \\n        \\n public static void swap(char arr[],int i,int j)\\n {\\n    char temp=arr[i];\\n    arr[i]=arr[j];\\n    arr[j]=temp;\\n }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char []arr=s.toCharArray();\\n        int start=0;\\n        int n=s.length();\\n        int end=s.length()-1;\\n        int res=0;\\n        while(start<end)\\n        {\\n            int k=end;\\n            // if we found pal char \\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n                end--;\\n                continue;   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2138121,
                "title": "without-considering-any-odd-element-case-using-two-pointer-method",
                "content": "**Hello guys,**\\nthis is a simple solution for  `Minimum Number of Moves to Make Palindrome` problem\\n\\nLet `l=0, r=n-1`\\n\\n`if(s[l]==s[r]) l++,r--;`\\n\\n`else`\\n`{`\\nsearch s[l] from right side of the string \\nand seach s[r] from left side of the string\\n\\nlet we get `s[l]` at `idx2` from right then there will be` r-idx2` swaps required\\nand for we get `s[r]` at `idx1` from left then there will be `idx1-l` swaps required\\n\\nwe will take swap action from min distance and pull that particular character to `l` or `r`\\n`}`\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.size();\\n        int l=0,r=n-1;\\n        \\n        int cnt=0;\\n        while(l<r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++,r--;\\n            }\\n            else\\n            {\\n                int idx1=l,idx2=r;\\n                \\n                // left search\\n                char c=s[r];\\n                for(int i=l+1;i<n;++i)\\n                {\\n                    if(s[i]==c)\\n                    {\\n                        idx1=i; break;\\n                    }\\n                }\\n                \\n                // right search\\n                c=s[l];\\n                for(int i=r-1;i>=0;i--)\\n                {\\n                    if(s[i]==c) {\\n                        idx2=i; break;\\n                    }\\n                }\\n                \\n                // swap \\n                if(idx1-l<=r-idx2)\\n                {\\n                    while(idx1>l)\\n                    {\\n                        swap(s[idx1],s[idx1-1]);\\n                        idx1--;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                else\\n                {\\n                    while(idx2<r)\\n                    {\\n                        swap(s[idx2], s[idx2+1]);\\n                        idx2++;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                \\n                l++,r--;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\nThanks...",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.size();\\n        int l=0,r=n-1;\\n        \\n        int cnt=0;\\n        while(l<r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++,r--;\\n            }\\n            else\\n            {\\n                int idx1=l,idx2=r;\\n                \\n                // left search\\n                char c=s[r];\\n                for(int i=l+1;i<n;++i)\\n                {\\n                    if(s[i]==c)\\n                    {\\n                        idx1=i; break;\\n                    }\\n                }\\n                \\n                // right search\\n                c=s[l];\\n                for(int i=r-1;i>=0;i--)\\n                {\\n                    if(s[i]==c) {\\n                        idx2=i; break;\\n                    }\\n                }\\n                \\n                // swap \\n                if(idx1-l<=r-idx2)\\n                {\\n                    while(idx1>l)\\n                    {\\n                        swap(s[idx1],s[idx1-1]);\\n                        idx1--;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                else\\n                {\\n                    while(idx2<r)\\n                    {\\n                        swap(s[idx2], s[idx2+1]);\\n                        idx2++;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                \\n                l++,r--;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841912,
                "title": "c-superfast-92-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,char target,int last,int index)\\n    {\\n        int pos=-1;\\n        for(int i=last;i>=0;i--)\\n        {\\n            if(s[i]==target)\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        int c=0;\\n\\t\\t//if my string is \"abb\" and hence i got same pos of a from last and from end then return c i.e 0\\n        if(pos==index)return c;\\n        while(pos!=last)\\n        {\\n            swap(s[pos],s[pos+1]);\\n            pos++;\\n            c++;\\n        }\\n        return c;\\n    }\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int ans=0;\\n        int n=s.size();\\n        int res=0;\\n\\t\\t//for even\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(s[i]!=s[n-1-i])\\n            {\\n                int ch=solve(s,s[i],n-1-i,i);\\n                if(ch==0)\\n                {\\n                    ans=INT_MAX;\\n                    break;\\n                }\\n                res+=ch;\\n            }\\n        }\\n\\t\\t//for odd and my single element is in left\\n        if(n&1 && ans==INT_MAX)\\n        {\\n            ans=0;\\n            reverse(s.begin(),s.end());\\n            for(int i=0;i<n/2;i++)\\n            {\\n                if(s[i]!=s[n-1-i])\\n                {\\n                    int ch=solve(s,s[i],n-1-i,-1);\\n                    ans+=ch;\\n                }\\n            }\\n            return ans+res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,char target,int last,int index)\\n    {\\n        int pos=-1;\\n        for(int i=last;i>=0;i--)\\n        {\\n            if(s[i]==target)\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        int c=0;\\n\\t\\t//if my string is \"abb\" and hence i got same pos of a from last and from end then return c i.e 0\\n        if(pos==index)return c;\\n        while(pos!=last)\\n        {\\n            swap(s[pos],s[pos+1]);\\n            pos++;\\n            c++;\\n        }\\n        return c;\\n    }\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int ans=0;\\n        int n=s.size();\\n        int res=0;\\n\\t\\t//for even\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(s[i]!=s[n-1-i])\\n            {\\n                int ch=solve(s,s[i],n-1-i,i);\\n                if(ch==0)\\n                {\\n                    ans=INT_MAX;\\n                    break;\\n                }\\n                res+=ch;\\n            }\\n        }\\n\\t\\t//for odd and my single element is in left\\n        if(n&1 && ans==INT_MAX)\\n        {\\n            ans=0;\\n            reverse(s.begin(),s.end());\\n            for(int i=0;i<n/2;i++)\\n            {\\n                if(s[i]!=s[n-1-i])\\n                {\\n                    int ch=solve(s,s[i],n-1-i,-1);\\n                    ans+=ch;\\n                }\\n            }\\n            return ans+res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830147,
                "title": "c-runtime-8-ms-faster-than-99-93-memory-6-6-mb-less-than-98-24",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        \\n        while(s.length() > 0){\\n            int n = s.length();\\n            char c = s[n-1];\\n            int ind = s.find(c);\\n            //cout<<s<<\" \"<<ind<<\" \"<<c<<endl;\\n            if(ind == n-1){\\n                ans += n/2;\\n                s.pop_back();\\n            } else {\\n                ans += ind;\\n                s.pop_back();\\n                s.erase(ind,1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        \\n        while(s.length() > 0){\\n            int n = s.length();\\n            char c = s[n-1];\\n            int ind = s.find(c);\\n            //cout<<s<<\" \"<<ind<<\" \"<<c<<endl;\\n            if(ind == n-1){\\n                ans += n/2;\\n                s.pop_back();\\n            } else {\\n                ans += ind;\\n                s.pop_back();\\n                s.erase(ind,1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1821980,
                "title": "c-easy-swap-solution",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        for(int i = 0, j = s.length() - 1; i < s.length() / 2; i++, j--) {\\n            if(s[i] == s[j]) continue;\\n            int f = j - 1;\\n            for(; f >= i; f--) { //find closest character\\n                if(s[i] == s[f]) break;\\n            }\\n            if(f == i) { //if closest character is at s[i], s[i] should move to middle of s\\n                res += s.length() / 2 - i;\\n                j++;\\n            } else { //else, calculate distance and swap all characters\\n                res += j - f;\\n                for(; f < j; f++) {\\n                    swap(s[f], s[f+1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        for(int i = 0, j = s.length() - 1; i < s.length() / 2; i++, j--) {\\n            if(s[i] == s[j]) continue;\\n            int f = j - 1;\\n            for(; f >= i; f--) { //find closest character\\n                if(s[i] == s[f]) break;\\n            }\\n            if(f == i) { //if closest character is at s[i], s[i] should move to middle of s\\n                res += s.length() / 2 - i;\\n                j++;\\n            } else { //else, calculate distance and swap all characters\\n                res += j - f;\\n                for(; f < j; f++) {\\n                    swap(s[f], s[f+1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621577,
                "title": "brute-force-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.length()-1,k,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;j--;\\n            }else{\\n                k = j;\\n                while(k>=i && s[k] != s[i]){\\n                    k--;\\n                }\\n                if(k==i){\\n                    ans++;\\n                    swap(s[i],s[i+1]);\\n                }else{\\n                    while(k<j){\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        ans++;\\n                    }\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.length()-1,k,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;j--;\\n            }else{\\n                k = j;\\n                while(k>=i && s[k] != s[i]){\\n                    k--;\\n                }\\n                if(k==i){\\n                    ans++;\\n                    swap(s[i],s[i+1]);\\n                }else{\\n                    while(k<j){\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        ans++;\\n                    }\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453981,
                "title": "java-solution-string-builder-greedy-two-pointer",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int n=s.length();\\n        StringBuilder sb=new StringBuilder(s);\\n        int ans=0;\\n        \\n        while(sb.length()>1)\\n        {\\n            char ch=sb.charAt(0);\\n            int pos=sb.lastIndexOf(ch+\"\");\\n            \\n            if(pos==0)\\n            ans+=n/2;\\n            \\n            else\\n            {\\n                ans+=n-pos-1;\\n                sb.deleteCharAt(pos);\\n                n--;\\n            }\\n            \\n            sb.deleteCharAt(0);\\n            n--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int n=s.length();\\n        StringBuilder sb=new StringBuilder(s);\\n        int ans=0;\\n        \\n        while(sb.length()>1)\\n        {\\n            char ch=sb.charAt(0);\\n            int pos=sb.lastIndexOf(ch+\"\");\\n            \\n            if(pos==0)\\n            ans+=n/2;\\n            \\n            else\\n            {\\n                ans+=n-pos-1;\\n                sb.deleteCharAt(pos);\\n                n--;\\n            }\\n            \\n            sb.deleteCharAt(0);\\n            n--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827875,
                "title": "java-greedy-two-pointers",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        int n=str.length();\\n        char[] s=str.toCharArray();\\n        int lptr=0;\\n        int rptr=n-1;\\n        \\n        int res=0;\\n        while(lptr<rptr){\\n            int r=rptr;\\n            \\n            if(s[lptr]==s[r]){\\n                lptr++;\\n                rptr--;\\n                continue;\\n            }\\n            \\n            while(s[lptr]!=s[r]) r--;\\n            \\n            if(lptr==r){\\n                swap(s,lptr,lptr+1);\\n                res++;\\n            }\\n            else{\\n                while(r!=rptr){\\n                    swap(s,r,r+1);\\n                    r++;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void swap(char[] s,int l,int r){\\n        char temp=s[l];\\n        s[l]=s[r];\\n        s[r]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        int n=str.length();\\n        char[] s=str.toCharArray();\\n        int lptr=0;\\n        int rptr=n-1;\\n        \\n        int res=0;\\n        while(lptr<rptr){\\n            int r=rptr;\\n            \\n            if(s[lptr]==s[r]){\\n                lptr++;\\n                rptr--;\\n                continue;\\n            }\\n            \\n            while(s[lptr]!=s[r]) r--;\\n            \\n            if(lptr==r){\\n                swap(s,lptr,lptr+1);\\n                res++;\\n            }\\n            else{\\n                while(r!=rptr){\\n                    swap(s,r,r+1);\\n                    r++;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void swap(char[] s,int l,int r){\\n        char temp=s[l];\\n        s[l]=s[r];\\n        s[r]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822337,
                "title": "explanation-logical-proof-why-greedy-works",
                "content": "This may not be a concrete proof but atleast having some idea is better than nothing. I could not find any good explanation out there, so please comment here if you have found a better resource :)\\n\\n\\nYou might have already read the approach - \\n1. initialise left and right pointers to 0 and size-1 respectively\\n2. find character to the left of right pointer which is equal to character at l and modify the string. If not found return -1 (handle odd length string case as well)\\n\\nWhy does this work? Why is it enough replace just 1 character (either to the left or right), could there be a better solution by replacing both characters ?\\n\\nThink about this - No matter what you do, in order to align 2 characters in the given string, it would taken a min of swaps depending on the following 2 values - pos(right), pos(left) .i.e. in the end you will end up making these many swaps for sure for these 2 characters.\\n\\nNow, you can notice that in our method we are exaclty doing this - making a minimum number of swaps. .i.e. moving one of the left or the right character by this minimum number of swaps.\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int count = 0;\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        int skip = 0;\\n        \\n        while(l<r){\\n            \\n            char leftChar = sb.charAt(l); \\n            char rightChar = sb.charAt(r);\\n            int temp = r; \\n            \\n            while(l < temp &&  leftChar != sb.charAt(temp)){\\n                temp--;\\n            }\\n            \\n            if(l == temp){\\n                if(s.length()%2 == 0){\\n                    return -1;\\n                } else {\\n                    if(skip == 1) return -1;\\n                    skip = 1;\\n                    count = count + s.length()/2 - l;\\n                    l = l + 1;\\n                }\\n                continue;\\n            }\\n            \\n            count = count + r - temp;\\n            \\n            sb.deleteCharAt(temp);\\n            sb.insert(r, leftChar);\\n            \\n            \\n            r--;\\n            l++;\\n            \\n        }\\n        \\n\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int count = 0;\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        int skip = 0;\\n        \\n        while(l<r){\\n            \\n            char leftChar = sb.charAt(l); \\n            char rightChar = sb.charAt(r);\\n            int temp = r; \\n            \\n            while(l < temp &&  leftChar != sb.charAt(temp)){\\n                temp--;\\n            }\\n            \\n            if(l == temp){\\n                if(s.length()%2 == 0){\\n                    return -1;\\n                } else {\\n                    if(skip == 1) return -1;\\n                    skip = 1;\\n                    count = count + s.length()/2 - l;\\n                    l = l + 1;\\n                }\\n                continue;\\n            }\\n            \\n            count = count + r - temp;\\n            \\n            sb.deleteCharAt(temp);\\n            sb.insert(r, leftChar);\\n            \\n            \\n            r--;\\n            l++;\\n            \\n        }\\n        \\n\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755656,
                "title": "intuition-made-easy-for-you-c-explanation",
                "content": "```\\nint solve(string s)\\n    {\\n         int n=s.size(),ans=0,i=0,j=n-1;\\n        \\n         while(i<j)\\n         {\\n            if(s[i]!=s[j])\\n            {\\n    //Step 1 ->We are fixing the first half and changing 2nd half according to it    \\n                \\n                int idx=j;\\n                while(s[idx]!=s[i])  //j se i ki trf aao aur dekho kaunsa idx s[i] ke equal\\n                    idx--;\\n      \\n    //Step 2 -> special case like \"ahbbaaa\" here h should come in middle so just swap with its next element and (NO i++,j-- here as process krna baaki hai use to ab \"abhbaaa\" is string me process kro NO i++ and j--)\\n                \\n                if(i==idx) \\n                {\\n                    swap(s[idx],s[idx+1]);\\n                    ans++;\\n                    continue;  //IMPORTANT --> No i++ and j-- for special case\\n                }\\n                \\n    //Step 3 -> Agar koi milgya hume s[i] ke equal to use hume jth place tk lana to idx<j jab tk hai tb tk swap marte rho aur ans++ krdo\\n                \\n                else\\n                {\\n                    while(idx<j)\\n                    {\\n                        swap(s[idx],s[idx+1]);\\n                        idx++; ans++;\\n                    }\\n                }\\n            }\\n             \\n            i++;\\n            j--;    //i aur j position match krwadi ab aage bdo         \\n         }\\n        return ans;\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve(s);\\n    }",
                "solutionTags": [],
                "code": "```\\nint solve(string s)\\n    {\\n         int n=s.size(),ans=0,i=0,j=n-1;\\n        \\n         while(i<j)\\n         {\\n            if(s[i]!=s[j])\\n            {\\n    //Step 1 ->We are fixing the first half and changing 2nd half according to it    \\n                \\n                int idx=j;\\n                while(s[idx]!=s[i])  //j se i ki trf aao aur dekho kaunsa idx s[i] ke equal\\n                    idx--;\\n      \\n    //Step 2 -> special case like \"ahbbaaa\" here h should come in middle so just swap with its next element and (NO i++,j-- here as process krna baaki hai use to ab \"abhbaaa\" is string me process kro NO i++ and j--)\\n                \\n                if(i==idx) \\n                {\\n                    swap(s[idx],s[idx+1]);\\n                    ans++;\\n                    continue;  //IMPORTANT --> No i++ and j-- for special case\\n                }\\n                \\n    //Step 3 -> Agar koi milgya hume s[i] ke equal to use hume jth place tk lana to idx<j jab tk hai tb tk swap marte rho aur ans++ krdo\\n                \\n                else\\n                {\\n                    while(idx<j)\\n                    {\\n                        swap(s[idx],s[idx+1]);\\n                        idx++; ans++;\\n                    }\\n                }\\n            }\\n             \\n            i++;\\n            j--;    //i aur j position match krwadi ab aage bdo         \\n         }\\n        return ans;\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve(s);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2567960,
                "title": "python-greedy-2-pointer",
                "content": "\\tclass Solution:\\n\\t\\tdef minMovesToMakePalindrome(self, s: str) -> int:\\n\\t\\t\\ts = list(s) #makes it easy for assignment op\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tleft, right = 0, len(s) - 1\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tl, r = left, right\\n\\n\\t\\t\\t\\t#find matching char\\n\\t\\t\\t\\twhile s[l] != s[r]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\t\\t# if index dont match then swap\\n\\t\\t\\t\\tif l != r:\\n\\t\\t\\t\\t\\t# swap one by one\\n\\t\\t\\t\\t\\twhile r < right:\\n\\t\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t\\tr += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\tcontinue # get outside the main while loop\\n\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright -= 1\\n\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minMovesToMakePalindrome(self, s: str) -> int:\\n\\t\\t\\ts = list(s) #makes it easy for assignment op\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tleft, right = 0, len(s) - 1\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tl, r = left, right\\n\\n\\t\\t\\t\\t#find matching char\\n\\t\\t\\t\\twhile s[l] != s[r]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\t\\t# if index dont match then swap\\n\\t\\t\\t\\tif l != r:\\n\\t\\t\\t\\t\\t# swap one by one\\n\\t\\t\\t\\t\\twhile r < right:\\n\\t\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t\\tr += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\tcontinue # get outside the main while loop\\n\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright -= 1\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2537153,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s)\\n    {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        int yes=-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                int temp=j-1;\\n                while(s[temp]!=s[i])\\n                    temp--;\\n                if(i!=temp)\\n                {\\n                    for(int k=temp+1;k<=j;k++)\\n                    {\\n                        swap(s[k-1],s[k]);\\n                        ans++;\\n                    }\\n                }\\n                else\\n                {\\n                    yes=i;\\n                    j++;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(yes!=-1)\\n        {\\n            ans+=((s.size())/2-yes);\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s)\\n    {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        int yes=-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                int temp=j-1;\\n                while(s[temp]!=s[i])\\n                    temp--;\\n                if(i!=temp)\\n                {\\n                    for(int k=temp+1;k<=j;k++)\\n                    {\\n                        swap(s[k-1],s[k]);\\n                        ans++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2451681,
                "title": "c-short-and-simple-greedy-solution",
                "content": "\\n```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), ans = 0;\\n        while(n)\\n        {\\n            int i = 0;\\n            while(s[i] != s[n-1]) i++;\\n            if(i == n-1) ans += (n-1)/2;\\n            else ans += i, s.erase(s.begin()+i),n--;\\n            s.pop_back();\\n            n--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), ans = 0;\\n        while(n)\\n        {\\n            int i = 0;\\n            while(s[i] != s[n-1]) i++;\\n            if(i == n-1) ans += (n-1)/2;\\n            else ans += i, s.erase(s.begin()+i),n--;\\n            s.pop_back();\\n            n--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2419573,
                "title": "easy-two-pointer-c-method-75-faster",
                "content": "```\\n int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=n-1;\\n        int cnt=0;\\n        int centre_ele=-1;\\n        int left,right;\\n        while(i<=j)\\n        {\\n            //non-matching elements\\n            if(s[i]!=s[j])\\n            {\\n                left=i+1;\\n                while(s[left]!=s[j] && left<j)\\n                {\\n                    left++;\\n                }\\n                \\n                //odd element found -> to be made middle element\\n                if(left==j)\\n                {\\n                   \\n                    centre_ele=j;\\n                    j--;\\n                    continue;\\n                }\\n                \\n                else\\n                {\\n                    for(int k=left;k>i;k--)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        cnt++;\\n                    }\\n                }\\n                \\n            }\\n            //normal matching elements\\n            else\\n            {\\n                i++;\\n                j--;\\n            }\\n        }\\n        \\n        \\n        \\n        if(centre_ele!=-1)\\n        {\\n            cnt+=centre_ele -(n / 2);\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=n-1;\\n        int cnt=0;\\n        int centre_ele=-1;\\n        int left,right;\\n        while(i<=j)\\n        {\\n            //non-matching elements\\n            if(s[i]!=s[j])\\n            {\\n                left=i+1;\\n                while(s[left]!=s[j] && left<j)\\n                {\\n                    left++;\\n                }\\n                \\n                //odd element found -> to be made middle element\\n                if(left==j)\\n                {\\n                   \\n                    centre_ele=j;\\n                    j--;\\n                    continue;\\n                }\\n                \\n                else\\n                {\\n                    for(int k=left;k>i;k--)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        cnt++;\\n                    }\\n                }\\n                \\n            }\\n            //normal matching elements\\n            else\\n            {\\n                i++;\\n                j--;\\n            }\\n        }\\n        \\n        \\n        \\n        if(centre_ele!=-1)\\n        {\\n            cnt+=centre_ele -(n / 2);\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152484,
                "title": "python3-peel-the-string",
                "content": "\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910883,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Greedy Approach***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint minMovesToMakePalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int count = 0;\\n        \\n        while(low <= high)\\n        {\\n            if(str[low] == str[high])\\n            {\\n                low++;\\n                \\n                high--;\\n            }\\n            else\\n            {\\n                int idx = high - 1;\\n                \\n                while(idx > low)\\n                {\\n                    if(str[low] == str[idx])\\n                    {\\n                        break;\\n                    }\\n                    \\n                    idx--;\\n                }\\n                \\n                if(idx == low)\\n                {\\n                    count++;\\n                    \\n                    swap(str[idx], str[idx + 1]);\\n                }\\n                \\n                else\\n                {\\n                    while(idx < high)\\n                    {\\n                        count++;\\n                    \\n                        swap(str[idx], str[idx + 1]);\\n                    \\n                        idx++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minMovesToMakePalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int count = 0;\\n        \\n        while(low <= high)\\n        {\\n            if(str[low] == str[high])\\n            {\\n                low++;\\n                \\n                high--;\\n            }\\n            else\\n            {\\n                int idx = high - 1;\\n                \\n                while(idx > low)\\n                {\\n                    if(str[low] == str[idx])\\n                    {\\n                        break;\\n                    }\\n                    \\n                    idx--;\\n                }\\n                \\n                if(idx == low)\\n                {\\n                    count++;\\n                    \\n                    swap(str[idx], str[idx + 1]);\\n                }\\n                \\n                else\\n                {\\n                    while(idx < high)\\n                    {\\n                        count++;\\n                    \\n                        swap(str[idx], str[idx + 1]);\\n                    \\n                        idx++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828689,
                "title": "c-two-pointers-implementation",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION AND EXPLANATION  :\\')**\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.length();\\n        int left=0,right=n-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n            int l=left,r=right; \\n            while(s[l]!=s[r])\\n            l++;//traversing from the left in search of the same ele as s[r]\\n        \\n            //if we do not get another occurence of s[r] i.e., there is only one instance and hence it will be the middle ele\\n            //we swap s[l] with the previous char to check whether another instance of that char is present so that we can \\n            //swap to make a valid palindromic string\\n            \\n        if(l==r)\\n        {\\n            //on doing this repeatedly for each window we have the single char at s[l] and finally at the last\\n            //iteration l will point to the middle of the string and hence the single ele will be placed at the middle of the\\n            //string resulting into a valid palindromic string\\n            \\n            swap(s[l-1],s[l]);\\n            res++;\\n            //here we do not decrease the size of the current window \\n            //for checking once again in the same window\\n            continue;\\n        }\\n        else\\n        {\\n            while(l>left)\\n            {\\n                swap(s[l-1],s[l]);\\n                res++;\\n                l--;\\n            }\\n        }\\n            //swap is done and hence we are sure that s[left]==s[right]\\n            //now we decrease the size of the window from both the sides and do the same process again\\n            left++;\\n            right--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.length();\\n        int left=0,right=n-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n            int l=left,r=right; \\n            while(s[l]!=s[r])\\n            l++;//traversing from the left in search of the same ele as s[r]\\n        \\n            //if we do not get another occurence of s[r] i.e., there is only one instance and hence it will be the middle ele\\n            //we swap s[l] with the previous char to check whether another instance of that char is present so that we can \\n            //swap to make a valid palindromic string\\n            \\n        if(l==r)\\n        {\\n            //on doing this repeatedly for each window we have the single char at s[l] and finally at the last\\n            //iteration l will point to the middle of the string and hence the single ele will be placed at the middle of the\\n            //string resulting into a valid palindromic string\\n            \\n            swap(s[l-1],s[l]);\\n            res++;\\n            //here we do not decrease the size of the current window \\n            //for checking once again in the same window\\n            continue;\\n        }\\n        else\\n        {\\n            while(l>left)\\n            {\\n                swap(s[l-1],s[l]);\\n                res++;\\n                l--;\\n            }\\n        }\\n            //swap is done and hence we are sure that s[left]==s[right]\\n            //now we decrease the size of the window from both the sides and do the same process again\\n            left++;\\n            right--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823441,
                "title": "python-easy-and-good-solution",
                "content": "**let\\'s take one example:** let ```s = \"letelt\"```. we have two cases where final ```s``` can start with ```l``` or final ```s``` can end with ```t```. we calculate moves  for both of them. for final ```s``` starts with ```l``` takes  1 swap(i.e letetl) and for final ```s``` ends with ```t``` takes two swap (i.e tleelt). starting with ```l``` is minimun so continue the process recursion with deleting both start and end letter of s. \\n\\n**TIME COMPLEXITY**:\\n```O(n*n)```\\n\\n**code**\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def check(w):\\n\\t\\t#base case\\n            if w==w[::-1]:\\n                return 0\\n            ans=0\\n\\t\\t#if already both ends are equal\\n            if w[0]==w[-1]:\\n                return check(w[1:-1])\\n            else:\\n                wi=w[::-1]\\n\\t\\t\\t\\t#i=first letter of word\\n                i=w[0]\\n\\t\\t\\t\\t#j is the last letter of the word\\n                j=wi[0]\\n\\t\\t\\t\\t#k is the no of swaps to make in w of j letter. This is fo checking swap with ending case\\n                k=w.index(j)\\n\\t\\t\\t\\t#swaps for starting case\\n                z=wi.index(i)\\n\\t\\t\\t\\t#final words after deleting\\n                q=w[:k]+w[k+1:-1]\\n                a=wi[:z]+wi[z+1:-1]\\n                #checking greedy\\n                if k<z:\\n                    ans+=check(q)+k\\n                else:\\n                    ans+=check(a)+z\\n            return ans\\n        return check(s)\\n```\\n**Please Upvote! I Really Appreciate it If You Upvote.**\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```s = \"letelt\"```\n```s```\n```l```\n```s```\n```t```\n```s```\n```l```\n```s```\n```t```\n```l```\n```O(n*n)```\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def check(w):\\n\\t\\t#base case\\n            if w==w[::-1]:\\n                return 0\\n            ans=0\\n\\t\\t#if already both ends are equal\\n            if w[0]==w[-1]:\\n                return check(w[1:-1])\\n            else:\\n                wi=w[::-1]\\n\\t\\t\\t\\t#i=first letter of word\\n                i=w[0]\\n\\t\\t\\t\\t#j is the last letter of the word\\n                j=wi[0]\\n\\t\\t\\t\\t#k is the no of swaps to make in w of j letter. This is fo checking swap with ending case\\n                k=w.index(j)\\n\\t\\t\\t\\t#swaps for starting case\\n                z=wi.index(i)\\n\\t\\t\\t\\t#final words after deleting\\n                q=w[:k]+w[k+1:-1]\\n                a=wi[:z]+wi[z+1:-1]\\n                #checking greedy\\n                if k<z:\\n                    ans+=check(q)+k\\n                else:\\n                    ans+=check(a)+z\\n            return ans\\n        return check(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822409,
                "title": "java-o-n-log-n-solution-with-binary-index-trees",
                "content": "```\\nclass Solution {\\n    List<Integer> [] charList;\\n    int [][] charPointers;\\n    int [] BIT;\\n    \\n    public int minMovesToMakePalindrome(String s) {\\n            \\n        charList = new List[26];\\n        charPointers = new int [26][2];\\n        BIT = new int [s.length()];\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charList[i] = new ArrayList<>();\\n        }\\n        \\n        for (int i = 0; i < s.length(); ++i)\\n            charList[s.charAt(i) - \\'a\\'].add(i);\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charPointers[i][0] = 0;\\n            charPointers[i][1] = charList[i].size() - 1;\\n        }\\n        \\n        int l = 0;\\n        int lP, rP;\\n        char c;\\n        int result = 0;\\n        int currentIdx;\\n        boolean [] visited = new boolean [s.length()];\\n        \\n        int mid = s.length() / 2;\\n        \\n        for (int r = s.length() - 1; r > l; --r){\\n            if (visited[r]) continue;\\n            \\n            c = s.charAt(r);\\n            \\n            lP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][0]++);\\n            rP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][1]--);\\n            \\n            visited[lP] = true;\\n            visited[rP] = true;\\n            \\n            if (lP == rP){\\n                result += Math.max(mid , 0);\\n                addToBIT(lP);\\n                continue;\\n            }\\n            \\n            result += lP  - getBITVal(lP);\\n            addToBIT(lP);\\n            --mid;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void addToBIT(int val){\\n        ++val;\\n        \\n        for (int i = val; i < BIT.length; i += (i & -i)){\\n            ++BIT[i];\\n        }\\n    }\\n    \\n    private int getBITVal(int val){\\n        val++;\\n        int result = 0;\\n        \\n        for (int i = val; i > 0; i -= (i & -i)){\\n            result += BIT[i];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> [] charList;\\n    int [][] charPointers;\\n    int [] BIT;\\n    \\n    public int minMovesToMakePalindrome(String s) {\\n            \\n        charList = new List[26];\\n        charPointers = new int [26][2];\\n        BIT = new int [s.length()];\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charList[i] = new ArrayList<>();\\n        }\\n        \\n        for (int i = 0; i < s.length(); ++i)\\n            charList[s.charAt(i) - \\'a\\'].add(i);\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charPointers[i][0] = 0;\\n            charPointers[i][1] = charList[i].size() - 1;\\n        }\\n        \\n        int l = 0;\\n        int lP, rP;\\n        char c;\\n        int result = 0;\\n        int currentIdx;\\n        boolean [] visited = new boolean [s.length()];\\n        \\n        int mid = s.length() / 2;\\n        \\n        for (int r = s.length() - 1; r > l; --r){\\n            if (visited[r]) continue;\\n            \\n            c = s.charAt(r);\\n            \\n            lP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][0]++);\\n            rP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][1]--);\\n            \\n            visited[lP] = true;\\n            visited[rP] = true;\\n            \\n            if (lP == rP){\\n                result += Math.max(mid , 0);\\n                addToBIT(lP);\\n                continue;\\n            }\\n            \\n            result += lP  - getBITVal(lP);\\n            addToBIT(lP);\\n            --mid;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void addToBIT(int val){\\n        ++val;\\n        \\n        for (int i = val; i < BIT.length; i += (i & -i)){\\n            ++BIT[i];\\n        }\\n    }\\n    \\n    private int getBITVal(int val){\\n        val++;\\n        int result = 0;\\n        \\n        for (int i = val; i > 0; i -= (i & -i)){\\n            result += BIT[i];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875388,
                "title": "c-two-pointers-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int low = 0;\\n        int high = s.length()-1;\\n\\n        int count = 0;\\n        while (low<=high)\\n        {\\n            if (s[low] != s[high])\\n            {\\n                int i = high-1;\\n                while (i>=low+1)\\n                {\\n                    if (s[low] == s[i])\\n                    {\\n                        break;\\n                    }\\n                    i--;\\n                }\\n\\n                int j = low+1;\\n                while (j<=high-1)\\n                {\\n                    if (s[high]==s[j])\\n                    {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n\\n                int d1 = high-i;\\n                int d2 = j-low;\\n\\n                if (d1<=d2)\\n                {\\n\\n                    while (i<=high-1)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        count++;\\n                        i++;\\n                    }\\n                }\\n                else\\n                {\\n                    while (j>=low+1)\\n                    {\\n                        swap(s[j],s[j-1]);\\n                        count++;\\n                        j--;\\n                    }\\n                }\\n            }\\n            low++;\\n            high--;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int low = 0;\\n        int high = s.length()-1;\\n\\n        int count = 0;\\n        while (low<=high)\\n        {\\n            if (s[low] != s[high])\\n            {\\n                int i = high-1;\\n                while (i>=low+1)\\n                {\\n                    if (s[low] == s[i])\\n                    {\\n                        break;\\n                    }\\n                    i--;\\n                }\\n\\n                int j = low+1;\\n                while (j<=high-1)\\n                {\\n                    if (s[high]==s[j])\\n                    {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n\\n                int d1 = high-i;\\n                int d2 = j-low;\\n\\n                if (d1<=d2)\\n                {\\n\\n                    while (i<=high-1)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        count++;\\n                        i++;\\n                    }\\n                }\\n                else\\n                {\\n                    while (j>=low+1)\\n                    {\\n                        swap(s[j],s[j-1]);\\n                        count++;\\n                        j--;\\n                    }\\n                }\\n            }\\n            low++;\\n            high--;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785032,
                "title": "easy-understandable-c-solution-greedy-two-pointers",
                "content": "# Intuition + Approach\\n- We basically try to convert the second half of the string into the first half.\\n- To do this, We greedily pick the closest element to the right pointer and swap it until we reach its correct position, i..e.. (n-i-1).\\n- An edge case will be when the length of the string is odd and there\\'s a character which occurs an odd number of times, and then this odd character should be present in the middle of the whole string.\\n- To do this, if the character is found at the same index as the left pointer, then we just shift it by one to the right,so that it comes in the middle eventually.\\n\\n# Complexity\\n- Time complexity: O(n*n) worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) , constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n> \\uD83C\\uDF86Upvote\\uD83C\\uDF86\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s){\\n        int left=0,right=s.size()-1;\\n        int out=0;\\n\\n        while(left<right){\\n            if(s[left]==s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                int r=right-1;\\n                while(s[left]!=s[r])r--;\\n                if(r==left){\\n                    swap(s[r],s[r+1]);\\n                    out++;\\n                }\\n                else{\\n                    while(r<right){\\n                        swap(s[r],s[r+1]);\\n                        out++;\\n                        r++;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\n```\\n![upvote xd.jpeg](https://assets.leetcode.com/users/images/affb622f-4207-4037-9821-0f5cba15aa17_1689714255.0265648.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s){\\n        int left=0,right=s.size()-1;\\n        int out=0;\\n\\n        while(left<right){\\n            if(s[left]==s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                int r=right-1;\\n                while(s[left]!=s[r])r--;\\n                if(r==left){\\n                    swap(s[r],s[r+1]);\\n                    out++;\\n                }\\n                else{\\n                    while(r<right){\\n                        swap(s[r],s[r+1]);\\n                        out++;\\n                        r++;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460146,
                "title": "simple-iterative-solution",
                "content": "# Intuition\\nin each iteration of the while loop(outer) we are solving a subproblem or trying to make the chars to be equal \\nfor that we can either swap the s[l] to next similar char on the right which is equal to s[r]\\nor we can swap s[r] we the next similar char on the left which is equal to s[l] \\neither way would work\\n//since the ans  is possible in every cases as mentioned by the question if we are unable to make chars similar at an index that the char will be the part of the middlwe of the pallindrome\\nin inner while loops we are calculating the total nbumber of swaps\\neach time we try to make the chars at l and r as equal \\nafter each iteration of the outer while loop we only require to find the min swaps in s[lt..rt] as we have made the rest as pallindrome\\nthis is some kind of a subproblem \\nhere  choosing the next first occrrence on the left or the right which can make the curr 2 as equal is the greedy approach here \\nwhich works for the all the test cases\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n\\n        //here we will be using an iterative recursive approach \\n        int lt=0;\\n        int rt=s.size()-1;\\n        int ans=0;\\n        //ans will keep track of the minimum number of swaps required to make it pallindrome in the most \\n        //optimal ways\\n        int l;\\n        int r;\\n        while(lt<rt){\\n          l=lt;\\n          r=rt;\\n\\n          while(s[l]!=s[r])l++;\\n          //finding the first occurence from the right side which can make the current 2 characters equal\\n          if(l==r){\\n            //then it will be part of the odd length part in btw the whole pallindrome\\n            swap(s[l],s[l-1]);//here we will be using the internal c++  swapping function\\n            ans++;\\n            continue;\\n          }\\n          while(l>lt){\\n            swap(s[l],s[l-1]);\\n            l--;\\n            ans++;\\n          }\\n          lt++;\\n          rt--;\\n          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n\\n        //here we will be using an iterative recursive approach \\n        int lt=0;\\n        int rt=s.size()-1;\\n        int ans=0;\\n        //ans will keep track of the minimum number of swaps required to make it pallindrome in the most \\n        //optimal ways\\n        int l;\\n        int r;\\n        while(lt<rt){\\n          l=lt;\\n          r=rt;\\n\\n          while(s[l]!=s[r])l++;\\n          //finding the first occurence from the right side which can make the current 2 characters equal\\n          if(l==r){\\n            //then it will be part of the odd length part in btw the whole pallindrome\\n            swap(s[l],s[l-1]);//here we will be using the internal c++  swapping function\\n            ans++;\\n            continue;\\n          }\\n          while(l>lt){\\n            swap(s[l],s[l-1]);\\n            l--;\\n            ans++;\\n          }\\n          lt++;\\n          rt--;\\n          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942333,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        \\n        int result=0;\\n        int start=0,end=s.size()-1;\\n\\n       while(end>start){\\n             if(s[start]!=s[end]){\\n            int i=end;\\n            while(i>start&&s[start]!=s[i]){\\n                i--;\\n            }\\n            if(i==start){\\n                swap(s[start],s[start+1]);\\n                result++;\\n                \\n            }\\n            else{\\n                while(i<end){\\n                    swap(s[i],s[i+1]);\\n                    result++;\\n                    i++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n        else{\\n            start++;\\n            end--;\\n        }\\n       }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        \\n        int result=0;\\n        int start=0,end=s.size()-1;\\n\\n       while(end>start){\\n             if(s[start]!=s[end]){\\n            int i=end;\\n            while(i>start&&s[start]!=s[i]){\\n                i--;\\n            }\\n            if(i==start){\\n                swap(s[start],s[start+1]);\\n                result++;\\n                \\n            }\\n            else{\\n                while(i<end){\\n                    swap(s[i],s[i+1]);\\n                    result++;\\n                    i++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n        else{\\n            start++;\\n            end--;\\n        }\\n       }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812340,
                "title": "python-2-pointers-explanation",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        # At each point, we look at the first and the last elements\\n        # if they are the same, then we skip them, else we find\\n        # another element in the string that matches the left\\n        # element and then we make the necessary swaps to move it\\n        # to the right place. \\n        # if we can\\'t find that element -- this means this is the middle element\\n        # in the palindrome, we just move it one position to the right and continue\\n        # over the next few iterations, it will be moved to the center automatically\\n        # run it for string = \"dpacacp\", answer should be 4\\n        # the character that should be in the middle is \"d\"\\n        l, r, res, st = 0, len(s)-1, 0, list(s)\\n        while l < r:\\n            if st[l] != st[r]:\\n                i = r\\n                while i > l and st[l] != st[i]:\\n                    i -= 1\\n                if i == l:\\n                    st[i], st[i+1] = st[i+1], st[i]\\n                    res += 1\\n                    continue\\n                else:\\n                    while i < r:\\n                        st[i], st[i+1] = st[i+1], st[i]\\n                        i += 1\\n                        res += 1\\n            l, r = l+1, r-1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        # At each point, we look at the first and the last elements\\n        # if they are the same, then we skip them, else we find\\n        # another element in the string that matches the left\\n        # element and then we make the necessary swaps to move it\\n        # to the right place. \\n        # if we can\\'t find that element -- this means this is the middle element\\n        # in the palindrome, we just move it one position to the right and continue\\n        # over the next few iterations, it will be moved to the center automatically\\n        # run it for string = \"dpacacp\", answer should be 4\\n        # the character that should be in the middle is \"d\"\\n        l, r, res, st = 0, len(s)-1, 0, list(s)\\n        while l < r:\\n            if st[l] != st[r]:\\n                i = r\\n                while i > l and st[l] != st[i]:\\n                    i -= 1\\n                if i == l:\\n                    st[i], st[i+1] = st[i+1], st[i]\\n                    res += 1\\n                    continue\\n                else:\\n                    while i < r:\\n                        st[i], st[i+1] = st[i+1], st[i]\\n                        i += 1\\n                        res += 1\\n            l, r = l+1, r-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657441,
                "title": "java-easy-solution-w-comments-using-two-pointer-swapping",
                "content": "# Intuition\\nJava Solution to Minimum Number of Moves To Make Palindrome. Uses a Two Pointer approach with swapping.\\n\\nIncluded comments for reference.\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        if (len == 0) return -1;\\n\\n        char[] chars = s.toCharArray();             // Init char array of all characters from s\\n        int swaps = 0;                              // int to store final number of swaps taken to make the palindrome\\n\\n        // Use a two-pointer approach, initialize int pointer for left and right\\n        int left = 0;\\n        int right = len - 1;\\n\\n        while (left < right)\\n        {\\n            // Found a palindrome\\n            if (chars[left] == chars[right])\\n            {\\n                left++;                             // Increment left pointer\\n                right--;                            // Decrement right pointer\\n            }\\n            // Characters are not palindrome\\n            else\\n            {\\n                // Search for character moving towards the starting point \\'left\\' to ensure\\n                // minimum number of moves until char at k matches char at \\'left\\'\\n                int k = right;\\n                k = findIndexMatchingLeftIndex(chars, left, k);\\n\\n                // Character matching char at index \\'left\\' was not found between initial k index and left index\\n                if (k == left)\\n                {\\n                    swaps++;                        // Increment swap count\\n                    swapChars(chars, left);         // Swap left with left + 1\\n                }\\n                // Character matching char at index \\'left\\' was found between initial k index and left index\\n                // Swap all characters from k to k + 1\\n                else\\n                {\\n                    while (k < right)\\n                    {\\n                        swaps++;\\n                        swapChars(chars, k);\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the number of swaps (Moves) needed to make the Palindrome\\n        return swaps;\\n    }\\n\\n    /**\\n     * Swap Characters In The Character Array.\\n     */\\n    public void swapChars(char[] chars, int left) {\\n        // Swap chars[]\\n        if (left -1 < chars.length)\\n        {\\n            char temp = chars[left];\\n            chars[left] = chars[left + 1];\\n            chars[left + 1] = temp;\\n        }\\n    }\\n\\n    /**\\n     * Finds The Kth Index In The Input char[] That Matches The Character At The Left Index Of The Input char[].\\n     */\\n    public int findIndexMatchingLeftIndex(char[] chars, int left, int k) {\\n        while (left < k)\\n        {\\n            if (chars[k] == chars[left])\\n            {\\n                return k;\\n            }\\n            k--;                                    // Decrement k to compare with the previous index of the arr with left\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        if (len == 0) return -1;\\n\\n        char[] chars = s.toCharArray();             // Init char array of all characters from s\\n        int swaps = 0;                              // int to store final number of swaps taken to make the palindrome\\n\\n        // Use a two-pointer approach, initialize int pointer for left and right\\n        int left = 0;\\n        int right = len - 1;\\n\\n        while (left < right)\\n        {\\n            // Found a palindrome\\n            if (chars[left] == chars[right])\\n            {\\n                left++;                             // Increment left pointer\\n                right--;                            // Decrement right pointer\\n            }\\n            // Characters are not palindrome\\n            else\\n            {\\n                // Search for character moving towards the starting point \\'left\\' to ensure\\n                // minimum number of moves until char at k matches char at \\'left\\'\\n                int k = right;\\n                k = findIndexMatchingLeftIndex(chars, left, k);\\n\\n                // Character matching char at index \\'left\\' was not found between initial k index and left index\\n                if (k == left)\\n                {\\n                    swaps++;                        // Increment swap count\\n                    swapChars(chars, left);         // Swap left with left + 1\\n                }\\n                // Character matching char at index \\'left\\' was found between initial k index and left index\\n                // Swap all characters from k to k + 1\\n                else\\n                {\\n                    while (k < right)\\n                    {\\n                        swaps++;\\n                        swapChars(chars, k);\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the number of swaps (Moves) needed to make the Palindrome\\n        return swaps;\\n    }\\n\\n    /**\\n     * Swap Characters In The Character Array.\\n     */\\n    public void swapChars(char[] chars, int left) {\\n        // Swap chars[]\\n        if (left -1 < chars.length)\\n        {\\n            char temp = chars[left];\\n            chars[left] = chars[left + 1];\\n            chars[left + 1] = temp;\\n        }\\n    }\\n\\n    /**\\n     * Finds The Kth Index In The Input char[] That Matches The Character At The Left Index Of The Input char[].\\n     */\\n    public int findIndexMatchingLeftIndex(char[] chars, int left, int k) {\\n        while (left < k)\\n        {\\n            if (chars[k] == chars[left])\\n            {\\n                return k;\\n            }\\n            k--;                                    // Decrement k to compare with the previous index of the arr with left\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614313,
                "title": "rust-simple-greedy-solution",
                "content": "For any string with length > 1, check the number of moves required to make the string with equal leftmost and rightmost characters. Remove the leftmost and the rightmost characters. Repeat the procedure until the string length less than or equal to 1. The sum of all moves is the answer.\\n\\n```rust\\nuse std::collections::*;\\n \\nimpl Solution {\\n\\tpub fn min_moves_to_make_palindrome(s: String) -> i32 {\\n\\t\\tlet mut s = s.clone();\\n\\t\\tlet mut ans = 0;\\n\\t\\twhile s.len() > 1 {\\n\\t\\t\\tlet i = s.rfind(s.chars().nth(0).unwrap()).unwrap();\\n\\t\\t\\tif i != 0 {\\n\\t\\t\\t\\tans += (s.len() - 1 - i) as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[1..i], &s[i + 1..]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet i = s.find(s.chars().last().unwrap()).unwrap();\\n\\t\\t\\t\\tans += i as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[..i], &s[i + 1..(s.len() - 1)]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```rust\\nuse std::collections::*;\\n \\nimpl Solution {\\n\\tpub fn min_moves_to_make_palindrome(s: String) -> i32 {\\n\\t\\tlet mut s = s.clone();\\n\\t\\tlet mut ans = 0;\\n\\t\\twhile s.len() > 1 {\\n\\t\\t\\tlet i = s.rfind(s.chars().nth(0).unwrap()).unwrap();\\n\\t\\t\\tif i != 0 {\\n\\t\\t\\t\\tans += (s.len() - 1 - i) as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[1..i], &s[i + 1..]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet i = s.find(s.chars().last().unwrap()).unwrap();\\n\\t\\t\\t\\tans += i as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[..i], &s[i + 1..(s.len() - 1)]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2604630,
                "title": "python3-easy-to-understand-2-pointer-solution-with-comments",
                "content": "```\\n\\'\\'\\'\\nidea is to fix one side (left or right) and make other side equal to it\\nfor e.g. \\naabb , I will make right side equal to left.\\n1. index[0] = a != index[3] = b \\n2. now look for a from right to left \\n3. once found swap with adjacent element till it reaches index[3].\\n4. abba. is palindrome. took 2 swaps, \\n\\nfor cases like abb \\n1. we fixed left side a. \\n2. now from right we will move to left looking for a , we found it at index 0 which is our left\\n3. now when left == right, just swap it with next adjacent element and continue.\\n4. you will get your palindrome\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        lt = 0\\n        rt = n-1\\n        ans = 0\\n        while lt < rt:\\n            l = lt\\n            r = rt\\n            while s[l] != s[r]:\\n                r -= 1\\n            # for abb like case\\n            # swap(s[r], s[r+1])\\n            # bab\\n            if l == r:\\n                s[r], s[r+1] = s[r+1], s[r]\\n                ans += 1\\n                continue\\n            else:\\n\\t\\t\\t# for aabb like case\\n                while r < rt:\\n                    s[r], s[r+1] = s[r+1], s[r]\\n                    ans += 1\\n                    r += 1\\n            lt += 1\\n            rt -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\\'\\'\\'\\nidea is to fix one side (left or right) and make other side equal to it\\nfor e.g. \\naabb , I will make right side equal to left.\\n1. index[0] = a != index[3] = b \\n2. now look for a from right to left \\n3. once found swap with adjacent element till it reaches index[3].\\n4. abba. is palindrome. took 2 swaps, \\n\\nfor cases like abb \\n1. we fixed left side a. \\n2. now from right we will move to left looking for a , we found it at index 0 which is our left\\n3. now when left == right, just swap it with next adjacent element and continue.\\n4. you will get your palindrome\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        lt = 0\\n        rt = n-1\\n        ans = 0\\n        while lt < rt:\\n            l = lt\\n            r = rt\\n            while s[l] != s[r]:\\n                r -= 1\\n            # for abb like case\\n            # swap(s[r], s[r+1])\\n            # bab\\n            if l == r:\\n                s[r], s[r+1] = s[r+1], s[r]\\n                ans += 1\\n                continue\\n            else:\\n\\t\\t\\t# for aabb like case\\n                while r < rt:\\n                    s[r], s[r+1] = s[r+1], s[r]\\n                    ans += 1\\n                    r += 1\\n            lt += 1\\n            rt -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603132,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char arr[]=s.toCharArray();\\n        int i=0; \\n        int j=arr.length-1;\\n        while(i<j){\\n            int high=j;\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                    }\\n                \\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char arr[]=s.toCharArray();\\n        int i=0; \\n        int j=arr.length-1;\\n        while(i<j){\\n            int high=j;\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                    }\\n                \\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533462,
                "title": "python-2-pointer-approach",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        res, left, right = 0, 0, len(s) - 1\\n        while left < right:\\n            l, r = left, right\\n            while s[l] != s[r]:\\n                r -= 1\\n            if l == r:\\n                s[r], s[r + 1] = s[r + 1], s[r]\\n                res += 1\\n                continue\\n            else:\\n                while r < right:\\n                    s[r], s[r + 1] = s[r + 1], s[r]\\n                    res += 1\\n                    r += 1\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        res, left, right = 0, 0, len(s) - 1\\n        while left < right:\\n            l, r = left, right\\n            while s[l] != s[r]:\\n                r -= 1\\n            if l == r:\\n                s[r], s[r + 1] = s[r + 1], s[r]\\n                res += 1\\n                continue\\n            else:\\n                while r < right:\\n                    s[r], s[r + 1] = s[r + 1], s[r]\\n                    res += 1\\n                    r += 1\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525848,
                "title": "c-simple-c-code",
                "content": "**Taken the help by master piece submission by**\\nhttps://leetcode.com/be_quick/\\n\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.size()-1, ans = 0;\\n        while(i < j)\\n        {\\n            while(s[i] == s[j])\\n            {\\n                if(i >= j)\\n                    return ans;\\n                i++;\\n                j--;\\n            }\\n            int indx = -1;\\n            for(int k = j-1; k > i; k--)\\n            {\\n                if(s[i] != s[k])\\n                    continue;\\n                indx = k;\\n                break;\\n            }\\n            if(indx != -1)\\n            {\\n                for(int k = indx; k < j; k++)\\n                {\\n                    swap(s[k], s[k+1]);\\n                    ans++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                swap(s[i], s[i+1]);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.size()-1, ans = 0;\\n        while(i < j)\\n        {\\n            while(s[i] == s[j])\\n            {\\n                if(i >= j)\\n                    return ans;\\n                i++;\\n                j--;\\n            }\\n            int indx = -1;\\n            for(int k = j-1; k > i; k--)\\n            {\\n                if(s[i] != s[k])\\n                    continue;\\n                indx = k;\\n                break;\\n            }\\n            if(indx != -1)\\n            {\\n                for(int k = indx; k < j; k++)\\n                {\\n                    swap(s[k], s[k+1]);\\n                    ans++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                swap(s[i], s[i+1]);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512462,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> list = s.ToList();\\n        int moves = 0;\\n        while(list.Count > 2){\\n            char target = list[0];\\n            int i = list.FindLastIndex(ch => ch == target);\\n            if(i != 0){\\n                moves += list.Count-i-1;\\n                list.RemoveAt(i);\\n                list.RemoveAt(0);\\n            } else{\\n                target = list[list.Count-1];\\n                i = list.FindIndex(ch => ch == target);\\n                moves += i;\\n                list.RemoveAt(list.Count-1);\\n                list.RemoveAt(i);\\n            }\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> list = s.ToList();\\n        int moves = 0;\\n        while(list.Count > 2){\\n            char target = list[0];\\n            int i = list.FindLastIndex(ch => ch == target);\\n            if(i != 0){\\n                moves += list.Count-i-1;\\n                list.RemoveAt(i);\\n                list.RemoveAt(0);\\n            } else{\\n                target = list[list.Count-1];\\n                i = list.FindIndex(ch => ch == target);\\n                moves += i;\\n                list.RemoveAt(list.Count-1);\\n                list.RemoveAt(i);\\n            }\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399882,
                "title": "java-o-nlogn-harder-variant-of-1505",
                "content": "This question is the harder version of [#1505 (link)](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits), so I can recommend that you do that problem first before coming back to this one. The idea is basically the same - to know what its actual position is, we need the prefix sum AND suffix sum of the characters we\\'ve swapped.\\n\\nHere I am using 2 BIT arrays for the sake of simplicity.  There are 2 cases, for the one we are switching to the head, denoted by `a` in my code below, it\\'s cost needed is `L - i + (i - sum(head, L)) - sum(tail, L);`. \\n> It translates to \"Current index - current head position + all the characters behind it that moved to the head previously - all the characters ahead of it that moved to the tail` \\n\\nFor the one moving to tail, it needs `j - R + sum(tail, R) - (i - sum(head, R))`\\n\\n#### Java\\n```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] A = s.toCharArray();\\n        Deque<Integer>[] deque = new ArrayDeque[26];\\n        Arrays.setAll(deque, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){\\n            deque[A[i]-\\'a\\'].offer(i);\\n        }\\n        int[] head = new int[A.length+1];\\n        int[] tail = new int[A.length+1];\\n        int i = 0, j = s.length()-1, ans = 0;\\n        while(i < j){\\n            int min = (int)1e9, idx = -1;\\n            for (int k = 0; k < 26; k++){\\n                if (deque[k].size()>=2){\\n                    int L = deque[k].peekFirst(), R = deque[k].peekLast();\\n                    int a = L - i + (i - sum(head, L)) - sum(tail, L);\\n                    int b = j - R + sum(tail, R) - (i - sum(head, R));\\n                    if (a+b < min){\\n                        min=a+b;\\n                        idx=k;\\n                    }\\n                }\\n            }\\n            ans += min;\\n            add(head, deque[idx].pollFirst(), 1);\\n            add(tail, deque[idx].pollLast(), 1);\\n            i++;\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] A = s.toCharArray();\\n        Deque<Integer>[] deque = new ArrayDeque[26];\\n        Arrays.setAll(deque, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){\\n            deque[A[i]-\\'a\\'].offer(i);\\n        }\\n        int[] head = new int[A.length+1];\\n        int[] tail = new int[A.length+1];\\n        int i = 0, j = s.length()-1, ans = 0;\\n        while(i < j){\\n            int min = (int)1e9, idx = -1;\\n            for (int k = 0; k < 26; k++){\\n                if (deque[k].size()>=2){\\n                    int L = deque[k].peekFirst(), R = deque[k].peekLast();\\n                    int a = L - i + (i - sum(head, L)) - sum(tail, L);\\n                    int b = j - R + sum(tail, R) - (i - sum(head, R));\\n                    if (a+b < min){\\n                        min=a+b;\\n                        idx=k;\\n                    }\\n                }\\n            }\\n            ans += min;\\n            add(head, deque[idx].pollFirst(), 1);\\n            add(tail, deque[idx].pollLast(), 1);\\n            i++;\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384907,
                "title": "python-simple-recursion-97-time",
                "content": "```\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n <= 1:\\n            return 0\\n        if s[0]==s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        \\n        ind_l, ind_r = s.find(s[-1]), s.rfind(s[0])\\n        if ind_l <= n-1-ind_r:\\n            return ind_l + self.minMovesToMakePalindrome(s[:ind_l] + s[ind_l+1:-1])\\n        else:\\n            return n-1-ind_r + self.minMovesToMakePalindrome(s[1:ind_r] + s[ind_r+1:])\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n <= 1:\\n            return 0\\n        if s[0]==s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        \\n        ind_l, ind_r = s.find(s[-1]), s.rfind(s[0])\\n        if ind_l <= n-1-ind_r:\\n            return ind_l + self.minMovesToMakePalindrome(s[:ind_l] + s[ind_l+1:-1])\\n        else:\\n            return n-1-ind_r + self.minMovesToMakePalindrome(s[1:ind_r] + s[ind_r+1:])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2259580,
                "title": "c-two-pointers-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n     Two cases can come\\n     while we can compare first half with other half\\n     case 1  aabb -> a != b come back and see if we find a , we finally find an \\'a\\' at aa so swap it till we bring it at end to match , abab swap again abba, now a==a now its turn of b and its matching so we return swaps=2\\n     case 2 - odd number of chars abb , a!=b search for a, we finally get a at a itself which means its the only character in the string so swap it with next index\\n     abb->bab and continue your search , b==b so swaps=1 ans\\n    */\\n    int minMovesToMakePalindrome(string s) {\\n        int left=0;\\n        int right=s.size()-1;\\n        int ans=0;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            \\n            //while you not find char same a first element continue decreasing right index\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            //case 2 ->single element found\\n            if(l==r)\\n            {\\n                swap(s[r],s[r+1]);\\n                ans++;\\n                continue;\\n            }\\n            else\\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r],s[r+1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n     Two cases can come\\n     while we can compare first half with other half\\n     case 1  aabb -> a != b come back and see if we find a , we finally find an \\'a\\' at aa so swap it till we bring it at end to match , abab swap again abba, now a==a now its turn of b and its matching so we return swaps=2\\n     case 2 - odd number of chars abb , a!=b search for a, we finally get a at a itself which means its the only character in the string so swap it with next index\\n     abb->bab and continue your search , b==b so swaps=1 ans\\n    */\\n    int minMovesToMakePalindrome(string s) {\\n        int left=0;\\n        int right=s.size()-1;\\n        int ans=0;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            \\n            //while you not find char same a first element continue decreasing right index\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            //case 2 ->single element found\\n            if(l==r)\\n            {\\n                swap(s[r],s[r+1]);\\n                ans++;\\n                continue;\\n            }\\n            else\\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r],s[r+1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248463,
                "title": "c-easy-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n         int cnt = 0;\\n         while(!s.empty()) {\\n             int other = s.find(s.back());\\n             if(other==s.size()-1) {\\n                   // odd ?\\n                   cnt+=other/2;   // move it to the middle \\n             }else {\\n                   cnt+=other;\\n                   s.erase(other,1);   // delete char at positon \\n             }\\n             s.pop_back();\\n         }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n         int cnt = 0;\\n         while(!s.empty()) {\\n             int other = s.find(s.back());\\n             if(other==s.size()-1) {\\n                   // odd ?\\n                   cnt+=other/2;   // move it to the middle \\n             }else {\\n                   cnt+=other;\\n                   s.erase(other,1);   // delete char at positon \\n             }\\n             s.pop_back();\\n         }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191696,
                "title": "using-two-pointer-simplest-solution",
                "content": "```\\n int i=0;\\n        int j=s.size()-1;\\n        int l=0;\\n        int r=s.size()-1;\\n        int cnt=0;\\n        while(l<r){\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            i=l;\\n            j=r;\\n            while(s[j]!=s[i]){\\n                j--;\\n            }\\n            swap(s[j],s[j+1]);\\n            cnt++;         \\n        }\\n        \\n        return cnt;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int i=0;\\n        int j=s.size()-1;\\n        int l=0;\\n        int r=s.size()-1;\\n        int cnt=0;\\n        while(l<r){\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            i=l;\\n            j=r;\\n            while(s[j]!=s[i]){\\n                j--;\\n            }\\n            swap(s[j],s[j+1]);\\n            cnt++;         \\n        }\\n        \\n        return cnt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106361,
                "title": "python-2-pointers-greddy",
                "content": "Make first half equal to second half greedily!!\\n\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        s=list(s)\\n        l,r=0,n-1\\n        ans=0\\n        while (l<r):\\n            ll,rr=l,r\\n            while (s[ll]!=s[rr]): rr-=1\\n            if (ll==rr):              # found a middle element in an odd palindrome\\n                s[rr],s[rr+1]=s[rr+1],s[rr]\\n                ans+=1\\n                continue\\n            else:\\n                while (rr<r): \\n                    s[rr],s[rr+1]=s[rr+1],s[rr]\\n                    rr+=1\\n                    ans+=1\\n            l+=1\\n            r-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        s=list(s)\\n        l,r=0,n-1\\n        ans=0\\n        while (l<r):\\n            ll,rr=l,r\\n            while (s[ll]!=s[rr]): rr-=1\\n            if (ll==rr):              # found a middle element in an odd palindrome\\n                s[rr],s[rr+1]=s[rr+1],s[rr]\\n                ans+=1\\n                continue\\n            else:\\n                while (rr<r): \\n                    s[rr],s[rr+1]=s[rr+1],s[rr]\\n                    rr+=1\\n                    ans+=1\\n            l+=1\\n            r-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063971,
                "title": "very-easy-solution-with-proper-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /**\\n    \\n    observation->we only need to move one of two characters of the palindrome string at minimum cost\\n    \\n    \\n    move from left to right\\n        try to find and swap the character according scanning from right to left\\n            -> from required position to left\\n    \\n        in case of odd length of the string you may find a unpaired character which you have to store in the center of the string.\\n        -> you can ignore it if it is present on the right side of the string because it will adjust itself automatically \\n        -> but if it is on the left side \\n            just reverse the string and pass in the same function\\n    */\\n    \\n    int solve(string &a)\\n    {        \\n        int size = a.size();\\n        \\n        int cnt=0;\\n        \\n        //traverse only the half of the string \\n        for(int i=0;i<size/2;i++)\\n        {\\n            \\n            int ind=-1;\\n            \\n            //searching for other pair right to left from required position-> size-1-i \\n            for(int j=size-1-i;j>i;j--)\\n            {\\n                //break if found\\n                if(a[i]==a[j]){\\n                    ind=j;\\n                    break;\\n                }\\n            }\\n        \\n            //in case of unpaired character \\n            //reverse the string and pass to same function\\n            //just to move that unpaired character to right part\\n            if(ind==-1)\\n            {\\n                reverse(a.begin(),a.end());\\n                return cnt+solve(a);\\n            }\\n            \\n            //add the difference of indexes (actual index to required index) in the cound\\n            cnt += size-1-i-ind;\\n            \\n            //modify the string accordingly\\n            for(int j=ind;j<size-1-i;j++)\\n            {\\n                swap(a[j],a[j+1]);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /**\\n    \\n    observation->we only need to move one of two characters of the palindrome string at minimum cost\\n    \\n    \\n    move from left to right\\n        try to find and swap the character according scanning from right to left\\n            -> from required position to left\\n    \\n        in case of odd length of the string you may find a unpaired character which you have to store in the center of the string.\\n        -> you can ignore it if it is present on the right side of the string because it will adjust itself automatically \\n        -> but if it is on the left side \\n            just reverse the string and pass in the same function\\n    */\\n    \\n    int solve(string &a)\\n    {        \\n        int size = a.size();\\n        \\n        int cnt=0;\\n        \\n        //traverse only the half of the string \\n        for(int i=0;i<size/2;i++)\\n        {\\n            \\n            int ind=-1;\\n            \\n            //searching for other pair right to left from required position-> size-1-i \\n            for(int j=size-1-i;j>i;j--)\\n            {\\n                //break if found\\n                if(a[i]==a[j]){\\n                    ind=j;\\n                    break;\\n                }\\n            }\\n        \\n            //in case of unpaired character \\n            //reverse the string and pass to same function\\n            //just to move that unpaired character to right part\\n            if(ind==-1)\\n            {\\n                reverse(a.begin(),a.end());\\n                return cnt+solve(a);\\n            }\\n            \\n            //add the difference of indexes (actual index to required index) in the cound\\n            cnt += size-1-i-ind;\\n            \\n            //modify the string accordingly\\n            for(int j=ind;j<size-1-i;j++)\\n            {\\n                swap(a[j],a[j+1]);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906760,
                "title": "typescript-greedy-faster-that-100",
                "content": "```\\nfunction minMovesToMakePalindrome(s: string): number {\\n    let leftIndex = 0\\n    let rightIndex = s.length - 1\\n    const sArr: string[] = Array.from(s)\\n    let sumChange = 0\\n    \\n    while(leftIndex < rightIndex){\\n        if(sArr[leftIndex] === sArr[rightIndex]){\\n            leftIndex ++\\n            rightIndex --\\n            continue\\n        }\\n        let matchRight = leftIndex + 1\\n        let matchLeft = rightIndex - 1\\n        \\n        while(sArr[matchRight] !== sArr[rightIndex]){\\n            matchRight++\\n        }\\n        while(sArr[matchLeft] !== sArr[leftIndex]){\\n            matchLeft--\\n        }\\n        if(matchRight - leftIndex <= rightIndex - matchLeft){\\n            sumChange += matchRight - leftIndex\\n            sArr.splice(matchRight, 1)\\n            sArr.splice(leftIndex, 0, s[rightIndex])\\n        }else{\\n            sumChange += rightIndex - matchLeft\\n            sArr.splice(rightIndex + 1, 0, s[leftIndex])\\n            sArr.splice(matchLeft, 1)\\n        }\\n        leftIndex ++\\n        rightIndex --\\n    }\\n    return sumChange\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction minMovesToMakePalindrome(s: string): number {\\n    let leftIndex = 0\\n    let rightIndex = s.length - 1\\n    const sArr: string[] = Array.from(s)\\n    let sumChange = 0\\n    \\n    while(leftIndex < rightIndex){\\n        if(sArr[leftIndex] === sArr[rightIndex]){\\n            leftIndex ++\\n            rightIndex --\\n            continue\\n        }\\n        let matchRight = leftIndex + 1\\n        let matchLeft = rightIndex - 1\\n        \\n        while(sArr[matchRight] !== sArr[rightIndex]){\\n            matchRight++\\n        }\\n        while(sArr[matchLeft] !== sArr[leftIndex]){\\n            matchLeft--\\n        }\\n        if(matchRight - leftIndex <= rightIndex - matchLeft){\\n            sumChange += matchRight - leftIndex\\n            sArr.splice(matchRight, 1)\\n            sArr.splice(leftIndex, 0, s[rightIndex])\\n        }else{\\n            sumChange += rightIndex - matchLeft\\n            sArr.splice(rightIndex + 1, 0, s[leftIndex])\\n            sArr.splice(matchLeft, 1)\\n        }\\n        leftIndex ++\\n        rightIndex --\\n    }\\n    return sumChange\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850587,
                "title": "c-greedy-solution-o-n-2",
                "content": "Runtime: 31 ms, faster than 47.44% of C++ online submissions for Minimum Number of Moves to Make Palindrome.\\nMemory Usage: 6.8 MB, less than 50.32% of C++ online submissions for Minimum Number of Moves to Make Palindrome.\\n\\n```\\nTo make string palindrome we can keep left half of string in exact position and change \\nthe right half chars using swaps from from two end point.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        int sl = s.length();\\n\\n        // left and right end pointers\\n        int left = 0;\\n        int right = sl - 1;\\n        \\n        // count number of swaps\\n        int swapCount = 0;\\n\\n        // loop through string from both side using left and right pointer\\n        while (left < right)\\n        {\\n            // if left and right pointer chars are not same then \\n            // find the rightmost position X of left pointer char\\n            // then swap from X to right pointer and increment swap count \\n            if (s[left] != s[right])\\n            {\\n                int l = left;\\n                int r = right;\\n                \\n                // get the right most index of s[l] char\\n                while(s[l]!=s[r])r--;\\n                \\n                // only swap once if s[l] is single char in range left and right\\n                if (l == r) {\\n                    swap(s[r], s[r + 1]);\\n                    swapCount++;\\n                    continue;\\n                }\\n                \\n                // swap from r to right and increment count\\n                while(r<right)\\n                {\\n                    swap(s[r+1],s[r]);\\n                    r++;\\n                    swapCount++;\\n                }\\n            }\\n\\n            // reduce right and left pointer from both side in each step\\n            left++;\\n            right--;\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nTo make string palindrome we can keep left half of string in exact position and change \\nthe right half chars using swaps from from two end point.\\n```\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        int sl = s.length();\\n\\n        // left and right end pointers\\n        int left = 0;\\n        int right = sl - 1;\\n        \\n        // count number of swaps\\n        int swapCount = 0;\\n\\n        // loop through string from both side using left and right pointer\\n        while (left < right)\\n        {\\n            // if left and right pointer chars are not same then \\n            // find the rightmost position X of left pointer char\\n            // then swap from X to right pointer and increment swap count \\n            if (s[left] != s[right])\\n            {\\n                int l = left;\\n                int r = right;\\n                \\n                // get the right most index of s[l] char\\n                while(s[l]!=s[r])r--;\\n                \\n                // only swap once if s[l] is single char in range left and right\\n                if (l == r) {\\n                    swap(s[r], s[r + 1]);\\n                    swapCount++;\\n                    continue;\\n                }\\n                \\n                // swap from r to right and increment count\\n                while(r<right)\\n                {\\n                    swap(s[r+1],s[r]);\\n                    r++;\\n                    swapCount++;\\n                }\\n            }\\n\\n            // reduce right and left pointer from both side in each step\\n            left++;\\n            right--;\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832463,
                "title": "java-greedy-with-explanation",
                "content": "Each time we check the first and the last character. If they are the same, we can quickly shrink this problem into a subproblem with the size of n - 2. \\nIf they are not the same, such as \"a..b..a..b\", then the answer becomes which character we need to choose as the end of both sides. If we choose \\'a\\', we need to move the last \\'a\\' to the end, and the cost will be the distance between the last \\'b\\' and the last \\'a\\'; If we choose \\'b\\', we need to move the first \\'b\\' to the beginning, the cost will be the distance between the first \\'a\\' and the first \\'b\\'. Therefore, we apply a greedy strategy picking the less costly one. \\nWe apply this greedy strategy recursively until the size of the string less than or equal to 2(that would be the base case).\\n```\\npublic class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        List<Character> list = new ArrayList<>();\\n        for (char c : s.toCharArray()) {\\n            list.add(c);\\n        }\\n        return helper(list);\\n    }\\n\\n    private int helper(List<Character> list) {\\n        if (list.size() <= 2) return 0;\\n        int beginning = 0;\\n        int end = list.size() - 1;\\n        // both ends are the same\\n        if (list.get(beginning) == list.get(end)) {\\n            list.remove(end);\\n            list.remove(beginning);\\n            return helper(list);\\n        }\\n        // find the last \\'a\\'\\n        int lastA = end;\\n        while (lastA > beginning) {\\n            if (list.get(lastA) == list.get(beginning)) break;\\n            lastA -= 1;\\n        }\\n        // find the first \\'b\\'\\n        int firstB = beginning;\\n        while (firstB < end) {\\n            if (list.get(firstB) == list.get(end)) break;\\n            firstB += 1;\\n        }\\n        if (firstB - beginning <= end - lastA) {\\n            list.remove(end);\\n            list.remove(firstB);\\n            return firstB - beginning + helper(list);\\n        } else {\\n            list.remove(lastA);\\n            list.remove(0);\\n            return end - lastA + helper(list);\\n        }\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        List<Character> list = new ArrayList<>();\\n        for (char c : s.toCharArray()) {\\n            list.add(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1832261,
                "title": "c-solution-without-swapping-uses-maths",
                "content": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome (string s) {\\n        int sum = 0;\\n        List<char> chars = s.ToCharArray ().ToList ();\\n        int b = 0, e = chars.Count - 1;\\n        while (b < e) {\\n            if (chars[b] != chars[e]) {\\n                int maxIx = -1;\\n                for (int i = e - 1; i > b; i--) {\\n                    if (chars[i] == chars[b]) {\\n                        maxIx = i;\\n                        break;\\n                    }\\n                }\\n                // check if this is a single letter that needs to be in the middle, \\n                // the way the maths works for the middle letter is that we are leaving it\\n                // to swap it in the end - in order to reduce unneccessary swaps\\n                // and in the end when everything is in place, the cost to swap this letter\\n                // and put in in the middle will be the cost to put in in the middle right now\\n                if (maxIx == -1) {\\n                    sum += (e - b) / 2;\\n                    chars.RemoveAt (b);\\n                } \\n                // the cost to swap the rightmost letter that\\'s the same with the current left\\n                // letter will be the endIndex - currentIndex\\n                else {\\n                    sum += e - maxIx;\\n                    chars.RemoveAt (maxIx);\\n                    chars.RemoveAt (b);\\n                }\\n            } else {\\n                chars.RemoveAt (e);\\n                chars.RemoveAt (b);\\n            }\\n            e = chars.Count - 1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome (string s) {\\n        int sum = 0;\\n        List<char> chars = s.ToCharArray ().ToList ();\\n        int b = 0, e = chars.Count - 1;\\n        while (b < e) {\\n            if (chars[b] != chars[e]) {\\n                int maxIx = -1;\\n                for (int i = e - 1; i > b; i--) {\\n                    if (chars[i] == chars[b]) {\\n                        maxIx = i;\\n                        break;\\n                    }\\n                }\\n                // check if this is a single letter that needs to be in the middle, \\n                // the way the maths works for the middle letter is that we are leaving it\\n                // to swap it in the end - in order to reduce unneccessary swaps\\n                // and in the end when everything is in place, the cost to swap this letter\\n                // and put in in the middle will be the cost to put in in the middle right now\\n                if (maxIx == -1) {\\n                    sum += (e - b) / 2;\\n                    chars.RemoveAt (b);\\n                } \\n                // the cost to swap the rightmost letter that\\'s the same with the current left\\n                // letter will be the endIndex - currentIndex\\n                else {\\n                    sum += e - maxIx;\\n                    chars.RemoveAt (maxIx);\\n                    chars.RemoveAt (b);\\n                }\\n            } else {\\n                chars.RemoveAt (e);\\n                chars.RemoveAt (b);\\n            }\\n            e = chars.Count - 1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823949,
                "title": "javascript-two-pointer",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minMovesToMakePalindrome = function(s) {\\n    let left = 0, right = s.length-1, ans = 0;\\n    \\n    \\n    function swapStr(str, first, last){\\n        return str.substr(0, first)\\n           + str[last]\\n           + str.substring(first+1, last)\\n           + str[first]\\n           + str.substr(last+1);\\n    }\\n    \\n    while (left < right) {\\n        let l = left, r = right;\\n        \\n        while (s[l] != s[r]) {\\n            r--;\\n        }\\n        \\n        if (l == r) {\\n            ans++;\\n            s = swapStr(s, r, r+1);\\n            continue;\\n        } else {\\n            while (r < right) {\\n                s = swapStr(s, r, r+1);\\n                ans++;\\n                r++;\\n            }   \\n        }\\n        left++;\\n        right--;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minMovesToMakePalindrome = function(s) {\\n    let left = 0, right = s.length-1, ans = 0;\\n    \\n    \\n    function swapStr(str, first, last){\\n        return str.substr(0, first)\\n           + str[last]\\n           + str.substring(first+1, last)\\n           + str[first]\\n           + str.substr(last+1);\\n    }\\n    \\n    while (left < right) {\\n        let l = left, r = right;\\n        \\n        while (s[l] != s[r]) {\\n            r--;\\n        }\\n        \\n        if (l == r) {\\n            ans++;\\n            s = swapStr(s, r, r+1);\\n            continue;\\n        } else {\\n            while (r < right) {\\n                s = swapStr(s, r, r+1);\\n                ans++;\\n                r++;\\n            }   \\n        }\\n        left++;\\n        right--;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822301,
                "title": "python-simple",
                "content": "Old school grinding:\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,N  = list(s), len(s)\\n        min_swaps = i = 0\\n        while i < N // 2:\\n            L, R = i, N - i - 1\\n            while L < R:\\n                if s[L] == s[R]: break\\n                else: R -= 1\\n            if L == R:\\n                s[L], s[L + 1] = s[L + 1], s[L]\\n                min_swaps += 1\\n            else:\\n                for j in range(R, N - L - 1):\\n                    s[j], s[j + 1] = s[j + 1], s[j]\\n                    min_swaps += 1\\n                i += 1\\n        return min_swaps\\n```\\nGreedy everyone else used\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, min_swaps = list(s), 0\\n        \\n        while s:\\n            first_occur_index = s.index(s[-1])\\n            if first_occur_index == len(s) - 1:\\n                min_swaps += first_occur_index // 2\\n            else:\\n                min_swaps += first_occur_index\\n                s.pop(first_occur_index)\\n                \\n            s.pop()\\n                                \\n        return min_swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,N  = list(s), len(s)\\n        min_swaps = i = 0\\n        while i < N // 2:\\n            L, R = i, N - i - 1\\n            while L < R:\\n                if s[L] == s[R]: break\\n                else: R -= 1\\n            if L == R:\\n                s[L], s[L + 1] = s[L + 1], s[L]\\n                min_swaps += 1\\n            else:\\n                for j in range(R, N - L - 1):\\n                    s[j], s[j + 1] = s[j + 1], s[j]\\n                    min_swaps += 1\\n                i += 1\\n        return min_swaps\\n```\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, min_swaps = list(s), 0\\n        \\n        while s:\\n            first_occur_index = s.index(s[-1])\\n            if first_occur_index == len(s) - 1:\\n                min_swaps += first_occur_index // 2\\n            else:\\n                min_swaps += first_occur_index\\n                s.pop(first_occur_index)\\n                \\n            s.pop()\\n                                \\n        return min_swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822181,
                "title": "c-two-pointers-greedy-algo-o-n-2",
                "content": "The idea is to consider two pointers, from left end and right end, to the middle.\\nWhenever there is a pair of the same letters, swap the right one towards the right end till it finds the correct position.\\nA special condition is that there might be a single letter on the left, which does not find its counterpart on the right. In this case, this letter should be moved to the middle.\\n\\nOne might wonder why we need to operate on the right one, but not the left one. It is equivalent to operate on the left one, and might result in a different result string though.\\n\\nTime complexity `O(N^2)`\\n```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), res = 0, i = 0;\\n        while(i < n / 2)\\n        {\\n            int l = i, r = n - l - 1;\\n            while(l < r)\\n            {\\n                if (s[l] == s[r])\\n                    break;\\n                --r;\\n            }\\n            if (l == r)\\n            {\\n\\t\\t\\t\\t// There is a single letter which should go to the middle.\\n                swap(s[l], s[l + 1]);\\n                ++res;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// Move the letter to the right till its correct position.\\n                for (int j = r; j < n - l - 1; ++j)\\n                {\\n                    swap(s[j], s[j + 1]);\\n                    ++res;\\n                }\\n                ++i;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), res = 0, i = 0;\\n        while(i < n / 2)\\n        {\\n            int l = i, r = n - l - 1;\\n            while(l < r)\\n            {\\n                if (s[l] == s[r])\\n                    break;\\n                --r;\\n            }\\n            if (l == r)\\n            {\\n\\t\\t\\t\\t// There is a single letter which should go to the middle.\\n                swap(s[l], s[l + 1]);\\n                ++res;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// Move the letter to the right till its correct position.\\n                for (int j = r; j < n - l - 1; ++j)\\n                {\\n                    swap(s[j], s[j + 1]);\\n                    ++res;\\n                }\\n                ++i;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822159,
                "title": "o-n-2-solution-greedy-approach-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\n\\t\\tint minMovesToMakePalindrome(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j= n-1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\tif(s[i] == s[j]){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint idx1 = -1;\\n\\t\\t\\t\\t\\tint idx2 = -1;\\n\\t\\t\\t\\t\\tfor(int k=i+1; k<j; k++){\\n\\t\\t\\t\\t\\t\\tif(s[k] == s[j]) {\\n\\t\\t\\t\\t\\t\\t\\tidx1 = k;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int k=j-1; k>i; k--){\\n\\t\\t\\t\\t\\t\\tif(s[k] == s[i]){\\n\\t\\t\\t\\t\\t\\t\\tidx2 = k;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(idx1 != -1 && abs(idx1 - i) < abs(idx2 - j)){\\n\\t\\t\\t\\t\\t\\tans += abs(idx1 - i);\\n\\n\\t\\t\\t\\t\\t\\tfor(int k = idx1; k>i; k--){\\n\\t\\t\\t\\t\\t\\t\\tswap(s[k], s[k-1]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tans += abs(idx2 - j);\\n\\t\\t\\t\\t\\t\\tfor(int k=idx2; k<j; k++){\\n\\t\\t\\t\\t\\t\\t\\tswap(s[k], s[k+1]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\n\\t\\tint minMovesToMakePalindrome(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j= n-1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\tif(s[i] == s[j]){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1822140,
                "title": "python-greedy-easy-and-clean-solution",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        left, right = 0, n-1\\n        res = 0\\n        while left < right:\\n            if s[left] != s[right]:\\n                lidx, ridx = left+1, right-1\\n                rdelta = 1\\n                while s[left] != s[ridx]:\\n                    ridx -= 1\\n                    rdelta += 1\\n                ldelta = 1\\n                while s[right] != s[lidx]:\\n                    lidx += 1\\n                    ldelta += 1\\n                if ldelta < rdelta:\\n                    for i in range(lidx,left,-1):\\n                        s[i-1],s[i] = s[i],s[i-1]\\n                    res += ldelta\\n                else:\\n                    for i in range(ridx,right):\\n                        s[i],s[i+1] = s[i+1],s[i]\\n                    res += rdelta\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        left, right = 0, n-1\\n        res = 0\\n        while left < right:\\n            if s[left] != s[right]:\\n                lidx, ridx = left+1, right-1\\n                rdelta = 1\\n                while s[left] != s[ridx]:\\n                    ridx -= 1\\n                    rdelta += 1\\n                ldelta = 1\\n                while s[right] != s[lidx]:\\n                    lidx += 1\\n                    ldelta += 1\\n                if ldelta < rdelta:\\n                    for i in range(lidx,left,-1):\\n                        s[i-1],s[i] = s[i],s[i-1]\\n                    res += ldelta\\n                else:\\n                    for i in range(ridx,right):\\n                        s[i],s[i+1] = s[i+1],s[i]\\n                    res += rdelta\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822077,
                "title": "explained-two-pointer-cpp-solution",
                "content": "```\\n// TWO- POINTER APPROACH\\n\\n// 1. traversed from the two ends and chose the best possible option out of the characters  which has its count left greater than equal to 2 \\n\\n// 2. calculated the no. of swaps\\n\\n// Please do upvote if u like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    int minMovesToMakePalindrome(string s) {\\n        ll i=0,j=s.length()-1;\\n        map<char,ll>m;\\n        for(ll i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        ll ans=0;\\n        ll n=s.length()/2;\\n        while(i<n){\\n            ll i1=-1,i2=-1;ll c=INT_MAX;\\n            for(auto x:m){\\n                if(x.second>=2){\\n                    ll a=-1,b=-1;\\n                    for(ll z=i;z<s.length();z++){\\n                        if(s[z]==x.first){a=z; break;}\\n                    }\\n                    for(ll z=j;z>=0;z--){\\n                        if(s[z]==x.first){b=z; break;}\\n                    }\\n                    if(abs(a-i)+abs(j-b)<c){i1=a; i2=b; c=(a-i)+(j-b);}\\n                }\\n            }\\n            m[s[i1]]--; m[s[i1]]--;\\n            while(i1>i){\\n                //cout<<i1<<\" \";\\n                swap(s[i1],s[i1-1]);\\n                i1--;\\n                ans++;\\n            }\\n            cout<<endl;\\n            while(i2<j){\\n                // cout<<i2<<\"    \";\\n                swap(s[i2],s[i2+1]);\\n                i2++;\\n                ans++;\\n            }\\n            i++; j--;\\n        }\\n        //cout<<s<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n// TWO- POINTER APPROACH\\n\\n// 1. traversed from the two ends and chose the best possible option out of the characters  which has its count left greater than equal to 2 \\n\\n// 2. calculated the no. of swaps\\n\\n// Please do upvote if u like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    int minMovesToMakePalindrome(string s) {\\n        ll i=0,j=s.length()-1;\\n        map<char,ll>m;\\n        for(ll i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        ll ans=0;\\n        ll n=s.length()/2;\\n        while(i<n){\\n            ll i1=-1,i2=-1;ll c=INT_MAX;\\n            for(auto x:m){\\n                if(x.second>=2){\\n                    ll a=-1,b=-1;\\n                    for(ll z=i;z<s.length();z++){\\n                        if(s[z]==x.first){a=z; break;}\\n                    }\\n                    for(ll z=j;z>=0;z--){\\n                        if(s[z]==x.first){b=z; break;}\\n                    }\\n                    if(abs(a-i)+abs(j-b)<c){i1=a; i2=b; c=(a-i)+(j-b);}\\n                }\\n            }\\n            m[s[i1]]--; m[s[i1]]--;\\n            while(i1>i){\\n                //cout<<i1<<\" \";\\n                swap(s[i1],s[i1-1]);\\n                i1--;\\n                ans++;\\n            }\\n            cout<<endl;\\n            while(i2<j){\\n                // cout<<i2<<\"    \";\\n                swap(s[i2],s[i2+1]);\\n                i2++;\\n                ans++;\\n            }\\n            i++; j--;\\n        }\\n        //cout<<s<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1822032,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = [i for i in s]\\n        start = 0\\n        end = len(s)-1\\n        count = 0\\n        while start < end:\\n            if s[start] != s[end]:\\n                i = start\\n                j = end\\n                j_f = i_f = False\\n                ii = jj = -1\\n                while i < end:\\n                    if s[start] == s[j]:\\n                        j_f = True\\n                        jj = j\\n                        break\\n                    elif s[end] == s[i]:\\n                        i_f = True\\n                        ii = i\\n                        break\\n                    count += 1\\n                    i += 1\\n                    j -= 1\\n                if i_f:\\n                    for i in range(ii, start, -1):\\n                        s[i] = s[i-1]\\n                else:\\n                    for i in range(jj, end):\\n                        s[i] = s[i+1]\\n            start += 1\\n            end -= 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = [i for i in s]\\n        start = 0\\n        end = len(s)-1\\n        count = 0\\n        while start < end:\\n            if s[start] != s[end]:\\n                i = start\\n                j = end\\n                j_f = i_f = False\\n                ii = jj = -1\\n                while i < end:\\n                    if s[start] == s[j]:\\n                        j_f = True\\n                        jj = j\\n                        break\\n                    elif s[end] == s[i]:\\n                        i_f = True\\n                        ii = i\\n                        break\\n                    count += 1\\n                    i += 1\\n                    j -= 1\\n                if i_f:\\n                    for i in range(ii, start, -1):\\n                        s[i] = s[i-1]\\n                else:\\n                    for i in range(jj, end):\\n                        s[i] = s[i+1]\\n            start += 1\\n            end -= 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995630,
                "title": "c-nlogn-solution",
                "content": "You can copy code for counting inversion in nlon\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int getNumOfInversions(vector<int>& A) {\\n        int N = A.size();\\n        if (N <= 1) {\\n            return 0;\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sortList;\\n        int result = 0;\\n    \\n        // Heapsort, O(N*log(N))\\n        for (int i = 0; i < N; i++) {\\n            sortList.push(make_pair(A[i], i));\\n        }\\n    \\n        // Create a sorted list of indexes\\n        vector<int> x;\\n        while (!sortList.empty()) {\\n    \\n            // O(log(N))\\n            int v = sortList.top().first;\\n            int i = sortList.top().second;\\n            sortList.pop();\\n    \\n            // Find the current minimum\\'s index\\n            // the index y can represent how many minimums on the left\\n            int y = upper_bound(x.begin(), x.end(), i) - x.begin();\\n    \\n            // i can represent how many elements on the left\\n            // i - y can find how many bigger nums on the left\\n            result += i - y;\\n    \\n            x.insert(upper_bound(x.begin(), x.end(), i), i);\\n        }\\n    \\n        return result;\\n    }\\n    ll get_ans(string s1,string s2)\\n    {\\n        int n = (int)s1.size();\\n        vector<vector<int>> pos(26);\\n        for(int i=0;i<n;i++){\\n            pos[s2[i]-\\'a\\'].push_back(i);\\n        }\\n        vector<int> p(n);\\n        for(int i=n-1;i>=0;i--){\\n            p[i]=pos[s1[i]-\\'a\\'].back();\\n            pos[s1[i]-\\'a\\'].pop_back();\\n        }\\n        return getNumOfInversions(p);\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        int n=(int)s.size();\\n\\t\\tstring s1 = s;\\n\\t\\treverse(s1.begin(),s1.end());\\n\\t\\treturn get_ans(s,s1)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int getNumOfInversions(vector<int>& A) {\\n        int N = A.size();\\n        if (N <= 1) {\\n            return 0;\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sortList;\\n        int result = 0;\\n    \\n        // Heapsort, O(N*log(N))\\n        for (int i = 0; i < N; i++) {\\n            sortList.push(make_pair(A[i], i));\\n        }\\n    \\n        // Create a sorted list of indexes\\n        vector<int> x;\\n        while (!sortList.empty()) {\\n    \\n            // O(log(N))\\n            int v = sortList.top().first;\\n            int i = sortList.top().second;\\n            sortList.pop();\\n    \\n            // Find the current minimum\\'s index\\n            // the index y can represent how many minimums on the left\\n            int y = upper_bound(x.begin(), x.end(), i) - x.begin();\\n    \\n            // i can represent how many elements on the left\\n            // i - y can find how many bigger nums on the left\\n            result += i - y;\\n    \\n            x.insert(upper_bound(x.begin(), x.end(), i), i);\\n        }\\n    \\n        return result;\\n    }\\n    ll get_ans(string s1,string s2)\\n    {\\n        int n = (int)s1.size();\\n        vector<vector<int>> pos(26);\\n        for(int i=0;i<n;i++){\\n            pos[s2[i]-\\'a\\'].push_back(i);\\n        }\\n        vector<int> p(n);\\n        for(int i=n-1;i>=0;i--){\\n            p[i]=pos[s1[i]-\\'a\\'].back();\\n            pos[s1[i]-\\'a\\'].pop_back();\\n        }\\n        return getNumOfInversions(p);\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        int n=(int)s.size();\\n\\t\\tstring s1 = s;\\n\\t\\treverse(s1.begin(),s1.end());\\n\\t\\treturn get_ans(s,s1)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949565,
                "title": "easy-to-understand",
                "content": "# Intuition\\ntwo pointer approach: inititalize two pointers to the start of the array and the end of the array respectively, and then check if they are the same, if they arent, move the right backwards and find the same charater in the array, and swap the adjacent characters till it reaches the correct spot, performing a final swap in the middle of the array at the end while ensure the correct answer \\n\\n# Approach\\n1) convert it to character array\\n2) use count variable to track the number of swaps\\n3) initialise two pointers let and right, and also a \"find\" variable to find the character which is same as the character in the position \"left\" \\n4) after finding the character, swap it with adjacent characters until you reach the right index.\\n5) perform these oprations until you reach the middle of the array, at the middle of the array, swap the adjacent elements to get the required answer\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count=0;\\n        char[] charArray=s.toCharArray();\\n        int right=charArray.length-1;\\n        int left=0;\\n        int find=0;\\n        while(left<right){\\n            find=right;// the find variable to find the same character as left\\n            if(charArray[left]==charArray[right]){\\n                left++;// if at the right position, move the pointers\\n                right--;\\n            }else{\\n                \\n                \\n                while(charArray[find]!=charArray[left]){\\n                    find--;// move the find pointer backwards until you find the right spot\\n                }\\n                if(left==find){\\n                    swap(charArray,find,find+1);\\n                    count++;continue;// for middle of the array\\n                }else{\\n                while((find)<right){\\n                    swap(charArray,find,find+1);\\n                    find+=1;count+=1;// for moving the find variable value to the correct spot by swapping adjacent element until it reaches the \"right\" index. update he counter for every swap                }}\\n                \\n            }\\n            \\n        }\\n        return count;\\n        \\n        \\n    }\\n    public void swap(char[] c,int a,int b){\\n        char temp=c[a];\\n        c[a]=c[b];\\n        c[b]=temp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count=0;\\n        char[] charArray=s.toCharArray();\\n        int right=charArray.length-1;\\n        int left=0;\\n        int find=0;\\n        while(left<right){\\n            find=right;// the find variable to find the same character as left\\n            if(charArray[left]==charArray[right]){\\n                left++;// if at the right position, move the pointers\\n                right--;\\n            }else{\\n                \\n                \\n                while(charArray[find]!=charArray[left]){\\n                    find--;// move the find pointer backwards until you find the right spot\\n                }\\n                if(left==find){\\n                    swap(charArray,find,find+1);\\n                    count++;continue;// for middle of the array\\n                }else{\\n                while((find)<right){\\n                    swap(charArray,find,find+1);\\n                    find+=1;count+=1;// for moving the find variable value to the correct spot by swapping adjacent element until it reaches the \"right\" index. update he counter for every swap                }}\\n                \\n            }\\n            \\n        }\\n        return count;\\n        \\n        \\n    }\\n    public void swap(char[] c,int a,int b){\\n        char temp=c[a];\\n        c[a]=c[b];\\n        c[b]=temp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843056,
                "title": "greedy-approach",
                "content": "# Intuition\\nGreedy approach -> \\n    At each instance we can do following things: \\n    1. keep left most character as-it-is, and make some moves to move other equivalent character to right. \\n    2. keep right most character as-it-is, and make some moves to move other equivalent character to left. \\n    Choose greedy solution which would needs to minimum moves to make left-most and right-most characters same. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFor example : \\nconsider - \\nl--e--t--e--l--t\\n0-1--2-3--4-5 (indexes)\\n to make left and right chars same, we have following 2 options\\n1. move l (at index 4) to 5th index - with move count 1\\n2. move t (at index 2) to 0th index - with move count 2 ( we needed 2 swaps).\\n\\nFrom above 2 possibilities , we can chose first one (as it has lower moves) & repeat same for subproblem subproblem \\n**e t e t**\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        char[] s = str.toCharArray();\\n        return minMovesToMakePalindrome(s,0, s.length-1);\\n    }\\n\\n    int minMovesToMakePalindrome(char[] s, int left, int right){\\n\\n        while(left < right && s[left]==s[right]){\\n            left++;\\n            right--;\\n        }\\n\\n        if(left>=right) return 0;\\n\\n        int l = left+1;\\n        while(l < right && s[l]!=s[right]) l++;\\n\\n        int r = right-1;\\n        while(left < r && s[r]!=s[left]) r--;\\n\\n        int leftMoves = l-left;\\n        int rightMoves = right-r;  \\n\\n        int currentMoves = 0; \\n\\n        if(leftMoves < rightMoves){\\n            currentMoves = leftMoves;\\n            l--;\\n            while(left<=l){\\n                swap(s, l, l+1);\\n                l--;\\n            }\\n        }else{\\n            currentMoves = rightMoves;\\n            r++;\\n            while(r<=right){\\n                swap(s, r, r-1);\\n                r++;\\n            }\\n        }\\n\\n        return currentMoves + minMovesToMakePalindrome(s, left+1, right-1);\\n    }\\n\\n    public void swap(char[] s, int i1, int i2){\\n        char temp = s[i1];\\n        s[i1] = s[i2];\\n        s[i2] = temp; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        char[] s = str.toCharArray();\\n        return minMovesToMakePalindrome(s,0, s.length-1);\\n    }\\n\\n    int minMovesToMakePalindrome(char[] s, int left, int right){\\n\\n        while(left < right && s[left]==s[right]){\\n            left++;\\n            right--;\\n        }\\n\\n        if(left>=right) return 0;\\n\\n        int l = left+1;\\n        while(l < right && s[l]!=s[right]) l++;\\n\\n        int r = right-1;\\n        while(left < r && s[r]!=s[left]) r--;\\n\\n        int leftMoves = l-left;\\n        int rightMoves = right-r;  \\n\\n        int currentMoves = 0; \\n\\n        if(leftMoves < rightMoves){\\n            currentMoves = leftMoves;\\n            l--;\\n            while(left<=l){\\n                swap(s, l, l+1);\\n                l--;\\n            }\\n        }else{\\n            currentMoves = rightMoves;\\n            r++;\\n            while(r<=right){\\n                swap(s, r, r-1);\\n                r++;\\n            }\\n        }\\n\\n        return currentMoves + minMovesToMakePalindrome(s, left+1, right-1);\\n    }\\n\\n    public void swap(char[] s, int i1, int i2){\\n        char temp = s[i1];\\n        s[i1] = s[i2];\\n        s[i2] = temp; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826741,
                "title": "kotlin-two-pointers-solution",
                "content": "# Intuition\\nKotlin two pointers solution\\n\\n# Approach\\ntwo pointers solution\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun minMovesToMakePalindrome(str: String): Int {\\n        var ans = 0\\n        var s = StringBuilder(str)\\n\\n        while (s.length > 1) {\\n            if (s[0] == s[s.length-1]) {\\n                s = s.deleteCharAt(0)\\n                s = s.deleteCharAt(s.length-1)\\n                continue\\n            }\\n            for (i in s.length-1 downTo 0) {\\n                if (s[0] == s[i] && i == 0) {\\n                    s = s.deleteCharAt(0)\\n                    ans += (s.length/2).toInt()\\n                    break\\n                } else if (s[0] == s[i]) {\\n                    ans += (s.length - i - 1)\\n                    s = s.deleteCharAt(0)\\n                    s = s.deleteCharAt(i-1)\\n                    break\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    fun minMovesToMakePalindrome(str: String): Int {\\n        var ans = 0\\n        var s = StringBuilder(str)\\n\\n        while (s.length > 1) {\\n            if (s[0] == s[s.length-1]) {\\n                s = s.deleteCharAt(0)\\n                s = s.deleteCharAt(s.length-1)\\n                continue\\n            }\\n            for (i in s.length-1 downTo 0) {\\n                if (s[0] == s[i] && i == 0) {\\n                    s = s.deleteCharAt(0)\\n                    ans += (s.length/2).toInt()\\n                    break\\n                } else if (s[0] == s[i]) {\\n                    ans += (s.length - i - 1)\\n                    s = s.deleteCharAt(0)\\n                    s = s.deleteCharAt(i-1)\\n                    break\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795700,
                "title": "c-easy-o-n-2-two-pointer-in-place-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int left = 0, right = s.length()-1, center = -1, swaps = 0;\\n        while (left<right) {\\n            if (s[left] == s[right]) {\\n                left++;\\n                right--;\\n                continue;\\n            }\\n            int index=-1;\\n            for (int i=left+1;i<right;i++) {\\n                if (s[i] == s[right]) {\\n                    index=i;\\n                    break;\\n                }\\n            }\\n            if (index == -1) {\\n                center = right;\\n                right--;\\n                continue;\\n            }\\n            for (int i=index-1;i>=left;i--) {\\n                swap(s[i], s[i+1]);\\n                swaps++;\\n            } \\n            left++;\\n            right--;\\n        }\\n        if (center!=-1) {\\n            swaps+=center-s.length()/2;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int left = 0, right = s.length()-1, center = -1, swaps = 0;\\n        while (left<right) {\\n            if (s[left] == s[right]) {\\n                left++;\\n                right--;\\n                continue;\\n            }\\n            int index=-1;\\n            for (int i=left+1;i<right;i++) {\\n                if (s[i] == s[right]) {\\n                    index=i;\\n                    break;\\n                }\\n            }\\n            if (index == -1) {\\n                center = right;\\n                right--;\\n                continue;\\n            }\\n            for (int i=index-1;i>=left;i--) {\\n                swap(s[i], s[i+1]);\\n                swaps++;\\n            } \\n            left++;\\n            right--;\\n        }\\n        if (center!=-1) {\\n            swaps+=center-s.length()/2;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767315,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n  =s.size();\\n        int lt = 0 , rt = n-1, ans = 0;\\n        while(lt<rt){\\n            int l = lt;\\n            int r = rt;\\n            while(s[l] != s[r])\\n            r--;\\n            if(l==r){\\n                swap(s[r], s[r+1]);\\n                ans ++;\\n                continue;\\n            }\\n            else{\\n                while(r<rt){\\n                    swap(s[r], s[r+1]);\\n                    ans++; \\n                    r++;\\n\\n                }\\n            }\\n            lt++;\\n            rt--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n  =s.size();\\n        int lt = 0 , rt = n-1, ans = 0;\\n        while(lt<rt){\\n            int l = lt;\\n            int r = rt;\\n            while(s[l] != s[r])\\n            r--;\\n            if(l==r){\\n                swap(s[r], s[r+1]);\\n                ans ++;\\n                continue;\\n            }\\n            else{\\n                while(r<rt){\\n                    swap(s[r], s[r+1]);\\n                    ans++; \\n                    r++;\\n\\n                }\\n            }\\n            lt++;\\n            rt--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746793,
                "title": "optimal-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729975,
                "title": "straightforward-greedy-algorithm-in-python-beating-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn each turn, it is necessary to match the first character `s[0]` and the last charactor `s[-1]` of the string `s`. Do nothing if the first and the last ones already match (i.e., `s[0] == s[-1]`). Otherwise, my greedy approach determines to replace the first or the last one by considering the cost. The cost to replace the first character `s[0]` is its distance to the leftmost occurrence of `s[-1]`; the cost to replace the last character `s[-1]` is its distance to the rightmost occurrence of `s[0]`. Pick up the choice with the lower cost and trim the first and the last characters from the string. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, where $$n$$ is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The input is $$O(n)$$. Only constant extra memeory is used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                l, r = s.find(s[-1]), s.rfind(s[0])\\n                if l < len(s) - r - 1: \\n                    ans += l\\n                    s = s[:l] + s[l+1:-1]\\n                else:\\n                    ans += len(s) - r - 1\\n                    s = s[1:r] + s[r+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                l, r = s.find(s[-1]), s.rfind(s[0])\\n                if l < len(s) - r - 1: \\n                    ans += l\\n                    s = s[:l] + s[l+1:-1]\\n                else:\\n                    ans += len(s) - r - 1\\n                    s = s[1:r] + s[r+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725253,
                "title": "straightforward-brute-force-in-python-beating-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn each turn, it is necessary to match the first character `s[0]` and the last charactor `s[-1]` of the string `s`. Do nothing if the first and the last ones already match (i.e., `s[0] == s[-1]`). Otherwise, my greedy approach determines to replace the first or the last one by considering the cost. The cost to replace the first character `s[0]` is its distance to the leftmost occurrence of `s[-1]`; the cost to replace the last character `s[-1]` is its distance to the rightmost occurrence of `s[0]`. Pick up the choice with the lower cost and trim the first and the last characters from the string. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, where $$n$$ is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The input is $$O(n)$$. Only constant extra memeory is used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        l, r = 0, len(s)-1\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                nl, nr = s.find(s[-1]), s.rfind(s[0])\\n                if nl < len(s) - nr - 1: \\n                    ans += nl\\n                    s = s[:nl] + s[nl+1:-1]\\n                else:\\n                    ans += len(s) - nr - 1\\n                    s = s[1:nr] + s[nr+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        l, r = 0, len(s)-1\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                nl, nr = s.find(s[-1]), s.rfind(s[0])\\n                if nl < len(s) - nr - 1: \\n                    ans += nl\\n                    s = s[:nl] + s[nl+1:-1]\\n                else:\\n                    ans += len(s) - nr - 1\\n                    s = s[1:nr] + s[nr+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712720,
                "title": "c-two-pointer-approach-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int ans=0;\\n        while(j>=i)\\n        {\\n            if(s[i]==s[j]) \\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                int ct=0;\\n                int idx=-1;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    if(s[k]==s[j]) \\n                    {\\n                        idx=k;\\n                        ct=k-i;\\n                        break;\\n                    }\\n                }\\n               // cout<<i<<\" \"<<j<<\\n                int ct1=0;\\n                int idx2=-1;\\n                for(int k=j;k>=i;k--)\\n                {\\n                    if(s[k]==s[i])\\n                    {\\n                        idx2=k;\\n                        ct1=j-k;\\n                        break;\\n                    }\\n                }\\n                if(ct<=ct1)\\n                {\\n                    ans+=ct;\\n                    while(idx>i)\\n                    {\\n                        swap(s[idx],s[idx-1]);\\n                        idx--;\\n                    }\\n                }\\n                else\\n                {\\n                    ans+=ct1;\\n                    while(idx2<j)\\n                    {\\n                        swap(s[idx2],s[idx2+1]);\\n                        idx2++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int ans=0;\\n        while(j>=i)\\n        {\\n            if(s[i]==s[j]) \\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                int ct=0;\\n                int idx=-1;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    if(s[k]==s[j]) \\n                    {\\n                        idx=k;\\n                        ct=k-i;\\n                        break;\\n                    }\\n                }\\n               // cout<<i<<\" \"<<j<<\\n                int ct1=0;\\n                int idx2=-1;\\n                for(int k=j;k>=i;k--)\\n                {\\n                    if(s[k]==s[i])\\n                    {\\n                        idx2=k;\\n                        ct1=j-k;\\n                        break;\\n                    }\\n                }\\n                if(ct<=ct1)\\n                {\\n                    ans+=ct;\\n                    while(idx>i)\\n                    {\\n                        swap(s[idx],s[idx-1]);\\n                        idx--;\\n                    }\\n                }\\n                else\\n                {\\n                    ans+=ct1;\\n                    while(idx2<j)\\n                    {\\n                        swap(s[idx2],s[idx2+1]);\\n                        idx2++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3686481,
                "title": "simple-c-two-pointers-greedy-solution",
                "content": "```\\nint solve( string &s , int i , int j )\\n    {\\n        if( i >= j ) return 0 ;\\n        \\n        if( s[i] == s[j] )\\n        {\\n            return solve( s , i+1 , j-1 ) ;\\n        }\\n        \\n        int ans = INT_MAX ;\\n        \\n        int p1 = i + 1 ;\\n        int p2 = j - 1 ;\\n        \\n        \\n        while( p1 < j  && s[p1] != s[j] )\\n        {\\n            p1++ ;\\n        }\\n        \\n        while( p2 > i  && s[p2] != s[i] )\\n        {\\n            p2-- ;\\n        }\\n        \\n        int temp = 0 ;\\n        \\n        if( p1 < j && p2 > i )\\n        {\\n            if( (p1 - i ) <= ( j - p2 ) )\\n            {\\n                temp = 1 ;\\n            }\\n            else\\n            {\\n                temp = 2 ;\\n            }\\n        }\\n        else if( p1 < j )\\n        {\\n            temp = 1 ;\\n            \\n        }\\n        else if( p2 > i )\\n        {\\n            temp = 2 ;\\n        }\\n        \\n        if(temp == 1 )\\n        {\\n            ans = p1 - i ;\\n            while( p1 > i )\\n            {\\n                swap( s[p1] , s[p1-1] ) ;\\n                p1-- ;\\n            }\\n            \\n        }\\n        else if( temp == 2 )\\n        {\\n            ans = j - p2 ;\\n            while( p2 < j )\\n            {\\n                swap( s[p2] , s[p2 + 1] ) ;\\n                p2++ ;\\n            }\\n            \\n        }\\n        \\n        return ans + solve( s , i+1 , j-1 ) ;\\n        \\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve( s , 0 , s.size()-1 ) ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint solve( string &s , int i , int j )\\n    {\\n        if( i >= j ) return 0 ;\\n        \\n        if( s[i] == s[j] )\\n        {\\n            return solve( s , i+1 , j-1 ) ;\\n        }\\n        \\n        int ans = INT_MAX ;\\n        \\n        int p1 = i + 1 ;\\n        int p2 = j - 1 ;\\n        \\n        \\n        while( p1 < j  && s[p1] != s[j] )\\n        {\\n            p1++ ;\\n        }\\n        \\n        while( p2 > i  && s[p2] != s[i] )\\n        {\\n            p2-- ;\\n        }\\n        \\n        int temp = 0 ;\\n        \\n        if( p1 < j && p2 > i )\\n        {\\n            if( (p1 - i ) <= ( j - p2 ) )\\n            {\\n                temp = 1 ;\\n            }\\n            else\\n            {\\n                temp = 2 ;\\n            }\\n        }\\n        else if( p1 < j )\\n        {\\n            temp = 1 ;\\n            \\n        }\\n        else if( p2 > i )\\n        {\\n            temp = 2 ;\\n        }\\n        \\n        if(temp == 1 )\\n        {\\n            ans = p1 - i ;\\n            while( p1 > i )\\n            {\\n                swap( s[p1] , s[p1-1] ) ;\\n                p1-- ;\\n            }\\n            \\n        }\\n        else if( temp == 2 )\\n        {\\n            ans = j - p2 ;\\n            while( p2 < j )\\n            {\\n                swap( s[p2] , s[p2 + 1] ) ;\\n                p2++ ;\\n            }\\n            \\n        }\\n        \\n        return ans + solve( s , i+1 , j-1 ) ;\\n        \\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve( s , 0 , s.size()-1 ) ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641189,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string str) {\\n    int size=str.size()-1;\\n    int count=0;\\n    int left=0;\\n    int right=size;\\n    while(left<right){\\n        int l=left,r=right;\\n        while(str[r]!=str[l]) r--;\\n        if(l==r){\\n            swap(str[r],str[r+1]);\\n            count++;\\n            continue;\\n        }\\n        else{\\n            while(r<right){\\n                swap(str[r],str[r+1]);\\n                r++;\\n                count++;\\n            }\\n        }\\n        left++;\\n        right--;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string str) {\\n    int size=str.size()-1;\\n    int count=0;\\n    int left=0;\\n    int right=size;\\n    while(left<right){\\n        int l=left,r=right;\\n        while(str[r]!=str[l]) r--;\\n        if(l==r){\\n            swap(str[r],str[r+1]);\\n            count++;\\n            continue;\\n        }\\n        else{\\n            while(r<right){\\n                swap(str[r],str[r+1]);\\n                r++;\\n                count++;\\n            }\\n        }\\n        left++;\\n        right--;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592644,
                "title": "minimum-number-of-moves-to-make-palindrome-2-pointers",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string &s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n          if(i==j)break;\\n          if(s[i]!=s[j]){\\n            size_t found=s.find(s[j]);\\n            if(found == j){\\n              int k=j;\\n              for ( k = j; k > i ; k--) {\\n                /* code */\\n                if(s[k]==s[i])break;\\n                \\n              }\\n              ans += j-k;\\n              s.erase(k,1);\\n              s.erase(i,1);\\n              j-=2;\\n              \\n            }\\n            else{ \\n              ans+=found - i;\\n              s.erase(j,1);\\n              s.erase(found,1);\\n              j-=2;\\n            }\\n            \\n          }\\n          else {\\n            s.erase(j,1);\\n            s.erase(i,1);\\n            j-=2;\\n            \\n          }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string &s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n          if(i==j)break;\\n          if(s[i]!=s[j]){\\n            size_t found=s.find(s[j]);\\n            if(found == j){\\n              int k=j;\\n              for ( k = j; k > i ; k--) {\\n                /* code */\\n                if(s[k]==s[i])break;\\n                \\n              }\\n              ans += j-k;\\n              s.erase(k,1);\\n              s.erase(i,1);\\n              j-=2;\\n              \\n            }\\n            else{ \\n              ans+=found - i;\\n              s.erase(j,1);\\n              s.erase(found,1);\\n              j-=2;\\n            }\\n            \\n          }\\n          else {\\n            s.erase(j,1);\\n            s.erase(i,1);\\n            j-=2;\\n            \\n          }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551712,
                "title": "easy-c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing two pointer approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing simple two pointer approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i =0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }else if(s[i]!=s[j]){\\n                int l = i;\\n                int r =  j;\\n                \\n                while(s[i]!=s[r]){\\n                    r--;\\n                }\\n                int val1 =j-r;\\n                while(s[l]!=s[j]){\\n                    l++;\\n                }\\n                int val2 =l-i;\\n                if(val1<=val2){\\n                    while(r<j){\\n                        swap(s[r],s[r+1]);\\n                        r++;\\n                    }\\n                }else{\\n                    while(l>i){\\n                        swap(s[l],s[l-1]);\\n                        l--;\\n                    }\\n                }\\n                ans+=min(val1,val2);\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//please Upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i =0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }else if(s[i]!=s[j]){\\n                int l = i;\\n                int r =  j;\\n                \\n                while(s[i]!=s[r]){\\n                    r--;\\n                }\\n                int val1 =j-r;\\n                while(s[l]!=s[j]){\\n                    l++;\\n                }\\n                int val2 =l-i;\\n                if(val1<=val2){\\n                    while(r<j){\\n                        swap(s[r],s[r+1]);\\n                        r++;\\n                    }\\n                }else{\\n                    while(l>i){\\n                        swap(s[l],s[l-1]);\\n                        l--;\\n                    }\\n                }\\n                ans+=min(val1,val2);\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//please Upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546515,
                "title": "greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- check 2 cases\\n- 1 only one character\\n- 2 there are 2 characters\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2), while s takes n, index takes n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, res = list(s), 0\\n        while s:\\n            i = s.index(s[-1])\\n            # if there is only 1 character at the end, find moves, pop it only\\n            if i == len(s) - 1: \\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i) # pop from the left first, after that, pop from the right\\n            s.pop() # pop from the right\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, res = list(s), 0\\n        while s:\\n            i = s.index(s[-1])\\n            # if there is only 1 character at the end, find moves, pop it only\\n            if i == len(s) - 1: \\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i) # pop from the left first, after that, pop from the right\\n            s.pop() # pop from the right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458939,
                "title": "intuitive-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem we just need to think for the end positions which item will be best to swap with minimun swaps. For example, if we have string \"aaccbb\", we need to think that which operation will result into minimum swaps: \\n\\n1) swapping a with nearest b \\n    OR\\n2) swapping b with nearest a \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        first = 0\\n        last = len(s)-1\\n        totalSwaps = 0\\n        s = list(s)\\n                    \\n        def swapsRequired(left, right, direction):\\n            if direction:\\n                closestIdx = right\\n                swapWith = s[right]\\n                for i in range(right-1, left,-1):\\n                    if s[i] == swapWith:\\n                        closestIdx = min(closestIdx, i)\\n                return (closestIdx-left, closestIdx)\\n\\n            else:\\n                closestIdx = left\\n                swapWith = s[left]\\n                for i in range(left+1, right):\\n                    if s[i] == swapWith:\\n                        closestIdx = max(i, closestIdx)\\n                return (right - closestIdx, closestIdx)\\n\\n        while first < last:\\n            if s[first] == s[last]:\\n                first += 1\\n                last -= 1\\n                continue\\n            leftSwap, leftIdx = swapsRequired(first, last, 1)\\n            rightSwap, rightIdx = swapsRequired(first, last, 0)\\n            if leftSwap < rightSwap:\\n                while first < leftIdx:\\n                    s[leftIdx], s[leftIdx-1] = s[leftIdx-1], s[leftIdx]\\n                    leftIdx -= 1\\n            else:\\n                while rightIdx < last:\\n                    s[rightIdx], s[rightIdx+1] = s[rightIdx+1], s[rightIdx]\\n                    rightIdx += 1\\n            totalSwaps += min(leftSwap, rightSwap)\\n            first += 1\\n            last -= 1   \\n\\n        return totalSwaps           \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        first = 0\\n        last = len(s)-1\\n        totalSwaps = 0\\n        s = list(s)\\n                    \\n        def swapsRequired(left, right, direction):\\n            if direction:\\n                closestIdx = right\\n                swapWith = s[right]\\n                for i in range(right-1, left,-1):\\n                    if s[i] == swapWith:\\n                        closestIdx = min(closestIdx, i)\\n                return (closestIdx-left, closestIdx)\\n\\n            else:\\n                closestIdx = left\\n                swapWith = s[left]\\n                for i in range(left+1, right):\\n                    if s[i] == swapWith:\\n                        closestIdx = max(i, closestIdx)\\n                return (right - closestIdx, closestIdx)\\n\\n        while first < last:\\n            if s[first] == s[last]:\\n                first += 1\\n                last -= 1\\n                continue\\n            leftSwap, leftIdx = swapsRequired(first, last, 1)\\n            rightSwap, rightIdx = swapsRequired(first, last, 0)\\n            if leftSwap < rightSwap:\\n                while first < leftIdx:\\n                    s[leftIdx], s[leftIdx-1] = s[leftIdx-1], s[leftIdx]\\n                    leftIdx -= 1\\n            else:\\n                while rightIdx < last:\\n                    s[rightIdx], s[rightIdx+1] = s[rightIdx+1], s[rightIdx]\\n                    rightIdx += 1\\n            totalSwaps += min(leftSwap, rightSwap)\\n            first += 1\\n            last -= 1   \\n\\n        return totalSwaps           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452962,
                "title": "python-readable-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy idea.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe check the leftmost and rightmost characters, if they are equal, pop these two out. Otherwise, we examine the index of the first character equal rightmost and the index of last character equal leftmost. The SMALLEST should be the steps we move. It is where greedy works.\\n\\nPop out these two characters and do the above again, until no more than one character left.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        temp = [_ for _ in s]\\n        ans = 0\\n        while len(temp) > 1:\\n            if temp[0] == temp[-1]:\\n                temp.pop(0)\\n                temp.pop()\\n            else:\\n                left,right = temp[0],temp[-1]\\n                a,b = -1,-1\\n                for i in range(len(temp)):\\n                    if temp[i] == right:\\n                        a = i\\n                        break\\n                for j in range(len(temp)):\\n                    if temp[~j] == left:\\n                        b = j\\n                        break\\n                if a < b:\\n                    ans += a\\n                    temp.pop(a)\\n                    temp.pop()\\n                else:\\n                    ans += b\\n                    temp.pop(~b)\\n                    temp.pop(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        temp = [_ for _ in s]\\n        ans = 0\\n        while len(temp) > 1:\\n            if temp[0] == temp[-1]:\\n                temp.pop(0)\\n                temp.pop()\\n            else:\\n                left,right = temp[0],temp[-1]\\n                a,b = -1,-1\\n                for i in range(len(temp)):\\n                    if temp[i] == right:\\n                        a = i\\n                        break\\n                for j in range(len(temp)):\\n                    if temp[~j] == left:\\n                        b = j\\n                        break\\n                if a < b:\\n                    ans += a\\n                    temp.pop(a)\\n                    temp.pop()\\n                else:\\n                    ans += b\\n                    temp.pop(~b)\\n                    temp.pop(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444737,
                "title": "simple-2-pointer-algorithm-simple-easy-specially-designed-for-beginner-s-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            if(s[i]!=s[n-i-1]){\\n                // we have to do something peter \\n                //we have to find in the range (i+1,n-i-1);\\n                char ch = s[i];\\n                int idx = -1;\\n                for(int j = n-i-1;j>i;j--){\\n                    if(s[j]==ch){\\n                        // find the nearest character\\n                        idx = j;\\n                        break;\\n                    }\\n                }\\n                char ch2 = s[n-i-1];\\n                int idx2= -1;\\n                for(int j=i;j<n-i-1;j++){\\n                    if(s[j]==ch2){\\n                        idx2=j;\\n                        break;\\n                    }\\n                }\\n                int diff = n-1-i-idx;\\n                int diff2 = idx2 - i;\\n                if(idx!=-1 && idx2!=-1){\\n                    // if they both are actively available;\\n                    if(diff < diff2){\\n                        for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                        s[n-i-1]=ch;\\n                        ans+=diff;\\n                    }else{\\n                        for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                        s[i]=ch2;\\n                        ans+=diff2;\\n                    }\\n                }\\n                else if(idx!=-1){\\n                    for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                    s[n-i-1]=ch;\\n                    ans+=diff;\\n                }else if(idx2!=-1){\\n                    for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                    s[i]=ch2;\\n                    ans+=diff2;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            if(s[i]!=s[n-i-1]){\\n                // we have to do something peter \\n                //we have to find in the range (i+1,n-i-1);\\n                char ch = s[i];\\n                int idx = -1;\\n                for(int j = n-i-1;j>i;j--){\\n                    if(s[j]==ch){\\n                        // find the nearest character\\n                        idx = j;\\n                        break;\\n                    }\\n                }\\n                char ch2 = s[n-i-1];\\n                int idx2= -1;\\n                for(int j=i;j<n-i-1;j++){\\n                    if(s[j]==ch2){\\n                        idx2=j;\\n                        break;\\n                    }\\n                }\\n                int diff = n-1-i-idx;\\n                int diff2 = idx2 - i;\\n                if(idx!=-1 && idx2!=-1){\\n                    // if they both are actively available;\\n                    if(diff < diff2){\\n                        for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                        s[n-i-1]=ch;\\n                        ans+=diff;\\n                    }else{\\n                        for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                        s[i]=ch2;\\n                        ans+=diff2;\\n                    }\\n                }\\n                else if(idx!=-1){\\n                    for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                    s[n-i-1]=ch;\\n                    ans+=diff;\\n                }else if(idx2!=-1){\\n                    for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                    s[i]=ch2;\\n                    ans+=diff2;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444152,
                "title": "two-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach used in this code is to traverse the string from both ends simultaneously and comparing the characters. If the characters are not the same, we need to perform a swap operation to make them equal. If the string has odd length and we reach the middle of the string, we need to handle the middle element differently by swapping it with the adjacent element. We continue this process until we reach the middle of the string.\\n\\n# Complexity\\nThe time complexity of this algorithm is O(n^2) where n is the length of the string s because we are traversing the string multiple times. The space complexity is O(1) because we are not using any additional data structure to store the string or intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n        int left = 0, right = s.size() - 1, ans = 0;\\n        \\n        // Traverse the string from both ends simultaneously\\n        while (left < right) {\\n            int l = left, r = right;\\n            \\n            // Compare the characters at left and right positions\\n            while (s[l] != s[r]) {\\n                r--;   \\n            }\\n            \\n            // If l==r, we have reached the odd middle element of the string\\n            if (l == r) {\\n                // Swap the middle element with the adjacent element\\n                swap(s[r], s[r + 1]);\\n                ans++;\\n                continue;\\n            } \\n            else {\\n                // If l!=r, we have reached a normal element\\n                // Move the unequal character to the right side of the string\\n                while (r < right) {\\n                    swap(s[r], s[r + 1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // Move to the next set of left and right characters\\n            left++;\\n            right--;\\n        }\\n        // Return the number of moves required to make the string a palindrome\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n        int left = 0, right = s.size() - 1, ans = 0;\\n        \\n        // Traverse the string from both ends simultaneously\\n        while (left < right) {\\n            int l = left, r = right;\\n            \\n            // Compare the characters at left and right positions\\n            while (s[l] != s[r]) {\\n                r--;   \\n            }\\n            \\n            // If l==r, we have reached the odd middle element of the string\\n            if (l == r) {\\n                // Swap the middle element with the adjacent element\\n                swap(s[r], s[r + 1]);\\n                ans++;\\n                continue;\\n            } \\n            else {\\n                // If l!=r, we have reached a normal element\\n                // Move the unequal character to the right side of the string\\n                while (r < right) {\\n                    swap(s[r], s[r + 1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // Move to the next set of left and right characters\\n            left++;\\n            right--;\\n        }\\n        // Return the number of moves required to make the string a palindrome\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442688,
                "title": "simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.size()-1,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j])\\n              {\\n                  i++;\\n                  j--;\\n              }\\n              else{\\n                  int idx=-1;\\n                  for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        idx = k;\\n                        break;\\n                    }\\n                }\\n                  if(idx>0){\\n                      for(int k=idx;k<j;k++){\\n                          swap(s[k],s[k+1]);\\n                          ans++;\\n                      }\\n                      i++;j--;\\n                  }\\n                  else{\\n                      swap(s[i],s[i+1]);\\n                      ans++;\\n                  }\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\nABouve one pass perfectly but lower one does not pass propery,give tle why\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.size()-1,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j])\\n              {\\n                  i++;\\n                  j--;\\n              }\\n              else{\\n                  int idx=-1;\\n                  for(int k=i+1;k<j;k++){\\n                      if(s[k]==s[j]){\\n                          idx=k;break;\\n                      }\\n                  }\\n                  if(idx>0){\\n                      for(int k=idx;k>i;k--){\\n                          swap(s[k],s[k-1]);\\n                          ans++;\\n                      }\\n                      i++;j--;\\n                  }\\n                  else{\\n                      swap(s[i],s[i+1]);\\n                      ans++;\\n                  }\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan amyone explain",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.size()-1,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j])\\n              {\\n                  i++;\\n                  j--;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3419327,
                "title": "sakshi-awadhiya",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        //using two pointer approach\\n\\n      int ans=0; // creating ans variable\\n        char arr[]=s.toCharArray(); //convert string to character array\\n        int i=0;  //creating i pointer\\n        int j=arr.length-1; // creating j pointer\\n        while(i<j){ \\n            int high=j; //crating high variable\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                }\\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    // write swap function to swap \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n   \\n        \\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        //using two pointer approach\\n\\n      int ans=0; // creating ans variable\\n        char arr[]=s.toCharArray(); //convert string to character array\\n        int i=0;  //creating i pointer\\n        int j=arr.length-1; // creating j pointer\\n        while(i<j){ \\n            int high=j; //crating high variable\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                }\\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    // write swap function to swap \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n   \\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376624,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ret = 0 ;\\n        while(s.size() > 1){\\n            int i = s.find(s.back()) ;\\n            //the string in the middle\\n            if(i == s.size() - 1){\\n                ret += s.size()/2 ;\\n            }\\n            else{\\n                ret += i ;\\n                s.erase(i, 1) ;\\n            }\\n            s.pop_back() ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ret = 0 ;\\n        while(s.size() > 1){\\n            int i = s.find(s.back()) ;\\n            //the string in the middle\\n            if(i == s.size() - 1){\\n                ret += s.size()/2 ;\\n            }\\n            else{\\n                ret += i ;\\n                s.erase(i, 1) ;\\n            }\\n            s.pop_back() ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285097,
                "title": "c-greedy",
                "content": "# Intuition\\nfind the min move to make left bound and right bound the same. then recursion\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while(s.size() > 1) res += oneStep(s);\\n        return res;\\n    }\\n\\n    int oneStep(string& s){\\n        vector<int> left(26, 9999), right(26, -1);\\n        const int n = s.size();\\n        for(int i=0;i<n;i++){\\n            left[s[i]-\\'a\\'] = min(left[s[i]-\\'a\\'], i);\\n            right[s[i]-\\'a\\'] = max(right[s[i]-\\'a\\'], i);\\n        }\\n        int bestChar = -1, minMove = 9999999;\\n        for(int i=0;i<26;i++){\\n            if(left[i] == right[i]) continue;\\n            int numMove = left[i] + n-1-right[i];\\n            if(numMove < minMove){\\n                minMove = numMove;\\n                bestChar = i;\\n            }\\n        }\\n        string t;\\n        for(int i=0;i<n;i++){\\n            if(i!= left[bestChar] && i!=right[bestChar])\\n            t += s[i];\\n        }\\n        s = move(t);\\n        return minMove;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while(s.size() > 1) res += oneStep(s);\\n        return res;\\n    }\\n\\n    int oneStep(string& s){\\n        vector<int> left(26, 9999), right(26, -1);\\n        const int n = s.size();\\n        for(int i=0;i<n;i++){\\n            left[s[i]-\\'a\\'] = min(left[s[i]-\\'a\\'], i);\\n            right[s[i]-\\'a\\'] = max(right[s[i]-\\'a\\'], i);\\n        }\\n        int bestChar = -1, minMove = 9999999;\\n        for(int i=0;i<26;i++){\\n            if(left[i] == right[i]) continue;\\n            int numMove = left[i] + n-1-right[i];\\n            if(numMove < minMove){\\n                minMove = numMove;\\n                bestChar = i;\\n            }\\n        }\\n        string t;\\n        for(int i=0;i<n;i++){\\n            if(i!= left[bestChar] && i!=right[bestChar])\\n            t += s[i];\\n        }\\n        s = move(t);\\n        return minMove;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281388,
                "title": "c-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n = s.size();\\n        int left = 0, right = n - 1;\\n        int ans = 0;\\n        while (left < right) {\\n            // Find the first character from left that doesn\\'t match the corresponding character from right\\n            while (left < right && s[left] == s[right]) {\\n                left++;\\n                right--;\\n            }\\n            // If we have processed the entire string, we\\'re done\\n            if (left >= right) {\\n                break;\\n            }\\n            // Find the character from right that matches the current character from left\\n            int j = right;\\n            while (j > left && s[j] != s[left]) {\\n                j--;\\n            }\\n            // If we can\\'t find a matching character, swap the current character from left with the next character\\n            if (j == left) {\\n                swap(s[left], s[left + 1]);\\n                ans++;\\n            }\\n            // Otherwise, swap the characters from j to right and move left and right pointers towards each other\\n            else {\\n                while (j < right) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n = s.size();\\n        int left = 0, right = n - 1;\\n        int ans = 0;\\n        while (left < right) {\\n            // Find the first character from left that doesn\\'t match the corresponding character from right\\n            while (left < right && s[left] == s[right]) {\\n                left++;\\n                right--;\\n            }\\n            // If we have processed the entire string, we\\'re done\\n            if (left >= right) {\\n                break;\\n            }\\n            // Find the character from right that matches the current character from left\\n            int j = right;\\n            while (j > left && s[j] != s[left]) {\\n                j--;\\n            }\\n            // If we can\\'t find a matching character, swap the current character from left with the next character\\n            if (j == left) {\\n                swap(s[left], s[left + 1]);\\n                ans++;\\n            }\\n            // Otherwise, swap the characters from j to right and move left and right pointers towards each other\\n            else {\\n                while (j < right) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248824,
                "title": "c-easy-to-understand-code-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            int x = i,y=j;\\n            \\n            while(s[x]!=s[y])y--;\\n            \\n            // accbb,abb case for this condition dry run\\n            if(x==y){\\n                swap(s[y],s[y+1]);\\n                ans++;\\n                continue;\\n            }\\n            //aabb case for this condition dry run\\n            else{\\n                while(y<j){\\n                    swap(s[y],s[y+1]);\\n                    y++;\\n                    ans++;\\n                }\\n            }\\n            \\n            i++;j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            int x = i,y=j;\\n            \\n            while(s[x]!=s[y])y--;\\n            \\n            // accbb,abb case for this condition dry run\\n            if(x==y){\\n                swap(s[y],s[y+1]);\\n                ans++;\\n                continue;\\n            }\\n            //aabb case for this condition dry run\\n            else{\\n                while(y<j){\\n                    swap(s[y],s[y+1]);\\n                    y++;\\n                    ans++;\\n                }\\n            }\\n            \\n            i++;j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245541,
                "title": "scala-4-ways-recursion-two-pointers-greedy-with-arraybuffer-or-fenwick-tree-no-pointers-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Desocribe your approach to solving the problem. -->\\n1. construct palindrome using recursion, handle carefully for odd number palindromes, see approach #4 for iterative approach\\n2. two pointers O(N^2) (left and right and closing in)\\n3. two pointers with BIT to track num of chars swapped to the right of certain index\\n4. no pointers, popping processed chars from both ends as we closing in, this is actually the iterative version of approach #1 which is recursive\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. O(N^2) with either approach 1 or 3\\n2. O(NlogN) for approach 2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\nSome thoughts:\\nProof that abab has two arrangements that requires equal number of min moves (abba or baab):\\nfor n=8, a in (1,5), b in (3,8) , a.b.a..a to begin with:\\n1. \\'a\\' pair has imsymmetricity around the invisible center , the imbalance is that one side is 3 chars away from center while the other side is 0, so either left moves rightward by 3(arrives at 4), or right moves rightward by 3 (arrives at 8), the imbalance amount is 3, similarly , \\'b\\' pair has an imbalance amount of 2 on two sides of the invisible center. because moving either one first will offset the imbalance amount of another by exactly 1, the total min move is 3+2-1=4, regardless we picked \\'a\\' or \\'b\\' as our first move\\n2. at every pair making step, we do not waste any swap to move both chars in the pair , we only locate the matching target to the left or right and pick one of them for our action , this guarantees minimum swaps needed\\n\\n# Code\\n```\\nclass BIT (var sz:Int) {\\n        sz+=1 // size internal Array with size+1 because BIT does not use index 0\\n        var arr:Array[Int]=Array.fill[Int](this.sz){0}\\n    def add(i:Int, v:Int) : Unit = { //note that we add the incremental change, not update !\\n        var idx=i+1\\n        while (idx<sz) {  \\n            arr(idx)+=v\\n            idx += idx & -idx\\n        }\\n    }\\n    def query(i:Int) ={\\n        var sum=0;\\n        var idx=i+1;\\n        while (idx!=0) {  \\n            sum+= arr(idx) \\n            idx -= idx & -idx\\n        }\\n        sum\\n    }\\n};\\nobject Solution {\\n    //construct palindrome using recursion, compare whether to keep left end or right end along the way\\n    def minMovesToMakePalindrome(s: String): Int = {\\n        var n=s.length\\n        if (n<=1) 0\\n        else if (s(0)==s.last) minMovesToMakePalindrome(s.slice(1,s.length-1))\\n        else {\\n            val (l,r)=(s.indexOf(s.last),s.lastIndexOf(s(0))) //(l,r) = (,) both parenthesis mandatory\\n            if (r==0) n/2+minMovesToMakePalindrome(s.substring(1))\\n            else if (l==s.size-1) n/2+minMovesToMakePalindrome(s.substring(0,s.size-1))\\n            else l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //pick either l,r or mix and match all yields the same result, this is because a..b..a...b can be arranged in a.b...b.a or b.a...a.b but same minimum move. This has something to do with the number of inversions inherent in the given input eg a in (1,5) position, b in (3,8) position, as in a.b.a..b init state, then a(5)->a(8) takes 3 steps, b(3)->b(1) takes 2 steps, matching first pair moves the other pairs with the gap one step smaller 3+2-1=4 is the min moves needed\\n            //There are cases where Palindrome is made of odd number of chars. If we do not test that as above, \\n            //We can use following trick will ensure that the odd char be left unmatched until the very last recursive call\\n            //if (l<=n-1-r) l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //if s(0) is odd char, r=0 && l>r => l<=n-1-r, keep the odd char at idx 0, match the right end char with idx l;\\n            //else n-1-r + minMovesToMakePalindrome(s.slice(1,r)+s.slice(r+1,s.length)) //otherwise s.last is odd char, l==s.size-1 && r<l => l>n-1-r, keep the odd char at idx s.size-1, match the left end char with idx r\\n        }\\n    }\\n\\n    def minMovesToMakePalindromeBIT(s: String): Int = {\\n        //use Fenwick Tree \\n        import scala.collection.mutable.{ArrayDeque}; //Array does not println well because it\\'s JVM Array\\n        var d=Array.fill[ArrayDeque[Int]](26){ArrayDeque[Int]()}\\n        for ( (c,i) <- s.zipWithIndex)  d(c-\\'a\\').append(i) // note (c,i) order, opposite to python\\'s enumerate(l)\\n        var res=0;\\n        val bit=new BIT(s.size);\\n        for (i <- s.length-1 to 0 by -1) {\\n            val j=s(i)-\\'a\\';\\n            if (!d(j).isEmpty) {\\n                //This statement adjusts (reduces) the swapping needed if there are already some characters whose position is ahead of (smaller than) the current position. Similarly, p/=2 is to calculate the steps needed to swap a character to the central position when there are odd number of chars in this palindrome.\\n                var p=d(j)(0)-bit.query(d(j)(0))\\n                bit.add(d(j)(0),1);\\n                if (d(j).size!=1)  d(j).dropInPlace(1) //must be InPlace!\\n                else  p /= 2; // p accounts for previous swapped chars, so p/2 is the #swaps to make it center\\n                res += p;\\n                d(j).dropRightInPlace(1)\\n            }\\n        }\\n        res\\n    }\\n    //greedy 2 using ListBuffer or ArrayBuffer, note that ListBuffer timed exceeded while ArrayBuffer not\\n    //A ListBuffer is like an array buffer except that it uses a linked list internally instead of an array. If you plan to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer.\\n    def minMovesToMakePalindrome2(S: String): Int = {\\n       var res=0\\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S) //not exists collection.mutable.List\\n       var l=0\\n       var r,i=s.length-1\\n        while (l<r) {\\n            if (s(l)==s(r)) { l+=1; r-=1}\\n            else {\\n                i=s.lastIndexOf(s(l),r) // keeping left end or right end yields same number of moves, we keep left char\\n                val t=s(i)\\n                if (l==i) {\\n                    s(l)=s(l+1)\\n                    s(l+1)=t\\n                    res+=1\\n                } \\n                else {\\n                    for (k <- i until r )  s(k)=s(k+1)\\n                    res+=r-i\\n                    s(r)=t\\n                    l+=1\\n                    r-=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    //greedy 1\\n    def minMovesToMakePalindrome1(S: String): Int = {\\n       var res=0 \\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S)\\n       while (s.size>0) {\\n           val i=s.indexOf(s.last)\\n           if (i==s.size-1) res += i/2 // only one single char allowed in each Palindrome, so i must be even\\n           else  {\\n               res += i\\n               s.remove(i)\\n           }\\n           s.remove(s.size-1)\\n       }\\n       res\\n    }\\n}\\n```\\n\\nC++ with Fenwick Tree:\\n```\\nusing namespace std;\\nclass BIT {\\npublic: \\n    BIT(int sz) {\\n        this->sz=sz+1;\\n        arr=new int[this->sz];\\n        for (int i=0; i<this->sz; ++i) *(arr+i)=0;\\n    }\\n    ~BIT() {\\n        delete[] arr;\\n    }\\n    int* arr;\\n    int sz;\\n    void add(int idx, int val) {\\n        for (++idx; idx<this->sz; idx += idx & -idx)  arr[idx]+=val;\\n    }\\n    int query(int idx) {\\n        int sum=0;\\n        for (++idx; idx; idx -= idx & -idx)  sum+= arr[idx] ;\\n        return sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        deque<int> d[26];\\n        for (int i=0; i<s.size(); ++i) {\\n            d[s[i]-\\'a\\'].push_back(i);\\n        }\\n        int res=0;\\n        BIT bit(s.size());\\n        for (int i=s.size()-1; i>=0; --i) {\\n            int j=s[i]-\\'a\\';\\n            if (!d[j].empty()) {\\n                int p=d[j].front()-bit.query(d[j].front());\\n                bit.add(d[j].front(),1);\\n                if (d[j].size()!=1)  d[j].pop_front();\\n                else  p /= 2;\\n                res += p;\\n                d[j].pop_back();\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nclass BIT (var sz:Int) {\\n        sz+=1 // size internal Array with size+1 because BIT does not use index 0\\n        var arr:Array[Int]=Array.fill[Int](this.sz){0}\\n    def add(i:Int, v:Int) : Unit = { //note that we add the incremental change, not update !\\n        var idx=i+1\\n        while (idx<sz) {  \\n            arr(idx)+=v\\n            idx += idx & -idx\\n        }\\n    }\\n    def query(i:Int) ={\\n        var sum=0;\\n        var idx=i+1;\\n        while (idx!=0) {  \\n            sum+= arr(idx) \\n            idx -= idx & -idx\\n        }\\n        sum\\n    }\\n};\\nobject Solution {\\n    //construct palindrome using recursion, compare whether to keep left end or right end along the way\\n    def minMovesToMakePalindrome(s: String): Int = {\\n        var n=s.length\\n        if (n<=1) 0\\n        else if (s(0)==s.last) minMovesToMakePalindrome(s.slice(1,s.length-1))\\n        else {\\n            val (l,r)=(s.indexOf(s.last),s.lastIndexOf(s(0))) //(l,r) = (,) both parenthesis mandatory\\n            if (r==0) n/2+minMovesToMakePalindrome(s.substring(1))\\n            else if (l==s.size-1) n/2+minMovesToMakePalindrome(s.substring(0,s.size-1))\\n            else l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //pick either l,r or mix and match all yields the same result, this is because a..b..a...b can be arranged in a.b...b.a or b.a...a.b but same minimum move. This has something to do with the number of inversions inherent in the given input eg a in (1,5) position, b in (3,8) position, as in a.b.a..b init state, then a(5)->a(8) takes 3 steps, b(3)->b(1) takes 2 steps, matching first pair moves the other pairs with the gap one step smaller 3+2-1=4 is the min moves needed\\n            //There are cases where Palindrome is made of odd number of chars. If we do not test that as above, \\n            //We can use following trick will ensure that the odd char be left unmatched until the very last recursive call\\n            //if (l<=n-1-r) l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //if s(0) is odd char, r=0 && l>r => l<=n-1-r, keep the odd char at idx 0, match the right end char with idx l;\\n            //else n-1-r + minMovesToMakePalindrome(s.slice(1,r)+s.slice(r+1,s.length)) //otherwise s.last is odd char, l==s.size-1 && r<l => l>n-1-r, keep the odd char at idx s.size-1, match the left end char with idx r\\n        }\\n    }\\n\\n    def minMovesToMakePalindromeBIT(s: String): Int = {\\n        //use Fenwick Tree \\n        import scala.collection.mutable.{ArrayDeque}; //Array does not println well because it\\'s JVM Array\\n        var d=Array.fill[ArrayDeque[Int]](26){ArrayDeque[Int]()}\\n        for ( (c,i) <- s.zipWithIndex)  d(c-\\'a\\').append(i) // note (c,i) order, opposite to python\\'s enumerate(l)\\n        var res=0;\\n        val bit=new BIT(s.size);\\n        for (i <- s.length-1 to 0 by -1) {\\n            val j=s(i)-\\'a\\';\\n            if (!d(j).isEmpty) {\\n                //This statement adjusts (reduces) the swapping needed if there are already some characters whose position is ahead of (smaller than) the current position. Similarly, p/=2 is to calculate the steps needed to swap a character to the central position when there are odd number of chars in this palindrome.\\n                var p=d(j)(0)-bit.query(d(j)(0))\\n                bit.add(d(j)(0),1);\\n                if (d(j).size!=1)  d(j).dropInPlace(1) //must be InPlace!\\n                else  p /= 2; // p accounts for previous swapped chars, so p/2 is the #swaps to make it center\\n                res += p;\\n                d(j).dropRightInPlace(1)\\n            }\\n        }\\n        res\\n    }\\n    //greedy 2 using ListBuffer or ArrayBuffer, note that ListBuffer timed exceeded while ArrayBuffer not\\n    //A ListBuffer is like an array buffer except that it uses a linked list internally instead of an array. If you plan to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer.\\n    def minMovesToMakePalindrome2(S: String): Int = {\\n       var res=0\\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S) //not exists collection.mutable.List\\n       var l=0\\n       var r,i=s.length-1\\n        while (l<r) {\\n            if (s(l)==s(r)) { l+=1; r-=1}\\n            else {\\n                i=s.lastIndexOf(s(l),r) // keeping left end or right end yields same number of moves, we keep left char\\n                val t=s(i)\\n                if (l==i) {\\n                    s(l)=s(l+1)\\n                    s(l+1)=t\\n                    res+=1\\n                } \\n                else {\\n                    for (k <- i until r )  s(k)=s(k+1)\\n                    res+=r-i\\n                    s(r)=t\\n                    l+=1\\n                    r-=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    //greedy 1\\n    def minMovesToMakePalindrome1(S: String): Int = {\\n       var res=0 \\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S)\\n       while (s.size>0) {\\n           val i=s.indexOf(s.last)\\n           if (i==s.size-1) res += i/2 // only one single char allowed in each Palindrome, so i must be even\\n           else  {\\n               res += i\\n               s.remove(i)\\n           }\\n           s.remove(s.size-1)\\n       }\\n       res\\n    }\\n}\\n```\n```\\nusing namespace std;\\nclass BIT {\\npublic: \\n    BIT(int sz) {\\n        this->sz=sz+1;\\n        arr=new int[this->sz];\\n        for (int i=0; i<this->sz; ++i) *(arr+i)=0;\\n    }\\n    ~BIT() {\\n        delete[] arr;\\n    }\\n    int* arr;\\n    int sz;\\n    void add(int idx, int val) {\\n        for (++idx; idx<this->sz; idx += idx & -idx)  arr[idx]+=val;\\n    }\\n    int query(int idx) {\\n        int sum=0;\\n        for (++idx; idx; idx -= idx & -idx)  sum+= arr[idx] ;\\n        return sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        deque<int> d[26];\\n        for (int i=0; i<s.size(); ++i) {\\n            d[s[i]-\\'a\\'].push_back(i);\\n        }\\n        int res=0;\\n        BIT bit(s.size());\\n        for (int i=s.size()-1; i>=0; --i) {\\n            int j=s[i]-\\'a\\';\\n            if (!d[j].empty()) {\\n                int p=d[j].front()-bit.query(d[j].front());\\n                bit.add(d[j].front(),1);\\n                if (d[j].size()!=1)  d[j].pop_front();\\n                else  p /= 2;\\n                res += p;\\n                d[j].pop_back();\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244038,
                "title": "python-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n\\n        if n <= 1:\\n            return 0\\n\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n\\n        l, r = s.find(s[-1]), s.rfind(s[0])\\n\\n        (2,4)\\n\\n        if l <= n-1-r:\\n            return l + self.minMovesToMakePalindrome(s[:l] + s[l+1:-1])\\n        else:\\n            return n-1-r + self.minMovesToMakePalindrome(s[1:r] + s[r+1:])\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n\\n        if n <= 1:\\n            return 0\\n\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n\\n        l, r = s.find(s[-1]), s.rfind(s[0])\\n\\n        (2,4)\\n\\n        if l <= n-1-r:\\n            return l + self.minMovesToMakePalindrome(s[:l] + s[l+1:-1])\\n        else:\\n            return n-1-r + self.minMovesToMakePalindrome(s[1:r] + s[r+1:])\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214766,
                "title": "java-easy-2-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find the character for one end to other that matches and if the match is made then we need that number to move to the end. \\nIf we donot find such number we need to make it mode to middle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse to pointer to do this .\\nThis could be also done by having greedy appreoach.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int strt = 0;\\n        int end = s.length()-1;\\n        int ans = 0;\\n        while(strt<end)\\n        {\\n            if(s.charAt(end) == s.charAt(strt))\\n            {\\n                strt++;\\n                end --;\\n                continue;\\n            }\\n            int r__ = end;\\n            while(s.charAt(r__) != s.charAt(strt))\\n            r__--;\\n\\n\\n            if(r__ == strt)\\n            {\\n                ans += s.length()/2 - strt;\\n                strt++;\\n            }\\n            else\\n            {\\n                ans += end - r__;\\n                while(end>r__)\\n                {\\n                    s = swap(s,r__,r__+1);\\n                    r__++;\\n                    //ans++;\\n                }\\n                strt++;\\n                end--;\\n                //swap(s,r)\\n            }\\n            //strt++;\\n\\n        }\\n        return ans ;\\n    }\\n    public String swap(String s , int i , int j)\\n    {\\n        StringBuilder sb = new StringBuilder(s);\\n    \\n        char temp = s.charAt(i);\\n        sb.setCharAt(i,s.charAt(j));\\n        sb.setCharAt(j,temp);\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int strt = 0;\\n        int end = s.length()-1;\\n        int ans = 0;\\n        while(strt<end)\\n        {\\n            if(s.charAt(end) == s.charAt(strt))\\n            {\\n                strt++;\\n                end --;\\n                continue;\\n            }\\n            int r__ = end;\\n            while(s.charAt(r__) != s.charAt(strt))\\n            r__--;\\n\\n\\n            if(r__ == strt)\\n            {\\n                ans += s.length()/2 - strt;\\n                strt++;\\n            }\\n            else\\n            {\\n                ans += end - r__;\\n                while(end>r__)\\n                {\\n                    s = swap(s,r__,r__+1);\\n                    r__++;\\n                    //ans++;\\n                }\\n                strt++;\\n                end--;\\n                //swap(s,r)\\n            }\\n            //strt++;\\n\\n        }\\n        return ans ;\\n    }\\n    public String swap(String s , int i , int j)\\n    {\\n        StringBuilder sb = new StringBuilder(s);\\n    \\n        char temp = s.charAt(i);\\n        sb.setCharAt(i,s.charAt(j));\\n        sb.setCharAt(j,temp);\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197767,
                "title": "python3-with-lots-of-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each letter pair, you have to move one to match the index of the other. The fastest way to do this is to only move one of the letters, starting with the one that has to move furthest. \\n\\nIf you have aaaaaaaaabb, either all the a\\'s have to move between the bs or both bs need to move to the center. This is an equivalent operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy algorithm. Start at the outside of the onion and peel off layers\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        wild_west = list(s)\\n        moves = 0\\n        while wild_west:\\n            # index of first char that matches the last char\\n            matching_end = wild_west.index(wild_west[-1])\\n            # if end is the only one of its kind move it to centre\\n            if matching_end == len(wild_west) - 1:\\n                moves_to_middle = matching_end // 2\\n                moves += matching_end // 2\\n            else:\\n                # move first match of end to the start\\n                moves += matching_end\\n                # remove the first match\\n                wild_west.pop(matching_end)\\n                \\n            # remove the end of the list \\n            wild_west.pop()\\n\\n        return moves\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        wild_west = list(s)\\n        moves = 0\\n        while wild_west:\\n            # index of first char that matches the last char\\n            matching_end = wild_west.index(wild_west[-1])\\n            # if end is the only one of its kind move it to centre\\n            if matching_end == len(wild_west) - 1:\\n                moves_to_middle = matching_end // 2\\n                moves += matching_end // 2\\n            else:\\n                # move first match of end to the start\\n                moves += matching_end\\n                # remove the first match\\n                wild_west.pop(matching_end)\\n                \\n            # remove the end of the list \\n            wild_west.pop()\\n\\n        return moves\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178787,
                "title": "bit-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nused BIT to calculate inversions\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n\\tdef __init__(self, n):\\n\\t\\tself.n = n\\n\\t\\tself.tree = [0] * (n + 1)\\n\\n\\tdef sum(self, i):\\n\\t\\tans = 0\\n\\t\\ti += 1\\n\\t\\twhile i > 0:\\n\\t\\t\\tans += self.tree[i]\\n\\t\\t\\ti -= (i & (-i))\\n\\t\\treturn ans\\n\\n\\tdef update(self, i, value):\\n\\t\\ti += 1\\n\\t\\twhile i <= self.n:\\n\\t\\t\\tself.tree[i] += value\\n\\t\\t\\ti += (i & (-i))\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        idx=defaultdict(list)\\n        n=len(s)\\n        for i in range(n):\\n            idx[s[i]].append(i)\\n        pp=[]\\n        d=[0]*n\\n        for ch,l in idx.items():\\n            if len(l)&1:\\n                d[l[len(l)//2]]=n//2\\n            for i in range(len(l)//2):\\n                pp.append((l[i],l[-i-1]))\\n        for i,(l,r) in enumerate(sorted(pp)):\\n            d[l]=i\\n            d[r]=n-i-1\\n        bt=BIT(n)\\n        ans=0 #calculate inversions\\n        for i in range(n):\\n            ans+=i-bt.sum(d[i])\\n            bt.update(d[i],1)\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT():\\n\\tdef __init__(self, n):\\n\\t\\tself.n = n\\n\\t\\tself.tree = [0] * (n + 1)\\n\\n\\tdef sum(self, i):\\n\\t\\tans = 0\\n\\t\\ti += 1\\n\\t\\twhile i > 0:\\n\\t\\t\\tans += self.tree[i]\\n\\t\\t\\ti -= (i & (-i))\\n\\t\\treturn ans\\n\\n\\tdef update(self, i, value):\\n\\t\\ti += 1\\n\\t\\twhile i <= self.n:\\n\\t\\t\\tself.tree[i] += value\\n\\t\\t\\ti += (i & (-i))\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        idx=defaultdict(list)\\n        n=len(s)\\n        for i in range(n):\\n            idx[s[i]].append(i)\\n        pp=[]\\n        d=[0]*n\\n        for ch,l in idx.items():\\n            if len(l)&1:\\n                d[l[len(l)//2]]=n//2\\n            for i in range(len(l)//2):\\n                pp.append((l[i],l[-i-1]))\\n        for i,(l,r) in enumerate(sorted(pp)):\\n            d[l]=i\\n            d[r]=n-i-1\\n        bt=BIT(n)\\n        ans=0 #calculate inversions\\n        for i in range(n):\\n            ans+=i-bt.sum(d[i])\\n            bt.update(d[i],1)\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165964,
                "title": "recursive-by-deleting-letters-at-left-or-right-end-that-produce-less-swaps",
                "content": "# Intuition\\nEach time swapping letters to match the end letter will produce lest swaps. But we need to decide if we want to match letters at left end or we want to swap letters at right end. Once we decide which one to match, we can delete these letters. And keep doing till we are left with no letters (even length) or 1 letter (odd length). \\n\\n\\nSpace complexity will be O(N) \\nThe recursive stack will run N/2 long since we delete 2 letters each time. \\nSpace taken by letters array is N\\n\\nTime complexity will be O(N^2). We have stack recursive fn executed N/2 times and each time it does a liner pass to delete 2 letters at the end so O(N) - Total O(N^2). \\n\\n# Code\\n```\\nclass Solution:\\n    \\n    # Check if matching left most letter will lead to less swaps or \\n    # if swapping right most letter will need to less swaps \\n    # Eg: [e]v{p}xuw[e]qo{p} \\n    # If we make move the rightmost \\'e\\' to right we need 3 swaps\\n    # If we move the left post \\'p\\' left we need 2 swaps\\n    # So we will move the p left and delete p from both ends\\n    def swapsToMatchLastLetter(self, letters):\\n        # If one letter left then it is the last letter in odd length string so no more swaps\\n        if len(letters) == 1:\\n            letters.pop()\\n            return 0\\n        # If letters at 2 ends match then we don\\'t need any swaps \\n        if letters[0] == letters[-1]:\\n            letters.pop()\\n            letters.pop(0)\\n            return 0\\n\\n        # We save left most and right most letter\\n        last_left, last_right = letters[0], letters[-1]\\n        # We set our index finding pointers to edge cases\\n        rightmost_left_letter = 1\\n        leftmost_right_letter = len(letters) - 1\\n        \\n        # Iterate string and find the first index on right for left most letter\\n        # and first index on left for right most letter\\n        for start in range(1, len(letters) - 1):\\n            if letters[start] == last_left:\\n                rightmost_left_letter = max(rightmost_left_letter, start)\\n            if letters[start] == last_right:\\n                leftmost_right_letter = min(leftmost_right_letter, start)\\n\\n        # If the index did not change from initial value then we did not find the letter\\n        left_exists = rightmost_left_letter != 0\\n        right_exists = leftmost_right_letter != len(letters) - 1\\n        # If we found a letter to swap with then num swaps makes sense else give it a high value so we ignore\\n        # this swap option\\n        swaps_to_match_left_end = (len(letters) - 1) - rightmost_left_letter if left_exists else float(\\'inf\\')\\n        swaps_to_match_right_end = leftmost_right_letter - 0 if right_exists else float(\\'inf\\')\\n\\n        # Swap the letter that will produce less swaps\\n        if swaps_to_match_left_end < swaps_to_match_right_end:\\n            letters.pop(rightmost_left_letter)\\n            letters.pop(0)\\n            return swaps_to_match_left_end\\n        else: \\n            letters.pop(leftmost_right_letter)\\n            letters.pop()\\n            return swaps_to_match_right_end\\n\\n\\n    def recursive_swaps(self, letters):\\n        if not letters:\\n            return 0\\n\\n        swaps = 0 \\n        # Find min number of swaps to match letters at the end and the delete those letters\\n        # Look at comment above. \\n        # This is a greedy approach that works because if we try to match an inner letter vs \\n        # outermost letters then we will need more swaps. Here we will need less swaps as one \\n        # letter is already at the edge (left-most or right-most)\\n        swaps += self.swapsToMatchLastLetter(letters)\\n        # Now calculate how many swaps for next remaining letters\\n        swaps += self.recursive_swaps(letters)\\n\\n        return swaps\\n\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        letters = list(s)\\n        return self.recursive_swaps(letters)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Check if matching left most letter will lead to less swaps or \\n    # if swapping right most letter will need to less swaps \\n    # Eg: [e]v{p}xuw[e]qo{p} \\n    # If we make move the rightmost \\'e\\' to right we need 3 swaps\\n    # If we move the left post \\'p\\' left we need 2 swaps\\n    # So we will move the p left and delete p from both ends\\n    def swapsToMatchLastLetter(self, letters):\\n        # If one letter left then it is the last letter in odd length string so no more swaps\\n        if len(letters) == 1:\\n            letters.pop()\\n            return 0\\n        # If letters at 2 ends match then we don\\'t need any swaps \\n        if letters[0] == letters[-1]:\\n            letters.pop()\\n            letters.pop(0)\\n            return 0\\n\\n        # We save left most and right most letter\\n        last_left, last_right = letters[0], letters[-1]\\n        # We set our index finding pointers to edge cases\\n        rightmost_left_letter = 1\\n        leftmost_right_letter = len(letters) - 1\\n        \\n        # Iterate string and find the first index on right for left most letter\\n        # and first index on left for right most letter\\n        for start in range(1, len(letters) - 1):\\n            if letters[start] == last_left:\\n                rightmost_left_letter = max(rightmost_left_letter, start)\\n            if letters[start] == last_right:\\n                leftmost_right_letter = min(leftmost_right_letter, start)\\n\\n        # If the index did not change from initial value then we did not find the letter\\n        left_exists = rightmost_left_letter != 0\\n        right_exists = leftmost_right_letter != len(letters) - 1\\n        # If we found a letter to swap with then num swaps makes sense else give it a high value so we ignore\\n        # this swap option\\n        swaps_to_match_left_end = (len(letters) - 1) - rightmost_left_letter if left_exists else float(\\'inf\\')\\n        swaps_to_match_right_end = leftmost_right_letter - 0 if right_exists else float(\\'inf\\')\\n\\n        # Swap the letter that will produce less swaps\\n        if swaps_to_match_left_end < swaps_to_match_right_end:\\n            letters.pop(rightmost_left_letter)\\n            letters.pop(0)\\n            return swaps_to_match_left_end\\n        else: \\n            letters.pop(leftmost_right_letter)\\n            letters.pop()\\n            return swaps_to_match_right_end\\n\\n\\n    def recursive_swaps(self, letters):\\n        if not letters:\\n            return 0\\n\\n        swaps = 0 \\n        # Find min number of swaps to match letters at the end and the delete those letters\\n        # Look at comment above. \\n        # This is a greedy approach that works because if we try to match an inner letter vs \\n        # outermost letters then we will need more swaps. Here we will need less swaps as one \\n        # letter is already at the edge (left-most or right-most)\\n        swaps += self.swapsToMatchLastLetter(letters)\\n        # Now calculate how many swaps for next remaining letters\\n        swaps += self.recursive_swaps(letters)\\n\\n        return swaps\\n\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        letters = list(s)\\n        return self.recursive_swaps(letters)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092239,
                "title": "greedy-algo",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        res = 0\\n        s = list(s)\\n        while s:\\n            last = s[-1]\\n            i = s.index(last)\\n            if i == len(s) - 1:\\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        res = 0\\n        s = list(s)\\n        while s:\\n            last = s[-1]\\n            i = s.index(last)\\n            if i == len(s) - 1:\\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047896,
                "title": "beats-98-2023-py-soln-string-slicing-approach",
                "content": "\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033009,
                "title": "just-do-what-the-question-tells-you-java",
                "content": "Just do what the question tells you..\\ncheck left and right and pick the minimum one\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int left = 0, right = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n        int count = 0;\\n        while(!isPalindrome(chars)){\\n            \\n            count += makeRight(chars, left++, right--); \\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    \\n    public int makeRight(char[] chars, int left, int right){\\n        \\n        char leftChar = chars[left], rightChar = chars[right];\\n        \\n        if(leftChar == rightChar) return 0;\\n        \\n        int moveRight = chars.length, moveLeft = chars.length;\\n        \\n        for(int i = right - 1; i > left; i--){\\n            \\n            if(chars[i] == leftChar){\\n                moveRight = right - i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = left + 1; i < right; i++){\\n            if(chars[i] == rightChar){\\n                moveLeft = i - left;\\n                break;\\n            }\\n        }\\n        \\n        if(moveLeft < moveRight){\\n            swap(chars, left, moveLeft, true);\\n            return moveLeft;\\n        }else{\\n            swap(chars, right, moveRight, false);\\n            return moveRight;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    public void swap(char[] chars, int start, int steps, boolean isMovedLeft){\\n        \\n        if(isMovedLeft){\\n            for(int i = start + steps; i > start; i--){\\n                char temp = chars[i];\\n                chars[i] = chars[i - 1];\\n                chars[i - 1] = temp;\\n            }\\n        }else{\\n            for(int i = start - steps; i < start; i++){\\n                char temp = chars[i];\\n                chars[i] = chars[i + 1];\\n                chars[i + 1] = temp;\\n            }\\n        }\\n        \\n    }\\n    \\n    \\n    public boolean isPalindrome(char[] chars){\\n        \\n        int left = 0, right = chars.length-1;\\n        \\n        while(left < right){\\n            if(chars[left++] != chars[right--]) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int left = 0, right = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n        int count = 0;\\n        while(!isPalindrome(chars)){\\n            \\n            count += makeRight(chars, left++, right--); \\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    \\n    public int makeRight(char[] chars, int left, int right){\\n        \\n        char leftChar = chars[left], rightChar = chars[right];\\n        \\n        if(leftChar == rightChar) return 0;\\n        \\n        int moveRight = chars.length, moveLeft = chars.length;\\n        \\n        for(int i = right - 1; i > left; i--){\\n            \\n            if(chars[i] == leftChar){\\n                moveRight = right - i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = left + 1; i < right; i++){\\n            if(chars[i] == rightChar){\\n                moveLeft = i - left;\\n                break;\\n            }\\n        }\\n        \\n        if(moveLeft < moveRight){\\n            swap(chars, left, moveLeft, true);\\n            return moveLeft;\\n        }else{\\n            swap(chars, right, moveRight, false);\\n            return moveRight;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    public void swap(char[] chars, int start, int steps, boolean isMovedLeft){\\n        \\n        if(isMovedLeft){\\n            for(int i = start + steps; i > start; i--){\\n                char temp = chars[i];\\n                chars[i] = chars[i - 1];\\n                chars[i - 1] = temp;\\n            }\\n        }else{\\n            for(int i = start - steps; i < start; i++){\\n                char temp = chars[i];\\n                chars[i] = chars[i + 1];\\n                chars[i + 1] = temp;\\n            }\\n        }\\n        \\n    }\\n    \\n    \\n    public boolean isPalindrome(char[] chars){\\n        \\n        int left = 0, right = chars.length-1;\\n        \\n        while(left < right){\\n            if(chars[left++] != chars[right--]) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003940,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> strList = s.ToList();\\n\\n        int result=0;\\n        while( strList.Any())\\n        {\\n            //Find last element in list\\n            char lastElement = strList[strList.Count-1];\\n            int index = strList.FindIndex(ch=> ch== lastElement);\\n\\n            //if element match not found and it is last element\\n            //then move that element to center of string to make palindrome\\n            if(index == strList.Count -1)\\n                result += (index/2);\\n            //add i index to result and remove the item;\\n            else\\n            {\\n                result +=index;\\n                strList.RemoveAt(index);\\n            }\\n            strList.RemoveAt(strList.Count-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> strList = s.ToList();\\n\\n        int result=0;\\n        while( strList.Any())\\n        {\\n            //Find last element in list\\n            char lastElement = strList[strList.Count-1];\\n            int index = strList.FindIndex(ch=> ch== lastElement);\\n\\n            //if element match not found and it is last element\\n            //then move that element to center of string to make palindrome\\n            if(index == strList.Count -1)\\n                result += (index/2);\\n            //add i index to result and remove the item;\\n            else\\n            {\\n                result +=index;\\n                strList.RemoveAt(index);\\n            }\\n            strList.RemoveAt(strList.Count-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000931,
                "title": "python-solution-is-giving-me-tle-but-same-c-doesn-t",
                "content": "\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1,ans=0;\\n        \\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                int p=r;\\n                while(p>l and s[l]!=s[p])\\n                    p-=1;\\n                if(p==l){\\n                    swap(s[p],s[p+1]);\\n                    ans+=1;\\n                }\\n                else{\\n                    while(p<r){\\n                         swap(s[p],s[p+1]);\\n                        p+=1;\\n                        ans+=1;\\n                    }\\n                    l++,r--;\\n                }\\n            }\\n\\n            else{\\n                     l++,r--;\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\\nWhat should I do now ?\\n## Py\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,l,r=list(s),0,len(s)-1\\n        ans=0\\n        while(l<r):\\n            if(s[l]!=s[r]):\\n                p=r\\n                while(p>l and s[l]!=s[p]):\\n                    p-=1\\n                if(p==l):\\n                    s[p],s[p+1]=s[p],s[p+1]\\n                    ans+=1\\n                else:\\n                    while(p<r):\\n                        s[p],s[p+1]=s[p+1],s[p]\\n                        p+=1\\n                        ans+=1\\n                    l,r=l+1,r-1\\n            else:\\n                l,r=l+1,r-1\\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1,ans=0;\\n        \\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                int p=r;\\n                while(p>l and s[l]!=s[p])\\n                    p-=1;\\n                if(p==l){\\n                    swap(s[p],s[p+1]);\\n                    ans+=1;\\n                }\\n                else{\\n                    while(p<r){\\n                         swap(s[p],s[p+1]);\\n                        p+=1;\\n                        ans+=1;\\n                    }\\n                    l++,r--;\\n                }\\n            }\\n\\n            else{\\n                     l++,r--;\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,l,r=list(s),0,len(s)-1\\n        ans=0\\n        while(l<r):\\n            if(s[l]!=s[r]):\\n                p=r\\n                while(p>l and s[l]!=s[p]):\\n                    p-=1\\n                if(p==l):\\n                    s[p],s[p+1]=s[p],s[p+1]\\n                    ans+=1\\n                else:\\n                    while(p<r):\\n                        s[p],s[p+1]=s[p+1],s[p]\\n                        p+=1\\n                        ans+=1\\n                    l,r=l+1,r-1\\n            else:\\n                l,r=l+1,r-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991116,
                "title": "full-proof-o-n-and-o-1-c-solution-with-in-depth-explaination",
                "content": "# Intuition\\nSo the intuition behind this is that, if we can make the extreme elements (first and last index elements) of the string a palindrome taking optimal moves than we can recurse the algorithm on the substring from 2nd and 2nd last index, and so on and repeating this we can find the optimal no of moves.\\n\\nBut how to find the optimal moves for the first and last elements to be palindrome. This can be done by comparing which of the elements at last and first index is better suited for being the palindromic element.\\n\\nIf first and last elements are different, say first one is a and last one is b (a........b) than the substring can become palindromic with either choosing b or a at its extreme ends. ie a.......a or b.......b (where dots indicates all the elements in between the extreme ends). So now we have 2 options either to find another a from the string and make the last element a or to find another b from the string and to make the first element b.\\n(we won\\'t move first and last elements because we want to take least moves and thus we consider that atleast one of them is already palindromic)\\n\\nWe make the greedy choice here, we choose whichever elements is closer to the extremes, ie we want b at first index, so find after how many elements is another \\'b\\' from first element (to match it with the b at the other end) and similarly find after how many elements is another \\'a\\' from last element. (to match it with the a at the first index)\\n\\nIf b is closer, bring it to the first element or if a is closer, bring it to the last element. now we have a.....a or b.....b based on the closeness of same elements from both the ends. and thus the extremes of this substring are made palindromic and now consider the inner substring and do this recursively.\\n\\n# Why this works ??\\nThis works because every time we are only bringing the similar element to the first or last index and rest all the elements are either right shifted (while bringing b to first index) or left shifted (while bringing a to last index) one space. Thus their order within the next smaller substring is not changed and we can again recurse them greedily. This would not be the case if we can move or swap any number with any other number, in that case the effect of swapping inner elements before choosing greedily would be different than after choosing greedily.\\n\\n# Walk through an example \\ns = lleett\\nso the extreme elements are l and t at index 0 and 5.\\nthus finding the no of elements between 0 and next t, which is 3 and between index 5 and l is also 3. so we can make any one either l or t as the extreme elements in palindromic substring. we choose to make l as last element too.\\ns = l(eett)l \\n(we can see clearly here that the numbers between the extremes are just shifted to left side by 1 space and thier inner order has not changed.)\\nnow considering the substring eett\\nboth again have same distance from both ends, ie other t is 1 element away from first e and vice versa. we can again choose to move any one here.\\nthus s = l(e(tt)e)l\\nthus s is converted to a palindromic substring. and the swaps it takes is, distance swapped in pass one (ie 3)+1 and distance swapped in pass 2 (ie 1) + 1 = (3+1)+(1+1)=6.\\n\\ni hope you understood it, if yes than please upvote it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\nwe can write this code recursively too it would be far better for understanding, so you can write it yourself to check your understanding of the problem, we have written if iteratively because it takes less space.\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int left=0;\\n        int right=n-1;\\n        int count=0;\\n        int mid=n/2;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            char a=s[left];\\n            char b=s[right];\\n//finding the closest duplicate and swapping.\\n            if(a!=b)\\n            {\\n                int count1=0;\\n                for(int j=left+1;j<right;j++)\\n                {\\n                    if(s[j]!=b)\\n                    {\\n                        count1+=1;\\n                    }\\n                    else break;\\n                }\\n                int count2=0;\\n                for(int j=right-1;j>left;j--)\\n                {\\n                    if(s[j]!=a)\\n                    {\\n                        count2+=1;\\n                    }\\n                    else break;\\n                }\\n                if(count1>count2) //means that duplicate of a is\\n                //closer to right index of our window.\\n                {\\n                    //now we will swap that duplicate till it reaches \\n                    //till it reaches the right\\'th index.\\n                    int k=right-count2-1;\\n//k stores the index of that duplicate no.\\n                    count+=count2+1;\\n                    while(k<right)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                    }\\n                }\\n                else \\n                {\\n//else either both have same distance or b is closer to left index,\\n//in which case, we will swap it, till it reaches left\\'th index\\n                    int k=count1+1+left;\\n//k stores the index of that duplicate no.\\n                    count+=count1+1;\\n                    while(k>left)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        k--;\\n                    }\\n                }\\n\\n            }\\n//decreasing the size of the subarray.\\n            left+=1;\\n            right-=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int left=0;\\n        int right=n-1;\\n        int count=0;\\n        int mid=n/2;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            char a=s[left];\\n            char b=s[right];\\n//finding the closest duplicate and swapping.\\n            if(a!=b)\\n            {\\n                int count1=0;\\n                for(int j=left+1;j<right;j++)\\n                {\\n                    if(s[j]!=b)\\n                    {\\n                        count1+=1;\\n                    }\\n                    else break;\\n                }\\n                int count2=0;\\n                for(int j=right-1;j>left;j--)\\n                {\\n                    if(s[j]!=a)\\n                    {\\n                        count2+=1;\\n                    }\\n                    else break;\\n                }\\n                if(count1>count2) //means that duplicate of a is\\n                //closer to right index of our window.\\n                {\\n                    //now we will swap that duplicate till it reaches \\n                    //till it reaches the right\\'th index.\\n                    int k=right-count2-1;\\n//k stores the index of that duplicate no.\\n                    count+=count2+1;\\n                    while(k<right)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                    }\\n                }\\n                else \\n                {\\n//else either both have same distance or b is closer to left index,\\n//in which case, we will swap it, till it reaches left\\'th index\\n                    int k=count1+1+left;\\n//k stores the index of that duplicate no.\\n                    count+=count1+1;\\n                    while(k>left)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        k--;\\n                    }\\n                }\\n\\n            }\\n//decreasing the size of the subarray.\\n            left+=1;\\n            right-=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981753,
                "title": "python-sliding-window-48-time-61-space",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        output = 0\\n        l, r = 0, len(s) - 1\\n\\n        while l < r:\\n            if s[l] != s[r]:\\n                left, right = s[l], s[r]\\n                swap = None\\n                # Find string to match with left boundary\\n                for i in range(l + 1, r):\\n                    if s[i] == right:\\n                        swap = i\\n                        break\\n                # Find string to match with right boundary\\n                for j in range(r - 1, l, -1):\\n                    if s[j] == left and (not swap or swap - l > r - j):\\n                        swap = -j\\n                        break\\n                # If swapping with left boundary\\n                if swap >= 0:\\n                    s = s[0:l] + s[swap] + s[l:swap] + s[swap + 1:]\\n                    output += swap - l\\n                # Else swap with right boundary\\n                else:\\n                    swap = -swap\\n                    s = s[0:swap] + s[swap + 1:r + 1] + s[swap] + s[r + 1:]\\n                    output += r - (swap)\\n            l += 1\\n            r -= 1\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        output = 0\\n        l, r = 0, len(s) - 1\\n\\n        while l < r:\\n            if s[l] != s[r]:\\n                left, right = s[l], s[r]\\n                swap = None\\n                # Find string to match with left boundary\\n                for i in range(l + 1, r):\\n                    if s[i] == right:\\n                        swap = i\\n                        break\\n                # Find string to match with right boundary\\n                for j in range(r - 1, l, -1):\\n                    if s[j] == left and (not swap or swap - l > r - j):\\n                        swap = -j\\n                        break\\n                # If swapping with left boundary\\n                if swap >= 0:\\n                    s = s[0:l] + s[swap] + s[l:swap] + s[swap + 1:]\\n                    output += swap - l\\n                # Else swap with right boundary\\n                else:\\n                    swap = -swap\\n                    s = s[0:swap] + s[swap + 1:r + 1] + s[swap] + s[r + 1:]\\n                    output += r - (swap)\\n            l += 1\\n            r -= 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892996,
                "title": "proof-of-correctness",
                "content": "https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/solutions/1847011/c-2-pointers-with-detail-proof-and-explanation/ gives a fantastic explanation of correctness, complete with beautiful visuals. In this post I provide a mathematical explanation to complement it.\\n\\nLet\\'s discuss the case where $n$ is even for simplicity.\\n\\nWithout loss of generality, we may assume that the characters in the string are distinct. It is obviously never optimal to swap two identical characters, so the relative ordering of identical characters remains unchanged throughout the algorithm. Therefore, we can replace all subsequences like \"a...a..a...a...a....a\" with \"a1...a2..a3...a3...a2....a1\". Let\\'s call the characters \"a\", \"b\", \"c\", ..., for simplicity.\\n\\nAdditionally, we may assume without loss of generality that the final string constructed by our algorithm is \"abc...cba\" by renaming characters  in the final output.\\n\\nCall a *lefty* a tuple $(i, j, k)$ with $0 \\\\le i < j \\\\le k < n / 2$ and $s[i] = s[j]$. Call a *nonversion* a quadruple $(i, j, k, \\\\ell)$ with $0 \\\\le i < j < n/2$, $n/2 \\\\le k < \\\\ell < n$, and $(s[i], s[j]) = (s[k], s[\\\\ell])$. Call the *skew* of a string $s$ the sum of the number of leftys in $s$ and the number of nonversions in $s$.\\n\\nNote that the skew of a palindromic string is zero and that a swap may decrease the skew of a string by at most one, as a swap may eliminate at most one lefty and at most one nonversion, but cannot do so simultaneously. Therefore, it suffices to show that every operation in our algorithm decreases the number of nonversions by one.\\n\\nConsider some stage in the execution of our algorithm, for example:\\n\\n```\\n\"\"\"\\nabcfed|cfedba\\n  |\\n  | Suppose we are on c.\\n\\nWe will make the following series of swaps:\\n\\n    abcfed|cfedba\\n--> abcfed|fcedba\\n--> abcfed|fecdba\\n--> abcfed|fcdcba\\n\"\"\"\\n```\\n\\nDenote by $c$ the character that we are currently swapping. By construction of the algorithm, we will always swap the right instance of $c$ with some lexicographically greater character $d$. The relative ordering of $c$s and $d$s must transform either via $(c_1, c_2, d_1, d_2) \\\\rightsquigarrow (c_1, d_1, c_2, d_2)$ or via $(c_1, d_1, c_2, d_2) \\\\rightsquigarrow (c_1, d_1, d_2, c_2)$. In the former case, the lefty $(c_1, c_2, c_2)$ is eliminated, and in the latter case, the nonversion $(c_1, d_1, c_2, d_2)$ is eliminated. In both cases, the skew of the string decreases by one.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nabcfed|cfedba\\n  |\\n  | Suppose we are on c.\\n\\nWe will make the following series of swaps:\\n\\n    abcfed|cfedba\\n--> abcfed|fcedba\\n--> abcfed|fecdba\\n--> abcfed|fcdcba\\n\"\"\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819524,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800512,
                "title": "easy-to-understand-2-pointer-solution",
                "content": "# Intuition\\nStart on the outer corners, moving in from left and right, and do the min swaps needed to make them the same.\\n\\n# Approach\\nAt each iteration we find the number of swaps needed to make s[i] == s[j] from the right and from the left. Then we simply do our swaps from the side requiring the least.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\'\\'\\'\\n            Intuition: Start on the outer corners, moving in from left and right, and do min swaps to make them the same.\\n\\n            Spacetime: O(n)\\n            Runtime: O(n^2)\\n        \\'\\'\\'\\n\\n        i, j = 0, len(s) - 1\\n        sArr = list(s)\\n        swaps = 0\\n\\n        while i < j:\\n            if sArr[i] != sArr[j]:\\n                minSwapsI = math.inf # min swaps needed to get i the same as position j\\n                minSwapsJ = math.inf\\n\\n                # get min swaps needed to make pos i == pos j\\n                for k in range(i+1,j):\\n                    if sArr[k] == sArr[j]:\\n                        minSwapsI = k - i\\n                        break\\n\\n                # get min swaps needed to make pos j == pos i\\n                for k in range(j-1, i, -1):\\n                    if sArr[k] == sArr[i]:\\n                        minSwapsJ = j - k\\n                        break\\n                \\n                # make min swaps needed\\n                if minSwapsI < minSwapsJ:\\n                    for k in range(i + minSwapsI, i, -1):\\n                        sArr[k-1], sArr[k] = sArr[k], sArr[k-1]\\n                else:\\n                    for k in range(j - minSwapsJ, j):\\n                        sArr[k+1], sArr[k] = sArr[k], sArr[k+1]\\n                \\n                swaps += min(minSwapsI, minSwapsJ) # update swap count\\n\\n            # update pointers\\n            i += 1\\n            j -= 1\\n\\n        return swaps\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\'\\'\\'\\n            Intuition: Start on the outer corners, moving in from left and right, and do min swaps to make them the same.\\n\\n            Spacetime: O(n)\\n            Runtime: O(n^2)\\n        \\'\\'\\'\\n\\n        i, j = 0, len(s) - 1\\n        sArr = list(s)\\n        swaps = 0\\n\\n        while i < j:\\n            if sArr[i] != sArr[j]:\\n                minSwapsI = math.inf # min swaps needed to get i the same as position j\\n                minSwapsJ = math.inf\\n\\n                # get min swaps needed to make pos i == pos j\\n                for k in range(i+1,j):\\n                    if sArr[k] == sArr[j]:\\n                        minSwapsI = k - i\\n                        break\\n\\n                # get min swaps needed to make pos j == pos i\\n                for k in range(j-1, i, -1):\\n                    if sArr[k] == sArr[i]:\\n                        minSwapsJ = j - k\\n                        break\\n                \\n                # make min swaps needed\\n                if minSwapsI < minSwapsJ:\\n                    for k in range(i + minSwapsI, i, -1):\\n                        sArr[k-1], sArr[k] = sArr[k], sArr[k-1]\\n                else:\\n                    for k in range(j - minSwapsJ, j):\\n                        sArr[k+1], sArr[k] = sArr[k], sArr[k+1]\\n                \\n                swaps += min(minSwapsI, minSwapsJ) # update swap count\\n\\n            # update pointers\\n            i += 1\\n            j -= 1\\n\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759000,
                "title": "c-solution-greedy",
                "content": "```\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s), minMoves = 0, idx = 0;\\n\\n    while(len > 0) {\\n        char  *ret = strchr(s, s[len - 1]);\\n        int pos = ret - s;\\n    \\n        if(pos == len - 1) {\\n            minMoves += pos / 2;\\n        } else {\\n            minMoves += pos;\\n            memmove(&s[pos], &s[pos+1], len - pos);     // remove the matched char from string\\n            -- len;\\n        }\\n        \\n        if(len > 0)                                     // remove the last char from string\\n            s[len-1] = \\'\\\\0\\';\\n        --len;    \\n    }\\n    return minMoves;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s), minMoves = 0, idx = 0;\\n\\n    while(len > 0) {\\n        char  *ret = strchr(s, s[len - 1]);\\n        int pos = ret - s;\\n    \\n        if(pos == len - 1) {\\n            minMoves += pos / 2;\\n        } else {\\n            minMoves += pos;\\n            memmove(&s[pos], &s[pos+1], len - pos);     // remove the matched char from string\\n            -- len;\\n        }\\n        \\n        if(len > 0)                                     // remove the last char from string\\n            s[len-1] = \\'\\\\0\\';\\n        --len;    \\n    }\\n    return minMoves;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727642,
                "title": "java-o-n-2",
                "content": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        int ans = 0;\\n        for(int i=0; i<len/2; i++){\\n            int j = s.length()-1;\\n            int count = 0;\\n            while(s.charAt(j) != s.charAt(0)){\\n                j--;\\n                count++;\\n            }\\n            if(j==0){\\n                s = s.substring(1);\\n                ans += (s.length()/2);\\n            }\\n            else{\\n               s = s.substring(1, j)+s.substring(j+1);\\n               ans += count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        int ans = 0;\\n        for(int i=0; i<len/2; i++){\\n            int j = s.length()-1;\\n            int count = 0;\\n            while(s.charAt(j) != s.charAt(0)){\\n                j--;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2702477,
                "title": "two-pointers-chararray",
                "content": "# Intuition\\nTraverse an array of chars, swaping them until they match in pairs.\\n\\n# Approach\\nThe array is traversed until the first pointer is equal to the lenght. The first pointer will be increased only when the chars of the two pointers are the same.\\nWhile traversing, the chars in the index pointers are compared and the different ones are swaped by the rightmost one.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n\\npublic int MinMovesToMakePalindrome(String s)\\n        {\\n            var ans = 0;\\n            var firstPointer = 0;\\n            var end = s.Length - 1;\\n            char[] ch = s.ToCharArray();\\n\\n            //Do not even start to make swaps\\n            if (CanFormPalindrome(s) == false) \\n                return -1;\\n\\n            while (firstPointer < end)\\n            {\\n                var secondPointer = end;\\n                if (ch[firstPointer] == ch[end])\\n                {\\n                    firstPointer++; // first char will remain in the same index, so it will be ignored \\n                    end--; // last char will remain in the same index so it will be ignored \\n\\n                    continue;\\n                }\\n\\n                while (ch[firstPointer] != ch[secondPointer])\\n                {\\n                    secondPointer--; //decreasing until find the same chars between the two pointers\\n                }\\n\\n\\n                if (firstPointer == secondPointer) //If both reach the same index, swap the chars so it never get stucked in a infinite loop\\n                {\\n                    Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                    ans++;\\n                }\\n                else\\n                {\\n                    while (secondPointer < end)\\n                    {\\n                        Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                        ans++;\\n                        secondPointer++;\\n                    }\\n                }\\n            }\\n\\n\\n            return ans;\\n        }\\n\\n        static void Swap(char[] ch, int i, int j)\\n        {\\n            var temp = ch[i];\\n            ch[i] = ch[j];\\n            ch[j] = temp;\\n        }\\n\\n        static bool CanFormPalindrome(string str)\\n        {\\n            int NO_OF_CHARS = 256;\\n\\n            // Create a count array and initialize all\\n            // values as 0\\n            int[] count = new int[NO_OF_CHARS];\\n            Array.Fill(count, 0);\\n\\n            // For each character in input strings,\\n            // increment count in the corresponding\\n            // count array\\n            for (int i = 0; i < str.Length; i++)\\n            {\\n                count[(int)(str[i])]++;\\n            }\\n\\n            // Count odd occurring characters\\n            int odd = 0;\\n            for (int i = 0; i < NO_OF_CHARS; i++)\\n            {\\n                if ((count[i] & 1) == 1)\\n                    odd++;\\n\\n                if (odd > 1)\\n                    return false;\\n            }\\n\\n            // Return true if odd count is 0 or 1,\\n            return true;\\n        }\\n        \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\npublic int MinMovesToMakePalindrome(String s)\\n        {\\n            var ans = 0;\\n            var firstPointer = 0;\\n            var end = s.Length - 1;\\n            char[] ch = s.ToCharArray();\\n\\n            //Do not even start to make swaps\\n            if (CanFormPalindrome(s) == false) \\n                return -1;\\n\\n            while (firstPointer < end)\\n            {\\n                var secondPointer = end;\\n                if (ch[firstPointer] == ch[end])\\n                {\\n                    firstPointer++; // first char will remain in the same index, so it will be ignored \\n                    end--; // last char will remain in the same index so it will be ignored \\n\\n                    continue;\\n                }\\n\\n                while (ch[firstPointer] != ch[secondPointer])\\n                {\\n                    secondPointer--; //decreasing until find the same chars between the two pointers\\n                }\\n\\n\\n                if (firstPointer == secondPointer) //If both reach the same index, swap the chars so it never get stucked in a infinite loop\\n                {\\n                    Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                    ans++;\\n                }\\n                else\\n                {\\n                    while (secondPointer < end)\\n                    {\\n                        Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                        ans++;\\n                        secondPointer++;\\n                    }\\n                }\\n            }\\n\\n\\n            return ans;\\n        }\\n\\n        static void Swap(char[] ch, int i, int j)\\n        {\\n            var temp = ch[i];\\n            ch[i] = ch[j];\\n            ch[j] = temp;\\n        }\\n\\n        static bool CanFormPalindrome(string str)\\n        {\\n            int NO_OF_CHARS = 256;\\n\\n            // Create a count array and initialize all\\n            // values as 0\\n            int[] count = new int[NO_OF_CHARS];\\n            Array.Fill(count, 0);\\n\\n            // For each character in input strings,\\n            // increment count in the corresponding\\n            // count array\\n            for (int i = 0; i < str.Length; i++)\\n            {\\n                count[(int)(str[i])]++;\\n            }\\n\\n            // Count odd occurring characters\\n            int odd = 0;\\n            for (int i = 0; i < NO_OF_CHARS; i++)\\n            {\\n                if ((count[i] & 1) == 1)\\n                    odd++;\\n\\n                if (odd > 1)\\n                    return false;\\n            }\\n\\n            // Return true if odd count is 0 or 1,\\n            return true;\\n        }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689790,
                "title": "python3-two-pointer-greedy-approach",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        left,right=0,n-1\\n        ans=0\\n        while left<=right:\\n            if s[left]!=s[right]:\\n                ind1=right\\n                while left<=ind1 and s[ind1]!=s[left]:\\n                    ind1-=1\\n                ind2=left\\n                while right>=ind2 and s[ind2]!=s[right]:\\n                    ind2+=1\\n                leftShift=right-ind1\\n                rightShift=ind2-left\\n                if leftShift<=rightShift:\\n                    s=s[:ind1]+s[ind1+1:right+1]+s[ind1]+s[right+1:]\\n                    ans+=leftShift\\n                else:\\n                    s=s[:left]+s[ind2]+s[left:ind2]+s[ind2+1:]\\n                    ans+=rightShift\\n            left+=1\\n            right-=1\\n        return ans\\n            \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        left,right=0,n-1\\n        ans=0\\n        while left<=right:\\n            if s[left]!=s[right]:\\n                ind1=right\\n                while left<=ind1 and s[ind1]!=s[left]:\\n                    ind1-=1\\n                ind2=left\\n                while right>=ind2 and s[ind2]!=s[right]:\\n                    ind2+=1\\n                leftShift=right-ind1\\n                rightShift=ind2-left\\n                if leftShift<=rightShift:\\n                    s=s[:ind1]+s[ind1+1:right+1]+s[ind1]+s[right+1:]\\n                    ans+=leftShift\\n                else:\\n                    s=s[:left]+s[ind2]+s[left:ind2]+s[ind2+1:]\\n                    ans+=rightShift\\n            left+=1\\n            right-=1\\n        return ans\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668217,
                "title": "javascript-2-pointer-like-bubble-sort",
                "content": "```\\nvar minMovesToMakePalindrome = function(str) {\\n  if (str.length < 2) return 0;\\n  \\n  const s = str.split(\\'\\'), mid = Math.floor(str.length / 2);\\n  let l = 0, r = s.length - 1, res = 0, midMisplacedIdx = -1;\\n  \\n  while (l < r) {\\n    if (s[l] !== s[r]) {\\n      // Here we need swapping as both the chars are not equal\\n      // We start from the right at position (r - 1) till (l + 1) to find a match for s[l]\\n\\t  // We need the value of i after the loop ends, so not assigning it within the loop initiation\\n      let i = r - 1;\\n      for (; i > l; i--) {\\n        if (s[l] === s[i]) {\\n          bubbleUp(s, i, r);\\n          res += (r - i);\\n          break;\\n        }\\n      }\\n      \\n      // If no match is found till s[l], we know that this is the mid value for an odd lengthed palindrome\\n      // Since mid remains unique in odd lengthed palindrome, we store its index for future,\\n      // skip working on s[l] and continue to the next iteration (here we\\'re also avoiding making any change to r)\\n      if (i === l) {\\n        midMisplacedIdx = l;\\n        l++;\\n        continue;\\n      }\\n    }\\n    \\n    l++;\\n    r--;\\n  }\\n  \\n  // At the end, we move s[midMisplacedIdx] to mid and compute the swap count as (mid - l)\\n  // We don\\'t have to swap here as we\\'re only interested in the count\\n  if (midMisplacedIdx >= 0 && midMisplacedIdx < mid) {\\n    bubbleUp(s, midMisplacedIdx, mid); // can be skipped\\n    res += (mid - midMisplacedIdx);\\n  }\\n  \\n  return res;\\n};\\n\\n// Better call it sifting or bubbling to the right but the question calls this swap\\n// We\\'re basically bubbling an item from one index to the other towards its right\\nfunction bubbleUp(arr, from, to) {\\n  for (let i = from; i < to; i++) {\\n    [arr[i],arr[i + 1]] = [arr[i + 1],arr[i]];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nvar minMovesToMakePalindrome = function(str) {\\n  if (str.length < 2) return 0;\\n  \\n  const s = str.split(\\'\\'), mid = Math.floor(str.length / 2);\\n  let l = 0, r = s.length - 1, res = 0, midMisplacedIdx = -1;\\n  \\n  while (l < r) {\\n    if (s[l] !== s[r]) {\\n      // Here we need swapping as both the chars are not equal\\n      // We start from the right at position (r - 1) till (l + 1) to find a match for s[l]\\n\\t  // We need the value of i after the loop ends, so not assigning it within the loop initiation\\n      let i = r - 1;\\n      for (; i > l; i--) {\\n        if (s[l] === s[i]) {\\n          bubbleUp(s, i, r);\\n          res += (r - i);\\n          break;\\n        }\\n      }\\n      \\n      // If no match is found till s[l], we know that this is the mid value for an odd lengthed palindrome\\n      // Since mid remains unique in odd lengthed palindrome, we store its index for future,\\n      // skip working on s[l] and continue to the next iteration (here we\\'re also avoiding making any change to r)\\n      if (i === l) {\\n        midMisplacedIdx = l;\\n        l++;\\n        continue;\\n      }\\n    }\\n    \\n    l++;\\n    r--;\\n  }\\n  \\n  // At the end, we move s[midMisplacedIdx] to mid and compute the swap count as (mid - l)\\n  // We don\\'t have to swap here as we\\'re only interested in the count\\n  if (midMisplacedIdx >= 0 && midMisplacedIdx < mid) {\\n    bubbleUp(s, midMisplacedIdx, mid); // can be skipped\\n    res += (mid - midMisplacedIdx);\\n  }\\n  \\n  return res;\\n};\\n\\n// Better call it sifting or bubbling to the right but the question calls this swap\\n// We\\'re basically bubbling an item from one index to the other towards its right\\nfunction bubbleUp(arr, from, to) {\\n  for (let i = from; i < to; i++) {\\n    [arr[i],arr[i + 1]] = [arr[i + 1],arr[i]];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2662747,
                "title": "java-solution-using-string-builder",
                "content": "```\\n    public int minMovesToMakePalindrome(String s) {\\n        int result = 0;\\n\\n        // using stringbuilder to be efficient. \\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int end = sb.length() - 1;\\n\\n        while(end > 0){\\n            char lastChar = sb.charAt(end);\\n\\n            // finding the first index of the last char\\n            int firstIdx = sb.indexOf(String.valueOf(lastChar));\\n\\n            // if the last char appears only once we need to move it to the middle of the string.\\n            if(firstIdx == end){\\n                result += end / 2;\\n            }\\n            // else it should be move to the begining of the string to become palindrome.\\n            else{\\n                result += firstIdx;\\n            }\\n\\n            // removing the end char to consider next char. \\n            sb.deleteCharAt(end);\\n\\n            // if char appears more than once then remove the first index.\\n            if(firstIdx != end){\\n                end--;\\n                sb.deleteCharAt(firstIdx);\\n            }\\n\\n            end--;\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minMovesToMakePalindrome(String s) {\\n        int result = 0;\\n\\n        // using stringbuilder to be efficient. \\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int end = sb.length() - 1;\\n\\n        while(end > 0){\\n            char lastChar = sb.charAt(end);\\n\\n            // finding the first index of the last char\\n            int firstIdx = sb.indexOf(String.valueOf(lastChar));\\n\\n            // if the last char appears only once we need to move it to the middle of the string.\\n            if(firstIdx == end){\\n                result += end / 2;\\n            }\\n            // else it should be move to the begining of the string to become palindrome.\\n            else{\\n                result += firstIdx;\\n            }\\n\\n            // removing the end char to consider next char. \\n            sb.deleteCharAt(end);\\n\\n            // if char appears more than once then remove the first index.\\n            if(firstIdx != end){\\n                end--;\\n                sb.deleteCharAt(firstIdx);\\n            }\\n\\n            end--;\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643335,
                "title": "java-easy-it-depends-on-you",
                "content": "```\\nclass Solution {\\n  public static void swap(char arr[],int i,int j){\\n        \\n        char temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char strarr[]=s.toCharArray();\\n        int i=0; \\n        int j=strarr.length-1;\\n        while(i<j){\\n            int r=j;\\n            if(strarr[i]==strarr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(strarr[i]!=strarr[r]){\\n                    r--;\\n                }\\n                \\n                if(i==r){\\n                   swap(strarr,r,r+1);\\n                   ans++;\\n                   continue;\\n                 }               \\n                else{\\n                 while(r<j){  \\n                    swap(strarr,r,r+1);\\n                    ans++;\\n                    r++;\\n                }\\n              }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public static void swap(char arr[],int i,int j){\\n        \\n        char temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char strarr[]=s.toCharArray();\\n        int i=0; \\n        int j=strarr.length-1;\\n        while(i<j){\\n            int r=j;\\n            if(strarr[i]==strarr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(strarr[i]!=strarr[r]){\\n                    r--;\\n                }\\n                \\n                if(i==r){\\n                   swap(strarr,r,r+1);\\n                   ans++;\\n                   continue;\\n                 }               \\n                else{\\n                 while(r<j){  \\n                    swap(strarr,r,r+1);\\n                    ans++;\\n                    r++;\\n                }\\n              }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616060,
                "title": "simple-java-solution-with-explanation-greedy-with-simulation",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int count = 0, rightLimit = arr.length - 1, oddIndex = -1;\\n        // simulation: for avery element in the string find the nearest right-most compliment \\n        // and make the extremeties a palindrome like : b[a]......[a]...b -> ba.........ab\\n        // continue inwards until you reach the centre of the string\\n        for (int left = 0; left < arr.length / 2; left++) {\\n            // assume that the current character is single occuring character\\n            oddIndex = (oddIndex == -1 ? left : oddIndex); \\n            for (int right = rightLimit; right > left; right--) {\\n                if (arr[right] == arr[left]) {\\n                    // refute assumption that the current character is single occuring character\\n                    oddIndex = (oddIndex == left ? -1 : oddIndex);\\n                    // swap current right counterpart to make extremes palindrome\\n                    // count the number of swaps required in the process and add to answer\\n                    count += swapChars(arr, right, rightLimit);\\n                    // reduce the right limit, this implies (rightLimit - endOfString] is now a palindrome\\n                    rightLimit--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (oddIndex != -1) {\\n            // if the oddIndex has a non-negative value\\n            // swap it to the centre of the string and account for those swaps\\n            count += swapChars(arr, oddIndex, arr.length / 2);\\n        }\\n        return count;\\n    }\\n    \\n    // simulate swapping, move 1 character each to the left in the given range\\n    // and then replace the final character with the first character\\n    int swapChars(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        for (int i = left; i < right; i++) arr[i] = arr[i + 1];\\n        arr[right] = temp;\\n        return right - left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int count = 0, rightLimit = arr.length - 1, oddIndex = -1;\\n        // simulation: for avery element in the string find the nearest right-most compliment \\n        // and make the extremeties a palindrome like : b[a]......[a]...b -> ba.........ab\\n        // continue inwards until you reach the centre of the string\\n        for (int left = 0; left < arr.length / 2; left++) {\\n            // assume that the current character is single occuring character\\n            oddIndex = (oddIndex == -1 ? left : oddIndex); \\n            for (int right = rightLimit; right > left; right--) {\\n                if (arr[right] == arr[left]) {\\n                    // refute assumption that the current character is single occuring character\\n                    oddIndex = (oddIndex == left ? -1 : oddIndex);\\n                    // swap current right counterpart to make extremes palindrome\\n                    // count the number of swaps required in the process and add to answer\\n                    count += swapChars(arr, right, rightLimit);\\n                    // reduce the right limit, this implies (rightLimit - endOfString] is now a palindrome\\n                    rightLimit--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (oddIndex != -1) {\\n            // if the oddIndex has a non-negative value\\n            // swap it to the centre of the string and account for those swaps\\n            count += swapChars(arr, oddIndex, arr.length / 2);\\n        }\\n        return count;\\n    }\\n    \\n    // simulate swapping, move 1 character each to the left in the given range\\n    // and then replace the final character with the first character\\n    int swapChars(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        for (int i = left; i < right; i++) arr[i] = arr[i + 1];\\n        arr[right] = temp;\\n        return right - left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607435,
                "title": "python-o-nlogn-by-counting-inversions-in-a-permutation",
                "content": "Enumerate all characters of the string and represent target palindrome as permutation of indices of characters of the original string. Number of moves is going to be equal then to the number of inversions in the permutation (See [Permutation Inversion](https://mathworld.wolfram.com/PermutationInversion.html))\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        # Calculate the permutation\\n        \\n        count = Counter(s)\\n        p = []\\n        v = [-1] * len(s) # List v will represent the permutation\\n        j = 0\\n        for i, c in enumerate(s):\\n            if count[c] > 1:\\n                p.append(c)\\n                v[i] = j \\n                j += 1\\n            elif count[c] == 1: # The character that is not paired with another equal character will go to the center of the palindrome\\n                v[i] = len(s) // 2       \\n            count[c] -= 2\\n                \\n        j = (len(s) + 1) // 2\\n                \\n        p.reverse()\\n        d = defaultdict(list)\\n        for c in p:\\n            d[c].append(j)\\n            j += 1\\n        \\n        for i in range(len(v))[::-1]:\\n            if v[i] == -1:\\n                v[i] = d[s[i]].pop()\\n                \\n        # Count number of inversions in the permutation\\n        \\n        u = SortedList()\\n        r = 0\\n        v.reverse()\\n        for j in v:\\n            r += u.bisect_right(j)\\n            u.add(j)\\n            \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        # Calculate the permutation\\n        \\n        count = Counter(s)\\n        p = []\\n        v = [-1] * len(s) # List v will represent the permutation\\n        j = 0\\n        for i, c in enumerate(s):\\n            if count[c] > 1:\\n                p.append(c)\\n                v[i] = j \\n                j += 1\\n            elif count[c] == 1: # The character that is not paired with another equal character will go to the center of the palindrome\\n                v[i] = len(s) // 2       \\n            count[c] -= 2\\n                \\n        j = (len(s) + 1) // 2\\n                \\n        p.reverse()\\n        d = defaultdict(list)\\n        for c in p:\\n            d[c].append(j)\\n            j += 1\\n        \\n        for i in range(len(v))[::-1]:\\n            if v[i] == -1:\\n                v[i] = d[s[i]].pop()\\n                \\n        # Count number of inversions in the permutation\\n        \\n        u = SortedList()\\n        r = 0\\n        v.reverse()\\n        for j in v:\\n            r += u.bisect_right(j)\\n            u.add(j)\\n            \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598453,
                "title": "greedy-approach-explained-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        if(s.length() < 3) return 0;\\n\\t\\t// here we are thinking to finding every character that is nearest and then shifting it to that position to make palindrome \\n        int pt1 = 0;\\n        int pt2 = s.length()-1;\\n        int ans = 0;\\n        int tpl = 0 , tpr = pt2; // to store temporary pointer left and right ...\\n        while(pt1 < pt2){\\n            // if both end have not same character then come inside and make it same \\n            if(s[pt1] != s[pt2]){\\n                // search in left for right end character and in right leftmost character\\n                tpl = pt1 + 1;\\n                tpr = pt2 - 1;\\n                // bool to store which pointer found the character in first\\n                bool l = 0 , r = 0;\\n                while(tpl < pt2 && tpr > pt1){\\n                    if(s[tpl] == s[pt2]){\\n                        l = 1;\\n                        break;\\n                    }\\n                    if(s[tpr] == s[pt1]){\\n                        r = 1;\\n                        break;\\n                    }\\n                    tpl++;\\n                    tpr--;\\n                }\\n                // found\\n                if(l){\\n                    // Here if left pointer found character so we have to shift characters to right\\n                    int t = tpl;\\n                    // shifting characters\\n                    while(t > pt1){ s[t] = s[t-1]; ans++; t--;}\\n                    // finally changing pt1 character to pt2 as this character if found\\n                    s[pt1] = s[pt2];\\n                }else{\\n                    // Here if right pointer found character so we have to shift characters to left\\n                    int t = tpr;\\n                    while(t < pt2){ s[t] = s[t+1]; ans++; t++;}\\n                    s[pt2] = s[pt1];\\n                }\\n            }\\n            pt1++;\\n            pt2--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        if(s.length() < 3) return 0;\\n\\t\\t// here we are thinking to finding every character that is nearest and then shifting it to that position to make palindrome \\n        int pt1 = 0;\\n        int pt2 = s.length()-1;\\n        int ans = 0;\\n        int tpl = 0 , tpr = pt2; // to store temporary pointer left and right ...\\n        while(pt1 < pt2){\\n            // if both end have not same character then come inside and make it same \\n            if(s[pt1] != s[pt2]){\\n                // search in left for right end character and in right leftmost character\\n                tpl = pt1 + 1;\\n                tpr = pt2 - 1;\\n                // bool to store which pointer found the character in first\\n                bool l = 0 , r = 0;\\n                while(tpl < pt2 && tpr > pt1){\\n                    if(s[tpl] == s[pt2]){\\n                        l = 1;\\n                        break;\\n                    }\\n                    if(s[tpr] == s[pt1]){\\n                        r = 1;\\n                        break;\\n                    }\\n                    tpl++;\\n                    tpr--;\\n                }\\n                // found\\n                if(l){\\n                    // Here if left pointer found character so we have to shift characters to right\\n                    int t = tpl;\\n                    // shifting characters\\n                    while(t > pt1){ s[t] = s[t-1]; ans++; t--;}\\n                    // finally changing pt1 character to pt2 as this character if found\\n                    s[pt1] = s[pt2];\\n                }else{\\n                    // Here if right pointer found character so we have to shift characters to left\\n                    int t = tpr;\\n                    while(t < pt2){ s[t] = s[t+1]; ans++; t++;}\\n                    s[pt2] = s[pt1];\\n                }\\n            }\\n            pt1++;\\n            pt2--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565218,
                "title": "java-simple-solution-greedy-intuitive-approach",
                "content": "```\\nclass Solution {\\n    public int find(char[] sArr, char key, int from, int to){\\n        for(int i=from;i<=to; i++){\\n            if(key == sArr[i])\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public void swap(char[] sArr, int i, int j){\\n        char t = sArr[i];\\n        sArr[i] = sArr[j];\\n        sArr[j] = t;\\n    }\\n    public void shift(char[] sArr, int from, int to){\\n        for(int i=from;i>to;i--){\\n            swap(sArr, i, i-1);\\n        }\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] sArr = s.toCharArray();\\n        int n = sArr.length;\\n        int left = 0;\\n        int right = sArr.length-1;\\n        int ans = 0;\\n        while(left<right){\\n            int index = find(sArr, sArr[right], left, right);\\n            if(index == right){\\n                ans += right-n/2;\\n                right--;\\n            }\\n            else{\\n                shift(sArr, index, left);\\n                ans += index-left;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int find(char[] sArr, char key, int from, int to){\\n        for(int i=from;i<=to; i++){\\n            if(key == sArr[i])\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public void swap(char[] sArr, int i, int j){\\n        char t = sArr[i];\\n        sArr[i] = sArr[j];\\n        sArr[j] = t;\\n    }\\n    public void shift(char[] sArr, int from, int to){\\n        for(int i=from;i>to;i--){\\n            swap(sArr, i, i-1);\\n        }\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] sArr = s.toCharArray();\\n        int n = sArr.length;\\n        int left = 0;\\n        int right = sArr.length-1;\\n        int ans = 0;\\n        while(left<right){\\n            int index = find(sArr, sArr[right], left, right);\\n            if(index == right){\\n                ans += right-n/2;\\n                right--;\\n            }\\n            else{\\n                shift(sArr, index, left);\\n                ans += index-left;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551292,
                "title": "simple-to-understand-two-pointer",
                "content": "\\nWe don\\'t care to actually do the swap. \\nAll we need to do is figure out how far away from the end it is.\\nThe only edge case, since the prompt gaurantees a palindrome, is an odd palindrome, which means the character that has no duplicate will need to be at the center.\\n\\n\\n\\n\\n\\n\\n```\\nA = 0\\n# if length == 1, then no swaps needed\\nwhile len(s) > 1:\\n\\t#grab first character\\n\\tletter = s[0]\\n\\t#loop backwards to ensure we grab min swap character\\n\\tfor i in range(len(s)-1,-1,-1):\\n\\t\\t#we\\'ve found the closest character to the end to swap\\n\\t\\tif s[i] == letter and i != 0:\\n\\t\\t\\t#get our new string excluding the two same characters, and add to our total\\n\\t\\t\\tA += (len(s) - i - 1)\\n\\t\\t\\ts = s[1:i] + s[i+1:]\\n\\t\\t\\tbreak\\n\\t\\t#odd palindrome case, just add distance from center to our total and remove it\\n        if i == 0:\\n\\t\\t\\tcenter = len(s) // 2\\n\\t\\t\\tA += center\\n\\t\\t\\ts = s[1:]\\n\\t\\t\\tbreak\\nreturn A\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nA = 0\\n# if length == 1, then no swaps needed\\nwhile len(s) > 1:\\n\\t#grab first character\\n\\tletter = s[0]\\n\\t#loop backwards to ensure we grab min swap character\\n\\tfor i in range(len(s)-1,-1,-1):\\n\\t\\t#we\\'ve found the closest character to the end to swap\\n\\t\\tif s[i] == letter and i != 0:\\n\\t\\t\\t#get our new string excluding the two same characters, and add to our total\\n\\t\\t\\tA += (len(s) - i - 1)\\n\\t\\t\\ts = s[1:i] + s[i+1:]\\n\\t\\t\\tbreak\\n\\t\\t#odd palindrome case, just add distance from center to our total and remove it\\n        if i == 0:\\n\\t\\t\\tcenter = len(s) // 2\\n\\t\\t\\tA += center\\n\\t\\t\\ts = s[1:]\\n\\t\\t\\tbreak\\nreturn A\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545661,
                "title": "accepted-java-two-pointers-with-simple-explanation",
                "content": "Just maintain two pointers for the String,\\nFor every character at position i there has got to be a corresponding char at pos j same as that of i so we find this char towrads the left of j and when we find it we bring this at position j and increment the number of swaps accordingly.\\nIf we do not find any other char to the left of j other than i itself this means that the char at i occurs just once and this will inturn be the middle character of the palindrome so we swap it with i+1 th char and move forward.\\n\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr=s.toCharArray();\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length()/2;i++){\\n            int j=s.length()-1-i;\\n            \\n            while(arr[i]!=arr[j]){\\n                j--;\\n            }\\n             int swaps=0;\\n            if(j==i){ //condn where char at i will be middle elem.\\n                char c=arr[i];\\n                arr[i]=arr[i+1];\\n                arr[i+1]=c;\\n                swaps++;\\n                i--;\\n            }else{\\n           \\n            for(int x=j;x<s.length()-1-i;x++){\\n                arr[x]=arr[x+1];\\n                swaps++;\\n            }\\n            arr[s.length()-1-i]=arr[i];\\n            }\\n            ans+=swaps;\\n         \\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr=s.toCharArray();\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length()/2;i++){\\n            int j=s.length()-1-i;\\n            \\n            while(arr[i]!=arr[j]){\\n                j--;\\n            }\\n             int swaps=0;\\n            if(j==i){ //condn where char at i will be middle elem.\\n                char c=arr[i];\\n                arr[i]=arr[i+1];\\n                arr[i+1]=c;\\n                swaps++;\\n                i--;\\n            }else{\\n           \\n            for(int x=j;x<s.length()-1-i;x++){\\n                arr[x]=arr[x+1];\\n                swaps++;\\n            }\\n            arr[s.length()-1-i]=arr[i];\\n            }\\n            ans+=swaps;\\n         \\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517633,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int result = 0;\\n        int left = 0, right = s.length()-1;\\n        while(left < right) {\\n            int l = left, r = right;\\n            while(s[l] != s[r])\\n                r--;\\n            // if the element we reached is the middle element then take the element to the adjacent index\\n            if(l == r) {\\n                swap(s[r], s[r+1]);\\n                result++;\\n                continue;\\n            } \\n            // if the element is a normal element then set it to its right position\\n            else {\\n                while(r < right) {\\n                    swap(s[r], s[r+1]);\\n                    r++;\\n                    result++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int result = 0;\\n        int left = 0, right = s.length()-1;\\n        while(left < right) {\\n            int l = left, r = right;\\n            while(s[l] != s[r])\\n                r--;\\n            // if the element we reached is the middle element then take the element to the adjacent index\\n            if(l == r) {\\n                swap(s[r], s[r+1]);\\n                result++;\\n                continue;\\n            } \\n            // if the element is a normal element then set it to its right position\\n            else {\\n                while(r < right) {\\n                    swap(s[r], s[r+1]);\\n                    r++;\\n                    result++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500675,
                "title": "python-bfs-tle-and-greedy-two-pointers-solution",
                "content": "```\\nimport collections\\n\\nclass Solution:\\n    # BFS TLE\\n    # def minMovesToMakePalindrome(self, s: str) -> int:\\n    #     queue = collections.deque()\\n    #     queue.append((s, 0))\\n    #     seen = set()\\n    #     while queue:\\n    #         text, operation = queue.popleft()\\n    #         if text in seen:\\n    #             continue\\n    #         if text == text[::-1]:\\n    #             return operation\\n    #         seen.add(text)\\n    #         for i in range(len(text)-1):\\n    #             new_text = text[:i] + text[i+1] + text[i] + text[i+2:]\\n    #             if new_text not in seen:\\n    #                 queue.append((new_text, operation+1))\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                while s[left] != s[j]:\\n                    j -= 1\\n                      \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x], s[x+1] = s[x+1], s[x]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x], s[x-1] = s[x-1], s[x]  \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    # BFS TLE\\n    # def minMovesToMakePalindrome(self, s: str) -> int:\\n    #     queue = collections.deque()\\n    #     queue.append((s, 0))\\n    #     seen = set()\\n    #     while queue:\\n    #         text, operation = queue.popleft()\\n    #         if text in seen:\\n    #             continue\\n    #         if text == text[::-1]:\\n    #             return operation\\n    #         seen.add(text)\\n    #         for i in range(len(text)-1):\\n    #             new_text = text[:i] + text[i+1] + text[i] + text[i+2:]\\n    #             if new_text not in seen:\\n    #                 queue.append((new_text, operation+1))\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                while s[left] != s[j]:\\n                    j -= 1\\n                      \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x], s[x+1] = s[x+1], s[x]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x], s[x-1] = s[x-1], s[x]  \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454656,
                "title": "two-pointer-greedy-approach",
                "content": "```\\n public int minMovesToMakePalindrome(String s) {\\n        int lo = 0;\\n        int hi = s.length() - 1;\\n        int ans = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while (lo < hi) {\\n            \\n            if (sb.charAt(lo) == sb.charAt(hi)) {\\n                lo++;\\n                hi--;\\n                continue;\\n            }\\n            int l = lo + 1;\\n            int h = hi - 1;\\n            \\n            while (sb.charAt(l) != sb.charAt(hi)) {\\n                l++;\\n            } \\n            \\n            while (sb.charAt(h) != sb.charAt(lo)) {\\n                h--;\\n            }\\n            //Can also be done using Arrays while bubbling the value to the position\\n            if (l - lo < hi - h) {\\n                sb.insert(lo, sb.charAt(l));\\n                sb.deleteCharAt(l + 1);\\n                ans += l - lo;\\n            } else {\\n                sb.insert(hi + 1, sb.charAt(h));\\n                sb.deleteCharAt(h);\\n                ans += hi - h;\\n            }\\n            lo++;\\n            hi--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n public int minMovesToMakePalindrome(String s) {\\n        int lo = 0;\\n        int hi = s.length() - 1;\\n        int ans = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while (lo < hi) {\\n            \\n            if (sb.charAt(lo) == sb.charAt(hi)) {\\n                lo++;\\n                hi--;\\n                continue;\\n            }\\n            int l = lo + 1;\\n            int h = hi - 1;\\n            \\n            while (sb.charAt(l) != sb.charAt(hi)) {\\n                l++;\\n            } \\n            \\n            while (sb.charAt(h) != sb.charAt(lo)) {\\n                h--;\\n            }\\n            //Can also be done using Arrays while bubbling the value to the position\\n            if (l - lo < hi - h) {\\n                sb.insert(lo, sb.charAt(l));\\n                sb.deleteCharAt(l + 1);\\n                ans += l - lo;\\n            } else {\\n                sb.insert(hi + 1, sb.charAt(h));\\n                sb.deleteCharAt(h);\\n                ans += hi - h;\\n            }\\n            lo++;\\n            hi--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2448331,
                "title": "java-detail-explained-greedy-solution",
                "content": "```\\n    //Greedy strategy to check one char by one char as peel an onion i<-->j until nothing left.\\n    public int minMovesToMakePalindrome(String s) {\\n        int res = 0;\\n        while(s.length() > 0) {\\n            char e = s.charAt(s.length() - 1);\\n            int i = s.indexOf(e);\\n            //if single char, it means for palindromic, it should in the middle. so move i /2 steps to put it in the middle.\\n            if(i == s.length() - 1) {\\n                res += i/2;\\n            } else {\\n                //move i step to put it to the head.\\n                res += i;\\n               //skip the ith char as it should be put to head and peeled off.\\n                s = s.substring(0, i) + s.substring(i+1);\\n            }\\n            \\n            //remove the last one as peel off the leftmost and right most.\\n            s = s.substring(0, s.length() - 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n    //Greedy strategy to check one char by one char as peel an onion i<-->j until nothing left.\\n    public int minMovesToMakePalindrome(String s) {\\n        int res = 0;\\n        while(s.length() > 0) {\\n            char e = s.charAt(s.length() - 1);\\n            int i = s.indexOf(e);\\n            //if single char, it means for palindromic, it should in the middle. so move i /2 steps to put it in the middle.\\n            if(i == s.length() - 1) {\\n                res += i/2;\\n            } else {\\n                //move i step to put it to the head.\\n                res += i;\\n               //skip the ith char as it should be put to head and peeled off.\\n                s = s.substring(0, i) + s.substring(i+1);\\n            }\\n            \\n            //remove the last one as peel off the leftmost and right most.\\n            s = s.substring(0, s.length() - 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401251,
                "title": "c-89-time-greedy-two-pointer",
                "content": "![image](https://assets.leetcode.com/users/images/eb3f97c4-5576-42ae-afd1-90110d8e0dec_1660031490.3080149.png)\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/eb3f97c4-5576-42ae-afd1-90110d8e0dec_1660031490.3080149.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2347637,
                "title": "c-solution-with-comments-2-pointers-swap-time-limit-exceeded",
                "content": "```\\n/* Time Limit is Exceeded for some case. Plase see the below code to understand the logic only. */\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        // 2 pointers -- left (start), right (end)\\n        int left = 0;\\n        int right = s.Length - 1;\\n        \\n        // l and r copies to initial pointers because these will be moved\\n        int l, r = 0;\\n        while(left < right)\\n        {\\n            l = left;\\n            r = right;\\n            \\n            // move r towards l till matching char is found\\n            while(s[l] != s[r])\\n                r--;\\n            \\n            if(l == r) // there is only 1 character in string so it should be in center\\n            {\\n                s = Swap(r, (r + 1), s);\\n                ans++;\\n                continue;\\n            }\\n            else // there are 2 (or more) same chars and this other char should be moved to opposite end\\n            {\\n                while(r < right) // move second char till r = right\\n                {\\n                    s = Swap(r, (r + 1), s);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // after each iteration move left and right towards each other\\n            left++;\\n            right--;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static string Swap(int index1, int index2, string str)\\n    {\\n        char[] strChar = str.ToCharArray();\\n        char temp = strChar[index1];\\n        strChar[index1] = strChar[index2];\\n        strChar[index2] = temp;\\n        \\n        return new string(strChar);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n/* Time Limit is Exceeded for some case. Plase see the below code to understand the logic only. */\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        // 2 pointers -- left (start), right (end)\\n        int left = 0;\\n        int right = s.Length - 1;\\n        \\n        // l and r copies to initial pointers because these will be moved\\n        int l, r = 0;\\n        while(left < right)\\n        {\\n            l = left;\\n            r = right;\\n            \\n            // move r towards l till matching char is found\\n            while(s[l] != s[r])\\n                r--;\\n            \\n            if(l == r) // there is only 1 character in string so it should be in center\\n            {\\n                s = Swap(r, (r + 1), s);\\n                ans++;\\n                continue;\\n            }\\n            else // there are 2 (or more) same chars and this other char should be moved to opposite end\\n            {\\n                while(r < right) // move second char till r = right\\n                {\\n                    s = Swap(r, (r + 1), s);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // after each iteration move left and right towards each other\\n            left++;\\n            right--;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static string Swap(int index1, int index2, string str)\\n    {\\n        char[] strChar = str.ToCharArray();\\n        char temp = strChar[index1];\\n        strChar[index1] = strChar[index2];\\n        strChar[index2] = temp;\\n        \\n        return new string(strChar);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347480,
                "title": "swift-two-pointer-solution-100-efficient",
                "content": "```\\nclass Solution {\\n    func minMovesToMakePalindrome(_ s: String) -> Int {\\n        let n = s.count\\n        var s = Array(s)\\n        var lptr = 0\\n        var rptr = n - 1\\n        var res = 0\\n        while lptr < rptr {\\n            var r = rptr\\n            if s[lptr] == s[r] {\\n                lptr += 1\\n                rptr -= 1\\n                continue\\n            }\\n            while s[lptr] != s[r] {\\n                r -= 1\\n            }\\n            if lptr == r {\\n                swap(&s, lptr, lptr + 1)\\n                res += 1\\n            } else {\\n                while r != rptr {\\n                    swap(&s, r, r + 1)\\n                    r += 1\\n                    res += 1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    \\n    func swap(_ s: inout [Character], _ l: Int, _ r: Int) {\\n        let temp = s[l]\\n        s[l] = s[r]\\n        s[r] = temp\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minMovesToMakePalindrome(_ s: String) -> Int {\\n        let n = s.count\\n        var s = Array(s)\\n        var lptr = 0\\n        var rptr = n - 1\\n        var res = 0\\n        while lptr < rptr {\\n            var r = rptr\\n            if s[lptr] == s[r] {\\n                lptr += 1\\n                rptr -= 1\\n                continue\\n            }\\n            while s[lptr] != s[r] {\\n                r -= 1\\n            }\\n            if lptr == r {\\n                swap(&s, lptr, lptr + 1)\\n                res += 1\\n            } else {\\n                while r != rptr {\\n                    swap(&s, r, r + 1)\\n                    r += 1\\n                    res += 1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    \\n    func swap(_ s: inout [Character], _ l: Int, _ r: Int) {\\n        let temp = s[l]\\n        s[l] = s[r]\\n        s[r] = temp\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333573,
                "title": "java-solution-for-minimum-move-to-make-palindrome",
                "content": "this solution work with all type of string i.e binary, number strings as well \\nbut leet code expecting on their test is 2 move to make palindrome **aabb** and expecting 2 moves but this algorithm give most minimum and solve this with 1 move \\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int length = s.length();\\n        if (length == 0 || length == 1) return 0;\\n\\n        char[] str = s.toCharArray();\\n        int start = 0, end = length - 1;\\n        int count = 0;\\n        while (start < end) {\\n            if (str[start] != str[end]){\\n                boolean isSwapped = false;\\n                for (int i = start + 1; i < end; i++){\\n                    if (str[start] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[end];\\n                        str[end] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }else if (str[end] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[start];\\n                        str[start] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }\\n                }\\n                if (!isSwapped) return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int length = s.length();\\n        if (length == 0 || length == 1) return 0;\\n\\n        char[] str = s.toCharArray();\\n        int start = 0, end = length - 1;\\n        int count = 0;\\n        while (start < end) {\\n            if (str[start] != str[end]){\\n                boolean isSwapped = false;\\n                for (int i = start + 1; i < end; i++){\\n                    if (str[start] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[end];\\n                        str[end] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }else if (str[end] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[start];\\n                        str[start] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }\\n                }\\n                if (!isSwapped) return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326598,
                "title": "3-liner-recursive-solution",
                "content": "Let `a` denotes the first char of `s`, `S` denotes  the palindrome which takes miminum swaps to make, we have two following observations:\\n\\n1. `a` is also the first char of `S`\\n   <details>\\n   <summary>Proof</summary>\\n   \\n   We prove this by contradiction:\\n   Suppose the first character of `S` is not `a`, then `S` must be of form `..a..a..`, since `S` is a permutation of `s` the minimum number of swaps needed to create `S` is the number of inversions of the permuation `S`.\\n   Moving the first `a` to the beggining of `S` decreases the number of inversions by `j` (index of the first `a` in `S`). Moving the last  `a` to the end of `S` increases the number of inversions by at most `j`. So the number of inversions of `a....a` is always equal or smaller than `S`\\'s. So the panlidrome whick takes minimum swaps always have the first char of `a`.\\n   </details>\\n2. Let `i` denotes the furthest index of  char `a` in `s`, move `i`th char to the end of `s` we obtain a new string `s\\'` . The minimum number of moves to make S equal to number of moves to move `i`th char to \\'S\\'\\'s end plus the minimum number of swaps to make substring `s\\'[1..-1]` become a panlindrome.\\n\\t<details>\\n\\t<summary>Proof</summary>\\n\\n\\t The last char of `S` must be `a`, hence moving the furthest `a` to the end would take minimum moves.\\n\\t</details>\\n\\t\\n**Note** : There is an edge case where `a` is the middle char of the panlidrome in this case there\\'s only one `a` in `s`, the result would be equal to half the length of `s` plus min moves to change the rest substring.\\n```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        if len(s) < 2:\\n          return 0 \\n        j = s.rfind(s[0])\\n        return self.minMovesToMakePalindrome(s[1:]) + len(s)//2  if j==0 \\\\\\n        else len(s)-1-j + self.minMovesToMakePalindrome(s[1:j] + s[j+1:]) \\n```\\n--- \\n<br>\\n<summary><b>Advance solution O(nlogn)</b></summary>\\nThis solution takes only O(nlogn) whereas the previous takes O(n^2)\\nThe idea is to create the panlindrome permutation first and then calculate the number of its inversion (Traverse from left to right, if there exists a right most unused char which is identical to the current one then update the correspond indexes in the permutation)\\n\\n```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        idx = collections.defaultdict(collections.deque) ; \\n        for i,j in enumerate(s):\\n            idx[j].append(i)\\n        p = [0] * len(s)\\n        j = 0 \\n        for i in s:\\n            if len(idx[i]) > 1:\\n                p[j] = idx[i].popleft()\\n                p[n-j-1] = idx[i].pop()\\n                j += 1\\n            elif len(idx[i]) == 1:\\n                p[n//2] = idx[i].pop()\\n        from sortedcontainers import SortedList\\n        res = 0\\n        A = SortedList()\\n        for i in p[::-1]:\\n            res += A.bisect(i)\\n            A.add(i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        if len(s) < 2:\\n          return 0 \\n        j = s.rfind(s[0])\\n        return self.minMovesToMakePalindrome(s[1:]) + len(s)//2  if j==0 \\\\\\n        else len(s)-1-j + self.minMovesToMakePalindrome(s[1:j] + s[j+1:]) \\n```\n```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        idx = collections.defaultdict(collections.deque) ; \\n        for i,j in enumerate(s):\\n            idx[j].append(i)\\n        p = [0] * len(s)\\n        j = 0 \\n        for i in s:\\n            if len(idx[i]) > 1:\\n                p[j] = idx[i].popleft()\\n                p[n-j-1] = idx[i].pop()\\n                j += 1\\n            elif len(idx[i]) == 1:\\n                p[n//2] = idx[i].pop()\\n        from sortedcontainers import SortedList\\n        res = 0\\n        A = SortedList()\\n        for i in p[::-1]:\\n            res += A.bisect(i)\\n            A.add(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2323007,
                "title": "java-two-pointer-o-n-or-o-n-2-easy-to-understand",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n               \\n        int left = 0;\\n        int right = s.length() -1;\\n        int ans = 0;\\n        \\n        char[] str = s.toCharArray();\\n        \\n        while(left < right)\\n        {\\n            // System.out.println(\"-------------------------------------\");\\n            // System.out.println(str[left] + \" <----> \" + str[right]);\\n            if(str[left] == str[right])\\n            {\\n                left++;\\n                right--;\\n                // System.out.println(left + \" <--> \" + right);\\n            }\\n            else\\n            {\\n                int matchIdx = -1;\\n                for(int goRight = left+1; goRight < right; goRight++)\\n                {\\n                    if(str[goRight] == str[right])\\n                    {\\n                        matchIdx = goRight;\\n                        break;\\n                    }\\n                }\\n                \\n                if(matchIdx != -1)\\n                {\\n                    for(int goLeft = matchIdx; goLeft > left; goLeft--)\\n                    {\\n                        str = swap(str, goLeft, goLeft-1);\\n                        ans++;\\n                        // System.out.println(\"swap ->  \" + String.valueOf(str));\\n                    }\\n                }\\n                else\\n                {\\n                    str = swap(str, right, right-1);\\n                    ans++;\\n                    // System.out.println(\"swap else -> \" + String.valueOf(str));\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        // System.out.println(String.valueOf(str));\\n        \\n        return ans;\\n        \\n    }\\n    \\n    char[] swap(char[] str, int i , int j)\\n    {\\n        char tmp = str[i];\\n        str[i] = str[j];\\n        str[j] = tmp;\\n        return str;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n               \\n        int left = 0;\\n        int right = s.length() -1;\\n        int ans = 0;\\n        \\n        char[] str = s.toCharArray();\\n        \\n        while(left < right)\\n        {\\n            // System.out.println(\"-------------------------------------\");\\n            // System.out.println(str[left] + \" <----> \" + str[right]);\\n            if(str[left] == str[right])\\n            {\\n                left++;\\n                right--;\\n                // System.out.println(left + \" <--> \" + right);\\n            }\\n            else\\n            {\\n                int matchIdx = -1;\\n                for(int goRight = left+1; goRight < right; goRight++)\\n                {\\n                    if(str[goRight] == str[right])\\n                    {\\n                        matchIdx = goRight;\\n                        break;\\n                    }\\n                }\\n                \\n                if(matchIdx != -1)\\n                {\\n                    for(int goLeft = matchIdx; goLeft > left; goLeft--)\\n                    {\\n                        str = swap(str, goLeft, goLeft-1);\\n                        ans++;\\n                        // System.out.println(\"swap ->  \" + String.valueOf(str));\\n                    }\\n                }\\n                else\\n                {\\n                    str = swap(str, right, right-1);\\n                    ans++;\\n                    // System.out.println(\"swap else -> \" + String.valueOf(str));\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        // System.out.println(String.valueOf(str));\\n        \\n        return ans;\\n        \\n    }\\n    \\n    char[] swap(char[] str, int i , int j)\\n    {\\n        char tmp = str[i];\\n        str[i] = str[j];\\n        str[j] = tmp;\\n        return str;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321206,
                "title": "c-greedy-o-n-2-sln",
                "content": "```\\nint minMovesToMakePalindromeImpl(string& s, int i, int j) {\\n        if (i >= j) {\\n            return 0;\\n        }\\n        int k = j;\\n        while (s[k] != s[i]) {\\n            --k;\\n        }\\n        if (k == i) {\\n            swap(s[k], s[k + 1]);\\n            return minMovesToMakePalindromeImpl(s, i, j) + 1;\\n        }\\n        rotate(begin(s) + k, begin(s) + k + 1, begin(s) + j + 1);\\n        return minMovesToMakePalindromeImpl(s, i + 1, j - 1) + j - k;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return minMovesToMakePalindromeImpl(s, 0, size(s) - 1);\\n    }",
                "solutionTags": [],
                "code": "```\\nint minMovesToMakePalindromeImpl(string& s, int i, int j) {\\n        if (i >= j) {\\n            return 0;\\n        }\\n        int k = j;\\n        while (s[k] != s[i]) {\\n            --k;\\n        }\\n        if (k == i) {\\n            swap(s[k], s[k + 1]);\\n            return minMovesToMakePalindromeImpl(s, i, j) + 1;\\n        }\\n        rotate(begin(s) + k, begin(s) + k + 1, begin(s) + j + 1);\\n        return minMovesToMakePalindromeImpl(s, i + 1, j - 1) + j - k;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return minMovesToMakePalindromeImpl(s, 0, size(s) - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2307648,
                "title": "c-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = s.size() - 1;\\n        int cnt = 0;\\n        while(i < j){\\n            if(s[i] != s[j]){\\n                int k = j;\\n                string str = s;\\n                while(s[i] != s[k] and k >= 0){\\n                    k--;\\n                }\\n                int c1 = 0;\\n                while(str[i] != str[j] and k < (n-1)){\\n                    swap(str[k] , str[k+1]);\\n                    c1++;\\n                    k++;\\n                }\\n                \\n                k = i;\\n                \\n                string t = s;\\n                while(s[j] != s[k] and k < (n-1)){\\n                    k++;\\n                }\\n                // cout<<s<<k<<endl;\\n                int c2 = 0;\\n                while(t[i] != t[j] and k > 0){\\n                    swap(t[k] , t[k-1]);\\n                    c2++;\\n                    k--;\\n                }\\n                \\n                // cout<<c1<<\" \"<<c2<<endl;\\n                if(c1 > c2){\\n                    cnt += c2;\\n                    s = t;\\n                }\\n                else{\\n                    cnt += c1;\\n                    s = str;\\n                }\\n            }else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        cout<<s<<endl;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = s.size() - 1;\\n        int cnt = 0;\\n        while(i < j){\\n            if(s[i] != s[j]){\\n                int k = j;\\n                string str = s;\\n                while(s[i] != s[k] and k >= 0){\\n                    k--;\\n                }\\n                int c1 = 0;\\n                while(str[i] != str[j] and k < (n-1)){\\n                    swap(str[k] , str[k+1]);\\n                    c1++;\\n                    k++;\\n                }\\n                \\n                k = i;\\n                \\n                string t = s;\\n                while(s[j] != s[k] and k < (n-1)){\\n                    k++;\\n                }\\n                // cout<<s<<k<<endl;\\n                int c2 = 0;\\n                while(t[i] != t[j] and k > 0){\\n                    swap(t[k] , t[k-1]);\\n                    c2++;\\n                    k--;\\n                }\\n                \\n                // cout<<c1<<\" \"<<c2<<endl;\\n                if(c1 > c2){\\n                    cnt += c2;\\n                    s = t;\\n                }\\n                else{\\n                    cnt += c1;\\n                    s = str;\\n                }\\n            }else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        cout<<s<<endl;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2302517,
                "title": "simple-c-soln-two-pointers",
                "content": "```\\n int minMovesToMakePalindrome(string s) {\\n        \\n        int left= 0;\\n        int right= s.length()-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n           int l=left, r=right;\\n            \\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            \\n            if(l==r)                                //odd component\\n            {\\n                swap(s[r], s[r+1]);\\n                res++;\\n                continue;\\n                    \\n            }\\n            else \\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r], s[r+1]);\\n                    res++;\\n                    r++;\\n                }\\n            }\\n            \\n            \\n            left++;\\n            right--;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        \\n        int left= 0;\\n        int right= s.length()-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n           int l=left, r=right;\\n            \\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            \\n            if(l==r)                                //odd component\\n            {\\n                swap(s[r], s[r+1]);\\n                res++;\\n                continue;\\n                    \\n            }\\n            else \\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r], s[r+1]);\\n                    res++;\\n                    r++;\\n                }\\n            }\\n            \\n            \\n            left++;\\n            right--;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2261685,
                "title": "c-two-pointers-approach",
                "content": "use two pointers if left char is equal to right continue if not equal find the char of left one from right side and simlarly for right char from left side take the minimum of two do swaps check the condition that if there is only one suitable\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.length(),ans=0;\\n        int l=0,r=n-1;\\n        while(l<r)\\n        {\\n            int p,q;\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                int key1=s[r],key2=s[l];\\n                p=l+1;\\n                while(p<r)\\n                {\\n                    if(key1!=s[p])\\n                        p++;\\n                    else\\n                        break;\\n                }\\n                q=r-1;\\n                while(q>l)\\n                {\\n                    if(key2!=s[q])\\n                        q--;\\n                    else\\n                        break;\\n                }\\n                if(q!=l&&p!=r)\\n                {\\n                    ans+=min(p-l,r-q);\\n                    if(p-l<r-q)\\n                    {\\n                        while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }    \\n                    }\\n                    else\\n                    {\\n                        while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                    }\\n                }\\n                else if(q!=l&&p==r)\\n                {\\n                    ans+=(r-q);\\n                    while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                }\\n                else\\n                {\\n                    ans+=(p-l);\\n                    while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nit may not be optimised but i tried all possibilities",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.length(),ans=0;\\n        int l=0,r=n-1;\\n        while(l<r)\\n        {\\n            int p,q;\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                int key1=s[r],key2=s[l];\\n                p=l+1;\\n                while(p<r)\\n                {\\n                    if(key1!=s[p])\\n                        p++;\\n                    else\\n                        break;\\n                }\\n                q=r-1;\\n                while(q>l)\\n                {\\n                    if(key2!=s[q])\\n                        q--;\\n                    else\\n                        break;\\n                }\\n                if(q!=l&&p!=r)\\n                {\\n                    ans+=min(p-l,r-q);\\n                    if(p-l<r-q)\\n                    {\\n                        while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }    \\n                    }\\n                    else\\n                    {\\n                        while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                    }\\n                }\\n                else if(q!=l&&p==r)\\n                {\\n                    ans+=(r-q);\\n                    while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                }\\n                else\\n                {\\n                    ans+=(p-l);\\n                    while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258616,
                "title": "c-w-comments-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int count=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k=i;\\n                while(k<j && s[k]!=s[j]){\\n                    /*i\\'m finding the other pair of\\n                    the element which should be at opp position;*/\\n                    k++;\\n                }\\n                if(k==j){ \\n                    /* element is odd and should\\n                    be present at the middle of the string;*/\\n                    swap(s[j-1],s[j]);\\n                    count++;\\n                }\\n                else{\\n                    while(k>0 && s[i]!=s[j]){ \\n                        /*this loop will continue till the we\\'ve\\n                        not set both of the ends to be equal.*/\\n                        swap(s[k-1],s[k]);\\n                        count++;\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int count=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k=i;\\n                while(k<j && s[k]!=s[j]){\\n                    /*i\\'m finding the other pair of\\n                    the element which should be at opp position;*/\\n                    k++;\\n                }\\n                if(k==j){ \\n                    /* element is odd and should\\n                    be present at the middle of the string;*/\\n                    swap(s[j-1],s[j]);\\n                    count++;\\n                }\\n                else{\\n                    while(k>0 && s[i]!=s[j]){ \\n                        /*this loop will continue till the we\\'ve\\n                        not set both of the ends to be equal.*/\\n                        swap(s[k-1],s[k]);\\n                        count++;\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247603,
                "title": "two-pointer-solution",
                "content": "```\\n int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int ind=-1;\\n\\t\\t\\t\\t//find the first index where they matches\\n                for(int k=i+1;k<j;k++){\\n                    if(s[k]==s[j]){\\n                        ind=k;\\n                        break;\\n                    }\\n                }\\n                if(ind!=-1){\\n\\t\\t\\t\\t//if we found then swap  them\\n                    for(int k=ind;k>i;k--){\\n                        swap(s[k],s[k-1]);\\n                        ans++;\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t// this is odd no of char\\n                    swap(s[j],s[j-1]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int ind=-1;\\n\\t\\t\\t\\t//find the first index where they matches\\n                for(int k=i+1;k<j;k++){\\n                    if(s[k]==s[j]){\\n                        ind=k;\\n                        break;\\n                    }\\n                }\\n                if(ind!=-1){\\n\\t\\t\\t\\t//if we found then swap  them\\n                    for(int k=ind;k>i;k--){\\n                        swap(s[k],s[k-1]);\\n                        ans++;\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t// this is odd no of char\\n                    swap(s[j],s[j-1]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235103,
                "title": "c-two-pointer-solution",
                "content": "\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        long long l=0,e=s.size()-1;\\n        long long cnt=0;\\n        while(l<e)\\n        {\\n            int a=l,b=e;\\n            while(s[a]!=s[b])\\n            {\\n                b--;\\n            }\\n            \\n            if(a==b)\\n            {\\n                swap(s[b],s[b+1]);\\n                cnt++;\\n                continue;\\n            }\\n            else\\n            {\\n                while(b<e){\\n                swap(s[b],s[b+1]);\\n                cnt++;\\n                b++;\\n                }\\n            }\\n            //cout<<s<<\"\\\\n\";\\n            l++;e--;\\n        }\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        long long l=0,e=s.size()-1;\\n        long long cnt=0;\\n        while(l<e)\\n        {\\n            int a=l,b=e;\\n            while(s[a]!=s[b])\\n            {\\n                b--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2120406,
                "title": "c-easy-recursion-o-n-n",
                "content": "class Solution {\\npublic:\\n    int find(string s)\\n    {\\n        int i=0,j=s.size()-1;\\n        if(s.size()==1)return 0;\\n        if(s[i]==s[j])\\n        {\\n            s.pop_back();\\n             if(s.size()==1)return 0;\\n            return find(s.substr(1));\\n        }\\n        else\\n        {\\n            int k=j;\\n            while(s[k]!=s[i])k--;\\n            int k2=i;\\n            while(s[k2]!=s[j])k2++;\\n            if(j-k<k2-i)\\n            {\\n                int t=j-k;\\n                while(k<j){swap(s[k],s[k+1]);k++;}\\n                s.pop_back();\\n                return find(s.substr(1))+t;\\n            }\\n            else\\n            {\\n                int t=k2-i;\\n                while(k2>0){swap(s[k2],s[k2-1]);k2--;}\\n                s.pop_back();\\n                return find(s.substr(1))+t;\\n            }\\n        }\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        return find(s);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find(string s)\\n    {\\n        int i=0,j=s.size()-1;\\n        if(s.size()==1)return 0;\\n        if(s[i]==s[j])\\n        {\\n            s.pop_back();\\n             if(s.size()==1)return 0;\\n            return find(s.substr(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2109119,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int count=0,te=0,counter=0;\\n        for(int j=0;j<s.length()/2;j++){\\n            int c=0;\\n            char temp=s[j];\\n            for(int i=s.size()-1-j;i>j;i--){\\n                if(s[i]==temp){\\n                    char t=s[i];\\n                    s.erase(s.size()-1-c-j,1);\\n                    s.insert(s.end()-j,t);\\n                    count+=c;\\n                    break;\\n                }else if(i==(j+1)){\\n                    te=j;\\n                    s.erase(s.begin()+j);\\n                    j--;\\n                    counter++;\\n                    break;\\n                }\\n              c++;\\n            }\\n         }\\n        if(counter!=0){\\n            count+=(s.size()/2)-te;\\n        }    \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int count=0,te=0,counter=0;\\n        for(int j=0;j<s.length()/2;j++){\\n            int c=0;\\n            char temp=s[j];\\n            for(int i=s.size()-1-j;i>j;i--){\\n                if(s[i]==temp){\\n                    char t=s[i];\\n                    s.erase(s.size()-1-c-j,1);\\n                    s.insert(s.end()-j,t);\\n                    count+=c;\\n                    break;\\n                }else if(i==(j+1)){\\n                    te=j;\\n                    s.erase(s.begin()+j);\\n                    j--;\\n                    counter++;\\n                    break;\\n                }\\n              c++;\\n            }\\n         }\\n        if(counter!=0){\\n            count+=(s.size()/2)-te;\\n        }    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036420,
                "title": "c-solution",
                "content": "```\\nvoid findmin_ex(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            return;\\n        } else {\\n            int copy = now+1;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[len] != s[copy]){\\n                copy++;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            *ans += copy-now;\\n            s[copy] = \\'A\\';\\n            len--;\\n        }\\n    }\\n}\\n\\nvoid findmin(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[now] == \\'A\\'){\\n            now++;\\n        }\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            now++;\\n            len--;\\n        } else {\\n            int copy = len-1;\\n            int copya = *ans;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[now] != s[copy]){\\n                copy--;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            if (copy != now){\\n                *ans += len-copy;\\n                s[copy] = \\'A\\';\\n            } else {\\n                *ans = copya;\\n                findmin_ex(s, now, len, ans);\\n                return;\\n            }\\n            now++;\\n        }\\n    }\\n}\\n\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s);\\n    int ans = 0;\\n    findmin(s, 0, len-1, &ans);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid findmin_ex(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            return;\\n        } else {\\n            int copy = now+1;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[len] != s[copy]){\\n                copy++;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            *ans += copy-now;\\n            s[copy] = \\'A\\';\\n            len--;\\n        }\\n    }\\n}\\n\\nvoid findmin(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[now] == \\'A\\'){\\n            now++;\\n        }\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            now++;\\n            len--;\\n        } else {\\n            int copy = len-1;\\n            int copya = *ans;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[now] != s[copy]){\\n                copy--;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            if (copy != now){\\n                *ans += len-copy;\\n                s[copy] = \\'A\\';\\n            } else {\\n                *ans = copya;\\n                findmin_ex(s, now, len, ans);\\n                return;\\n            }\\n            now++;\\n        }\\n    }\\n}\\n\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s);\\n    int ans = 0;\\n    findmin(s, 0, len-1, &ans);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840252,
                "title": "c-2-pointers-solution",
                "content": "\\t int minMovesToMakePalindrome(string s) {\\n        int n = s.length(), l = 0, r = n - 1, ans = 0;\\n        \\n        while(l < r) {\\n            int i = l, j = r;\\n            \\n            if(s[i] == s[j])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            while(s[j] != s[i])\\n                j--;\\n            \\n            if(i == j) {\\n                swap(s[j], s[j + 1]);\\n                ans++;\\n            }\\n            else {\\n                while(j < r) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                \\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t int minMovesToMakePalindrome(string s) {\\n        int n = s.length(), l = 0, r = n - 1, ans = 0;\\n        \\n        while(l < r) {\\n            int i = l, j = r;\\n            \\n            if(s[i] == s[j])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            while(s[j] != s[i])\\n                j--;\\n            \\n            if(i == j) {\\n                swap(s[j], s[j + 1]);\\n                ans++;\\n            }\\n            else {\\n                while(j < r) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                \\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1834805,
                "title": "c-commented-solution-gready-time-o-n-2-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string a) {\\n       \\n        int n = a.size(),g,w,k1,k2;\\n        \\n        unordered_map<char,int> m;    // For maping every char of string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            m[a[i]]++;\\n        }\\n        \\n        int ans =0 ,i =0 ,j= n-1;     // Two pointer one from start another from end of string\\n \\n        while(1)\\n        {\\n            j = n-i-1;\\n            if(i>=j)                          \\n                return ans;                  // Return ans if pointer i greater or equal to pointer j\\n            if(a[i]!=a[j])                     // If both pointer character are diffrent\\n            {\\n                \\n                w = -1 ;\\n                g= -1;\\n                k1 = INT_MAX;\\n                k2 = INT_MAX;\\n                for(int k=i+1;k<j;k++)              // Find same char as a[j] and store distance in variable\\n                {\\n                    if(a[k]==a[j])\\n                    {\\n                        k1 =(k-i);\\n                        g = k;\\n                        break;\\n                    }\\n                }\\n                    \\n                if(m[a[i]]!=1)                                 // If a[i] count is 1 means there is no more same char as a[i]\\n                {\\n                    for(int k=j-1;k>i;k--)            // Find same char as a[i] and store distance in variable\\n                    {\\n                        if(a[k]==a[i])\\n                        {\\n                            k2 = (j-k);\\n                            w = k;\\n                            break;\\n                        }\\n                    }\\n                   \\n                }\\n                \\n                if(k1<k2)                              // Select smallest distance\\n                {\\n                    for(int k=g-1;k>=i;k--)\\n                    {\\n                        swap(a[k],a[k+1]);                  // Swap to tiil ith position\\n                    }\\n                    m[a[j]]-=2;                                // Reduced char from map\\n                    ans += k1;                               // Add to ans\\n                }\\n                else\\n                {\\n                    for(int k=w+1;k<=j;k++)                  //  Swap to tiil jth position\\n                    {\\n                        swap(a[k],a[k-1]);\\n                    }\\n                    m[a[i]]-=2;                                             // Reduced char from map\\n                    ans += k2;                                              // Add to ans\\n                }\\n                \\n            }\\n            i++;\\n            \\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string a) {\\n       \\n        int n = a.size(),g,w,k1,k2;\\n        \\n        unordered_map<char,int> m;    // For maping every char of string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            m[a[i]]++;\\n        }\\n        \\n        int ans =0 ,i =0 ,j= n-1;     // Two pointer one from start another from end of string\\n \\n        while(1)\\n        {\\n            j = n-i-1;\\n            if(i>=j)                          \\n                return ans;                  // Return ans if pointer i greater or equal to pointer j\\n            if(a[i]!=a[j])                     // If both pointer character are diffrent\\n            {\\n                \\n                w = -1 ;\\n                g= -1;\\n                k1 = INT_MAX;\\n                k2 = INT_MAX;\\n                for(int k=i+1;k<j;k++)              // Find same char as a[j] and store distance in variable\\n                {\\n                    if(a[k]==a[j])\\n                    {\\n                        k1 =(k-i);\\n                        g = k;\\n                        break;\\n                    }\\n                }\\n                    \\n                if(m[a[i]]!=1)                                 // If a[i] count is 1 means there is no more same char as a[i]\\n                {\\n                    for(int k=j-1;k>i;k--)            // Find same char as a[i] and store distance in variable\\n                    {\\n                        if(a[k]==a[i])\\n                        {\\n                            k2 = (j-k);\\n                            w = k;\\n                            break;\\n                        }\\n                    }\\n                   \\n                }\\n                \\n                if(k1<k2)                              // Select smallest distance\\n                {\\n                    for(int k=g-1;k>=i;k--)\\n                    {\\n                        swap(a[k],a[k+1]);                  // Swap to tiil ith position\\n                    }\\n                    m[a[j]]-=2;                                // Reduced char from map\\n                    ans += k1;                               // Add to ans\\n                }\\n                else\\n                {\\n                    for(int k=w+1;k<=j;k++)                  //  Swap to tiil jth position\\n                    {\\n                        swap(a[k],a[k-1]);\\n                    }\\n                    m[a[i]]-=2;                                             // Reduced char from map\\n                    ans += k2;                                              // Add to ans\\n                }\\n                \\n            }\\n            i++;\\n            \\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831236,
                "title": "removing-pairs-70-speed",
                "content": "![image](https://assets.leetcode.com/users/images/4fcc293d-ce6f-4f05-ae5d-44c3aff5ff27_1646750948.4992037.png)\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n\\n        def remove_edges(current: str) -> str:\\n            nonlocal ans\\n            left, right = dict(), dict()\\n            len_c1 = len(current) - 1\\n            for i, c in enumerate(current):\\n                if c in right and i != right[c]:\\n                    j = right[c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif c not in left:\\n                    left[c] = i\\n                j = len_c1 - i\\n                right_c = current[j]\\n                if right_c in left and left[right_c] != j:\\n                    i = left[right_c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif right_c not in right:\\n                    right[right_c] = j\\n\\n            return \"\"\\n\\n        while len(s) > 2:\\n            s = remove_edges(s)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n\\n        def remove_edges(current: str) -> str:\\n            nonlocal ans\\n            left, right = dict(), dict()\\n            len_c1 = len(current) - 1\\n            for i, c in enumerate(current):\\n                if c in right and i != right[c]:\\n                    j = right[c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif c not in left:\\n                    left[c] = i\\n                j = len_c1 - i\\n                right_c = current[j]\\n                if right_c in left and left[right_c] != j:\\n                    i = left[right_c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif right_c not in right:\\n                    right[right_c] = j\\n\\n            return \"\"\\n\\n        while len(s) > 2:\\n            s = remove_edges(s)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830972,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n=s.size();\\n        int step=0;\\n        int left=0;\\n        int right=n-1;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            if(l==r)\\n            {\\n                swap(s[l],s[l+1]);\\n                step++;\\n            }\\n            else\\n            {\\n            for(int i=r;i<right;i++)\\n            {\\n                swap(s[i],s[i+1]);\\n                step++;\\n            }\\n            left++;\\n            right--;\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n=s.size();\\n        int step=0;\\n        int left=0;\\n        int right=n-1;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            if(l==r)\\n            {\\n                swap(s[l],s[l+1]);\\n                step++;\\n            }\\n            else\\n            {\\n            for(int i=r;i<right;i++)\\n            {\\n                swap(s[i],s[i+1]);\\n                step++;\\n            }\\n            left++;\\n            right--;\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828107,
                "title": "c-what-is-issue-in-this-solution",
                "content": "Can someone chech, what is issue in this code?\\n\\n\\tpublic int MinMovesToMakePalindrome(string s) {\\n        char[] chr = new char[s.Length];\\n        for(int index=0; index<s.Length; index++){\\n            chr[index] = s[index];\\n        }\\n        \\n        int j = s.Length-1;\\n        int i = 0;\\n        int moves = 0;\\n        while(i<j){\\n            if(chr[i]!=chr[j]){\\n                int k = j;\\n                while(k>i){\\n                    if(chr[k]==chr[i]){\\n                        char ch = chr[k];\\n                        chr[k] = chr[j];\\n                        chr[j] = ch;                        \\n                        moves = moves + (j-k);                        \\n                        break;\\n                    }\\n                 k--;\\n                }\\n                if(i==k){\\n                    char ch2 = chr[s.Length/2];\\n                    chr[s.Length/2] = chr[i];\\n                    chr[i] = ch2;                    \\n                    moves = moves + (s.Length/2-i);                    \\n                    continue;\\n                }\\n            }\\n            i++;\\n            j = s.Length-1 - i;\\n        }\\n        return moves;\\n    }",
                "solutionTags": [],
                "code": "Can someone chech, what is issue in this code?\\n\\n\\tpublic int MinMovesToMakePalindrome(string s) {\\n        char[] chr = new char[s.Length];\\n        for(int index=0; index<s.Length; index++){\\n            chr[index] = s[index];\\n        }\\n        \\n        int j = s.Length-1;\\n        int i = 0;\\n        int moves = 0;\\n        while(i<j){\\n            if(chr[i]!=chr[j]){\\n                int k = j;\\n                while(k>i){\\n                    if(chr[k]==chr[i]){\\n                        char ch = chr[k];\\n                        chr[k] = chr[j];\\n                        chr[j] = ch;                        \\n                        moves = moves + (j-k);                        \\n                        break;\\n                    }\\n                 k--;\\n                }\\n                if(i==k){\\n                    char ch2 = chr[s.Length/2];\\n                    chr[s.Length/2] = chr[i];\\n                    chr[i] = ch2;                    \\n                    moves = moves + (s.Length/2-i);                    \\n                    continue;\\n                }\\n            }\\n            i++;\\n            j = s.Length-1 - i;\\n        }\\n        return moves;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1827913,
                "title": "cpp-simple-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int pos = 0;\\n        \\n        int ans = 0;\\n        while(pos < s.size()){\\n            if(pos == s.size() - 1 || pos == s.size()-2) break;\\n            int cpos = s.size()-1;\\n            \\n            while(s[cpos] != s[pos]) cpos--;\\n            \\n            if(cpos == pos){\\n                swap(s[pos], s[pos+1]);\\n                ans++;\\n                continue;\\n            }\\n            \\n            while(cpos != s.size()-1){\\n                swap(s[cpos], s[cpos+1]);\\n                cpos++;\\n                ans++;\\n            }\\n            \\n            pos++;\\n            s.pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int pos = 0;\\n        \\n        int ans = 0;\\n        while(pos < s.size()){\\n            if(pos == s.size() - 1 || pos == s.size()-2) break;\\n            int cpos = s.size()-1;\\n            \\n            while(s[cpos] != s[pos]) cpos--;\\n            \\n            if(cpos == pos){\\n                swap(s[pos], s[pos+1]);\\n                ans++;\\n                continue;\\n            }\\n            \\n            while(cpos != s.size()-1){\\n                swap(s[cpos], s[cpos+1]);\\n                cpos++;\\n                ans++;\\n            }\\n            \\n            pos++;\\n            s.pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826144,
                "title": "java-easy-to-understand-solution",
                "content": "```\\n\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        char[] charArray = s.toCharArray();\\n        int output = 0;\\n        while(l < r){\\n            if(charArray[l] == charArray[r]){\\n                l++;\\n                r--;\\n            }else{\\n                char prev = charArray[l];\\n                int k = r;\\n                while(charArray[k] != prev){\\n                    k--;\\n                }\\n                //middle element\\n                if(k == l){\\n                    char temp = charArray[l];\\n                    charArray[l] = charArray[l+1];\\n                    charArray[l+1] = temp; \\n                    output++;\\n                    continue;\\n                }\\n                \\n                for(int i = k;i<r;i++){\\n                    char temp = charArray[i];\\n                    charArray[i] = charArray[i+1];\\n                    charArray[i+1] = temp;\\n                    output++;\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return output;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        char[] charArray = s.toCharArray();\\n        int output = 0;\\n        while(l < r){\\n            if(charArray[l] == charArray[r]){\\n                l++;\\n                r--;\\n            }else{\\n                char prev = charArray[l];\\n                int k = r;\\n                while(charArray[k] != prev){\\n                    k--;\\n                }\\n                //middle element\\n                if(k == l){\\n                    char temp = charArray[l];\\n                    charArray[l] = charArray[l+1];\\n                    charArray[l+1] = temp; \\n                    output++;\\n                    continue;\\n                }\\n                \\n                for(int i = k;i<r;i++){\\n                    char temp = charArray[i];\\n                    charArray[i] = charArray[i+1];\\n                    charArray[i+1] = temp;\\n                    output++;\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return output;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1826026,
                "title": "python-3-basic-1000ms",
                "content": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n<=1:\\n            return 0\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        i = 1\\n        while s[i]!=s[-1]:\\n            i+=1\\n        j = n - 2\\n        while s[j]!=s[0]:\\n            j-=1\\n        if i <= n - 1 - j:\\n            return i + self.minMovesToMakePalindrome(s[:i]+s[i+1:-1])\\n        else:\\n            return n - 1 - j + self.minMovesToMakePalindrome(s[1:j]+s[j+1:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n<=1:\\n            return 0\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        i = 1\\n        while s[i]!=s[-1]:\\n            i+=1\\n        j = n - 2\\n        while s[j]!=s[0]:\\n            j-=1\\n        if i <= n - 1 - j:\\n            return i + self.minMovesToMakePalindrome(s[:i]+s[i+1:-1])\\n        else:\\n            return n - 1 - j + self.minMovesToMakePalindrome(s[1:j]+s[j+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824278,
                "title": "c-o-n2-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1;\\n        int ans=0;\\n        while(l<r){\\n           if(s[l]!=s[r]){\\n               int rr=r-1;\\n               while(s[rr]!=s[l])\\n                   rr--;\\n               int ll=l;\\n               while(s[ll]!=s[r])\\n                   ll++;\\n               int a=r-rr,b=ll-l;\\n               if(a<b){\\n                   s.erase(begin(s)+rr);\\n                   ans+=a;\\n                   r--;l++;\\n               }\\n               else{\\n                   s.erase(begin(s)+ll);\\n                   ans+=b;\\n                   r-=2;  \\n               }\\n           } \\n            else{\\n                l++;r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1;\\n        int ans=0;\\n        while(l<r){\\n           if(s[l]!=s[r]){\\n               int rr=r-1;\\n               while(s[rr]!=s[l])\\n                   rr--;\\n               int ll=l;\\n               while(s[ll]!=s[r])\\n                   ll++;\\n               int a=r-rr,b=ll-l;\\n               if(a<b){\\n                   s.erase(begin(s)+rr);\\n                   ans+=a;\\n                   r--;l++;\\n               }\\n               else{\\n                   s.erase(begin(s)+ll);\\n                   ans+=b;\\n                   r-=2;  \\n               }\\n           } \\n            else{\\n                l++;r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823273,
                "title": "c-greedy-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        const auto shift_fwd = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i + 1 <= idx_dest; ++i) {\\n                s[i] = s[i + 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n\\n        const auto shift_rev = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i - 1 >= idx_dest; --i) {\\n                s[i] = s[i - 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n        \\n        const auto shift = [&](int idx_src, int idx_dest) {\\n            if (idx_src < idx_dest) {\\n                shift_fwd(idx_src, idx_dest);\\n            } else if (idx_src > idx_dest) {\\n                shift_rev(idx_src, idx_dest);\\n            }\\n        };        \\n        \\n        int total_ops = 0; \\n        int i = 0, j = s.size() - 1;\\n        for (; i < j; ++i, --j) {\\n            if (s[i] == s[j]) {\\n                continue;\\n            }\\n\\n            int lhs_ops = INT_MAX;\\n            int lhs_k = -1;\\n            {\\n                int k = j - 1;            \\n                for (; k > i; --k) {\\n                    if (s[k] == s[i]) {\\n                        break;\\n                    }\\n                }\\n                if (k != i) {\\n                    lhs_k = k;\\n                    lhs_ops = j - k;\\n                }\\n            }\\n\\n            int rhs_ops = INT_MAX;\\n            int rhs_k = -1;\\n            {\\n                int k = i + 1;\\n                for (; k < j; ++k) {\\n                    if (s[k] == s[j]) {\\n                        break;\\n                    }\\n                }\\n                if (k != j) {\\n                    rhs_k = k;\\n                    rhs_ops = k - i;\\n                }\\n            }\\n\\n            if (lhs_ops < rhs_ops) {\\n                total_ops += lhs_ops;\\n                shift(lhs_k, j);\\n            } else {\\n                total_ops += rhs_ops;\\n                shift(rhs_k, i);\\n            }\\n        }            \\n        \\n        return total_ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        const auto shift_fwd = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i + 1 <= idx_dest; ++i) {\\n                s[i] = s[i + 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n\\n        const auto shift_rev = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i - 1 >= idx_dest; --i) {\\n                s[i] = s[i - 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n        \\n        const auto shift = [&](int idx_src, int idx_dest) {\\n            if (idx_src < idx_dest) {\\n                shift_fwd(idx_src, idx_dest);\\n            } else if (idx_src > idx_dest) {\\n                shift_rev(idx_src, idx_dest);\\n            }\\n        };        \\n        \\n        int total_ops = 0; \\n        int i = 0, j = s.size() - 1;\\n        for (; i < j; ++i, --j) {\\n            if (s[i] == s[j]) {\\n                continue;\\n            }\\n\\n            int lhs_ops = INT_MAX;\\n            int lhs_k = -1;\\n            {\\n                int k = j - 1;            \\n                for (; k > i; --k) {\\n                    if (s[k] == s[i]) {\\n                        break;\\n                    }\\n                }\\n                if (k != i) {\\n                    lhs_k = k;\\n                    lhs_ops = j - k;\\n                }\\n            }\\n\\n            int rhs_ops = INT_MAX;\\n            int rhs_k = -1;\\n            {\\n                int k = i + 1;\\n                for (; k < j; ++k) {\\n                    if (s[k] == s[j]) {\\n                        break;\\n                    }\\n                }\\n                if (k != j) {\\n                    rhs_k = k;\\n                    rhs_ops = k - i;\\n                }\\n            }\\n\\n            if (lhs_ops < rhs_ops) {\\n                total_ops += lhs_ops;\\n                shift(lhs_k, j);\\n            } else {\\n                total_ops += rhs_ops;\\n                shift(rhs_k, i);\\n            }\\n        }            \\n        \\n        return total_ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823058,
                "title": "two-pointer-approach-c",
                "content": "\\n``` \\nint minMovesToMakePalindrome(string s) {\\n        int moves = 0;\\n        int i =0 , j = s.length()-1;\\n        while(i < j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k = j-1;\\n                while(s[k]!=s[i])\\n                {\\n                    k--;   \\n                }\\n                if(k==i)\\n                {\\n                    swap(s[k],s[k+1]);\\n                    moves++;\\n                    continue;\\n                }\\n                else{\\n                     while(k < j)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        moves++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return moves;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "\\n``` \\nint minMovesToMakePalindrome(string s) {\\n        int moves = 0;\\n        int i =0 , j = s.length()-1;\\n        while(i < j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k = j-1;\\n                while(s[k]!=s[i])\\n                {\\n                    k--;   \\n                }\\n                if(k==i)\\n                {\\n                    swap(s[k],s[k+1]);\\n                    moves++;\\n                    continue;\\n                }\\n                else{\\n                     while(k < j)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        moves++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return moves;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1823036,
                "title": "java-solution-o-n-2",
                "content": "````\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char[] cArr = s.toCharArray();\\n        int i = 0, j = s.length() - 1, count = 0;\\n        while(i < j) {\\n            \\n            /// character at begin equal with character at the end, move forward\\n            if (cArr[i] == cArr[j]) {\\n                i++;\\n                j--;\\n            } else {\\n                /*\\n                character at begin not equal with character at the end so we need to move the first \\n                character equal with start from the end\\n                \\n                Two case here:\\n                1. we able to find a character from the end that match with current start character theb\\n                we could swap them\\n                2. we unable to find the character match with current start character\\n                then we should move current start to the middle\\n                For example: abb => bab\\n                */\\n                \\n                ///find the first position from the end that match with character from start\\n                int k = j;\\n                while(k > i && cArr[k] != cArr[i]) {\\n                    k--;\\n                }\\n                \\n                /// we don\\'t found anything, so we need to move start to middle\\n                if (k == i) {\\n                    swap(cArr, i, i + 1);\\n                    count++;\\n                } else {\\n                    /// we found a first character that match with start character\\n                    while(k < j) {\\n                        swap(cArr, k, k + 1);\\n                        k++;\\n                        count++;\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void swap(char[] cArr, int i, int j) {\\n        char ch = cArr[i];\\n        cArr[i] = cArr[j];\\n        cArr[j] = ch;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char[] cArr = s.toCharArray();\\n        int i = 0, j = s.length() - 1, count = 0;\\n        while(i < j) {\\n            \\n            /// character at begin equal with character at the end, move forward\\n            if (cArr[i] == cArr[j]) {\\n                i++;\\n                j--;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576538,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1648169,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1568739,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1978877,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1909870,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1710073,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            }
        ]
    }
]