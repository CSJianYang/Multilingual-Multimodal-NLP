[
    {
        "title": "Find Common Characters",
        "question_content": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\n&nbsp;\nExample 1:\nInput: words = [\"bella\",\"label\",\"roller\"]\nOutput: [\"e\",\"l\",\"l\"]\nExample 2:\nInput: words = [\"cool\",\"lock\",\"cook\"]\nOutput: [\"c\",\"o\"]\n&nbsp;\nConstraints:\n\t1 <= words.length <= 100\n\t1 <= words[i].length <= 100\n\twords[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 3540699,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        \\n        sort(words.begin(), words.end());\\n        \\n        for (char c : words[0]) {\\n            bool common = true;\\n            \\n            for (int i = 1; i < words.size(); i++) {\\n                if (words[i].find(c) == string::npos) {\\n                    common = false;\\n                    break;\\n                } else {\\n                    words[i].erase(words[i].find(c), 1);\\n                }\\n            }\\n            if (common) {\\n                res.push_back(string(1, c));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words) < 2:\\n            return words\\n        res = []\\n        word1 = set(words[0])\\n        for char in word1:\\n            frequency = min([word.count(char) for word in words])\\n            res += [char] * frequency\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n   public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        \\n        sort(words.begin(), words.end());\\n        \\n        for (char c : words[0]) {\\n            bool common = true;\\n            \\n            for (int i = 1; i < words.size(); i++) {\\n                if (words[i].find(c) == string::npos) {\\n                    common = false;\\n                    break;\\n                } else {\\n                    words[i].erase(words[i].find(c), 1);\\n                }\\n            }\\n            if (common) {\\n                res.push_back(string(1, c));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words) < 2:\\n            return words\\n        res = []\\n        word1 = set(words[0])\\n        for char in word1:\\n            frequency = min([word.count(char) for word in words])\\n            res += [char] * frequency\\n        return res\\n```\n```Java []\\nclass Solution {\\n   public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247560,
                "title": "python-1-line",
                "content": "```\\n    def commonChars(self, A):\\n        res = collections.Counter(A[0])\\n        for a in A:\\n            res &= collections.Counter(a)\\n        return list(res.elements())\\n```\\n\\n1-line version\\n```\\n    def commonChars(self, A):\\n        return list(reduce(collections.Counter.__and__, map(collections.Counter, A)).elements())\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def commonChars(self, A):\\n        res = collections.Counter(A[0])\\n        for a in A:\\n            res &= collections.Counter(a)\\n        return list(res.elements())\\n```\n```\\n    def commonChars(self, A):\\n        return list(reduce(collections.Counter.__and__, map(collections.Counter, A)).elements())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 247573,
                "title": "c-o-n-o-1-two-vectors",
                "content": "For each string, we count characters in ```cnt1```. Then, we track the minimum count for each character in ```cnt```.\\n```\\nvector<string> commonChars(vector<string>& A) {\\n  vector<int> cnt(26, INT_MAX);\\n  vector<string> res;\\n  for (auto s : A) {\\n    vector<int> cnt1(26, 0);\\n    for (auto c : s) ++cnt1[c - \\'a\\'];\\n    for (auto i = 0; i < 26; ++i) cnt[i] = min(cnt[i], cnt1[i]);\\n  }\\n  for (auto i = 0; i < 26; ++i)\\n    for (auto j = 0; j < cnt[i]; ++j) res.push_back(string(1, i + \\'a\\'));\\n  return res;\\n}\\n```\\n## Complexity Analysis\\nRuntime: *O(n)*, where *n* is the total number of characters.\\nMemory: *O(1)* (we use two fixed-size vectors).",
                "solutionTags": [],
                "code": "```cnt1```\n```cnt```\n```\\nvector<string> commonChars(vector<string>& A) {\\n  vector<int> cnt(26, INT_MAX);\\n  vector<string> res;\\n  for (auto s : A) {\\n    vector<int> cnt1(26, 0);\\n    for (auto c : s) ++cnt1[c - \\'a\\'];\\n    for (auto i = 0; i < 26; ++i) cnt[i] = min(cnt[i], cnt1[i]);\\n  }\\n  for (auto i = 0; i < 26; ++i)\\n    for (auto j = 0; j < cnt[i]; ++j) res.push_back(string(1, i + \\'a\\'));\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247558,
                "title": "java-python-3-12-liner-and-7-liner-count-and-look-for-minimum",
                "content": "Initialize `count` array with `Integer.MAX_VALUE`, loop through the input to count the chars in each string; then find out the minimum for each char.\\n\\n**Method 1:**\\n\\n```\\n    public List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            for (int i = 0; i < 26; ++i) { count[i] = Math.min(cnt[i], count[i]); } // update minimum frequency.\\n        }\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n            while (count[c - \\'a\\']-- > 0) { ans.add(\"\" + c); }\\n        }\\n        return ans;\\n    }\\n```\\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = [float(\\'inf\\')] * 26\\n        for s in A:\\n            cnt2 = [0] * 26\\n            for c in s:\\n                cnt2[ord(c) - ord(\\'a\\')] += 1\\n            cnt = [min(cnt[i], cnt2[i]) for i in range(26)]    \\n        return [c for k, c in zip(cnt, string.ascii_lowercase) for _ in range(k)]\\n```\\nor use `Counter`:\\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = collections.Counter(A[0])\\n        for s in A:\\n            cnt2 = collections.Counter(s)\\n            for k in cnt.keys():\\n                cnt[k] = min(cnt[k], cnt2[k])\\n        return cnt.elements()\\n```\\n\\n----\\n**Method 2: Java 8 Stream**\\n\\n```\\n    public List<String> commonChars(String[] A) {\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            IntStream.range(0, 26).forEach(i ->  count[i] = Math.min(cnt[i], count[i])); // update minimum frequency.\\n        }\\n        List<String> ans = new ArrayList<>();\\n        IntStream.range(\\'a\\', \\'z\\' + 1).forEach(c ->  ans.addAll(Collections.nCopies(count[c - \\'a\\'], \"\" + (char)c)));\\n        return ans;\\n    }\\n```\\n\\n----\\n\\n**Analysis:**\\n**Time: O(n)**, where `n` is the total number of characters in A; \\n**extra space: O(1)**, excludes output/return space.\\n\\n----\\n\\n**Q & A**:\\n\\nQ: What does ` ++cnt[c - \\'a\\']; ` mean?\\n\\nA: \\ncount the frequency of chars in String str.\\n\\nc : cnt[c - \\'a\\'] \\n-----------------------------\\n\\'a\\': cnt[\\'a\\' - \\'a\\'] = cnt[0]\\n\\'b\\': cnt[\\'b\\' - \\'a\\'] = cnt[1]\\n\\'c\\': cnt[\\'c\\' - \\'a\\'] = cnt[2]\\n...\\n\\'z\\': cnt[\\'z\\' - \\'a\\'] = cnt[25]\\n--------------------------------\\nif char `c` represents `\\'x\\'`, then  `cnt[c - \\'a\\'] = cnt[23]`. That is, when encountering char \\'x\\', we increase cnt[23] by 1. \\n\\nTherefore, after traversal of all chars in String `str`, we have the frequency (number of occurrence) of each char in `cnt`.",
                "solutionTags": [],
                "code": "```\\n    public List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            for (int i = 0; i < 26; ++i) { count[i] = Math.min(cnt[i], count[i]); } // update minimum frequency.\\n        }\\n        for (char c = \\'a\\'; c <= \\'z\\'; ++c) {\\n            while (count[c - \\'a\\']-- > 0) { ans.add(\"\" + c); }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = [float(\\'inf\\')] * 26\\n        for s in A:\\n            cnt2 = [0] * 26\\n            for c in s:\\n                cnt2[ord(c) - ord(\\'a\\')] += 1\\n            cnt = [min(cnt[i], cnt2[i]) for i in range(26)]    \\n        return [c for k, c in zip(cnt, string.ascii_lowercase) for _ in range(k)]\\n```\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        cnt = collections.Counter(A[0])\\n        for s in A:\\n            cnt2 = collections.Counter(s)\\n            for k in cnt.keys():\\n                cnt[k] = min(cnt[k], cnt2[k])\\n        return cnt.elements()\\n```\n```\\n    public List<String> commonChars(String[] A) {\\n        int[] count = new int[26]; \\n        Arrays.fill(count, Integer.MAX_VALUE);\\n        for (String str : A) {\\n            int[] cnt = new int[26];\\n            str.chars().forEach(c -> ++cnt[c - \\'a\\']); // count each char\\'s frequency in string str.\\n            IntStream.range(0, 26).forEach(i ->  count[i] = Math.min(cnt[i], count[i])); // update minimum frequency.\\n        }\\n        List<String> ans = new ArrayList<>();\\n        IntStream.range(\\'a\\', \\'z\\' + 1).forEach(c ->  ans.addAll(Collections.nCopies(count[c - \\'a\\'], \"\" + (char)c)));\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 332733,
                "title": "python-solution-easy-to-understand",
                "content": "```\\ndef commonChars(self,A):\\n        check = list(A[0])\\n        for word in A:\\n            newCheck = []\\n            for c in word:\\n                if c in check:\\n                    newCheck.append(c)\\n                    check.remove(c)\\n            check = newCheck\\n        \\n        return check\\n```",
                "solutionTags": [],
                "code": "```\\ndef commonChars(self,A):\\n        check = list(A[0])\\n        for word in A:\\n            newCheck = []\\n            for c in word:\\n                if c in check:\\n                    newCheck.append(c)\\n                    check.remove(c)\\n            check = newCheck\\n        \\n        return check\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 712527,
                "title": "c-simple-and-sweet",
                "content": "Runtime: 8 ms, faster than 99.08% of C++ online submissions for Find Common Characters.\\nMemory Usage: 8.9 MB, less than 96.95% of C++ online submissions for Find Common Characters.\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> commonChars(vector<string>& arr) {\\n\\t\\t   vector<int> hash1(26, 0);\\n\\t\\t\\tvector<int> hash2(26, 0);\\n\\n\\t\\t\\tfor(auto ch : arr[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\thash1[ch - \\'a\\']++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 1; i < arr.size() ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(auto ch : arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thash2[ch-\\'a\\']++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\thash1[i] = min(hash1[i], hash2[i]);\\n\\t\\t\\t\\t\\thash2[i] = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\n\\t\\t\\t\\tif(hash1[i] > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint count = hash1[i];\\n\\t\\t\\t\\t\\twhile(count--)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tchar x = i+ \\'a\\';\\n\\t\\t\\t\\t\\t\\tstring s ;\\n\\t\\t\\t\\t\\t\\ts = x;\\n\\t\\t\\t\\t\\t\\tans.push_back(s);\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> commonChars(vector<string>& arr) {\\n\\t\\t   vector<int> hash1(26, 0);\\n\\t\\t\\tvector<int> hash2(26, 0);\\n\\n\\t\\t\\tfor(auto ch : arr[0])\\n\\t\\t\\t{\\n\\t\\t\\t\\thash1[ch - \\'a\\']++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 249739,
                "title": "java-10ms-38mb-clear-solution-with-comments",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        // Common characters dictionary\\n        int[] dict = new int[26];\\n        for (int j = 0; j < A[0].length(); j++) {\\n            dict[A[0].charAt(j) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            // Dictionary of the current word\\n            int[] curr = new int[26];\\n            for (int j = 0; j < A[i].length(); j++) {\\n                curr[A[i].charAt(j) - \\'a\\']++;\\n            }\\n            // Update the common dictionary\\n            for (int j = 0; j < 26; j++) {\\n                if (curr[j] < dict[j]) dict[j] = curr[j];\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < dict[i]; j++) {\\n                ans.add(Character.toString((char) (\\'a\\' + i)));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n        List<String> ans = new ArrayList<>();\\n        // Common characters dictionary\\n        int[] dict = new int[26];\\n        for (int j = 0; j < A[0].length(); j++) {\\n            dict[A[0].charAt(j) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            // Dictionary of the current word\\n            int[] curr = new int[26];\\n            for (int j = 0; j < A[i].length(); j++) {\\n                curr[A[i].charAt(j) - \\'a\\']++;\\n            }\\n            // Update the common dictionary\\n            for (int j = 0; j < 26; j++) {\\n                if (curr[j] < dict[j]) dict[j] = curr[j];\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < dict[i]; j++) {\\n                ans.add(Character.toString((char) (\\'a\\' + i)));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 447986,
                "title": "java-best-solution-100-faster-100-lessor",
                "content": "Just count the characters and reduce intersection of words. Then, convert it back to List.\\n```\\n    public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<String> commonChars(String[] A) {\\n        int[] last = count(A[0]);\\n        for (int i = 1; i < A.length; i++) {\\n            last = intersection(last, count(A[i]));\\n        }\\n        List<String> arr = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (last[i] != 0) {\\n                char a = \\'a\\';\\n                a += i;\\n                String s = String.valueOf(a);\\n                while (last[i] > 0) {\\n                    arr.add(s);\\n                    last[i]--;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[] intersection(int[] a, int[] b) {\\n        int[] t = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            t[i] = Math.min(a[i], b[i]);\\n        }\\n        return t;\\n    }\\n\\n    int[] count(String str) {\\n        int[] t = new int[26];\\n        for (char c : str.toCharArray()) t[c - \\'a\\']++;\\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 259707,
                "title": "java-clean-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (char c = \\'a\\'; c <= \\'z\\'; c++){\\n            int minCount = Integer.MAX_VALUE;\\n            for (String s : A){\\n                int wordCount = 0;\\n                for (char cur_c : s.toCharArray()) if (cur_c == c) wordCount++;\\n                minCount = Math.min(minCount, wordCount);\\n            }\\n            \\n            for (int i = 0; i < minCount; i++) result.add(\"\" + c);\\n        }\\n        \\n        return result;\\n}\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (char c = \\'a\\'; c <= \\'z\\'; c++){\\n            int minCount = Integer.MAX_VALUE;\\n            for (String s : A){\\n                int wordCount = 0;\\n                for (char cur_c : s.toCharArray()) if (cur_c == c) wordCount++;\\n                minCount = Math.min(minCount, wordCount);\\n            }\\n            \\n            for (int i = 0; i < minCount; i++) result.add(\"\" + c);\\n        }\\n        \\n        return result;\\n}\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422308,
                "title": "python-7-lines-beats-100-and-100-in-o-n",
                "content": "```python\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     # make a set from first string\\n        res = []\\n        for one in alist:\\n            n = min([a_word.count(one) for a_word in A])     # count min frequency of every letter in every word\\n            if n:    # if n>0 , we append this letter n times\\n                res += [one]*n\\n        return res\\n```\\n\\n\\n**Runtime: 28 ms**, faster than **100.00%** of Python3 online submissions for Find Common Characters.\\n**Memory Usage: 12.8 MB**, less than **100.00%** of Python3 online submissions for Find Common Characters.\\n\\n**If it helps you , Please give me a star \\nThanks.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if len(A)<2 : return A\\n        alist = set(A[0])     # make a set from first string\\n        res = []\\n        for one in alist:\\n            n = min([a_word.count(one) for a_word in A])     # count min frequency of every letter in every word\\n            if n:    # if n>0 , we append this letter n times\\n                res += [one]*n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515453,
                "title": "javascript-concise-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  let res = [...A[0]];\\n  for (let i = 1; i < A.length; i++) {\\n    res = res.filter(c => {\\n      const l = A[i].length;\\n      A[i] = A[i].replace(c, \"\");\\n      return l > A[i].length;\\n    });\\n  }\\n  return res;\\n};\\n```\\n\\n* 83/83 cases passed (56 ms)\\n* Your runtime beats 97.73 % of javascript submissions\\n* Your memory usage beats 85.71 % of javascript submissions (37 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  let res = [...A[0]];\\n  for (let i = 1; i < A.length; i++) {\\n    res = res.filter(c => {\\n      const l = A[i].length;\\n      A[i] = A[i].replace(c, \"\");\\n      return l > A[i].length;\\n    });\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413601,
                "title": "python-showing-progress-from-64-ms-to-12-ms-from-beating-38-to-100",
                "content": "I\\'ll start with my slowest solution.  During a Contest, fast and reliable code is best, so definitely use ```collections.Counter``` then.  But if you want a fast solution, ```Counter``` tends to do extra work, and so runs slower.  Here\\'s my first solution, clocked at 64 ms:\\n\\n```python\\nfrom collections import Counter\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\t\\t\\t\\n        count = Counter(A[0])\\n        for w in A[1:]:\\n            count &= Counter(w)\\n\\t\\t\\t\\n        return list(count.elements())\\n```\\nThe ```Counter``` class implements ```&=``` by pairing up all the same elements, and reducing their counts to the minimum common count.  Very appropriate for this problem!  Since an empty ```Counter``` has a count of 0, I have to start with one of the words, and I picked ```A[0]```.\\n\\nMy second slowest solution was a bit more creatve than re-using an existing class.  I can\\'t directly compare two words because they\\'re in random order.  But if I ```sort()``` both words, I can see which letters are in common.  Even better, after each comparison I get a list of overlaps.  I can use that list to compare against other words, and keep shrinking it until it only holds the letters common to all of the words.  Here\\'s how that looks in code:\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        key = list(sorted(A[0]))\\n        key_n = len(key)\\n        for w in A:\\n            w_n, w_i, k_i, new_key = len(w), 0, 0, []\\n            sort_w = list(sorted(w))\\n            while k_i < key_n and w_i < w_n:\\n                if sort_w[w_i] > key[k_i]:\\n                    k_i += 1\\n                elif key[k_i] == sort_w[w_i]:\\n                    new_key.append(key[k_i])\\n                    k_i += 1\\n                    w_i += 1\\n                else:\\n                    w_i += 1\\n            key = new_key\\n            key_n = len(new_key)\\n\\n        return key\\n```\\n\\nThat\\'s slightly faster, at 56 ms.  There\\'s another trick to this problem, but it doesn\\'t speed it up much: sort(A) and go through in that order.  Going through the smaller lists first means fewer overlaps, and then later comparisons are made against a smaller list.  But that\\'s still in the 52 ms to 56 ms range.\\n\\nSo that\\'s two solutions, and the ```sort()``` approach doesn\\'t seem to get much faster.  But what about replacing ```Counter``` with custom code?  That would avoid the overhead of a ```Counter``` object, and tracking that isn\\'t needed for this problem.  I could count the number of letters / characters in each word, and then only keep counts that they had in common.  I\\'ll have some extra work to do at the end: I\\'ll need to output the characters times the count.  Since I\\'ll be performing frequency counts in two different places, I split that code into it\\'s own method, giving me:\\n\\n```python\\ndef Freq(w):\\n    fq = {}\\n    for ch in w:\\n        fq[ch] = 1 + fq.get(ch, 0)\\n    return fq\\n\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        common = Freq(A[0])\\n        for w in A[1:]:\\n            fq = Freq(w)\\n            for ch,count in list(common.items()):\\n                try:\\n                    common[ch] = min(count, fq[ch])\\n                except KeyError:\\n                    del common[ch]\\n\\n        res = []\\n        for ch,count in common.items():\\n            res.extend([ch]*count)\\n        return res\\n```\\n\\nWhich runs notably faster at 44 ms.  Note that 44 ms is the faster of two times.  When I rewrote the code to use lists of zeros, the fastest run was still 44 ms.  But it did lead me in a new direction, so I\\'ll show this code - the turning point - here:\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        A_n = len(A)\\n        if A_n < 2:\\n            return A\\n\\n        all_freq = {chr(i):[0]*A_n for i in range(ord(\\'a\\'), ord(\\'z\\')+1)}\\n        for i,w in enumerate(A):\\n            if not w:\\n                return []\\n            for ch in w:\\n                all_freq[ch][i] += 1\\n\\n        res = []\\n        for ch,count_list in all_freq.items():\\n            least = min(count_list)\\n            if least:\\n                res.extend([ch]*least)\\n\\n        return res\\n```\\n\\nThe above all all solutions before I saw anyone else\\'s code.  Sometimes Python prefers approaches that might not intuitively seem faster.  Some Python built-ins are written in \"C\", so the more of your processing that happens in those built-ins, the faster your code runs.  But it\\'s not a guarantee, just something worth trying.\\n\\nMy code above calls ```min()``` in every frequency count.  But I\\'m taking a frequency count of everything, and wasting time calling ```min()``` with a value of 0.  I can avoid that by only going over letters that might be in every word.  I can start with all the letters in one word (the first word), and then only count the frequencies of those letters.  Most of that time will be spent calling ```min()``` and building list comprehensions, which may help improve the speeed.  After seeing another solution, I wrote something similar, which got me going in a new direction.\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if not A:\\n            return []\\n\\n        res = []\\n        key_set = set(A[0])\\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\\n\\nNote that ```res.extend()``` and ```res +=``` have the same functionality, so if you prefer ```+=```, just picture that instead.\\n\\nThis code runs even faster, at 32 ms.  Now it\\'s beating 90% of entries - but really I\\'m taking someone else\\'s idea.  But what if I could improve on their idea.  Python loves list comprehensions... could I write this entire problem in one line?  One big list comprehension?\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        return A and sum([[ch]*min([w.count(ch) for w in A]) for ch in set(A[0])], [])\\n```\\n\\nYou need a wide monitor to call that \"one line\", but it might fit.  But why do I start with ```A and ...```?  What if the input is empty.  If I call ```A[0]``` when A is empty, I\\'ll trigger an exception.  I know that ```3 and 5``` returns 5, while ```[] and 5``` returns ```[]```.  So that\\'s what I\\'m doing here: ```[] and ``` causes my code to return ```[]``` when the input is ```[]```.\\n\\nAnother trick is with sum().  If \"b\" appears once and \"c\" appears 3 times, I\\'ve generated a list that looks like: ```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```.  The problem doesn\\'t call for nested lists.  I need a way to call ```res.extend()``` or ```res +=```.  It turns out ```sum()``` can be used to ```+=``` numbers starting with 0, or it can be used to ```+=``` lists, starting with the empty list.  So I call ```sum(..., [])``` to flatten all my lists, and give the answer ```[\"b\", \"c\", \"c\", \"c\"]``` instead of ```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```.\\n\\nThe rest is a list comprehesion: I go through all the unique letters in the first word, and build a list showing how many times that letter appears in each word.  Then I call ```min()``` to find the least number of occurances.\\n\\nOne line solutions are fun, but in this case it\\'s also fast: 24 ms.  (The slower run was 32 ms, which seems like a wide range to me).  Could I do faster than either of these last two?\\n\\nI figured if I could avoid checking for an empty input, that might speed up the code.  But I have to deal with empty input somehow.  So I put that code in a try/except block to see if that\\'s any faster.  Using an exception to catch the empty input turns out to be my fastest solution to the problem:\\n\\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        res = []\\n        try:\\n            key_set = set(A[0])\\n        except IndexError:\\n            return res\\n        \\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\\n\\nThis code beats 100% of other solutions on time, and on memory.  It runs in 12 ms.  It\\'s other run was 20 ms, which beats 99.7% of other submissions.  In this case, pushing the empty list check into a try/except sped up the code.\\n\\nSo here\\'s a summary of the approaches I used, and the performance of each one.\\n\\nUsing a Counter\\n```text\\nRuntime: 64 ms, faster than 39.04% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 82.35% of Python online submissions for Find Common Characters.\\n```\\n\\nsort() each word\\n```text\\nRuntime: 56 ms, faster than 47.84% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\\n\\nsort() the entire list so the smallest are at the front, then sort() each word:\\n```text\\nRuntime: 52 ms, faster than 51.98% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 94.12% of Python online submissions for Find Common Characters.\\n```\\n\\nuse a dict() to count frequencies:\\n```text\\nRuntime: 44 ms, faster than 62.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\\n\\nloop through the first word\\'s unique letters, count each word, and take the minimum:\\n```text\\nRuntime: 32 ms, faster than 90.21% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\\n\\nOne line solution using ```return A and sum(... , [])```\\n```text\\nRuntime: 24 ms, faster than 98.83% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\\n\\nAnd my fastest solution, using try/except to handle an empty list:\\n```text\\nRuntime: 12 ms, faster than 100.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.7 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\\n\\nI hope you liked my various solutions and explanations.  Feel free to ask me questions about anything that wasn\\'t clear.\\n\\nThere\\'s no official solution to this problem, so what do others think of leetcode using mine?  I\\'m not sure how that works, but up votes will probably help.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```collections.Counter```\n```Counter```\n```python\\nfrom collections import Counter\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\t\\t\\t\\n        count = Counter(A[0])\\n        for w in A[1:]:\\n            count &= Counter(w)\\n\\t\\t\\t\\n        return list(count.elements())\\n```\n```Counter```\n```&=```\n```Counter```\n```A[0]```\n```sort()```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        key = list(sorted(A[0]))\\n        key_n = len(key)\\n        for w in A:\\n            w_n, w_i, k_i, new_key = len(w), 0, 0, []\\n            sort_w = list(sorted(w))\\n            while k_i < key_n and w_i < w_n:\\n                if sort_w[w_i] > key[k_i]:\\n                    k_i += 1\\n                elif key[k_i] == sort_w[w_i]:\\n                    new_key.append(key[k_i])\\n                    k_i += 1\\n                    w_i += 1\\n                else:\\n                    w_i += 1\\n            key = new_key\\n            key_n = len(new_key)\\n\\n        return key\\n```\n```sort()```\n```Counter```\n```Counter```\n```python\\ndef Freq(w):\\n    fq = {}\\n    for ch in w:\\n        fq[ch] = 1 + fq.get(ch, 0)\\n    return fq\\n\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if len(A) < 2:\\n            return A\\n\\n        common = Freq(A[0])\\n        for w in A[1:]:\\n            fq = Freq(w)\\n            for ch,count in list(common.items()):\\n                try:\\n                    common[ch] = min(count, fq[ch])\\n                except KeyError:\\n                    del common[ch]\\n\\n        res = []\\n        for ch,count in common.items():\\n            res.extend([ch]*count)\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        A_n = len(A)\\n        if A_n < 2:\\n            return A\\n\\n        all_freq = {chr(i):[0]*A_n for i in range(ord(\\'a\\'), ord(\\'z\\')+1)}\\n        for i,w in enumerate(A):\\n            if not w:\\n                return []\\n            for ch in w:\\n                all_freq[ch][i] += 1\\n\\n        res = []\\n        for ch,count_list in all_freq.items():\\n            least = min(count_list)\\n            if least:\\n                res.extend([ch]*least)\\n\\n        return res\\n```\n```min()```\n```min()```\n```min()```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        if not A:\\n            return []\\n\\n        res = []\\n        key_set = set(A[0])\\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\n```res.extend()```\n```res +=```\n```+=```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        return A and sum([[ch]*min([w.count(ch) for w in A]) for ch in set(A[0])], [])\\n```\n```A and ...```\n```A[0]```\n```3 and 5```\n```[] and 5```\n```[]```\n```[] and ```\n```[]```\n```[]```\n```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```\n```res.extend()```\n```res +=```\n```sum()```\n```+=```\n```+=```\n```sum(..., [])```\n```[\"b\", \"c\", \"c\", \"c\"]```\n```[ [\"b\"], [\"c\",\"c\",\"c\"] ]```\n```min()```\n```python\\nclass Solution(object):\\n    def commonChars(self, A):\\n        res = []\\n        try:\\n            key_set = set(A[0])\\n        except IndexError:\\n            return res\\n        \\n        for ch in key_set:\\n            n = min([w.count(ch) for w in A])\\n            if n:\\n                res.extend([ch]*n)\\n\\n        return res\\n```\n```text\\nRuntime: 64 ms, faster than 39.04% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 82.35% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 56 ms, faster than 47.84% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 52 ms, faster than 51.98% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 94.12% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 44 ms, faster than 62.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 32 ms, faster than 90.21% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.9 MB, less than 88.24% of Python online submissions for Find Common Characters.\\n```\n```return A and sum(... , [])```\n```text\\nRuntime: 24 ms, faster than 98.83% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.8 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```\n```text\\nRuntime: 12 ms, faster than 100.00% of Python online submissions for Find Common Characters.\\nMemory Usage: 11.7 MB, less than 100.00% of Python online submissions for Find Common Characters.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248428,
                "title": "clear-python-solution",
                "content": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:                        \\n        common_counter = Counter(A[0])                \\n        for str in A[1:]:\\n            common_counter &= Counter(str)                                    \\n        return list(common_counter.elements())\\n\\t\\t\\n```\\n\\nFor Testcase [\"bella\",\"label\",\"roller\"],  **common_counter**  would be \\n\\nCounter({\\'l\\': 2, \\'b\\': 1, \\'e\\': 1, \\'a\\': 1}) \\n->\\nCounter({\\'l\\': 2, \\'b\\': 1, \\'e\\': 1, \\'a\\': 1}) \\n->\\nCounter({\\'l\\': 2, \\'e\\': 1})\\n\\n:D",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:                        \\n        common_counter = Counter(A[0])                \\n        for str in A[1:]:\\n            common_counter &= Counter(str)                                    \\n        return list(common_counter.elements())\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247637,
                "title": "java-two-hashmap-solution-easy-to-understand",
                "content": "The idea here is to use two HashMaps. The first, which we call `union`, will contain all of the common chars found in the strings compared before our current string. Then, before we go through the chars in the current string, we declare a new HashMap, called `temp`. `temp` will contain the chars that are found in our current string which are also found in `union`. \\n\\nWe have to make sure that we don\\'t add a common char too many times. For example, if we have 2 instances of the letter `c` in common strings before the current, but we have three instances of `c` in the current string, we have to make sure that we only count 2 instances of `c` in common. \\n\\nWe do this via the following line: `Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)`. Then, when we finish looping through the current string, we just set `union` to ` temp`. \\n\\n\\t\\tList<String> ans = new ArrayList<String>(); \\n        if(A == null || A.length == 0) return ans; \\n        \\n        HashMap<Character, Integer> union = new HashMap<>(); \\n        for(int i = 0; i < A[0].length(); i++) union.put(A[0].charAt(i), union.getOrDefault(A[0].charAt(i), 0)+1); \\n        \\n        for(int i = 1; i < A.length; i++){\\n            HashMap<Character, Integer> temp = new HashMap<>(); \\n            for(int j = 0; j < A[i].length(); j++){\\n                char curr = A[i].charAt(j); \\n                if(union.containsKey(curr)) temp.put(curr, Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)); \\n            }\\n            union = temp; \\n        }\\n        \\n        for(char c : union.keySet()){\\n            for(int i = 0; i < union.get(c); i++) ans.add(c + \"\"); \\n        }\\n        \\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea here is to use two HashMaps. The first, which we call `union`, will contain all of the common chars found in the strings compared before our current string. Then, before we go through the chars in the current string, we declare a new HashMap, called `temp`. `temp` will contain the chars that are found in our current string which are also found in `union`. \\n\\nWe have to make sure that we don\\'t add a common char too many times. For example, if we have 2 instances of the letter `c` in common strings before the current, but we have three instances of `c` in the current string, we have to make sure that we only count 2 instances of `c` in common. \\n\\nWe do this via the following line: `Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)`. Then, when we finish looping through the current string, we just set `union` to ` temp`. \\n\\n\\t\\tList<String> ans = new ArrayList<String>(); \\n        if(A == null || A.length == 0) return ans; \\n        \\n        HashMap<Character, Integer> union = new HashMap<>(); \\n        for(int i = 0; i < A[0].length(); i++) union.put(A[0].charAt(i), union.getOrDefault(A[0].charAt(i), 0)+1); \\n        \\n        for(int i = 1; i < A.length; i++){\\n            HashMap<Character, Integer> temp = new HashMap<>(); \\n            for(int j = 0; j < A[i].length(); j++){\\n                char curr = A[i].charAt(j); \\n                if(union.containsKey(curr)) temp.put(curr, Math.min(union.get(curr), temp.getOrDefault(curr, 0)+1)); \\n            }\\n            union = temp; \\n        }\\n        \\n        for(char c : union.keySet()){\\n            for(int i = 0; i < union.get(c); i++) ans.add(c + \"\"); \\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 923859,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n^2) space O(n)\\nvar commonChars = function(A) {\\n    const result = []\\n    const firstWordArr = [...A[0]]\\n    \\n    for(const letter of firstWordArr) {\\n        if(A.every(word => word.includes(letter))) {\\n            result.push(letter)\\n            A = A.map(word => word.replace(letter, \\'\\'))\\n        }\\n    }    \\n    \\n    return result\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n^2) space O(n)\\nvar commonChars = function(A) {\\n    const result = []\\n    const firstWordArr = [...A[0]]\\n    \\n    for(const letter of firstWordArr) {\\n        if(A.every(word => word.includes(letter))) {\\n            result.push(letter)\\n            A = A.map(word => word.replace(letter, \\'\\'))\\n        }\\n    }    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 722794,
                "title": "c-very-easy-to-understand-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        vector<int> mainCnt(26, 0);\\n        vector<int> tempCnt(26,0);\\n        for(int i=0;i<A[0].length();i++)\\n            mainCnt[A[0][i]-\\'a\\']++;\\n        for(int i=1;i<A.size();i++){\\n            for(int j=0;j<A[i].length();j++){\\n                tempCnt[A[i][j]-\\'a\\']++;\\n            }\\n            for(int j=0;j<26;j++){\\n                mainCnt[j] = min(tempCnt[j],mainCnt[j]);\\n                tempCnt[j] = 0;\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++){\\n            if(mainCnt[i]>0){\\n                while(mainCnt[i]--){\\n\\t\\t\\t\\t// the below 2 lines convert \\'char\\' type into \\'string\\' type\\n                    string temp = \"\";\\n                    temp += i+\\'a\\';\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFeel free to ask any questions in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        vector<int> mainCnt(26, 0);\\n        vector<int> tempCnt(26,0);\\n        for(int i=0;i<A[0].length();i++)\\n            mainCnt[A[0][i]-\\'a\\']++;\\n        for(int i=1;i<A.size();i++){\\n            for(int j=0;j<A[i].length();j++){\\n                tempCnt[A[i][j]-\\'a\\']++;\\n            }\\n            for(int j=0;j<26;j++){\\n                mainCnt[j] = min(tempCnt[j],mainCnt[j]);\\n                tempCnt[j] = 0;\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++){\\n            if(mainCnt[i]>0){\\n                while(mainCnt[i]--){\\n\\t\\t\\t\\t// the below 2 lines convert \\'char\\' type into \\'string\\' type\\n                    string temp = \"\";\\n                    temp += i+\\'a\\';\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473485,
                "title": "python-99-60-short-and-understandable-solution",
                "content": "Idea is simple:\\n\\n1) We loop over the unique characters in the first word because for a letter to be considered it must be in all words including first word.\\n\\n2) Comparing each character in first word with all other words.\\n3) Check if the character in comparison in the first world exists in the word in comparison\\n4) If it does then count its count and compare with existing count and take the min. Also increment the occurences to see if this character exists in all words.\\n5) If it doesn\\'t then break from the loop as now one of characters isn\\'t in first words and we are no longer interested in it.\\n6) After inside loop exits, check if occurences amount equals that of the amount of words we have to make sure the character in question exists in all the words.\\n7) Lastly add this character which exists in all words with its minimum occurence.\\n\\n```\\n\\t\\tresult = []\\n        for c in set(A[0]):\\n            count = A[0].count(c)\\n            occurences = 1\\n            for i in range(1,len(A)):\\n                if c in A[i]:\\n                    count = min(count,A[i].count(c))\\n                    occurences += 1\\n                else:\\n                    break\\n            if occurences == len(A):\\n                for i in range(count):\\n                    result.append(c)\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tresult = []\\n        for c in set(A[0]):\\n            count = A[0].count(c)\\n            occurences = 1\\n            for i in range(1,len(A)):\\n                if c in A[i]:\\n                    count = min(count,A[i].count(c))\\n                    occurences += 1\\n                else:\\n                    break\\n            if occurences == len(A):\\n                for i in range(count):\\n                    result.append(c)\\n                    \\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274501,
                "title": "java-solution-faster-than-100-simple-logic",
                "content": "*Runtime: 1 ms, faster than 100.00% of Java online submissions for Find Common Characters.\\nMemory Usage: 37.7 MB, less than 100.00% of Java online submissions for Find Common Characters.*\\n\\nVery native solution. We use the first String char_count as a reference.\\nfor example, \"bella\" will count into arr[26] with all letter\\'s count. [b]=1, [e]=1,[l]=2,[a]=1 will be the reference.\\nThen we loop the rest String: for each string ,we did the same new arr[26] count, then scan reference with the new arr count. If count not match, then we need to update the reference count with smaller count. like \"label\" has same char_count, then \"roller\" will update reference as [e]=1, [l]=2;\\nAfter loop the whole string array, we only need to scan the reference count [e]=1, [l]=2 and add the letter into a list respectively with the count number.\\n\\n```\\nclass Solution {\\n    int[] arr = new int[26];\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<String>();\\n        if (A == null || A.length == 0) return list;\\n        int[] arr_ori = new int[26];\\n        for (char c : A[0].toCharArray()) {\\n            arr_ori[c - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            countValid(A[i], arr_ori);\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0) {\\n                for (int j = 0; j < arr_ori[i]; j++) {\\n                    list.add((char)(i+\\'a\\') + \"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    private void countValid(String str, int[] arr_ori) {\\n        for (char c : str.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0 && arr[i] != arr_ori[i]) {\\n                arr_ori[i] = Math.min(arr_ori[i], arr[i]);\\n            }\\n        }\\n        arr = new int[26];\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] arr = new int[26];\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<String>();\\n        if (A == null || A.length == 0) return list;\\n        int[] arr_ori = new int[26];\\n        for (char c : A[0].toCharArray()) {\\n            arr_ori[c - \\'a\\']++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            countValid(A[i], arr_ori);\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0) {\\n                for (int j = 0; j < arr_ori[i]; j++) {\\n                    list.add((char)(i+\\'a\\') + \"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    private void countValid(String str, int[] arr_ori) {\\n        for (char c : str.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (arr_ori[i] != 0 && arr[i] != arr_ori[i]) {\\n                arr_ori[i] = Math.min(arr_ori[i], arr[i]);\\n            }\\n        }\\n        arr = new int[26];\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250620,
                "title": "short-javascript-solution",
                "content": "```\\nvar commonChars = function(A) {\\n    let originalChars = A[0].split(\\'\\');\\n    for (let i = 1; i < A.length; i++) {\\n        let tempChars = A[i].split(\\'\\');\\n        originalChars = originalChars.filter(char => {\\n            let ind = tempChars.indexOf(char);\\n            return ind > -1 ? tempChars[ind] = true : false;\\n        });\\n    }\\n    return originalChars;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar commonChars = function(A) {\\n    let originalChars = A[0].split(\\'\\');\\n    for (let i = 1; i < A.length; i++) {\\n        let tempChars = A[i].split(\\'\\');\\n        originalChars = originalChars.filter(char => {\\n            let ind = tempChars.indexOf(char);\\n            return ind > -1 ? tempChars[ind] = true : false;\\n        });\\n    }\\n    return originalChars;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175578,
                "title": "c-easy-simple",
                "content": "***Do upvote if you found the solution helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n***Explanation in the comments section***\\n```\\nclass Solution {\\npublic:\\n     vector<string> commonChars(vector<string>& A)\\n     {\\n         vector<int> count(26,INT_MAX);\\n         vector<string> res;\\n         \\n         for(auto i: A)\\n         {\\n             vector<int> temp(26,0);\\n             for(auto j: i)\\n             {\\n                 temp[j-\\'a\\']++;\\n             }\\n             \\n             for(int k=0 ; k<26 ;k++)\\n             {\\n                 count[k] = min(count[k],temp[k]);\\n             }\\n         }\\n         \\n         for(int l=0 ; l<26 ;l++)\\n         {\\n             while(count[l]--)\\n             {\\n                 res.push_back(string(1 , l+\\'a\\'));\\n             }\\n         }\\n         return res;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<string> commonChars(vector<string>& A)\\n     {\\n         vector<int> count(26,INT_MAX);\\n         vector<string> res;\\n         \\n         for(auto i: A)\\n         {\\n             vector<int> temp(26,0);\\n             for(auto j: i)\\n             {\\n                 temp[j-\\'a\\']++;\\n             }\\n             \\n             for(int k=0 ; k<26 ;k++)\\n             {\\n                 count[k] = min(count[k],temp[k]);\\n             }\\n         }\\n         \\n         for(int l=0 ; l<26 ;l++)\\n         {\\n             while(count[l]--)\\n             {\\n                 res.push_back(string(1 , l+\\'a\\'));\\n             }\\n         }\\n         return res;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211860,
                "title": "java-intuitive-approach-using-list-of-hashmap-explained-with-comments",
                "content": "# Commented Code(for clean code scroll down)\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        //create list of hashmap so that we can store the frequency of characters for each string\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        // Ex: TC1 would look something like this [{a=1, b=1, e=1, l=2}, {a=1, b=1, e=1, l=2}, {r=2, e=1, l=2, o=1}]\\n\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n//take the key of the first map in string(doesnt really matter 1st or 2nd just to avoid out of bound error take 0th index map\\'s keySet)\\n            int min = Integer.MAX_VALUE;//find out the minimum occurrence of a character which is common in every string\\n            for (HashMap<Character, Integer> map : list) {//just iterate over all the maps and get the min occurrence\\n                if (!map.containsKey(ch)) {\\n//if map doesnt contain a key then we are sure that this particiular character is not common\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n//put the common chararcter in the ans list (loop will take care of duplicates as in TC1 chaar \\'l\\' is present twice in every string so min value for \\'l\\' would be 2 and hence we added it twice)\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Clean code without comments\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n            int min = Integer.MAX_VALUE;\\n            for (HashMap<Character, Integer> map : list) {\\n                if (!map.containsKey(ch)) {\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        //create list of hashmap so that we can store the frequency of characters for each string\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        // Ex: TC1 would look something like this [{a=1, b=1, e=1, l=2}, {a=1, b=1, e=1, l=2}, {r=2, e=1, l=2, o=1}]\\n\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n//take the key of the first map in string(doesnt really matter 1st or 2nd just to avoid out of bound error take 0th index map\\'s keySet)\\n            int min = Integer.MAX_VALUE;//find out the minimum occurrence of a character which is common in every string\\n            for (HashMap<Character, Integer> map : list) {//just iterate over all the maps and get the min occurrence\\n                if (!map.containsKey(ch)) {\\n//if map doesnt contain a key then we are sure that this particiular character is not common\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n//put the common chararcter in the ans list (loop will take care of duplicates as in TC1 chaar \\'l\\' is present twice in every string so min value for \\'l\\' would be 2 and hence we added it twice)\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<HashMap<Character,Integer>> list = new ArrayList<>();\\n        for(String s: words){\\n            HashMap<Character,Integer> map = new HashMap<>();\\n            for(char ch: s.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n            }\\n            list.add(map);\\n        }\\n        List<String> ans = new ArrayList<>();\\n        for(char ch : list.get(0).keySet()) {\\n            int min = Integer.MAX_VALUE;\\n            for (HashMap<Character, Integer> map : list) {\\n                if (!map.containsKey(ch)) {\\n                    min = 0;\\n                    break;\\n                }\\n                min = Math.min(min, map.get(ch));\\n            }\\n            for (int i = 0; i < min; i++) {\\n                ans.add(String.valueOf(ch));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247798,
                "title": "detailed-explanation-c-o-n",
                "content": "**Approach**\\n* \\tCreate a vector `freq` that maps each character of the alphabet to its frequency in any given string.\\n* \\tCreate a vector `minMatching` that stores the count of characters which occur in all the strings so far\\n* \\tTraverse the list of strings and for each string, update (overwrite) the `freq` vector and accordingly update the `minMatching` vector.\\n* \\tAt the end, traverse the `minMatching` vector and append each character as a single string in the answer vector.\\n\\n**MIscellaneous**\\n* The `minMatching` vector has been initialised with `INT_MAX` instead of `0` to handle the updation of first string. After that, all the non-appearing charcters would be set to zero.\\n```\\nclass Solution\\n{\\n    int alphabetSize = 26;\\n    vector<int> freq;\\n    vector<int> minMatching;\\n    vector<string> answer;\\npublic:   \\n    Solution()\\n    {\\n        freq.resize(alphabetSize);\\n        minMatching.resize(alphabetSize, INT_MAX);\\n    }\\n    void mapCharacters(string str);\\n    vector<string> commonChars(vector<string>& a);\\n};\\n\\n/* Maps the characters to its frequency */\\nvoid Solution :: mapCharacters(string str)\\n{\\n    // Initialise the frequency vector with zero\\n    for(auto &ele:freq)\\n        ele = 0;\\n    \\n    // Increase the frequency of each element as it is encountered\\n    for(auto ele : str)\\n        freq[ele-\\'a\\']++;\\n}\\n\\n/* Returns the common characters in all the strings */\\nvector<string> Solution :: commonChars(vector<string>& a)\\n{\\n    // Iterate throught each string\\n    for(auto str : a)\\n    {\\n        // Map the charcters in the frequency vector\\n        mapCharacters(str);\\n        \\n        // Traverse the frequency map , and update the minimum matching\\n        for(int i=0; i<alphabetSize; i++)\\n            minMatching[i] = min(minMatching[i], freq[i]);\\n    }\\n\\n    // Traverse the minMatching vector and fill the answer\\n    for(int i=0; i<alphabetSize; i++)\\n    {\\n        // Get the minimum number of repetitions of ecah charcter and append it to answer\\n        int count = minMatching[i];\\n        for(int j=0; j<count; j++)\\n            answer.push_back(string(1, \\'a\\'+i));\\n    }\\n    \\n    return answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    int alphabetSize = 26;\\n    vector<int> freq;\\n    vector<int> minMatching;\\n    vector<string> answer;\\npublic:   \\n    Solution()\\n    {\\n        freq.resize(alphabetSize);\\n        minMatching.resize(alphabetSize, INT_MAX);\\n    }\\n    void mapCharacters(string str);\\n    vector<string> commonChars(vector<string>& a);\\n};\\n\\n/* Maps the characters to its frequency */\\nvoid Solution :: mapCharacters(string str)\\n{\\n    // Initialise the frequency vector with zero\\n    for(auto &ele:freq)\\n        ele = 0;\\n    \\n    // Increase the frequency of each element as it is encountered\\n    for(auto ele : str)\\n        freq[ele-\\'a\\']++;\\n}\\n\\n/* Returns the common characters in all the strings */\\nvector<string> Solution :: commonChars(vector<string>& a)\\n{\\n    // Iterate throught each string\\n    for(auto str : a)\\n    {\\n        // Map the charcters in the frequency vector\\n        mapCharacters(str);\\n        \\n        // Traverse the frequency map , and update the minimum matching\\n        for(int i=0; i<alphabetSize; i++)\\n            minMatching[i] = min(minMatching[i], freq[i]);\\n    }\\n\\n    // Traverse the minMatching vector and fill the answer\\n    for(int i=0; i<alphabetSize; i++)\\n    {\\n        // Get the minimum number of repetitions of ecah charcter and append it to answer\\n        int count = minMatching[i];\\n        for(int j=0; j<count; j++)\\n            answer.push_back(string(1, \\'a\\'+i));\\n    }\\n    \\n    return answer;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346579,
                "title": "python-solution-beat-95",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        for ch in set(A[0]):\\n            count = []\\n            for word in A:\\n                count.append(word.count(ch))\\n            res += ch * min(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        for ch in set(A[0]):\\n            count = []\\n            for word in A:\\n                count.append(word.count(ch))\\n            res += ch * min(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250336,
                "title": "python-100-no-built-ins-straight-forward-with-comments",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        answer = None\\n        \\n        for a in A:\\n            # create the counts for the current word\\n            work = {}\\n            for c in a:\\n                if c in work:\\n                    work[c] += 1\\n                else:\\n                    work[c] = 1\\n            \\n            # compare the current word counts\\n            # keep the least of the common ones\\n            # delete the ones in the answer not found in the current word\\n            if answer != None:\\n                keys = list(answer.keys())\\n                for k in keys:\\n                    if k in work:\\n                        answer[k] = min(answer[k], work[k])\\n                    else:\\n                        del answer[k]\\n            else:\\n                answer = work\\n\\n        # turn the counts into an array\\n        answerArr = []\\n        for key in answer:\\n            count = answer[key]\\n            for _ in xrange(count):\\n                answerArr.append(key)\\n        \\n        return answerArr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        answer = None\\n        \\n        for a in A:\\n            # create the counts for the current word\\n            work = {}\\n            for c in a:\\n                if c in work:\\n                    work[c] += 1\\n                else:\\n                    work[c] = 1\\n            \\n            # compare the current word counts\\n            # keep the least of the common ones\\n            # delete the ones in the answer not found in the current word\\n            if answer != None:\\n                keys = list(answer.keys())\\n                for k in keys:\\n                    if k in work:\\n                        answer[k] = min(answer[k], work[k])\\n                    else:\\n                        del answer[k]\\n            else:\\n                answer = work\\n\\n        # turn the counts into an array\\n        answerArr = []\\n        for key in answer:\\n            count = answer[key]\\n            for _ in xrange(count):\\n                answerArr.append(key)\\n        \\n        return answerArr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248223,
                "title": "hashmap-java-100",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character,Integer> map=new HashMap<>();\\n        for(char c:A[0].toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            Map<Character,Integer> tmp=new HashMap<>();\\n            for(int j=0;j<A[i].length();j++){\\n                char c=A[i].charAt(j);\\n                if(map.containsKey(c) && map.get(c)>0){\\n                    tmp.put(c,tmp.getOrDefault(c,0)+1);\\n                    map.put(c,map.get(c)-1);\\n                }\\n            }\\n            map=tmp;\\n            if(map.size()==0)break;\\n        }\\n        List<String> res=new ArrayList<>();\\n        for(Character c:map.keySet()){\\n            for(int k=0;k<map.get(c);k++){\\n                res.add(\"\"+c);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character,Integer> map=new HashMap<>();\\n        for(char c:A[0].toCharArray()){\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            Map<Character,Integer> tmp=new HashMap<>();\\n            for(int j=0;j<A[i].length();j++){\\n                char c=A[i].charAt(j);\\n                if(map.containsKey(c) && map.get(c)>0){\\n                    tmp.put(c,tmp.getOrDefault(c,0)+1);\\n                    map.put(c,map.get(c)-1);\\n                }\\n            }\\n            map=tmp;\\n            if(map.size()==0)break;\\n        }\\n        List<String> res=new ArrayList<>();\\n        for(Character c:map.keySet()){\\n            for(int k=0;k<map.get(c);k++){\\n                res.add(\"\"+c);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271676,
                "title": "easy-js-sol-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n- This below **approach** works because if a **character** appears in every word in the input array, then its frequency in **charFreqs** will be equal to the **minimum frequency** of that character across all words. \\n\\n- By taking the intersection of the frequency maps for each word, we effectively *find the common characters across all words.*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe below code uses a *frequency counting approach to find the common characters across all words in the input array.*\\n\\n1. It first initializes a Map object called **charFreqs** with the frequency of each character in the first word of the input array. \\n\\n2. It then iterates through the rest of the words in the array and for each word, it creates a new Map object called **wordFreqs** to *store the frequency of each character in the current word.*\\n\\n3. For each character in **charFreqs**, the code checks if it also appears in **wordFreqs**. \\n\\n4. If it does, the code updates the frequency of that character in **charFreqs** to the minimum of its current frequency and its frequency in **wordFreqs**. \\n\\n5. If it does not, the code deletes the character from **charFreqs**.\\n\\n6. Finally, the code converts the resulting **charFreqs** Map object to an **array of common characters**, where each character appears as many times as its frequency in **charFreqs**.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here **n** is the number of words in the input array and **m** is the length of the longest word. \\n\\n2. This is because the algorithm iterates through each word in the array once and performs a constant amount of work for each character in each word.\\n\\n\\n\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n1. Here k is the number of distinct characters across all the words.\\n\\n2. This is because the algorithm creates a Map object to store the frequency of each character, which has a space complexity proportional to the number of distinct keys (characters) it contains.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nvar commonChars = function(words) {\\n    \\n    let charFreqs = new Map();\\n    // initialize charFreqs with the first word\\n    \\n    for (let char of words[0]) {\\n        \\n        charFreqs.set(char, (charFreqs.get(char) || 0) + 1);\\n    }\\n    \\n    // iterate through the rest of the words\\n    for (let i = 1; i < words.length; i++) {\\n        \\n        let wordFreqs = new Map();\\n        \\n        for (let char of words[i]) {\\n            \\n            wordFreqs.set(char, (wordFreqs.get(char) || 0) + 1);\\n        }\\n        \\n        // update charFreqs with the intersection of wordFreqs\\n        for (let [char, freq] of charFreqs) {\\n            \\n            if (wordFreqs.has(char)) {\\n                charFreqs.set(char, Math.min(freq, wordFreqs.get(char)));\\n            }\\n            \\n            else {\\n                \\n                charFreqs.delete(char);\\n            }\\n        }\\n    }\\n    \\n    // convert charFreqs to an array of characters\\n    let result = [];\\n    \\n    for (let [char, freq] of charFreqs) {\\n        \\n        for (let i = 0; i < freq; i++) {\\n            \\n            result.push(char);\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/9a4a1a61-4716-41af-a842-8a8b7f2e1d31_1678263114.7496967.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n\\nvar commonChars = function(words) {\\n    \\n    let charFreqs = new Map();\\n    // initialize charFreqs with the first word\\n    \\n    for (let char of words[0]) {\\n        \\n        charFreqs.set(char, (charFreqs.get(char) || 0) + 1);\\n    }\\n    \\n    // iterate through the rest of the words\\n    for (let i = 1; i < words.length; i++) {\\n        \\n        let wordFreqs = new Map();\\n        \\n        for (let char of words[i]) {\\n            \\n            wordFreqs.set(char, (wordFreqs.get(char) || 0) + 1);\\n        }\\n        \\n        // update charFreqs with the intersection of wordFreqs\\n        for (let [char, freq] of charFreqs) {\\n            \\n            if (wordFreqs.has(char)) {\\n                charFreqs.set(char, Math.min(freq, wordFreqs.get(char)));\\n            }\\n            \\n            else {\\n                \\n                charFreqs.delete(char);\\n            }\\n        }\\n    }\\n    \\n    // convert charFreqs to an array of characters\\n    let result = [];\\n    \\n    for (let [char, freq] of charFreqs) {\\n        \\n        for (let i = 0; i < freq; i++) {\\n            \\n            result.push(char);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595220,
                "title": "python-unique-way-using-dictionary-faster-than-100-00-less-than-77-78",
                "content": "\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        \\n        res = [] \\n        d = defaultdict(lambda: 0) \\n        # create default dictionary with key as character, and value as the occurence\\n        # since the constraint is that there is always more than 1 item in the list, we can do this\\n        for x in words[0]:\\n            d[x] += 1\\n        \\n        \\n        for key in d: # check each key in the dictinary to see if the character exist in the item in the list\\n            for word in words[1:]: # since we already looked up the first element, start from the second\\n                if not key in word: # if key does not exsit in the item, set the occurence as 0\\n                    d[key] = 0\\n                else:\\n                    # check the value of the key in the dictinonary is more than 1\\n                    # in that case, we need to check how many of the same key(character) exists in the item\\n                    # and keep the minimun value of the occurence\\n                    if d[key] > 1:\\n                        d[key] = min(d[key], word.count(key)) \\n                        \\n        \\n\\t\\t# now the dictionary holds the common characters as key and its occurences as value\\n        for key, value in d.items():\\n            if value > 0:\\n                for i in range(value):\\n                    res.append(key)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        \\n        res = [] \\n        d = defaultdict(lambda: 0) \\n        # create default dictionary with key as character, and value as the occurence\\n        # since the constraint is that there is always more than 1 item in the list, we can do this\\n        for x in words[0]:\\n            d[x] += 1\\n        \\n        \\n        for key in d: # check each key in the dictinary to see if the character exist in the item in the list\\n            for word in words[1:]: # since we already looked up the first element, start from the second\\n                if not key in word: # if key does not exsit in the item, set the occurence as 0\\n                    d[key] = 0\\n                else:\\n                    # check the value of the key in the dictinonary is more than 1\\n                    # in that case, we need to check how many of the same key(character) exists in the item\\n                    # and keep the minimun value of the occurence\\n                    if d[key] > 1:\\n                        d[key] = min(d[key], word.count(key)) \\n                        \\n        \\n\\t\\t# now the dictionary holds the common characters as key and its occurences as value\\n        for key, value in d.items():\\n            if value > 0:\\n                for i in range(value):\\n                    res.append(key)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283550,
                "title": "c-faster-than-99-26-unique-map-approach-with-detailed-explanation",
                "content": "**Please leave an upvote if you feel the efforts were good enough, Thank You**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int sz = words.size();\\n        vector<string> ans;\\n        unordered_map<char, array<int,100>> mp;        //This map stores the count of each letter in every word(assuming there are max 100 words)\\n         \\n        for(int i=0;i<sz;i++)       //get each word\\n        {\\n            for(int j=0;j<words[i].size();j++)      //get each letter in word\\n                mp[words[i][j]][i]++;               //increment the count at appropriate index in map\\n        }\\n        int cnt=0;      //count variable to keep minimum occurence count of a letter in each word\\n        for(auto x:mp)\\n        {\\n            cnt = INT_MAX;\\n            for(int i=0;i<sz;i++)\\n            {\\n                if(x.second[i]< cnt)\\n                    cnt = x.second[i];      //get the minimum common occurence\\n            }\\n            string s(1, x.first);\\n            for(int i=0;i<cnt;i++)\\n                ans.push_back(s);           //push to the answer vector \\'count\\' times\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int sz = words.size();\\n        vector<string> ans;\\n        unordered_map<char, array<int,100>> mp;        //This map stores the count of each letter in every word(assuming there are max 100 words)\\n         \\n        for(int i=0;i<sz;i++)       //get each word\\n        {\\n            for(int j=0;j<words[i].size();j++)      //get each letter in word\\n                mp[words[i][j]][i]++;               //increment the count at appropriate index in map\\n        }\\n        int cnt=0;      //count variable to keep minimum occurence count of a letter in each word\\n        for(auto x:mp)\\n        {\\n            cnt = INT_MAX;\\n            for(int i=0;i<sz;i++)\\n            {\\n                if(x.second[i]< cnt)\\n                    cnt = x.second[i];      //get the minimum common occurence\\n            }\\n            string s(1, x.first);\\n            for(int i=0;i<cnt;i++)\\n                ans.push_back(s);           //push to the answer vector \\'count\\' times\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075750,
                "title": "faster-than-99-71-python-with-hash-table-easy-to-understand",
                "content": "Step 1: count all letter in first word, save result in hash table \"count\"\\nStep 2: for each letter in first word, check if it exists in all the rest words, if exist: \\nStep 3: find the min counts for that letter, and overwrite the count value in hash table. if doesn\\'t exist:\\nStep 4: overwrite the count of that letter to 0, and break the inner loop\\nStep 5: define an empty list `l`, for all the letter in hash table, use the `l+= [letter] *count`  to generate final answer\\n\\n\\n\\n```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        count = {}\\n        for x in A[0]:\\n            count[x] = count.get(x, 0) + 1\\n            \\n        \\n        for x in count:\\n            for i in range(1,len(A)):\\n                if x in A[i]:\\n                    count[x] = min(count[x], A[i].count(x))\\n                    \\n                else:\\n                    count[x] = 0\\n                    break\\n        \\n        ans = []\\n        for k,v in count.items():\\n            ans += v * [k]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        count = {}\\n        for x in A[0]:\\n            count[x] = count.get(x, 0) + 1\\n            \\n        \\n        for x in count:\\n            for i in range(1,len(A)):\\n                if x in A[i]:\\n                    count[x] = min(count[x], A[i].count(x))\\n                    \\n                else:\\n                    count[x] = 0\\n                    break\\n        \\n        ans = []\\n        for k,v in count.items():\\n            ans += v * [k]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506674,
                "title": "javascript-solution-straightforward",
                "content": "```\\nvar commonChars = function(A) {\\n    return A.reduce(findCommon, A[0].split(\\'\\'))\\n};\\n\\nconst findCommon = (prev, curr) => {\\n    curr = curr.split(\\'\\');\\n    return prev.filter(p => {\\n        const i = curr.indexOf(p);\\n        if(i !== -1) {\\n            curr.splice(i, 1);\\n            return true;\\n        }\\n        return false;\\n    });\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar commonChars = function(A) {\\n    return A.reduce(findCommon, A[0].split(\\'\\'))\\n};\\n\\nconst findCommon = (prev, curr) => {\\n    curr = curr.split(\\'\\');\\n    return prev.filter(p => {\\n        const i = curr.indexOf(p);\\n        if(i !== -1) {\\n            curr.splice(i, 1);\\n            return true;\\n        }\\n        return false;\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233490,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        //Go through each char in the first string\\n        for (int i=0; i<words[0].length(); i++) {\\n            int flag = 0; \\n            char c = words[0].charAt(i);\\n            //Go through each string in words starting from the second string\\n            for (int j=1; j<words.length; j++){\\n                int index = words[j].indexOf(c);\\n                //if char is not in the string then break and set flag to 1\\n                if (index==-1) {\\n                    flag = 1;\\n                    break;\\n                }\\n                else {\\n                    words[j]= words[j].substring(0, index) + words[j].substring(index+1); //delete the char the is already compared\\n                }\\n            }\\n            //if flag is 0 that means char is in all the string thus add to result\\n            if (flag==0) {\\n                result.add(Character.toString(c));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n//Time: O(N*M) where N is char in the first string and M is number of string\\n//Space: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        //Go through each char in the first string\\n        for (int i=0; i<words[0].length(); i++) {\\n            int flag = 0; \\n            char c = words[0].charAt(i);\\n            //Go through each string in words starting from the second string\\n            for (int j=1; j<words.length; j++){\\n                int index = words[j].indexOf(c);\\n                //if char is not in the string then break and set flag to 1\\n                if (index==-1) {\\n                    flag = 1;\\n                    break;\\n                }\\n                else {\\n                    words[j]= words[j].substring(0, index) + words[j].substring(index+1); //delete the char the is already compared\\n                }\\n            }\\n            //if flag is 0 that means char is in all the string thus add to result\\n            if (flag==0) {\\n                result.add(Character.toString(c));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n//Time: O(N*M) where N is char in the first string and M is number of string\\n//Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161807,
                "title": "python-simple-and-easy-to-understand",
                "content": "```\\n\\nlength = len(A)\\noutput = []\\nfor i in A[0]:\\n\\tcheck = True\\n\\tfor j in range(1, length):\\n\\t\\tif i in A[j] and check:\\n\\t\\t\\tA[j] = A[j].replace(i, \"\", 1)\\n\\t\\t\\tcheck = i\\n\\t\\telse:\\n\\t\\t\\tcheck = None\\n\\tif check == i:\\n\\t\\toutput.append(i)\\n\\nreturn output\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nlength = len(A)\\noutput = []\\nfor i in A[0]:\\n\\tcheck = True\\n\\tfor j in range(1, length):\\n\\t\\tif i in A[j] and check:\\n\\t\\t\\tA[j] = A[j].replace(i, \"\", 1)\\n\\t\\t\\tcheck = i\\n\\t\\telse:\\n\\t\\t\\tcheck = None\\n\\tif check == i:\\n\\t\\toutput.append(i)\\n\\nreturn output\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721548,
                "title": "python-faster-than-77-67-and-better-space-than-86-74",
                "content": "It takes 302 steps just to complete with the sample input [\"bella\",\"label\",\"roller\"] so I  thought my solution would end up being miserably slow compared to other submissions but it actually seems to hold up fairly decent.\\n```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        alphabet = string.ascii_lowercase\\n        d = {c: 0 for c in alphabet}\\n        \\n        for k, v in d.items():\\n            d[k] = min([word.count(k) for word in A])\\n\\n        res = []\\n        for c, n in d.items():\\n            if n > 0:\\n                res += [c] * n\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/17f1a637-682d-4135-8db4-fc009842b8a3_1593978255.9363427.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        alphabet = string.ascii_lowercase\\n        d = {c: 0 for c in alphabet}\\n        \\n        for k, v in d.items():\\n            d[k] = min([word.count(k) for word in A])\\n\\n        res = []\\n        for c, n in d.items():\\n            if n > 0:\\n                res += [c] * n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545858,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        map<char,int> ans;\\n        for(auto ch: A[0]){\\n            ans[ch]++;\\n        }\\n        map<char,int>cur;\\n        for(auto& word:A){\\n            cur.clear();\\n            for(auto ch:word){\\n                cur[ch]++;\\n            }\\n            for(auto& it:ans){\\n                it.second = min(it.second,cur[it.first]);\\n            }\\n        }\\n        vector<string> sol;\\n        string s;\\n        for(auto& it:ans){\\n            while(it.second!=0){\\n                s=it.first;\\n                sol.push_back(s);\\n                it.second--;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        map<char,int> ans;\\n        for(auto ch: A[0]){\\n            ans[ch]++;\\n        }\\n        map<char,int>cur;\\n        for(auto& word:A){\\n            cur.clear();\\n            for(auto ch:word){\\n                cur[ch]++;\\n            }\\n            for(auto& it:ans){\\n                it.second = min(it.second,cur[it.first]);\\n            }\\n        }\\n        vector<string> sol;\\n        string s;\\n        for(auto& it:ans){\\n            while(it.second!=0){\\n                s=it.first;\\n                sol.push_back(s);\\n                it.second--;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353247,
                "title": "java-beats-100-in-speed-and-takes-100-less-memory",
                "content": "```\\nclass Solution {\\n    public int[] getCharCountBucket(String word, int[] charCount) {\\n        int[] charCountBucket = new int[26];\\n        for (char ch : word.toCharArray()) {\\n            if (charCount[ch - 97] > 0) {\\n                charCount[ch - 97]--;\\n                charCountBucket[ch - 97]++;\\n            }\\n        }\\n        return charCountBucket;\\n    }\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList();\\n        if (A.length == 0) {\\n            return new ArrayList<String>();\\n        }\\n        int[] charCount = new int[26];\\n        for (char ch : A[0].toCharArray()) {\\n            charCount[ch - 97]++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            charCount = getCharCountBucket(A[i], charCount);\\n        }\\n        for (int i = 0; i < charCount.length; i++) {\\n            while (charCount[i] > 0) {\\n                result.add(\"\" + (char)(i + 97));\\n                charCount[i]--;\\n            }\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getCharCountBucket(String word, int[] charCount) {\\n        int[] charCountBucket = new int[26];\\n        for (char ch : word.toCharArray()) {\\n            if (charCount[ch - 97] > 0) {\\n                charCount[ch - 97]--;\\n                charCountBucket[ch - 97]++;\\n            }\\n        }\\n        return charCountBucket;\\n    }\\n    public List<String> commonChars(String[] A) {\\n        List<String> result = new ArrayList();\\n        if (A.length == 0) {\\n            return new ArrayList<String>();\\n        }\\n        int[] charCount = new int[26];\\n        for (char ch : A[0].toCharArray()) {\\n            charCount[ch - 97]++;\\n        }\\n        for (int i = 1; i < A.length; i++) {\\n            charCount = getCharCountBucket(A[i], charCount);\\n        }\\n        for (int i = 0; i < charCount.length; i++) {\\n            while (charCount[i] > 0) {\\n                result.add(\"\" + (char)(i + 97));\\n                charCount[i]--;\\n            }\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321240,
                "title": "java-high-performance",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n\\tList<String> res=new ArrayList<String>();\\n\\tint[] min=new int[26];\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tmin[i]=Integer.MAX_VALUE;\\n\\t}\\n\\tfor(String s:A){\\n\\t\\tint[] cur=new int[26];\\n\\t\\tchar[] ca=s.toCharArray();\\n\\t\\tfor(char c:ca){\\n\\t\\t\\tcur[c -\\'a\\']++;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\tmin[i]=Math.min(min[i],cur[i]);\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tfor(int j=0;j<min[i];j++){\\n\\t\\t\\tres.add(String.valueOf((char)(i+\\'a\\')));\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n\\tList<String> res=new ArrayList<String>();\\n\\tint[] min=new int[26];\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tmin[i]=Integer.MAX_VALUE;\\n\\t}\\n\\tfor(String s:A){\\n\\t\\tint[] cur=new int[26];\\n\\t\\tchar[] ca=s.toCharArray();\\n\\t\\tfor(char c:ca){\\n\\t\\t\\tcur[c -\\'a\\']++;\\n\\t\\t}\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\tmin[i]=Math.min(min[i],cur[i]);\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<26;i++){\\n\\t\\tfor(int j=0;j<min[i];j++){\\n\\t\\t\\tres.add(String.valueOf((char)(i+\\'a\\')));\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260815,
                "title": "javascript-99-time-100-memory-easy-to-understand-iterative-method",
                "content": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n    let ans = A[0].split(\"\");\\n    for(let i=1; i< A.length; i++){\\n        ans = findCommon(ans, A[i].split(\"\"));\\n    }\\n    return ans;\\n};\\n\\nvar findCommon = function(a,b){\\n  return a.filter(v=>{\\n      let i = b.indexOf(v);\\n      if(i !== -1){\\n          b.splice(i, 1);\\n          return true\\n      }\\n      return false;\\n  })\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n    let ans = A[0].split(\"\");\\n    for(let i=1; i< A.length; i++){\\n        ans = findCommon(ans, A[i].split(\"\"));\\n    }\\n    return ans;\\n};\\n\\nvar findCommon = function(a,b){\\n  return a.filter(v=>{\\n      let i = b.indexOf(v);\\n      if(i !== -1){\\n          b.splice(i, 1);\\n          return true\\n      }\\n      return false;\\n  })\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2625261,
                "title": "simple-counter-49ms",
                "content": "![image](https://assets.leetcode.com/users/images/6bf5ce0d-9bf7-4ae8-b832-5405476a9384_1664167116.9646862.png)\\n\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        data = collections.Counter(words[0])\\n        for word in words:\\n            data2 = collections.Counter(word)\\n            for k in data.keys():\\n                data[k] = min(data[k], data2[k])\\n        return data.elements()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        data = collections.Counter(words[0])\\n        for word in words:\\n            data2 = collections.Counter(word)\\n            for k in data.keys():\\n                data[k] = min(data[k], data2[k])\\n        return data.elements()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099192,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        int count[][] = new int[words.length][26];\\n        List<Integer> l = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        for(int i=0; i<words.length; i++)\\n        {\\n            for(int j=0; j<words[i].length(); j++)\\n                count[i][(int)(words[i].charAt(j) - 97)]++;\\n        }\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<words.length; j++)\\n            {\\n                l.add(count[j][i]);\\n            }\\n            int min = Collections.min(l);\\n            l.clear();\\n            if(min > 0)\\n            {\\n                for(int j=0; j<min; j++)\\n                {\\n                    res.add(String.valueOf((char)(i + 97)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        int count[][] = new int[words.length][26];\\n        List<Integer> l = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        for(int i=0; i<words.length; i++)\\n        {\\n            for(int j=0; j<words[i].length(); j++)\\n                count[i][(int)(words[i].charAt(j) - 97)]++;\\n        }\\n\\n        for(int i=0; i<26; i++)\\n        {\\n            for(int j=0; j<words.length; j++)\\n            {\\n                l.add(count[j][i]);\\n            }\\n            int min = Collections.min(l);\\n            l.clear();\\n            if(min > 0)\\n            {\\n                for(int j=0; j<min; j++)\\n                {\\n                    res.add(String.valueOf((char)(i + 97)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412020,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        ArrayList<String> result = new ArrayList<>();\\n\\t\\t//an int array with size of 26 to count character frequency\\n        int[] count = new int[26];\\n\\t\\t//count character frequencies in first word, and put count in an int array\\n        for (int i = 0; i < words[0].length(); i++) {\\n            count[words[0].charAt(i) - \\'a\\']++;\\n        }\\n\\t\\t//for each word, start from second word\\n        for (int i = 1; i < words.length; i++) {\\n            int[] temp = new int[26];\\n\\t\\t\\t//count character frequencies and put result into a temp array\\n            for (int j = 0; j < words[i].length(); j++) {\\n                temp[words[i].charAt(j) - \\'a\\']++;\\n            }\\n\\t\\t\\t//compare frequencies in temp and count\\n            for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t//if temp[j]==0, that means this character cannot be the common character\\n\\t\\t\\t\\t//if temp[j] and count[j] are both greater than 0, that means there will be common characters of temp[j] at the current moment. set count[j] to temp[j]\\n\\t\\t\\t\\t//count[j] is frequency of common characters for previous words, and temp[j] is frequency of characters for current word\\n                if (temp[j] <= count[j] && temp[j] != 0) count[j] = temp[j];\\n                if (temp[j] == 0) count[j] = 0;\\n            }\\n        }\\n\\t\\t// convert count to a set\\n        for (int i = 0; i < 26; i++) {\\n            while (count[i]-- > 0) {\\n                result.add(\"\" + (char) (\\'a\\' + i));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        ArrayList<String> result = new ArrayList<>();\\n\\t\\t//an int array with size of 26 to count character frequency\\n        int[] count = new int[26];\\n\\t\\t//count character frequencies in first word, and put count in an int array\\n        for (int i = 0; i < words[0].length(); i++) {\\n            count[words[0].charAt(i) - \\'a\\']++;\\n        }\\n\\t\\t//for each word, start from second word\\n        for (int i = 1; i < words.length; i++) {\\n            int[] temp = new int[26];\\n\\t\\t\\t//count character frequencies and put result into a temp array\\n            for (int j = 0; j < words[i].length(); j++) {\\n                temp[words[i].charAt(j) - \\'a\\']++;\\n            }\\n\\t\\t\\t//compare frequencies in temp and count\\n            for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t//if temp[j]==0, that means this character cannot be the common character\\n\\t\\t\\t\\t//if temp[j] and count[j] are both greater than 0, that means there will be common characters of temp[j] at the current moment. set count[j] to temp[j]\\n\\t\\t\\t\\t//count[j] is frequency of common characters for previous words, and temp[j] is frequency of characters for current word\\n                if (temp[j] <= count[j] && temp[j] != 0) count[j] = temp[j];\\n                if (temp[j] == 0) count[j] = 0;\\n            }\\n        }\\n\\t\\t// convert count to a set\\n        for (int i = 0; i < 26; i++) {\\n            while (count[i]-- > 0) {\\n                result.add(\"\" + (char) (\\'a\\' + i));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688794,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        ans = list(A[0])\\n        for word in A:\\n            check = []\\n            for c in word:\\n                if c in ans:\\n                    check.append(c)\\n                    ans.remove(c)\\n            ans = check\\n        return ans\\n        \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        ans = list(A[0])\\n        for word in A:\\n            check = []\\n            for c in word:\\n                if c in ans:\\n                    check.append(c)\\n                    ans.remove(c)\\n            ans = check\\n        return ans\\n        \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 514982,
                "title": "c-linq-solution-with-no-limitation-on-char-being-a-to-z-with-description",
                "content": "```\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return A\\n\\t\\t\\t// group chars in each word and then select all the groups across all words\\n            .SelectMany(a => a.GroupBy(c => c))\\n\\t\\t\\t// group all the groups again by char again\\n            .GroupBy(e => e.Key)\\n\\t\\t\\t// filtering out groups that don\\'t have a count not matching the number of words\\n\\t\\t\\t// if count doesn\\'t match word count that means not all the words have that specific char\\n            .Where(g => g.Count() == A.Length)\\n\\t\\t\\t// for each group we generate a char repeated to minumum of its repeat across words\\n\\t\\t\\t// if a word has 1 <o> and another has 2 then the min is 1 so we output only 1 <o>\"\\n            .SelectMany(g => Enumerable.Repeat(g.Key.ToString(), g.Min(h => h.Count())))\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return A\\n\\t\\t\\t// group chars in each word and then select all the groups across all words\\n            .SelectMany(a => a.GroupBy(c => c))\\n\\t\\t\\t// group all the groups again by char again\\n            .GroupBy(e => e.Key)\\n\\t\\t\\t// filtering out groups that don\\'t have a count not matching the number of words\\n\\t\\t\\t// if count doesn\\'t match word count that means not all the words have that specific char\\n            .Where(g => g.Count() == A.Length)\\n\\t\\t\\t// for each group we generate a char repeated to minumum of its repeat across words\\n\\t\\t\\t// if a word has 1 <o> and another has 2 then the min is 1 so we output only 1 <o>\"\\n            .SelectMany(g => Enumerable.Repeat(g.Key.ToString(), g.Min(h => h.Count())))\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349352,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if(A.length===1){\\n    return A[0].split(\\'\\');\\n  }\\n  let lens = A.length;\\n  let res = [];\\n  for(let j of A[0]){\\n    let i;\\n    for(i = 1; i < lens; i++){\\n      if(!A[i].includes(j)){\\n        break;\\n      }else{\\n        A[i] = A[i].replace(j,\\'\\');\\n      }\\n    }\\n    if(i === lens){\\n      res.push(j);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if(A.length===1){\\n    return A[0].split(\\'\\');\\n  }\\n  let lens = A.length;\\n  let res = [];\\n  for(let j of A[0]){\\n    let i;\\n    for(i = 1; i < lens; i++){\\n      if(!A[i].includes(j)){\\n        break;\\n      }else{\\n        A[i] = A[i].replace(j,\\'\\');\\n      }\\n    }\\n    if(i === lens){\\n      res.push(j);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325381,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if (A.length <= 1) return [];\\n  let res = helper(A[0], A[1]);\\n  \\n  for (let i = 2; i < A.length; i++) {\\n    res = helper(res, A[i]);\\n  }\\n  return res.split(\\'\\');\\n};\\n\\n// Helper function returns character intersecations as a string\\nconst helper = (str1, str2) => {\\n  let result = \\'\\';\\n  let map = {};\\n  \\n  for (let char of str1) {\\n    if (!map[char]) {\\n      map[char] = 1;\\n    } else {\\n      map[char]++;\\n    }\\n  }\\n  \\n  for (let char of str2) {\\n    if (map[char]) {\\n      result += char;\\n      map[char]--;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} A\\n * @return {string[]}\\n */\\nvar commonChars = function(A) {\\n  if (A.length <= 1) return [];\\n  let res = helper(A[0], A[1]);\\n  \\n  for (let i = 2; i < A.length; i++) {\\n    res = helper(res, A[i]);\\n  }\\n  return res.split(\\'\\');\\n};\\n\\n// Helper function returns character intersecations as a string\\nconst helper = (str1, str2) => {\\n  let result = \\'\\';\\n  let map = {};\\n  \\n  for (let char of str1) {\\n    if (!map[char]) {\\n      map[char] = 1;\\n    } else {\\n      map[char]++;\\n    }\\n  }\\n  \\n  for (let char of str2) {\\n    if (map[char]) {\\n      result += char;\\n      map[char]--;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250132,
                "title": "c-one-line",
                "content": "```\\n    public IList<string> CommonChars(string[] A) {\\n        return A[0].Distinct().SelectMany(l => Enumerable.Repeat(l.ToString(), A.Min(x => x.Count(y => y == l)))).ToList();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<string> CommonChars(string[] A) {\\n        return A[0].Distinct().SelectMany(l => Enumerable.Repeat(l.ToString(), A.Min(x => x.Count(y => y == l)))).ToList();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248410,
                "title": "python-explained-no-counter-intuitive-solution",
                "content": "**Approach**\\n1) Initialize a dictionary dict1 with letter counts from word#1\\n2) Compare letters in dict1 with word#2: add letters in common to dict2 while reducing the count in dict1 to account for duplicates\\n3) Clear dict1\\n4) Compare letters in dict2 with word#3 in the same fashion\\n5) Clear dict2\\n6) Repeat for next words, alternating between filling/clearing dict1/2\\n7) Return result from the appropriate dictionary\\n\\nWill appreciate if you guys can suggest more condensed code with this logic.\\n\\nCheers\\n\\n**Solution**\\n```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict1 = collections.defaultdict(int)\\n        dict2 = collections.defaultdict(int)\\n        k = 0\\n        \\n        for letter in A[0]:\\n            dict1[letter] += 1\\n        \\n        for word in A[1:]:\\n            if k%2 == 0:\\n                for letter in word:\\n                    if dict1[letter]:\\n                        dict2[letter] += 1\\n                        dict1[letter] -= 1\\n                dict1.clear()\\n            else:\\n                for letter in word:\\n                    if dict2[letter]:\\n                        dict1[letter] += 1\\n                        dict2[letter] -= 1\\n                dict2.clear()\\n            k += 1\\n        \\n        if k%2 == 0:\\n            result = [letter for l,cnt in dict1.items() for letter in l*cnt]\\n        else:\\n            result = [letter for l,cnt in dict2.items() for letter in l*cnt]\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict1 = collections.defaultdict(int)\\n        dict2 = collections.defaultdict(int)\\n        k = 0\\n        \\n        for letter in A[0]:\\n            dict1[letter] += 1\\n        \\n        for word in A[1:]:\\n            if k%2 == 0:\\n                for letter in word:\\n                    if dict1[letter]:\\n                        dict2[letter] += 1\\n                        dict1[letter] -= 1\\n                dict1.clear()\\n            else:\\n                for letter in word:\\n                    if dict2[letter]:\\n                        dict1[letter] += 1\\n                        dict2[letter] -= 1\\n                dict2.clear()\\n            k += 1\\n        \\n        if k%2 == 0:\\n            result = [letter for l,cnt in dict1.items() for letter in l*cnt]\\n        else:\\n            result = [letter for l,cnt in dict2.items() for letter in l*cnt]\\n\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2062244,
                "title": "simple-javascript-solution-easy-to-understand",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar commonChars = function(words, result = []) {\\n    // we just need to take the first element from the array for comparison\\n    for (const letter of words[0]) {\\n        // check letter in word\\n        if (words.every(w => w.includes(letter))) {\\n            result.push(letter)\\n            // remove letter from word\\n            words = words.map(w => w.replace(letter, \\'\\'))\\n        }\\n    }\\n    // the duplicate letter\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar commonChars = function(words, result = []) {\\n    // we just need to take the first element from the array for comparison\\n    for (const letter of words[0]) {\\n        // check letter in word\\n        if (words.every(w => w.includes(letter))) {\\n            result.push(letter)\\n            // remove letter from word\\n            words = words.map(w => w.replace(letter, \\'\\'))\\n        }\\n    }\\n    // the duplicate letter\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1818072,
                "title": "simple-solution-brute-force",
                "content": "\\n \\n    ArrayList<String> list = new ArrayList<>();\\n        for(int k = 0;k<words[0].length();k++){\\n            int c = 1;\\n           for(int i = 1;i<words.length;i++){\\n             for(int j = 0;j<words[i].length();j++){  \\n                 if(words[0].charAt(k) == words[i].charAt(j)){\\n                     c++;\\n                     words[i] = words[i].substring(0,j)+\"\"+words[i].substring(j+1);\\n                     break;\\n                 }\\n             }\\n          }\\n            if(c == words.length) list.add(words[0].charAt(k)+\"\"); \\n        } \\n        return list;",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n \\n    ArrayList<String> list = new ArrayList<>();\\n        for(int k = 0;k<words[0].length();k++){\\n            int c = 1;\\n           for(int i = 1;i<words.length;i++){\\n             for(int j = 0;j<words[i].length();j++){  \\n                 if(words[0].charAt(k) == words[i].charAt(j)){\\n                     c++;\\n                     words[i] = words[i].substring(0,j)+\"\"+words[i].substring(j+1);\\n                     break;\\n                 }\\n             }\\n          }\\n            if(c == words.length) list.add(words[0].charAt(k)+\"\"); \\n        } \\n        return list;",
                "codeTag": "Unknown"
            },
            {
                "id": 1177496,
                "title": "easy-to-understand-c",
                "content": "Description in Comment Section .\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {        \\n        string s = A[0];\\n        vector<string> res;\\n        int j=0, k;\\n        char search;\\n        while(j != s.length()) {\\n            search = s[j];\\n            k = 0;\\n             for(int i=1; i<A.size(); i++) {\\n                 if(A[i].find(search) != -1) {\\n                     A[i].erase(A[i].find(search),1);\\n                     k++;\\n                 }         \\n             }\\n            if(k == A.size()-1)\\n                res.push_back(string(1, search));\\n            j++;\\n        }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {        \\n        string s = A[0];\\n        vector<string> res;\\n        int j=0, k;\\n        char search;\\n        while(j != s.length()) {\\n            search = s[j];\\n            k = 0;\\n             for(int i=1; i<A.size(); i++) {\\n                 if(A[i].find(search) != -1) {\\n                     A[i].erase(A[i].find(search),1);\\n                     k++;\\n                 }         \\n             }\\n            if(k == A.size()-1)\\n                res.push_back(string(1, search));\\n            j++;\\n        }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049772,
                "title": "simple-method-c-java-o-n-2-0-ms-faster-than-99-00-easy-to-understand",
                "content": "**Implementation**\\n\\n**1st Approach in C++**\\nTime Complexity = O(N^2), Space Complexity = O(N)\\n```\\nvector<string> commonChars(vector<string>& A) {\\n    vector<int> check1(26, 0);\\n    vector<int> check2(26, 0);\\n    vector<string> result;\\n    \\n    for(char ch : A[0]){\\n        check1[ch-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.size(); itr++){\\n        for(char ch : A[itr]){\\n            check2[ch-\\'a\\']++;\\n        }\\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr]){\\n            int value = check1[itr];\\n            while(value--){\\n                char ch = itr + \\'a\\';\\n                string str;\\n                str = ch;\\n                result.emplace_back(str);                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```\\n**2nd Approach in Java**\\nTime Complexity = O(N^2), Space Complexity = O(N)\\n\\n```\\npublic List<String> commonChars(String[] A) {\\n    int[] check1 = new int[26];\\n    int[] check2 = new int[26];\\n    List<String> result = new ArrayList<String>();\\n    \\n    String str = A[0];\\n    for(int itr = 0; itr < str.length(); itr++){\\n        check1[str.charAt(itr)-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.length; itr++){\\n        str = A[itr];\\n        for(int jtr = 0; jtr < str.length(); jtr++){\\n            check2[str.charAt(jtr)-\\'a\\']++;\\n        }            \\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = Math.min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr] > 0){\\n            int value = check1[itr];\\n            while(value-- > 0){\\n                char ch = (char)(itr + \\'a\\');                                        \\n                result.add(Character.toString((char)ch));                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array"
                ],
                "code": "```\\nvector<string> commonChars(vector<string>& A) {\\n    vector<int> check1(26, 0);\\n    vector<int> check2(26, 0);\\n    vector<string> result;\\n    \\n    for(char ch : A[0]){\\n        check1[ch-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.size(); itr++){\\n        for(char ch : A[itr]){\\n            check2[ch-\\'a\\']++;\\n        }\\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr]){\\n            int value = check1[itr];\\n            while(value--){\\n                char ch = itr + \\'a\\';\\n                string str;\\n                str = ch;\\n                result.emplace_back(str);                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```\n```\\npublic List<String> commonChars(String[] A) {\\n    int[] check1 = new int[26];\\n    int[] check2 = new int[26];\\n    List<String> result = new ArrayList<String>();\\n    \\n    String str = A[0];\\n    for(int itr = 0; itr < str.length(); itr++){\\n        check1[str.charAt(itr)-\\'a\\']++;\\n    }\\n    \\n    for(int itr = 1; itr < A.length; itr++){\\n        str = A[itr];\\n        for(int jtr = 0; jtr < str.length(); jtr++){\\n            check2[str.charAt(jtr)-\\'a\\']++;\\n        }            \\n        \\n        for(int jtr = 0; jtr < 26; jtr++){\\n            check1[jtr] = Math.min(check1[jtr], check2[jtr]); \\n            check2[jtr] = 0;\\n        }\\n    }\\n           \\n    for(int itr = 0; itr < 26; itr++){\\n        if(check1[itr] > 0){\\n            int value = check1[itr];\\n            while(value-- > 0){\\n                char ch = (char)(itr + \\'a\\');                                        \\n                result.add(Character.toString((char)ch));                                \\n            }                \\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905080,
                "title": "python3-beats-98-100-with-5-short-lines",
                "content": "**idea**\\nfor each letter of the alphabet, count its number *n* of occurences across all words, then append it *n* times to the result.\\n```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n    res = []\\n    for c in ascii_lowercase:\\n        for n in range(min([w.count(c) for w in A])):\\n            res.append(c)\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n    res = []\\n    for c in ascii_lowercase:\\n        for n in range(min([w.count(c) for w in A])):\\n            res.append(c)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 849212,
                "title": "c-clean-code-with-map-easy-to-understand",
                "content": "If you don\\'t know how this code work , Please comment below I will try my best to answer your question : )\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        unordered_map<char, int> ansMap;\\n        unordered_map<char, int> midMap;\\n        vector<string> ans;\\n        for(auto c : A[0]) {\\n            ansMap[c]++;\\n        }\\n        for (auto i = 1; i < A.size() ; ++i) {\\n            midMap.clear();\\n            for (auto c : A[i]) {\\n                midMap[c]++;\\n            }\\n            if (ansMap.size() == 0) {\\n                return ans;\\n            }\\n            for (auto iter = ansMap.begin(); iter != ansMap.end();iter++) {\\n                if (midMap.count(iter->first)) { \\n                    ansMap[iter->first] = min(ansMap[iter->first], midMap[iter->first]);\\n                }\\n                else {\\n                    ansMap[iter->first] = 0;\\n                }\\n            }\\n        }\\n        for (auto iter = ansMap.begin(); iter != ansMap.end(); iter++) {\\n            for (auto i = 0; i < ansMap[iter->first]; ++i) {\\n                ans.push_back(string(1, iter->first));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) {\\n        unordered_map<char, int> ansMap;\\n        unordered_map<char, int> midMap;\\n        vector<string> ans;\\n        for(auto c : A[0]) {\\n            ansMap[c]++;\\n        }\\n        for (auto i = 1; i < A.size() ; ++i) {\\n            midMap.clear();\\n            for (auto c : A[i]) {\\n                midMap[c]++;\\n            }\\n            if (ansMap.size() == 0) {\\n                return ans;\\n            }\\n            for (auto iter = ansMap.begin(); iter != ansMap.end();iter++) {\\n                if (midMap.count(iter->first)) { \\n                    ansMap[iter->first] = min(ansMap[iter->first], midMap[iter->first]);\\n                }\\n                else {\\n                    ansMap[iter->first] = 0;\\n                }\\n            }\\n        }\\n        for (auto iter = ansMap.begin(); iter != ansMap.end(); iter++) {\\n            for (auto i = 0; i < ansMap[iter->first]; ++i) {\\n                ans.push_back(string(1, iter->first));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778615,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dic = {}\\n        for i in range(len(A)):\\n            for j in range(len(A[i])):\\n                if A[i][j] not in dic:\\n                    dic[A[i][j]] = (len(A))*[0]\\n                    dic[A[i][j]][i] = 1\\n                else:\\n                    dic[A[i][j]][i] += 1\\n        out = []\\n        for i,v in dic.items():\\n            if min(v)>0:\\n                out.extend([i]*min(v))\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dic = {}\\n        for i in range(len(A)):\\n            for j in range(len(A[i])):\\n                if A[i][j] not in dic:\\n                    dic[A[i][j]] = (len(A))*[0]\\n                    dic[A[i][j]][i] = 1\\n                else:\\n                    dic[A[i][j]][i] += 1\\n        out = []\\n        for i,v in dic.items():\\n            if min(v)>0:\\n                out.extend([i]*min(v))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368428,
                "title": "swift-solution-beats-90-32",
                "content": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        \\n        //use the first string to get candidates for matching\\n        var candidates = [Character : Int]()        \\n        for ch in A[0] {\\n            if let val = candidates[ch] {\\n                candidates[ch] = val + 1\\n            } else {\\n                candidates[ch] = 1\\n            }\\n        }\\n        \\n        //create a dict for each additional string and compare\\n        for i in 1..<A.count {\\n            var matcher = [Character : Int]()\\n            for ch in A[i] {\\n                if let _ = candidates[ch] { \\n                    if let val = matcher[ch] {\\n                        matcher[ch] = val + 1\\n                    } else {\\n                        matcher[ch] = 1\\n                    }\\n                } \\n            }\\n            \\n            //reduce initial candidates list down to what we had in common\\n            candidates = reduceCandidates(candidates: candidates, matcher: matcher)\\n        }\\n\\n        //convert from dict\\'s quantities to array and return the result\\n        var result = [String]()\\n        for (c, n) in candidates {\\n            for i in 0..<n {\\n                result.append(String(c))\\n            }\\n        }\\n        return result\\n    }\\n    \\n    \\n    func reduceCandidates(candidates: [Character : Int], matcher: [Character : Int]) -> [Character : Int] {\\n        var newCandidates = candidates\\n        for (c, n) in candidates {\\n            if let val = matcher[c] {\\n                newCandidates[c] = min(candidates[c]!, val)  \\n            } else {\\n                newCandidates[c] = nil\\n            }\\n        }\\n    \\n        return newCandidates\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        \\n        //use the first string to get candidates for matching\\n        var candidates = [Character : Int]()        \\n        for ch in A[0] {\\n            if let val = candidates[ch] {\\n                candidates[ch] = val + 1\\n            } else {\\n                candidates[ch] = 1\\n            }\\n        }\\n        \\n        //create a dict for each additional string and compare\\n        for i in 1..<A.count {\\n            var matcher = [Character : Int]()\\n            for ch in A[i] {\\n                if let _ = candidates[ch] { \\n                    if let val = matcher[ch] {\\n                        matcher[ch] = val + 1\\n                    } else {\\n                        matcher[ch] = 1\\n                    }\\n                } \\n            }\\n            \\n            //reduce initial candidates list down to what we had in common\\n            candidates = reduceCandidates(candidates: candidates, matcher: matcher)\\n        }\\n\\n        //convert from dict\\'s quantities to array and return the result\\n        var result = [String]()\\n        for (c, n) in candidates {\\n            for i in 0..<n {\\n                result.append(String(c))\\n            }\\n        }\\n        return result\\n    }\\n    \\n    \\n    func reduceCandidates(candidates: [Character : Int], matcher: [Character : Int]) -> [Character : Int] {\\n        var newCandidates = candidates\\n        for (c, n) in candidates {\\n            if let val = matcher[c] {\\n                newCandidates[c] = min(candidates[c]!, val)  \\n            } else {\\n                newCandidates[c] = nil\\n            }\\n        }\\n    \\n        return newCandidates\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316230,
                "title": "find-common-characters-0-ms-golang-solution-o-n-o-1",
                "content": "```\\nfunc commonChars(A []string) []string {\\n\\tcnt := [26]int{}\\n\\tfor i := range cnt {\\n\\t\\tcnt[i] = math.MaxUint16\\n\\t}\\n\\n\\tcntInWord := [26]int{}\\n\\tfor _, word := range A {\\n\\t\\tfor _, char := range []byte(word) { // compiler trick - here we will not allocate new memory\\n\\t\\t\\tcntInWord[char - \\'a\\']++\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tif cntInWord[i] < cnt[i] {\\n\\t\\t\\t\\tcnt[i] = cntInWord[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor i := range cntInWord {\\n\\t\\t\\tcntInWord[i] = 0\\n\\t\\t}\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tfor j := 0; j < cnt[i]; j++ {\\n\\t\\t\\tresult = append(result, string(i + \\'a\\'))\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```\\nComplexity Analysis\\n\\nRuntime: O(n), n - total number of characters\\nSpace: O(1) - use 2 arrays",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc commonChars(A []string) []string {\\n\\tcnt := [26]int{}\\n\\tfor i := range cnt {\\n\\t\\tcnt[i] = math.MaxUint16\\n\\t}\\n\\n\\tcntInWord := [26]int{}\\n\\tfor _, word := range A {\\n\\t\\tfor _, char := range []byte(word) { // compiler trick - here we will not allocate new memory\\n\\t\\t\\tcntInWord[char - \\'a\\']++\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tif cntInWord[i] < cnt[i] {\\n\\t\\t\\t\\tcnt[i] = cntInWord[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor i := range cntInWord {\\n\\t\\t\\tcntInWord[i] = 0\\n\\t\\t}\\n\\t}\\n\\n\\tresult := make([]string, 0)\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tfor j := 0; j < cnt[i]; j++ {\\n\\t\\t\\tresult = append(result, string(i + \\'a\\'))\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309840,
                "title": "c-readable-solution",
                "content": "```\\npublic IList<string> CommonChars(string[] A) {\\n          var intersection = A[0].ToCharArray().ToList();\\n            for (int i = 1; i < A.Length; i++)\\n            for (int k = 0; k < intersection.Count; k++)\\n            {\\n                int index = A[i].IndexOf(intersection[k]);\\n                if (index >= 0)\\n                    A[i] = A[i].Remove(index, 1);\\n                else\\n                {\\n                    intersection.RemoveAt(k);\\n                    k--;\\n                }\\n            }\\n\\n            return intersection.Select(ch => ch.ToString()).ToList();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<string> CommonChars(string[] A) {\\n          var intersection = A[0].ToCharArray().ToList();\\n            for (int i = 1; i < A.Length; i++)\\n            for (int k = 0; k < intersection.Count; k++)\\n            {\\n                int index = A[i].IndexOf(intersection[k]);\\n                if (index >= 0)\\n                    A[i] = A[i].Remove(index, 1);\\n                else\\n                {\\n                    intersection.RemoveAt(k);\\n                    k--;\\n                }\\n            }\\n\\n            return intersection.Select(ch => ch.ToString()).ToList();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261592,
                "title": "python-solution-three-lines",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        check = set(A[0])\\n        result = [[l] * min([a.count(l) for a in A]) for l in check]\\n        return sorted([i for e in result for i in e])\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        check = set(A[0])\\n        result = [[l] * min([a.count(l) for a in A]) for l in check]\\n        return sorted([i for e in result for i in e])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647780,
                "title": "for-beginners-more-simplified",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res = Counter(words[0])\\n        for i in words:\\n            res &= Counter(i)\\n        return list(res.elements())\\n        \\n```\\n\\n# Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\'&=\\'\\nThe &= operator in Python is a compound assignment operator that performs a bitwise AND operation between two operands and assigns the result back to the left operand.\\n\\nThe & operator is a bitwise AND operator that performs a bitwise AND operation between corresponding bits of two integers. It returns a new integer with bits set to 1 only where both corresponding bits of the operands are 1.\\n\\nThe &= operator combines the bitwise AND operation and assignment operation. It updates the left operand with the result of the bitwise AND operation between the left operand and the right operand.\\n\\nHere\\'s an example to illustrate the usage of &=:\\n\\npython\\n\\na = 5\\nb = 3\\na &= b  # Equivalent to: a = a & b\\nprint(a)  # Output: 1\\n\\nIn this example, a initially holds the value 5 (binary: 0101) and b holds the value 3 (binary: 0011). After performing a &= b, the value of a is updated to 1 (binary: 0001) because it performs a bitwise AND operation between the two values.\\n\\nThe &= operator can be used with different types, such as integers, booleans, sets, or custom objects, depending on how it is defined for each type. The specific behavior of &= may vary depending on the data type being used.\\n\\nIt\\'s important to note that the &= operator is not universally defined for all data types. Its availability and behavior depend on the specific implementation and behavior defined for each type.\\n\\n\\n# credits :   https://leetcode.com/rioran/",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res = Counter(words[0])\\n        for i in words:\\n            res &= Counter(i)\\n        return list(res.elements())\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420780,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2366740,
                "title": "c-easiest-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> res;\\n        for (auto c: words[0])\\n        {\\n            bool isPresent = true;\\n            string s;\\n            for (int i = 1; i < words.size(); i++)\\n            {\\n                int index = words[i].find(c);\\n                cout<<index<<\" \";\\n                if(index != string::npos) {\\n                    words[i].erase(index, 1);\\n                }else {\\n                    isPresent = false;\\n                    break;\\n                }\\n            }\\n            if(isPresent) res.push_back(s+=c);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2103125,
                "title": "python-solution-slow-but-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        \\n        g = []\\n        \\n        for i in words[0]:\\n            t = True\\n            for j in range(len(words)):\\n                if i not in words[j]:\\n                    t = False\\n                else:\\n                    cur = list(words[j])\\n                    cur.pop(cur.index(i))\\n                    words[j] = \\'\\'.join(cur)\\n                  \\n                \\n            if t:\\n                g.append(i)\\n                \\n        return g\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        \\n        g = []\\n        \\n        for i in words[0]:\\n            t = True\\n            for j in range(len(words)):\\n                if i not in words[j]:\\n                    t = False\\n                else:\\n                    cur = list(words[j])\\n                    cur.pop(cur.index(i))\\n                    words[j] = \\'\\'.join(cur)\\n                  \\n                \\n            if t:\\n                g.append(i)\\n                \\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819654,
                "title": "c-unordered-map-comments-for-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        //mapping first word characters with their count\\n        for(auto x: words[0]) mp[x]++;\\n        \\n        for(int i=1; i<words.size(); i++){\\n           unordered_map<char, int> temp;\\n           //storing count of next words characters by making temp map everytime\\n            for(auto y : words[i])\\n                temp[y]++;\\n           \\n            //Updating original map values \\n            for(int i=0; i<26; i++){\\n                char ch = \\'a\\' + i;\\n                //If both mp and temp contains the character ch, update the\\n\\t\\t\\t\\t// main map i.e. mp with the value minimum of both mp and temp\\n\\t\\t\\t\\tif(temp.find(ch) != temp.end() && mp.find(ch) != mp.end()) mp[ch] = min(mp[ch], temp[ch]);\\n                //If temp doesn\\'t contain the character, that means we have to\\n\\t\\t\\t\\t//remove the ch from main map now\\n\\t\\t\\t\\telse if(mp.find(ch) != mp.end()) mp.erase(ch);\\n            }\\n        }\\n        \\n        //Handling the output of common characters\\n        vector<string> v;\\n        for(auto x: mp){\\n            string s =\"\"; \\n            s += x.first;\\n            for(int i=1; i<=x.second; i++) v.push_back(s);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        //mapping first word characters with their count\\n        for(auto x: words[0]) mp[x]++;\\n        \\n        for(int i=1; i<words.size(); i++){\\n           unordered_map<char, int> temp;\\n           //storing count of next words characters by making temp map everytime\\n            for(auto y : words[i])\\n                temp[y]++;\\n           \\n            //Updating original map values \\n            for(int i=0; i<26; i++){\\n                char ch = \\'a\\' + i;\\n                //If both mp and temp contains the character ch, update the\\n\\t\\t\\t\\t// main map i.e. mp with the value minimum of both mp and temp\\n\\t\\t\\t\\tif(temp.find(ch) != temp.end() && mp.find(ch) != mp.end()) mp[ch] = min(mp[ch], temp[ch]);\\n                //If temp doesn\\'t contain the character, that means we have to\\n\\t\\t\\t\\t//remove the ch from main map now\\n\\t\\t\\t\\telse if(mp.find(ch) != mp.end()) mp.erase(ch);\\n            }\\n        }\\n        \\n        //Handling the output of common characters\\n        vector<string> v;\\n        for(auto x: mp){\\n            string s =\"\"; \\n            s += x.first;\\n            for(int i=1; i<=x.second; i++) v.push_back(s);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261884,
                "title": "c-o-n-where-n-is-total-number-charachters-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        map<char,int>mp1;\\n        map<char,int>mp2;\\n        \\n        for(char ch: words[0])\\n            mp1[ch]++;\\n        \\n        for(int i=1;i<words.size();i++){\\n            string word = words[i];\\n            for(char ch:word){\\n                if(mp1.find(ch)!=mp1.end() && mp1[ch]>0){\\n                    mp1[ch]--;\\n                    mp2[ch]++;\\n                }\\n            }\\n            mp1.clear();\\n            mp1=mp2;\\n            mp2.clear();\\n        }\\n        vector<string>res;\\n        for(auto iter:mp1){\\n            int j = iter.second;\\n            string s = \"\";\\n            s=s+iter.first;\\n            while(j>0){\\n                res.push_back(s);j--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        map<char,int>mp1;\\n        map<char,int>mp2;\\n        \\n        for(char ch: words[0])\\n            mp1[ch]++;\\n        \\n        for(int i=1;i<words.size();i++){\\n            string word = words[i];\\n            for(char ch:word){\\n                if(mp1.find(ch)!=mp1.end() && mp1[ch]>0){\\n                    mp1[ch]--;\\n                    mp2[ch]++;\\n                }\\n            }\\n            mp1.clear();\\n            mp1=mp2;\\n            mp2.clear();\\n        }\\n        vector<string>res;\\n        for(auto iter:mp1){\\n            int j = iter.second;\\n            string s = \"\";\\n            s=s+iter.first;\\n            while(j>0){\\n                res.push_back(s);j--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184747,
                "title": "python-simple-list-comprehension-very-basic",
                "content": "\\n\\t# We can first find all the distinct letters that exist in A\\n\\t# For each distinct letter, we find how many times it occurs in each word in A. Take the minimum occurance.\\n\\t# occurance gives you something like this [[\"e\",1],[\"a\",0],[\"l\",2],[\"r\",0],[\"o\",0],[\"b\",0]]\\n\\t# This indicates we need to append \\'e\\' 1 time, and \\'l\\' 2 times. Other letters did not occur in some words since their minimum occurance is 0.\\n\\tclass Solution:\\n\\t\\tdef commonChars(self, A: List[str]) -> List[str]:\\n\\t\\t\\tletters = set([x for a in A for x in a])\\n\\t\\t\\toccurance = [[l, min([a.count(l) for a in A])] for l in letters]\\n\\t\\t\\tans = []\\n\\t\\t\\tfor o in occurance:\\n\\t\\t\\t\\tans += o[0]*o[1]\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\n\\t# We can first find all the distinct letters that exist in A\\n\\t# For each distinct letter, we find how many times it occurs in each word in A. Take the minimum occurance.\\n\\t# occurance gives you something like this [[\"e\",1],[\"a\",0],[\"l\",2],[\"r\",0],[\"o\",0],[\"b\",0]]\\n\\t# This indicates we need to append \\'e\\' 1 time, and \\'l\\' 2 times. Other letters did not occur in some words since their minimum occurance is 0.\\n\\tclass Solution:\\n\\t\\tdef commonChars(self, A: List[str]) -> List[str]:\\n\\t\\t\\tletters = set([x for a in A for x in a])\\n\\t\\t\\toccurance = [[l, min([a.count(l) for a in A])] for l in letters]\\n\\t\\t\\tans = []\\n\\t\\t\\tfor o in occurance:\\n\\t\\t\\t\\tans += o[0]*o[1]\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1088489,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] common = count(A[0]);\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            common = cross(common, count(A[i]));\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < common[i]; j++) {\\n                Character c = (char) (\\'a\\' + i);\\n                result.add(c.toString());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static int[] count(String s) {\\n        int[] count = new int[26];\\n        for (char c: s.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }\\n        return count;\\n    }\\n    \\n    private static int[] cross(int[] x, int[] y) {\\n        int[] result = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            result[i] = Math.min(x[i], y[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] common = count(A[0]);\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            common = cross(common, count(A[i]));\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < common[i]; j++) {\\n                Character c = (char) (\\'a\\' + i);\\n                result.add(c.toString());\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static int[] count(String s) {\\n        int[] count = new int[26];\\n        for (char c: s.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }\\n        return count;\\n    }\\n    \\n    private static int[] cross(int[] x, int[] y) {\\n        int[] result = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            result[i] = Math.min(x[i], y[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037047,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        for i in set(A[0]):\\n            x = []\\n            for j in A:\\n                x.append(j.count(i))\\n            a = 0\\n            while a < min(x):\\n                ans.append(i)\\n                a += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        for i in set(A[0]):\\n            x = []\\n            for j in A:\\n                x.append(j.count(i))\\n            a = 0\\n            while a < min(x):\\n                ans.append(i)\\n                a += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964176,
                "title": "c-solution-hashmap-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) \\n    {\\n        int mp[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            mp[i]=INT_MAX;\\n        }\\n        for(auto x: A)\\n        {\\n            int h[26]={0};\\n            for(auto c:x)\\n            {\\n                h[c-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                mp[i]=min(mp[i],h[i]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++)\\n        {\\n            while(mp[i])\\n            {\\n                ans.push_back(string(1,i+\\'a\\'));\\n                mp[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& A) \\n    {\\n        int mp[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            mp[i]=INT_MAX;\\n        }\\n        for(auto x: A)\\n        {\\n            int h[26]={0};\\n            for(auto c:x)\\n            {\\n                h[c-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                mp[i]=min(mp[i],h[i]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<26;i++)\\n        {\\n            while(mp[i])\\n            {\\n                ans.push_back(string(1,i+\\'a\\'));\\n                mp[i]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861581,
                "title": "java-3ms-runtime-92",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int n = A.length;\\n        int[]result = new int[26];\\n        Arrays.fill(result,100);\\n        for(int i=0;i<n;i++){\\n            int[]curr=new int[26];\\n            for(int j=0;j<A[i].length();j++){\\n                curr[(int)(A[i].charAt(j) - \\'a\\')]++;\\n            }\\n            for(int j=0;j<26;j++){\\n                result[j]=Math.min(result[j],curr[j]);\\n            }\\n        }\\n        List<String>ret = new LinkedList<String>();\\n        for(int i=0;i<26;i++){\\n            while(result[i]--!=0){\\n                ret.add(String.valueOf((char)(i+\\'a\\')));\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int n = A.length;\\n        int[]result = new int[26];\\n        Arrays.fill(result,100);\\n        for(int i=0;i<n;i++){\\n            int[]curr=new int[26];\\n            for(int j=0;j<A[i].length();j++){\\n                curr[(int)(A[i].charAt(j) - \\'a\\')]++;\\n            }\\n            for(int j=0;j<26;j++){\\n                result[j]=Math.min(result[j],curr[j]);\\n            }\\n        }\\n        List<String>ret = new LinkedList<String>();\\n        for(int i=0;i<26;i++){\\n            while(result[i]--!=0){\\n                ret.add(String.valueOf((char)(i+\\'a\\')));\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716130,
                "title": "c-o-n-time-o-1-space-beats-99",
                "content": "In our solution we are basically calculating the result map as mp1, and mp2 is a temporary map for each iterating word. Next we find the intersection (minimum) of both sets to get our desired results in map mp1.\\n```\\nvector<string> commonChars(vector<string>& A) {\\n        int mp1[26] = {0};\\n        int mp2[26] = {0};\\n        for(auto &c:A[0])\\n            mp1[c-\\'a\\']++;\\n        for(int i=1;i<A.size();i++)\\n        {\\n            for(auto &c:A[i])\\n                mp2[c-\\'a\\']++;\\n            for(int j=0;j<26;j++)\\n            {\\n                mp1[j] = min(mp1[j],mp2[j]);\\n                mp2[j] = 0;\\n            }\\n        }\\n        vector<string> res;\\n        for(int i=0;i<26;i++)\\n            while(mp1[i]--)\\n                res.push_back(string(1,\\'a\\'+ i));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> commonChars(vector<string>& A) {\\n        int mp1[26] = {0};\\n        int mp2[26] = {0};\\n        for(auto &c:A[0])\\n            mp1[c-\\'a\\']++;\\n        for(int i=1;i<A.size();i++)\\n        {\\n            for(auto &c:A[i])\\n                mp2[c-\\'a\\']++;\\n            for(int j=0;j<26;j++)\\n            {\\n                mp1[j] = min(mp1[j],mp2[j]);\\n                mp2[j] = 0;\\n            }\\n        }\\n        vector<string> res;\\n        for(int i=0;i<26;i++)\\n            while(mp1[i]--)\\n                res.push_back(string(1,\\'a\\'+ i));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498420,
                "title": "python-simple-solution-faster-than-96-93-memory-less-than-100",
                "content": "* Runtime: 36 ms, faster than 96.93% of Python3 online submissions for Find Common Characters.\\n* Memory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Find Common Characters.\\n\\n```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n\\toutput = []\\n\\t\\tfor char in A[0]: # iterate through each character in the first string\\n\\t\\t\\tif all(char in string for string in A): # if every string contains this character\\n\\t\\t\\t\\toutput.append(char) # add it to the output list\\n\\t\\t\\t\\tA = [s.replace(char,\\'\\',1) for s in A] # replace 1 instance of this character from each string\\n\\treturn output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n\\toutput = []\\n\\t\\tfor char in A[0]: # iterate through each character in the first string\\n\\t\\t\\tif all(char in string for string in A): # if every string contains this character\\n\\t\\t\\t\\toutput.append(char) # add it to the output list\\n\\t\\t\\t\\tA = [s.replace(char,\\'\\',1) for s in A] # replace 1 instance of this character from each string\\n\\treturn output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 487777,
                "title": "python-1-line-and-counters-or-min-count",
                "content": "```\\ndef commonChars(self, A):\\n    return reduce(operator.and_, map(collections.Counter, A)).elements()\\n```\\n```\\ndef commonChars(self, A):\\n    return [c for c in set(A[0]) for c in c * min(a.count(c) for a in A)]\\n```",
                "solutionTags": [],
                "code": "```\\ndef commonChars(self, A):\\n    return reduce(operator.and_, map(collections.Counter, A)).elements()\\n```\n```\\ndef commonChars(self, A):\\n    return [c for c in set(A[0]) for c in c * min(a.count(c) for a in A)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 442487,
                "title": "c-linq-solution-5-lines",
                "content": "``` csharp\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return Enumerable.Range((int)\\'a\\', 26)\\n            .Select(x => new { ch = (char)x, cnt = A.Min(y => y.Count(z => z == (char)x)) })\\n            .Where(x => x.cnt > 0)\\n            .SelectMany(x => Enumerable.Range(0, x.cnt).Select(y => x.ch.ToString()))\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic class Solution {\\n    public IList<string> CommonChars(string[] A) {\\n        return Enumerable.Range((int)\\'a\\', 26)\\n            .Select(x => new { ch = (char)x, cnt = A.Min(y => y.Count(z => z == (char)x)) })\\n            .Where(x => x.cnt > 0)\\n            .SelectMany(x => Enumerable.Range(0, x.cnt).Select(y => x.ch.ToString()))\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404915,
                "title": "python-99",
                "content": "\\'\\'\\'\\n        \\n\\t\\tres = []\\n\\n        for ch in A[0]:\\n            count = 0\\n            for i in range(1, len(A)):\\n                if ch not in A[i]:\\n                    break\\n                else:\\n                    count += 1\\n                    A[i] = A[i].replace(ch,\\'\\', 1)\\n            if count == len(A) - 1:\\n                res.append(ch)\\n        \\n        return res\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n        \\n\\t\\tres = []\\n\\n        for ch in A[0]:\\n            count = 0\\n            for i in range(1, len(A)):\\n                if ch not in A[i]:\\n                    break\\n                else:\\n                    count += 1\\n                    A[i] = A[i].replace(ch,\\'\\', 1)\\n            if count == len(A) - 1:\\n                res.append(ch)\\n        \\n        return res\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 301527,
                "title": "java-98-time-99-space",
                "content": "```java\\npublic List<String> commonChars(String[] A) {\\n        // use two frequency arrays\\n        // \\'freqs\\' holds our answer as we build it\\n        // \\'compare\\' holds each String as we iterate\\n        // as we inspect it\\n        int[] freqs = new int[26];\\n        int[] compare = new int[26];\\n        \\n        // initialize the \\'freqs\\' array with the frequencies\\n\\t\\t// found in the first String\\n        String first = A[0];\\n        for (char c : first.toCharArray()) {\\n            freqs[c - \\'a\\']++;\\n        }\\n\\n        for (int i = 1; i < A.length; i++) {\\n\\t\\t\\t// build the \\'compare\\' array with frequency of\\n\\t\\t\\t// each character occurring in the current String\\n            for (char c : A[i].toCharArray()) {\\n                compare[c - \\'a\\']++;\\n            }\\n\\t\\t\\t// whittle the \\'freqs\\' values down by using Math.min()\\n\\t\\t\\t// with the frequencies found in the current String\\n\\t\\t\\t// also reset the \\'compare\\' array for next iteration\\n            for (int j = 0; j < 26; j++) {\\n                freqs[j] = Math.min(freqs[j], compare[j]);\\n                compare[j] = 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// at this point, \\'freqs\\' contains the minimum occurrence\\n\\t\\t// frequency for each character a-z across all the Strings\\n        \\n        // construct the required List<String> answer\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i++) {\\n            while (freqs[i]-- > 0) {\\n                result.add(Character.toString((char)(\\'a\\' + i)));\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic List<String> commonChars(String[] A) {\\n        // use two frequency arrays\\n        // \\'freqs\\' holds our answer as we build it\\n        // \\'compare\\' holds each String as we iterate\\n        // as we inspect it\\n        int[] freqs = new int[26];\\n        int[] compare = new int[26];\\n        \\n        // initialize the \\'freqs\\' array with the frequencies\\n\\t\\t// found in the first String\\n        String first = A[0];\\n        for (char c : first.toCharArray()) {\\n            freqs[c - \\'a\\']++;\\n        }\\n\\n        for (int i = 1; i < A.length; i++) {\\n\\t\\t\\t// build the \\'compare\\' array with frequency of\\n\\t\\t\\t// each character occurring in the current String\\n            for (char c : A[i].toCharArray()) {\\n                compare[c - \\'a\\']++;\\n            }\\n\\t\\t\\t// whittle the \\'freqs\\' values down by using Math.min()\\n\\t\\t\\t// with the frequencies found in the current String\\n\\t\\t\\t// also reset the \\'compare\\' array for next iteration\\n            for (int j = 0; j < 26; j++) {\\n                freqs[j] = Math.min(freqs[j], compare[j]);\\n                compare[j] = 0;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// at this point, \\'freqs\\' contains the minimum occurrence\\n\\t\\t// frequency for each character a-z across all the Strings\\n        \\n        // construct the required List<String> answer\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i++) {\\n            while (freqs[i]-- > 0) {\\n                result.add(Character.toString((char)(\\'a\\' + i)));\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251620,
                "title": "java-solution-without-hashmap-faster-than-97",
                "content": "class Solution {\\n    public List<String> commonChars(String[] A) {\\n        \\n        int[] all_dict = new int[26];\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i ++) {\\n            all_dict[i] = Integer.MAX_VALUE;\\n        }\\n        for (String word: A) {\\n            int[] dict = new int[26];\\n            for (int i = 0; i < 26; i ++) {\\n                dict[i] = 0;\\n            }\\n            \\n            for (Character c: word.toCharArray()) {\\n                dict[c - \\'a\\'] ++;\\n            }\\n            for (int k = 0; k < 26; k ++) {\\n                if (dict[k] < all_dict[k]) {\\n                    all_dict[k] = dict[k];\\n                }\\n            }\\n        }\\n        for (int k = 0; k < 26; k ++) {\\n            if ((all_dict[k] != 0) && (all_dict[k] != Integer.MAX_VALUE)) {\\n                for (int i = 0; i < all_dict[k]; i ++) {\\n                    result.add(Character.toString((char)(k+\\'a\\')));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public List<String> commonChars(String[] A) {\\n        \\n        int[] all_dict = new int[26];\\n        List<String> result = new ArrayList<String>();\\n        for (int i = 0; i < 26; i ++) {\\n            all_dict[i] = Integer.MAX_VALUE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 249508,
                "title": "js-one-pass-o-n-time-and-o-1-space",
                "content": "Please vote up\\n```\\nconst commonChars = A => {\\n    let res = [], count = Array(26).fill(1e9), size = 26, aCode = 97;\\n\\n    for (let s of A) {\\n        let cnt = Array(size).fill(0);\\n        \\n        for (let c of s) { cnt[c.charCodeAt(0) - aCode]++; }\\n        for (let i = 0; i < size; i++) { count[i] = Math.min(count[i], cnt[i]); }\\n    }\\n    \\n    for (let i = 0; i < size; i++) {\\n        while (count[i]-- > 0) {\\n            res.push(String.fromCharCode(i + aCode));\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst commonChars = A => {\\n    let res = [], count = Array(26).fill(1e9), size = 26, aCode = 97;\\n\\n    for (let s of A) {\\n        let cnt = Array(size).fill(0);\\n        \\n        for (let c of s) { cnt[c.charCodeAt(0) - aCode]++; }\\n        for (let i = 0; i < size; i++) { count[i] = Math.min(count[i], cnt[i]); }\\n    }\\n    \\n    for (let i = 0; i < size; i++) {\\n        while (count[i]-- > 0) {\\n            res.push(String.fromCharCode(i + aCode));\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3375707,
                "title": "my-solution-using-hash-table-o-n-time-and-o-1-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        return self.sol1(words)\\n\\n    def sol1(self, words):\\n        # INIT\\n\\n        # ALGO\\n\\n        #   --Build a freq graph of letters\\n        #   --Each letter has an array mapped to it containing the frequency of char in a specific word\\n        #   -- Populate the result array by checking for chars that appear in all strings \\n        #   -- The number if times to add a char is the min \\n\\n        freq_graph = {}\\n        result = []\\n\\n        for idx, word in enumerate(words):\\n            for char in word:\\n                if char not in freq_graph:\\n                    freq_graph[char] = [0] * len(words)\\n                    freq_graph[char][idx] = 1\\n                else:\\n                    freq_graph[char][idx] += 1\\n\\n\\n        for char in freq_graph:\\n            for i in range(0, min(freq_graph[char])):\\n                result.append(char)\\n\\n        return result\\n\\n        \\n\\n        \\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        return self.sol1(words)\\n\\n    def sol1(self, words):\\n        # INIT\\n\\n        # ALGO\\n\\n        #   --Build a freq graph of letters\\n        #   --Each letter has an array mapped to it containing the frequency of char in a specific word\\n        #   -- Populate the result array by checking for chars that appear in all strings \\n        #   -- The number if times to add a char is the min \\n\\n        freq_graph = {}\\n        result = []\\n\\n        for idx, word in enumerate(words):\\n            for char in word:\\n                if char not in freq_graph:\\n                    freq_graph[char] = [0] * len(words)\\n                    freq_graph[char][idx] = 1\\n                else:\\n                    freq_graph[char][idx] += 1\\n\\n\\n        for char in freq_graph:\\n            for i in range(0, min(freq_graph[char])):\\n                result.append(char)\\n\\n        return result\\n\\n        \\n\\n        \\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115294,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        common = []\\n        for c in range(len(words[0])):\\n            isCommon = True\\n            for wordIdx in range(1, len(words)):\\n                if words[0][c] not in words[wordIdx]:\\n                    isCommon = False\\n                    break\\n            if isCommon:\\n                common.append(words[0][c])\\n                for word in range(1, len(words)):\\n                    i = words[word].index(words[0][c])\\n                    words[word] = words[word][:i] + words[word][i + 1:]\\n        return common\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/604f2746-0039-49ef-9457-9ae348a1dc4a_1675026543.4825096.png)\\n![image.png](https://assets.leetcode.com/users/images/ded51de0-4748-45a8-9128-c7977b501b7a_1675026556.308422.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        common = []\\n        for c in range(len(words[0])):\\n            isCommon = True\\n            for wordIdx in range(1, len(words)):\\n                if words[0][c] not in words[wordIdx]:\\n                    isCommon = False\\n                    break\\n            if isCommon:\\n                common.append(words[0][c])\\n                for word in range(1, len(words)):\\n                    i = words[word].index(words[0][c])\\n                    words[word] = words[word][:i] + words[word][i + 1:]\\n        return common\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457090,
                "title": "simple-o-n-go-solution",
                "content": "```\\nfunc commonChars(words []string) []string {\\n    var res []string\\n    \\n    arr := make([][26]byte, len(words))\\n    \\n    for i := 0; i < len(words); i++ {\\n        for j := 0; j < len(words[i]); j++ {\\n            arr[i][words[i][j] - \\'a\\']++\\n        }\\n    }\\n    \\n    for i := 0; i < 26; i++ {\\n        isValid, count := true, 1<<63-1\\n        \\n        for j := 0; j < len(words); j++ {\\n            if arr[j][i] <= 0 {\\n                isValid = false\\n                break\\n            } else if int(arr[j][i]) < count {\\n                count = int(arr[j][i])\\n            }\\n        }\\n        \\n        if isValid {\\n            for count > 0 {\\n                res = append(res, fmt.Sprintf(\"%c\", i + \\'a\\'))\\n                count--\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc commonChars(words []string) []string {\\n    var res []string\\n    \\n    arr := make([][26]byte, len(words))\\n    \\n    for i := 0; i < len(words); i++ {\\n        for j := 0; j < len(words[i]); j++ {\\n            arr[i][words[i][j] - \\'a\\']++\\n        }\\n    }\\n    \\n    for i := 0; i < 26; i++ {\\n        isValid, count := true, 1<<63-1\\n        \\n        for j := 0; j < len(words); j++ {\\n            if arr[j][i] <= 0 {\\n                isValid = false\\n                break\\n            } else if int(arr[j][i]) < count {\\n                count = int(arr[j][i])\\n            }\\n        }\\n        \\n        if isValid {\\n            for count > 0 {\\n                res = append(res, fmt.Sprintf(\"%c\", i + \\'a\\'))\\n                count--\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2366737,
                "title": "java-simple-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> strResult = new ArrayList<String>();\\n        for(int i = 0; i < words[0].length(); i++){\\n            String ch = String.valueOf(words[0].charAt(i));\\n            boolean isTrue = false;\\n            for(int j = 1; j < words.length; j++){\\n                if(words[j].contains(ch)){\\n                    words[j] = words[j].replaceFirst(ch,\"\");\\n                    isTrue = true;\\n                }else{\\n                    isTrue = false;\\n                    break;\\n                }\\n            }\\n            if(isTrue){\\n                strResult.add(ch);\\n            }\\n        }\\n        \\n        return strResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> strResult = new ArrayList<String>();\\n        for(int i = 0; i < words[0].length(); i++){\\n            String ch = String.valueOf(words[0].charAt(i));\\n            boolean isTrue = false;\\n            for(int j = 1; j < words.length; j++){\\n                if(words[j].contains(ch)){\\n                    words[j] = words[j].replaceFirst(ch,\"\");\\n                    isTrue = true;\\n                }else{\\n                    isTrue = false;\\n                    break;\\n                }\\n            }\\n            if(isTrue){\\n                strResult.add(ch);\\n            }\\n        }\\n        \\n        return strResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294440,
                "title": "simple-c-solution-using-two-arrays",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int cnt1[26]={0};\\n        \\n        for(int i = 0; i < words.size(); i++)\\n        {\\n            int cnt2[26]={0};\\n            if(i == 0) for(char c: words[i]) cnt1[c-\\'a\\']++;\\n            else \\n            {\\n                for(char c: words[i])\\n                    cnt2[c-\\'a\\']++;\\n                for(int j = 0; j<26; j++)\\n                cnt1[j] = min(cnt1[j], cnt2[j]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i<26; i++)\\n        {\\n            while(cnt1[i]>0)\\n            {\\n                cnt1[i]--;   \\n                ans.push_back(string(1,i+\\'a\\'));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        int cnt1[26]={0};\\n        \\n        for(int i = 0; i < words.size(); i++)\\n        {\\n            int cnt2[26]={0};\\n            if(i == 0) for(char c: words[i]) cnt1[c-\\'a\\']++;\\n            else \\n            {\\n                for(char c: words[i])\\n                    cnt2[c-\\'a\\']++;\\n                for(int j = 0; j<26; j++)\\n                cnt1[j] = min(cnt1[j], cnt2[j]);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i<26; i++)\\n        {\\n            while(cnt1[i]>0)\\n            {\\n                cnt1[i]--;   \\n                ans.push_back(string(1,i+\\'a\\'));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046065,
                "title": "vanilla-python-with-explanation",
                "content": "Probably not the fanciest solution, but gets the job done. Input constaraints are reasonable, we are not dealing with millions of words. \\n```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        example input: words = [\"bella\",\"label\",\"roller\"]\\n                output: [\"e\",\"l\",\"l\"]\\n        approach: we are only interested in letters that are in \\n                  all 3 words, therefore map only the letters in \\n                  first word like for \\'bella\\': \\n          fill the array of len(words) size with zeros, and \\n          account for first occurence with proper count: for \\n          \\'bella\\' and 3 words this would look like \\n                  b: [1, 0, 0]\\n                  e: [1, 0, 0]\\n                  l: [2, 0, 0] there are 2 \\'l\\'s\\n                  a: [1, 0 ,0]\\n      \"\"\"\\n      \\n        firstWordMap = {}\\n        for letter in words[0]:\\n            if letter not in firstWordMap:\\n                firstWordMap[letter] = [0] * len(words)\\n                firstWordMap[letter][0] = 1\\n            else:\\n                firstWordMap[letter][0] += 1\\n        \\'\\'\\'\\n        from index 1-len(words), sum up only the letters that show up in that first OG word \\n\\t\\tand  place the count in the correct index in hash map value for that letter\\n        \\'\\'\\'\\n        for i in range(1, len(words)):\\n            curr = words[i]\\n            for letter in curr:\\n                if letter in firstWordMap:\\n                    firstWordMap[letter][i] += 1\\n        \\n        result = []\\n        \\'\\'\\'\\n          iterate over key, value pairs \\n          append each letter min times it shows up in all words\\n          this will append letters with 0 occurrences 0 times, \\n          which handles the scenario where a letter in that first\\n          word does not show up in other words\\n          so for a map like this:\\n        {\\'a\\': [1, 1, 0], means \\'a\\' shows up in first and second word but NOT in third\\n         \\'b\\': [1, 1, 0], same as above\\n         \\'e\\': [1, 1, 1], means \\'e\\' shows up once in all 3 words\\n         \\'l\\': [2, 2, 2]  means \\'l\\' shows up twice in all 3 words\\n        }\\n        result will correctly contain one \\'e\\' and two \\'l\\'s\\n        \\'\\'\\'\\n        for letter, occurences in firstWordMap.items():\\n            for i in range(min(occurences)):\\n                result.append(letter)\\n        return result\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        example input: words = [\"bella\",\"label\",\"roller\"]\\n                output: [\"e\",\"l\",\"l\"]\\n        approach: we are only interested in letters that are in \\n                  all 3 words, therefore map only the letters in \\n                  first word like for \\'bella\\': \\n          fill the array of len(words) size with zeros, and \\n          account for first occurence with proper count: for \\n          \\'bella\\' and 3 words this would look like \\n                  b: [1, 0, 0]\\n                  e: [1, 0, 0]\\n                  l: [2, 0, 0] there are 2 \\'l\\'s\\n                  a: [1, 0 ,0]\\n      \"\"\"\\n      \\n        firstWordMap = {}",
                "codeTag": "Java"
            },
            {
                "id": 1793520,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    string common(string a, string b){ //gives us common characters between two strings\\n        string ans=\"\";\\n        map<char,int> m;\\n        for(int i=0;i<a.length();i++) m[a[i]]++;\\n        for(int i=0;i<b.length();i++){\\n            if(m.find(b[i])!=m.end() && m[b[i]]>0) {\\n                ans+=b[i];\\n                m[b[i]]--;}\\n            \\n        }\\n        return ans;\\n    }\\n\\n    vector<string> commonChars(vector<string>& words) {\\n        string fans=words[0]; //fans=final answer\\n        for(int i=0;i<words.size();i++){\\n            string ans=common(fans,words[i]);\\n            fans=ans;\\n        }\\n        vector<string> res;\\n        for(int i=0;i<fans.length();i++){\\n            string s(1, fans[i]); //converting each character of fans to string\\n            res.push_back(s);\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    string common(string a, string b){ //gives us common characters between two strings\\n        string ans=\"\";\\n        map<char,int> m;\\n        for(int i=0;i<a.length();i++) m[a[i]]++;\\n        for(int i=0;i<b.length();i++){\\n            if(m.find(b[i])!=m.end() && m[b[i]]>0) {\\n                ans+=b[i];\\n                m[b[i]]--;}\\n            \\n        }\\n        return ans;\\n    }\\n\\n    vector<string> commonChars(vector<string>& words) {\\n        string fans=words[0]; //fans=final answer\\n        for(int i=0;i<words.size();i++){\\n            string ans=common(fans,words[i]);\\n            fans=ans;\\n        }\\n        vector<string> res;\\n        for(int i=0;i<fans.length();i++){\\n            string s(1, fans[i]); //converting each character of fans to string\\n            res.push_back(s);\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738597,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n       String str = words[0];\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < str.length(); i++)\\n        {\\n            char ch = str.charAt(i);\\n            int count = 1;\\n            for(int j = 1; j < words.length; j++)\\n            {\\n                String s = words[j];\\n                for(int k = 0; k < s.length(); k++)\\n                {\\n                    char c = s.charAt(k);\\n                    if(c == ch)\\n                    {\\n                        StringBuilder sb = new StringBuilder(s);\\n                        sb.setCharAt(k, \\'1\\');\\n                        words[j] = sb.toString();\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(count == words.length)\\n            {\\n                list.add(ch+\"\");\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n       String str = words[0];\\n        List<String> list = new ArrayList<>();\\n        for(int i = 0; i < str.length(); i++)\\n        {\\n            char ch = str.charAt(i);\\n            int count = 1;\\n            for(int j = 1; j < words.length; j++)\\n            {\\n                String s = words[j];\\n                for(int k = 0; k < s.length(); k++)\\n                {\\n                    char c = s.charAt(k);\\n                    if(c == ch)\\n                    {\\n                        StringBuilder sb = new StringBuilder(s);\\n                        sb.setCharAt(k, \\'1\\');\\n                        words[j] = sb.toString();\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(count == words.length)\\n            {\\n                list.add(ch+\"\");\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410231,
                "title": "python-faster-than-98",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if len(words) == 0:\\n            return\\n        \\n        ref = words[0] # reference word to compare to rest of list\\n        ret = []\\n            \\n        for char in ref:\\n            valid = True\\n            for i in range(1, len(words)):\\n                # break if word does not contain this char\\n                if not char in words[i]:\\n                    valid = False\\n                    break\\n                else:\\n                    # replace first occurrence of char with blank (allow duplicates)\\n                    words[i] = words[i].replace(char, \"\", 1)\\n            if valid:\\n                ret.append(char)\\n                    \\n        return ret\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if len(words) == 0:\\n            return\\n        \\n        ref = words[0] # reference word to compare to rest of list\\n        ret = []\\n            \\n        for char in ref:\\n            valid = True\\n            for i in range(1, len(words)):\\n                # break if word does not contain this char\\n                if not char in words[i]:\\n                    valid = False\\n                    break\\n                else:\\n                    # replace first occurrence of char with blank (allow duplicates)\\n                    words[i] = words[i].replace(char, \"\", 1)\\n            if valid:\\n                ret.append(char)\\n                    \\n        return ret\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1310060,
                "title": "o-n-2-solution-python3",
                "content": "**I know it\\'s pretty immature approach but helpful for beginners.**\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return list(*words)\\n        output=[]\\n        for i in words[0]:\\n            temp=0\\n            for j,k in enumerate(words[1:]):\\n                if i in k:\\n                    words[j+1]=k.replace(i,\"_\",1)\\n                    temp+=1\\n            if temp==len(words)-1:\\n                output.append(i)\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return list(*words)\\n        output=[]\\n        for i in words[0]:\\n            temp=0\\n            for j,k in enumerate(words[1:]):\\n                if i in k:\\n                    words[j+1]=k.replace(i,\"_\",1)\\n                    temp+=1\\n            if temp==len(words)-1:\\n                output.append(i)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283213,
                "title": "c-easy-to-understand-using-vectors-clean-code",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string> A){\\n       vector<int> main(26,0);\\n       vector<int> temp(26,0);\\n       for(int i=0;i<A[0].length();i++)\\n       {\\n           main[A[0][i]-\\'a\\']++;\\n       }\\n       for(int i=1;i<A.size();i++)\\n       {\\n           for(int j=0;j<A[i].length();j++)\\n           {\\n               temp[A[i][j]-\\'a\\']++;\\n           }\\n           for(int j=0;j<26;j++)\\n           {\\n               main[j]=min(main[j],temp[j]);\\n               temp[j]=0;\\n           }\\n       }\\n        vector<string> ans;\\n       for(int i=0;i<26;i++)\\n       {\\n           if(main[i]>0)\\n           {\\n               while(main[i]--)\\n               {\\n                   string str=\"\";\\n                   str.append(1,(char)(i+97));\\n                   ans.push_back(str);\\n               }\\n           }\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> commonChars(vector<string> A){\\n       vector<int> main(26,0);\\n       vector<int> temp(26,0);\\n       for(int i=0;i<A[0].length();i++)\\n       {\\n           main[A[0][i]-\\'a\\']++;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1150217,
                "title": "python3-simple-and-readable-solution",
                "content": "**Runtime Beats 98% of Python3 Sumbissions**\\n```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        arr = []\\n        for i in set(A[0]):\\n            ans = [A[0].count(i)]\\n            for j in A[1:]:\\n                if(i in j):\\n                    ans.append(j.count(i))\\n            if(len(ans) == len(A)):\\n                arr += ([i] * min(ans))\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        arr = []\\n        for i in set(A[0]):\\n            ans = [A[0].count(i)]\\n            for j in A[1:]:\\n                if(i in j):\\n                    ans.append(j.count(i))\\n            if(len(ans) == len(A)):\\n                arr += ([i] * min(ans))\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108075,
                "title": "c-solution-constant-size-frequency-table",
                "content": "Because all of the frequency tables will be compared at the end to produce one set of counters with the minimum for each character, we could easily do with only two frequency tables. When building a frequency table for a string, we can merge it into the final frequency table as soon as we\\'re done counting. Afterward, we just allocate the prescribed amount of strings and return the resulting array.\\n\\n```\\nvoid calculateHistorgram(unsigned char finalFreq[26], char ** A, int ASize){\\n    unsigned char tempFreq[26];\\n    char * strPtr;\\n    int i, j;\\n    \\n    for(strPtr = A[0]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n        ++finalFreq[*strPtr - \\'a\\'];\\n    \\n    for(i = 1; i < ASize; ++i){\\n        memset(tempFreq, 0, sizeof(tempFreq));\\n        \\n        for(strPtr = A[i]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n            ++tempFreq[*strPtr - \\'a\\'];\\n        \\n        for(j = 0; j < 26; ++j){\\n            if(tempFreq[j] < finalFreq[j])\\n                finalFreq[j] = tempFreq[j];\\n        }\\n    }\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** commonChars(char ** A, int ASize, int* returnSize){\\n    unsigned char freq[26] = {0};\\n    char ** output;\\n    int i, j, ctr;\\n    int outputSize = 0;\\n    \\n    calculateHistorgram(freq, A, ASize);\\n    \\n    for(i = 0; i < 26; ++i)\\n        outputSize += freq[i];\\n    \\n    output = malloc(outputSize * sizeof(char *));\\n    \\n    for(i = 0, j = 0; i < 26; ++i){\\n        for(ctr = freq[i]; ctr-- > 0; ++j){\\n            output[j] = malloc(2 * sizeof(char));\\n            output[j][0] = \\'a\\' + i;\\n            output[j][1] = \\'\\\\0\\';\\n        }\\n    }\\n    \\n    *returnSize = outputSize;\\n    \\n    return output;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "Because all of the frequency tables will be compared at the end to produce one set of counters with the minimum for each character, we could easily do with only two frequency tables. When building a frequency table for a string, we can merge it into the final frequency table as soon as we\\'re done counting. Afterward, we just allocate the prescribed amount of strings and return the resulting array.\\n\\n```\\nvoid calculateHistorgram(unsigned char finalFreq[26], char ** A, int ASize){\\n    unsigned char tempFreq[26];\\n    char * strPtr;\\n    int i, j;\\n    \\n    for(strPtr = A[0]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n        ++finalFreq[*strPtr - \\'a\\'];\\n    \\n    for(i = 1; i < ASize; ++i){\\n        memset(tempFreq, 0, sizeof(tempFreq));\\n        \\n        for(strPtr = A[i]; *strPtr != \\'\\\\0\\'; ++strPtr)\\n            ++tempFreq[*strPtr - \\'a\\'];\\n        \\n        for(j = 0; j < 26; ++j){\\n            if(tempFreq[j] < finalFreq[j])\\n                finalFreq[j] = tempFreq[j];\\n        }\\n    }\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** commonChars(char ** A, int ASize, int* returnSize){\\n    unsigned char freq[26] = {0};\\n    char ** output;\\n    int i, j, ctr;\\n    int outputSize = 0;\\n    \\n    calculateHistorgram(freq, A, ASize);\\n    \\n    for(i = 0; i < 26; ++i)\\n        outputSize += freq[i];\\n    \\n    output = malloc(outputSize * sizeof(char *));\\n    \\n    for(i = 0, j = 0; i < 26; ++i){\\n        for(ctr = freq[i]; ctr-- > 0; ++j){\\n            output[j] = malloc(2 * sizeof(char));\\n            output[j][0] = \\'a\\' + i;\\n            output[j][1] = \\'\\\\0\\';\\n        }\\n    }\\n    \\n    *returnSize = outputSize;\\n    \\n    return output;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1019213,
                "title": "java-constant-space-straightforward-explanation",
                "content": "Key Idea:\\n- Take first string into account as that\\'s the bare minimum required to return *something*. Have a hashmap that stores each character\\'s total occurrences. (`charFreq`)\\n- Loop through other strings:\\n\\t- For each string, have a hashmap to store each character\\'s occurrences. (`currCharFreq`)\\n\\t- Find the minimum of occurrences between `currCharFreq` and `charFreq` for each character => and store in `charFreq`. (again bare minimum is needed)\\n- At the end, you will be left with **non-zero** occurrences implying the common characters in total.\\n\\n**Time Complexity:** `O(N * M)`, where `N` - A.length (total number of strings) and `M` - the number of characters in the longest string.\\n**Space Complexity** `O(1)`, excluding the return list space.\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<>();\\n        int n = A.length;\\n        int[] charFreq = new int[26];\\n        \\n\\t\\tfor(char c : A[0].toCharArray())\\n            charFreq[c - \\'a\\']++;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int[] currCharFreq = new int[26];\\n\\t\\t\\t\\n            for(Character c : A[i].toCharArray())\\n\\t\\t\\t\\tcurrCharFreq[c - \\'a\\']++;\\n            \\n\\t\\t\\tfor(int k = 0; k < 26; k++)\\n\\t\\t\\t\\tcharFreq[k] = Math.min(currCharFreq[k], charFreq[k]); \\n        }\\n        \\n\\t\\tfor(int i = 0; i < 26; i++)\\n            while(charFreq[i]-- > 0)\\n                list.add(Character.toString(i + \\'a\\')); //add only those that have frequency count > 0. If none, then return empty list.\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        List<String> list = new ArrayList<>();\\n        int n = A.length;\\n        int[] charFreq = new int[26];\\n        \\n\\t\\tfor(char c : A[0].toCharArray())\\n            charFreq[c - \\'a\\']++;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int[] currCharFreq = new int[26];\\n\\t\\t\\t\\n            for(Character c : A[i].toCharArray())\\n\\t\\t\\t\\tcurrCharFreq[c - \\'a\\']++;\\n            \\n\\t\\t\\tfor(int k = 0; k < 26; k++)\\n\\t\\t\\t\\tcharFreq[k] = Math.min(currCharFreq[k], charFreq[k]); \\n        }\\n        \\n\\t\\tfor(int i = 0; i < 26; i++)\\n            while(charFreq[i]-- > 0)\\n                list.add(Character.toString(i + \\'a\\')); //add only those that have frequency count > 0. If none, then return empty list.\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015608,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        \\n        count = Counter(A[0])            \\n        for word in A[1:]:\\n            count &= Counter(word)\\n                    \\n        result = []\\n        for x in count:\\n            result += [x] * count[x]\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        \\n        count = Counter(A[0])            \\n        for word in A[1:]:\\n            count &= Counter(word)\\n                    \\n        result = []\\n        for x in count:\\n            result += [x] * count[x]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010839,
                "title": "python-solution",
                "content": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        else:\\n            freq = Counter(A[0])\\n            for i in range(1, len(A)):\\n                for key in freq:\\n                    freq[key] = min(freq[key],A[i].count(key))\\n            return freq.elements()  \\n```\\n\\nWould really appreciate your feedback on how to fasten my code.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return None\\n        else:\\n            freq = Counter(A[0])\\n            for i in range(1, len(A)):\\n                for key in freq:\\n                    freq[key] = min(freq[key],A[i].count(key))\\n            return freq.elements()  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 898947,
                "title": "python-3-detailed-explanation-including-assumptions-missed-in-the-question-itself",
                "content": "**Idea**:\\nFirst, you need to make sure that all elements of the same length. Currently nothing states that this is a case. Thus, we will assume otherwise and will do sorting. Your result cannot have letters that are **not** present in the shortest word.\\nSecond, we will count characters\\' frequencies in the shortest word and save them in ```d_shortest```.\\nThen we will iterate over all other words. \\nThe trick is the following. You need to make sure that\\n1. you are looking at a character that is present in ```d_shortest```\\n2. and after that you need to update the respective character\\'s value by choosing between the current value and the number of times this character occurs in a current word\\n\\n\\nThird, after updating you dictionary, you need to build an answer. \\nIterate over the dictionaries\\' keys and values and, if the value ```>=1``` (means that this character is present in all words), append the character whatever many times its key tells you.\\n\\n```\\nfrom collections import Counter\\ndef commonChars(A):\\n    res = []\\n    A.sort(key = lambda x: len(x))\\n    d_shortest = Counter(A[0])\\n    for word in A[1:]:\\n        for k in d_shortest:\\n            d_shortest[k] = min(d_shortest[k], word.count(k))\\n    for k, v in d_shortest.items():\\n        if v >= 1:\\n            for _ in range(v):\\n                res.append(k)\\n    return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```d_shortest```\n```d_shortest```\n```>=1```\n```\\nfrom collections import Counter\\ndef commonChars(A):\\n    res = []\\n    A.sort(key = lambda x: len(x))\\n    d_shortest = Counter(A[0])\\n    for word in A[1:]:\\n        for k in d_shortest:\\n            d_shortest[k] = min(d_shortest[k], word.count(k))\\n    for k, v in d_shortest.items():\\n        if v >= 1:\\n            for _ in range(v):\\n                res.append(k)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 834680,
                "title": "ultimate-use-of-dictionaries-in-python",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        m = collections.defaultdict(lambda:[0]*len(A))\\n        for i in range(len(A)):\\n            for char in A[i]:\\n                if char not in m:\\n                    m[char][i] = 1\\n                else:\\n                    m[char][i] += 1\\n        res = []\\n        for key,values in m.items():\\n            value = min(values)\\n            if value != 0:\\n                res.extend(key*value)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        m = collections.defaultdict(lambda:[0]*len(A))\\n        for i in range(len(A)):\\n            for char in A[i]:\\n                if char not in m:\\n                    m[char][i] = 1\\n                else:\\n                    m[char][i] += 1\\n        res = []\\n        for key,values in m.items():\\n            value = min(values)\\n            if value != 0:\\n                res.extend(key*value)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790529,
                "title": "python-simple",
                "content": "Slightly modified version of https://leetcode.com/problems/find-common-characters/discuss/247560/Python-1-Line\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        res = Counter(A[0])\\n        \\n        for a in A:\\n            res &= Counter(a)\\n        \\n        return res.elements()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        res = Counter(A[0])\\n        \\n        for a in A:\\n            res &= Counter(a)\\n        \\n        return res.elements()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786157,
                "title": "python-3-using-set-count",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A):\\n        \"\"\"\\n        Given a list of strings consisting of lowercase letters,\\n        this program determines the list of common letters,\\n        including frequencies, among all the strings.\\n\\n        :param A: list of strings made up of only lowercase letters\\n        :type A: list[str]\\n        :return: list of common letters among all strings in A\\n        :rtype: list[str]\\n        \"\"\"\\n        \\n        \"\"\"\\n        Get the set of letters that are common to all strings in A.\\n        \"\"\"\\n        set_A = set(A[0])\\n        for a in A[1:]:\\n            set_A = set_A.intersection(a)\\n        \\n        \"\"\"\\n        For each common letter, determine its frequency that is\\n        common to all strings in A. Capture the common letters\\n        and their frequencies in common_letters and return\\n        common_letters to the caller.\\n        \"\"\"\\n        common_letters = []\\n        for letter in set_A:\\n            count = 101\\n            for a in A:\\n                count = min(count, a.count(letter))\\n            common_letters += [letter] * count\\n        return common_letters\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A):\\n        \"\"\"\\n        Given a list of strings consisting of lowercase letters,\\n        this program determines the list of common letters,\\n        including frequencies, among all the strings.\\n\\n        :param A: list of strings made up of only lowercase letters\\n        :type A: list[str]\\n        :return: list of common letters among all strings in A\\n        :rtype: list[str]\\n        \"\"\"\\n        \\n        \"\"\"\\n        Get the set of letters that are common to all strings in A.\\n        \"\"\"\\n        set_A = set(A[0])\\n        for a in A[1:]:\\n            set_A = set_A.intersection(a)\\n        \\n        \"\"\"\\n        For each common letter, determine its frequency that is\\n        common to all strings in A. Capture the common letters\\n        and their frequencies in common_letters and return\\n        common_letters to the caller.\\n        \"\"\"\\n        common_letters = []\\n        for letter in set_A:\\n            count = 101\\n            for a in A:\\n                count = min(count, a.count(letter))\\n            common_letters += [letter] * count\\n        return common_letters\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776863,
                "title": "javascript-99-faster-easy-to-read-and-understand",
                "content": "Loop through the first word, since the matching letters have to be in every word.\\n\\n```\\nvar commonChars = function(A) {\\n    let res = [];\\n    \\n    // Set number of loops outside of function\\n    // Since we modify A[0]\\n    let loops = A[0].length;\\n    \\n    for (let i = 0; i < loops; i++) {\\n        let letter = A[0][i];\\n        \\n        if (letter === undefined) return res;\\n\\n        if (A.every(word => word.indexOf(letter) !== -1 )) {\\n            // Every word in array has letter\\n            res.push(letter);\\n            \\n            // Remove the matched letter from the words\\n            A = A.map(word => word.replace(letter, \\'\\'));\\n            \\n            // Reset i since we replaced the current letter\\n            i--;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nStats:\\nRuntime: 68 ms, faster than 99.77% of JavaScript online submissions for Find Common Characters.\\nMemory Usage: 38.6 MB, less than 84.51% of JavaScript online submissions for Find Common Characters.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar commonChars = function(A) {\\n    let res = [];\\n    \\n    // Set number of loops outside of function\\n    // Since we modify A[0]\\n    let loops = A[0].length;\\n    \\n    for (let i = 0; i < loops; i++) {\\n        let letter = A[0][i];\\n        \\n        if (letter === undefined) return res;\\n\\n        if (A.every(word => word.indexOf(letter) !== -1 )) {\\n            // Every word in array has letter\\n            res.push(letter);\\n            \\n            // Remove the matched letter from the words\\n            A = A.map(word => word.replace(letter, \\'\\'));\\n            \\n            // Reset i since we replaced the current letter\\n            i--;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636527,
                "title": "java-simple-and-easy-to-understand",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n             \\n        List<String> result = new ArrayList<>();\\n               \\n        for(Character c: A[0].toCharArray()) {\\n            \\n            boolean exists = true;\\n            for(int i =1; i <A.length; i++) {\\n                if(A[i].indexOf(c+\"\") == -1) {\\n                    exists = false;\\n                    break;\\n                } else {\\n                    A[i] = A[i].replaceFirst(c+\"\",\"\");\\n                }\\n            }\\n            \\n            if(exists) \\n                result.add(c + \"\");\\n            \\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n             \\n        List<String> result = new ArrayList<>();\\n               \\n        for(Character c: A[0].toCharArray()) {\\n            \\n            boolean exists = true;\\n            for(int i =1; i <A.length; i++) {\\n                if(A[i].indexOf(c+\"\") == -1) {\\n                    exists = false;\\n                    break;\\n                } else {\\n                    A[i] = A[i].replaceFirst(c+\"\",\"\");\\n                }\\n            }\\n            \\n            if(exists) \\n                result.add(c + \"\");\\n            \\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607334,
                "title": "python-simple-and-clean-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        from collections import Counter\\n        \\n        overlap = Counter(A[0])\\n        for i in range(1, len(A)):\\n            overlap = overlap & Counter(A[i])\\n            \\n        res = []    \\n        for key, value in overlap.items():\\n            res.extend(list(key)*value)\\n            \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        from collections import Counter\\n        \\n        overlap = Counter(A[0])\\n        for i in range(1, len(A)):\\n            overlap = overlap & Counter(A[i])\\n            \\n        res = []    \\n        for key, value in overlap.items():\\n            res.extend(list(key)*value)\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 537979,
                "title": "java-use-hashmap",
                "content": "```\\npublic List<String> commonChars(String[] A) {\\n        int[] res = new int[26];\\n        Arrays.fill(res, Integer.MAX_VALUE);\\n        for (String s : A) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                map.put(c - \\'a\\', map.getOrDefault(c - \\'a\\', 0) + 1);\\n            }\\n            for (int i = 0; i < 26; i++) {\\n                res[i] = Math.min(res[i], map.getOrDefault(i, 0));\\n            }\\n        }\\n        List<String> ret = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            while (res[i] > 0) {\\n                ret.add(String.valueOf((char) (i + \\'a\\')));\\n                res[i]--;\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> commonChars(String[] A) {\\n        int[] res = new int[26];\\n        Arrays.fill(res, Integer.MAX_VALUE);\\n        for (String s : A) {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                map.put(c - \\'a\\', map.getOrDefault(c - \\'a\\', 0) + 1);\\n            }\\n            for (int i = 0; i < 26; i++) {\\n                res[i] = Math.min(res[i], map.getOrDefault(i, 0));\\n            }\\n        }\\n        List<String> ret = new ArrayList<>();\\n        for (int i = 0; i < 26; i++) {\\n            while (res[i] > 0) {\\n                ret.add(String.valueOf((char) (i + \\'a\\')));\\n                res[i]--;\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528098,
                "title": "javascript",
                "content": "```\\nvar commonChars = function(A) {\\n    let common = A[0].split(\\'\\').filter(char => {\\n        for (var i = 1; i < A.length; i++) {\\n            if (!A[i].includes(char)) return false;\\n            else {\\n                A[i] = A[i].replace(char, \\'\\')\\n            }\\n        }\\n        return true;\\n    })\\n\\treturn common\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar commonChars = function(A) {\\n    let common = A[0].split(\\'\\').filter(char => {\\n        for (var i = 1; i < A.length; i++) {\\n            if (!A[i].includes(char)) return false;\\n            else {\\n                A[i] = A[i].replace(char, \\'\\')\\n            }\\n        }\\n        return true;\\n    })\\n\\treturn common\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454371,
                "title": "python-dictionary-beat-96-time-and-100-space",
                "content": "![image](https://assets.leetcode.com/users/jefferyzzy/image_1576619610.png)\\n```\\nimport collections\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict = collections.Counter(A[0])\\n        for i in range(1, len(A)):\\n            del_keys = []\\n            for k, v in dict.items():\\n                if k in A[i]:\\n                    dict[k] = min(A[i].count(k), v)\\n                else:\\n                    del_keys.append(k)\\n            for key in del_keys:\\n                del dict[key]\\n        return list(dict.elements())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        dict = collections.Counter(A[0])\\n        for i in range(1, len(A)):\\n            del_keys = []\\n            for k, v in dict.items():\\n                if k in A[i]:\\n                    dict[k] = min(A[i].count(k), v)\\n                else:\\n                    del_keys.append(k)\\n            for key in del_keys:\\n                del dict[key]\\n        return list(dict.elements())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435957,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int k = 0; k < A.length; k++) {\\n            String s = A[k];\\n            for (int i = 0; i < s.length(); i++) {\\n                Map<Integer, Integer> set = map.getOrDefault(s.charAt(i), new HashMap<>());\\n                set.put(k, set.getOrDefault(k, 0) + 1);\\n                map.put(s.charAt(i), set);\\n            }\\n        }\\n        List<String> result = new ArrayList<>();\\n        for (Character c : map.keySet()) {\\n            if (map.get(c).size() < A.length) {\\n                continue;\\n            }\\n            int cnt = Integer.MAX_VALUE;\\n            for (Map.Entry<Integer, Integer> e : map.get(c).entrySet()) {\\n                cnt = Math.min(e.getValue(), cnt);\\n            }\\n            for (int i = 0; i < cnt; i++) {\\n                result.add(\"\"+c);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        Map<Character, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int k = 0; k < A.length; k++) {\\n            String s = A[k];\\n            for (int i = 0; i < s.length(); i++) {\\n                Map<Integer, Integer> set = map.getOrDefault(s.charAt(i), new HashMap<>());\\n                set.put(k, set.getOrDefault(k, 0) + 1);\\n                map.put(s.charAt(i), set);\\n            }\\n        }\\n        List<String> result = new ArrayList<>();\\n        for (Character c : map.keySet()) {\\n            if (map.get(c).size() < A.length) {\\n                continue;\\n            }\\n            int cnt = Integer.MAX_VALUE;\\n            for (Map.Entry<Integer, Integer> e : map.get(c).entrySet()) {\\n                cnt = Math.min(e.getValue(), cnt);\\n            }\\n            for (int i = 0; i < cnt; i++) {\\n                result.add(\"\"+c);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395860,
                "title": "python-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \"\"\"\\n        A Counter is a dict subclass for counting hashable objects. \\n        It is an unordered collection where elements are stored as dictionary keys \\n        and their counts are stored as dictionary values.\\n        \"\"\"\\n        c=Counter(A[0])\\n        for i in range(1,len(A)):\\n            c&=Counter(A[i]) # concept borrowed from [rachit\\'s solution](https://leetcode.com/problems/find-common-characters/discuss/394501/Python-Simple-Solution)\\n            \"\"\"\\n            elements() Return an iterator over elements repeating each as many times \\n            as its count. Elements are returned in arbitrary order. If an element\\u2019s \\n            count is less than one, elements() will ignore it.\\n            \"\"\"\\n        return c.elements()\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \"\"\"\\n        A Counter is a dict subclass for counting hashable objects. \\n        It is an unordered collection where elements are stored as dictionary keys \\n        and their counts are stored as dictionary values.\\n        \"\"\"\\n        c=Counter(A[0])\\n        for i in range(1,len(A)):\\n            c&=Counter(A[i]) # concept borrowed from [rachit\\'s solution](https://leetcode.com/problems/find-common-characters/discuss/394501/Python-Simple-Solution)\\n            \"\"\"\\n            elements() Return an iterator over elements repeating each as many times \\n            as its count. Elements are returned in arbitrary order. If an element\\u2019s \\n            count is less than one, elements() will ignore it.\\n            \"\"\"\\n        return c.elements()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356723,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \\n        # Add first word in list \\n        prev_word = [char for char in A[0]]\\n        \\n        \\n        # Loop through the list starting from second item since we already marked the first above \\n        for word in A[1:]:\\n            current_word = []\\n            for char in word:\\n                if char in prev_word:\\n                    # If the current word we are iterating over is in the prev_word then append to the current_word list\\n                    current_word.append(char)\\n                    # Need to remove the just visited char otherwise we will keep adding it to our current_word list \\n                    prev_word.remove(char)\\n            \\n            prev_word = current_word\\n            \\n        return prev_word\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        \\n        # Add first word in list \\n        prev_word = [char for char in A[0]]\\n        \\n        \\n        # Loop through the list starting from second item since we already marked the first above \\n        for word in A[1:]:\\n            current_word = []\\n            for char in word:\\n                if char in prev_word:\\n                    # If the current word we are iterating over is in the prev_word then append to the current_word list\\n                    current_word.append(char)\\n                    # Need to remove the just visited char otherwise we will keep adding it to our current_word list \\n                    prev_word.remove(char)\\n            \\n            prev_word = current_word\\n            \\n        return prev_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332716,
                "title": "very-easy-to-understand-python-solution",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if A:\\n            t = list(A.pop())\\n            n = []\\n            while A:\\n                s = A.pop()\\n                for val in s:\\n                    if val in t:\\n                        t.remove(val)\\n                        n.append(val)\\n                t = n\\n                n = []\\n        return t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if A:\\n            t = list(A.pop())\\n            n = []\\n            while A:\\n                s = A.pop()\\n                for val in s:\\n                    if val in t:\\n                        t.remove(val)\\n                        n.append(val)\\n                t = n\\n                n = []\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288671,
                "title": "swift-3-line-solution",
                "content": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        let chars = A.map { Set($0) }.reduce(Set(A.first!)) { $0.intersection($1) }\\n        let counts = Dictionary(A.flatMap { Dictionary($0.compactMap { chars.contains($0) ? ($0,1) : nil }, uniquingKeysWith:+) }, uniquingKeysWith:min)\\n        return counts.flatMap { Array(repeating:String($0.0), count:$0.1) }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func commonChars(_ A: [String]) -> [String] {\\n        let chars = A.map { Set($0) }.reduce(Set(A.first!)) { $0.intersection($1) }\\n        let counts = Dictionary(A.flatMap { Dictionary($0.compactMap { chars.contains($0) ? ($0,1) : nil }, uniquingKeysWith:+) }, uniquingKeysWith:min)\\n        return counts.flatMap { Array(repeating:String($0.0), count:$0.1) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285824,
                "title": "go-o-n-solution-beat-100",
                "content": "```go\\nfunc commonChars(A []string) []string {\\n\\tres := []string{}\\n\\tfor i := range A[0] {\\n\\t\\tcurrentString := A[0][i : i+1]\\n\\t\\tfind := true\\n\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\tif strings.Index(A[j], currentString) == -1 {\\n\\t\\t\\t\\tfind = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif find  {\\n\\t\\t\\t// \\u6D88\\u8017\\u4E00\\u4E2A\\n\\t\\t\\tres = append(res, currentString)\\n\\n\\t\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\t\\tcurrentStringIndex := strings.Index(A[j], currentString)\\n\\t\\t\\t\\tA[j] = A[j][:currentStringIndex] + A[j][currentStringIndex+1:]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc commonChars(A []string) []string {\\n\\tres := []string{}\\n\\tfor i := range A[0] {\\n\\t\\tcurrentString := A[0][i : i+1]\\n\\t\\tfind := true\\n\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\tif strings.Index(A[j], currentString) == -1 {\\n\\t\\t\\t\\tfind = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif find  {\\n\\t\\t\\t// \\u6D88\\u8017\\u4E00\\u4E2A\\n\\t\\t\\tres = append(res, currentString)\\n\\n\\t\\t\\tfor j := 1; j < len(A); j++ {\\n\\t\\t\\t\\tcurrentStringIndex := strings.Index(A[j], currentString)\\n\\t\\t\\t\\tA[j] = A[j][:currentStringIndex] + A[j][currentStringIndex+1:]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267593,
                "title": "clean-python",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        my_list, res = [], []\\n        for v in A:\\n            my_list.append(Counter(v))\\n        for key in my_list[0]:\\n            times = my_list[0][key]\\n            for e in my_list[1:]:\\n                times = min(times, e[key])\\n            for _ in range(times):\\n                res.append(key)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        my_list, res = [], []\\n        for v in A:\\n            my_list.append(Counter(v))\\n        for key in my_list[0]:\\n            times = my_list[0][key]\\n            for e in my_list[1:]:\\n                times = min(times, e[key])\\n            for _ in range(times):\\n                res.append(key)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259572,
                "title": "python-solution-runtime-beats-98-39-memory-beats-100",
                "content": "\\tdef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return []\\n\\n        concat = set(\\'\\'.join(A))\\n        repeats = []\\n        for char in concat:\\n            occurance = min([x.count(char) for x in A])\\n            repeats += [char]*occurance\\n        return repeats\\n\\t",
                "solutionTags": [],
                "code": "\\tdef commonChars(self, A: List[str]) -> List[str]:\\n        if not A:\\n            return []\\n\\n        concat = set(\\'\\'.join(A))\\n        repeats = []\\n        for char in concat:\\n            occurance = min([x.count(char) for x in A])\\n            repeats += [char]*occurance\\n        return repeats\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 255465,
                "title": "simple-python3-code",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        l=[]\\n        for i in \"abcdefghijklmnopqrstuvwxyz\":\\n            l=l+[i]*min(list(map(lambda x:x.count(i),A)))\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, A):\\n        l=[]\\n        for i in \"abcdefghijklmnopqrstuvwxyz\":\\n            l=l+[i]*min(list(map(lambda x:x.count(i),A)))\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247552,
                "title": "simple-python-version",
                "content": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        d1 = Counter(A[0])\\n        for i in range(1,len(A)):\\n            d2 = Counter(A[i])\\n            d1 = d1 & d2\\n        ans = list(d1.elements())\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def commonChars(self, A: List[str]) -> List[str]:\\n        ans = []\\n        d1 = Counter(A[0])\\n        for i in range(1,len(A)):\\n            d2 = Counter(A[i])\\n            d1 = d1 & d2\\n        ans = list(d1.elements())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020449,
                "title": "c-code-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        //to store the count of common element\\n        vector<int>common(26,INT_MAX);\\n        //to stroe the result\\n        vector<string>res;\\n        for(auto s :words){\\n            //to stroe the count of each element\\n            vector<int>count(26,0);\\n            //to count the frequency\\n            for(auto c:s) count[c-\\'a\\']++;\\n            // to store the min count of elements \\n            //as we find the common elements in each string\\n            //so we need to stroe the min freq of them\\n            //eg [\"cool\",\"lock\",\"cook\"] \\n            //in cool count of l -1, lock count of l-1 , cook of l -0\\n            //min count is-->0 so we store common[i]=0 for count of l\\n\\n            for(int i=0;i<26;++i){\\n                common[i]=min(common[i],count[i]);\\n            \\n            }\\n        }\\n        //store the ouput in result\\n        for(int i=0;i<26;++i){\\n        //if common[i] is not 0 we have store it common[i] times as it includes duplicates    \\n            if(common[i]>0){\\n                while(common[i]--)res.push_back(string(1,i+\\'a\\'));//it means we are storing string size 1\\n            }\\n        }\\nreturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        //to store the count of common element\\n        vector<int>common(26,INT_MAX);\\n        //to stroe the result\\n        vector<string>res;\\n        for(auto s :words){\\n            //to stroe the count of each element\\n            vector<int>count(26,0);\\n            //to count the frequency\\n            for(auto c:s) count[c-\\'a\\']++;\\n            // to store the min count of elements \\n            //as we find the common elements in each string\\n            //so we need to stroe the min freq of them\\n            //eg [\"cool\",\"lock\",\"cook\"] \\n            //in cool count of l -1, lock count of l-1 , cook of l -0\\n            //min count is-->0 so we store common[i]=0 for count of l\\n\\n            for(int i=0;i<26;++i){\\n                common[i]=min(common[i],count[i]);\\n            \\n            }\\n        }\\n        //store the ouput in result\\n        for(int i=0;i<26;++i){\\n        //if common[i] is not 0 we have store it common[i] times as it includes duplicates    \\n            if(common[i]>0){\\n                while(common[i]--)res.push_back(string(1,i+\\'a\\'));//it means we are storing string size 1\\n            }\\n        }\\nreturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850080,
                "title": "python-nested-for-in-loops-beats-100-00",
                "content": "# Intuition\\nI decided to take the shortest word (\"min_word\") and compare it to the others\\n\\n# Approach\\nI loop through the shortest word, then loop through the remaining words inside. \\nIf a character is not in the word, I delete it from \"min_word\".\\nElse, I delete it from the comparable word.\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        min_word = min(words)\\n        words.remove(min_word)\\n        for char in min_word[:]: # shallow copy by slice\\n            for idx_w, word in enumerate(words):\\n                if char not in word and (idx_w == len(words) or char in min_word):\\n                    min_word = min_word.replace(char, \"\", 1)\\n                    break\\n                else:\\n                    words[idx_w] = words[idx_w].replace(char, \"\", 1)\\n        return min_word\\n```\\n\\n![Screenshot 2023-08-01 at 11.41.20 PM.png](https://assets.leetcode.com/users/images/1373198d-61ab-4aac-8e3e-153be42047e5_1690922501.803046.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        min_word = min(words)\\n        words.remove(min_word)\\n        for char in min_word[:]: # shallow copy by slice\\n            for idx_w, word in enumerate(words):\\n                if char not in word and (idx_w == len(words) or char in min_word):\\n                    min_word = min_word.replace(char, \"\", 1)\\n                    break\\n                else:\\n                    words[idx_w] = words[idx_w].replace(char, \"\", 1)\\n        return min_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717808,
                "title": "runtime-100-beats-memory-96-beats-fully-explained",
                "content": "# Approach\\n\\n1. Initialize an empty result list, `res`, to store the common characters.\\n2. Declare an empty array, `cnt`, which will be used to count the frequencies of characters.\\n3. Iterate through the words array using a for loop:\\n   - If it is the first word (i.e., `i == 0`), call the `count` method to count the frequencies of characters in the word and assign the result to the `cnt` array.\\n   - If it is not the first word, call the `count` method to count the frequencies of characters in the word and update the `cnt` array by finding the intersection (minimum frequencies) between `cnt` and the current word\\'s frequencies using the `intersect` method.\\n4. After the loop, iterate through the `cnt` array:\\n   - For each index `i` in the `cnt` array, if the frequency at `cnt[i]` is greater than 0, it means the character represented by `i + \\'a\\'` is common. Therefore, decrement `cnt[i]` and add the character to the result list `res` using `String.valueOf((char)(i + \\'a\\'))`.\\n5. Return the result list `res`, which contains all the common characters.\\n\\nThe approach essentially counts the frequencies of characters in each word using the `count` method and finds the intersection of frequencies between the words using the `intersect` method. Finally, it constructs the result list by iterating through the resulting `cnt` array and adding the common characters based on their frequencies.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        int[] cnt = new int[0];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (i == 0) \\n                cnt = count(words[i]);\\n            else \\n                intersect(cnt, count(words[i]));\\n        }\\n\\n        for (int i = 0; i < cnt.length; i++)\\n            while (cnt[i]-- > 0)\\n                res.add(String.valueOf((char)(i + \\'a\\')));\\n\\n        return res;\\n    }\\n\\n    private int[] count(String str) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < str.length(); i++)\\n            ++cnt[str.charAt(i) - \\'a\\'];\\n        return cnt;\\n    }\\n\\n    private void intersect(int[] cnt1, int[] cnt2) {\\n        for (int i = 0; i < cnt1.length; i++)\\n            cnt1[i] = Math.min(cnt1[i], cnt2[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        int[] cnt = new int[0];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (i == 0) \\n                cnt = count(words[i]);\\n            else \\n                intersect(cnt, count(words[i]));\\n        }\\n\\n        for (int i = 0; i < cnt.length; i++)\\n            while (cnt[i]-- > 0)\\n                res.add(String.valueOf((char)(i + \\'a\\')));\\n\\n        return res;\\n    }\\n\\n    private int[] count(String str) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < str.length(); i++)\\n            ++cnt[str.charAt(i) - \\'a\\'];\\n        return cnt;\\n    }\\n\\n    private void intersect(int[] cnt1, int[] cnt2) {\\n        for (int i = 0; i < cnt1.length; i++)\\n            cnt1[i] = Math.min(cnt1[i], cnt2[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461671,
                "title": "nice-short-collections-counter-65-ms-16-4-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI recalled a nice tool fit for the job - the Counter class from the collections built-in module. Aside from other solutions - mine is more readable, though slightly less optimized: redundunt 1-st element conversion and Counter-ization of every word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounter class creates a dictionary-like object with chars as keys and amounts as values. What is more - we can get intersections of Counters with the \"&\" operation (and mechanic).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI read every char of the input and perform word by word comparison. If to be more presize - it is O(x*n), where x is an average word length.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI store only a small portion of the data, representing at most 2 words at a time.\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        counter = Counter(words[0])\\n        for word in words:\\n            counter &= Counter(word)\\n        return list(counter.elements())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        counter = Counter(words[0])\\n        for word in words:\\n            counter &= Counter(word)\\n        return list(counter.elements())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290285,
                "title": "easy-solution-c-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int> freq1(26,0) , freq2(26,0) ;\\n        for(auto ch: words[0]){\\n            freq1[ch -\\'a\\']++;\\n        }\\n        int i , j  , n = words.size() ;\\n        for(i=1;i<n;i++)\\n        {\\n            for(auto ch: words[i]){\\n                freq2[ch-\\'a\\']++;\\n            }\\n            for(j=0;j<26;j++){\\n                freq1[j] = min(freq1[j],freq2[j]) ;\\n                freq2[j] = 0 ;\\n            }\\n        }\\n        vector<string> ans ;\\n        for(i=0;i<26;i++){\\n            if(freq1[i]>0){\\n                char ch = i + \\'a\\' ;\\n                string s = \"\" ;\\n                s += ch;\\n                int count = freq1[i] ;\\n                while(count-->0){\\n                    ans.push_back(s) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int> freq1(26,0) , freq2(26,0) ;\\n        for(auto ch: words[0]){\\n            freq1[ch -\\'a\\']++;\\n        }\\n        int i , j  , n = words.size() ;\\n        for(i=1;i<n;i++)\\n        {\\n            for(auto ch: words[i]){\\n                freq2[ch-\\'a\\']++;\\n            }\\n            for(j=0;j<26;j++){\\n                freq1[j] = min(freq1[j],freq2[j]) ;\\n                freq2[j] = 0 ;\\n            }\\n        }\\n        vector<string> ans ;\\n        for(i=0;i<26;i++){\\n            if(freq1[i]>0){\\n                char ch = i + \\'a\\' ;\\n                string s = \"\" ;\\n                s += ch;\\n                int count = freq1[i] ;\\n                while(count-->0){\\n                    ans.push_back(s) ;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280559,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        \\n  vector<int> ans_freq(26, INT_MAX);\\n  int n=words.size();\\n  for (int i = 0; i < n; i++)\\n  {\\n    vector<int> freq(26,0);\\n    string word = words[i];\\n    for (int j = 0; j < word.size(); j++)\\n      freq[word[j] - \\'a\\']++;\\n\\n    for (int j = 0; j < 26; j++)\\n      ans_freq[j] = min(ans_freq[j], freq[j]);\\n  }\\n\\n   vector<string> ans;\\n  for (int i = 0; i < 26; i++)\\n  {\\n    while (ans_freq[i] != 0)\\n    {\\n      string s=\"\";\\n      char c = \\'a\\' + i;\\n      s=s+c;\\n      ans.push_back(s);\\n      ans_freq[i]--;\\n    }\\n  }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        \\n  vector<int> ans_freq(26, INT_MAX);\\n  int n=words.size();\\n  for (int i = 0; i < n; i++)\\n  {\\n    vector<int> freq(26,0);\\n    string word = words[i];\\n    for (int j = 0; j < word.size(); j++)\\n      freq[word[j] - \\'a\\']++;\\n\\n    for (int j = 0; j < 26; j++)\\n      ans_freq[j] = min(ans_freq[j], freq[j]);\\n  }\\n\\n   vector<string> ans;\\n  for (int i = 0; i < 26; i++)\\n  {\\n    while (ans_freq[i] != 0)\\n    {\\n      string s=\"\";\\n      char c = \\'a\\' + i;\\n      s=s+c;\\n      ans.push_back(s);\\n      ans_freq[i]--;\\n    }\\n  }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278901,
                "title": "python-solution-with-collections",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        from collections import Counter\\n        from typing import List\\n\\n        # Initialize a Counter object with the characters of the first word\\n        common = Counter(words[0])\\n\\n        # Iterate over the remaining words and update the common Counter object\\n        for word in words[1:]:\\n            # Initialize a Counter object for the current word\\n            word_count = Counter(word)\\n            # Update the common Counter object to only include characters present in both\\n            common &= word_count\\n\\n        # Convert the common Counter object to a list of characters\\n        result = []\\n        for char, count in common.items():\\n            result += [char] * count\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        from collections import Counter\\n        from typing import List\\n\\n        # Initialize a Counter object with the characters of the first word\\n        common = Counter(words[0])\\n\\n        # Iterate over the remaining words and update the common Counter object\\n        for word in words[1:]:\\n            # Initialize a Counter object for the current word\\n            word_count = Counter(word)\\n            # Update the common Counter object to only include characters present in both\\n            common &= word_count\\n\\n        # Convert the common Counter object to a list of characters\\n        result = []\\n        for char, count in common.items():\\n            result += [char] * count\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074402,
                "title": "python-readable-no-shortcuts-with-explanation",
                "content": "# Approach\\nThe idea of this approach is to first start with the counts of every character in the first word and store these `character : character count` pairs in `res_counts`. Then we iterate through every other word in the words list. For each word, we use its own `char_counts` hash map to store `character : character count` pairs. Then we iterate through `res_counts`, and reassign each character\\'s count to the min of what it is currently and what we found in this current word. It is important to understand that we have to iterate through `res_counts` characters, not the `char_counts` characters. This is because we want to only update the characters that have been seen previously. If we iterate through every character in the current word, we might not have a character that was in the previous words, so we would skip characters that should actually be updated to have a count of 0 due to them not being present in the current word.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_counts = defaultdict(int)\\n        for char in words[0]:\\n            res_counts[char] += 1\\n\\n        for i in range(1, len(words)):\\n            word = words[i]\\n            char_counts = defaultdict(int)\\n            for char in word:\\n                char_counts[char] += 1\\n            for char in res_counts:\\n                res_counts[char] = min(res_counts[char], char_counts[char])\\n        \\n        res = []\\n        for char, char_count in res_counts.items():\\n            if char_count != 0:\\n                for i in range(char_count):\\n                    res.append(char)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_counts = defaultdict(int)\\n        for char in words[0]:\\n            res_counts[char] += 1\\n\\n        for i in range(1, len(words)):\\n            word = words[i]\\n            char_counts = defaultdict(int)\\n            for char in word:\\n                char_counts[char] += 1\\n            for char in res_counts:\\n                res_counts[char] = min(res_counts[char], char_counts[char])\\n        \\n        res = []\\n        for char, char_count in res_counts.items():\\n            if char_count != 0:\\n                for i in range(char_count):\\n                    res.append(char)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805284,
                "title": "java-find-common-characters",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        List<String> list=new ArrayList<>();\\n        char c[]=words[0].toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(isContains(c[i],words))\\n                list.add(String.valueOf(c[i]));\\n        }\\n        return list;\\n        \\n    }\\n    \\n    public static boolean isContains(char c1,String[] words){\\n        for(int i=1;i<words.length;i++){\\n            if(!words[i].contains(String.valueOf(c1)))return false;\\n            else words[i]=words[i].replaceFirst(String.valueOf(c1), \"@\");\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        \\n        List<String> list=new ArrayList<>();\\n        char c[]=words[0].toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(isContains(c[i],words))\\n                list.add(String.valueOf(c[i]));\\n        }\\n        return list;\\n        \\n    }\\n    \\n    public static boolean isContains(char c1,String[] words){\\n        for(int i=1;i<words.length;i++){\\n            if(!words[i].contains(String.valueOf(c1)))return false;\\n            else words[i]=words[i].replaceFirst(String.valueOf(c1), \"@\");\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788868,
                "title": "c-solution-hashmaps-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int>shared(26,INT_MAX);\\n        vector<string>ans;\\n        for(auto it:words)\\n        {\\n            vector<int>count(26,0);\\n            for(auto ut:it)\\n            {\\n                count[ut-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                shared[i]=min(shared[i],count[i]);\\n            }\\n        }\\n       for(int i=0;i<26;i++)\\n       {\\n           for(int j=0;j<shared[i];j++)\\n               ans.push_back(string(1,i+\\'a\\'));\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<int>shared(26,INT_MAX);\\n        vector<string>ans;\\n        for(auto it:words)\\n        {\\n            vector<int>count(26,0);\\n            for(auto ut:it)\\n            {\\n                count[ut-\\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2653444,
                "title": "c-95-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<string> commonChars(vector<string>& words) {\\n\\t\\tvector<int>util(26,INT_MAX);\\n\\t\\tfor(auto it:words){\\n\\t\\t\\tvector<int>v(26,0);\\n\\t\\t\\tfor(auto t:it) v[t-\\'a\\']++;\\n\\t\\t\\tfor(int i=0;i<26;i++) util[i] = min(util[i],v[i]);\\n\\t\\t}\\n\\t\\tvector<string>ans;\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\twhile(util[i]--) ans.push_back(string(1,i+\\'a\\'));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<string> commonChars(vector<string>& words) {\\n\\t\\tvector<int>util(26,INT_MAX);\\n\\t\\tfor(auto it:words){\\n\\t\\t\\tvector<int>v(26,0);\\n\\t\\t\\tfor(auto t:it) v[t-\\'a\\']++;\\n\\t\\t\\tfor(int i=0;i<26;i++) util[i] = min(util[i],v[i]);\\n\\t\\t}\\n\\t\\tvector<string>ans;\\n\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\twhile(util[i]--) ans.push_back(string(1,i+\\'a\\'));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573534,
                "title": "python",
                "content": "class Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        a=[x for x in words[0]]\\n        b=[]\\n        for i in a:\\n            s=0\\n            for j in range(1,len(words)):\\n                if i in words[j]:\\n                    c=[x for x in words[j]]\\n                    c.remove(i)\\n                    s=s+1\\n                    words[j]=\"\".join(c)\\n            if(s==len(words)-1):\\n                b.append(i)\\n        return b",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        a=[x for x in words[0]]\\n        b=[]\\n        for i in a:\\n            s=0\\n            for j in range(1,len(words)):\\n                if i in words[j]:\\n                    c=[x for x in words[j]]\\n                    c.remove(i)\\n                    s=s+1\\n                    words[j]=\"\".join(c)\\n            if(s==len(words)-1):\\n                b.append(i)\\n        return b",
                "codeTag": "Java"
            },
            {
                "id": 2560903,
                "title": "java-solution-stream-faster-than-100",
                "content": "```\\n    public List<String> commonChars(String[] words) {\\n        return Stream.of(words)\\n                .map(x -> {\\n                    int[] arr = new int[26];\\n                    for (char c : x.toCharArray()) arr[c - 97]++;\\n                    return arr;\\n                })\\n                .reduce((x1, x2) -> {\\n                    for (int i = 0; i < 26; i++) x1[i] = Math.min(x1[i], x2[i]);\\n                    return x1;\\n                })\\n                .map(x -> {\\n                    List<String> ans = new ArrayList<>();\\n                    for (int i = 0; i < x.length; i++)\\n                        for (int j = 0; j < x[i]; j++) ans.add(String.valueOf((char) (i + 97)));\\n                    return ans;\\n                }).get();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<String> commonChars(String[] words) {\\n        return Stream.of(words)\\n                .map(x -> {\\n                    int[] arr = new int[26];\\n                    for (char c : x.toCharArray()) arr[c - 97]++;\\n                    return arr;\\n                })\\n                .reduce((x1, x2) -> {\\n                    for (int i = 0; i < 26; i++) x1[i] = Math.min(x1[i], x2[i]);\\n                    return x1;\\n                })\\n                .map(x -> {\\n                    List<String> ans = new ArrayList<>();\\n                    for (int i = 0; i < x.length; i++)\\n                        for (int j = 0; j < x[i]; j++) ans.add(String.valueOf((char) (i + 97)));\\n                    return ans;\\n                }).get();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2543225,
                "title": "java-arraylist-string-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String str = words[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        if(words.length==1){\\n            for(int i=0;i<str.length();i++)\\n                list.add(Character.toString(str.charAt(i)));\\n            return list;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            String letter = Character.toString(str.charAt(i));\\n            int flag=1;\\n            for(int j=0;j<words.length;j++){\\n                if(words[j].contains(letter))\\n                    words[j]=words[j].replaceFirst(letter,\"\");\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n                flag=1;\\n            else\\n                list.add(letter);\\n        }\\n        return list;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String str = words[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        if(words.length==1){\\n            for(int i=0;i<str.length();i++)\\n                list.add(Character.toString(str.charAt(i)));\\n            return list;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            String letter = Character.toString(str.charAt(i));\\n            int flag=1;\\n            for(int j=0;j<words.length;j++){\\n                if(words[j].contains(letter))\\n                    words[j]=words[j].replaceFirst(letter,\"\");\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n                flag=1;\\n            else\\n                list.add(letter);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453727,
                "title": "easy-python-solution-91-5",
                "content": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        rt_dict = {}\\n        for c in set(words[0]):\\n            rt_dict[c] = min([word.count(c) for word in words])\\n        rt_list = []\\n        for key, value in rt_dict.items():\\n            if value > 0:\\n                for _ in range(value):\\n                    rt_list.append(key)\\n        return rt_list\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def commonChars(self, words):\\n        rt_dict = {}\\n        for c in set(words[0]):\\n            rt_dict[c] = min([word.count(c) for word in words])\\n        rt_list = []\\n        for key, value in rt_dict.items():\\n            if value > 0:\\n                for _ in range(value):\\n                    rt_list.append(key)\\n        return rt_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308263,
                "title": "a-c-naive-approach",
                "content": "```\\nclass Solution {\\n    string commom_of_two(string& v1, string& v2){\\n        string st = \"\";\\n        vector<string> v;\\n        int l1 = v1.length(), l2 = v2.length();\\n        unordered_map<char,int> m1,m2;\\n        for(auto& i : v1){\\n            m1[i]++;\\n        }\\n        for(auto& i : v2){\\n            m2[i]++;\\n        }\\n        if(m1.size() < m2.size()){\\n            for(auto& itr : m1){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        else{\\n            for(auto& itr : m2){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        return st;\\n    }\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> v;\\n        int l = words.size();\\n        string s = words[0];\\n        if(l>1){\\n            for(int i=1; i<l; ++i){\\n                s = commom_of_two(s,words[i]);\\n            }\\n        }\\n        for(auto& i : s){\\n            string t = \"\";\\n            v.push_back(t+i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    string commom_of_two(string& v1, string& v2){\\n        string st = \"\";\\n        vector<string> v;\\n        int l1 = v1.length(), l2 = v2.length();\\n        unordered_map<char,int> m1,m2;\\n        for(auto& i : v1){\\n            m1[i]++;\\n        }\\n        for(auto& i : v2){\\n            m2[i]++;\\n        }\\n        if(m1.size() < m2.size()){\\n            for(auto& itr : m1){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        else{\\n            for(auto& itr : m2){\\n                auto p = itr.first;\\n                if(m1[p] > 0 && m2[p] >0){\\n                    int num = min(m1[p],m2[p]);\\n                    for(int i=0; i<num; ++i){\\n                        string s = \"\";\\n                        st += p+s;\\n                    }\\n                }\\n            }\\n        }\\n        return st;\\n    }\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n        vector<string> v;\\n        int l = words.size();\\n        string s = words[0];\\n        if(l>1){\\n            for(int i=1; i<l; ++i){\\n                s = commom_of_two(s,words[i]);\\n            }\\n        }\\n        for(auto& i : s){\\n            string t = \"\";\\n            v.push_back(t+i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206972,
                "title": "javascript-solution-with-hash",
                "content": "```\\nvar commonChars = function(words) {\\n    let res = [];    \\n    let hash = hashWord(words[0]);    \\n    \\n    for(let i=1; i<words.length; i++) {\\n        let word = words[i];\\n        let tempHash = hashWord(word);                 \\n        merge(hash, tempHash);\\n    }\\n    \\n    for(let [letter, count] of Object.entries(hash)) {\\n        while(0 < count--) {\\n            res.push(letter);\\n        }                \\n    }\\n    \\n    return res;\\n};\\n\\nfunction hashWord(word) {\\n    let hash = {};\\n    for(let i=0; i<word.length; i++) {\\n        let letter = word[i];\\n        if( hash[letter] ){\\n            hash[letter]++;\\n        } else {\\n            hash[letter] = 1;\\n        }\\n    }    \\n    return hash;\\n}\\n\\nfunction merge(hash1, hash2) {  \\n    for(let letter of Object.keys(hash1)) {        \\n        if(!hash2[letter]) {\\n            delete hash1[letter];\\n        } else {\\n            hash1[letter] = Math.min(hash1[letter], hash2[letter]);            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar commonChars = function(words) {\\n    let res = [];    \\n    let hash = hashWord(words[0]);    \\n    \\n    for(let i=1; i<words.length; i++) {\\n        let word = words[i];\\n        let tempHash = hashWord(word);                 \\n        merge(hash, tempHash);\\n    }\\n    \\n    for(let [letter, count] of Object.entries(hash)) {\\n        while(0 < count--) {\\n            res.push(letter);\\n        }                \\n    }\\n    \\n    return res;\\n};\\n\\nfunction hashWord(word) {\\n    let hash = {};\\n    for(let i=0; i<word.length; i++) {\\n        let letter = word[i];\\n        if( hash[letter] ){\\n            hash[letter]++;\\n        } else {\\n            hash[letter] = 1;\\n        }\\n    }    \\n    return hash;\\n}\\n\\nfunction merge(hash1, hash2) {  \\n    for(let letter of Object.keys(hash1)) {        \\n        if(!hash2[letter]) {\\n            delete hash1[letter];\\n        } else {\\n            hash1[letter] = Math.min(hash1[letter], hash2[letter]);            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171936,
                "title": "very-interesting-solution-java",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n     \\n        int [] array=new int[26];\\n        Arrays.fill(array,Integer.MAX_VALUE);\\n        for(String str:words)\\n        {\\n            int [] res=new int[26];\\n            for(char ch:str.toCharArray())\\n            {\\n                res[ch-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                array[i]=Math.min(array[i],res[i]);\\n            }   \\n        }\\n        \\n        ArrayList<String> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            while(array[i]>0)\\n            {\\n                ans.add(\"\"+(char)(i+\\'a\\'));\\n                array[i]--;\\n            }\\n        }\\n        return ans;     \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n     \\n        int [] array=new int[26];\\n        Arrays.fill(array,Integer.MAX_VALUE);\\n        for(String str:words)\\n        {\\n            int [] res=new int[26];\\n            for(char ch:str.toCharArray())\\n            {\\n                res[ch-\\'a\\']++;\\n            }\\n            for(int i=0;i<26;i++)\\n            {\\n                array[i]=Math.min(array[i],res[i]);\\n            }   \\n        }\\n        \\n        ArrayList<String> ans=new ArrayList<>();\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            while(array[i]>0)\\n            {\\n                ans.add(\"\"+(char)(i+\\'a\\'));\\n                array[i]--;\\n            }\\n        }\\n        return ans;     \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071783,
                "title": "c-code-with-explanation",
                "content": "```\\n/*\\n\\tintuition : suppose in input we have -> words = [ \"aaa\" , \"aa\"  ,\"a\" ]\\n\\t\\t\\t    here just calculate the frequency of char \\'a\\' for every string and\\n\\t\\t\\t\\tstroe it in a vector and at the end we just calculate the minimun \\n\\t\\t\\t\\tfrequency of a .\\n*/\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n\\t    //to store the final output\\n        vector<string> ans;\\n        vector<int> freq1(26,INT_MAX); // to store final frequency of every char \\n\\n        for(auto word : words){\\n            vector<int> freq2(26,0); // for every iteration you need to store the every char\\'s freq of word.\\n            for(auto ch : word) freq2[ch-\\'a\\']++;\\n            for(int i=0;i<26;i++) freq1[i] = min(freq1[i],freq2[i]); // after that store the minimun freq\\n        }\\n        \\n\\t\\t\\n        for(int i=0;i<26;i++)\\n            if(freq1[i])\\n                while(freq1[i]--) ans.push_back(string(1, i + \\'a\\')); // converting the char to string\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tor you can convert a char to string in this way --\\n\\t\\t\\t\\t\\tchar c = i+97;\\n                    string str;\\n                    str.append(1,c);\\n                    ans.push_back(str);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tremember every char can be a string but every string can\\'t be char .\\n\\t\\t\\t\\t*/\\n       \\n        return ans;\\n    }\\n};\\n```\\n\\n**if you like please upvoat :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n\\tintuition : suppose in input we have -> words = [ \"aaa\" , \"aa\"  ,\"a\" ]\\n\\t\\t\\t    here just calculate the frequency of char \\'a\\' for every string and\\n\\t\\t\\t\\tstroe it in a vector and at the end we just calculate the minimun \\n\\t\\t\\t\\tfrequency of a .\\n*/\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) {\\n\\t    //to store the final output\\n        vector<string> ans;\\n        vector<int> freq1(26,INT_MAX); // to store final frequency of every char \\n\\n        for(auto word : words){\\n            vector<int> freq2(26,0); // for every iteration you need to store the every char\\'s freq of word.\\n            for(auto ch : word) freq2[ch-\\'a\\']++;\\n            for(int i=0;i<26;i++) freq1[i] = min(freq1[i],freq2[i]); // after that store the minimun freq\\n        }\\n        \\n\\t\\t\\n        for(int i=0;i<26;i++)\\n            if(freq1[i])\\n                while(freq1[i]--) ans.push_back(string(1, i + \\'a\\')); // converting the char to string\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tor you can convert a char to string in this way --\\n\\t\\t\\t\\t\\tchar c = i+97;\\n                    string str;\\n                    str.append(1,c);\\n                    ans.push_back(str);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tremember every char can be a string but every string can\\'t be char .\\n\\t\\t\\t\\t*/\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057778,
                "title": "simple-python-4-lines-solution-with-counter",
                "content": "Here is what I did.\\nA lot of shortcuts, but if they are in stdlib and you can implement each of them if needed then I guess it\\'s ok to use them: \\n\\n```python\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        ans = Counter(words[0])\\n        for i in range(1, len(words)):\\n            ans &= Counter(words[i])\\n        return ans.elements()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        ans = Counter(words[0])\\n        for i in range(1, len(words)):\\n            ans &= Counter(words[i])\\n        return ans.elements()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2042612,
                "title": "java-solution-using-2-hashmaps",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) \\n    {\\n        List<String> list=new ArrayList<>();\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(char c:words[0].toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            HashMap<Character,Integer> hmap2=new HashMap<>();\\n            for(char c:words[i].toCharArray())\\n                hmap2.put(c,hmap2.getOrDefault(c,0)+1);\\n            hmap.keySet().retainAll(hmap2.keySet());\\n            for(Character c:hmap.keySet())\\n            {\\n                if(hmap.get(c)!=hmap2.get(c))\\n                    hmap.put(c,Math.min(hmap.get(c),hmap2.get(c)));\\n            }\\n        }\\n        for(Character c:hmap.keySet())\\n        {\\n            if(hmap.get(c)!=1)\\n                for(int i=0;i<hmap.get(c)-1;i++)\\n                    list.add(String.valueOf(c));\\n            list.add(String.valueOf(c));\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> commonChars(String[] words) \\n    {\\n        List<String> list=new ArrayList<>();\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(char c:words[0].toCharArray())\\n            hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            HashMap<Character,Integer> hmap2=new HashMap<>();\\n            for(char c:words[i].toCharArray())\\n                hmap2.put(c,hmap2.getOrDefault(c,0)+1);\\n            hmap.keySet().retainAll(hmap2.keySet());\\n            for(Character c:hmap.keySet())\\n            {\\n                if(hmap.get(c)!=hmap2.get(c))\\n                    hmap.put(c,Math.min(hmap.get(c),hmap2.get(c)));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2006225,
                "title": "python-short-code-with-counter",
                "content": "\\tclass Solution:\\n\\t\\tdef commonChars(self, words: List[str]) -> List[str]:\\t\\n\\t\\t\\tmin_counter = collections.Counter(words[0])\\n        \\n\\t\\t\\tfor word in words[1:]:\\n\\t\\t\\t\\tword_counter = collections.Counter(word)\\n\\t\\t\\t\\tmin_counter = word_counter & min_counter\\n        \\n\\t\\t\\treturn list(min_counter.elements())\\n\\t\\t\\t\\n\\t\\t\\t\\nUsing first word to build initial Counter dictionary. Then going through all other words. Each time compare the min_counter with current word_counter, and using & to do intersection. For example, c = Counter(\\'a\\':3, \\'b\\':1), d = Counter(\\'a\\':1, \\'b\\':2), c & d is Counter({\\'a\\': 1, \\'b\\': 1}). Finally, using Counter.elements to return an iterator over elements repeating each as many times as its count.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef commonChars(self, words: List[str]) -> List[str]:\\t\\n\\t\\t\\tmin_counter = collections.Counter(words[0])\\n        \\n\\t\\t\\tfor word in words[1:]:\\n\\t\\t\\t\\tword_counter = collections.Counter(word)\\n\\t\\t\\t\\tmin_counter = word_counter & min_counter\\n        \\n\\t\\t\\treturn list(min_counter.elements())\\n\\t\\t\\t\\n\\t\\t\\t\\nUsing first word to build initial Counter dictionary. Then going through all other words. Each time compare the min_counter with current word_counter, and using & to do intersection. For example, c = Counter(\\'a\\':3, \\'b\\':1), d = Counter(\\'a\\':1, \\'b\\':2), c & d is Counter({\\'a\\': 1, \\'b\\': 1}",
                "codeTag": "Java"
            },
            {
                "id": 2000645,
                "title": "java-easy-to-undersatand",
                "content": "class Solution {\\n\\n    public List<String> commonChars(String[] words) {\\n        HashMap<Character,Integer> cmap =new HashMap<>();\\n        \\n        for(int i=0;i<words[0].length();i++){\\n            char ch = words[0].charAt(i);\\n            cmap.put(ch,cmap.getOrDefault(ch,0)+1);\\n        }\\n        for(int i =1;i<words.length;i++){\\n            String word = words[i];\\n            \\n            HashMap<Character,Integer> map =new HashMap<>();\\n            \\n            for(int j=0;j<word.length();j++){\\n                char ch = word.charAt(j);\\n                map.put(ch,map.getOrDefault(ch,0)+1);\\n            }\\n            HashMap<Character,Integer> map2 =new HashMap<>();\\n            for(char key : map.keySet()){\\n                if(cmap.containsKey(key)== true){\\n                    map2.put(key,Math.min(map.get(key),cmap.get(key)));\\n                }\\n            }\\n         \\n            cmap = map2;\\n        }\\n        List<String> res = new ArrayList<>();\\n        \\n        for(char key: cmap.keySet()){\\n            int frq = cmap.get(key);\\n            for(int i=0;i<frq;i++){\\n                res.add(\"\"+key);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public List<String> commonChars(String[] words) {\\n        HashMap<Character,Integer> cmap =new HashMap<>();\\n        \\n        for(int i=0;i<words[0].length();i++){\\n            char ch = words[0].charAt(i);\\n            cmap.put(ch,cmap.getOrDefault(ch,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1871865,
                "title": "java-beat-95",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(final String[] words) {\\n        final int[] current = new int[\\'z\\' - \\'a\\' + 1];\\n        final int[] result = new int[\\'z\\' - \\'a\\' + 1];\\n        for (final char ch: words[0].toCharArray()) {\\n            result[ch - \\'a\\']++;\\n        }\\n        for (int i=1; i<words.length; i++) {\\n            for (final char ch: words[i].toCharArray()) {\\n                final int index = ch - \\'a\\';\\n                current[index]++;\\n                \\n            }\\n            \\n            for (int j=0; j<result.length; j++) {\\n                result[j] = Math.min(result[j], current[j]);\\n                current[j] = 0;\\n            }\\n        }\\n        final List<String> resultList = new LinkedList<>();\\n        for (int i=0; i<result.length; i++) {\\n            while (result[i]-- > 0) {\\n                resultList.add(Character.toString(\\'a\\' + i));\\n            }\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(final String[] words) {\\n        final int[] current = new int[\\'z\\' - \\'a\\' + 1];\\n        final int[] result = new int[\\'z\\' - \\'a\\' + 1];\\n        for (final char ch: words[0].toCharArray()) {\\n            result[ch - \\'a\\']++;\\n        }\\n        for (int i=1; i<words.length; i++) {\\n            for (final char ch: words[i].toCharArray()) {\\n                final int index = ch - \\'a\\';\\n                current[index]++;\\n                \\n            }\\n            \\n            for (int j=0; j<result.length; j++) {\\n                result[j] = Math.min(result[j], current[j]);\\n                current[j] = 0;\\n            }\\n        }\\n        final List<String> resultList = new LinkedList<>();\\n        for (int i=0; i<result.length; i++) {\\n            while (result[i]-- > 0) {\\n                resultList.add(Character.toString(\\'a\\' + i));\\n            }\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861512,
                "title": "python-counter",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_dict = {elem:words[0].count(elem) for elem in words[0]}\\n        for elem in words[1:]:\\n            comp_dict = dict(Counter(elem))\\n            res_dict = {k: min(v, res_dict[k]) for k, v in comp_dict.items() if k in comp_dict and k in res_dict}\\n            \\n        \\n        res = []\\n        for k in res_dict:\\n            res.extend([k]*res_dict[k])\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        res_dict = {elem:words[0].count(elem) for elem in words[0]}\\n        for elem in words[1:]:\\n            comp_dict = dict(Counter(elem))\\n            res_dict = {k: min(v, res_dict[k]) for k, v in comp_dict.items() if k in comp_dict and k in res_dict}\\n            \\n        \\n        res = []\\n        for k in res_dict:\\n            res.extend([k]*res_dict[k])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818068,
                "title": "java-find-common-characters",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> li = new ArrayList<>();\\n        int n = words.length;\\n        String s = words[0];\\n        int count = 1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            count=1;\\n            for(int j=1;j<words.length;j++)\\n            {\\n                String str = words[j];\\n                for(int k=0;k<str.length();k++){\\n                if(ch==str.charAt(k)){\\n                  count++;\\n                  words[j] = str.substring(0,k)+\"\"+str.substring(k+1);\\n                  break;\\n                }\\n            }\\n            if(count==words.length)\\n                li.add(ch+\"\");\\n            }\\n        }\\n        return li;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> commonChars(String[] words) {\\n        List<String> li = new ArrayList<>();\\n        int n = words.length;\\n        String s = words[0];\\n        int count = 1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            count=1;\\n            for(int j=1;j<words.length;j++)\\n            {\\n                String str = words[j];\\n                for(int k=0;k<str.length();k++){\\n                if(ch==str.charAt(k)){\\n                  count++;\\n                  words[j] = str.substring(0,k)+\"\"+str.substring(k+1);\\n                  break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1807799,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n\\t\\t// count the frequency of each character for first word\\n        for (char ch : words[0].toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n\\t\\t// loop through the rest of words and compare with the first word\\n        for (int i = 1; i < words.length; i++) {\\n\\t\\t\\t// count the frequency of character to do comparison\\n            Map<Character, Integer> tempMap = new HashMap<>();\\n            for (char ch : words[i].toCharArray()) {\\n                tempMap.put(ch, tempMap.getOrDefault(ch, 0) + 1);\\n            }\\n            \\n\\t\\t\\t// if the character in first word is not in other words, then make it 0\\n\\t\\t\\t// else we put the min frequency\\n            for (Character ch : map.keySet()){\\n                if (!tempMap.containsKey(ch)) {\\n                    map.put(ch, 0);\\n                } else {\\n                    map.put(ch, Math.min(map.get(ch), tempMap.get(ch)));\\n                }\\n            }\\n        }\\n        \\n\\t\\t// last step is simply printing out the result\\n        List<String> result = new ArrayList<>();\\n        for (Character ch : map.keySet()) {\\n            int count = map.get(ch);\\n            while (count > 0) {\\n                result.add(String.valueOf(ch));\\n                count--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nN is num of words, M is the len of word\\nTime Complexity: O(N * M), worst case is words[0] has longest M and compare it with N - 1 words\\nSpace Complexity: O(M), two hashmaps",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n\\t\\t// count the frequency of each character for first word\\n        for (char ch : words[0].toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n\\t\\t// loop through the rest of words and compare with the first word\\n        for (int i = 1; i < words.length; i++) {\\n\\t\\t\\t// count the frequency of character to do comparison\\n            Map<Character, Integer> tempMap = new HashMap<>();\\n            for (char ch : words[i].toCharArray()) {\\n                tempMap.put(ch, tempMap.getOrDefault(ch, 0) + 1);\\n            }\\n            \\n\\t\\t\\t// if the character in first word is not in other words, then make it 0\\n\\t\\t\\t// else we put the min frequency\\n            for (Character ch : map.keySet()){\\n                if (!tempMap.containsKey(ch)) {\\n                    map.put(ch, 0);\\n                } else {\\n                    map.put(ch, Math.min(map.get(ch), tempMap.get(ch)));\\n                }\\n            }\\n        }\\n        \\n\\t\\t// last step is simply printing out the result\\n        List<String> result = new ArrayList<>();\\n        for (Character ch : map.keySet()) {\\n            int count = map.get(ch);\\n            while (count > 0) {\\n                result.add(String.valueOf(ch));\\n                count--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786865,
                "title": "easiest-solution-to-understand-time-0-ms-space-less-than-98-subs",
                "content": "**Please upvote if you liked my solution. It is always a great motivation to write more :)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) \\n    {\\n        int hash1[26] = {0};\\n        vector<string> result;\\n        \\n        for(int i=0; i<words[0].length(); i++)\\n            hash1[words[0][i]-\\'a\\']++;\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            int hash2[26] = {0};\\n            \\n            for(int j=0; j<words[i].length(); j++)\\n                hash2[words[i][j]-\\'a\\']++;\\n\\n            for(int j=0; j<26; j++)\\n                hash1[j] = min(hash1[j], hash2[j]);\\n        }\\n        \\n        for(int i=0; i<26; i++)\\n            if(hash1[i] != 0)\\n            {\\n                while(hash1[i]-- > 0)\\n                {\\n                    string temp1(1, i + \\'a\\');\\n                    result.push_back(temp1);   \\n                }\\n            }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> commonChars(vector<string>& words) \\n    {\\n        int hash1[26] = {0};\\n        vector<string> result;\\n        \\n        for(int i=0; i<words[0].length(); i++)\\n            hash1[words[0][i]-\\'a\\']++;\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            int hash2[26] = {0};\\n            \\n            for(int j=0; j<words[i].length(); j++)\\n                hash2[words[i][j]-\\'a\\']++;\\n\\n            for(int j=0; j<26; j++)\\n                hash1[j] = min(hash1[j], hash2[j]);\\n        }\\n        \\n        for(int i=0; i<26; i++)\\n            if(hash1[i] != 0)\\n            {\\n                while(hash1[i]-- > 0)\\n                {\\n                    string temp1(1, i + \\'a\\');\\n                    result.push_back(temp1);   \\n                }\\n            }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768841,
                "title": "python-3-lines-solution-with-counter-with-explanation",
                "content": "First we will import the class \\nthen we will take the first word into a temp variable\\nthen iterate the rest of the words and find the letters common in the two words and store as a dict\\nThen finally using another function of collections we will return the final dict as a list.\\n\\n```from collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        dict1 = words[0]\\n        for i in range(1,len(words)):\\n            dict1 = Counter(dict1) & Counter(words[i])\\n        return list(dict1.elements())\\n                \\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "First we will import the class \\nthen we will take the first word into a temp variable\\nthen iterate the rest of the words and find the letters common in the two words and store as a dict\\nThen finally using another function of collections we will return the final dict as a list.\\n\\n```from collections import Counter\\nclass Solution:\\n    def commonChars(self, words: List[str]) -> List[str]:\\n        dict1 = words[0]\\n        for i in range(1,len(words)):\\n            dict1 = Counter(dict1) & Counter(words[i])\\n        return list(dict1.elements())\\n                \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1683586,
                "title": "1ms-faster-than-100-with-explanation",
                "content": "Test Case - [\"bella\",\"label\",\"roller\"]\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] ar=countOccurances(A[0]);     //First get occurance array of 1st String\\n        //ar will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now we will be comparing 1st String\\'s countOccurance with 2nd, 3rd.. and so on, and will be getting the intersection also\\n        \\n        //Count Occurance of bella is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //Count Occurance of label is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //After Intersection it will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now Intersection will be compared with 3rd String\\'s Count Occurance and so on  \\n        for(int x=1; x<A.length; x++){\\n            ar=intersection(ar, countOccurances(A[x]));\\n        }\\n        //For the result we will have to print each repeating element by the nuber of time it repeats\\n        return result(ar);         \\n    }\\n    public static List<String> result(int[] ar){\\n        List<String> l=new ArrayList<>();\\n        for(int x=0; x<26; x++){\\n            while(ar[x]!=0){        //this is the case of \\'l\\' which repeats twice in every string so it needs to be printed twice \\n                l.add(String.valueOf( (char)(x+97) )); \\n                ar[x]=ar[x]-1;\\n            }\\n        }\\n        return l;\\n    }\\n    public static int[] intersection(int[]a, int[]b){\\n        int[] t=new int[26];\\n        for(int x=0; x<26; x++){\\n            t[x]=Math.min(a[x], b[x]);\\n        }\\n        return t;\\n    }\\n    public static int[] countOccurances(String a){\\n        int[] t=new int[26];\\n        for(char ch : a.toCharArray())\\n            t[ch - \\'a\\']++; \\n        // for(int x: t)\\n        //     System.out.print(x + \" \");\\n        // System.out.println();\\n        return t;\\n    }\\n}\\n```\\nPlease upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] A) {\\n        int[] ar=countOccurances(A[0]);     //First get occurance array of 1st String\\n        //ar will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now we will be comparing 1st String\\'s countOccurance with 2nd, 3rd.. and so on, and will be getting the intersection also\\n        \\n        //Count Occurance of bella is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //Count Occurance of label is   1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        //After Intersection it will be 1 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n        \\n        //Now Intersection will be compared with 3rd String\\'s Count Occurance and so on  \\n        for(int x=1; x<A.length; x++){\\n            ar=intersection(ar, countOccurances(A[x]));\\n        }\\n        //For the result we will have to print each repeating element by the nuber of time it repeats\\n        return result(ar);         \\n    }\\n    public static List<String> result(int[] ar){\\n        List<String> l=new ArrayList<>();\\n        for(int x=0; x<26; x++){\\n            while(ar[x]!=0){        //this is the case of \\'l\\' which repeats twice in every string so it needs to be printed twice \\n                l.add(String.valueOf( (char)(x+97) )); \\n                ar[x]=ar[x]-1;\\n            }\\n        }\\n        return l;\\n    }\\n    public static int[] intersection(int[]a, int[]b){\\n        int[] t=new int[26];\\n        for(int x=0; x<26; x++){\\n            t[x]=Math.min(a[x], b[x]);\\n        }\\n        return t;\\n    }\\n    public static int[] countOccurances(String a){\\n        int[] t=new int[26];\\n        for(char ch : a.toCharArray())\\n            t[ch - \\'a\\']++; \\n        // for(int x: t)\\n        //     System.out.print(x + \" \");\\n        // System.out.println();\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619166,
                "title": "simplest-approach-for-1002-find-common-characters",
                "content": "\\twhat you can do just iterate for all string and store all characters frequency in your string then find minimum frequency for that char then store in your ans vector\\n\\t\\n\\t\\n```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> commonChars(vector<string>& a) {\\n\\t\\t\\t\\t\\tvector<vector<int>> v(a.size(),vector<int> (30,0));\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<a.size();i++){\\n\\t\\t\\t\\t\\t\\tfor(auto &it:a[i]){\\n\\t\\t\\t\\t\\t\\t\\tint val = (int)(it -\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\tv[i][val]++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvector<string> ans;\\n\\t\\t\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\tint cnt=INT_MAX;\\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<a.size();j++){\\n\\t\\t\\t\\t\\t\\t\\tcnt=min(v[j][i],cnt);\\n\\t\\t\\t\\t\\t\\t\\t//cout<<v[j][i];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstring s = \"\";\\n\\t\\t\\t\\t\\t\\ts+=(i+\\'a\\');\\n\\t\\t\\t\\t\\t\\tfor(int l=0;l<cnt;l++){\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> commonChars(vector<string>& a) {\\n\\t\\t\\t\\t\\tvector<vector<int>> v(a.size(),vector<int> (30,0));\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<a.size();i++){\\n\\t\\t\\t\\t\\t\\tfor(auto &it:a[i]){\\n\\t\\t\\t\\t\\t\\t\\tint val = (int)(it -\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\tv[i][val]++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvector<string> ans;\\n\\t\\t\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\tint cnt=INT_MAX;\\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<a.size();j++){\\n\\t\\t\\t\\t\\t\\t\\tcnt=min(v[j][i],cnt);\\n\\t\\t\\t\\t\\t\\t\\t//cout<<v[j][i];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstring s = \"\";\\n\\t\\t\\t\\t\\t\\ts+=(i+\\'a\\');\\n\\t\\t\\t\\t\\t\\tfor(int l=0;l<cnt;l++){\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1606764,
                "title": "simple-java-code-using-array-and-ascii-key",
                "content": "```\\n public List<String> commonChars(String[] A) {\\n        \\n        \\n        ArrayList<String> result=new ArrayList<>();\\n        \\n        int[] min_frequency=new int[26];\\n        \\n        Arrays.fill(min_frequency, Integer.MAX_VALUE);\\n       \\n            \\n            \\n            for( String current: A)\\n            {\\n                int[] char_frequency=new int[26];\\n                \\n                \\n                for(char c: current.toCharArray())\\n                {\\n                    char_frequency[c-\\'a\\']++;\\n                    \\n                }\\n                \\n                for(int i=0; i<26; i++)\\n                {\\n                    min_frequency[i]=Math.min( min_frequency[i], char_frequency[i]);\\n                }\\n            }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            while(min_frequency[i]>0)\\n            {\\n                result.add(\"\"+(char)(i+\\'a\\'));\\n                 min_frequency[i]--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n public List<String> commonChars(String[] A) {\\n        \\n        \\n        ArrayList<String> result=new ArrayList<>();\\n        \\n        int[] min_frequency=new int[26];\\n        \\n        Arrays.fill(min_frequency, Integer.MAX_VALUE);\\n       \\n            \\n            \\n            for( String current: A)\\n            {\\n                int[] char_frequency=new int[26];\\n                \\n                \\n                for(char c: current.toCharArray())\\n                {\\n                    char_frequency[c-\\'a\\']++;\\n                    \\n                }\\n                \\n                for(int i=0; i<26; i++)\\n                {\\n                    min_frequency[i]=Math.min( min_frequency[i], char_frequency[i]);\\n                }\\n            }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            while(min_frequency[i]>0)\\n            {\\n                result.add(\"\"+(char)(i+\\'a\\'));\\n                 min_frequency[i]--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546010,
                "title": "simple-java-solution",
                "content": "```\\npublic List<String> commonChars(String[] words) {\\n\\tMap<String, Integer> map = new HashMap<>();\\n\\tfor(int j = 0; j < words[0].length(); j++){\\n\\t\\tString key = words[0].substring(j, j+1);\\n\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t}\\n\\tfor(int i = 1; i < words.length; i++){\\n\\t\\tMap<String, Integer> temp = new HashMap<>();\\n\\t\\tfor(int j = 0; j < words[i].length(); j++){\\n\\t\\t\\tString key = words[i].substring(j, j+1);\\n\\t\\t\\ttemp.put(key, temp.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\tmap = getCommon(map, temp);\\n\\t}\\n\\tList<String> list = new ArrayList<>();\\n\\tfor(Map.Entry<String, Integer> e : map.entrySet()){\\n\\t\\tint value = e.getValue();\\n\\t\\twhile(value > 0){\\n\\t\\t\\tlist.add(e.getKey());\\n\\t\\t\\tvalue--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn list;\\n}\\n\\n// This method will compare the 2 maps and will return a map having the common characters\\npublic Map<String, Integer> getCommon(Map<String, Integer> map1, Map<String, Integer> map2){\\n\\tMap<String, Integer> common = new HashMap<>();\\n\\tfor(Map.Entry<String, Integer> e : map1.entrySet()){\\n\\t\\tif(map2.containsKey(e.getKey())){\\n\\t\\t\\tcommon.put(e.getKey(), Math.min(e.getValue(), map2.get(e.getKey())));\\n\\t\\t}\\n\\t}\\n\\n\\treturn common;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> commonChars(String[] words) {\\n\\tMap<String, Integer> map = new HashMap<>();\\n\\tfor(int j = 0; j < words[0].length(); j++){\\n\\t\\tString key = words[0].substring(j, j+1);\\n\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t}\\n\\tfor(int i = 1; i < words.length; i++){\\n\\t\\tMap<String, Integer> temp = new HashMap<>();\\n\\t\\tfor(int j = 0; j < words[i].length(); j++){\\n\\t\\t\\tString key = words[i].substring(j, j+1);\\n\\t\\t\\ttemp.put(key, temp.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\tmap = getCommon(map, temp);\\n\\t}\\n\\tList<String> list = new ArrayList<>();\\n\\tfor(Map.Entry<String, Integer> e : map.entrySet()){\\n\\t\\tint value = e.getValue();\\n\\t\\twhile(value > 0){\\n\\t\\t\\tlist.add(e.getKey());\\n\\t\\t\\tvalue--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn list;\\n}\\n\\n// This method will compare the 2 maps and will return a map having the common characters\\npublic Map<String, Integer> getCommon(Map<String, Integer> map1, Map<String, Integer> map2){\\n\\tMap<String, Integer> common = new HashMap<>();\\n\\tfor(Map.Entry<String, Integer> e : map1.entrySet()){\\n\\t\\tif(map2.containsKey(e.getKey())){\\n\\t\\t\\tcommon.put(e.getKey(), Math.min(e.getValue(), map2.get(e.getKey())));\\n\\t\\t}\\n\\t}\\n\\n\\treturn common;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1476020,
                "title": "java-no-hashmap-inputs-appreciated",
                "content": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String firstWord = words[0]; //setting word to first word\\n        List<String> list = new ArrayList<>();\\n        for(char c:firstWord.toCharArray()) {\\n            for(int i = 0; i < words.length; i++) {\\n                if(!words[i].contains(Character.toString(c))) \\n                    break;\\n                else if(i == words.length - 1) \\n                    // if it got till here, it means that character was present in all\\n                    list.add(Character.toString(c));\\n                //Replacing character with star (for duplicates)\\n                StringBuilder string = new StringBuilder(words[i]);\\n                string.setCharAt(words[i].indexOf(c), \\'*\\');\\n                words[i] = string.toString();\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n        String firstWord = words[0]; //setting word to first word\\n        List<String> list = new ArrayList<>();\\n        for(char c:firstWord.toCharArray()) {\\n            for(int i = 0; i < words.length; i++) {\\n                if(!words[i].contains(Character.toString(c))) \\n                    break;\\n                else if(i == words.length - 1) \\n                    // if it got till here, it means that character was present in all\\n                    list.add(Character.toString(c));\\n                //Replacing character with star (for duplicates)\\n                StringBuilder string = new StringBuilder(words[i]);\\n                string.setCharAt(words[i].indexOf(c), \\'*\\');\\n                words[i] = string.toString();\\n            }\\n        }\\n        return list;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405684,
                "title": "easy-java-solution",
                "content": "\\t\\t\\t\\t\\n```\\n    public List<String> commonChars(String[] words) {\\n        int[][] characters = new int[words.length][26];\\n        for(int i = 0; i<words[0].length(); i++){\\n            characters[0][words[0].charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 1; i<words.length; i++){\\n            int[] array = characters[i - 1];\\n            for(char ch: words[i].toCharArray()){\\n                if(array[ch - \\'a\\'] > 0){\\n                    characters[i][ch - \\'a\\']++;\\n                    array[ch - \\'a\\']--;\\n                }\\n            }\\n        }\\n        List<String> answer = new ArrayList<>();\\n        for(int i = 0; i<26; i++){\\n            while(characters[words.length - 1][i]-- > 0){\\n                answer.add(String.valueOf((char)(i + \\'a\\')));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> commonChars(String[] words) {\\n        int[][] characters = new int[words.length][26];\\n        for(int i = 0; i<words[0].length(); i++){\\n            characters[0][words[0].charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 1; i<words.length; i++){\\n            int[] array = characters[i - 1];\\n            for(char ch: words[i].toCharArray()){\\n                if(array[ch - \\'a\\'] > 0){\\n                    characters[i][ch - \\'a\\']++;\\n                    array[ch - \\'a\\']--;\\n                }\\n            }\\n        }\\n        List<String> answer = new ArrayList<>();\\n        for(int i = 0; i<26; i++){\\n            while(characters[words.length - 1][i]-- > 0){\\n                answer.add(String.valueOf((char)(i + \\'a\\')));\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1381570,
                "title": "dynamic-programming-approach",
                "content": "\\t # dynamic programming\\n\\t\\tdp = [[]] * len(words)\\n\\t\\tdp[0] = words[0]\\n\\t\\t\\n        for i in range(1, len(words)):\\n            dp[i-1] = Counter(dp[i-1])\\n            chars = []\\n            for char in words[i]:\\n                if char in dp[i-1] and dp[i-1][char] > 0:\\n                    chars.append(char)\\n                    dp[i-1][char] -= 1\\n                dp[i] = chars\\n                \\n        return dp[-1]\\n        \\nThe logic is to use the common characters in the previous element, and extract the common character for the current element, at the end return the last item of the dp",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\t # dynamic programming\\n\\t\\tdp = [[]] * len(words)\\n\\t\\tdp[0] = words[0]\\n\\t\\t\\n        for i in range(1, len(words)):\\n            dp[i-1] = Counter(dp[i-1])\\n            chars = []\\n            for char in words[i]:\\n                if char in dp[i-1] and dp[i-1][char] > 0:\\n                    chars.append(char)\\n                    dp[i-1][char] -= 1\\n                dp[i] = chars\\n                \\n        return dp[-1]\\n        \\nThe logic is to use the common characters in the previous element, and extract the common character for the current element, at the end return the last item of the dp",
                "codeTag": "Unknown"
            },
            {
                "id": 1316906,
                "title": "simple-and-easy-c-approach-using-maps",
                "content": "```\\n vector<string> commonChars(vector<string>& words) {\\n        vector<string> ans;\\n        \\n        map<char,int> mp;\\n        \\n       for(int i=0;i<words[0].size();i++){\\n           mp[words[0][i]]++;\\n       }\\n\\n        \\n        for(int i=1;i<words.size();i++){\\n            map<char,int>  mp1;\\n            \\n            for(int j=0;j<words[i].size();j++){\\n                mp1[words[i][j]]++;\\n            }\\n            \\n            for(auto x: mp){\\n                if(mp1.find(x.first)!=mp.end()){\\n                    \\n                    if(mp1[x.first]!=x.second){\\n                     \\n                        mp[x.first]=min(x.second, mp1[x.first]);\\n                    }\\n                }\\n                else{\\n                     mp.erase(mp.find(x.first));\\n                }\\n            }\\n         \\n         \\n        }\\n\\n            for(auto x: mp){\\n                while(x.second--){\\n                    string s(1, x.first);\\n                    ans.push_back(s);\\n                }\\n                \\n            }\\n            \\n           return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<string> commonChars(vector<string>& words) {\\n        vector<string> ans;\\n        \\n        map<char,int> mp;\\n        \\n       for(int i=0;i<words[0].size();i++){\\n           mp[words[0][i]]++;\\n       }\\n\\n        \\n        for(int i=1;i<words.size();i++){\\n            map<char,int>  mp1;\\n            \\n            for(int j=0;j<words[i].size();j++){\\n                mp1[words[i][j]]++;\\n            }\\n            \\n            for(auto x: mp){\\n                if(mp1.find(x.first)!=mp.end()){\\n                    \\n                    if(mp1[x.first]!=x.second){\\n                     \\n                        mp[x.first]=min(x.second, mp1[x.first]);\\n                    }\\n                }\\n                else{\\n                     mp.erase(mp.find(x.first));\\n                }\\n            }\\n         \\n         \\n        }\\n\\n            for(auto x: mp){\\n                while(x.second--){\\n                    string s(1, x.first);\\n                    ans.push_back(s);\\n                }\\n                \\n            }\\n            \\n           return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1278939,
                "title": "java-most-easy-solution-5ms",
                "content": "```\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n\\n        for (char c : words[0].toCharArray()) {\\n            boolean isCommon = true;\\n            for (int i = 1; i < words.length; i++) {\\n                if (words[i].indexOf(c) == -1) {\\n                    isCommon = false;\\n                    break;\\n                }\\n            }\\n            if (isCommon) {\\n                result.add(String.valueOf(c));\\n                for (int i = 1; i < words.length; i++) {\\n                    StringBuilder sb = new StringBuilder(words[i]);\\n                    sb.deleteCharAt(words[i].indexOf(c));\\n                    words[i] = sb.toString();\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> commonChars(String[] words) {\\n        List<String> result = new ArrayList<>();\\n\\n        for (char c : words[0].toCharArray()) {\\n            boolean isCommon = true;\\n            for (int i = 1; i < words.length; i++) {\\n                if (words[i].indexOf(c) == -1) {\\n                    isCommon = false;\\n                    break;\\n                }\\n            }\\n            if (isCommon) {\\n                result.add(String.valueOf(c));\\n                for (int i = 1; i < words.length; i++) {\\n                    StringBuilder sb = new StringBuilder(words[i]);\\n                    sb.deleteCharAt(words[i].indexOf(c));\\n                    words[i] = sb.toString();\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1930540,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1834515,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1948693,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1997766,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999640,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2035727,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999711,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1988614,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2053054,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1873594,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1930540,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1834515,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1948693,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1997766,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999640,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2035727,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1999711,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1988614,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 2053054,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            },
            {
                "id": 1873594,
                "content": [
                    {
                        "username": "rwatso",
                        "content": "How in bloody hell is this considered easy? Especially when there are easy problems where the solution is literally one if check and a counter. LC difficulty rankings are basically useless, but I think most people have figured that out."
                    },
                    {
                        "username": "woodstea",
                        "content": "This is the first random easy challenge I\\'ve tried after the ones in the Beginner\\'s Guide. Took me a couple hours+. I guess I have a long way to go."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how it could be an easy problem ???????"
                    },
                    {
                        "username": "viess009",
                        "content": "This is the hardest easy problem that I have ever done"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "When you start with Hoping You can solve easy ones and getting stuck in a medium problem as beginner :-)"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "this easy is hard for me."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "hardest easy problem"
                    },
                    {
                        "username": "singhhemant233",
                        "content": "This is the easiest question i have ever seen in my life "
                    },
                    {
                        "username": "sk315425",
                        "content": "Easy Problem :( ?"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Do not forget to count the number of repetitions of a character in the strings."
                    }
                ]
            }
        ]
    }
]