[
    {
        "title": "Minimum Deletions to Make Array Divisible",
        "question_content": "You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\nReturn the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\nNote that an integer x divides y if y % x == 0.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\nOutput: 2\nExplanation: \nThe smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\nThe smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed.\n\nExample 2:\n\nInput: nums = [4,3,6], numsDivide = [8,2,6,10]\nOutput: -1\nExplanation: \nWe want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this.\n&nbsp;\nConstraints:\n\n\t1 <= nums.length, numsDivide.length <= 105\n\t1 <= nums[i], numsDivide[i] <= 109",
        "solutions": [
            {
                "id": 2292651,
                "title": "java-c-python-gcd-o-n-m-log",
                "content": "# **Explanation**\\n\"divides all the elements of numsDivide\"\\nequals to\\n\"divides gcd of all the elements of numsDivide\"\\nwhere gcd is the greatest common divisor.\\n\\nSo the first step, find out the gcd of `numsDivide`,\\nthen sort input nums `A`,\\nand find out the smallest element `A[i]` in `A` divides `gcd`.\\n\\nWe need to remove all elements smaller than `A[i]`.\\nIf no such `A[i]`, return `-1`\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn + m + gcd)`, where `gcd = log(max(numsDivide)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minOperations(int[] A, int[] numsDivide) {\\n        int g = numsDivide[0], tmp;\\n        for (int a : numsDivide) {\\n            while (a > 0) { // g = gcd(g, a)\\n                tmp = g % a;\\n                g = a;\\n                a = tmp;\\n            }\\n        }\\n        Arrays.sort(A);\\n        for (int i = 0; i < A.length && A[i] <= g; ++i)\\n            if (g % A[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minOperations(vector<int>& A, vector<int>& numsDivide) {\\n        int g = numsDivide[0];\\n        for (int a: numsDivide)\\n            g = gcd(g, a);\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < A.size() && A[i] <= g; ++i)\\n            if (g % A[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        for i,a in enumerate(sorted(A)):\\n            if g % a == 0: return i\\n            if a > g: break\\n        return -1\\n```\\nCompressed version\\n```py\\n    def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        return next((i for i,a in enumerate(sorted(A)) if g % a == 0), -1)\\n```\\n<br>\\n\\n# Solution 2: Slight improvement\\nImprove from `O(nlogn)` to `O(n)`\\n\\nExplanation from @k_r_h_ise:\\nthe optimisation is done by not sorting the nums array.\\nInstead, we iterate it twice.\\n\\nfirst iteration\\uFF1A\\nfind the smallest element that divides the `gcd_of_all(numsDivide)`.\\nlet\\'s call it `min_divisor`.\\n\\nsecond iteration\\uFF1A\\ncount no. of elements that are smaller than the min_divisor.\\nlet\\'s call it `small_cnt`.\\n\\nNow if `small_cnt == size_of_num` return `-1` else return `small_cnt`\\n\\n\\nTime `O(n + m + gcd)`, where `gcd = log(max(numsDivide)`\\nSpace `O(1)`\\n\\n```py\\n    def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        small = min((a for a in A if g % a == 0), default = 0)\\n        return sum(a < small for a in A) if small else -1\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minOperations(int[] A, int[] numsDivide) {\\n        int g = numsDivide[0], tmp;\\n        for (int a : numsDivide) {\\n            while (a > 0) { // g = gcd(g, a)\\n                tmp = g % a;\\n                g = a;\\n                a = tmp;\\n            }\\n        }\\n        Arrays.sort(A);\\n        for (int i = 0; i < A.length && A[i] <= g; ++i)\\n            if (g % A[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```\n```cpp\\n    int minOperations(vector<int>& A, vector<int>& numsDivide) {\\n        int g = numsDivide[0];\\n        for (int a: numsDivide)\\n            g = gcd(g, a);\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < A.size() && A[i] <= g; ++i)\\n            if (g % A[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```\n```py\\n    def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        for i,a in enumerate(sorted(A)):\\n            if g % a == 0: return i\\n            if a > g: break\\n        return -1\\n```\n```py\\n    def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        return next((i for i,a in enumerate(sorted(A)) if g % a == 0), -1)\\n```\n```py\\n    def minOperations(self, A: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        small = min((a for a in A if g % a == 0), default = 0)\\n        return sum(a < small for a in A) if small else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2292612,
                "title": "gcd",
                "content": "We compute GCD among all numbers to divide. \\n- GCD divides all those numbers, and it\\'s the largest possible one.\\n\\nThen, we find the smallest element that can divide that GCD.\\n\\n> It\\'s easy to just sort the numbers; we can also avoid sort (see the no-sort solution below).\\n\\nThe reasoning can be easily proven using a contradiction.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], divs: List[int]) -> int:\\n        div = reduce(gcd, divs)\\n        return next((i for i, n in enumerate(sorted(nums)) if div % n == 0), -1)\\n```\\n\\n**Java**\\n```java\\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\\npublic int minOperations(int[] nums, int[] divs) {\\n    Arrays.sort(nums);\\n    int div = Arrays.stream(divs).reduce((a, b) -> gcd(a, b)).getAsInt();\\n    for (int i = 0; i < nums.length; ++i)\\n        if (div % nums[i] == 0)\\n            return i;\\n    return -1;\\n}\\n```\\n**C++**\\n```cpp\\nint minOperations(vector<int>& nums, vector<int>& divs) {\\n    sort(begin(nums), end(nums));\\n    int div = reduce(begin(divs), end(divs), divs[0], [](int a, int b){ return gcd(a, b); });\\n    for (int i = 0; i < nums.size(); ++i)\\n        if (div % nums[i] == 0)\\n            return i;\\n    return -1;\\n}\\n```\\n#### No-Sort\\n**Python 3**\\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], divs: List[int]) -> int:\\n        div = reduce(gcd, divs)\\n        mn = min(filter(lambda n: div % n == 0, nums), default = -1)\\n        return -1 if mn == -1 else sum (n < mn for n in nums)\\n```\\n**C++**\\n```cpp\\nint minOperations(vector<int>& nums, vector<int>& divs) {\\n    int div = reduce(begin(divs), end(divs), divs[0], [](int a, int b){ return gcd(a, b); });\\n    int mn = INT_MAX;\\n    for (int n : nums)\\n        mn = min(mn, div % n == 0 ? n : INT_MAX);\\n    return mn == INT_MAX ? -1 : count_if(begin(nums), end(nums), [&](int n){ return n < mn; });\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], divs: List[int]) -> int:\\n        div = reduce(gcd, divs)\\n        return next((i for i, n in enumerate(sorted(nums)) if div % n == 0), -1)\\n```\n```java\\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\\npublic int minOperations(int[] nums, int[] divs) {\\n    Arrays.sort(nums);\\n    int div = Arrays.stream(divs).reduce((a, b) -> gcd(a, b)).getAsInt();\\n    for (int i = 0; i < nums.length; ++i)\\n        if (div % nums[i] == 0)\\n            return i;\\n    return -1;\\n}\\n```\n```cpp\\nint minOperations(vector<int>& nums, vector<int>& divs) {\\n    sort(begin(nums), end(nums));\\n    int div = reduce(begin(divs), end(divs), divs[0], [](int a, int b){ return gcd(a, b); });\\n    for (int i = 0; i < nums.size(); ++i)\\n        if (div % nums[i] == 0)\\n            return i;\\n    return -1;\\n}\\n```\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], divs: List[int]) -> int:\\n        div = reduce(gcd, divs)\\n        mn = min(filter(lambda n: div % n == 0, nums), default = -1)\\n        return -1 if mn == -1 else sum (n < mn for n in nums)\\n```\n```cpp\\nint minOperations(vector<int>& nums, vector<int>& divs) {\\n    int div = reduce(begin(divs), end(divs), divs[0], [](int a, int b){ return gcd(a, b); });\\n    int mn = INT_MAX;\\n    for (int n : nums)\\n        mn = min(mn, div % n == 0 ? n : INT_MAX);\\n    return mn == INT_MAX ? -1 : count_if(begin(nums), end(nums), [&](int n){ return n < mn; });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292543,
                "title": "c-java-python3-gcd-explained-and-sorting",
                "content": "\\n\\n**Explanation**\\n\\n* We use `Euclidean algorithm` to find gcd of numsDivide and store it in variable `g`. `Euclidean algorithm` calculates the gcd of 2 numbers in `O(log(min(a, b)))`\\n* Sort `nums`\\n* If `g % x == 0` where `x` is a number in `nums` then return index of x in `sorted(nums)` because this number can divide the whole of `numsDivide`\\n\\n<iframe src=\"https://leetcode.com/playground/cAxTNvGK/shared\" frameBorder=\"0\" width=\"560\" height=\"230\"></iframe>\\n\\n**About the euclidean algorithm**:\\n* The Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number. \\n* For example, 21 is the GCD of 252 and 105 (as 252 = 21 \\xD7 12 and 105 = 21 \\xD7 5), and the same number 21 is also the GCD of 105 and 252 \\u2212 105 = 147. \\n* Since this replacement reduces the larger of the two numbers, repeating this process gives successively smaller pairs of numbers until the two numbers become equal. When that occurs, they are the GCD of the original two numbers.\\n* Continued example:\\n```\\n252 105\\n147 105\\n105 42\\n63 42\\n42 21\\n21 21 -> GCD\\n```\\n* Instead of repeated subtraction we can use modulus operator to make this process faster.\\n* This is the recursive euclidean algorithm with modulus operator:\\n```\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n        return b;\\n    return gcd(b % a, a);\\n}\\n```\\n* Continued example:\\n```\\n252 105\\n105 252\\n42 105\\n21 42\\n0 21\\n```",
                "solutionTags": [],
                "code": "```\\n252 105\\n147 105\\n105 42\\n63 42\\n42 21\\n21 21 -> GCD\\n```\n```\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n        return b;\\n    return gcd(b % a, a);\\n}\\n```\n```\\n252 105\\n105 252\\n42 105\\n21 42\\n0 21\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292645,
                "title": "c-simple-gcd-priority-queue-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int c = 0; // count\\n        priority_queue<int,vector<int>,greater<int>> pq; /// min heap\\n        int op = numsDivide[0];\\n        int n = numsDivide.size();\\n        for(int i = 1;i < n;i++){\\n            op = __gcd(op,numsDivide[i]); // as it will be the maximum number that will divide all the numbers \\n        }\\n        for(auto&i : nums){\\n            pq.push(i); // pushing all elements in the heap\\n        } \\n        while(!pq.empty()){ \\n            int temp = pq.top();\\n            pq.pop();\\n            if(op%temp == 0){ // if the minimum element divides the gcd return count at that time\\n                return c;\\n            }\\n            if(temp > op){ // if pq top become bigger than the find gcd then it returns -1\\n                return -1;\\n            }\\n            c++;\\n            \\n        }\\n        return -1; // means the heap got empty and no element divide the numsDivide array\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int c = 0; // count\\n        priority_queue<int,vector<int>,greater<int>> pq; /// min heap\\n        int op = numsDivide[0];\\n        int n = numsDivide.size();\\n        for(int i = 1;i < n;i++){\\n            op = __gcd(op,numsDivide[i]); // as it will be the maximum number that will divide all the numbers \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2292773,
                "title": "java-python-3-2-methods-about-gcd-w-brief-explanation-and-analysis",
                "content": "\"divide all numbers in `numsDivide`\"  implies \"divide the gcd of `numsDivide`\". Therefore, we can design an algorithm as follows:\\n\\n----\\n\\n**Method 1:**\\n1. Compute the gcd of `numsDivide`;\\n2. Traverse `nums` to find the smallest number that can divide the gcd;; If fails, return -1\\n3. Traverse `nums` to count how many numbers are less than the afore-mentioned smallest number.\\n\\n```java\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g = IntStream.of(numsDivide).reduce(numsDivide[0], (a, b) -> gcd(a, b));\\n        int minOp = 0, smallest = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (g % num == 0) {\\n                smallest = Math.min(smallest, num);\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num < smallest) {\\n                ++minOp;\\n            }\\n        }\\n        return smallest == Integer.MAX_VALUE ? -1 : minOp;\\n    }\\n    private int gcd(int a, int b) {\\n        while (b > 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n```\\n\\n```python\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        def gcd(a, b) -> int:\\n            while b > 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        g = functools.reduce(gcd, numsDivide)\\n        smallest = min([num for num in nums if g % num == 0], default = inf)\\n        return -1 if smallest == inf else sum(smallest > num for num in nums)\\n```\\n\\n**Analysis:**\\n\\nTime: `O(m + n + log(max(numsDivide)))`, \\nspace: Java code - `O(1)`, Python 3 code -`O(m)`, where `m = nums.length, n = numsDivide.length`.\\n\\n----\\n\\n\\n\\n**Method 2: Sort**\\n\\n *Sort nums:*\\n \\n1. Compute the gcd of `numsDivide`;\\n2. Sort `nums`;\\n3. Traverse `nums` to check one by one till locating the smallest number that can divide the gcd; If fails, return -1.\\n\\n\\n\\n```java\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g = IntStream.of(numsDivide).reduce(numsDivide[0], (a, b) -> gcd(a, b));\\n        int minOp = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (g % nums[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    private int gcd(int a, int b) {\\n        while (b > 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n```\\n```python\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        def gcd(a, b) -> int:\\n            while b > 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        g = functools.reduce(gcd, numsDivide)\\n        nums.sort()\\n        for i, num in enumerate(nums):\\n            if g % num == 0:\\n                return i \\n        return -1\\n```\\n\\n----\\n\\n**Use TreeMap**\\n\\n```java\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g = numsDivide[0];\\n        for (int n : numsDivide) {\\n            g = gcd(g, n);\\n        }\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        for (int num : nums) {\\n            cnt.merge(num, 1, Integer::sum);\\n        }\\n        int minOp = 0;\\n        for (var entry : cnt.entrySet()) {\\n            if (g % entry.getKey() == 0) {\\n                return minOp;\\n            }\\n            minOp += entry.getValue();\\n        }\\n        return -1;\\n    }\\n    private int gcd(int a, int b) {\\n        while (b > 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n```\\n\\n```python\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        def gcd(a, b) -> int:\\n            while b > 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        g = reduce(gcd, numsDivide)\\n        cnt = Counter(nums)\\n        min_op = 0\\n        for c in sorted(cnt):\\n            if g % c == 0:\\n                return min_op\\n            min_op += cnt[c]\\n        return -1\\n```\\n\\n**Analysis:**\\n\\nTime: `O(m * logm + n + log(max(numsDivide)))`, space: `O(m)` - including sorting space, where `m = nums.length, n = numsDivide.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g = IntStream.of(numsDivide).reduce(numsDivide[0], (a, b) -> gcd(a, b));\\n        int minOp = 0, smallest = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (g % num == 0) {\\n                smallest = Math.min(smallest, num);\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num < smallest) {\\n                ++minOp;\\n            }\\n        }\\n        return smallest == Integer.MAX_VALUE ? -1 : minOp;\\n    }\\n    private int gcd(int a, int b) {\\n        while (b > 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n```\n```python\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        def gcd(a, b) -> int:\\n            while b > 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        g = functools.reduce(gcd, numsDivide)\\n        smallest = min([num for num in nums if g % num == 0], default = inf)\\n        return -1 if smallest == inf else sum(smallest > num for num in nums)\\n```\n```java\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g = IntStream.of(numsDivide).reduce(numsDivide[0], (a, b) -> gcd(a, b));\\n        int minOp = 0;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (g % nums[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    private int gcd(int a, int b) {\\n        while (b > 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n```\n```python\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        def gcd(a, b) -> int:\\n            while b > 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        g = functools.reduce(gcd, numsDivide)\\n        nums.sort()\\n        for i, num in enumerate(nums):\\n            if g % num == 0:\\n                return i \\n        return -1\\n```\n```java\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g = numsDivide[0];\\n        for (int n : numsDivide) {\\n            g = gcd(g, n);\\n        }\\n        TreeMap<Integer, Integer> cnt = new TreeMap<>();\\n        for (int num : nums) {\\n            cnt.merge(num, 1, Integer::sum);\\n        }\\n        int minOp = 0;\\n        for (var entry : cnt.entrySet()) {\\n            if (g % entry.getKey() == 0) {\\n                return minOp;\\n            }\\n            minOp += entry.getValue();\\n        }\\n        return -1;\\n    }\\n    private int gcd(int a, int b) {\\n        while (b > 0) {\\n            int tmp = a;\\n            a = b;\\n            b = tmp % b;\\n        }\\n        return a;\\n    }\\n```\n```python\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        def gcd(a, b) -> int:\\n            while b > 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        g = reduce(gcd, numsDivide)\\n        cnt = Counter(nums)\\n        min_op = 0\\n        for c in sorted(cnt):\\n            if g % c == 0:\\n                return min_op\\n            min_op += cnt[c]\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2292555,
                "title": "c-short-and-easy-with-math",
                "content": "### Intuition\\nIf a number is divisible by the numbers in `numsDivide` then it must be **divisible by the greatest common divisor** of all the numbers in `numsDivide`\\nThen we just need to find the smallest number satisfying this condition\\n\\n\\n### Complexity\\nTime `O(nLogn + m)` where `n` is size of `nums` and `m` is size of `numsDivide`\\nSpace `O(1)`\\n\\n```C++\\nclass Solution {\\npublic:\\n    int minOperations(vector<int> &nums, vector<int> &numsDivide) {\\n        int gcd = numsDivide[0];\\n        for (int i = 1; i < numsDivide.size(); ++i)\\n            gcd = std::__gcd(gcd, numsDivide[i]);\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size(); i++)\\n            if (gcd % nums[i] == 0) return i;\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minOperations(vector<int> &nums, vector<int> &numsDivide) {\\n        int gcd = numsDivide[0];\\n        for (int i = 1; i < numsDivide.size(); ++i)\\n            gcd = std::__gcd(gcd, numsDivide[i]);\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < nums.size(); i++)\\n            if (gcd % nums[i] == 0) return i;\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292781,
                "title": "gcd-and-sorting",
                "content": "**Aproach**\\n* Find the gcd of all numsDivide, which will give the maximum number which can dvide all the numbers in numsDivide.\\n* Find all the factors of above gcd as these numbers can also dvide all numbers in numsDivide.\\n* Sort nums and the factors array.\\n* Start iterating from the begining of the sorted factor array and find the index of this element in sorted nums array, and keep track of how many elements you deleted, if you find the number return its index as answer as the number of elements previous to this number need to be deleted.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gc = numsDivide[0], n = nums.size(), del = 0;\\n        for (int &a: numsDivide) gc = __gcd(gc, a);\\n        sort(nums.begin(), nums.end());\\n        vector<int> data;\\n        \\n        for (int i = 1; i * i <= gc; i++)\\n            if (gc % i == 0)\\n                data.push_back(i), data.push_back(gc / i);\\n        \\n        sort(data.begin(), data.end());\\n        \\n        for (int &a: data) {\\n            while (del < n && nums[del] < a)\\n                del++;\\n            \\n            if (del < n && nums[del] == a)\\n                return del;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc = numsDivide[0]\\n        deleted = 0\\n        n = len(nums)\\n        \\n        for num in numsDivide:\\n            gc = math.gcd(num, gc)\\n        \\n        nums.sort()\\n        factors = []\\n        factor = 1\\n        \\n        while factor * factor <= gc:\\n            if gc % factor == 0:\\n                factors.append(factor)\\n                factors.append(gc // factor)\\n            \\n            factor += 1\\n        \\n        factors.sort()\\n        \\n        for num in factors:\\n            while deleted < n and nums[deleted] < num:\\n                deleted += 1\\n            \\n            if deleted < n and nums[deleted] == num:\\n                return deleted\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gc = numsDivide[0], n = nums.size(), del = 0;\\n        for (int &a: numsDivide) gc = __gcd(gc, a);\\n        sort(nums.begin(), nums.end());\\n        vector<int> data;\\n        \\n        for (int i = 1; i * i <= gc; i++)\\n            if (gc % i == 0)\\n                data.push_back(i), data.push_back(gc / i);\\n        \\n        sort(data.begin(), data.end());\\n        \\n        for (int &a: data) {\\n            while (del < n && nums[del] < a)\\n                del++;\\n            \\n            if (del < n && nums[del] == a)\\n                return del;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc = numsDivide[0]\\n        deleted = 0\\n        n = len(nums)\\n        \\n        for num in numsDivide:\\n            gc = math.gcd(num, gc)\\n        \\n        nums.sort()\\n        factors = []\\n        factor = 1\\n        \\n        while factor * factor <= gc:\\n            if gc % factor == 0:\\n                factors.append(factor)\\n                factors.append(gc // factor)\\n            \\n            factor += 1\\n        \\n        factors.sort()\\n        \\n        for num in factors:\\n            while deleted < n and nums[deleted] < num:\\n                deleted += 1\\n            \\n            if deleted < n and nums[deleted] == num:\\n                return deleted\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177139,
                "title": "c-gcd-very-short-and-easy-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLittle bit of maths here we have to think how can we check whole numsDivide array is divisible by a number  without traversing whole numsDivide array and checking one by one each element is divisibel by nums[i] or not .  Becuase this will give tle --> O(n^2)\\nSo we know a property is there by which a set of elemnts can be checked if they are divisible by some number or not and that is GCD.\\nSince gcd is common divisor of all the numbers in set if gcd is divible by a number it means all the numbers will be divisible by that number . So we can find the gcd of whole numsDivide array and check divisiblity by nums array in sorted way one by one .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- So Take GCD of Whole numsDivide array \\n- Sort nums array beacuse we have to check minimum number by which each element in numsDivide array is divisible.\\n- Check one by one if gcd is divisible by nums[i] and if yes break if not counter++ .\\n- Atlast check if our counter = n it means no element in nums can divide whole numsDivide array so return -1 else retrun counter (number of deletions).\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsD) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),m=numsD.size();\\n        int gcd_num=numsD[0];\\n        for(int i=1;i<m;i++){\\n          gcd_num=gcd(gcd_num,numsD[i]);\\n        }\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(gcd_num%nums[i])\\n             c++;\\n             else break;\\n        }\\n\\n        return (c==n)?-1:c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsD) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),m=numsD.size();\\n        int gcd_num=numsD[0];\\n        for(int i=1;i<m;i++){\\n          gcd_num=gcd(gcd_num,numsD[i]);\\n        }\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(gcd_num%nums[i])\\n             c++;\\n             else break;\\n        }\\n\\n        return (c==n)?-1:c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292763,
                "title": "candidate-divisible-by-gcd-intuition",
                "content": "**Intuition** :\\n\\n   The number which divides all the group of number is called as **Greatest Common Divisor(gcd)**. \\n   And my logic was if we find the **gcd of all the elements of array**.\\n    \\n   If a **number divides GCD of the array** , then automatically the number will divide all the element of the array.\\n    \\n  For finding the number we just **sort in increasing** and return the **index of first number which divides gcd**.  \\n  That would be the minimum number of deletions.\\n  \\n  # C++\\n      class GCD{\\n        public:\\n        \\n        // Function to return gcd of a and b\\n        int gcd(int a, int b){\\n           return a == 0? b : gcd(b % a, a);\\n        }\\n        \\n        int getGCD(vector<int> &arr){\\n            int gcd_all = arr[0];\\n            for (int i = 1;i < size(arr); i++){\\n                 gcd_all = gcd(arr[i], gcd_all);\\n                 if(gcd_all == 1) return 1;\\n            }\\n            return gcd_all;\\n        }\\n        \\n        };\\n    \\n       int minOperations(vector<int>& nums, vector<int>& D) {     \\n        GCD g;\\n        int gcd_of_all= g.getGCD(D);\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        //if the smallest number divides GCD, then it will divide all\\n        int cnt=0;\\n        for(auto i:nums){\\n            if(gcd_of_all%i==0) return cnt;\\n            cnt++;\\n        }\\n        \\n        return -1;\\n       }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Intuition** :\\n\\n   The number which divides all the group of number is called as **Greatest Common Divisor(gcd)**. \\n   And my logic was if we find the **gcd of all the elements of array**.\\n    \\n   If a **number divides GCD of the array** , then automatically the number will divide all the element of the array.\\n    \\n  For finding the number we just **sort in increasing** and return the **index of first number which divides gcd**.  \\n  That would be the minimum number of deletions.\\n  \\n  # C++\\n      class GCD{\\n        public:\\n        \\n        // Function to return gcd of a and b\\n        int gcd(int a, int b){\\n           return a == 0? b : gcd(b % a, a);\\n        }\\n        \\n        int getGCD(vector<int> &arr){\\n            int gcd_all = arr[0];\\n            for (int i = 1;i < size(arr); i++){\\n                 gcd_all = gcd(arr[i], gcd_all);\\n                 if(gcd_all == 1) return 1;\\n            }\\n            return gcd_all;\\n        }\\n        \\n        };\\n    \\n       int minOperations(vector<int>& nums, vector<int>& D) {     \\n        GCD g;\\n        int gcd_of_all= g.getGCD(D);\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        //if the smallest number divides GCD, then it will divide all\\n        int cnt=0;\\n        for(auto i:nums){\\n            if(gcd_of_all%i==0) return cnt;\\n            cnt++;\\n        }\\n        \\n        return -1;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2292549,
                "title": "short-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        nums.sort()\\n        x = reduce(gcd, numsDivide)\\n        \\n        count = 0\\n        for num in nums:\\n            if x%num == 0:\\n                return count\\n            count+=1\\n        return -1       \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        \\n        nums.sort()\\n        x = reduce(gcd, numsDivide)\\n        \\n        count = 0\\n        for num in nums:\\n            if x%num == 0:\\n                return count\\n            count+=1\\n        return -1       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293510,
                "title": "gcd-easy-intution-efficient",
                "content": "```\\nclass Solution {\\n\\tpublic int minOperations(int[] arr, int[] numsDivide) {\\n\\t\\tint gcd = numsDivide[0];\\n\\t\\tfor (int i = 0; i < numsDivide.length; i++) {\\n\\t\\t\\tgcd = helper(numsDivide[i], gcd);\\n\\t\\t}\\n\\t\\tArrays.sort(arr);\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (gcd % arr[i] == 0) {\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic int helper(int a, int b) {\\n\\t\\tif (b == 0)\\n\\t\\t\\treturn a;\\n\\t\\treturn helper(b, a % b);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int minOperations(int[] arr, int[] numsDivide) {\\n\\t\\tint gcd = numsDivide[0];\\n\\t\\tfor (int i = 0; i < numsDivide.length; i++) {\\n\\t\\t\\tgcd = helper(numsDivide[i], gcd);\\n\\t\\t}\\n\\t\\tArrays.sort(arr);\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (gcd % arr[i] == 0) {\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tpublic int helper(int a, int b) {\\n\\t\\tif (b == 0)\\n\\t\\t\\treturn a;\\n\\t\\treturn helper(b, a % b);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292996,
                "title": "c-short-easy-explanation",
                "content": "**Please upvote if you like**\\n* Brute force would be to get every element from nums and check it is a factor of every element in numsDivide\\n* **BETTER APPROACH**\\n* How about getting numsDivide factor first and then verify , that will also lead TLE as `O(sqrt(10^9)*n)` sqrt() for calculating factor of each number of size of array n\\n* We need to think of something else\\n* We know concept of HCF , the number that is common to a list of numbers\\n* So hcf of numsDivide gives us the maximum possible common number between them\\n* Now our question becomes , **Check whether nums contains a number that can divide the HCF**\\n* or in other words **Check whether nums has a factor of HCF**\\n* Whenever our number becomes greater than HCF , now we can\\'t possibly get a factor\\n```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++) hcf=__gcd(hcf,numsDivide[i]);\\n        sort(begin(nums),end(nums));\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>hcf) return -1;\\n            else if(hcf%nums[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++) hcf=__gcd(hcf,numsDivide[i]);\\n        sort(begin(nums),end(nums));\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>hcf) return -1;\\n            else if(hcf%nums[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292718,
                "title": "very-simple-and-easy-to-understand-c-solution-using-gcd",
                "content": "\\n<b>Up Vote if you like the solution \\n```\\nclass Solution {\\npublic:\\n    //Evaluate gcd of numsDivide\\n    //sort nums and keep on checking if it is a factor of gcd or not \\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gc = numsDivide[0];\\n        for(int i = 1; i < numsDivide.size(); ++i){\\n            gc = __gcd(gc, numsDivide[i]);\\n        }\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(gc%nums[i]) ans++;\\n            else return ans;\\n        }\\n        return -1;\\n    }\\n};\\n``` \\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Evaluate gcd of numsDivide\\n    //sort nums and keep on checking if it is a factor of gcd or not \\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gc = numsDivide[0];\\n        for(int i = 1; i < numsDivide.size(); ++i){\\n            gc = __gcd(gc, numsDivide[i]);\\n        }\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(gc%nums[i]) ans++;\\n            else return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559063,
                "title": "c-using-heap-easy-to-understand",
                "content": "find gcd of numsDivide array.\\nget minimum element of vector nums untill i cann\\'t an element which not divide gcd of numsDivide array maintain count which we checked from nums.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g = 0;\\n        for(auto &i: numsDivide){\\n            g = __gcd(g,i);//gcd of numsDivide\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;//creater a queue get minimum element of nums\\n        for(auto &i: nums){\\n            pq.push(i);\\n        }\\n        int x = 0;\\n        while(!pq.empty() && g%pq.top()){//run untill i cann\\'t get an element for that g divide by minimum element nums.\\n            x++;\\n            pq.pop();\\n        }\\n        if(pq.empty())return -1;//if queue empty there is no element who divide all element of numDivide\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g = 0;\\n        for(auto &i: numsDivide){\\n            g = __gcd(g,i);//gcd of numsDivide\\n        }\\n        priority_queue<int,vector<int>,greater<int>> pq;//creater a queue get minimum element of nums\\n        for(auto &i: nums){\\n            pq.push(i);\\n        }\\n        int x = 0;\\n        while(!pq.empty() && g%pq.top()){//run untill i cann\\'t get an element for that g divide by minimum element nums.\\n            x++;\\n            pq.pop();\\n        }\\n        if(pq.empty())return -1;//if queue empty there is no element who divide all element of numDivide\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484339,
                "title": "simple-gcd-approach-java-solution-easy-to-understand-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of the problem is to find the minimum number of operations required to obtain an integer divisible by a given set of integers numsDivide by performing a set of allowed operations on another integer array nums. The allowed operations are selecting any integer from nums and adding or subtracting any other integer from nums to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in the minOperations method is to first calculate the GCD of all the integers in numsDivide using the gcd method. This GCD is then used to check if there exists any integer in the sorted array nums that is a factor of the GCD. If such an integer exists, then the index of the first such integer in nums is returned as the answer. Otherwise, -1 is returned to indicate that it is not possible to obtain an integer divisible by all the integers in numsDivide using the allowed operations on the nums array.\\n\\n# Complexity\\n- Time complexity:O(n log(min(a, b))) + O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int gcd(int a,int b){\\n        if(a==0)\\n        return b;\\n        return gcd(b%a,a);\\n    }\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int t=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            t=gcd(t,numsDivide[i]);\\n        }\\n        Arrays.sort(nums);\\n  for(int i=0;i<nums.length;i++){\\n        if(t%nums[i]==0)\\n        return i;\\n  }\\n  return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int gcd(int a,int b){\\n        if(a==0)\\n        return b;\\n        return gcd(b%a,a);\\n    }\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int t=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            t=gcd(t,numsDivide[i]);\\n        }\\n        Arrays.sort(nums);\\n  for(int i=0;i<nums.length;i++){\\n        if(t%nums[i]==0)\\n        return i;\\n  }\\n  return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049749,
                "title": "short-concise-gcd-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g = 0, n = nums.size();\\n        for(int i : numsDivide) g = __gcd(g, i);\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++) {\\n            if(g % nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g = 0, n = nums.size();\\n        for(int i : numsDivide) g = __gcd(g, i);\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++) {\\n            if(g % nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991826,
                "title": "c-very-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(nlogn)+O(nlogn)+O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        sort(numsDivide.begin(), numsDivide.end());\\n        int cnt=0;\\n        int cmn=numsDivide[0];\\n        for(int i=1; i<numsDivide.size(); i++){\\n            cmn=__gcd(cmn, numsDivide[i]);\\n        }\\n        //cout<<cmn<<endl;\\n        if(nums[0]>cmn){return -1;}\\n        for(int i=0; i<nums.size(); i++){\\n            if(cmn%nums[i]==0){\\n                return cnt;\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        sort(numsDivide.begin(), numsDivide.end());\\n        int cnt=0;\\n        int cmn=numsDivide[0];\\n        for(int i=1; i<numsDivide.size(); i++){\\n            cmn=__gcd(cmn, numsDivide[i]);\\n        }\\n        //cout<<cmn<<endl;\\n        if(nums[0]>cmn){return -1;}\\n        for(int i=0; i<nums.size(); i++){\\n            if(cmn%nums[i]==0){\\n                return cnt;\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2938043,
                "title": "solution-using-gcd-c-easy-to-understand-solution",
                "content": "1.We are given two positive integer arrays` nums` and `numsDivide`. Our objective is to delete `minimum` number of elements  from `nums` such that the smallest number in the array `nums`  after the removal of the elements , divides all the elements of `numsDivide`.\\n2. If a number `x` divides all the elements of an array then we can say it is one of it\\'s` common divisors` if not GCD .\\n3. If we can manage to find the GCD of all the elements in the array `numsDivide` and then manage to find the smallest element from `nums` which divides the GCD then our answer will be the smallest number (GCD can itself be the answer also).\\n4. For a number `x` to become the smallest of all the elements in a given array , all the elements that are smaller from the number `x` , are to be deleted , which is quite obvious , this is where sorting the array comes into picture.\\n5. If the array is sorted then in order to make a given number , the smallest of all , the minimum number of deletions will be equal to the index of it\\'s `first occurence in the sorted array`. \\n6. Below implemenation will make it more clear !\\n```\\n  int minOperations(vector<int>& nums, vector<int>& numsD) {\\n        int ans = -1;\\n        int n = nums.size();\\n       sort(nums.begin() , nums.end());\\n        //map<int , int>m;\\n        int gcdd = *max_element(numsD.begin() , numsD.end());\\n        // for(int i=0;i<n;++i)\\n        //     m[nums[i]] = i;\\n        for(auto i:numsD)\\n        {\\n            gcdd = __gcd(gcdd , i);\\n        }\\n        \\n        \\n        cout<<gcdd<<\"\\\\n\";\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(gcdd%nums[i] == 0)\\n            {\\n               ans = i;\\n                break;\\n            } \\n        }\\n        return ans;\\n    }\\n```\\n\\n**Upvote if you found it useful! Arigato.**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n  int minOperations(vector<int>& nums, vector<int>& numsD) {\\n        int ans = -1;\\n        int n = nums.size();\\n       sort(nums.begin() , nums.end());\\n        //map<int , int>m;\\n        int gcdd = *max_element(numsD.begin() , numsD.end());\\n        // for(int i=0;i<n;++i)\\n        //     m[nums[i]] = i;\\n        for(auto i:numsD)\\n        {\\n            gcdd = __gcd(gcdd , i);\\n        }\\n        \\n        \\n        cout<<gcdd<<\"\\\\n\";\\n        \\n        for(int i=0;i<n;++i)\\n        {\\n            if(gcdd%nums[i] == 0)\\n            {\\n               ans = i;\\n                break;\\n            } \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2296334,
                "title": "python3-gcd-and-heap-6-lines-w-explanation-t-m-56-100",
                "content": "```\\nclass Solution:\\n                    # From number theory, we know that an integer num divides each\\n                    # integer in a list if and only if num divides the list\\'s gcd.\\n                    # \\n                    # Our plan here is to:\\n                    #   \\u2022 find the gcd of numDivide\\n                    #   \\u2022 heapify(nums) and count the popped elements that do not\\n                    #     divide the gcd.\\n                    #   \\u2022 return that count when and if a popped element eventually\\n                    #     divides the gcd. If that never happens, return -1 \\n        \\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n\\t\\n        g, ans = gcd(*numsDivide), 0            # <-- find gcd (using * operator)\\n\\n        heapify(nums)                           # <-- create heap\\n\\n        while nums:                             # <-- pop and count\\n\\n            if not g%heappop(nums): return ans  # <-- found a divisor? return count\\n            else: ans+= 1                       # <-- if not, increment the count\\n\\n        return -1                               # <-- no divisors found\\n\\t\\t\\n#--------------------------------------------------\\nclass Solution:    # version w/o heap. Seems to run slower\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n\\t\\n        g = gcd(*numsDivide)\\n        nums.sort()\\n\\n        for i,num in enumerate(nums):\\n            if not g%num: return i\\n\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n                    # From number theory, we know that an integer num divides each\\n                    # integer in a list if and only if num divides the list\\'s gcd.\\n                    # \\n                    # Our plan here is to:\\n                    #   \\u2022 find the gcd of numDivide\\n                    #   \\u2022 heapify(nums) and count the popped elements that do not\\n                    #     divide the gcd.\\n                    #   \\u2022 return that count when and if a popped element eventually\\n                    #     divides the gcd. If that never happens, return -1 \\n        \\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n\\t\\n        g, ans = gcd(*numsDivide), 0            # <-- find gcd (using * operator)\\n\\n        heapify(nums)                           # <-- create heap\\n\\n        while nums:                             # <-- pop and count\\n\\n            if not g%heappop(nums): return ans  # <-- found a divisor? return count\\n            else: ans+= 1                       # <-- if not, increment the count\\n\\n        return -1                               # <-- no divisors found\\n\\t\\t\\n#--------------------------------------------------\\nclass Solution:    # version w/o heap. Seems to run slower\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n\\t\\n        g = gcd(*numsDivide)\\n        nums.sort()\\n\\n        for i,num in enumerate(nums):\\n            if not g%num: return i\\n\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2294110,
                "title": "gcd-euclidean-algorithm-python",
                "content": "Find the greatest common divisor (gcd) for numsDivide with the euclidean algorithm\\n\\nSort nums and find the lowest number that divides with the found gcd.\\n\\nI\\'ve implemented the GCD for learning purposes, there is a built-in implementation in `math.gcd()`\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        nums_divide_gcd = numsDivide[0]\\n        for num in numsDivide:\\n            nums_divide_gcd = self.gcd(nums_divide_gcd, num)\\n        \\n        nums.sort()\\n        ans = 0\\n        for n in nums:\\n            if n > nums_divide_gcd:\\n                return -1\\n            if nums_divide_gcd % n == 0:\\n                break\\n            ans += 1\\n        \\n        return ans\\n        \\n    \"\"\"\\n    Euclidean algorithm\\n    a = bq + r\\n    gcd(a,b) = gcd(b, r)\\n    \"\"\"\\n    def gcd(self, a: int, b: int):\\n        g = 0\\n        while b:\\n            tmp = a\\n            g = b\\n            a = b\\n            b = tmp % b\\n            \\n        return g\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        nums_divide_gcd = numsDivide[0]\\n        for num in numsDivide:\\n            nums_divide_gcd = self.gcd(nums_divide_gcd, num)\\n        \\n        nums.sort()\\n        ans = 0\\n        for n in nums:\\n            if n > nums_divide_gcd:\\n                return -1\\n            if nums_divide_gcd % n == 0:\\n                break\\n            ans += 1\\n        \\n        return ans\\n        \\n    \"\"\"\\n    Euclidean algorithm\\n    a = bq + r\\n    gcd(a,b) = gcd(b, r)\\n    \"\"\"\\n    def gcd(self, a: int, b: int):\\n        g = 0\\n        while b:\\n            tmp = a\\n            g = b\\n            a = b\\n            b = tmp % b\\n            \\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293188,
                "title": "c-map-heap",
                "content": "```\\nclass compare{\\n    public:\\n    bool operator()(pair<int,int>&a,pair<int,int>&b)\\n    {\\n        return a.first>b.first;//minheap\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        for(auto i:nums)mp1[i]++;\\n        for(auto i:numsDivide)mp2[i]++;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,compare>pq;\\n        for(auto i:mp1)pq.push({i.first,i.second});\\n        int count=0;\\n        while(!pq.empty())\\n        {\\n            auto [x,y]=pq.top();\\n            bool flag=false;\\n            for(auto i:mp2)\\n            {\\n                if(i.first%x!=0){\\n                    count+=y;\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(!flag)return count;\\n            pq.pop();\\n        }\\n        if(pq.empty())return -1;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass compare{\\n    public:\\n    bool operator()(pair<int,int>&a,pair<int,int>&b)\\n    {\\n        return a.first>b.first;//minheap\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        for(auto i:nums)mp1[i]++;\\n        for(auto i:numsDivide)mp2[i]++;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,compare>pq;\\n        for(auto i:mp1)pq.push({i.first,i.second});\\n        int count=0;\\n        while(!pq.empty())\\n        {\\n            auto [x,y]=pq.top();\\n            bool flag=false;\\n            for(auto i:mp2)\\n            {\\n                if(i.first%x!=0){\\n                    count+=y;\\n                    flag=true;\\n                    break;\\n                }\\n            }\\n            if(!flag)return count;\\n            pq.pop();\\n        }\\n        if(pq.empty())return -1;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292688,
                "title": "gcd-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint gcd(int a, int b){\\n\\t\\tif (a == 0)\\n\\t\\t\\treturn b;\\n\\t\\treturn gcd(b % a, a);\\n\\t}\\n\\n\\t\\tint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n\\t\\t\\tint res = 0,ans = 0;\\n\\t\\t\\tfor(auto x:numsDivide) res = gcd(res,x);\\n\\t\\t\\tsort(begin(nums),end(nums));\\n\\t\\t\\tfor(auto x:nums){\\n\\t\\t\\t\\tif(x==res or res%x==0) return ans;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint gcd(int a, int b){\\n\\t\\tif (a == 0)\\n\\t\\t\\treturn b;\\n\\t\\treturn gcd(b % a, a);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2292565,
                "title": "c-gcd",
                "content": "**Observation:**\\nKey point of this problem is `nums[i]` divides all the elements of `numsDivide`. So if `gcd` of all the elements of `numsDivide` can be divisibale by any `nums[i]` then solution exist. And we have to remove the smallest, damm sort the array to remove all the smallest not divisible numbers.\\n\\n**Time:** `O(M + N log N), M =  Length of numsDivide, N = Length of nums`\\n**Space:** `O(1) to O(N) for sorting algorithm implementation` \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        for (auto n : numsDivide) {\\n            gcd = __gcd(gcd, n);\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(gcd % nums[i] == 0) return i; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        for (auto n : numsDivide) {\\n            gcd = __gcd(gcd, n);\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(gcd % nums[i] == 0) return i; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321359,
                "title": "c-gcd-sorting-with-approach",
                "content": "Intuition:\\n* Sort the nums array\\n* Calculate gcd of numsDivide array \\n* Then check if gcd is divisible by any element in nums array \\n* Store the value in ans, if not present then ans=-1\\n\\nTime Complexity - **O(NlogN)**\\nSpace Complexity - **O(1)**\\n```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        int n=nums.size(),m=numsDivide.size(),ans,k=0,x=0;\\n        sort(nums.begin(),nums.end());\\n        if(m==1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(numsDivide[0]%nums[i]==0)\\n                {\\n                    ans=x;\\n                    k++;\\n                    break;\\n                }\\n                x++;\\n            }\\n        }\\n        else\\n        {\\n            int g=numsDivide[0];\\n            for(int i=1;i<m;i++)\\n            {\\n                g=__gcd(g,numsDivide[i]);\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                if(g%nums[i]==0)\\n                {\\n                    ans=x;\\n                    k++;\\n                    break;\\n                }\\n                x++;\\n            }\\n        }\\n        return k?ans:-1;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        int n=nums.size(),m=numsDivide.size(),ans,k=0,x=0;\\n        sort(nums.begin(),nums.end());\\n        if(m==1)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(numsDivide[0]%nums[i]==0)\\n                {\\n                    ans=x;\\n                    k++;\\n                    break;\\n                }\\n                x++;\\n            }\\n        }\\n        else\\n        {\\n            int g=numsDivide[0];\\n            for(int i=1;i<m;i++)\\n            {\\n                g=__gcd(g,numsDivide[i]);\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                if(g%nums[i]==0)\\n                {\\n                    ans=x;\\n                    k++;\\n                    break;\\n                }\\n                x++;\\n            }\\n        }\\n        return k?ans:-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2313299,
                "title": "complexity-is-not-good-but-easiest-accepted-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;++i){\\n            mp[nums[i]]++;\\n        }\\n        int m = numsDivide.size();\\n        int ans = 0;\\n        for(auto it:mp){\\n            bool isDivide = true;\\n            for(int j=0;j<m;++j){\\n                if(((numsDivide[j])%(it.first))==0){\\n                    continue;\\n                }else{\\n                    isDivide = false;\\n                    break;\\n                }\\n            }\\n            if(isDivide){\\n                break;\\n            }\\n            else{\\n                ans += it.second;\\n            }\\n        }\\n        if(ans==n){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<n;++i){\\n            mp[nums[i]]++;\\n        }\\n        int m = numsDivide.size();\\n        int ans = 0;\\n        for(auto it:mp){\\n            bool isDivide = true;\\n            for(int j=0;j<m;++j){\\n                if(((numsDivide[j])%(it.first))==0){\\n                    continue;\\n                }else{\\n                    isDivide = false;\\n                    break;\\n                }\\n            }\\n            if(isDivide){\\n                break;\\n            }\\n            else{\\n                ans += it.second;\\n            }\\n        }\\n        if(ans==n){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297449,
                "title": "simple-implementation-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        set<int> s1;\\n        for(auto &it:nums)      s1.insert(it);                 // Store elements in unique and sorted order\\n        int ans = 0;                                 // answer variable\\n        for(auto &it:s1){\\n            bool b1 = true;\\n            for(auto &i:numsDivide){                        // check is a number is divisible by all elements\\n                if(i%it!=0){                                 // is not we should delete that element\\n                    b1 = false;\\n                    ans += count(nums.begin(),nums.end(),it);        // count all occurance of that eleemnt\\n                    break;\\n                }\\n            }\\n            if(b1)  return ans;                                //  if solution exist else after iteration finishs return -1\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        set<int> s1;\\n        for(auto &it:nums)      s1.insert(it);                 // Store elements in unique and sorted order\\n        int ans = 0;                                 // answer variable\\n        for(auto &it:s1){\\n            bool b1 = true;\\n            for(auto &i:numsDivide){                        // check is a number is divisible by all elements\\n                if(i%it!=0){                                 // is not we should delete that element\\n                    b1 = false;\\n                    ans += count(nums.begin(),nums.end(),it);        // count all occurance of that eleemnt\\n                    break;\\n                }\\n            }\\n            if(b1)  return ans;                                //  if solution exist else after iteration finishs return -1\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294737,
                "title": "easy-c-gcd-solution-well-commented",
                "content": "```\\n\\tclass Solution {\\npublic:\\n\\n      int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int n = nums.size();\\n        int m = numsDivide.size();\\n        int a = numsDivide[0];\\n        //finding the GCD with all the numbers and store it in a\\n        //gcd will be the minimum number that divides all elements in array\\n        for(int i=1;i<m;i++){\\n            a = __gcd(a,numsDivide[i]);\\n        }\\n        //create a map\\n        map<int,int> mp;\\n        //Note we are not using unordered_map since we need to get sorted map \\n        //store the elements with their frequency in our map\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        //traverse through map and get the number that is divisible by our gcd\\n        //if a number cant divides gcd keep adding its freq\\n        //if number divides with gcd it will be our answer\\n        int ans = 0;\\n        for(auto i : mp){\\n            if( a % i.first == 0){\\n                return ans;\\n            }\\n            ans += i.second;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n\\n      int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int n = nums.size();\\n        int m = numsDivide.size();\\n        int a = numsDivide[0];\\n        //finding the GCD with all the numbers and store it in a\\n        //gcd will be the minimum number that divides all elements in array\\n        for(int i=1;i<m;i++){\\n            a = __gcd(a,numsDivide[i]);\\n        }\\n        //create a map\\n        map<int,int> mp;\\n        //Note we are not using unordered_map since we need to get sorted map \\n        //store the elements with their frequency in our map\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        //traverse through map and get the number that is divisible by our gcd\\n        //if a number cant divides gcd keep adding its freq\\n        //if number divides with gcd it will be our answer\\n        int ans = 0;\\n        for(auto i : mp){\\n            if( a % i.first == 0){\\n                return ans;\\n            }\\n            ans += i.second;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293601,
                "title": "c-easy-to-understand-gcd",
                "content": "**Approach:** Sort nums, find gcd of the numsDivide and just return the first index where gcd % nums[i] == 0\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=numsDivide[0], n=numsDivide.size();\\n        for(int i=1;i<n;i++) {\\n            gcd=__gcd(gcd, numsDivide[i]);\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(gcd == 1) {\\n            return nums[0]==1?0:-1;\\n        }\\n        for(int i=0;i<nums.size();i++) {\\n            if(i and nums[i]==nums[i-1]) continue;\\n            else if(gcd%nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Time: O(NlogN + M)\\nSpace: O(1)**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=numsDivide[0], n=numsDivide.size();\\n        for(int i=1;i<n;i++) {\\n            gcd=__gcd(gcd, numsDivide[i]);\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(gcd == 1) {\\n            return nums[0]==1?0:-1;\\n        }\\n        for(int i=0;i<nums.size();i++) {\\n            if(i and nums[i]==nums[i-1]) continue;\\n            else if(gcd%nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293056,
                "title": "easy-priority-queue-based-solution-100-faster",
                "content": "Minimum Deletions to Make Array Divisible\\n``typedef long long ll;\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& d) {\\n        priority_queue<int, vector<int>, greater<int>> minh;\\n        ll sum=accumulate(d.begin(), d.end(), 0LL); \\n        for(auto i:nums)\\n            minh.push(i);\\n        int cnt=0;\\n        while(!minh.empty())\\n        {\\n            int top=minh.top();\\n             // cout<<top<<endl;\\n            int flag=0;\\n            if(sum%top==0)\\n            {\\n            for(auto i:d)\\n            {\\n                if(i%top!=0)\\n                   {\\n                    cnt++;\\n                   flag=1;\\n                    break;\\n                }\\n            }\\n            }\\n            else\\n               { cnt++;\\n               flag=1;\\n               }\\n            if(flag==0)\\n                return cnt;\\n               minh.pop();\\n        }\\n                if(cnt==0 || cnt==nums.size())\\n                return -1;\\n            return cnt;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& d) {\\n        priority_queue<int, vector<int>, greater<int>> minh;\\n        ll sum=accumulate(d.begin(), d.end(), 0LL); \\n        for(auto i:nums)\\n            minh.push(i);\\n        int cnt=0;\\n        while(!minh.empty())\\n        {\\n            int top=minh.top();\\n             // cout<<top<<endl;\\n            int flag=0;\\n            if(sum%top==0)\\n            {\\n            for(auto i:d)\\n            {\\n                if(i%top!=0)\\n                   {\\n                    cnt++;\\n                   flag=1;\\n                    break;\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 2293005,
                "title": "python-gcd-and-sorting",
                "content": "First we find the GCD  in `numsDivide`, if any number in `nums` can divide the GCD, then it must can divide any number in `numsDivide`.\\n\\nThen sort `nums`, and search any number smaller than GCD can also divide it from start. If any number is larger than GCD, then it must cannot divide it.\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcdd = gcd(*numsDivide)\\n        nums.sort()\\n\\n        for i, num in enumerate(nums):\\n            if num > gcdd:\\n                return -1\\n            if gcdd % num == 0:\\n                return i\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcdd = gcd(*numsDivide)\\n        nums.sort()\\n\\n        for i, num in enumerate(nums):\\n            if num > gcdd:\\n                return -1\\n            if gcdd % num == 0:\\n                return i\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293002,
                "title": "brute-force-solution",
                "content": "```\\nclass Solution {\\n    bool perfectDivisible(int num, vector<int> &numsDivide)\\n    {\\n        for(int numDiv : numsDivide)\\n        {\\n            if(numDiv % num != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        sort(numsDivide.begin(), numsDivide.end());\\n        int prevNumber = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(prevNumber == nums[i])\\n                continue;\\n            if(perfectDivisible(nums[i], numsDivide))\\n                return i;\\n            prevNumber = nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool perfectDivisible(int num, vector<int> &numsDivide)\\n    {\\n        for(int numDiv : numsDivide)\\n        {\\n            if(numDiv % num != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        sort(numsDivide.begin(), numsDivide.end());\\n        int prevNumber = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(prevNumber == nums[i])\\n                continue;\\n            if(perfectDivisible(nums[i], numsDivide))\\n                return i;\\n            prevNumber = nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292932,
                "title": "easy-c-code-using-map-with-comments",
                "content": "Method 1: using hash_map and 2 loops\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t// store the elements of nums in a map so that the values will be sorted and its occurance will be conted at the same time\\n\\t\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\t\\tfor(auto x:nums)\\n\\t\\t\\t\\t\\tmp[x]++;\\n\\t\\t\\t\\tfor(auto x:mp){\\n\\t\\t\\t\\t// ck is used for checking if all the elements in numsDivide are divisible by x.first i.e the element of nums\\n\\t\\t\\t\\t\\tint ck=0;\\n\\t\\t\\t\\t\\tfor(auto z:numsDivide){\\n\\t\\t\\t\\t\\t\\tif(z%x.first!=0){\\n\\t\\t\\t\\t\\t\\t// if not divisible then break\\n\\t\\t\\t\\t\\t\\t\\tck=1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//if x.first is not divisible then remove all the occurance of x.first or add its number of occurance in the answer\\n\\t\\t\\t\\t\\tif(ck==1){\\n\\t\\t\\t\\t\\t\\tans+=x.second;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t//if all the elements of numsDivide is divisible by x.first then return the answer\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if there is not a single element present in nums that can divide all the elements of numsDivide then return -1\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\nMethod 2: using map and gcd(greatest common divisor) to reduce time complexity\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint gcd(int a,int b){\\n\\t\\t\\tif(b==0)\\n\\t\\t\\t\\treturn a;\\n\\t\\t\\treturn gcd(b,a%b);\\n\\t\\t}\\n\\t\\tint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\tfor(auto x:nums)\\n\\t\\t\\t\\tmp[x]++;\\n\\t\\t\\t// find greatest common divisor of numsDivide so as to easily find 1st element from nums which can divide all the elements of numsDivide\\n\\t\\t\\tint g=numsDivide[0];\\n\\t\\t\\tfor(auto x:numsDivide){\\n\\t\\t\\t\\tg=gcd(g,x);\\n\\t\\t\\t}\\n\\t\\t\\t// since map sorts all the elements so we can easily find the sortest element and time complexity can decrease a little bit if there are repitation of elements which are non-divisible\\n\\t\\t\\tfor(auto x:mp){\\n\\t\\t\\t\\tif(g%x.first==0){\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans+=x.second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}return -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t// store the elements of nums in a map so that the values will be sorted and its occurance will be conted at the same time\\n\\t\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\t\\tfor(auto x:nums)\\n\\t\\t\\t\\t\\tmp[x]++;\\n\\t\\t\\t\\tfor(auto x:mp){\\n\\t\\t\\t\\t// ck is used for checking if all the elements in numsDivide are divisible by x.first i.e the element of nums\\n\\t\\t\\t\\t\\tint ck=0;\\n\\t\\t\\t\\t\\tfor(auto z:numsDivide){\\n\\t\\t\\t\\t\\t\\tif(z%x.first!=0){\\n\\t\\t\\t\\t\\t\\t// if not divisible then break\\n\\t\\t\\t\\t\\t\\t\\tck=1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2292907,
                "title": "o-n-hashmap-gcd",
                "content": "Order n solution using simple GCD, trick was just to reduce the gcd as much as possible by finding divisor of gcd in nums\\uD83D\\uDE0D\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int gcdOfnums = numsDivide[0];\\n        for(int i =1;i<numsDivide.length;i++){\\n            gcdOfnums = gcd(gcdOfnums,numsDivide[i]);\\n        }\\n        int remove = 0;\\n        boolean isFound = false;\\n        for(int num: nums){\\n            if(gcdOfnums%num == 0){\\n                gcdOfnums= Math.min(num, gcdOfnums);\\n            }\\n        }\\n        for(int num: nums){\\n            if(num == gcdOfnums) isFound = true;\\n            else if(num < gcdOfnums) remove++;\\n        }\\n        return (isFound ? remove:-1);\\n    }\\n    private int gcd(int num1, int num2){\\n        int div, rem, num;\\n        if(num1<num2){\\n            div = num2/num1;\\n            rem = num2%num1;\\n            num = num1;\\n        }\\n        else{\\n            div = num1/num2;\\n            rem = num1%num2;\\n            num= num2;\\n        }\\n        if(rem == 0) return num;\\n        return gcd(num, rem);\\n    }\\n}\\n```\\nCherish the moment who all got all 4 questions for the first time.\\nHappy LeetCoding",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int gcdOfnums = numsDivide[0];\\n        for(int i =1;i<numsDivide.length;i++){\\n            gcdOfnums = gcd(gcdOfnums,numsDivide[i]);\\n        }\\n        int remove = 0;\\n        boolean isFound = false;\\n        for(int num: nums){\\n            if(gcdOfnums%num == 0){\\n                gcdOfnums= Math.min(num, gcdOfnums);\\n            }\\n        }\\n        for(int num: nums){\\n            if(num == gcdOfnums) isFound = true;\\n            else if(num < gcdOfnums) remove++;\\n        }\\n        return (isFound ? remove:-1);\\n    }\\n    private int gcd(int num1, int num2){\\n        int div, rem, num;\\n        if(num1<num2){\\n            div = num2/num1;\\n            rem = num2%num1;\\n            num = num1;\\n        }\\n        else{\\n            div = num1/num2;\\n            rem = num1%num2;\\n            num= num2;\\n        }\\n        if(rem == 0) return num;\\n        return gcd(num, rem);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292674,
                "title": "c-easy-commented-solution-using-gcd-and-sorting-time-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, vector<int>& b) {\\n    \\n        \\n        int  gcd = b[0];\\n        \\n        for(int i=1;i<b.size();i++)     // Finding smallest number(gcd) which divide the numDivide array\\n            gcd  = __gcd(gcd,b[i]);\\n        \\n        vector<int> v;\\n        \\n        for(int i=1;i<=sqrt(gcd);i++)    // Finding all divisor of smallest number(gcd)\\n        {\\n            if(gcd%i==0)\\n            {\\n                v.push_back(i);\\n                if(gcd/i!=i)\\n                {\\n                    v.push_back(gcd/i);\\n                }\\n            }\\n            \\n        }\\n        \\n       // It\\u2019s time to find the smallest number which is present in both divisor and nums array \\n\\n        sort(v.begin(),v.end());   // First sort both array\\n        sort(a.begin(),a.end());\\n        \\n        \\n        int i=0 , j=0;\\n        int n = a.size() , m = v.size() ,ans =-1;\\n        while(i<n&&j<m)\\n        {\\n            if(a[i]==v[j])     // If found put index in nums of that element iin ans variable\\n            {\\n                ans = i;        \\n                break;\\n            }\\n            if(a[i]<v[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n\\n               return ans;\\n        \\n    }\\n};\\n\\n\\n\\n\\n```\\n\\n**Upvote if you like it !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, vector<int>& b) {\\n    \\n        \\n        int  gcd = b[0];\\n        \\n        for(int i=1;i<b.size();i++)     // Finding smallest number(gcd) which divide the numDivide array\\n            gcd  = __gcd(gcd,b[i]);\\n        \\n        vector<int> v;\\n        \\n        for(int i=1;i<=sqrt(gcd);i++)    // Finding all divisor of smallest number(gcd)\\n        {\\n            if(gcd%i==0)\\n            {\\n                v.push_back(i);\\n                if(gcd/i!=i)\\n                {\\n                    v.push_back(gcd/i);\\n                }\\n            }\\n            \\n        }\\n        \\n       // It\\u2019s time to find the smallest number which is present in both divisor and nums array \\n\\n        sort(v.begin(),v.end());   // First sort both array\\n        sort(a.begin(),a.end());\\n        \\n        \\n        int i=0 , j=0;\\n        int n = a.size() , m = v.size() ,ans =-1;\\n        while(i<n&&j<m)\\n        {\\n            if(a[i]==v[j])     // If found put index in nums of that element iin ans variable\\n            {\\n                ans = i;        \\n                break;\\n            }\\n            if(a[i]<v[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n\\n               return ans;\\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292596,
                "title": "c-gcd-with-explanation",
                "content": "The number that will divide all the elements of the numsDivide array will be the GCD of numsDivide. Find gcd and store it in \\'result\\'.\\nSort the nums array and find the first number from nums that divides \\'result\\' because we need to find the smallest element.\\nReturn the index of that element as it is going to be equal to the min. deletions required as the numbers before that index are considered to be deleted from nums array.\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {   if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& arr) {\\n        int result = arr[0];\\n        int n = arr.size();\\n        for(int i=1;i<n;i++){\\n            result = gcd(arr[i], result);\\n            if(result == 1)\\n            {\\n                break;\\n            }\\n        }\\n        sort(begin(nums),end(nums));\\n        n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(result % nums[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {   if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& arr) {\\n        int result = arr[0];\\n        int n = arr.size();\\n        for(int i=1;i<n;i++){\\n            result = gcd(arr[i], result);\\n            if(result == 1)\\n            {\\n                break;\\n            }\\n        }\\n        sort(begin(nums),end(nums));\\n        n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(result % nums[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647102,
                "title": "easy-c-solution-using-gcd-with-intuitiuon-and-detailed-approach",
                "content": "# Intuition\\nThe Intuition behind this is that we need to check divisibility of numsDivide array. So first thing that comes to my mind is finding HCF(highest common factor) of the numsDivide array. After finding the HCF then we need to find the number of elements that are smaller than HCF in the nums array so that we can remove those elements to find our answer.\\n\\n# Approach\\nFirst we need to find the HCF of the numsDivide array, we can do that by using the euler\\'s formula for finding the GCD of 2 numbers. ie GCD(a,b) = GCD(a%b,b). So we will traverse through the whole array numsDivide and then find out the GCD of the entire array by considering pairs of 2 numbers and moving ahead in the array.\\n\\nAfter we found out the HCF then there is a twist. What if there is a number present in the array nums which is smaller than the HCF we found and is a factor of HCF? Then we need to consider that number as our answer. Eg. nums = [3,4,5,35] and numsDivide = [70,105,70,35,350]. From this example we will get our HCF as 35 but we can see in nums array that 5 is the minimum number that divides allm the numbers in the entire array numsDivide. SO we will delete 3 and 4 so that our ans is 2. Thus there is another loop for finding the minimum of the HCF factors in nums array.\\n\\nNow we got our minimum number. Now we just need to count how many numbers are there in nums array which are less than this GCD. Count of those numbers will be our answer.\\n\\n# Complexity\\n- Time complexity:\\n- As we are traversing through the array 3 times so O(3n) which is roughly-->\\nO(n)\\n\\n- Space complexity:\\n- As we are just using two variables hcf and gcd So-->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    int findGCD(vector<int> &arr, int n){\\n        int result = arr[0];\\n        for (int i = 1; i < n; i++){\\n            result = gcd(arr[i], result);\\n            if(result == 1){\\n                return 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int n=nums.size();\\n        int m=numsDivide.size();\\n        int hcf = findGCD(numsDivide, m);\\n\\n        <!-- cout<<hcf<<endl; -->\\n        int gcd=1e9;\\n        for(int i=0; i<n; i++){\\n            if(hcf%nums[i]==0){\\n                gcd=min(gcd, nums[i]);\\n            }\\n        }\\n        <!-- cout<<gcd<<endl; -->\\n        if(gcd==1e9) return -1;\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<gcd) ans++;\\n        }\\n        // if(ans==0 && m==1 && n==2 && numsDivide[0]%nums[0]==0) return 0;\\n        if(ans==0 && numsDivide[0]%gcd==0) return 0;\\n        if(ans==0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    int findGCD(vector<int> &arr, int n){\\n        int result = arr[0];\\n        for (int i = 1; i < n; i++){\\n            result = gcd(arr[i], result);\\n            if(result == 1){\\n                return 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int n=nums.size();\\n        int m=numsDivide.size();\\n        int hcf = findGCD(numsDivide, m);\\n\\n        <!-- cout<<hcf<<endl; -->\\n        int gcd=1e9;\\n        for(int i=0; i<n; i++){\\n            if(hcf%nums[i]==0){\\n                gcd=min(gcd, nums[i]);\\n            }\\n        }\\n        <!-- cout<<gcd<<endl; -->\\n        if(gcd==1e9) return -1;\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<gcd) ans++;\\n        }\\n        // if(ans==0 && m==1 && n==2 && numsDivide[0]%nums[0]==0) return 0;\\n        if(ans==0 && numsDivide[0]%gcd==0) return 0;\\n        if(ans==0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3639916,
                "title": "c-solution-gcd-sorting",
                "content": "\\n\\n# Complexity\\n- Time complexity: ```O(gcd + m + nlogn), where gcd = log(max(numsDivide))```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(a == 0)return b;\\n        return gcd(b%a,a);\\n    }\\n    int solve(vector<int> &v,int n){\\n        int res = v[0];\\n        for(int i=1;i<n;i++) res = gcd(res, v[i]);\\n        return res;\\n    }\\n    int minOperations(vector<int>& v, vector<int>& numsDivide) {\\n        int n = v.size();\\n        int k = solve(numsDivide,numsDivide.size());\\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<n;i++){\\n            if(k%v[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(gcd + m + nlogn), where gcd = log(max(numsDivide))```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(a == 0)return b;\\n        return gcd(b%a,a);\\n    }\\n    int solve(vector<int> &v,int n){\\n        int res = v[0];\\n        for(int i=1;i<n;i++) res = gcd(res, v[i]);\\n        return res;\\n    }\\n    int minOperations(vector<int>& v, vector<int>& numsDivide) {\\n        int n = v.size();\\n        int k = solve(numsDivide,numsDivide.size());\\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<n;i++){\\n            if(k%v[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319938,
                "title": "gcd-sort-modulo-easy-to-understand-c-short-sweet-code",
                "content": "![image](https://assets.leetcode.com/users/images/4b31a909-ff31-4629-b31a-cb88b56b5064_1679316124.6108158.png)\\n````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==1)return 0;\\n        int g = 0;\\n        for(auto &i: numsDivide){\\n            g = __gcd(g,i);\\n        }\\n        if(g==1||g<nums[0]){\\n            return -1;\\n        }\\n        int i;\\n        for(i = 0;i<nums.size();i++){\\n            if(g%nums[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==1)return 0;\\n        int g = 0;\\n        for(auto &i: numsDivide){\\n            g = __gcd(g,i);\\n        }\\n        if(g==1||g<nums[0]){\\n            return -1;\\n        }\\n        int i;\\n        for(i = 0;i<nums.size();i++){\\n            if(g%nums[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002955,
                "title": "asy-4-line-soln-well-explained-microsoft",
                "content": "# Please upvote if it is helpful ^_^\\n*6Companies30days #ReviseWithArsh Challenge 2023\\nDay3\\nQ14. Deletions to make an array divisible.*\\n\\n**Intuition: *gcd***\\n![14.minimum-deletions-to-make-array-divisible.jpg](https://assets.leetcode.com/users/images/86f0dbdf-dfe7-41fb-b0a5-b6529a7477c6_1672922423.6993096.jpeg)\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992866,
                "title": "java-solution",
                "content": "# Intuition\\nThis is Simple Math. \\nThink about the GCD.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirstly sort the numsDivide and find the gcd\\nSecondly sort the nums and find the first number by which gcd can give 0 as remender.\\nAlso think about the base cases like if count==length of num return -1\\nand if first element is greater than gcd then return -1;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        Arrays.sort(numsDivide);\\n        int val=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            val=gcd(val,numsDivide[i]);\\n        }\\n        Arrays.sort(nums);\\n        int c=0;\\n        if(nums[0]>val) return -1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>val) break;\\n            if(val%nums[i]!=0) c++;\\n            else break;\\n        }\\n        if(c==nums.length) return -1;\\n        return c;\\n    }\\n\\n    static int gcd(int a, int b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        Arrays.sort(numsDivide);\\n        int val=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            val=gcd(val,numsDivide[i]);\\n        }\\n        Arrays.sort(nums);\\n        int c=0;\\n        if(nums[0]>val) return -1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>val) break;\\n            if(val%nums[i]!=0) c++;\\n            else break;\\n        }\\n        if(c==nums.length) return -1;\\n        return c;\\n    }\\n\\n    static int gcd(int a, int b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749081,
                "title": "python-easy-solution-82-faster",
                "content": "```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n\\t#storing the elememts of nums in map to count their occurrance in the list\\n        d = {}\\n        for i in nums:\\n            if i not in d:\\n                d[i]= 1\\n            else:\\n                d[i]+=1\\n\\t\\t#update the nums value to the key list of dictionary and sorted the nums\\n        nums = list(d.keys())\\n        nums.sort()\\n        cnt = 0\\n\\t\\t#created a function to calculate the gcd of the whole element of the numsDivide list\\n        def GcdOfArray(arr, idx):\\n            if idx == len(arr)-1:\\n                return arr[idx]\\n\\n            a = arr[idx]\\n            b = GcdOfArray(arr,idx+1)\\n\\n            return math.gcd(a, b)\\n        gcd = GcdOfArray(numsDivide,0)\\n        ans = 0\\n\\t\\t#if the gcd of numsDivide list is divisible by the any value of the nums as nums is sorted in ascending order  then we will break the loop then we will return the cnt  otherwise we will return -1\\n        for ele in nums:\\n            if gcd%ele==0:\\n                ans = ele\\n                break\\n            else:\\n                cnt+=d[ele]\\n        if ans==0:\\n            return -1\\n        else:\\n            return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n\\t#storing the elememts of nums in map to count their occurrance in the list\\n        d = {}\\n        for i in nums:\\n            if i not in d:\\n                d[i]= 1\\n            else:\\n                d[i]+=1\\n\\t\\t#update the nums value to the key list of dictionary and sorted the nums\\n        nums = list(d.keys())\\n        nums.sort()\\n        cnt = 0\\n\\t\\t#created a function to calculate the gcd of the whole element of the numsDivide list\\n        def GcdOfArray(arr, idx):\\n            if idx == len(arr)-1:\\n                return arr[idx]\\n\\n            a = arr[idx]\\n            b = GcdOfArray(arr,idx+1)\\n\\n            return math.gcd(a, b)\\n        gcd = GcdOfArray(numsDivide,0)\\n        ans = 0\\n\\t\\t#if the gcd of numsDivide list is divisible by the any value of the nums as nums is sorted in ascending order  then we will break the loop then we will return the cnt  otherwise we will return -1\\n        for ele in nums:\\n            if gcd%ele==0:\\n                ans = ele\\n                break\\n            else:\\n                cnt+=d[ele]\\n        if ans==0:\\n            return -1\\n        else:\\n            return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748277,
                "title": "java-solution-easy-to-understand-shorting-and-gcd",
                "content": "```\\nclass Solution {\\n    public static int gcd(int a,int b) {\\n\\t\\tif (b == 0) return a;\\n\\t\\treturn gcd(b, a % b);\\n\\t}\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g=numsDivide[0];\\n\\t\\tArrays.sort(numsDivide);\\n\\t\\tfor(int i=0;i<numsDivide.length-1;i++) {\\n\\t\\t\\tif(numsDivide[i]==numsDivide[i+1]) continue;\\n\\t\\t\\telse g=gcd(g,numsDivide[i]);\\n\\t\\t}\\n\\t\\tg=gcd(g,numsDivide[numsDivide.length-1]);\\n\\t\\tint count=0;\\n\\t\\tArrays.sort(nums);\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(g%nums[i]==0) return count;\\n\\t\\t\\telse count++;\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int gcd(int a,int b) {\\n\\t\\tif (b == 0) return a;\\n\\t\\treturn gcd(b, a % b);\\n\\t}\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int g=numsDivide[0];\\n\\t\\tArrays.sort(numsDivide);\\n\\t\\tfor(int i=0;i<numsDivide.length-1;i++) {\\n\\t\\t\\tif(numsDivide[i]==numsDivide[i+1]) continue;\\n\\t\\t\\telse g=gcd(g,numsDivide[i]);\\n\\t\\t}\\n\\t\\tg=gcd(g,numsDivide[numsDivide.length-1]);\\n\\t\\tint count=0;\\n\\t\\tArrays.sort(nums);\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(g%nums[i]==0) return count;\\n\\t\\t\\telse count++;\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659901,
                "title": "my-easy-c-solution-50-faster-o-nlogn-time",
                "content": "**If you like it please up vote**\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++)\\n        {\\n            gcd= __gcd(gcd,numsDivide[i]);\\n        }\\n        cout<<gcd;\\n        sort(nums.begin(),nums.end());\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n                if(gcd%nums[i]==0)\\n                break;\\n            else\\n                c++;\\n        }\\n        if(c==nums.size())\\n            return -1;\\n        else\\n            return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++)\\n        {\\n            gcd= __gcd(gcd,numsDivide[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2587044,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int c = 0; // count\\n        priority_queue<int,vector<int>,greater<int>> pq; /// min heap\\n        int op = numsDivide[0];\\n        int n = numsDivide.size();\\n        for(int i = 1;i < n;i++){\\n            op = __gcd(op,numsDivide[i]); // as it will be the maximum number that will divide all the numbers \\n        }\\n        for(auto&i : nums){\\n            pq.push(i); // pushing all elements in the heap\\n        } \\n        while(!pq.empty()){ \\n            int temp = pq.top();\\n            pq.pop();\\n            if(op%temp == 0){ // if the minimum element divides the gcd return count at that time\\n                return c;\\n            }\\n            if(temp > op){ // if pq top become bigger than the find gcd then it returns -1\\n                return -1;\\n            }\\n            c++;\\n            \\n        }\\n        return -1; // means the heap got empty and no element divide the numsDivide array\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int c = 0; // count\\n        priority_queue<int,vector<int>,greater<int>> pq; /// min heap\\n        int op = numsDivide[0];\\n        int n = numsDivide.size();\\n        for(int i = 1;i < n;i++){\\n            op = __gcd(op,numsDivide[i]); // as it will be the maximum number that will divide all the numbers \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2551075,
                "title": "c-2-approaches-min-heap-and-gcd",
                "content": "**Approach - 1 : Using priority queue**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool divisible(vector<int>&nums, int x){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%x!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        for(auto &x : nums)\\n            pq.push(x);\\n        \\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            int x = pq.top(); // min element\\n            if(divisible(numsDivide, x))\\n                break;\\n            else\\n            {\\n                while(!pq.empty() and x==pq.top()){\\n                    pq.pop();\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans==nums.size() ? -1 : ans;\\n    }\\n};\\n```\\n\\n\\n**Intuition**\\nIf a number is divisible by the numbers in numsDivide then it must be divisible by the greatest common divisor of all the numbers in numsDivide.\\nThen we just need to find the smallest number satisfying this condition.\\n**Approach - 2  : Using GCD**\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int> &nums, vector<int> &numsDivide) \\n    {\\n        int gcd = numsDivide[0];\\n        for (int i = 1; i < numsDivide.size(); ++i)\\n            gcd = __gcd(gcd, numsDivide[i]);\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n            if (gcd % nums[i] == 0) \\n                return i;\\n        \\n        return -1;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool divisible(vector<int>&nums, int x){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%x!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        for(auto &x : nums)\\n            pq.push(x);\\n        \\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            int x = pq.top(); // min element\\n            if(divisible(numsDivide, x))\\n                break;\\n            else\\n            {\\n                while(!pq.empty() and x==pq.top()){\\n                    pq.pop();\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans==nums.size() ? -1 : ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int> &nums, vector<int> &numsDivide) \\n    {\\n        int gcd = numsDivide[0];\\n        for (int i = 1; i < numsDivide.size(); ++i)\\n            gcd = __gcd(gcd, numsDivide[i]);\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n            if (gcd % nums[i] == 0) \\n                return i;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369130,
                "title": "gcd",
                "content": "class Solution {\\n   \\n    public int gcd(int a,int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        \\n        return gcd(b, a % b);\\n    }\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        Arrays.sort(nums);\\n        int l = numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++)\\n        {\\n            l=gcd(l,numsDivide[i]);\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(l%nums[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    public int gcd(int a,int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        \\n        return gcd(b, a % b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2341538,
                "title": "c-solution-explanation",
                "content": "```\\n//for a given number to divide all the numbers in the array, it should always divide the highest common factor of the given set of numbers. Therefore, we first find the HCF of all numbers in numsDivide vector and then check if that HCF is divisible by any number in nums vector\\npublic:\\n    int gcd(int a, int b)\\n\\t{\\n    return b == 0 ? a : gcd(b, a % b);   \\n\\t}\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        int g=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++)\\n        {\\n            g=gcd(g,numsDivide[i]);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(g%nums[i]==0)\\n                return i;   //elements before i should be deleted\\n        }\\n            return -1; //return -1 if no number in nums vector is divisible by g\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n//for a given number to divide all the numbers in the array, it should always divide the highest common factor of the given set of numbers. Therefore, we first find the HCF of all numbers in numsDivide vector and then check if that HCF is divisible by any number in nums vector\\npublic:\\n    int gcd(int a, int b)\\n\\t{\\n    return b == 0 ? a : gcd(b, a % b);   \\n\\t}\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        int g=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++)\\n        {\\n            g=gcd(g,numsDivide[i]);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(g%nums[i]==0)\\n                return i;   //elements before i should be deleted\\n        }\\n            return -1; //return -1 if no number in nums vector is divisible by g\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2336711,
                "title": "c-161ms-faster-than-100-o-n-m-easy-explanation",
                "content": "1) number `n` divides all elements in array `arr` IFF `n` divides `GCD(arr)`, `GCD` being Greatest Common Divisor\\n2) GCD is associative: GCD(a,b,c) = GCD(GCD(a,b), c) = GCD(a, GCD(b,c)), so we can compute the GCD of the entire `numsDivide` array in a simple loop. I provided three solutions: my own GCD of a pair of numbers using Euclid\\'s algorithm, and two using the C++20\\'s `gcd` function.\\n3) After the GCD of `numsDivide` is found we can simply test all elements of `nums` if they divide the GCD, and then in a second loop how many elements are smaller than the lowest divisor found in the previous step. No need to sort.\\n\\n```\\nclass Solution {\\n    int GCD(vector<int> &num)\\n    {\\n        if(num.size() == 1)\\n            return num[0];\\n        int a = num.back();\\n        num.pop_back();\\n        while(num.size())\\n        {\\n            int b = num.back();\\n            num.pop_back();\\n            while(a != 0 and b != 0)\\n            {\\n                if(a > b)\\n                    a %= b;\\n                else\\n                    b %= a;\\n            }\\n            if(a == 0)\\n                a = b;\\n        }\\n        return a;\\n    }\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide)\\n    {\\n        // 1:\\n        int d = GCD(numsDivide);  // my own function\\n        \\n        // 2:\\n        //int d = numsDivide[0];\\n        //for(int k : numsDivide)\\n        //    d = gcd(d, k);\\n        \\n        // 3:\\n        //int d = accumulate(numsDivide.begin(), numsDivide.end(), numsDivide[0],\\n        //                   [](int &a, int &b) { return gcd(a,b); });\\n        \\n        // first pass: find the smallest element dividing d\\n        int s = 1000000001;\\n        for(int num : nums)\\n        {\\n            if(d % num == 0)\\n                if(num < s)\\n                    s = num;\\n        }\\n        if(s == 1000000001)\\n            return -1;\\n        //cout << s;\\n        // second pass: find the number of elements smaller than s\\n        int ret = 0;\\n        for(int num : nums)\\n        {\\n            if(num < s)\\n                ret++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int GCD(vector<int> &num)\\n    {\\n        if(num.size() == 1)\\n            return num[0];\\n        int a = num.back();\\n        num.pop_back();\\n        while(num.size())\\n        {\\n            int b = num.back();\\n            num.pop_back();\\n            while(a != 0 and b != 0)\\n            {\\n                if(a > b)\\n                    a %= b;\\n                else\\n                    b %= a;\\n            }\\n            if(a == 0)\\n                a = b;\\n        }\\n        return a;\\n    }\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide)\\n    {\\n        // 1:\\n        int d = GCD(numsDivide);  // my own function\\n        \\n        // 2:\\n        //int d = numsDivide[0];\\n        //for(int k : numsDivide)\\n        //    d = gcd(d, k);\\n        \\n        // 3:\\n        //int d = accumulate(numsDivide.begin(), numsDivide.end(), numsDivide[0],\\n        //                   [](int &a, int &b) { return gcd(a,b); });\\n        \\n        // first pass: find the smallest element dividing d\\n        int s = 1000000001;\\n        for(int num : nums)\\n        {\\n            if(d % num == 0)\\n                if(num < s)\\n                    s = num;\\n        }\\n        if(s == 1000000001)\\n            return -1;\\n        //cout << s;\\n        // second pass: find the number of elements smaller than s\\n        int ret = 0;\\n        for(int num : nums)\\n        {\\n            if(num < s)\\n                ret++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2323926,
                "title": "greatest-common-divisor",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int g = 0;\\n        for (auto x: numsDivide) {\\n            g = __gcd(g, x);\\n        }\\n        int N = nums.size();\\n        for (int i = 0; i < N; i ++) {\\n            if (g % nums[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nIf a number divides all numbers in `numsDivide`, then it should be able to divide the gcd of `numsDivide`\\nlet the gcd of `numsDivide` be **g**, the number be **x**\\nIf **x** is able to divide all numbers in `numsDivide`, then it is a common divisor of `numsDivide`, and if **g** is gcd, and **x** is a common divisor, then **x | g**\\nSo it is to find the smallest number divides **g**",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int g = 0;\\n        for (auto x: numsDivide) {\\n            g = __gcd(g, x);\\n        }\\n        int N = nums.size();\\n        for (int i = 0; i < N; i ++) {\\n            if (g % nums[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322709,
                "title": "c-easiest-of-all-hard-problems-gcd-simplest-explanation",
                "content": "# class Solution {\\n# public:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g=0;\\n        for(auto it : numsDivide){\\n            g=__gcd(g,it);\\n        }\\n        map<int,int> m;\\n        for(auto it : nums)\\n            m[it]++;\\n        int ans=0;\\n        for(auto it : m){\\n            if(g%it.first==0){\\n                break;\\n            }\\n            else{\\n                ans+=it.second;\\n            }\\n        }\\n        if(ans==nums.size())\\n            ans=-1;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g=0;\\n        for(auto it : numsDivide){\\n            g=__gcd(g,it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2319804,
                "title": "swift-three-liner",
                "content": "**Three-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func minOperations(_ nums: [Int], _ numsDivide: [Int]) -> Int {\\n        func gcd(_ i:Int, _ j:Int) -> Int { i > 0 ? gcd(j % i, i) : j }\\n        let gcdNumsDivide = Set(numsDivide).reduce(0) { gcd($0, $1) }\\n        return nums.sorted().firstIndex{ gcdNumsDivide % $0 == 0 } ?? -1\\n    }\\n}\\n```\\n**OPTIMIZATIONS:** \\n1. Use of `Set()` to remove duplicates from `numsDivide`. This reduced execution time, apparently test cases have many duplicates to punish code that doesn\\'t employ the \"optimization insight\" of the GCD.\\n2. *REMOVED:* Use of `lastValue` to avoid duplicate calculations of `gcdNumsDivide % $0 == 0`; this added some code, but did not improve execution times, so was removed from the above code.\\n\\n## **SOLUTION**\\n\\nStarting with the naive solution, note the inner loop can be reduced from an entire array scan to a single value, the Greatest Common Divisor. This is the \"optimization insight\" this interview problem is asking for, without identifying it, you\\'d be dinged points in the interview.\\n\\n**Naive Solution (LeetCode accepted answer, but wouldn\\'t look good in interview)**\\n```\\nclass Solution {\\n    func minOperations(_ nums: [Int], _ numsDivide: [Int]) -> Int {\\n        let nums = nums.sorted()\\n        outer: \\n\\t\\tfor i in nums.indices where i == 0 || nums[i-1] != nums[i] {\\n            for numDivide in numsDivide where numDivide % nums[i] != 0 {\\n                continue outer\\n            }\\n            return i\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minOperations(_ nums: [Int], _ numsDivide: [Int]) -> Int {\\n        func gcd(_ i:Int, _ j:Int) -> Int { i > 0 ? gcd(j % i, i) : j }\\n        let gcdNumsDivide = Set(numsDivide).reduce(0) { gcd($0, $1) }\\n        return nums.sorted().firstIndex{ gcdNumsDivide % $0 == 0 } ?? -1\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minOperations(_ nums: [Int], _ numsDivide: [Int]) -> Int {\\n        let nums = nums.sorted()\\n        outer: \\n\\t\\tfor i in nums.indices where i == 0 || nums[i-1] != nums[i] {\\n            for numDivide in numsDivide where numDivide % nums[i] != 0 {\\n                continue outer\\n            }\\n            return i\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318750,
                "title": "cpp-solution-using-priority-queue-and-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        priority_queue<int, vector <int>, greater<int>> pq;\\n        map <int, int> freq;\\n        int gcd = numsDivide[0];\\n        for(auto dd: numsDivide) {\\n            gcd = __gcd(gcd, dd);\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (freq.find(nums[i]) == freq.end()) \\n                pq.push(nums[i]);\\n            freq[nums[i]] += 1;\\n        }\\n        \\n        int  minDel = 0;\\n        while (pq.size() > 0) {\\n            int front = pq.top();\\n            pq.pop();\\n            if (gcd % front == 0)  return minDel;\\n            else minDel += freq[front];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        priority_queue<int, vector <int>, greater<int>> pq;\\n        map <int, int> freq;\\n        int gcd = numsDivide[0];\\n        for(auto dd: numsDivide) {\\n            gcd = __gcd(gcd, dd);\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (freq.find(nums[i]) == freq.end()) \\n                pq.push(nums[i]);\\n            freq[nums[i]] += 1;\\n        }\\n        \\n        int  minDel = 0;\\n        while (pq.size() > 0) {\\n            int front = pq.top();\\n            pq.pop();\\n            if (gcd % front == 0)  return minDel;\\n            else minDel += freq[front];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317481,
                "title": "c-with-sort-and-without-sort-solutions-detailed-explanation",
                "content": "**Idea:**\\n\\n* We compute GCD among all numbers to divide.\\n* Now, we know that the GCD divides all those numbers, and it\\'s the largest possible one.\\n* Then, we find the smallest element in the nums that can divide that GCD.\\n* we remove all the elements smaller than the above obtained number\\n\\n\\n**With Sort:**\\n\\n* if while checking the condition we found a number>gcd we can return -1\\n* because all the elements ahead of this number are greater than this so they will be obv greater than gcd and hence won\\'t divide gcd so we don\\'t need to check condition for them\\n\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    int minOperations(vector<int> &nums, vector<int> &numsDivide)\\n    {\\n        int n = nums.size(), nd = numsDivide.size();\\n        sort(nums.begin(), nums.end());\\n        int g = numsDivide[0];\\n        for (int i = 0; i < nd; i++)\\n            g = gcd(g, numsDivide[i]);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] > g)\\n                return -1;\\n            if (g % nums[i] == 0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n\\n**Without Sort**\\n\\n* maintain a min-heap to store the elements of nums\\n* now as it is a min heap so the top element will be the smallest one \\n* so follow the same approach as we did in the above code \\n* this time instead of traversing the sorted nums we have to traverse the minheap\\n* keep track of count variable\\n* count = how many number we have deleted\\n\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    int minOperations(vector<int> &nums, vector<int> &numsDivide)\\n    {\\n        int n = nums.size(), nd = numsDivide.size();\\n        int g = numsDivide[0];\\n        for (int i = 0; i < nd; i++)\\n            g = gcd(g, numsDivide[i]);\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto x : nums)\\n            pq.push(x);\\n        int count = 0;\\n        while (!pq.empty())\\n        {\\n            auto x = pq.top();\\n            pq.pop();\\n            if (x > g)\\n                return -1;\\n            if (g % x == 0)\\n                return count;\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    int minOperations(vector<int> &nums, vector<int> &numsDivide)\\n    {\\n        int n = nums.size(), nd = numsDivide.size();\\n        sort(nums.begin(), nums.end());\\n        int g = numsDivide[0];\\n        for (int i = 0; i < nd; i++)\\n            g = gcd(g, numsDivide[i]);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] > g)\\n                return -1;\\n            if (g % nums[i] == 0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    int minOperations(vector<int> &nums, vector<int> &numsDivide)\\n    {\\n        int n = nums.size(), nd = numsDivide.size();\\n        int g = numsDivide[0];\\n        for (int i = 0; i < nd; i++)\\n            g = gcd(g, numsDivide[i]);\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto x : nums)\\n            pq.push(x);\\n        int count = 0;\\n        while (!pq.empty())\\n        {\\n            auto x = pq.top();\\n            pq.pop();\\n            if (x > g)\\n                return -1;\\n            if (g % x == 0)\\n                return count;\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305317,
                "title": "c",
                "content": "class Solution {\\npublic:\\n\\n    int minOperations(vector<int>& a, vector<int>& b) {\\n        int c=b[0];\\n        for(int i=0;i<b.size();i++){\\n            c=__gcd(c,b[i]);\\n        }\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<a.size();i++){\\n            if(c%a[i]==0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minOperations(vector<int>& a, vector<int>& b) {\\n        int c=b[0];\\n        for(int i=0;i<b.size();i++){\\n            c=__gcd(c,b[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2302198,
                "title": "very-easy-gcd-based-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int Gc(vector<int>& arr){\\n    int ans=arr[0];\\n    for(auto it:arr)\\n    {\\n        ans=__gcd(ans,it);\\n    }\\n        return ans;\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& arr) {\\n        \\n        int gc = Gc(arr);\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(gc%nums[i]==0)\\n                return i;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Gc(vector<int>& arr){\\n    int ans=arr[0];\\n    for(auto it:arr)\\n    {\\n        ans=__gcd(ans,it);\\n    }\\n        return ans;\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& arr) {\\n        \\n        int gc = Gc(arr);\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(gc%nums[i]==0)\\n                return i;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302007,
                "title": "simple-gcd-concept-c",
                "content": "```\\n\\nint minOperations(vector<int> &nums, vector<int> &numsDivide){\\n    \\n    int g = numsDivide[0];\\n    for(auto x: numsDivide){\\n        g = gcd(g, x);\\n    }\\n    \\n    // g is the gcd of all the numbers in numsDiivde\\n    int ans = 0;\\n    for(auto x: nums){\\n        if(x < g){\\n            ans++;\\n        }\\n    }\\n    \\n    \\n    sort(begin(nums),end(nums));\\n    \\n    // to find the smallest number which divides all numbers in numsDivide, sort the array\\n    // if a number divides g, then it will divide all numebrs in numsDivide\\n    \\n    int cnt = 0;   // stores min number of deletion\\n    for(auto x: nums){\\n        if(g%x == 0){\\n            // x is a number which divides all numbers in numsDivide\\n            return cnt;\\n        }\\n        \\n        cnt++;\\n        \\n    }\\n    \\n    return -1;\\n\\n}\\n  \\n ```\\n\\nUpvote if it helped you! :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint minOperations(vector<int> &nums, vector<int> &numsDivide){\\n    \\n    int g = numsDivide[0];\\n    for(auto x: numsDivide){\\n        g = gcd(g, x);\\n    }\\n    \\n    // g is the gcd of all the numbers in numsDiivde\\n    int ans = 0;\\n    for(auto x: nums){\\n        if(x < g){\\n            ans++;\\n        }\\n    }\\n    \\n    \\n    sort(begin(nums),end(nums));\\n    \\n    // to find the smallest number which divides all numbers in numsDivide, sort the array\\n    // if a number divides g, then it will divide all numebrs in numsDivide\\n    \\n    int cnt = 0;   // stores min number of deletion\\n    for(auto x: nums){\\n        if(g%x == 0){\\n            // x is a number which divides all numbers in numsDivide\\n            return cnt;\\n        }\\n        \\n        cnt++;\\n        \\n    }\\n    \\n    return -1;\\n\\n}\\n  \\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300246,
                "title": "javascript-6-lines",
                "content": "Inspired by [lee215\\'s solution](https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/discuss/2292651/JavaC%2B%2BPython-GCD-O(n-%2B-m-%2B-log))\\n```\\nconst minOperations = (nums, numsDivide) => {\\n    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b)\\n    const g = numsDivide.reduce(gcd)\\n    \\n    nums.sort((a, b) => a - b)\\n\\n    for (let i = 0; i < nums.length && nums[i] <= g; i++)\\n        if (g % nums[i] === 0) return i\\n    \\n    return -1\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Inspired by [lee215\\'s solution](https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/discuss/2292651/JavaC%2B%2BPython-GCD-O(n-%2B-m-%2B-log))\\n```\\nconst minOperations = (nums, numsDivide) => {\\n    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b)\\n    const g = numsDivide.reduce(gcd)\\n    \\n    nums.sort((a, b) => a - b)\\n\\n    for (let i = 0; i < nums.length && nums[i] <= g; i++)\\n        if (g % nums[i] === 0) return i\\n    \\n    return -1\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2300182,
                "title": "c-solution-using-gcd-and-sorting",
                "content": "Steps:\\n1. Sort nums vector.\\n2. Find GCD of all the elements of numsDivide vector. \\n3. Iterate through nums vector(sorted one ofcourse), once you find the smallest number nums[i] divisible by GCD,return i.\\n4. If no such index is found, return -1.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end()); //step1\\n        int gcd = numsDivide[0];\\n        for(int i=1; i<numsDivide.size(); i++)\\n        {\\n            gcd = __gcd(gcd, numsDivide[i]); //step2\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(gcd%nums[i]==0)\\n            {\\n                return i; //step3\\n            }\\n        }\\n        return -1; //step4\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end()); //step1\\n        int gcd = numsDivide[0];\\n        for(int i=1; i<numsDivide.size(); i++)\\n        {\\n            gcd = __gcd(gcd, numsDivide[i]); //step2\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(gcd%nums[i]==0)\\n            {\\n                return i; //step3\\n            }\\n        }\\n        return -1; //step4\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299868,
                "title": "easy-to-understand-javascript-solution-with-comments",
                "content": "```\\nvar minOperations = function(nums, numsDivide) {\\n    \\n\\t//First, we have to find the common divisor for all the elements of array\\n    let cmn_int = null\\n\\t//if the length of the array is 1\\n    if(numsDivide.length == 1){\\n        cmn_int = numsDivide[0]\\n\\t//if the length > 1, getting the first and second num\\n    }else{\\n        cmn_int = gcd(numsDivide[0], numsDivide[1])\\n\\t\\t//for each iteration, we find the gcd\\n        for(let i = 2; i<numsDivide.length; i++){\\n            cmn_int = gcd(cmn_int, numsDivide[i])\\n        }\\n    }\\n       \\n    let count = 0\\n\\t//sort the numsDivide in an ascending order\\n    nums.sort((a, b) => a-b)\\n\\t\\n\\t//check whether the gcd is divisible by the current item\\n    for(let i = 0; i<nums.length; i++){\\n\\t\\t//if not divisible, increment count\\n        if(cmn_int % nums[i] != 0){\\n            count++\\n            continue\\n\\t\\t//if divisible, break the loop => we found the num\\n        }else{\\n            break\\n        }\\n    }\\n    \\n    return count == nums.length ? -1 : count\\n        \\n\\t//a reusable function for finding the greatest common divisor\\t\\n    function gcd(x, y) {\\n        if (y === 0) return x;\\n        return gcd(y, x % y);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(nums, numsDivide) {\\n    \\n\\t//First, we have to find the common divisor for all the elements of array\\n    let cmn_int = null\\n\\t//if the length of the array is 1\\n    if(numsDivide.length == 1){\\n        cmn_int = numsDivide[0]\\n\\t//if the length > 1, getting the first and second num\\n    }else{\\n        cmn_int = gcd(numsDivide[0], numsDivide[1])\\n\\t\\t//for each iteration, we find the gcd\\n        for(let i = 2; i<numsDivide.length; i++){\\n            cmn_int = gcd(cmn_int, numsDivide[i])\\n        }\\n    }\\n       \\n    let count = 0\\n\\t//sort the numsDivide in an ascending order\\n    nums.sort((a, b) => a-b)\\n\\t\\n\\t//check whether the gcd is divisible by the current item\\n    for(let i = 0; i<nums.length; i++){\\n\\t\\t//if not divisible, increment count\\n        if(cmn_int % nums[i] != 0){\\n            count++\\n            continue\\n\\t\\t//if divisible, break the loop => we found the num\\n        }else{\\n            break\\n        }\\n    }\\n    \\n    return count == nums.length ? -1 : count\\n        \\n\\t//a reusable function for finding the greatest common divisor\\t\\n    function gcd(x, y) {\\n        if (y === 0) return x;\\n        return gcd(y, x % y);\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298143,
                "title": "c-brute-force-and-optimised",
                "content": "* **Solution-1 (Brute-Force --> 375ms)**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int dels = 0 ;\\n        multiset<int> ms(begin(nums),end(nums)) ;\\n        while(ms.size()){\\n            int small = *begin(ms);\\n            bool good = true ;\\n            for(auto &x : numsDivide) if(x % small) {good = false ; break; }\\n            if(!good){\\n                dels += ms.count(small) ;\\n                ms.erase(small) ;\\n            } else break ;\\n            \\n        }\\n        \\n        return ms.size() ? dels : -1;\\n        \\n    }\\n};\\n```\\n\\n* **Solution-2(Better --> 173ms)**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(begin(nums),end(nums)) ;\\n        int GCD = numsDivide[0] ;\\n        \\n        for(int i = 1 ; i < numsDivide.size() ; ++i ) GCD = __gcd(GCD,numsDivide[i]);\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            if(GCD % nums[i] == 0) return i ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int dels = 0 ;\\n        multiset<int> ms(begin(nums),end(nums)) ;\\n        while(ms.size()){\\n            int small = *begin(ms);\\n            bool good = true ;\\n            for(auto &x : numsDivide) if(x % small) {good = false ; break; }\\n            if(!good){\\n                dels += ms.count(small) ;\\n                ms.erase(small) ;\\n            } else break ;\\n            \\n        }\\n        \\n        return ms.size() ? dels : -1;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(begin(nums),end(nums)) ;\\n        int GCD = numsDivide[0] ;\\n        \\n        for(int i = 1 ; i < numsDivide.size() ; ++i ) GCD = __gcd(GCD,numsDivide[i]);\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            if(GCD % nums[i] == 0) return i ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296900,
                "title": "scala-functional-solution-using-indexwhere",
                "content": "```\\n  def minOperations(nums: Array[Int], numsDivide: Array[Int]): Int = {\\n    val g = numsDivide.reduce(gcd)\\n    nums.sorted.indexWhere { n =>\\n      if (n > g) return -1\\n      g % n == 0\\n    }\\n  }\\n    \\n  @annotation.tailrec\\n  def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n```",
                "solutionTags": [],
                "code": "```\\n  def minOperations(nums: Array[Int], numsDivide: Array[Int]): Int = {\\n    val g = numsDivide.reduce(gcd)\\n    nums.sorted.indexWhere { n =>\\n      if (n > g) return -1\\n      g % n == 0\\n    }\\n  }\\n    \\n  @annotation.tailrec\\n  def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2296896,
                "title": "did-simple-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, vector<int>& b) {\\n        \\n        \\n        \\n        vector<int > res;\\n        sort(a.begin(),a.end());\\n        \\n        bool f, ans = false;\\n        int cnt = 0;\\n        for(int i = 0;i <a.size();i++)\\n        {\\n            f=false;\\n            for(int j = 0;j< b.size();j++)\\n            {\\n                if(b[j]%a[i]!=0)\\n                {\\n                    int temp = i;\\n                    while(i+1<a.size() && a[i] == a[i+1])\\n                    {\\n                        i++;\\n                    }\\n                    cnt+=i-temp+1;\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!f){\\n                ans = true;\\n                break;\\n            }\\n        }\\n        \\n        return ans?cnt:-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, vector<int>& b) {\\n        \\n        \\n        \\n        vector<int > res;\\n        sort(a.begin(),a.end());\\n        \\n        bool f, ans = false;\\n        int cnt = 0;\\n        for(int i = 0;i <a.size();i++)\\n        {\\n            f=false;\\n            for(int j = 0;j< b.size();j++)\\n            {\\n                if(b[j]%a[i]!=0)\\n                {\\n                    int temp = i;\\n                    while(i+1<a.size() && a[i] == a[i+1])\\n                    {\\n                        i++;\\n                    }\\n                    cnt+=i-temp+1;\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(!f){\\n                ans = true;\\n                break;\\n            }\\n        }\\n        \\n        return ans?cnt:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296778,
                "title": "java-clean-simple-no-sorting-o-n-4-6-ms",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int target = numsDivide[0];\\n\\n        for (int item : numsDivide)\\n            target = gcd(target, item);\\n\\n        int min = Integer.MAX_VALUE;\\n        int result = 0;\\n\\n        for (int item : nums) {\\n            if (item >= min)\\n                continue;\\n\\n            if (target % item == 0)\\n                min = item;\\n        }\\n\\n        if (min == Integer.MAX_VALUE)\\n            return -1;\\n\\n        for (int item : nums) {\\n            if (item < min)\\n                result++;\\n        }\\n\\n        return result;\\n    }\\n\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int temp = a;\\n            a = b;\\n            b = temp % b;\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int target = numsDivide[0];\\n\\n        for (int item : numsDivide)\\n            target = gcd(target, item);\\n\\n        int min = Integer.MAX_VALUE;\\n        int result = 0;\\n\\n        for (int item : nums) {\\n            if (item >= min)\\n                continue;\\n\\n            if (target % item == 0)\\n                min = item;\\n        }\\n\\n        if (min == Integer.MAX_VALUE)\\n            return -1;\\n\\n        for (int item : nums) {\\n            if (item < min)\\n                result++;\\n        }\\n\\n        return result;\\n    }\\n\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int temp = a;\\n            a = b;\\n            b = temp % b;\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295936,
                "title": "c-solution-using-gcd-and-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nm, vector<int>& nums) {\\n        int gcd=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            gcd=__gcd(gcd,nums[i]);\\n        unordered_map<int,int> mp;\\n        for(auto i:nm)\\n            mp[i]+=1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(auto i:mp)\\n            pq.push({i.first,i.second});\\n        int cnt=0;\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().first;\\n            int y=pq.top().second;\\n            if(gcd%x==0)\\n                return cnt;\\n            cnt+=y;\\n            pq.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nm, vector<int>& nums) {\\n        int gcd=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            gcd=__gcd(gcd,nums[i]);\\n        unordered_map<int,int> mp;\\n        for(auto i:nm)\\n            mp[i]+=1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(auto i:mp)\\n            pq.push({i.first,i.second});\\n        int cnt=0;\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().first;\\n            int y=pq.top().second;\\n            if(gcd%x==0)\\n                return cnt;\\n            cnt+=y;\\n            pq.pop();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295647,
                "title": "c-gcd-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        \\n        for(int i=1;i<numsDivide.size();i++)\\n            gcd= __gcd(gcd,numsDivide[i]);\\n        \\n\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(gcd%nums[i]==0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        \\n        for(int i=1;i<numsDivide.size();i++)\\n            gcd= __gcd(gcd,numsDivide[i]);\\n        \\n\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(gcd%nums[i]==0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295580,
                "title": "java-100-faster-easy-simple-gcd-of-all-elements",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/edbf7565-fc3f-4e82-b677-818fc463c81b_1658066942.484054.png)\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        final int gcdAll = gcd(numsDivide);\\n        \\n        int minEle = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if ((gcdAll % num == 0) && num < minEle) {\\n                minEle = num;\\n            }\\n        }\\n        \\n        if (minEle == Integer.MAX_VALUE) return -1;\\n        \\n        int eleToDelete = 0;\\n        for (int num : nums) {\\n            if (num < minEle) eleToDelete++;\\n        }\\n        \\n        return eleToDelete;\\n    }\\n    \\n    private int gcd(int[] arr) {\\n        int res = arr[0]; \\n        for (int ele : arr) {\\n            res = gcd(res, ele);\\n        }\\n        return res;\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        while (a != 0) {\\n            int rem = b % a;\\n            b = a;\\n            a = rem;\\n        }\\n        return b;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        final int gcdAll = gcd(numsDivide);\\n        \\n        int minEle = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if ((gcdAll % num == 0) && num < minEle) {\\n                minEle = num;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2295010,
                "title": "c-easy-gcd-implementation-based-question",
                "content": "```\\nclass Solution {\\npublic:\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n    {\\n        return b;\\n    }\\n    else\\n    {\\n        return gcd(b % a, a);\\n    }\\n}\\nint minOperations(vector<int> &arr, vector<int> &arr2)\\n{\\n    int mygcd = arr2[0];\\n    for (int i = 1; i < arr2.size(); i++)\\n    {\\n        mygcd = gcd(mygcd, arr2[i]);\\n    }\\n    multiset<int> st;\\n    for (int i = 0; i < arr.size(); i++)\\n    {\\n        st.insert(arr[i]);\\n    }\\n\\n    int count = 0;\\n    for (auto it : st)\\n    {\\n        if (mygcd % it == 0)\\n        {\\n            break;\\n        }\\n        else\\n        {\\n            count++;\\n        }\\n    }\\n    if (count == arr.size())\\n    {\\n        return -1;\\n    }\\n    else\\n    {\\n        return count;\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n    {\\n        return b;\\n    }\\n    else\\n    {\\n        return gcd(b % a, a);\\n    }\\n}\\nint minOperations(vector<int> &arr, vector<int> &arr2)\\n{\\n    int mygcd = arr2[0];\\n    for (int i = 1; i < arr2.size(); i++)\\n    {\\n        mygcd = gcd(mygcd, arr2[i]);\\n    }\\n    multiset<int> st;\\n    for (int i = 0; i < arr.size(); i++)\\n    {\\n        st.insert(arr[i]);\\n    }\\n\\n    int count = 0;\\n    for (auto it : st)\\n    {\\n        if (mygcd % it == 0)\\n        {\\n            break;\\n        }\\n        else\\n        {\\n            count++;\\n        }\\n    }\\n    if (count == arr.size())\\n    {\\n        return -1;\\n    }\\n    else\\n    {\\n        return count;\\n    }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294885,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        counter = Counter(nums)\\n        setDivide = set(numsDivide)\\n        \\n        result = 0\\n        minimum = float(\"inf\")\\n        \\n        for i in sorted(set(nums)):\\n            flag = True\\n            for k in setDivide:\\n                if k % i != 0:\\n                    flag = False\\n                    break\\n            if flag == False:\\n                result+=counter[i]\\n            else:\\n                return result\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        counter = Counter(nums)\\n        setDivide = set(numsDivide)\\n        \\n        result = 0\\n        minimum = float(\"inf\")\\n        \\n        for i in sorted(set(nums)):\\n            flag = True\\n            for k in setDivide:\\n                if k % i != 0:\\n                    flag = False\\n                    break\\n            if flag == False:\\n                result+=counter[i]\\n            else:\\n                return result\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294484,
                "title": "java-easy-gcd-priorityqueue-without-sorting",
                "content": "We find the smallest element that is the factor of the HCF (Highest Common Factor aka GCD) of all the elements in numsDivide.\\n\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int min = numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            min = hcf(min, numsDivide[i]);\\n        }\\n                \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num:nums){\\n            pq.add(num);\\n        }\\n        \\n        int ans = 0;\\n        int removed = -1;\\n        while(pq.size()>0 && pq.peek()<min){\\n            removed = pq.remove();\\n            \\n            ans++;\\n            if(min%removed==0) return ans-1;\\n        }\\n        \\n        if(pq.size()!=0 && pq.peek()==min) return ans;\\n        \\n        return -1;\\n        \\n        \\n        \\n    }\\n    \\n    private int hcf(int a, int b){\\n        if(b==0) return a;\\n        return hcf(b, a%b);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int min = numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            min = hcf(min, numsDivide[i]);\\n        }\\n                \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num:nums){\\n            pq.add(num);\\n        }\\n        \\n        int ans = 0;\\n        int removed = -1;\\n        while(pq.size()>0 && pq.peek()<min){\\n            removed = pq.remove();\\n            \\n            ans++;\\n            if(min%removed==0) return ans-1;\\n        }\\n        \\n        if(pq.size()!=0 && pq.peek()==min) return ans;\\n        \\n        return -1;\\n        \\n        \\n        \\n    }\\n    \\n    private int hcf(int a, int b){\\n        if(b==0) return a;\\n        return hcf(b, a%b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294339,
                "title": "2344-minimum-deletions-to-make-array-divisible-c-accepted-solution-o-nlg2n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            hcf=__gcd(hcf,numsDivide[i]);//highest value wich can divide all\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=hcf){\\n                if(hcf%nums[i]==0){\\n                    return i;\\n                }\\n            }else{\\n                return -1;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            hcf=__gcd(hcf,numsDivide[i]);//highest value wich can divide all\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=hcf){\\n                if(hcf%nums[i]==0){\\n                    return i;\\n                }\\n            }else{\\n                return -1;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294154,
                "title": "c-simple-gcd-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/\\n    \\n    Since we want to find the smallest number from nums that can divide all the nums in numsDivide, we need to\\n    find the smallest number also that divides all the numbers of numsDivide.\\n    So we use GCD (HCF) to find the smallest number that divides all of them.\\n    \\n    Then we use a set to save the numbers of nums with their frequency and iterate from smallest to largest.\\n    If a number doesnt divide the HCF, that will account towards delete operation, do till the first number that divides the HCF.\\n    \\n    TC: O(nlogm), n = no. of numbers, m = max number\\n    Finding the GCD of two numbers take log(max(a, b)) and we do this for all n numbers\\n    \\n    SC: O(unique_nums)\\n    \\n    \\n*/\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        // Find the HCF (GCD) of the numbers\\n        // This is the smallest number that can divide all the numbers\\n        int hcf = numsDivide[0];\\n        for(int i = 1; i < numsDivide.size(); i++)\\n            hcf = __gcd(hcf, numsDivide[i]);\\n        \\n        // Find the frequency count for each number\\n        // and store in height balanced tree \\n        // <num, count>\\n        map<int, int> elements;\\n        for(auto num: nums)\\n            ++elements[num];\\n        \\n        // Iterate through the numbers in non-decreasing order\\n        // If a number can\\'t divide the HCF, that needs to be deleted\\n        // If the number can divide the HCF, then that is the answer\\n        int ops = 0;\\n        for(auto [num, freq]: elements) {\\n            if(hcf % num == 0)\\n                return ops;\\n            ops += freq;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/\\n    \\n    Since we want to find the smallest number from nums that can divide all the nums in numsDivide, we need to\\n    find the smallest number also that divides all the numbers of numsDivide.\\n    So we use GCD (HCF) to find the smallest number that divides all of them.\\n    \\n    Then we use a set to save the numbers of nums with their frequency and iterate from smallest to largest.\\n    If a number doesnt divide the HCF, that will account towards delete operation, do till the first number that divides the HCF.\\n    \\n    TC: O(nlogm), n = no. of numbers, m = max number\\n    Finding the GCD of two numbers take log(max(a, b)) and we do this for all n numbers\\n    \\n    SC: O(unique_nums)\\n    \\n    \\n*/\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        // Find the HCF (GCD) of the numbers\\n        // This is the smallest number that can divide all the numbers\\n        int hcf = numsDivide[0];\\n        for(int i = 1; i < numsDivide.size(); i++)\\n            hcf = __gcd(hcf, numsDivide[i]);\\n        \\n        // Find the frequency count for each number\\n        // and store in height balanced tree \\n        // <num, count>\\n        map<int, int> elements;\\n        for(auto num: nums)\\n            ++elements[num];\\n        \\n        // Iterate through the numbers in non-decreasing order\\n        // If a number can\\'t divide the HCF, that needs to be deleted\\n        // If the number can divide the HCF, then that is the answer\\n        int ops = 0;\\n        for(auto [num, freq]: elements) {\\n            if(hcf % num == 0)\\n                return ops;\\n            ops += freq;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293786,
                "title": "gcd-java-faster-solution",
                "content": "How to Think ?\\n\\nStep-1 :  Find the greatest Common divisor in numsDivide Array .\\n\\nStep-2 : Sort the nums array so that we can check the smallest element that can divide the gcd of numsdivide array.\\n\\nStep-3 : If we find any element that divides gcd of numsdivide array , return index of nums array.\\n\\n\\nCheckout My Easy to Understand java solution : -\\n\\n\\n```\\nclass Solution {\\n    \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        \\n        int val=numsDivide[0];\\n        \\n        \\n        for(int i=1;i<numsDivide.length;i++)\\n        {\\n              \\n          int ngcd = gcd(val,numsDivide[i]);\\n           \\n          val=ngcd;  \\n            \\n        }\\n        \\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(val%nums[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n           return gcd(b,a%b);    \\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        \\n        int val=numsDivide[0];\\n        \\n        \\n        for(int i=1;i<numsDivide.length;i++)\\n        {\\n              \\n          int ngcd = gcd(val,numsDivide[i]);\\n           \\n          val=ngcd;  \\n            \\n        }\\n        \\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(val%nums[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n           return gcd(b,a%b);    \\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293728,
                "title": "gcd-c-easy-solution-finding-divisors",
                "content": "We have to first find the gcd or greatest common divisor of all the numbers in numsDivide, then we have to prime factorise it and find the divisors; Then we have to check whether any of the divisors obtained is present in nums arrays, if it is present, we take the smallest divisor present in the nums array.\\n\\nHappy coding\\n...\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        int check = 0;\\n        \\n        for(int i = 0; i < numsDivide.size(); i++){\\n            check = __gcd(check, numsDivide[i]);\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        map <int, bool> mp;\\n        \\n        for(int i = 1; i*i <= check; i++){\\n            if(check % i == 0){\\n                mp[i] = true;\\n                mp[check/i] = true;\\n            }\\n        }\\n        \\n        int ans = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(mp[nums[i]] == true){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n...\\n\\n\\nImproved solution on further thought\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        int check = 0;\\n        \\n        for(int i = 0; i < numsDivide.size(); i++){\\n            check = __gcd(check, numsDivide[i]);\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int ans = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(check % nums[i] == 0){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        int check = 0;\\n        \\n        for(int i = 0; i < numsDivide.size(); i++){\\n            check = __gcd(check, numsDivide[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2293593,
                "title": "easy-c-gcd-solution",
                "content": "```\\nint minOperations(vector<int>& nums, vector<int>& d) {\\n        int g=d[0];\\n        for(int i=1;i<d.size();i++)g=__gcd(g,d[i]);\\n        sort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size();i++)if(g%nums[i]==0)return i;\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<int>& nums, vector<int>& d) {\\n        int g=d[0];\\n        for(int i=1;i<d.size();i++)g=__gcd(g,d[i]);\\n        sort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size();i++)if(g%nums[i]==0)return i;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293266,
                "title": "gcd-c-short-with-math",
                "content": "**Approach I : Brute Force**\\n**Status : TLE**\\n**Time Complexity : O(n^2)**\\n```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0;\\n        for(auto i=0; i<nums.size(); i++){\\n            int di = 0;\\n            for(int j=0; j<numsDivide.size(); j++){\\n                if(numsDivide[j] % nums[i] != 0) break;\\n                else{\\n                    di++;\\n                }\\n                if(di == numsDivide.size()) return cnt;\\n                \\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n```\\n**Approach II : Optimize (using GCD)**\\n**Status : Accepted**\\n**Time Complexity : O(nlog(n))**\\n```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int g = numsDivide[0];\\n        for(const int &ele:numsDivide) {\\n            g = __gcd(g, ele); \\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(g % nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0;\\n        for(auto i=0; i<nums.size(); i++){\\n            int di = 0;\\n            for(int j=0; j<numsDivide.size(); j++){\\n                if(numsDivide[j] % nums[i] != 0) break;\\n                else{\\n                    di++;\\n                }\\n                if(di == numsDivide.size()) return cnt;\\n                \\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n```\n```\\nint minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int g = numsDivide[0];\\n        for(const int &ele:numsDivide) {\\n            g = __gcd(g, ele); \\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(g % nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293201,
                "title": "gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    int GcdOfArray(vector<int>& arr, int idx){\\n    if (idx == arr.size() - 1) {\\n        return arr[idx];\\n    }\\n    int a = arr[idx];\\n    int b = GcdOfArray(arr, idx + 1);\\n    return __gcd(a, b);\\n}\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int mini = GcdOfArray(numsDivide,0);\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(mini%nums[i]==0)return i;\\n            if(nums[i]>mini)return -1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nTC : **O(N logN)**(*for gcd*) + **O(N logN)** (*for sorting*) +**O(N)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int GcdOfArray(vector<int>& arr, int idx){\\n    if (idx == arr.size() - 1) {\\n        return arr[idx];\\n    }\\n    int a = arr[idx];\\n    int b = GcdOfArray(arr, idx + 1);\\n    return __gcd(a, b);\\n}\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int mini = GcdOfArray(numsDivide,0);\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(mini%nums[i]==0)return i;\\n            if(nums[i]>mini)return -1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293157,
                "title": "gcd-and-sorting",
                "content": "Approach : First compute gcd of all the numbers of numsdivide then simply find out the lowest number in nums array where (gcd%nums[i]==0). Finally return the count of the numbers from nums that is less than that nums[i],  else return -1.\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumber(vector<int>& nd)\\n    {\\n        int ans=nd[0];\\n        for(int i=0;i<nd.size();i++)\\n            ans=__gcd(ans,nd[i]);\\n        \\n        return ans;\\n    }\\n    \\n    int minOperations(vector<int>& n, vector<int>& nd) \\n    {\\n        sort(n.begin(),n.end());\\n        int res=findNumber(nd);\\n        \\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(res%n[i]==0)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\nUpvote if you like the solution...",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumber(vector<int>& nd)\\n    {\\n        int ans=nd[0];\\n        for(int i=0;i<nd.size();i++)\\n            ans=__gcd(ans,nd[i]);\\n        \\n        return ans;\\n    }\\n    \\n    int minOperations(vector<int>& n, vector<int>& nd) \\n    {\\n        sort(n.begin(),n.end());\\n        int res=findNumber(nd);\\n        \\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(res%n[i]==0)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293007,
                "title": "accepted-but-tc-is-more",
                "content": "class Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums, vector<int>& divide) {\\n        map<int,int>mp;\\n        for(auto it :nums)mp[it]++;\\n        int count=0;\\n\\n        for(auto it :mp){\\n           int check=1;\\n            for(auto ele: divide){\\n            if(ele%it.first!=0)check=0;\\n            }\\n            if(check==0)count+=it.second;\\n            else break;\\n     \\n        }\\n        return count==nums.size()?-1:count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums, vector<int>& divide) {\\n        map<int,int>mp;\\n        for(auto it :nums)mp[it]++;\\n        int count=0;\\n\\n        for(auto it :mp){\\n           int check=1;\\n            for(auto ele: divide){\\n            if(ele%it.first!=0)check=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2292966,
                "title": "c-gcd-easy-explanation-simple-solution",
                "content": "Just find the **GCD** of array **numsDivide**. Store the frequency of elements in **nums** in a map. Then start from the smallest element in **map** and check whether (**gcd%nums[i]==0**). If false, increase **bad** counter by its **frequency** in map else return **bad**.\\n\\n```\\nclass Solution {\\npublic:\\n    int findgcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    int returnGCD(vector<int>& arr){\\n        int n = arr.size();\\n        int result = arr[0];\\n        for (int i = 1; i < n; i++){\\n            result = gcd(arr[i], result);\\n            if(result == 1){\\n                return 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = returnGCD(numsDivide);\\n        int bad = 0;\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]]=1;\\n            }\\n            else{\\n                mp[nums[i]]++;\\n            }\\n        }\\n        \\n        for(auto it:mp){\\n            if(gcd % it.first == 0){\\n                return bad;\\n            }\\n            else{\\n                bad += it.second;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findgcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    int returnGCD(vector<int>& arr){\\n        int n = arr.size();\\n        int result = arr[0];\\n        for (int i = 1; i < n; i++){\\n            result = gcd(arr[i], result);\\n            if(result == 1){\\n                return 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = returnGCD(numsDivide);\\n        int bad = 0;\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]]=1;\\n            }\\n            else{\\n                mp[nums[i]]++;\\n            }\\n        }\\n        \\n        for(auto it:mp){\\n            if(gcd % it.first == 0){\\n                return bad;\\n            }\\n            else{\\n                bad += it.second;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292945,
                "title": "c-easy-solution",
                "content": "int gcd(int a,int b)\\n    {\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& nd) {\\n        \\n        int n = nums.size();\\n        int count = 0;\\n        int m = nd.size();\\n        \\n        int g = nd[0];\\n        for(int i=0;i<m;i++)\\n        {\\n            g = gcd(g,nd[i]);\\n        }\\n        \\n        // cout<<g;\\n        priority_queue<int,vector<int> ,greater<int> > pq(nums.begin(),nums.end());\\n        while(pq.size())\\n        {\\n            int k = pq.top();\\n            if(g%k!=0)\\n            {\\n                 pq.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                break;\\n            }  \\n        }\\n        if(pq.size()==0)return -1;\\n        return count;\\n        \\n        \\n   }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "int gcd(int a,int b)\\n    {\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& nd) {\\n        \\n        int n = nums.size();\\n        int count = 0;\\n        int m = nd.size();\\n        \\n        int g = nd[0];\\n        for(int i=0;i<m;i++)\\n        {\\n            g = gcd(g,nd[i]);\\n        }\\n        \\n        // cout<<g;\\n        priority_queue<int,vector<int> ,greater<int> > pq(nums.begin(),nums.end());\\n        while(pq.size())\\n        {\\n            int k = pq.top();\\n            if(g%k!=0)\\n            {\\n                 pq.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                break;\\n            }  \\n        }\\n        if(pq.size()==0)return -1;\\n        return count;\\n        \\n        \\n   }",
                "codeTag": "C++"
            },
            {
                "id": 2292922,
                "title": "python3-2-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e6b38b5fa8ff313543c0b854e395b2eddc7e8c93) for solutions of weekly 302. \\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = reduce(gcd, numsDivide)\\n        return next((i for i, x in enumerate(sorted(nums)) if g % x == 0), -1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = reduce(gcd, numsDivide)\\n        return next((i for i, x in enumerate(sorted(nums)) if g % x == 0), -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292864,
                "title": "java-easy-approach",
                "content": "```\\n    int gcd(int a, int b){\\n        if(b == 0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n        \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int divisor = numsDivide[0];\\n        for(int i: numsDivide)\\n            divisor = gcd(divisor, i);\\n        \\n        int l = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(divisor % nums[i] == 0){\\n                l = i;\\n                break;\\n                    \\n            }\\n        }\\n        \\n        return l;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    int gcd(int a, int b){\\n        if(b == 0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n        \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int divisor = numsDivide[0];\\n        for(int i: numsDivide)\\n            divisor = gcd(divisor, i);\\n        \\n        int l = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(divisor % nums[i] == 0){\\n                l = i;\\n                break;\\n                    \\n            }\\n        }\\n        \\n        return l;\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292832,
                "title": "c-easy-solution-map",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        map<int,int>mp;\\n        \\n        for(auto it:nums)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        int cnt = 0;\\n        bool flag = false;\\n       \\n        for(auto it : mp)\\n        {\\n            flag = true;\\n            \\n            for(auto i : numsDivide)\\n            {\\n                if(i % it.first == 0)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            \\n            if(!flag)\\n            {\\n                cnt += it.second;\\n                \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        if(cnt == nums.size()) return -1;\\n        else return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        map<int,int>mp;\\n        \\n        for(auto it:nums)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        int cnt = 0;\\n        bool flag = false;\\n       \\n        for(auto it : mp)\\n        {\\n            flag = true;\\n            \\n            for(auto i : numsDivide)\\n            {\\n                if(i % it.first == 0)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            \\n            if(!flag)\\n            {\\n                cnt += it.second;\\n                \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        if(cnt == nums.size()) return -1;\\n        else return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292800,
                "title": "c-gcd-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++)\\n        {\\n            hcf=gcd(hcf,numsDivide[i]);\\n        }\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        int res=0;\\n        for(auto x:m)\\n        {\\n            if(hcf%x.first)\\n                res+=x.second;\\n            else\\n                break;\\n        }\\n        if(res==nums.size())\\n            return -1;\\n        return res;\\n    }\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++)\\n        {\\n            hcf=gcd(hcf,numsDivide[i]);\\n        }\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        int res=0;\\n        for(auto x:m)\\n        {\\n            if(hcf%x.first)\\n                res+=x.second;\\n            else\\n                break;\\n        }\\n        if(res==nums.size())\\n            return -1;\\n        return res;\\n    }\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292696,
                "title": "with-explanation-c",
                "content": "**Observation:-**\\n1. Smallest number shoud divide all numbers of other array.So we have to remove smallest number if it is not dividing all number of numDivide.\\n2. How can we check if smalest number divide all numbers of numDivide or not?\\n3. What is the smallest number that can divide all numbers of numDivide? that is ```GCD of all number of numDivide.```Calculate it.\\n4. If there is a number that divide all the numbers of numDivide then that should be a divisor of ```GCD```\\n4. Then check if smallest number of nums can divide GCD or not if yes then we found answer if no then increase ans and move on.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& div) {\\n        int gcd=0,ans=0;\\n        for(auto & i:div)\\n            gcd=__gcd(i,gcd);\\n        sort(begin(nums),end(nums));\\n        for(auto &i:nums){\\n            if(gcd%i==0)\\n                break;\\n            ans++;\\n        }\\n        return ans==num.size()?-1:ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```GCD of all number of numDivide.```\n```GCD```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& div) {\\n        int gcd=0,ans=0;\\n        for(auto & i:div)\\n            gcd=__gcd(i,gcd);\\n        sort(begin(nums),end(nums));\\n        for(auto &i:nums){\\n            if(gcd%i==0)\\n                break;\\n            ans++;\\n        }\\n        return ans==num.size()?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292677,
                "title": "java-n-log-n-using-gcd",
                "content": "```\\nclass Solution {\\n    // O(numsDivide.length*log(numsDivide.length) + nums.length)   O(n*log(n))\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        //number divides all the numbers if it divides the greatest common divisor\\n        int divide = gcd(numsDivide);\\n        \\n        //sort array\\n        Arrays.sort(nums);\\n        \\n        //we try all the numbers in the array starting from smallest\\n        for(int i = 0; i < nums.length; i++) {\\n            if(divide % nums[i] == 0) {\\n                return i;\\n            }\\n            \\n            //short circuit\\n            if(nums[i] > divide) {\\n                return -1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    //greatest common divisor of 2 numbers\\n    private int gcd(int a, int b) {\\n        if (a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n    \\n    //greatest common divisor of an array\\n    private int gcd(int[] nums) {\\n        int out = nums[0];\\n        \\n        for(int num : nums) {\\n            out = gcd(out, num);\\n        }\\n        \\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // O(numsDivide.length*log(numsDivide.length) + nums.length)   O(n*log(n))\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        //number divides all the numbers if it divides the greatest common divisor\\n        int divide = gcd(numsDivide);\\n        \\n        //sort array\\n        Arrays.sort(nums);\\n        \\n        //we try all the numbers in the array starting from smallest\\n        for(int i = 0; i < nums.length; i++) {\\n            if(divide % nums[i] == 0) {\\n                return i;\\n            }\\n            \\n            //short circuit\\n            if(nums[i] > divide) {\\n                return -1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    //greatest common divisor of 2 numbers\\n    private int gcd(int a, int b) {\\n        if (a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n    \\n    //greatest common divisor of an array\\n    private int gcd(int[] nums) {\\n        int out = nums[0];\\n        \\n        for(int num : nums) {\\n            out = gcd(out, num);\\n        }\\n        \\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292621,
                "title": "java-easy-gcd",
                "content": "```\\n\\n//                      Important Point\\n// the number that divides every element of numDivide array has to \\n// divide the highest common factor (GCD) of that array\\n\\nclass Solution {    \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int hcf = findGCD(numsDivide);\\n        \\n        int count=0;\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(hcf%nums[i]==0) return count;\\n            count++;\\n        }\\n        return -1;\\n    }\\n    \\n    //recursive function for GCD of two numbers\\n    int gcd(int a, int b){\\n        if (a == 0)  return b;\\n        return gcd(b % a, a);\\n    }\\n \\n    //GCD of an array\\n    int findGCD(int arr[]){\\n        int result = arr[0];\\n        for (int element: arr){\\n            result = gcd(result, element);\\n \\n            if(result == 1){\\n               return 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\nPLEASE UPVOTE IF YOU UNDERSTOOD THE SOLUTION",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\n//                      Important Point\\n// the number that divides every element of numDivide array has to \\n// divide the highest common factor (GCD) of that array\\n\\nclass Solution {    \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int hcf = findGCD(numsDivide);\\n        \\n        int count=0;\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(hcf%nums[i]==0) return count;\\n            count++;\\n        }\\n        return -1;\\n    }\\n    \\n    //recursive function for GCD of two numbers\\n    int gcd(int a, int b){\\n        if (a == 0)  return b;\\n        return gcd(b % a, a);\\n    }\\n \\n    //GCD of an array\\n    int findGCD(int arr[]){\\n        int result = arr[0];\\n        for (int element: arr){\\n            result = gcd(result, element);\\n \\n            if(result == 1){\\n               return 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292587,
                "title": "c-gcd",
                "content": "```class Solution {\\npublic:\\n    int gcd(int n1, int n2)\\n    {\\n        if (n2 == 0)\\n           return n1;\\n        return gcd(n2,n1%n2);\\n    }\\n    int fun(vector<int>& num_num, vector<int>& numDivide_numDivide)\\n    {\\n        int ans=0;\\n        for(auto i:numDivide_numDivide)\\n        {\\n            ans=gcd(ans,i);\\n        }\\n        for(int i=0;i<num_num.size();i++)\\n        {\\n            if(ans%num_num[i]==0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    int minOperations(vector<int>& num_num, vector<int>& numDivide_numDivide) {\\n        sort(num_num.begin(),num_num.end());\\n        return fun(num_num,numDivide_numDivide);\\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    int gcd(int n1, int n2)\\n    {\\n        if (n2 == 0)\\n           return n1;\\n        return gcd(n2,n1%n2);\\n    }\\n    int fun(vector<int>& num_num, vector<int>& numDivide_numDivide)\\n    {\\n        int ans=0;\\n        for(auto i:numDivide_numDivide)\\n        {\\n            ans=gcd(ans,i);\\n        }\\n        for(int i=0;i<num_num.size();i++)\\n        {\\n            if(ans%num_num[i]==0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    int minOperations(vector<int>& num_num, vector<int>& numDivide_numDivide) {\\n        sort(num_num.begin(),num_num.end());\\n        return fun(num_num,numDivide_numDivide);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 4090009,
                "title": "c-min-heap-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=0;\\n        for(int i = 0;i <numsDivide.size();i++){\\n            gcd=__gcd(numsDivide[i],gcd);\\n        }\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int it:nums) pq.push(it);\\n        int c=0;\\n        while(!pq.empty()){\\n            int p=pq.top();\\n            pq.pop();\\n            if(gcd%p==0) return c;\\n            else if(p>gcd) return -1;\\n            c++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=0;\\n        for(int i = 0;i <numsDivide.size();i++){\\n            gcd=__gcd(numsDivide[i],gcd);\\n        }\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int it:nums) pq.push(it);\\n        int c=0;\\n        while(!pq.empty()){\\n            int p=pq.top();\\n            pq.pop();\\n            if(gcd%p==0) return c;\\n            else if(p>gcd) return -1;\\n            c++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075388,
                "title": "minimum-deletions-to-make-array-divisible",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        final int gcd = getGCD(numsDivide);\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < nums.length; ++i)\\n      if (gcd % nums[i] == 0)\\n        return i;\\n\\n    return -1;\\n  }\\n\\n  private int getGCD(int[] nums) {\\n    int g = nums[0];\\n    for (final int num : nums)\\n      g = gcd(g, num);\\n    return g;\\n  }\\n\\n  int gcd(int a, int b) {\\n    return b == 0 ? a : gcd(b, a % b);}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        final int gcd = getGCD(numsDivide);\\n\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i < nums.length; ++i)\\n      if (gcd % nums[i] == 0)\\n        return i;\\n\\n    return -1;\\n  }\\n\\n  private int getGCD(int[] nums) {\\n    int g = nums[0];\\n    for (final int num : nums)\\n      g = gcd(g, num);\\n    return g;\\n  }\\n\\n  int gcd(int a, int b) {\\n    return b == 0 ? a : gcd(b, a % b);}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057809,
                "title": "2-easy-solutions-gcd-sorting-gcd-2-passes",
                "content": "# Complexity\\n$n$ - size of `nums`, $m$ - size of `numsDivide`\\n\\n### 1. gcd + sorting\\n- Time complexity: $$O(n \\\\cdot log(n)) + O(m \\\\cdot log(m))$$\\nsee Euclidean algorithm\\'s efficiency ([wiki](https://en.wikipedia.org/wiki/Euclidean_algorithm#Algorithmic_efficiency))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (for TimSort)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### 2. gcd + 2 passes\\n- Time complexity: $$O(n) + O(m \\\\cdot log(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n### 1. gcd + sorting\\n\\n``` python3 []\\n# using math.gcd\\n\\nfrom math import gcd\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        \\n        result = 0\\n        for elem in sorted(nums):\\n            if g % elem == 0:\\n                return result\\n            result += 1\\n        return -1\\n```\\n\\n``` python3 []\\n# non using math.gcd\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        def gcd_2(a, b):\\n            a, b = max(a, b), min(a, b)\\n            while b != 0:\\n                a, b = b, a % b\\n            return a\\n\\n        def gcd_many(elems):\\n            result = elems[0]\\n            for i in range(1, len(elems)):\\n                result = gcd(result, elems[i])\\n            return result\\n        \\n        g = gcd_many(numsDivide)\\n        \\n        result = 0\\n        for elem in sorted(nums):\\n            if g % elem == 0:\\n                return result\\n            result += 1\\n        return -1\\n```\\n\\n### 2. gcd + 2 passes\\n\\n``` python3 []\\nfrom math import gcd\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        \\n        # 1 pass\\n        target = float(\\'inf\\')\\n        for elem in nums:\\n            if elem < target and g % elem == 0:\\n                target = elem\\n        \\n        if target == float(\\'inf\\'):\\n            return -1\\n        \\n        # 2 pass\\n        result = 0\\n        for elem in nums:\\n            if elem < target:\\n                result += 1\\n        return result\\n\\n```\\n\\n#### If you found this useful or interesting, please upvote!",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sorting",
                    "Number Theory"
                ],
                "code": "``` python3 []\\n# using math.gcd\\n\\nfrom math import gcd\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        \\n        result = 0\\n        for elem in sorted(nums):\\n            if g % elem == 0:\\n                return result\\n            result += 1\\n        return -1\\n```\n``` python3 []\\n# non using math.gcd\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        def gcd_2(a, b):\\n            a, b = max(a, b), min(a, b)\\n            while b != 0:\\n                a, b = b, a % b\\n            return a\\n\\n        def gcd_many(elems):\\n            result = elems[0]\\n            for i in range(1, len(elems)):\\n                result = gcd(result, elems[i])\\n            return result\\n        \\n        g = gcd_many(numsDivide)\\n        \\n        result = 0\\n        for elem in sorted(nums):\\n            if g % elem == 0:\\n                return result\\n            result += 1\\n        return -1\\n```\n``` python3 []\\nfrom math import gcd\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = gcd(*numsDivide)\\n        \\n        # 1 pass\\n        target = float(\\'inf\\')\\n        for elem in nums:\\n            if elem < target and g % elem == 0:\\n                target = elem\\n        \\n        if target == float(\\'inf\\'):\\n            return -1\\n        \\n        # 2 pass\\n        result = 0\\n        for elem in nums:\\n            if elem < target:\\n                result += 1\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036965,
                "title": "simple-gcd-based-solution-in-o-n-log-n-time-and-o-1-space",
                "content": "# Intuition\\nFirst find the gcd of the list numsDivide. Begin eliminating numbers from sorted nums list that do not divide computed gcd divisor. Once you find a num that divides divisor, then return count of eliminated numbers from nums.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        divisor = numsDivide[0]\\n        for i in range(1, len(numsDivide)):\\n            divisor = math.gcd(divisor, numsDivide[i])\\n        print(divisor)\\n        cnt = 0\\n        for n in sorted(nums):\\n            if n > divisor:\\n                break\\n            if divisor%n == 0:\\n                return cnt\\n            cnt += 1\\n        return -1\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        divisor = numsDivide[0]\\n        for i in range(1, len(numsDivide)):\\n            divisor = math.gcd(divisor, numsDivide[i])\\n        print(divisor)\\n        cnt = 0\\n        for n in sorted(nums):\\n            if n > divisor:\\n                break\\n            if divisor%n == 0:\\n                return cnt\\n            cnt += 1\\n        return -1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009590,
                "title": "simple-use-of-heap-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    find hcf of all the numbers and checking which number divides the hcf fully is the intuition for the given problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    We will find the HCF of all the elements of numsDivide. Then using a min heap we will sort all the elements. if the top element divides the HCF fully then we will return the answer otherwise we will remove all the occurences of the top element from the heap and count them in answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        int n=nums.size(),m=numsDivide.size();\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        //creating a min heap\\n        for(auto i:nums) pq.push(i);\\n        //pushing elements in the min heap\\n        for(int i=1;i<m;i++) hcf=__gcd(hcf,numsDivide[i]);\\n        //finding the HCF \\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            int k=pq.top();\\n            if(hcf%k==0) return ans; //checking if top element of the heap divides the HCF fully\\n            while(!pq.empty() && pq.top()==k) {pq.pop();ans++;}\\n            //removing the elements otherwise and adding them to answer\\n        }       \\n        //if no such element is found return -1\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)",
                    "Number Theory"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        int n=nums.size(),m=numsDivide.size();\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        //creating a min heap\\n        for(auto i:nums) pq.push(i);\\n        //pushing elements in the min heap\\n        for(int i=1;i<m;i++) hcf=__gcd(hcf,numsDivide[i]);\\n        //finding the HCF \\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            int k=pq.top();\\n            if(hcf%k==0) return ans; //checking if top element of the heap divides the HCF fully\\n            while(!pq.empty() && pq.top()==k) {pq.pop();ans++;}\\n            //removing the elements otherwise and adding them to answer\\n        }       \\n        //if no such element is found return -1\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3952066,
                "title": "straightforward-python-solution-using-gcd-and-sorting",
                "content": "# Intuition\\nIf $x$ divides $y$ and $y$ divides $z$, then $x$ divides $z$ (Transitive)\\nThe greatest common divisor (GCD) of a list of numbers is the largest number that divides all the numbers in the list. Moreover, any other common divisor of the list must also divide the GCD of the list: https://math.stackexchange.com/questions/362975/concise-proof-that-every-common-divisor-divides-gcd-without-bezouts-identity\\n\\n# Approach\\nFind the GCD of the list by reducing the list with `math.gcd`. Since $gcd(a, b, c) = gcd(gcd(a, b), c)$ we can take advantage of `functools.reduce` to express our intent clearly. Then we sort `nums` to look for the smallest number that divides the GCD.\\n\\n# Complexity\\nFix $m$ as the length of `nums`, $n$ as the length of `numsDivide`, and $k$ as the maximal element of `numsDivide`.\\n\\n- Time complexity:\\n$O(m \\\\log m + n \\\\log k)$. Euclid\\'s algorithm to find the GCD of two numbers $a, b$ with $a > b$ is $O(\\\\log a)$ and we apply it $n-1$ times. Sorting `nums` is $O(m \\\\log m)$.\\n\\n- Space complexity:\\n$O(m)$. With Python, `sort` will take $O(m)$ space. You can sort a list of numbers with $O(1)$ space, though.\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcdNumsDivide = reduce(gcd, numsDivide)\\n        nums.sort()\\n        for i, x in enumerate(nums):\\n            if gcdNumsDivide % x == 0: return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcdNumsDivide = reduce(gcd, numsDivide)\\n        nums.sort()\\n        for i, x in enumerate(nums):\\n            if gcdNumsDivide % x == 0: return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947755,
                "title": "ruby-solution-with-gcd-explained-100-100",
                "content": "# Intuition\\nAny number that divides everythin in nums_divide must divide the gcd of nums_divide.  Find the gcd, then go through nums in sorted order to find the first number that divides gcd.\\n\\n# Approach\\n1. Find the gcd of nums_divide.\\n2. Sort nums.\\n3. Iterate through nums.  If you get to a number that divides gcd, return the index i, because that\\'s how many numbers you have to delete from nums (every smaller number).\\n4. If nothing in nums divides gcd, return -1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(log(n))$$\\n\\n# Code\\n```\\ndef min_operations(nums, nums_divide)\\n    gcd = nums_divide.pop\\n    until nums_divide.empty?\\n        gcd = gcd.gcd(nums_divide.pop)\\n    end\\n\\n    nums.sort!\\n\\n    nums.each_with_index { |num,i| return i if gcd % num == 0 }\\n\\n    -1  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_operations(nums, nums_divide)\\n    gcd = nums_divide.pop\\n    until nums_divide.empty?\\n        gcd = gcd.gcd(nums_divide.pop)\\n    end\\n\\n    nums.sort!\\n\\n    nums.each_with_index { |num,i| return i if gcd % num == 0 }\\n\\n    -1  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3930144,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // 1. Go for the brute force approach by checking each number\\n    // 2. Find the HCF of 2nd array and then check(My solution) beats 50%\\n\\n    // else go for below code for better T.C\\n\\n    \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int target = numsDivide[0];\\n\\n        for (int item : numsDivide)\\n            target = gcd(target, item);\\n\\n        int min = Integer.MAX_VALUE;\\n        int result = 0;\\n\\n        for (int item : nums) {\\n            if (item >= min)\\n                continue;\\n\\n            if (target % item == 0)\\n                min = item;\\n        }\\n\\n        if (min == Integer.MAX_VALUE)\\n            return -1;\\n\\n        for (int item : nums) {\\n            if (item < min)\\n                result++;\\n        }\\n\\n        return result;\\n    }\\n\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int temp = a;\\n            a = b;\\n            b = temp % b;\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // 1. Go for the brute force approach by checking each number\\n    // 2. Find the HCF of 2nd array and then check(My solution) beats 50%\\n\\n    // else go for below code for better T.C\\n\\n    \\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int target = numsDivide[0];\\n\\n        for (int item : numsDivide)\\n            target = gcd(target, item);\\n\\n        int min = Integer.MAX_VALUE;\\n        int result = 0;\\n\\n        for (int item : nums) {\\n            if (item >= min)\\n                continue;\\n\\n            if (target % item == 0)\\n                min = item;\\n        }\\n\\n        if (min == Integer.MAX_VALUE)\\n            return -1;\\n\\n        for (int item : nums) {\\n            if (item < min)\\n                result++;\\n        }\\n\\n        return result;\\n    }\\n\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int temp = a;\\n            a = b;\\n            b = temp % b;\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928107,
                "title": "easy-sorting-gcd-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        sort(numsDivide.begin(),numsDivide.end());\\n        int x=numsDivide[0];\\n        if(numsDivide.size()>1){\\n            for(int i=1;i<numsDivide.size();i++){\\n                x=__gcd(x,numsDivide[i]);\\n\\n             }\\n\\n        }\\n        cout<<x<<endl;\\n        int count=0;\\n        int n=nums.size();\\n        for(auto it:nums){\\n            if(x%it==0){\\n                break;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count==n?-1:count;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        sort(numsDivide.begin(),numsDivide.end());\\n        int x=numsDivide[0];\\n        if(numsDivide.size()>1){\\n            for(int i=1;i<numsDivide.size();i++){\\n                x=__gcd(x,numsDivide[i]);\\n\\n             }\\n\\n        }\\n        cout<<x<<endl;\\n        int count=0;\\n        int n=nums.size();\\n        for(auto it:nums){\\n            if(x%it==0){\\n                break;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count==n?-1:count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3927671,
                "title": "python-simplest-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcd=numsDivide[0]\\n        for i in range(len(numsDivide)-1):\\n            gcd=math.gcd(gcd,math.gcd(numsDivide[i]),numsDivide[i+1])\\n        hashMap=defaultdict(int)\\n        for num in nums:\\n            hashMap[num]+=1\\n        ans=0\\n        for num in sorted(set(nums)):\\n            if gcd%num==0:\\n                return ans\\n            ans+=hashMap[num]\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcd=numsDivide[0]\\n        for i in range(len(numsDivide)-1):\\n            gcd=math.gcd(gcd,math.gcd(numsDivide[i]),numsDivide[i+1])\\n        hashMap=defaultdict(int)\\n        for num in nums:\\n            hashMap[num]+=1\\n        ans=0\\n        for num in sorted(set(nums)):\\n            if gcd%num==0:\\n                return ans\\n            ans+=hashMap[num]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885180,
                "title": "gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findGCD(int a, int b)\\n    {\\n        while (a > 0 && b > 0) {\\n            if (a > b) {\\n                a = a % b;\\n            }\\n            else {\\n                b = b % a;\\n            }\\n        }\\n        if (a == 0) {\\n            return b;\\n        }\\n        return a;\\n    }\\n\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        int n = numsDivide.size();\\n\\n        for(int i=1; i<n; i++)\\n            gcd = findGCD(gcd, numsDivide[i]);\\n\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(gcd%nums[i] == 0)\\n                return ans;\\n            ans++;\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findGCD(int a, int b)\\n    {\\n        while (a > 0 && b > 0) {\\n            if (a > b) {\\n                a = a % b;\\n            }\\n            else {\\n                b = b % a;\\n            }\\n        }\\n        if (a == 0) {\\n            return b;\\n        }\\n        return a;\\n    }\\n\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        int n = numsDivide.size();\\n\\n        for(int i=1; i<n; i++)\\n            gcd = findGCD(gcd, numsDivide[i]);\\n\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(gcd%nums[i] == 0)\\n                return ans;\\n            ans++;\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872830,
                "title": "100-time-beating-python-code",
                "content": "# Approach\\nThis code finds the minimum number of elements to delete from `nums` so that the smallest element in `nums` divides all the elements of `nums_divide`.\\n\\nThe approach is as follows:\\n\\n1. Count the number of occurrences of each element in `nums`.\\n2. Find the greatest common divisor of all the elements in `nums_divide`.\\n3. Iterate over the elements in `nums` in sorted order.\\n4. If the smallest element in `nums` divides all the elements of `nums_divide`, return the number of deletions so far.\\n5. Otherwise, increment the number of deletions by the number of occurrences of the element in `nums`.\\n6. If the function reaches the end of `nums` without finding a solution, return -1.\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], nums_divide: List[int]) -> int:\\n        # Count the number of occurrences of each element in nums.\\n        counts = Counter(nums)\\n\\n        # Find the greatest common divisor of all the elements in nums_divide.\\n        gcd_nums_divide = gcd(*nums_divide)\\n\\n        deletions = 0\\n\\n        # Iterate over the elements in nums in sorted order.\\n        for val in sorted(counts):\\n            # If the smallest element in nums divides all the elements of nums_divide, we have found the solution.\\n            if gcd_nums_divide % val == 0:\\n                return deletions\\n            # Otherwise, increment the number of deletions by the number of occurrences of val in nums.\\n            else:\\n                deletions += counts[val]\\n\\n        # If we reach this point, we did not find a solution.\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], nums_divide: List[int]) -> int:\\n        # Count the number of occurrences of each element in nums.\\n        counts = Counter(nums)\\n\\n        # Find the greatest common divisor of all the elements in nums_divide.\\n        gcd_nums_divide = gcd(*nums_divide)\\n\\n        deletions = 0\\n\\n        # Iterate over the elements in nums in sorted order.\\n        for val in sorted(counts):\\n            # If the smallest element in nums divides all the elements of nums_divide, we have found the solution.\\n            if gcd_nums_divide % val == 0:\\n                return deletions\\n            # Otherwise, increment the number of deletions by the number of occurrences of val in nums.\\n            else:\\n                deletions += counts[val]\\n\\n        # If we reach this point, we did not find a solution.\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870969,
                "title": "easy-to-understand-gcd-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity: \\n $$O(nlogn)$$\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& n2) {\\n        int g = 0;\\n        map<int,int> m;\\n        for(auto x : nums)m[x]++;\\n\\n        for(auto x : n2){\\n            g = __gcd(x,g);\\n        <!-- just checking whether min element is 1 or not  -->\\n            if(g == 1 && (*m.begin()).first > 1)return -1;\\n        }\\n\\n        int ans = 0;\\n        auto it = m.begin();\\n        while(g % (*it).first != 0 && it != m.end()){\\n            ans += (*it).second;\\n            it++;\\n        } \\n        if(ans == nums.size())return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& n2) {\\n        int g = 0;\\n        map<int,int> m;\\n        for(auto x : nums)m[x]++;\\n\\n        for(auto x : n2){\\n            g = __gcd(x,g);\\n        <!-- just checking whether min element is 1 or not  -->\\n            if(g == 1 && (*m.begin()).first > 1)return -1;\\n        }\\n\\n        int ans = 0;\\n        auto it = m.begin();\\n        while(g % (*it).first != 0 && it != m.end()){\\n            ans += (*it).second;\\n            it++;\\n        } \\n        if(ans == nums.size())return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864015,
                "title": "c-easy-code-not-a-hard-problem",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            hcf=__gcd(hcf,numsDivide[i]);\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(auto it:nums){\\n            if(hcf%it==0){\\n                return cnt;\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int hcf=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            hcf=__gcd(hcf,numsDivide[i]);\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        for(auto it:nums){\\n            if(hcf%it==0){\\n                return cnt;\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853607,
                "title": "python3-easy-beats-100",
                "content": "\\n# Code\\n```\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcd = numsDivide[0]\\n        for e in numsDivide[1:]:\\n            gcd = math.gcd(gcd,e)\\n        nums.sort()\\n        c = 0\\n        for e in nums:\\n            if gcd%e == 0:\\n                return c\\n            c+=1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcd = numsDivide[0]\\n        for e in numsDivide[1:]:\\n            gcd = math.gcd(gcd,e)\\n        nums.sort()\\n        c = 0\\n        for e in nums:\\n            if gcd%e == 0:\\n                return c\\n            c+=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844445,
                "title": "share-my-solution",
                "content": "# Intuition\\n\\nThe problem asks for maximum number in nums array which divides all the numbers in the divs array. Some observations :- \\n\\n1. GCD is \"greatest common divisor\". This means that its not possible to find a greater number for n elements which divides all the numbers. If numbers are mutually co-prime, then GCD is 1 because of this reason.\\n2. Now if a number divides the GCD, then it will also divide the rest of the numbers. The number might not be the \"greatest\" but it would be some divisor. \\n3. We are also not looking for the greatest. We\\'re actually looking for the smallest. So just sort the array and find the first number that divides the gcd. All the numbers before this number are non divisible.\\n\\n# Approach\\n\\n1. Find GCD of n numbers in divs.\\n2. Sort the original nums array.\\n3. Iterate over the array and find the first number that divides GCD.\\n4. Find the position of this element in the sorted array and return the positin. This position is how many elements we need to remove.\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums, int[] divs) {\\n        int div = Arrays.stream(divs).reduce((a, b) -> gcd(a, b)).getAsInt();\\n\\n        Arrays.sort(nums);\\n        int cnt = -1;\\n        int i = 0;\\n        for (i = 0; i < nums.length; i++) {\\n            if (div % nums[i] == 0) {\\n                cnt = nums[i];\\n                break;\\n            }\\n        }\\n\\n        if (cnt == -1)\\n            return -1;\\n        else\\n            return i;\\n    }\\n\\n    int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums, int[] divs) {\\n        int div = Arrays.stream(divs).reduce((a, b) -> gcd(a, b)).getAsInt();\\n\\n        Arrays.sort(nums);\\n        int cnt = -1;\\n        int i = 0;\\n        for (i = 0; i < nums.length; i++) {\\n            if (div % nums[i] == 0) {\\n                cnt = nums[i];\\n                break;\\n            }\\n        }\\n\\n        if (cnt == -1)\\n            return -1;\\n        else\\n            return i;\\n    }\\n\\n    int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        } else {\\n            return gcd(b, a % b);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827472,
                "title": "c-easy-solution-using-maps-and-set",
                "content": "m\\n# Approach\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        set<int> div(numsDivide.begin(),numsDivide.end());\\n        map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            for(auto j:div){\\n                if(j%nums[i]!=0){\\n                    i+=(mp[nums[i]]-1);\\n                    break;\\n                }\\n                if(j==*(--div.end())){ return i;}\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        set<int> div(numsDivide.begin(),numsDivide.end());\\n        map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3821266,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, vector<int>& d) {\\n        int h=d[0];\\n        for(auto i : d) h=__gcd(i,h);\\n        sort(a.begin(),a.end());\\n        int c=0;bool b=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(h%a[i]==0)\\n             { b=1;\\n               break;}\\n            c++;\\n        }\\n        if(b)\\n        return c;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, vector<int>& d) {\\n        int h=d[0];\\n        for(auto i : d) h=__gcd(i,h);\\n        sort(a.begin(),a.end());\\n        int c=0;bool b=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(h%a[i]==0)\\n             { b=1;\\n               break;}\\n            c++;\\n        }\\n        if(b)\\n        return c;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813659,
                "title": "python3-o-nlogn",
                "content": "# Intuition\\n### Firstly, find the gcd of the entire numsDivide array.\\n### Next, find the smallest element that divides gcd.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcd = lambda a, b: a if b==0 else gcd(b, a%b)\\n        g = numsDivide[0]\\n        for i in range(1, len(numsDivide)):\\n            g = gcd(g, numsDivide[i])\\n        d = Counter(nums)\\n        dd = list(d.keys())\\n        dd.sort()\\n        count = 0\\n        for i in dd:\\n            if g%i == 0:\\n                return count\\n            count += d[i]\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gcd = lambda a, b: a if b==0 else gcd(b, a%b)\\n        g = numsDivide[0]\\n        for i in range(1, len(numsDivide)):\\n            g = gcd(g, numsDivide[i])\\n        d = Counter(nums)\\n        dd = list(d.keys())\\n        dd.sort()\\n        count = 0\\n        for i in dd:\\n            if g%i == 0:\\n                return count\\n            count += d[i]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804550,
                "title": "beats-100-for-javascript-with-time-and-space-complexity-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} numsDivide\\n * @return {number}\\n */\\n // overall time complexity -> O(nd * logx) + O(n) + O(sm) + O(smlog(sm)) + o(sm) = O(ndLogX + smlog(sm))  \\nvar minOperations = function(nums, numsDivide) {\\n    // time complexity -> O(logx); space -> O(logx)\\n    const gcd = (x, y) => {\\n        if(y > x) return gcd(y, x);\\n        while(x % y !== 0){\\n            let rem = x % y;\\n            x = y;\\n            y = rem;\\n        }\\n        return y;\\n    }\\n\\n    let commonGCD = numsDivide[0];\\n    // time -> O(nd * logx), space -> O(1)\\n    for(let i = 1; i < numsDivide.length; i++){\\n        commonGCD = gcd(commonGCD, numsDivide[i]);   \\n    }    \\n    // time -> O(n), space -> O(n)\\n    let freqMap = new Map();\\n    for(let j = 0; j < nums.length; j++){\\n        freqMap.set(nums[j], (freqMap.get(nums[j]) || 0) + 1);   \\n    }\\n    // sm = size of map; time -> O(sm), space -> O(1)\\n    let uniqueValue = Array.from(freqMap.keys() || []);\\n    // sm = size of map; time -> O(sm logsm), space -> O(sm)\\n    uniqueValue.sort((a, b) => a - b);\\n    let result = 0;\\n    // sm = size of map; time -> O(sm), space -> O(1)\\n    for(let i = 0; i < uniqueValue.length; i++){\\n        if(commonGCD % uniqueValue[i] !== 0) result += freqMap.get(uniqueValue[i]);\\n        else return result;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} numsDivide\\n * @return {number}\\n */\\n // overall time complexity -> O(nd * logx) + O(n) + O(sm) + O(smlog(sm)) + o(sm) = O(ndLogX + smlog(sm))  \\nvar minOperations = function(nums, numsDivide) {\\n    // time complexity -> O(logx); space -> O(logx)\\n    const gcd = (x, y) => {\\n        if(y > x) return gcd(y, x);\\n        while(x % y !== 0){\\n            let rem = x % y;\\n            x = y;\\n            y = rem;\\n        }\\n        return y;\\n    }\\n\\n    let commonGCD = numsDivide[0];\\n    // time -> O(nd * logx), space -> O(1)\\n    for(let i = 1; i < numsDivide.length; i++){\\n        commonGCD = gcd(commonGCD, numsDivide[i]);   \\n    }    \\n    // time -> O(n), space -> O(n)\\n    let freqMap = new Map();\\n    for(let j = 0; j < nums.length; j++){\\n        freqMap.set(nums[j], (freqMap.get(nums[j]) || 0) + 1);   \\n    }\\n    // sm = size of map; time -> O(sm), space -> O(1)\\n    let uniqueValue = Array.from(freqMap.keys() || []);\\n    // sm = size of map; time -> O(sm logsm), space -> O(sm)\\n    uniqueValue.sort((a, b) => a - b);\\n    let result = 0;\\n    // sm = size of map; time -> O(sm), space -> O(1)\\n    for(let i = 0; i < uniqueValue.length; i++){\\n        if(commonGCD % uniqueValue[i] !== 0) result += freqMap.get(uniqueValue[i]);\\n        else return result;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788886,
                "title": "easiest-way-to-approach",
                "content": "\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n\\n        Arrays.sort(nums);\\n        ArrayList<Integer> a = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            a.add(nums[i]);\\n        }\\n\\n        int count =0; //to check deletions;\\n        boolean confirm = false;\\n\\n        while(confirm==false && !a.isEmpty())\\n        {\\n            \\n                boolean c = check(numsDivide, a.get(0));\\n                if(c==true)\\n                {\\n                    confirm= true;\\n                }\\n                else\\n                {\\n                    int j=0;\\n                    int num = a.get(0);\\n                     while(!a.isEmpty() && a.get(j)==num)\\n                     {\\n                         a.remove(0);\\n                         count++;\\n                     }\\n                }\\n            }\\n\\n        if(a.isEmpty())return -1;\\n        \\n        return count;\\n        \\n    }\\n\\n\\n    public boolean check(int[] numsDivide, int i)\\n    {\\n        for(int j=0; j<numsDivide.length; j++)\\n        {\\n            if(numsDivide[j]%i!=0)return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n\\n        Arrays.sort(nums);\\n        ArrayList<Integer> a = new ArrayList<>();\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            a.add(nums[i]);\\n        }\\n\\n        int count =0; //to check deletions;\\n        boolean confirm = false;\\n\\n        while(confirm==false && !a.isEmpty())\\n        {\\n            \\n                boolean c = check(numsDivide, a.get(0));\\n                if(c==true)\\n                {\\n                    confirm= true;\\n                }\\n                else\\n                {\\n                    int j=0;\\n                    int num = a.get(0);\\n                     while(!a.isEmpty() && a.get(j)==num)\\n                     {\\n                         a.remove(0);\\n                         count++;\\n                     }\\n                }\\n            }\\n\\n        if(a.isEmpty())return -1;\\n        \\n        return count;\\n        \\n    }\\n\\n\\n    public boolean check(int[] numsDivide, int i)\\n    {\\n        for(int j=0; j<numsDivide.length; j++)\\n        {\\n            if(numsDivide[j]%i!=0)return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754330,
                "title": "c-o-n-solution-gcd-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            g=__gcd(g,numsDivide[i]);\\n        }\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto i:nums){\\n            pq.push(i);\\n        }\\n        int mini=*min_element(numsDivide.begin(),numsDivide.end());\\n        int count=0;\\n        while(!pq.empty()){\\n            int val=g/pq.top();\\n            if(val*pq.top()==g){\\n                break;\\n            }\\n            count++;\\n            pq.pop();\\n        }\\n        if(count>=nums.size()){\\n            return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            g=__gcd(g,numsDivide[i]);\\n        }\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto i:nums){\\n            pq.push(i);\\n        }\\n        int mini=*min_element(numsDivide.begin(),numsDivide.end());\\n        int count=0;\\n        while(!pq.empty()){\\n            int val=g/pq.top();\\n            if(val*pq.top()==g){\\n                break;\\n            }\\n            count++;\\n            pq.pop();\\n        }\\n        if(count>=nums.size()){\\n            return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750017,
                "title": "straightforward-go-lang-o-n-2",
                "content": "# Intuition & Approach\\n\\nI implemented brute force and it was accepted `\\xAF\\\\_(\\u30C4)_/\\xAF`.\\n\\nBut it can be optimized to a better complexity then $$O(n^2)$$ with Greatest Common Divisor.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc minOperations(nums []int, numsDivide []int) int {\\n    divides := func(n int) bool {\\n        for _, v := range numsDivide {\\n            if v % n != 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\n    sort.Ints(nums)\\n    prev := -1\\n    for i := 0; i < len(nums); i++ {\\n        if prev == nums[i] {\\n            continue\\n        }\\n        prev = nums[i]\\n\\n        if divides(nums[i]) {\\n            return i\\n        }\\n    }\\n    return -1    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(nums []int, numsDivide []int) int {\\n    divides := func(n int) bool {\\n        for _, v := range numsDivide {\\n            if v % n != 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\n    sort.Ints(nums)\\n    prev := -1\\n    for i := 0; i < len(nums); i++ {\\n        if prev == nums[i] {\\n            continue\\n        }\\n        prev = nums[i]\\n\\n        if divides(nums[i]) {\\n            return i\\n        }\\n    }\\n    return -1    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693944,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            gcd=__gcd(gcd,numsDivide[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(gcd%nums[i]==0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            gcd=__gcd(gcd,numsDivide[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(gcd%nums[i]==0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691906,
                "title": "c-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g = 0;\\n        for(auto &i:numsDivide){\\n            g = __gcd(g, i);\\n        }\\n\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n\\n        for(auto &i:nums){\\n            pq.push(i);\\n        }\\n        int x = 0;\\n\\n        while(!pq.empty() && g%pq.top()){\\n            x++;\\n            pq.pop();\\n        }\\n\\n        if(pq.empty())return -1;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g = 0;\\n        for(auto &i:numsDivide){\\n            g = __gcd(g, i);\\n        }\\n\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n\\n        for(auto &i:nums){\\n            pq.push(i);\\n        }\\n        int x = 0;\\n\\n        while(!pq.empty() && g%pq.top()){\\n            x++;\\n            pq.pop();\\n        }\\n\\n        if(pq.empty())return -1;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691601,
                "title": "making-use-of-euclidean-gcd-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n       Arrays.sort(nums);\\n       int el= traverse(numsDivide);\\n       System.out.println(el + \"gcd\");\\n\\n       int s=0;\\n       int e=nums.length-1;\\n\\n       for(int i=0;i<nums.length;i++)\\n       {\\n           if(el%nums[i]==0)\\n           {\\n               return i;\\n           }\\n       }\\n       return -1;\\n\\n\\n    }\\n\\n    public int traverse(int arr[])\\n    {\\n        Arrays.sort(arr);\\n        if(arr.length==1)\\n        {\\n            return arr[0];\\n        }\\n        int a = arr[0];\\n        int b= arr[1];\\n        int j=1;\\n        int n=gcd(a,b);\\n        while( j< arr.length)\\n        {\\n            n=gcd(n,arr[j]);\\n            j++;\\n\\n        }\\n        return n;\\n\\n\\n    }\\n\\n    public int gcd(int a, int b)\\n    {\\n        if(a==0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n       Arrays.sort(nums);\\n       int el= traverse(numsDivide);\\n       System.out.println(el + \"gcd\");\\n\\n       int s=0;\\n       int e=nums.length-1;\\n\\n       for(int i=0;i<nums.length;i++)\\n       {\\n           if(el%nums[i]==0)\\n           {\\n               return i;\\n           }\\n       }\\n       return -1;\\n\\n\\n    }\\n\\n    public int traverse(int arr[])\\n    {\\n        Arrays.sort(arr);\\n        if(arr.length==1)\\n        {\\n            return arr[0];\\n        }\\n        int a = arr[0];\\n        int b= arr[1];\\n        int j=1;\\n        int n=gcd(a,b);\\n        while( j< arr.length)\\n        {\\n            n=gcd(n,arr[j]);\\n            j++;\\n\\n        }\\n        return n;\\n\\n\\n    }\\n\\n    public int gcd(int a, int b)\\n    {\\n        if(a==0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691296,
                "title": "my-c-solution-o-nlogn-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if(a==0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int gcdNumsDivide = numsDivide[0];\\n        for(int i=0;i<numsDivide.size()-1;i++)\\n        {\\n            gcdNumsDivide = gcd(gcdNumsDivide,numsDivide[i+1]);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((gcdNumsDivide%nums[i])==0)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        if(count==nums.size())\\n        {\\n            return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if(a==0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        int gcdNumsDivide = numsDivide[0];\\n        for(int i=0;i<numsDivide.size()-1;i++)\\n        {\\n            gcdNumsDivide = gcd(gcdNumsDivide,numsDivide[i+1]);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((gcdNumsDivide%nums[i])==0)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n        if(count==nums.size())\\n        {\\n            return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640398,
                "title": "c-easy-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want a numbe that can divide element numsDivide and all elements will be divisible by their gcd. So, the smallest number which will divide all will also divide their gcd.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Find GCD of all elements of numsDivide\\n- sort the nums array\\n- find the smallest element that divides that GCD\\n- All elements before that needs to be removed, if there is no such element then return 0.\\n\\n# Complexity\\n- Time complexity: O(n*log (n * max_element))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int val;\\n        if(numsDivide.size() == 1){\\n            val = numsDivide[0];\\n        }\\n        else\\n        {\\n            val = gcd(numsDivide[0], numsDivide[1]);\\n            for(auto i : numsDivide){\\n                val = gcd(val , i);\\n            }\\n        }\\n        int ans = -1;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< nums.size(); i++){\\n            if(val%nums[i] == 0){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int val;\\n        if(numsDivide.size() == 1){\\n            val = numsDivide[0];\\n        }\\n        else\\n        {\\n            val = gcd(numsDivide[0], numsDivide[1]);\\n            for(auto i : numsDivide){\\n                val = gcd(val , i);\\n            }\\n        }\\n        int ans = -1;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< nums.size(); i++){\\n            if(val%nums[i] == 0){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614528,
                "title": "gcd-and-sorting",
                "content": "A number `n` divides every element in an array `arr` IFF `n` divides `gcd(arr)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        assert(!nums.empty());\\n        int g = numsDivide[0];\\n        for(int n: numsDivide){\\n            g = gcd(g, n);\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i=0;i<nums.size();++i){\\n            int n = nums[i];\\n            if(g%n==0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        assert(!nums.empty());\\n        int g = numsDivide[0];\\n        for(int n: numsDivide){\\n            g = gcd(g, n);\\n        }\\n        sort(nums.begin(), nums.end());\\n        for(int i=0;i<nums.size();++i){\\n            int n = nums[i];\\n            if(g%n==0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566259,
                "title": "find-number-of-elements-in-nums-that-couldn-t-divide-gcd",
                "content": "# Approach\\nIf a | b, b | c, for all c in nums, then a | c for all c in nums.\\nChoose b = gcd(numsDivide) since a <= gcd(numsDivide).\\nWe need to find number of elements in nondecreasing order that is not a factor of gcd.\\nIf that number is nums.length, return -1. \\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = reduce(gcd, numsDivide)\\n        heapify(nums)\\n\\n        for i in range(len(nums)):\\n            x = heappop(nums)\\n\\n            if g % x == 0:\\n                return i \\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        g = reduce(gcd, numsDivide)\\n        heapify(nums)\\n\\n        for i in range(len(nums)):\\n            x = heappop(nums)\\n\\n            if g % x == 0:\\n                return i \\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558345,
                "title": "c-simple-solution-gcd",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int gcd = numsDivide[0];\\n        for(auto it : numsDivide){\\n            gcd = __gcd(gcd, it);\\n        }\\n        int ans = -1, n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            if(gcd%nums[i] == 0) return i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n        int gcd = numsDivide[0];\\n        for(auto it : numsDivide){\\n            gcd = __gcd(gcd, it);\\n        }\\n        int ans = -1, n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            if(gcd%nums[i] == 0) return i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544333,
                "title": "sorting-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        sort(numsDivide.begin(),numsDivide.end());\\n        int x;\\n        if(numsDivide.size()==1)\\n        x=numsDivide[0];\\n        else{\\n            x=gcd(numsDivide[0],numsDivide[1]);\\n            for(int i=2;i<numsDivide.size();i++)\\n            {\\n                x=gcd(x,numsDivide[i]);\\n            }\\n        }\\n        cout<<x<<\"\\\\n\";\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(x%nums[i]==0)\\n            return count;\\n            count++;\\n        }\\n        return -1;\\n    }\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(),nums.end());\\n        sort(numsDivide.begin(),numsDivide.end());\\n        int x;\\n        if(numsDivide.size()==1)\\n        x=numsDivide[0];\\n        else{\\n            x=gcd(numsDivide[0],numsDivide[1]);\\n            for(int i=2;i<numsDivide.size();i++)\\n            {\\n                x=gcd(x,numsDivide[i]);\\n            }\\n        }\\n        cout<<x<<\"\\\\n\";\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(x%nums[i]==0)\\n            return count;\\n            count++;\\n        }\\n        return -1;\\n    }\\n    int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3506508,
                "title": "c-easy-to-understand-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n\\n        int gcd = numsDivide[0];\\n\\n        for(auto& i : numsDivide){\\n            gcd = __gcd(i, gcd);\\n        }\\n\\n        int minDelete = 0;\\n        for(auto& i : nums){\\n            if(gcd % i == 0){\\n                return minDelete;\\n            }\\n            \\n            minDelete++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        sort(nums.begin(), nums.end());\\n\\n        int gcd = numsDivide[0];\\n\\n        for(auto& i : numsDivide){\\n            gcd = __gcd(i, gcd);\\n        }\\n\\n        int minDelete = 0;\\n        for(auto& i : nums){\\n            if(gcd % i == 0){\\n                return minDelete;\\n            }\\n            \\n            minDelete++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502297,
                "title": "gcd-of-nums-divide",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$ (sorting of nums)\\n\\n- Space complexity:\\n$$O(n)$$ for input arrays\\n$$O(1)$$ additional memory \\n\\n# Code\\n```\\nimpl Solution {\\n    //Calculates the greatest common divisor of two numbers\\n    fn gcd(mut a: i32, mut b: i32) -> i32 {\\n        if a < b {\\n            std::mem::swap(&mut a, &mut b);\\n        }\\n        while b > 0 {\\n            a = a%b;\\n            std::mem::swap(&mut a, &mut b);            \\n        }\\n        a\\n    }\\n\\n    pub fn min_operations(mut nums: Vec<i32>, nums_divide: Vec<i32>) -> i32 {\\n        //calculate the greatest common divisor of all elements in nums_divide\\n        let mut gcd_nums_divide = nums_divide[0];\\n        for x in nums_divide.iter().skip(1) {\\n            gcd_nums_divide = Solution::gcd(gcd_nums_divide, *x);\\n        }\\n\\n        //sort nums\\n        nums.sort();\\n\\n        //Find first element in nums that divides the gcd of nums_divide\\n        for (idx, x) in nums.iter().enumerate() {\\n            if gcd_nums_divide % x == 0 {\\n                return idx as i32;\\n            }\\n        }\\n\\n        //no divisor found\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Math",
                    "Sorting",
                    "Number Theory"
                ],
                "code": "```\\nimpl Solution {\\n    //Calculates the greatest common divisor of two numbers\\n    fn gcd(mut a: i32, mut b: i32) -> i32 {\\n        if a < b {\\n            std::mem::swap(&mut a, &mut b);\\n        }\\n        while b > 0 {\\n            a = a%b;\\n            std::mem::swap(&mut a, &mut b);            \\n        }\\n        a\\n    }\\n\\n    pub fn min_operations(mut nums: Vec<i32>, nums_divide: Vec<i32>) -> i32 {\\n        //calculate the greatest common divisor of all elements in nums_divide\\n        let mut gcd_nums_divide = nums_divide[0];\\n        for x in nums_divide.iter().skip(1) {\\n            gcd_nums_divide = Solution::gcd(gcd_nums_divide, *x);\\n        }\\n\\n        //sort nums\\n        nums.sort();\\n\\n        //Find first element in nums that divides the gcd of nums_divide\\n        for (idx, x) in nums.iter().enumerate() {\\n            if gcd_nums_divide % x == 0 {\\n                return idx as i32;\\n            }\\n        }\\n\\n        //no divisor found\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441242,
                "title": "brute-force-using-map-tle-38-49-test-cases-passed-gcd-optimised-c",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n      \\n\\t  \\n\\t  //USING MAP GIVES TLE\\n        int ret=0;\\n       \\n      map<long long int,vector<long long int>>mp;\\n        for(long long int i=0;i<nums.size();i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        int j=0;\\n        //sort(numsDivide.begin(),numsDivide.end());\\n       long long int t=0;\\n        vector<long long int> temp;\\n      map<long long int,long long int> p;\\n        for(auto it:mp){\\n            long long int ans=0;\\n            bool flag=false;\\n           long long int count=0;\\n           for(long long int i=0;i<numsDivide.size();i++){\\n               \\n               if((numsDivide[i]%it.first)==0){\\n                   flag=true;\\n                   ans=it.second.size();\\n                 \\n               }\\n               else count++;\\n               \\n           }\\n            ret+=ans;\\n            temp.push_back(count);\\n           \\n            if(flag==false) break;\\n            \\n            \\n        }\\n       \\n         \\n         for(auto it:temp){\\n             p[it]++;\\n            \\n         }\\n       \\n        if(p.find(numsDivide.size())==p.end()) return -1;\\n        else return ret;\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n        \\n        //USING GCD\\n        sort(nums.begin(),nums.end());\\n        sort(numsDivide.begin(),numsDivide.end());\\n        int ret=0;\\n        int gc=numsDivide[0];\\n        for(int i=1;i<numsDivide.size();i++){\\n            gc=__gcd(gc,numsDivide[i]);\\n        }\\n        if(nums[0]>gc)return -1;\\n        for(int i=0;i<nums.size();i++){\\n            if((gc%nums[i])==0){\\n                return ret; \\n            }\\n             ret++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n      \\n\\t  \\n\\t  //USING MAP GIVES TLE\\n        int ret=0;\\n       \\n      map<long long int,vector<long long int>>mp;\\n        for(long long int i=0;i<nums.size();i++){\\n            mp[nums[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3430380,
                "title": "easiest-hard-problem-java",
                "content": "# Intuition\\nFind GCD of numsDivide to get the smallest number which divides the whole NumsDivide array\\nsort nums\\nfind if any element can divide gcd \\ncount all the element before that index and return \\nif no element divides gcd then return -1 \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int getGCD(int a, int b){\\n            while (a > 0 && b > 0) {\\n                if (a > b) {\\n                    a = a % b;\\n                }\\n                else {\\n                    b = b % a;\\n                }\\n            }\\n            if (a == 0) {\\n                return b;\\n            }\\n            return a;\\n        }\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int gcd = 0;\\n        for(int i=0; i<numsDivide.length; i++){\\n            gcd = getGCD(gcd , numsDivide[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            if(gcd % nums[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int getGCD(int a, int b){\\n            while (a > 0 && b > 0) {\\n                if (a > b) {\\n                    a = a % b;\\n                }\\n                else {\\n                    b = b % a;\\n                }\\n            }\\n            if (a == 0) {\\n                return b;\\n            }\\n            return a;\\n        }\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int gcd = 0;\\n        for(int i=0; i<numsDivide.length; i++){\\n            gcd = getGCD(gcd , numsDivide[i]);\\n        }\\n\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            if(gcd % nums[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413862,
                "title": "easyyyyyyyyyy-c-just-math-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n{\\n  if (a == 0)\\n    return b;\\n  return gcd(b % a, a);\\n}\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int result = numsDivide[0];\\n        int hcf = result;\\n        for(int i=1;i<numsDivide.size();i++){\\n            result = gcd(numsDivide[i],result);\\n            if(result == 1) hcf = 1;\\n        }\\n        hcf = result;\\n        sort(nums.begin(),nums.end());\\n        // int ans = 0;\\n        // bool flag = false;\\n        // for(int i=0;i<nums.size();i++) \\n        // {\\n        //     if(nums[i]==hcf) flag = true;\\n        // }\\n        // if(flag == false) return -1;\\n        // for(int i=0;i<nums.size();i++){\\n        //     if(nums[i]!=hcf) ans++;\\n        //     else break;\\n        // }\\n        // return ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(hcf % nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n{\\n  if (a == 0)\\n    return b;\\n  return gcd(b % a, a);\\n}\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int result = numsDivide[0];\\n        int hcf = result;\\n        for(int i=1;i<numsDivide.size();i++){\\n            result = gcd(numsDivide[i],result);\\n            if(result == 1) hcf = 1;\\n        }\\n        hcf = result;\\n        sort(nums.begin(),nums.end());\\n        // int ans = 0;\\n        // bool flag = false;\\n        // for(int i=0;i<nums.size();i++) \\n        // {\\n        //     if(nums[i]==hcf) flag = true;\\n        // }\\n        // if(flag == false) return -1;\\n        // for(int i=0;i<nums.size();i++){\\n        //     if(nums[i]!=hcf) ans++;\\n        //     else break;\\n        // }\\n        // return ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(hcf % nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399288,
                "title": "c-gcd",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < numsDivide.size() - 1; i++)\\n            numsDivide[i+1] = __gcd(numsDivide[i], numsDivide[i+1]);\\n        for(int i = 0; i < nums.size(); i++) if(numsDivide[numsDivide.size() - 1] % nums[i] == 0) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < numsDivide.size() - 1; i++)\\n            numsDivide[i+1] = __gcd(numsDivide[i], numsDivide[i+1]);\\n        for(int i = 0; i < nums.size(); i++) if(numsDivide[numsDivide.size() - 1] % nums[i] == 0) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370055,
                "title": "c-solution-faster-than-100",
                "content": "\\n# Complexity\\n- Time complexity:\\nO((N * log(N)) + (M * log(M)))\\nwhere N is nums length & M largest element of the numsDivide array\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int[] numsDivide) {\\n        Array.Sort(nums);\\n        int divide = GCD(numsDivide);\\n        int cur = 0;\\n        while(cur < nums.Length){\\n            if(divide % nums[cur] == 0) break;\\n            cur++;\\n        }\\n        if(cur == nums.Length) return -1;\\n        return cur;\\n    }\\n    public int GCD(int[] nums){\\n        int res = nums[0];\\n        for(int i = 1;i < nums.Length;i++)\\n           res = GCD(res,nums[i]);\\n        return res;\\n    }\\n    public int GCD(int a, int b){\\n        if(a == 0) return b;\\n        return GCD(b % a,a);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int[] numsDivide) {\\n        Array.Sort(nums);\\n        int divide = GCD(numsDivide);\\n        int cur = 0;\\n        while(cur < nums.Length){\\n            if(divide % nums[cur] == 0) break;\\n            cur++;\\n        }\\n        if(cur == nums.Length) return -1;\\n        return cur;\\n    }\\n    public int GCD(int[] nums){\\n        int res = nums[0];\\n        for(int i = 1;i < nums.Length;i++)\\n           res = GCD(res,nums[i]);\\n        return res;\\n    }\\n    public int GCD(int a, int b){\\n        if(a == 0) return b;\\n        return GCD(b % a,a);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349526,
                "title": "c-easy-and-clean-gcd-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A, vector<int>& B)\\n    {\\n        int g = 0;\\n        for (int i : B)\\n            g = gcd(g, i);\\n        \\n        \\n        sort(A.begin(), A.end());\\n        \\n        for (int i = 0; i < A.size(); i++)\\n            if (g%A[i]==0)\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A, vector<int>& B)\\n    {\\n        int g = 0;\\n        for (int i : B)\\n            g = gcd(g, i);\\n        \\n        \\n        sort(A.begin(), A.end());\\n        \\n        for (int i = 0; i < A.size(); i++)\\n            if (g%A[i]==0)\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346582,
                "title": "solution-honestly-felt-like-a-medium",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe only somewhat nontrivial part of this is finding the gcd of an array. once you figure out that the array\\'s gcd is just the gcd of one element with everything else, the rest falls into place.\\n\\none thing - make sure ur gcd algorithm doesn\\'t suck. i used the LITERAL definition of euclidean and hit tle about 12 times lmfao\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfinding gcd of the numsDivide array and we check the first nums that is divisible by this then return the elements before it (we can do this since we sort nums first) \\n# Complexity\\n- Time complexity:o(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minOperations(self, nums, numsDivide):\\n        def findGCD(a,b):\\n            if a == 0:\\n                return b\\n            return findGCD(b%a, a)\\n        \\n\\n        gcd = numsDivide[0]\\n\\n        for i2 in range(1, len(numsDivide)):\\n            gcd = findGCD(gcd, numsDivide[i2])\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gcd % nums[i] == 0:\\n                return i\\n        return -1 \\n        \"\"\"\\n        :type nums: List[int]\\n        :type numsDivide: List[int]\\n        :rtype: int\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, nums, numsDivide):\\n        def findGCD(a,b):\\n            if a == 0:\\n                return b\\n            return findGCD(b%a, a)\\n        \\n\\n        gcd = numsDivide[0]\\n\\n        for i2 in range(1, len(numsDivide)):\\n            gcd = findGCD(gcd, numsDivide[i2])\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gcd % nums[i] == 0:\\n                return i\\n        return -1 \\n        \"\"\"\\n        :type nums: List[int]\\n        :type numsDivide: List[int]\\n        :rtype: int\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343920,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        sort(numsDivide.rbegin(),numsDivide.rend());\\n        int c=0;\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(!pq.empty())\\n        {\\n            int ele=pq.top();\\n            bool f=true;\\n            for(int i=0;i<numsDivide.size();i++)\\n            {\\n                if(numsDivide[i]%ele!=0)\\n                {\\n                    f=false;\\n                    break;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                c++;\\n                pq.pop();\\n            }\\n            else if(f==true)\\n            {\\n                break;\\n            }\\n        }\\n        if(c==nums.size())\\n        {\\n            return -1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        sort(numsDivide.rbegin(),numsDivide.rend());\\n        int c=0;\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(!pq.empty())\\n        {\\n            int ele=pq.top();\\n            bool f=true;\\n            for(int i=0;i<numsDivide.size();i++)\\n            {\\n                if(numsDivide[i]%ele!=0)\\n                {\\n                    f=false;\\n                    break;\\n                }\\n            }\\n            if(f==false)\\n            {\\n                c++;\\n                pq.pop();\\n            }\\n            else if(f==true)\\n            {\\n                break;\\n            }\\n        }\\n        if(c==nums.size())\\n        {\\n            return -1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321192,
                "title": "simple-priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int count=0,prev=-1;\\n        while(!pq.empty())\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            if(top==prev)\\n            {\\n                count++;\\n            }\\n            else \\n            {\\n                 bool flag=false;\\n                for(int i=0;i<numsDivide.size();i++)\\n                {\\n                    if(numsDivide[i]%top!=0)\\n                    {\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag) return count;\\n                count++;\\n            }\\n            prev=top;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int count=0,prev=-1;\\n        while(!pq.empty())\\n        {\\n            int top=pq.top();\\n            pq.pop();\\n            if(top==prev)\\n            {\\n                count++;\\n            }\\n            else \\n            {\\n                 bool flag=false;\\n                for(int i=0;i<numsDivide.size();i++)\\n                {\\n                    if(numsDivide[i]%top!=0)\\n                    {\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag) return count;\\n                count++;\\n            }\\n            prev=top;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311506,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int gcd(int a,int b){\\n        if(a == 0)\\n            return b;\\n        return gcd(b % a , a);\\n    }\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int d = numsDivide[0];\\n        for(int i = 1;i<numsDivide.length;i++){\\n            if(d == 1)\\n                break;\\n            if(d == numsDivide[i])\\n                continue;\\n            int a = Math.min(d,numsDivide[i]);\\n            int b = Math.max(d,numsDivide[i]);\\n            d = gcd(a,b);\\n        }\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int flag = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            if(d%nums[i] == 0){\\n                flag = 1;\\n                break;\\n            }\\n            count++;\\n        }\\n        if(flag == 1)\\n            return count;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int a,int b){\\n        if(a == 0)\\n            return b;\\n        return gcd(b % a , a);\\n    }\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        int d = numsDivide[0];\\n        for(int i = 1;i<numsDivide.length;i++){\\n            if(d == 1)\\n                break;\\n            if(d == numsDivide[i])\\n                continue;\\n            int a = Math.min(d,numsDivide[i]);\\n            int b = Math.max(d,numsDivide[i]);\\n            d = gcd(a,b);\\n        }\\n        Arrays.sort(nums);\\n        int count = 0;\\n        int flag = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            if(d%nums[i] == 0){\\n                flag = 1;\\n                break;\\n            }\\n            count++;\\n        }\\n        if(flag == 1)\\n            return count;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303028,
                "title": "python-easiest-peasiest-solution-90-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        nums.sort()\\n        lol=gcd(*numsDivide)\\n        for i in range(len(nums)):\\n            if nums[i]==lol or lol%nums[i]==0:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        nums.sort()\\n        lol=gcd(*numsDivide)\\n        for i in range(len(nums)):\\n            if nums[i]==lol or lol%nums[i]==0:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229000,
                "title": "python-beats-97-using-gcd-and-unzipper",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        n = gcd(*set(numsDivide))\\n        # print(n)\\n        nums.sort()\\n        for i,a in enumerate(nums):\\n            if n % a == 0: return i\\n            if a > n: break\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        n = gcd(*set(numsDivide))\\n        # print(n)\\n        nums.sort()\\n        for i,a in enumerate(nums):\\n            if n % a == 0: return i\\n            if a > n: break\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225261,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& div) {\\n        int gcd=div[0];\\n        for(int i=0;i<div.size();i++){\\n            gcd=__gcd(gcd,div[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(gcd%nums[i]==0)\\n            return i;\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& div) {\\n        int gcd=div[0];\\n        for(int i=0;i<div.size();i++){\\n            gcd=__gcd(gcd,div[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(gcd%nums[i]==0)\\n            return i;\\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225259,
                "title": "easy-c-code-using-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        for (int i = 1; i < numsDivide.size(); ++i)\\n            gcd = std::__gcd(gcd, numsDivide[i]);\\n        sort(nums.begin(), nums.end());\\n        int k=0,f=0;\\n        for (int i = 0; i < nums.size(); i++){\\n            if (gcd % nums[i] == 0){\\n                f=1;\\n                break;\\n            }\\n            else\\n            k++;\\n        }\\n        if(f==0) return -1;\\n        else return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        for (int i = 1; i < numsDivide.size(); ++i)\\n            gcd = std::__gcd(gcd, numsDivide[i]);\\n        sort(nums.begin(), nums.end());\\n        int k=0,f=0;\\n        for (int i = 0; i < nums.size(); i++){\\n            if (gcd % nums[i] == 0){\\n                f=1;\\n                break;\\n            }\\n            else\\n            k++;\\n        }\\n        if(f==0) return -1;\\n        else return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178359,
                "title": "go-easy-0ms-solution",
                "content": "```\\nfunc minOperations(nums []int, numsDivide []int) int {\\n    sort.Ints(nums)\\n    sum := 0\\n    for _, v := range numsDivide {\\n        sum += v\\n    }\\n    sm := 0\\n    count := 0\\n    for _, v := range nums {\\n        if sm == v {\\n            count++\\n            continue\\n        }\\n        if sum % v == 0 && div(numsDivide, v){\\n            return count\\n        } \\n        sm = v\\n        count++\\n    }\\n    \\n    return -1\\n}\\n\\nfunc div(arr []int, d int) bool {\\n    for _, v := range arr {\\n        if v%d != 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(nums []int, numsDivide []int) int {\\n    sort.Ints(nums)\\n    sum := 0\\n    for _, v := range numsDivide {\\n        sum += v\\n    }\\n    sm := 0\\n    count := 0\\n    for _, v := range nums {\\n        if sm == v {\\n            count++\\n            continue\\n        }\\n        if sum % v == 0 && div(numsDivide, v){\\n            return count\\n        } \\n        sm = v\\n        count++\\n    }\\n    \\n    return -1\\n}\\n\\nfunc div(arr []int, d int) bool {\\n    for _, v := range arr {\\n        if v%d != 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3176805,
                "title": "dont-check-it-you-cannot-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\nArrays.sort(nums);\\n        int gcd =0;\\n        if(numsDivide.length==1){\\n            int count=-1;\\n            for (int i = 0; i < nums.length; i++) {\\n                if(i==0 && numsDivide[0]%nums[i]==0){\\n                    return 0;\\n                }\\n                if(numsDivide[0]%nums[i]!=0){\\n                    count++;\\n                }\\n            }\\n            if(count+1==nums.length){\\n                return -1;\\n            }\\n            if(count>-1){\\n                return count+1;\\n            }\\n            return count;\\n        }\\n        else {\\n            gcd = GCD(numsDivide[0], numsDivide[1]);\\n        }\\n        for (int i = 2; i < numsDivide.length; i++) {\\n            gcd=GCD(gcd,numsDivide[i]);\\n        }\\n        int count=-1;\\n        boolean flag=false;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(i==0 && nums[i]==gcd){\\n                return 0;\\n            }\\n            if(gcd!=nums[i]){\\n                count++;\\n            }else {\\n                break;\\n            }\\n            if(gcd%nums[i]==0){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        if(flag){\\n            return count;\\n        }\\n        if(count+1==nums.length){\\n            return -1;\\n        }\\n        if(count>-1){\\n            return count+1;\\n        }\\n        return count;\\n    }\\n    public int GCD(int a,int b){\\n        if (b == 0)\\n            return a;\\n        return GCD(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\nArrays.sort(nums);\\n        int gcd =0;\\n        if(numsDivide.length==1){\\n            int count=-1;\\n            for (int i = 0; i < nums.length; i++) {\\n                if(i==0 && numsDivide[0]%nums[i]==0){\\n                    return 0;\\n                }\\n                if(numsDivide[0]%nums[i]!=0){\\n                    count++;\\n                }\\n            }\\n            if(count+1==nums.length){\\n                return -1;\\n            }\\n            if(count>-1){\\n                return count+1;\\n            }\\n            return count;\\n        }\\n        else {\\n            gcd = GCD(numsDivide[0], numsDivide[1]);\\n        }\\n        for (int i = 2; i < numsDivide.length; i++) {\\n            gcd=GCD(gcd,numsDivide[i]);\\n        }\\n        int count=-1;\\n        boolean flag=false;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(i==0 && nums[i]==gcd){\\n                return 0;\\n            }\\n            if(gcd!=nums[i]){\\n                count++;\\n            }else {\\n                break;\\n            }\\n            if(gcd%nums[i]==0){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        if(flag){\\n            return count;\\n        }\\n        if(count+1==nums.length){\\n            return -1;\\n        }\\n        if(count>-1){\\n            return count+1;\\n        }\\n        return count;\\n    }\\n    public int GCD(int a,int b){\\n        if (b == 0)\\n            return a;\\n        return GCD(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156681,
                "title": "java-solution",
                "content": "# code\\n<h3>If this solution was helpful then like this like++</h3>\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        //Arrays.sort(numsDivide);\\n        int val=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            val=gcd(val,numsDivide[i]);\\n        }\\n        Arrays.sort(nums);\\n        int c=0;\\n        if(nums[0]>val) return -1;\\n        for(int i=0;i<nums.length;i++){\\n            //if(nums[i]>val) break;\\n            if(val%nums[i]!=0) c++;\\n            else break;\\n        }\\n        if(c==nums.length) return -1;\\n        return c;\\n    }\\n\\n    static int gcd(int a, int b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] numsDivide) {\\n        //Arrays.sort(numsDivide);\\n        int val=numsDivide[0];\\n        for(int i=1;i<numsDivide.length;i++){\\n            val=gcd(val,numsDivide[i]);\\n        }\\n        Arrays.sort(nums);\\n        int c=0;\\n        if(nums[0]>val) return -1;\\n        for(int i=0;i<nums.length;i++){\\n            //if(nums[i]>val) break;\\n            if(val%nums[i]!=0) c++;\\n            else break;\\n        }\\n        if(c==nums.length) return -1;\\n        return c;\\n    }\\n\\n    static int gcd(int a, int b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112978,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minOperations(nums: Array[Int], numsDivide: Array[Int]): Int = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        val n = numsDivide.reduce(gcd)\\n        nums.sorted.indexWhere(n % _ == 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minOperations(nums: Array[Int], numsDivide: Array[Int]): Int = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        val n = numsDivide.reduce(gcd)\\n        nums.sorted.indexWhere(n % _ == 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3058541,
                "title": "java-hashmap-very-easy-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to count up to smallest element which divide all the second array elements.So for that i think that we can sort this both arrays.After HashMap can be implemented to reduce time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all it is the first Hard Question that i solved in one run only.HURRRAH \\nNow comes to the question \\n1.We have to find count up to smallest element that divides all elements of second array .So for that we need to evaluate from smallest ones so we sort this nums array \\n nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\\nnow nums=[2,2,3,3,4]\\n2.Now we are iterating  each element of nums in numsDivide so for this time complexity become O(n^2) but we use hashmap here so if any element can not divide all elements then we add this value count in our ans and remove that element from map like in this test case\\n 2 could not divide all elements so we add just ans+=map.get(2); and map.remove(2);\\nSo now when 2 comes again then we do not process with it because it is not in map .\\n\\n\\n# Complexity\\n- Time complexity:(n*mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] nd) {\\n        Arrays.sort(nums);\\n        Arrays.sort(nd);\\n        int count=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int it:nums){\\n            map.put(it,map.getOrDefault(it,0)+1);\\n        }\\n        int i=0;\\n        boolean check=false;\\n        while(i<nums.length){          \\n            int x=nums[i];\\n            if(map.containsKey(x)){\\n            int j=0;\\n            boolean flag=true;\\n            while(j<nd.length){\\n                if(nd[j]%x!=0){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if(!flag) {\\n                count+=map.get(x);\\n                map.remove(x);\\n            }else{\\n                check=true;\\n                break;\\n            }\\n        }\\n            i++;\\n        }\\n        return check==true?count:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int[] nd) {\\n        Arrays.sort(nums);\\n        Arrays.sort(nd);\\n        int count=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int it:nums){\\n            map.put(it,map.getOrDefault(it,0)+1);\\n        }\\n        int i=0;\\n        boolean check=false;\\n        while(i<nums.length){          \\n            int x=nums[i];\\n            if(map.containsKey(x)){\\n            int j=0;\\n            boolean flag=true;\\n            while(j<nd.length){\\n                if(nd[j]%x!=0){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if(!flag) {\\n                count+=map.get(x);\\n                map.remove(x);\\n            }else{\\n                check=true;\\n                break;\\n            }\\n        }\\n            i++;\\n        }\\n        return check==true?count:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050114,
                "title": "beginner-friendly-easy-to-understand-thoughts-to-code",
                "content": "# Liked the solution please Upvote :)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwhy to use map instead of unordered map ?\\n\\nactually we have to catch the smallest element which divides all the  element of \\'numsdivide\\' array & you know map store element in sorted order\\n\\n1---> store the \\'nums\\' array element in map\\n2---> traverse the element of map and check if it divides all element of \\'numdivide\\' array. if yes that means we have to delete all occurence of that perticular element .\\n\\nEg.  nums = [2,3,2,4,3] , numsDivide = [9,6,9,3,15] \\n    \\n  map => 2- 2\\n         3- 2\\n         4- 1\\n\\n1st iteration -> 2 not divide numsDivide elements so delete all occurence of 2 i.e **ans = 2**\\n\\n2nd itreation -> since 3 divide all elements so just return ans\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool notdivide(int n,vector<int>&numsDivide)\\n   {\\n       for(int i=0;i<numsDivide.size();i++)\\n       {\\n           if(numsDivide[i]%n!=0)\\n           {\\n               return true;\\n           }\\n       }\\n       return false;\\n   }\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        map<int,int> mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n          int ans = 0;\\n        for(auto it:mp)\\n        {\\n            if(notdivide(it.first,numsDivide))\\n            {\\n                ans+=it.second;\\n                mp.erase(it.first) ;\\n            }\\n            else{\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool notdivide(int n,vector<int>&numsDivide)\\n   {\\n       for(int i=0;i<numsDivide.size();i++)\\n       {\\n           if(numsDivide[i]%n!=0)\\n           {\\n               return true;\\n           }\\n       }\\n       return false;\\n   }\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        map<int,int> mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n          int ans = 0;\\n        for(auto it:mp)\\n        {\\n            if(notdivide(it.first,numsDivide))\\n            {\\n                ans+=it.second;\\n                mp.erase(it.first) ;\\n            }\\n            else{\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043959,
                "title": "simplest-approach-gcd-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n      int k=numsDivide[0];\\n      for(int i=1;i<numsDivide.size();i++)\\n      {\\n          k=__gcd(k,numsDivide[i]);\\n      }\\n      sort(nums.begin(),nums.end());\\n      for(int i=0;i<nums.size();i++)\\n        if(!(k%nums[i])) return i;\\n\\n      return -1;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n      int k=numsDivide[0];\\n      for(int i=1;i<numsDivide.size();i++)\\n      {\\n          k=__gcd(k,numsDivide[i]);\\n      }\\n      sort(nums.begin(),nums.end());\\n      for(int i=0;i<nums.size();i++)\\n        if(!(k%nums[i])) return i;\\n\\n      return -1;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043389,
                "title": "gcd-with-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngcd with sort solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngcd with sort solution\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(Nlog(N))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(a<b)return gcd(b,a);\\n        if(a%b == 0) return b;\\n        return gcd(b,a%b);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g=numsDivide[0],counter=-1;\\n        for(int i=1;i<numsDivide.size();i++)g=gcd(g,numsDivide[i]);\\n        for(int i=0;i<nums.size();i++){\\n            if(g%nums[i] == 0)counter = min(counter,nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(g%nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(a<b)return gcd(b,a);\\n        if(a%b == 0) return b;\\n        return gcd(b,a%b);\\n    }\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int g=numsDivide[0],counter=-1;\\n        for(int i=1;i<numsDivide.size();i++)g=gcd(g,numsDivide[i]);\\n        for(int i=0;i<nums.size();i++){\\n            if(g%nums[i] == 0)counter = min(counter,nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0;i<nums.size();i++){\\n            if(g%nums[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040100,
                "title": "faster-gcd-in-c-map-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n Logn) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ --\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n\\n        int hcf ,ans=0;\\n\\n        if(nums.size()>1) hcf=__gcd(numsDivide[0],numsDivide[1]);\\n\\n        else hcf= numsDivide[0];\\n\\n        map<int,int> freq ; bool flag = true ;\\n\\n        //time complexity  of this loop is:o(nlogn) as gcd is log(min(a,b))\\n        for(auto num:numsDivide) hcf = __gcd(hcf,num);\\n\\n        for(auto num:nums) freq[num]++;\\n        \\n        for(auto &[num,count]:freq){\\n\\n            if(num>hcf) break ;\\n\\n            if(hcf%num!=0) ans+=count ;\\n\\n            else{\\n                flag = false ;\\n                break ;\\n            }\\n\\n        }\\n\\n        return flag?-1:ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n\\n        int hcf ,ans=0;\\n\\n        if(nums.size()>1) hcf=__gcd(numsDivide[0],numsDivide[1]);\\n\\n        else hcf= numsDivide[0];\\n\\n        map<int,int> freq ; bool flag = true ;\\n\\n        //time complexity  of this loop is:o(nlogn) as gcd is log(min(a,b))\\n        for(auto num:numsDivide) hcf = __gcd(hcf,num);\\n\\n        for(auto num:nums) freq[num]++;\\n        \\n        for(auto &[num,count]:freq){\\n\\n            if(num>hcf) break ;\\n\\n            if(hcf%num!=0) ans+=count ;\\n\\n            else{\\n                flag = false ;\\n                break ;\\n            }\\n\\n        }\\n\\n        return flag?-1:ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035983,
                "title": "easy-c-solution-using-maps",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    bool check(vector<int> &v, int a){\\n        for(int i = 0;i<v.size();i++){\\n            if(v[i]%a != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n    \\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(numsDivide.begin(), numsDivide.end());\\n        \\n        map<int, int> m;\\n        for(int i = 0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        \\n         map<int, int> mp;\\n        for(int i = 0;i<numsDivide.size();i++){\\n            mp[numsDivide[i]]++;\\n        }\\n        vector<int> v;\\n         for(auto itr = mp.begin();itr != mp.end();itr++){\\n             int y = itr->first;\\n             v.push_back(y);\\n         }\\n            \\n        int ans = 0;\\n        int n = nums.size();\\n        \\n        for(auto itr = m.begin();itr != m.end();itr++){\\n            int a = itr->first;\\n            if(check(v, a) == false){\\n                ans = ans + itr->second;\\n            }else{\\n                break;\\n            }\\n             \\n        }\\n        \\n        if(ans == n){\\n            return -1;\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    bool check(vector<int> &v, int a){\\n        for(int i = 0;i<v.size();i++){\\n            if(v[i]%a != 0){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3026537,
                "title": "simple-c-solution",
                "content": "```\\n int minOperations(vector<int>& A, vector<int>& numsDivide) {\\n        int g = numsDivide[0];\\n        for (int a: numsDivide)\\n            g = gcd(g, a);\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < A.size() && A[i] <= g; ++i)\\n            if (g % A[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n int minOperations(vector<int>& A, vector<int>& numsDivide) {\\n        int g = numsDivide[0];\\n        for (int a: numsDivide)\\n            g = gcd(g, a);\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < A.size() && A[i] <= g; ++i)\\n            if (g % A[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024602,
                "title": "detailed-explanation-very-easy-c",
                "content": "# Intuition\\nInstead of checking divisibility of all the elements of numsDivide we can check divisibility of the GCD of all the elements of numsDivide. This will reduce the runtime.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        int g=numsDivide[0];\\n        for(int x=1; x<numsDivide.size(); x++) g=__gcd(g,numsDivide[x]);\\n        sort(nums.begin(),nums.end());\\n        int x;\\n        for(x=0; x<nums.size(); x++) if(g%nums[x]==0) break;\\n        if(x==nums.size()) return -1;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) \\n    {\\n        int g=numsDivide[0];\\n        for(int x=1; x<numsDivide.size(); x++) g=__gcd(g,numsDivide[x]);\\n        sort(nums.begin(),nums.end());\\n        int x;\\n        for(x=0; x<nums.size(); x++) if(g%nums[x]==0) break;\\n        if(x==nums.size()) return -1;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017942,
                "title": "c-priority-queue-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        for(auto x:numsDivide)gcd = __gcd(gcd,x);\\n        unordered_map<int,int>m;\\n        priority_queue<int,vector<int>,greater<>>pq;\\n        for(auto x:nums){\\n            if(m.find(x)==m.end())pq.push(x);\\n            m[x] += 1;\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int x = pq.top();\\n            pq.pop();\\n            if(gcd%x==0){\\n                return ans;\\n            }\\n            ans += m[x];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Heap (Priority Queue)",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, vector<int>& numsDivide) {\\n        int gcd = numsDivide[0];\\n        for(auto x:numsDivide)gcd = __gcd(gcd,x);\\n        unordered_map<int,int>m;\\n        priority_queue<int,vector<int>,greater<>>pq;\\n        for(auto x:nums){\\n            if(m.find(x)==m.end())pq.push(x);\\n            m[x] += 1;\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int x = pq.top();\\n            pq.pop();\\n            if(gcd%x==0){\\n                return ans;\\n            }\\n            ans += m[x];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014443,
                "title": "javascript-gcd-solution-beast-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} numsDivide\\n * @return {number}\\n */\\nfunction findGCD(a, b) {\\n  if (b === 0) return a;\\n  return findGCD(b, a % b);\\n}\\n\\nfunction minOperations(nums, numsDivide) {\\n  let gcd = numsDivide[0];\\n  for (let i = 1; i < numsDivide.length; i++) {\\n    gcd = findGCD(gcd, numsDivide[i]);\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  let deletions = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (gcd % nums[i] !== 0) deletions++;\\n    else return deletions;\\n  }\\n  return -1;\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} numsDivide\\n * @return {number}\\n */\\nfunction findGCD(a, b) {\\n  if (b === 0) return a;\\n  return findGCD(b, a % b);\\n}\\n\\nfunction minOperations(nums, numsDivide) {\\n  let gcd = numsDivide[0];\\n  for (let i = 1; i < numsDivide.length; i++) {\\n    gcd = findGCD(gcd, numsDivide[i]);\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  let deletions = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (gcd % nums[i] !== 0) deletions++;\\n    else return deletions;\\n  }\\n  return -1;\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1849734,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "It took me 2 minutes to solve. Comparing with other LeetCode problems, this problem is medium if not easy."
                    },
                    {
                        "username": "H4CE",
                        "content": "Easiest Hard Ever!!"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Agree"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "THE HINT IS APPLY GCD ON NumsDivide\nFIND GCD OF NUMSDIVIDE. WHY? BECZ IT WILL GIVE YOU SMALLEST DIVISOR POSSIBLE\nTHEN WE CAN CHECK IN NUMS IF THERE IS ANY POSSIBLE DIVIDE!!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why calculating the GCD of an array by calculating GCD of min and max of array doesn\\'t work here?\\nSame approach worked in problem 1979[Find GCD of the array]."
                    }
                ]
            },
            {
                "id": 1958177,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "It took me 2 minutes to solve. Comparing with other LeetCode problems, this problem is medium if not easy."
                    },
                    {
                        "username": "H4CE",
                        "content": "Easiest Hard Ever!!"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Agree"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "THE HINT IS APPLY GCD ON NumsDivide\nFIND GCD OF NUMSDIVIDE. WHY? BECZ IT WILL GIVE YOU SMALLEST DIVISOR POSSIBLE\nTHEN WE CAN CHECK IN NUMS IF THERE IS ANY POSSIBLE DIVIDE!!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why calculating the GCD of an array by calculating GCD of min and max of array doesn\\'t work here?\\nSame approach worked in problem 1979[Find GCD of the array]."
                    }
                ]
            },
            {
                "id": 1755425,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "It took me 2 minutes to solve. Comparing with other LeetCode problems, this problem is medium if not easy."
                    },
                    {
                        "username": "H4CE",
                        "content": "Easiest Hard Ever!!"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Agree"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "THE HINT IS APPLY GCD ON NumsDivide\nFIND GCD OF NUMSDIVIDE. WHY? BECZ IT WILL GIVE YOU SMALLEST DIVISOR POSSIBLE\nTHEN WE CAN CHECK IN NUMS IF THERE IS ANY POSSIBLE DIVIDE!!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why calculating the GCD of an array by calculating GCD of min and max of array doesn\\'t work here?\\nSame approach worked in problem 1979[Find GCD of the array]."
                    }
                ]
            },
            {
                "id": 1777399,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "It took me 2 minutes to solve. Comparing with other LeetCode problems, this problem is medium if not easy."
                    },
                    {
                        "username": "H4CE",
                        "content": "Easiest Hard Ever!!"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Agree"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "THE HINT IS APPLY GCD ON NumsDivide\nFIND GCD OF NUMSDIVIDE. WHY? BECZ IT WILL GIVE YOU SMALLEST DIVISOR POSSIBLE\nTHEN WE CAN CHECK IN NUMS IF THERE IS ANY POSSIBLE DIVIDE!!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why calculating the GCD of an array by calculating GCD of min and max of array doesn\\'t work here?\\nSame approach worked in problem 1979[Find GCD of the array]."
                    }
                ]
            }
        ]
    }
]