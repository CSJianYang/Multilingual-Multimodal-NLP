[
    {
        "title": "Pass the Pillow",
        "question_content": "There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n\n\tFor example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.\n\nGiven the two positive integers n and time, return the index of the person holding the pillow after time seconds.\n&nbsp;\nExample 1:\n\nInput: n = 4, time = 5\nOutput: 2\nExplanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\nAfer five seconds, the pillow is given to the 2nd person.\n\nExample 2:\n\nInput: n = 3, time = 2\nOutput: 3\nExplanation: People pass the pillow in the following way: 1 -> 2 -> 3.\nAfer two seconds, the pillow is given to the 3rd person.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 1000\n\t1 <= time <= 1000",
        "solutions": [
            {
                "id": 3258156,
                "title": "java-c-python-one-line-o-1",
                "content": "# **Intuition**\\nGoing forward and back to the original position,\\ntake `n * 2 - 2` steps.\\n<br>\\n\\n# **Explanation**\\nOne loop take `n * 2 - 2` steps,\\nso we can first do `time %= (n * 2 - 2)` to save the `time`.\\n\\nNow we are still at position `1`\\nand it takes `n - 1` steps from `1` to `n`.\\n\\nIf `times < n - 1`, not reach `n` yet.\\nIf `times > n - 1`, will go back from `n`.\\n\\nWe calculate the distance from `n`,\\nwhich `abs(n - 1 - time)`,\\nand return `n - abs(n - 1 - time)`.\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int passThePillow(int n, int time) {\\n        return n - Math.abs(n - 1 - time % (n * 2 - 2));\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int passThePillow(int n, int time) {\\n        return n - abs(n - 1 - time % (n * 2 - 2));\\n    }\\n```\\n\\n**Python**\\n```py\\n    def passThePillow(self, n, time):\\n        return n - abs(n - 1 - time % (n * 2 - 2))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int passThePillow(int n, int time) {\\n        return n - Math.abs(n - 1 - time % (n * 2 - 2));\\n    }\\n```\n```cpp\\n    int passThePillow(int n, int time) {\\n        return n - abs(n - 1 - time % (n * 2 - 2));\\n    }\\n```\n```py\\n    def passThePillow(self, n, time):\\n        return n - abs(n - 1 - time % (n * 2 - 2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3258946,
                "title": "super-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- for n people, each round (from one end to the other) needs n-1 times of passing\\n- Last round direction:\\n    -  Left to right: k th pass will put the pillow at index: k+1\\n        - think about it, 1 pass put you at index 2 (1 -> 2), index starts from 1 here\\n    - Right to left: k th pass will put the pillow at index: n-k\\n        - last person\\'s index is n, 1 pass will put pillow at index: n -> n-1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int passThePillow(int n, int t) {\\n        int rounds = t/(n-1); // how many rounds have we passed back and forth\\n        int k = t % (n-1); // index starting from left or right at the last round\\n        return rounds % 2 == 0 ? k+1 : n - k;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int passThePillow(int n, int t) {\\n        int rounds = t/(n-1); // how many rounds have we passed back and forth\\n        int k = t % (n-1); // index starting from left or right at the last round\\n        return rounds % 2 == 0 ? k+1 : n - k;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258310,
                "title": "o-1",
                "content": "The full cycle takes `(n - 1) * 2` seconds (e.g. `1->2->3->4->3->2->1` takes 3 * 2 = 6 seconds). \\n\\nSo, we remove complete cycles (using modulo) and `1` so we are back at the first position.\\n\\nNote that we need to invert the position (`n * 2 - time`) if we are in the second part of the cycle.\\n\\n**C++**\\n```cpp\\nint passThePillow(int n, int time) {\\n    time = time % ((n - 1) * 2) + 1;\\n    return min(time, n * 2 - time);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint passThePillow(int n, int time) {\\n    time = time % ((n - 1) * 2) + 1;\\n    return min(time, n * 2 - time);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259675,
                "title": "white-board-solution-o-1-solution-video-solution-intution",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=gPUSB5u9zbA\\n\\n# Approach & Intution\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/438b7c50-851b-45f9-9374-b56347c7f7df_1678009728.5578868.png)\\n![image.png](https://assets.leetcode.com/users/images/0085de94-1a12-446e-b802-4c4576a2afbc_1678009738.8610444.png)\\n![image.png](https://assets.leetcode.com/users/images/874a2cfe-1577-4b00-aab9-fb947e64e4a2_1678009750.0435722.png)\\n![image.png](https://assets.leetcode.com/users/images/1a14be3e-e42c-4c8a-89b8-08a3697f73ef_1678009762.125701.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        \\n        int rounds = time/(n-1);\\n        int ans = 0;\\n        if(rounds%2 == 0){\\n            ans = (1+time%(n-1));\\n        }else{\\n            ans = (n-time%(n-1));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        \\n        int rounds = time/(n-1);\\n        int ans = 0;\\n        if(rounds%2 == 0){\\n            ans = (1+time%(n-1));\\n        }else{\\n            ans = (n-time%(n-1));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258340,
                "title": "c-if-else-o-1",
                "content": "\\n\\n# Approach\\n- Suppose if there are 4 persons, the number of passes is 3 at a time.\\n- Divide the time with the total number of persons.\\n- If the quotient is even : then we have to start the pass from the 1st person.\\n- Else if the quotient is odd : then we have to start the pass from the end. \\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        \\n        n--;\\n        \\n        int rem = time % n;\\n        int quo = time / n;\\n        \\n        // Left -> right only in one direction\\n        if( quo%2 != 0 ) return (n-rem)+1;\\n        \\n        // Left -> right then right -> left \\n        return rem+1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        \\n        n--;\\n        \\n        int rem = time % n;\\n        int quo = time / n;\\n        \\n        // Left -> right only in one direction\\n        if( quo%2 != 0 ) return (n-rem)+1;\\n        \\n        // Left -> right then right -> left \\n        return rem+1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259343,
                "title": "python-3-3-lines-w-comments-t-m-100-100",
                "content": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        n-= 1                       # the count of passes per traverse is one less than the count of the persons\\n        time%= n+n                  # account for the full laps to return to the beginning\\n        \\n        return n+1 - abs(n - time)  # determine the final position\\n```\\n[https://leetcode.com/problems/pass-the-pillow/submissions/909417872/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        n-= 1                       # the count of passes per traverse is one less than the count of the persons\\n        time%= n+n                  # account for the full laps to return to the beginning\\n        \\n        return n+1 - abs(n - time)  # determine the final position\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258201,
                "title": "java-mathematical-solution",
                "content": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int timeTakenForOnePass=n-1;\\n        int totalPasses=time/timeTakenForOnePass;\\n        int rem=time%timeTakenForOnePass;\\n        return totalPasses%2==0?rem+1:n-rem;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int timeTakenForOnePass=n-1;\\n        int totalPasses=time/timeTakenForOnePass;\\n        int rem=time%timeTakenForOnePass;\\n        return totalPasses%2==0?rem+1:n-rem;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258151,
                "title": "c-intuitive-approach",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int passThePillow(int n, int time) \\n    {\\n        int idx=1, fl=0;\\n        while(time)\\n        {\\n            if(fl==0) idx++;\\n            else idx--;\\n            if(idx==n) fl=1;\\n            else if(idx==1) fl=0;\\n            time--;\\n        }\\n        return idx;\\n        \\n    }\\n};\\n```\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int passThePillow(int n, int time) \\n    {\\n        int idx=1, fl=0;\\n        while(time)\\n        {\\n            if(fl==0) idx++;\\n            else idx--;\\n            if(idx==n) fl=1;\\n            else if(idx==1) fl=0;\\n            time--;\\n        }\\n        return idx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261671,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        person=1\\n        c=0\\n        while time>0:\\n            if c==0:\\n                person+=1\\n                if person==n:\\n                    c=-1\\n            elif c==-1:\\n                person-=1\\n                if person==1:\\n                    c=0\\n            time-=1\\n        return person\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        person=1\\n        c=0\\n        while time>0:\\n            if c==0:\\n                person+=1\\n                if person==n:\\n                    c=-1\\n            elif c==-1:\\n                person-=1\\n                if person==1:\\n                    c=0\\n            time-=1\\n        return person\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259455,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main thing is to keep the track of the direction of the move for that you can keep a bool which will tell it\\'s going right or left if the index is at 1 or n at that time the direction changes,and rest all you can get from code. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(time)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n         int  position = 1;\\n    bool going_right = true;\\n\\n    for(int i=0;i<time;i++){\\n        if(going_right)\\n            position += 1;\\n        else\\n            position -= 1;\\n\\n        if(position == 1 || position == n)\\n            going_right = !going_right;\\n    }\\n\\n    return position;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n         int  position = 1;\\n    bool going_right = true;\\n\\n    for(int i=0;i<time;i++){\\n        if(going_right)\\n            position += 1;\\n        else\\n            position -= 1;\\n\\n        if(position == 1 || position == n)\\n            going_right = !going_right;\\n    }\\n\\n    return position;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258352,
                "title": "10-line-code-c-time-o-1-space-o-1",
                "content": "```\\nint passThePillow(int n, int time) {\\n        int x = (time)/(n-1);\\n        if(x&1){\\n            x = (time)%(n-1);\\n            return n-x;\\n        }else{\\n            x = time%(n-1);\\n            return 1+x;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nint passThePillow(int n, int time) {\\n        int x = (time)/(n-1);\\n        if(x&1){\\n            x = (time)%(n-1);\\n            return n-x;\\n        }else{\\n            x = time%(n-1);\\n            return 1+x;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258076,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int ind=1;\\n        int bool=1;\\n        for(int i=0;i<time;i++){\\n            if(bool==1){\\n                if(ind<n)\\n                    ind++;\\n                else{\\n                    ind=ind-1;\\n                    bool=0;\\n                }\\n            }\\n            else{\\n                if(ind>1)\\n                    ind=ind-1;\\n                else{\\n                    ind=ind+1;\\n                    bool=1;\\n                }\\n            }\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int ind=1;\\n        int bool=1;\\n        for(int i=0;i<time;i++){\\n            if(bool==1){\\n                if(ind<n)\\n                    ind++;\\n                else{\\n                    ind=ind-1;\\n                    bool=0;\\n                }\\n            }\\n            else{\\n                if(ind>1)\\n                    ind=ind-1;\\n                else{\\n                    ind=ind+1;\\n                    bool=1;\\n                }\\n            }\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534781,
                "title": "100-optimised-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int x = time/(n-1);\\n        time %= (n-1);\\n        if(!(x&1)){\\n            return 1+time;\\n        }\\n        return n-time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int x = time/(n-1);\\n        time %= (n-1);\\n        if(!(x&1)){\\n            return 1+time;\\n        }\\n        return n-time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341224,
                "title": "o-1-step-by-step-explanation",
                "content": "\\n```python []\\nclass Solution:\\n    def passThePillow(self, n: int, k: int) -> int:\\n        path = ((k-1)//(n-1)) + 1\\n        index = k+1 - ((n-1)*(path-1))\\n        return n-index+1 if path & 1 == 0 else index \\n```\\n```C++ []\\nclass Solution \\n{\\npublic:\\n    int passThePillow(int n, int k)\\n    {\\n        int path = ((k-1)/(n-1)) + 1;\\n        int index = k+1 - ((n-1)*(path-1));\\n        return (path&1) == 0 ? n-index+1 : index;\\n    }\\n};\\n```\\n\\n## Approach\\n` Suppose n = 4, k = 11 `\\n```\\n         1   2   3   4    ---   Normal Index 1 to n\\n       \" 4   3   2   1 \"  ---   \" Reverse Index \"\\n                        \\n         1   2   3   4    -----\\n         7   6   5             |\\n             8   9   10        |  Total path = 4 as k+1 =12 finished on 4 no path\\n             12  11       -----\\n\\n We need to return the index of k+1 = 12 which is 2 (See the Normal Index).\\n\\n                \" (13)  12  11  \" -- 4 no path / \\'EVEN NO PATH \\n\\n12 on a \\'EVEN NO PATH\\' MEANS 11 will start from right instead of left, as it starts \\nfrom left so it\\'s at the index 3 (reverse index).\\n\\n9 on a \\'ODD NO PATH\\' means 8 will start from left, so for 9 Normal Indexing.\\nBUT 12 on a \\'EVEN NO PATH\\' so for 9 Reverse Indexing.\\n                   \\n                   NOW  12 - what = it\\'s index (3)\\n                        12 - 9 = 3\\n  12-9 means\\n                  1 \" 2   3   4 \"   |\\n                \" 7   6   5 \"       |  \\n                    \" 8   9   10 \"   --- Path = 4\\n                      12  11        |\\n  if path = 4 then we are subtracting all the PREVIOUS PATH\\'S (PATH-1) VALUES \\n  EXCEPT FOR 1 VALUE FROM THE FIRST ROW from k+1(12)\\n\\n  So PREVIOUS PATH\\'S (PATH-1) VALUES EXCEPT FOR 1 VALUE\\n             = (path-1) * (n-1)\\n             = (4-1) * (4-1)\\n             = 3 * 3\\n             = 9\\n  now, 12 - 9 = 3 and as 12 on a EVEN NO PATH, so the Normal Index for 12 \\n              = n - index + 1\\n              = 4 - 3 + 1\\n              = 2\\n\\nSo all we need to find out the total PATH for k+1 and rest is easy.\\n      For n = 4, k = 1\\n                        1 2     (as k+1 = 2), path = 1\\n                 k = 3\\n                        1 2 3 4 (as k+1 = 4), path = 1\\n                 k = 4\\n                        1 2 3 4\\n                            5   (as k+1 = 5), path = 2 \\n      SO DOESN\\'T MATTER WHATEVER THE N AND K IS, OUR PATH WILL BE MINIMUM 1!\\n      ALL WE NEED TO FIND IF THERE IS MORE PATH EXCEPT FOR THE 1ST NO PATH AND \\nTHEN WE WILL JUST ADD 1 TO GET THE TOTAL PATH.\\n\\n          1 \" 2   3   4 \"   |\\n        \" 7   6   5 \"       |  \\n            \" 8   9   10 \"   --- Path = 4\\n              12  11        |\\n\\n  12 - 4(1st no path) = 8 value left(5 to 12)\\n\\n               \" 7   6   5 \"         \\n                   \" 8   9   10 \"   -- each part has maximum n-1 = 3 values\\n                     12  11\\n\\n  so, ceil(8/3) = 3, so these 3 path + the first path = total 4 path?\\n                           \\n              k+1 - n         12 - 4                 8\\n  So, path = --------- + 1 = --------- + 1 = ceil ( --- ) + 1 = 3 + 1 = 4 \\n                n-1             4-1                  3\\n\\n  if r = k+1-n, m = n-1, then we need to do ceil(r/m) must?\\n  another way to do ceil(r/m) is (r+m-1)/m\\n              k+1-n  +  n-1  - 1          k-1\\n  so, path = -------------------- + 1 = ------- + 1\\n                    n-1                   n-1 \\n    \\n```\\n\\n## Most of the people did this calculation part like time/(n-1) and time%(n-1) but I did this in my own way, at the end O(1) solution both.\\n\\n## Thank you so much for reading. If the post was helpful you may leave an upvote:)\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def passThePillow(self, n: int, k: int) -> int:\\n        path = ((k-1)//(n-1)) + 1\\n        index = k+1 - ((n-1)*(path-1))\\n        return n-index+1 if path & 1 == 0 else index \\n```\n```C++ []\\nclass Solution \\n{\\npublic:\\n    int passThePillow(int n, int k)\\n    {\\n        int path = ((k-1)/(n-1)) + 1;\\n        int index = k+1 - ((n-1)*(path-1));\\n        return (path&1) == 0 ? n-index+1 : index;\\n    }\\n};\\n```\n```\\n         1   2   3   4    ---   Normal Index 1 to n\\n       \" 4   3   2   1 \"  ---   \" Reverse Index \"\\n                        \\n         1   2   3   4    -----\\n         7   6   5             |\\n             8   9   10        |  Total path = 4 as k+1 =12 finished on 4 no path\\n             12  11       -----\\n\\n We need to return the index of k+1 = 12 which is 2 (See the Normal Index).\\n\\n                \" (13)  12  11  \" -- 4 no path / \\'EVEN NO PATH \\n\\n12 on a \\'EVEN NO PATH\\' MEANS 11 will start from right instead of left, as it starts \\nfrom left so it\\'s at the index 3 (reverse index).\\n\\n9 on a \\'ODD NO PATH\\' means 8 will start from left, so for 9 Normal Indexing.\\nBUT 12 on a \\'EVEN NO PATH\\' so for 9 Reverse Indexing.\\n                   \\n                   NOW  12 - what = it\\'s index (3)\\n                        12 - 9 = 3\\n  12-9 means\\n                  1 \" 2   3   4 \"   |\\n                \" 7   6   5 \"       |  \\n                    \" 8   9   10 \"   --- Path = 4\\n                      12  11        |\\n  if path = 4 then we are subtracting all the PREVIOUS PATH\\'S (PATH-1) VALUES \\n  EXCEPT FOR 1 VALUE FROM THE FIRST ROW from k+1(12)\\n\\n  So PREVIOUS PATH\\'S (PATH-1) VALUES EXCEPT FOR 1 VALUE\\n             = (path-1) * (n-1)\\n             = (4-1) * (4-1)\\n             = 3 * 3\\n             = 9\\n  now, 12 - 9 = 3 and as 12 on a EVEN NO PATH, so the Normal Index for 12 \\n              = n - index + 1\\n              = 4 - 3 + 1\\n              = 2\\n\\nSo all we need to find out the total PATH for k+1 and rest is easy.\\n      For n = 4, k = 1\\n                        1 2     (as k+1 = 2), path = 1\\n                 k = 3\\n                        1 2 3 4 (as k+1 = 4), path = 1\\n                 k = 4\\n                        1 2 3 4\\n                            5   (as k+1 = 5), path = 2 \\n      SO DOESN\\'T MATTER WHATEVER THE N AND K IS, OUR PATH WILL BE MINIMUM 1!\\n      ALL WE NEED TO FIND IF THERE IS MORE PATH EXCEPT FOR THE 1ST NO PATH AND \\nTHEN WE WILL JUST ADD 1 TO GET THE TOTAL PATH.\\n\\n          1 \" 2   3   4 \"   |\\n        \" 7   6   5 \"       |  \\n            \" 8   9   10 \"   --- Path = 4\\n              12  11        |\\n\\n  12 - 4(1st no path) = 8 value left(5 to 12)\\n\\n               \" 7   6   5 \"         \\n                   \" 8   9   10 \"   -- each part has maximum n-1 = 3 values\\n                     12  11\\n\\n  so, ceil(8/3) = 3, so these 3 path + the first path = total 4 path?\\n                           \\n              k+1 - n         12 - 4                 8\\n  So, path = --------- + 1 = --------- + 1 = ceil ( --- ) + 1 = 3 + 1 = 4 \\n                n-1             4-1                  3\\n\\n  if r = k+1-n, m = n-1, then we need to do ceil(r/m) must?\\n  another way to do ceil(r/m) is (r+m-1)/m\\n              k+1-n  +  n-1  - 1          k-1\\n  so, path = -------------------- + 1 = ------- + 1\\n                    n-1                   n-1 \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261829,
                "title": "simple-o-1-solution",
                "content": "# Intuition\\nCalculate number of full traversals and number of passes from begining after.\\n\\n# Approach\\nIf we have N people it means we need n-1 passes to move pillow from the first one to the next. If we did even number of traversals it means we start next traversal from the first person, otherwise we start it from the nth person. Number of additional passses except full traversals could be calculated as **time mod (n-1)**.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let count = Math.floor(time / (n-1));\\n    let mod = time % (n-1);\\n    if(count % 2 == 0) {\\n        return 1 + mod\\n    }\\n    return n - mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let count = Math.floor(time / (n-1));\\n    let mod = time % (n-1);\\n    if(count % 2 == 0) {\\n        return 1 + mod\\n    }\\n    return n - mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258426,
                "title": "java-math-o-1-solution",
                "content": "# Intuition\\nOn the position 1, traveling to n needs (n - 1) passes;\\nOn the position n, traveling to 1 needs (n - 1) passes.\\nSo the times can be divided by (n - 1) to see which direction you are in: from 1 to n, or n to 1\\n\\n# Approach\\nFrom 1 to n, the answer should be 1 + remainder;\\nFrom n to 1, the answer shoudl be n - remainder.\\n\\nThanks @gautamhelange, your codes are concise, and I updated mine.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int res = 0, m = time / (n - 1), r = time % (n - 1);\\n        if (m % 2 == 0)\\n        \\tres = 1 + r;\\n        else\\n        \\tres = n - r;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int res = 0, m = time / (n - 1), r = time % (n - 1);\\n        if (m % 2 == 0)\\n        \\tres = 1 + r;\\n        else\\n        \\tres = n - r;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258193,
                "title": "java-simple-2-line-answer-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int passThePillow(int n, int time) {\\n    var div = time / (n-1);\\n    var mod = time % (n-1);\\n\\n    return div % 2 == 0 ? 1 + mod : n - mod;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int passThePillow(int n, int time) {\\n    var div = time / (n-1);\\n    var mod = time % (n-1);\\n\\n    return div % 2 == 0 ? 1 + mod : n - mod;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258150,
                "title": "2582-pass-the-pillow-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n    //     int count=0;\\n    //     for(int i=1; i<=time; i++){\\n    //         if(i < n){\\n    //             count+=1;\\n    //         }\\n    //         if(i>n){\\n    //             count--;\\n    //     }\\n    // }\\n    //     return count;\\n        int cur=1;\\n        int d=1;\\n        int ela=0;\\n        while(ela < time){\\n            cur+=d;\\n            if(cur == n ||cur == 1){\\n                d=-d;\\n            }\\n            ela++;\\n        }\\n        return cur;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n    //     int count=0;\\n    //     for(int i=1; i<=time; i++){\\n    //         if(i < n){\\n    //             count+=1;\\n    //         }\\n    //         if(i>n){\\n    //             count--;\\n    //     }\\n    // }\\n    //     return count;\\n        int cur=1;\\n        int d=1;\\n        int ela=0;\\n        while(ela < time){\\n            cur+=d;\\n            if(cur == n ||cur == 1){\\n                d=-d;\\n            }\\n            ela++;\\n        }\\n        return cur;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258134,
                "title": "python-simple-python-solution-100-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 38 ms, faster than 100.00% of Python3 online submissions for Pass the Pillow.\\n# Memory Usage: 13.9 MB, less than 100.00% of Python3 online submissions for Pass the Pillow.\\n![image](https://assets.leetcode.com/users/images/31dbb597-2197-476f-bdd8-3e8b649c59de_1677989074.7845366.png)\\n\\n\\t\\tclass Solution:\\n\\t\\tdef passThePillow(self, n: int, time: int) -> int:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tstart = 1\\n\\t\\t\\ttrip = 1\\n\\n\\t\\t\\twhile time > 0:\\n\\n\\t\\t\\t\\tif trip % 2 != 0:\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult = result - 1 \\n\\n\\t\\t\\t\\tif result == n or result == 1:\\n\\t\\t\\t\\t\\ttrip = trip + 1\\n\\n\\t\\t\\t\\ttime = time - 1\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 38 ms, faster than 100.00% of Python3 online submissions for Pass the Pillow.\\n# Memory Usage: 13.9 MB, less than 100.00% of Python3 online submissions for Pass the Pillow.\\n![image](https://assets.leetcode.com/users/images/31dbb597-2197-476f-bdd8-3e8b649c59de_1677989074.7845366.png)\\n\\n\\t\\tclass Solution:\\n\\t\\tdef passThePillow(self, n: int, time: int) -> int:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tstart = 1\\n\\t\\t\\ttrip = 1\\n\\n\\t\\t\\twhile time > 0:\\n\\n\\t\\t\\t\\tif trip % 2 != 0:\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult = result - 1 \\n\\n\\t\\t\\t\\tif result == n or result == 1:\\n\\t\\t\\t\\t\\ttrip = trip + 1\\n\\n\\t\\t\\t\\ttime = time - 1\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 3258080,
                "title": "c-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int x = 1,t=0;\\n        bool flg = true;\\n        while(t<time){\\n            if(flg){\\n                x+=1;\\n            }else if(!flg){\\n                x-=1;\\n            }\\n            if(x==n){\\n                flg = !flg;\\n            }else if(x==1){\\n                flg = !flg;\\n            }\\n            t+=1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int x = 1,t=0;\\n        bool flg = true;\\n        while(t<time){\\n            if(flg){\\n                x+=1;\\n            }else if(!flg){\\n                x-=1;\\n            }\\n            if(x==n){\\n                flg = !flg;\\n            }else if(x==1){\\n                flg = !flg;\\n            }\\n            t+=1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034722,
                "title": "pass-the-pillow-o-1-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(1)\\nSpace Complexity: O(1)\\n```\\nvar passThePillow = function(n, time) {\\n    const updatedN = n - 1;\\n    const rotation = parseInt(time / updatedN);\\n    const left = time % updatedN;\\n    if (rotation % 2) {\\n        return n - left;\\n    } else {\\n        return 1 + left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar passThePillow = function(n, time) {\\n    const updatedN = n - 1;\\n    const rotation = parseInt(time / updatedN);\\n    const left = time % updatedN;\\n    if (rotation % 2) {\\n        return n - left;\\n    } else {\\n        return 1 + left;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414418,
                "title": "c-using-flag-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        int count=0;\\n        int flag=1;\\n        while(count!=time)\\n        {\\n            if(flag==1)\\n            {\\n                i++;\\n                if(i==n)\\n                    flag=0;\\n            }\\n            else\\n            {\\n                i--;\\n                if(i==1)\\n                    flag=1;\\n            }\\n            count++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        int count=0;\\n        int flag=1;\\n        while(count!=time)\\n        {\\n            if(flag==1)\\n            {\\n                i++;\\n                if(i==n)\\n                    flag=0;\\n            }\\n            else\\n            {\\n                i--;\\n                if(i==1)\\n                    flag=1;\\n            }\\n            count++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285213,
                "title": "simple-java-solution-with-explanation",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Explanation\\n---\\n* To go from 1 to n it would take (n-1) seconds.\\n* The quotient when time is divided by (n-1) i.e. time/(n-1) will determine the direction in which pillow is moving\\n    * if giventime/(n-1) is even the pillow will be moved from start to end\\n    * if giventime/(n-1) is odd the pillow will be moved from end to start\\n* The remainder when time divided by (n-1) i.e. time%(n-1) will determine the position of the pillow\\n    * rem=time%(n-1)\\n    * Even case: ans=rem+1\\n    * Odd case:ans=n-rem\\n---\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int rem=time%(n-1);\\n        int ans=0;\\n        if ((time/(n-1))%2==0)\\n        {\\n            ans=rem+1;\\n        }\\n        else\\n        {\\n            ans=n-rem;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int rem=time%(n-1);\\n        int ans=0;\\n        if ((time/(n-1))%2==0)\\n        {\\n            ans=rem+1;\\n        }\\n        else\\n        {\\n            ans=n-rem;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275716,
                "title": "python-100-faster-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int: # ---- n = 4 , time = 5 \\n        if time > n:\\n            direction = int(time/(n-1)) # used to find direction, if odd then its going for reverse direction ---- direction = 5/(4-1) = 1\\n            remaning_time = time % (n-1) # used to find the remaning time after reaching last or first place ---- remaning_time = 5 % 3 = 2\\n            return n - remaning_time  if direction % 2 != 0 else 1 + remaning_time # if direction is odd, then the direction is reverse, so we do n - remaning_time, else 1 + remaning_time ---- return 2\\n        elif time == n:\\n            return n-1\\n        else:\\n            return 1 + time\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int: # ---- n = 4 , time = 5 \\n        if time > n:\\n            direction = int(time/(n-1)) # used to find direction, if odd then its going for reverse direction ---- direction = 5/(4-1) = 1\\n            remaning_time = time % (n-1) # used to find the remaning time after reaching last or first place ---- remaning_time = 5 % 3 = 2\\n            return n - remaning_time  if direction % 2 != 0 else 1 + remaning_time # if direction is odd, then the direction is reverse, so we do n - remaning_time, else 1 + remaning_time ---- return 2\\n        elif time == n:\\n            return n-1\\n        else:\\n            return 1 + time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269991,
                "title": "c-python-easy-to-understand",
                "content": "\\n\\n# Approach\\nMove right and left using flag while(time--)\\n\\n\\n# Code :\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int left = 1;\\n        int right = n;\\n        \\n        bool flag = true;\\n        int i = 1;\\n        while(time > 0){\\n            if(flag == true && i <= n){\\n                i++;\\n                time--;\\n                if(i == n){\\n                    flag = false;\\n                }\\n            }\\n            else if(flag == false && i >= 1){\\n                i--;\\n                time--;\\n                if(i == 1){\\n                    flag = true;\\n                }\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```\\n\\n```python []\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        flag = True\\n        i = 1\\n        while time > 0:\\n            if flag == True and i <= n:\\n                i = i+1\\n                time = time-1\\n                if i == n:\\n                    flag = False\\n            elif flag == False and i >= 1:\\n                i = i-1\\n                time = time-1\\n                if i == 1:\\n                    flag = True\\n        return i\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int left = 1;\\n        int right = n;\\n        \\n        bool flag = true;\\n        int i = 1;\\n        while(time > 0){\\n            if(flag == true && i <= n){\\n                i++;\\n                time--;\\n                if(i == n){\\n                    flag = false;\\n                }\\n            }\\n            else if(flag == false && i >= 1){\\n                i--;\\n                time--;\\n                if(i == 1){\\n                    flag = true;\\n                }\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        flag = True\\n        i = 1\\n        while time > 0:\\n            if flag == True and i <= n:\\n                i = i+1\\n                time = time-1\\n                if i == n:\\n                    flag = False\\n            elif flag == False and i >= 1:\\n                i = i-1\\n                time = time-1\\n                if i == 1:\\n                    flag = True\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265535,
                "title": "c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int l = time / (n - 1);\\n        time = time % (n - 1);\\n        return (l & 1) ? n - time: time + 1;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int l = time / (n - 1);\\n        time = time % (n - 1);\\n        return (l & 1) ? n - time: time + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264057,
                "title": "python-solution-100-accepted-and-explained",
                "content": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        go=0 #direction\\n        move=1 #initially one move is already done\\n        \\n        while time>0:\\n            if go==0: #if going right\\n                move+=1\\n            else: #if going left\\n                move-=1\\n            if move==n: #if reached right end\\n                go=1 #give indication to move left next\\n            elif move==1: #if reached left end\\n                go=0 #give indication to move right next\\n            time-=1 #decrease the time as you move\\n            \\n        return move\\n        \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL** \\uD83C\\uDF3A\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/939ceec7-69a5-4174-b49d-388e3aa166e0_1678099916.891117.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        go=0 #direction\\n        move=1 #initially one move is already done\\n        \\n        while time>0:\\n            if go==0: #if going right\\n                move+=1\\n            else: #if going left\\n                move-=1\\n            if move==n: #if reached right end\\n                go=1 #give indication to move left next\\n            elif move==1: #if reached left end\\n                go=0 #give indication to move right next\\n            time-=1 #decrease the time as you move\\n            \\n        return move\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261102,
                "title": "100-beats-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n         int currindex = 1 ;\\n          boolean forward = true;\\n       for(int i = 1 ; i <= time ; i++){\\n         \\n         if(forward){\\n            if(currindex == n){\\n                forward = false;\\n                currindex--;\\n            }else{\\n               currindex++; \\n            } \\n         }else{\\n            if(currindex == 1){\\n                forward = true;\\n                currindex++;\\n            }else{\\n                currindex--;\\n            } \\n         }\\n       }\\n        \\n        return currindex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n         int currindex = 1 ;\\n          boolean forward = true;\\n       for(int i = 1 ; i <= time ; i++){\\n         \\n         if(forward){\\n            if(currindex == n){\\n                forward = false;\\n                currindex--;\\n            }else{\\n               currindex++; \\n            } \\n         }else{\\n            if(currindex == 1){\\n                forward = true;\\n                currindex++;\\n            }else{\\n                currindex--;\\n            } \\n         }\\n       }\\n        \\n        return currindex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260398,
                "title": "c-code-o-1-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(n>time)\\n        {\\n            return time+1;\\n        }\\n        int x=time/(n-1),y=time%(n-1);\\n        if(x%2!=0)\\n        {\\n            return n-y;\\n        }\\n        return y+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(n>time)\\n        {\\n            return time+1;\\n        }\\n        int x=time/(n-1),y=time%(n-1);\\n        if(x%2!=0)\\n        {\\n            return n-y;\\n        }\\n        return y+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258299,
                "title": "python3-math",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e3093716659ec141e47ca013abcf405967592686) for solutions of weekly 335. \\n\\n**Intuition**\\nIf the pillow is passed n-1 times, it will reached the end. After another n-1 times, it will reach the beginnig again. \\nAs a result, there is a periodicity of 2*(n-1). So we can just focus on the the modulus time % 2*(n-1). \\n\\nIf it is passed less than or equal to n-1 times, it will reach index time. Otherwise, it will be at 2*(n-1) - time. Offset it by 1 will be the answer. \\n**Implementation**\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        time %= 2*(n-1)\\n        time -= 2*max(0, time-n+1)\\n        return time+1\\n```\\n**Complexity**\\nTime `O(1)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        time %= 2*(n-1)\\n        time -= 2*max(0, time-n+1)\\n        return time+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258242,
                "title": "beginner-friendly-simple-brute-force-comments",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere the approach is to traverse in two directions i.e., in follow up direction and oppposite direction.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![upvotecat.jpg](https://assets.leetcode.com/users/images/147b8a08-9a5c-4195-b00f-a275aea93a7c_1677989084.5668774.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int curr=1; //current pointer at beginning\\n        int dir=1; \\n        // dir=1 means travelling in follow up direction \\n        // dir=-1 means travelling in opposite direction \\n\\n        for(int i=1;i<=time;i++)\\n        { \\n            if(dir==1)\\n            {\\n                curr++;\\n                if(curr==n) // current reaches last change the direction\\n                    dir=-1;\\n            }\\n            else\\n            {\\n                curr--;\\n                if(curr==1) // current reaches at beginning change the direction\\n                    dir=1;\\n            }\\n        }\\n        return curr;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Brainteaser"
                ],
                "code": "class Solution {\\n    public int passThePillow(int n, int time) {\\n        int curr=1; //current pointer at beginning\\n        int dir=1; \\n        // dir=1 means travelling in follow up direction \\n        // dir=-1 means travelling in opposite direction \\n\\n        for(int i=1;i<=time;i++)\\n        { \\n            if(dir==1)\\n            {\\n                curr++;\\n                if(curr==n) // current reaches last change the direction\\n                    dir=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3258187,
                "title": "java-3-loops-easiest-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider n to be a 1 index based array, increment the index until it reaches n, then decrement until it reaches 1 and repeat until we reach time.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int curr=1;\\n        int currTime=0;\\n        while (currTime<time) {\\n            while (curr<n && currTime<time) {\\n                curr+=1;\\n                currTime++;\\n            }\\n            while (curr>1 && currTime<time) {\\n                curr-=1;\\n                currTime++;\\n            }\\n\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int curr=1;\\n        int currTime=0;\\n        while (currTime<time) {\\n            while (curr<n && currTime<time) {\\n                curr+=1;\\n                currTime++;\\n            }\\n            while (curr>1 && currTime<time) {\\n                curr-=1;\\n                currTime++;\\n            }\\n\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484348,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        while(time){\\n            if(i==1){\\n                int val = min(time,n-1);\\n                i+=val;\\n                time-=val;\\n            }\\n            if(i==n){\\n                int val = min(time,n-1);\\n                i-=val;\\n                time-=val;\\n            }\\n        }        \\n        return i;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        while(time){\\n            if(i==1){\\n                int val = min(time,n-1);\\n                i+=val;\\n                time-=val;\\n            }\\n            if(i==n){\\n                int val = min(time,n-1);\\n                i-=val;\\n                time-=val;\\n            }\\n        }        \\n        return i;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408401,
                "title": "c-easy-solution-0ms",
                "content": "# Complexity\\n- Time complexity:\\nO(time) = constant\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int position = 0;\\n    int direction = 1; \\n    for (int i = 0; i < time; i++) {\\n        if (position == 0) {\\n            direction = 1; \\n        } else if (position == n - 1) {\\n            direction = -1; \\n        }\\n        position += direction;\\n    }\\n    return position + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int position = 0;\\n    int direction = 1; \\n    for (int i = 0; i < time; i++) {\\n        if (position == 0) {\\n            direction = 1; \\n        } else if (position == n - 1) {\\n            direction = -1; \\n        }\\n        position += direction;\\n    }\\n    return position + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382789,
                "title": "java-big-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int num=(time/(n-1));\\n        if(n>time){\\n            return time+1;\\n        }\\n        if(num%2==1){\\n            return n-((time%(n-1)));\\n        }\\n            \\n        return (time%(n-1))+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int num=(time/(n-1));\\n        if(n>time){\\n            return time+1;\\n        }\\n        if(num%2==1){\\n            return n-((time%(n-1)));\\n        }\\n            \\n        return (time%(n-1))+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318184,
                "title": "c-calculate-loop-length-17ms-95",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int PassThePillow(int n, int time) \\n    {\\n        var c = 2 * (n - 1);\\n\\n        var r = time % c;\\n\\n        return 1 + (r < n ? r : c - r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PassThePillow(int n, int time) \\n    {\\n        var c = 2 * (n - 1);\\n\\n        var r = time % c;\\n\\n        return 1 + (r < n ? r : c - r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293355,
                "title": "easy-java-solution-o-1-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        if(n > time){\\n            return time + 1;\\n        }\\n        if((int)(time/(n-1)) % 2 == 1){\\n            return n - (time % (n-1));\\n        }else{\\n            return (time % (n-1)) + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        if(n > time){\\n            return time + 1;\\n        }\\n        if((int)(time/(n-1)) % 2 == 1){\\n            return n - (time % (n-1));\\n        }else{\\n            return (time % (n-1)) + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289222,
                "title": "easy-beginner-friendly-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        double count =0;\\n        while(true){\\n            \\n        for(int i=1; i <=n ; i++ ){\\n            if(count==time){\\n                return i;\\n                break;\\n            }\\n            count++;\\n        }\\n        \\n        for(int i=n-1; i >1 ; i-- ){\\n            if(count==time){\\n                return i;\\n                break;\\n            }\\n                count++;\\n           cout<<count;\\n        }\\n    \\n      \\n        }\\n    return 0;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        double count =0;\\n        while(true){\\n            \\n        for(int i=1; i <=n ; i++ ){\\n            if(count==time){\\n                return i;\\n                break;\\n            }\\n            count++;\\n        }\\n        \\n        for(int i=n-1; i >1 ; i-- ){\\n            if(count==time){\\n                return i;\\n                break;\\n            }\\n                count++;\\n           cout<<count;\\n        }\\n    \\n      \\n        }\\n    return 0;\\n     \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3288568,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n\\n        if (math.ceil(time/(n-1)))%2==0:\\n            return n - (time - (n-1)*(math.ceil(time/(n-1)) - 1))\\n        else:\\n            return 1 + (time - (n-1)*(math.ceil(time/(n-1)) - 1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n\\n        if (math.ceil(time/(n-1)))%2==0:\\n            return n - (time - (n-1)*(math.ceil(time/(n-1)) - 1))\\n        else:\\n            return 1 + (time - (n-1)*(math.ceil(time/(n-1)) - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284837,
                "title": "easy-c-solution-beats-100-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int tim) {\\n    int quo = tim/(n-1);  \\n    if(tim%(n-1) == 0) return quo%2==0?1:n;\\n    else{\\n        int rem = tim%(n-1);\\n        if(quo%2 == 0) return rem+1;\\n        else return n-rem;\\n        }       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int tim) {\\n    int quo = tim/(n-1);  \\n    if(tim%(n-1) == 0) return quo%2==0?1:n;\\n    else{\\n        int rem = tim%(n-1);\\n        if(quo%2 == 0) return rem+1;\\n        else return n-rem;\\n        }       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279589,
                "title": "python-one-liner",
                "content": "# Intuition\\nPython One-Liner :)\\n\\n# Complexity\\nO(1) time and O(1) space :)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def passThePillow(self, n, time):\\n        return (1-((time% ((n-1)<<1)) // (n-1)))* (((time% ((n-1)<<1)) % (n-1)) + 1) + ((time% ((n-1)<<1)) // (n-1))*(n- ((time% ((n-1)<<1)) % (n-1)))\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def passThePillow(self, n, time):\\n        return (1-((time% ((n-1)<<1)) // (n-1)))* (((time% ((n-1)<<1)) % (n-1)) + 1) + ((time% ((n-1)<<1)) // (n-1))*(n- ((time% ((n-1)<<1)) % (n-1)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274770,
                "title": "java-solution-with-explanation",
                "content": "Explaination -:\\nStep 1-: 1 -->2-->3-->4 for reaching to the last person it requires n-1 time . so if time = n-1 we will directly return n.\\nStep 2-:  We will calculate no of Passes , \\n               For one pass it requires n-1 time \\n\\t\\t\\t   therefore, for total no of passes it will be equal to time/(n-1);\\nStep 3-:   We will calculate the remaining by time%(n-1)\\n               for example if n=18 and time = 38;\\n\\t\\t\\t   noOfPassess = 2,  remaining = 4.\\nStep 4-: If no of passess is multiple of 2 that means it is starting from the initial position again , so on that case the index of person will be remainder+1,  \\n          If no of passess is not a multiple of 2 that means it is going back from the last position , on that case the index will be n-remaining.\\n\\t\\t  \\nfor ex: 1-->2-->3-->4-->5-->6--->7-->8-->9\\ni) n=9, time=12\\t\\t  \\n\\t\\t  noOfPasses = 1,\\n\\t\\t  remaining = 4.\\n\\t\\t  it means it just completed one passes and going back from the end . so the index of person will be n-remaining . i.e 9-4=5.\\nii) n=9 ,time 22\\n       noOfPasses = 2,\\n\\t   remaining = 6\\n\\t   it means , it has completed 2 passess and it is again starting from the start so we will count from the start. in this case the answer will be remaining+1 \\n\\t   i.e 6+1=7.\\n\\t\\t  \\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n       if(time==n-1)\\n           return n;\\n       int noOfPasses = time/(n-1);\\n       int remaining = time%(n-1);\\n       if(noOfPasses%2==0)\\n           return remaining+1;\\n        else\\n            return n-remaining;\\n*     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n       if(time==n-1)\\n           return n;\\n       int noOfPasses = time/(n-1);\\n       int remaining = time%(n-1);\\n       if(noOfPasses%2==0)\\n           return remaining+1;\\n        else\\n            return n-remaining;\\n*     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272430,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\nThere are 2 directions: forward and backward. the first step is forward, the second is backward, the third is forward, and so on. Found a pattern that if it is divided by the number of steps (number of people (n) - 1) and result an even value (round-down value) then the step is forward. While if it produces an odd value then the step is backward. The remain value is the number of steps taken from the first person if the steps are forward and the nth person if the steps are backwards.\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    var d = Math.floor(time / (n - 1));\\n    var r = time % (n - 1);\\n\\n    if (d % 2 === 0) {\\n        return 1 + r;\\n    }\\n\\n    return n - r;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    var d = Math.floor(time / (n - 1));\\n    var r = time % (n - 1);\\n\\n    if (d % 2 === 0) {\\n        return 1 + r;\\n    }\\n\\n    return n - r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271793,
                "title": "brute-force-easy-to-understand-simulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) \\n    {\\n         //the first person is holding the pillow\\n         int idx = 1;\\n\\n         //the direction of the passing of the pillow\\n         string dir = \"forward\";\\n\\n         for(int i=1;i<=time;i++)\\n         {\\n             if(idx == n)\\n             {\\n                 dir = \"backward\";\\n             }\\n             else if(idx == 1)\\n             {\\n                 dir = \"forward\";\\n             }\\n\\n             if(dir == \"forward\") idx++;\\n             if(dir == \"backward\") idx--;\\n         }\\n         return idx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) \\n    {\\n         //the first person is holding the pillow\\n         int idx = 1;\\n\\n         //the direction of the passing of the pillow\\n         string dir = \"forward\";\\n\\n         for(int i=1;i<=time;i++)\\n         {\\n             if(idx == n)\\n             {\\n                 dir = \"backward\";\\n             }\\n             else if(idx == 1)\\n             {\\n                 dir = \"forward\";\\n             }\\n\\n             if(dir == \"forward\") idx++;\\n             if(dir == \"backward\") idx--;\\n         }\\n         return idx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271432,
                "title": "constant-space-and-time-approach",
                "content": "# Intuition\\nAt first the problem can be solved using for loops but in this case it will be repetitive task so we can use division and modulus to find the index.\\n\\n# Approach\\nApproach is basic we need to find the direction first which can be done using division and using mod we can find the position from that direction.\\nFor n = 8 we take 7 steps that why there -1 and +1 somewhere.\\nThanks.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(time < n){\\n            return time + 1;\\n        }\\n        int dir = (time/(n - 1))%2;\\n        \\n        if(dir == 0){\\n            return time%(n-1) + 1;\\n        }\\n        return n - (time%(n-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(time < n){\\n            return time + 1;\\n        }\\n        int dir = (time/(n - 1))%2;\\n        \\n        if(dir == 0){\\n            return time%(n-1) + 1;\\n        }\\n        return n - (time%(n-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269458,
                "title": "basic-approach-sc-o-1-tc-o-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO[time]\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO[1]\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i = 1;\\n        int b = 1;\\n        int cnt = 0;\\n        while(cnt < time){\\n            if(i == n) {\\n                i--;\\n                cnt++;\\n            }\\n            else if(i <= b && i > 1){\\n                i--;\\n                cnt++;\\n                if(i == 1) b= 1;\\n            }\\n            else {\\n                i++;\\n                b = i-1;\\n                cnt++;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i = 1;\\n        int b = 1;\\n        int cnt = 0;\\n        while(cnt < time){\\n            if(i == n) {\\n                i--;\\n                cnt++;\\n            }\\n            else if(i <= b && i > 1){\\n                i--;\\n                cnt++;\\n                if(i == 1) b= 1;\\n            }\\n            else {\\n                i++;\\n                b = i-1;\\n                cnt++;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268988,
                "title": "100-easy",
                "content": "# Approach\\nPeroid of the sequence is 2*n-2, so easy to solve once we know the repetion sequence. \\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        // 1 2 3 4 3 2  1 2 3 4 3 2  1 2 3 4 3 2  1 2 3 4 3 2\\n        int  mod = 2*n-2;\\n        if ( time >= mod)\\n            time = time%mod;\\n\\n        if ( time < n) return time+1;\\n        else {\\n            return 2*n-time-1;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        // 1 2 3 4 3 2  1 2 3 4 3 2  1 2 3 4 3 2  1 2 3 4 3 2\\n        int  mod = 2*n-2;\\n        if ( time >= mod)\\n            time = time%mod;\\n\\n        if ( time < n) return time+1;\\n        else {\\n            return 2*n-time-1;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265415,
                "title": "easy-mathematical-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(time<n)return time+1;\\n        else if(time==n)return time-1;\\n        else{\\n            int x=(time)%(2*n-2);\\n            if(x<n)return x+1;\\n            else{\\n                return 2*n-x-1;\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(time<n)return time+1;\\n        else if(time==n)return time-1;\\n        else{\\n            int x=(time)%(2*n-2);\\n            if(x<n)return x+1;\\n            else{\\n                return 2*n-x-1;\\n            }\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264716,
                "title": "python-easy-solution-easy-to-understand-successfully-passed",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n3 conditons ==> \\n1) when time is greater than n\\n2) when time is lesser than n\\n3) when time is equal to n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        rounds=time//(n-1)\\n        steps=rounds*(n-1)\\n        if time<n:\\n            result=time+1\\n        elif time>n:\\n            if rounds%2==0:\\n                result=(time-steps)+1\\n            else:\\n                result=n-((time-steps)+1)+1\\n        else:\\n            result=time-1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        rounds=time//(n-1)\\n        steps=rounds*(n-1)\\n        if time<n:\\n            result=time+1\\n        elif time>n:\\n            if rounds%2==0:\\n                result=(time-steps)+1\\n            else:\\n                result=n-((time-steps)+1)+1\\n        else:\\n            result=time-1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262675,
                "title": "very-easy-solution-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        boolean forward=true;\\n        time=time+1;\\n        int i=0;\\n        while(time>0){\\n            if(forward==true){\\n                if(i==n){\\n                    i--;\\n                    forward=false;\\n                }else{\\n                    i++;\\n                }\\n            }\\n            else{\\n                if(i==1){\\n                    i++;\\n                    forward=true;\\n                }else{\\n                    i--;\\n                }\\n            }\\n            time--;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        boolean forward=true;\\n        time=time+1;\\n        int i=0;\\n        while(time>0){\\n            if(forward==true){\\n                if(i==n){\\n                    i--;\\n                    forward=false;\\n                }else{\\n                    i++;\\n                }\\n            }\\n            else{\\n                if(i==1){\\n                    i++;\\n                    forward=true;\\n                }else{\\n                    i--;\\n                }\\n            }\\n            time--;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261978,
                "title": "python3-33ms-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/b58c81f8-affa-4e7b-aabd-6c7bb2828d01_1678056634.9569702.png)\\n\\n\\nAlongside the timer ,using a pointer to iterate from 1 to the n and if the pointer = n; n becomes negative and we iterate on the way back, and if time = 0 and the pointer is negative we multiply it by -1 and it will become positive.\\n\\nHere\\'s the code:\\n\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        p1 = 1\\n        p2 = -n\\n        while time != 0: \\n            p1 += 1\\n            time -= 1      \\n            if p1 == n:\\n                p1 = p2 \\n            elif p1 == -1:\\n                p1 = 1\\n        if p1 < 0:\\n            p1 = p1 * (-1)\\n        else:\\n            pass\\n        return p1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        p1 = 1\\n        p2 = -n\\n        while time != 0: \\n            p1 += 1\\n            time -= 1      \\n            if p1 == n:\\n                p1 = p2 \\n            elif p1 == -1:\\n                p1 = 1\\n        if p1 < 0:\\n            p1 = p1 * (-1)\\n        else:\\n            pass\\n        return p1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261686,
                "title": "brute-flip-method-c-easy-understanding",
                "content": "**Intuition:** Just flip the operation on reaching the edge case (end points)\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int a=1,i=1;\\n        while(time--){\\n            if(a)i++;\\n            else i--;\\n            if(i==n || i==1)a=!a;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int a=1,i=1;\\n        while(time--){\\n            if(a)i++;\\n            else i--;\\n            if(i==n || i==1)a=!a;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261197,
                "title": "python-easy-to-understand-4-lines",
                "content": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        q, r = divmod(time, n - 1)\\n        if q % 2 == 0:      # even cycles\\n            return 1 + r    # return position\\n        return n - r        # odd cycles, position from end\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        q, r = divmod(time, n - 1)\\n        if q % 2 == 0:      # even cycles\\n            return 1 + r    # return position\\n        return n - r        # odd cycles, position from end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261110,
                "title": "simple-java-solution-beats-100-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        \\n        boolean forward = true;\\n        int idx = 1;\\n        for(int i=1; i<=time; i++) {\\n            \\n            if(forward==true) {\\n                idx++;\\n                if(idx==n) {\\n                    forward = false;\\n                }\\n            }\\n            \\n            else {\\n                idx--;\\n                if(idx==1) {\\n                    forward = true;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        \\n        boolean forward = true;\\n        int idx = 1;\\n        for(int i=1; i<=time; i++) {\\n            \\n            if(forward==true) {\\n                idx++;\\n                if(idx==n) {\\n                    forward = false;\\n                }\\n            }\\n            \\n            else {\\n                idx--;\\n                if(idx==1) {\\n                    forward = true;\\n                }\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260493,
                "title": "c-math",
                "content": "Time complexity : O(1)\\nSpace complexity : O(1)\\n\\n```\\nint passThePillow(const int n, const int time){\\n\\treturn n - abs(\\n\\t\\ttime % ( (n - 1) * 2 )\\n\\t\\t\\t- (n - 1)\\n\\t);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint passThePillow(const int n, const int time){\\n\\treturn n - abs(\\n\\t\\ttime % ( (n - 1) * 2 )\\n\\t\\t\\t- (n - 1)\\n\\t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260484,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn pass_the_pillow(n: i32, time: i32) -> i32 {\\n        n - (n - 1 - time % (n * 2 - 2)).abs()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn pass_the_pillow(n: i32, time: i32) -> i32 {\\n        n - (n - 1 - time % (n * 2 - 2)).abs()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260232,
                "title": "beats-100-c-easy-to-understand-solution",
                "content": "# Intuition and Approach\\nWe are creating an `current` int which will help us traverse the people of count `n`\\nThen using some conditions we are using it to move forward and then backward in the peoples `n`\\nYou can Understand it more by checking out the code\\n\\n**Your Upvote Will Motivates me so do if you like**\\n\\n# Complexity\\n- Time complexity:O(time)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int passThePillow(int n, int time) {\\n        //Base Condition if the elements are greater than the time then we dont need to reverse pass the pillow\\n        if(n>time){\\n            return time+1;\\n        }\\n        //Base condition if elements are equal to time then it always the (n-1)th person\\n        if(n==time){\\n            return n-1;\\n        }\\n        int curr=1,flag=1;\\n        while(time--){    \\n            //condition to track if pillow reached last position\\n            if(curr==n){\\n                flag=0;\\n            }\\n            //condition to track if pillow reached first position\\n            else if(curr==1){\\n                flag=1;\\n            }\\n            //increase the value of curr up untill it reaches to last position else decrease\\n            if(flag){curr++;}\\n            else{curr--;}         \\n        \\n        }            \\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int passThePillow(int n, int time) {\\n        //Base Condition if the elements are greater than the time then we dont need to reverse pass the pillow\\n        if(n>time){\\n            return time+1;\\n        }\\n        //Base condition if elements are equal to time then it always the (n-1)th person\\n        if(n==time){\\n            return n-1;\\n        }\\n        int curr=1,flag=1;\\n        while(time--){    \\n            //condition to track if pillow reached last position\\n            if(curr==n){\\n                flag=0;\\n            }\\n            //condition to track if pillow reached first position\\n            else if(curr==1){\\n                flag=1;\\n            }\\n            //increase the value of curr up untill it reaches to last position else decrease\\n            if(flag){curr++;}\\n            else{curr--;}         \\n        \\n        }            \\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260037,
                "title": "c-100-runtime-100-space-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: //Comment kr do mere se nhi hua ;(\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        vector<int>v1; \\n        vector<int>v2;\\n\\n        int i=1;\\n        while(i<=n){\\n            v1.push_back(i++);\\n        } \\n\\n        i=n-1;\\n        while(i>0){\\n            v2.push_back(i--);\\n        }\\n\\n        vector<int>ans;\\n        int cnt=1;\\n\\n        for(int it:v1)ans.push_back(it);\\n        for(int it:v2)ans.push_back(it);\\n\\n        while(cnt<=time){\\n\\n            int i=2;\\n            while(i<=n){\\n                ans.push_back(i++);\\n                cnt++;\\n            } \\n\\n            i=n-1;\\n            while(i>0){\\n                ans.push_back(i--);\\n                cnt++;\\n            }\\n        }\\n\\n        for(int it:ans){\\n            cout<<it<<\" \";\\n        }\\n        return ans[time];\\n    }\\n};\\n\\n// 4 => 1 2 3 4  3 2 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        vector<int>v1; \\n        vector<int>v2;\\n\\n        int i=1;\\n        while(i<=n){\\n            v1.push_back(i++);\\n        } \\n\\n        i=n-1;\\n        while(i>0){\\n            v2.push_back(i--);\\n        }\\n\\n        vector<int>ans;\\n        int cnt=1;\\n\\n        for(int it:v1)ans.push_back(it);\\n        for(int it:v2)ans.push_back(it);\\n\\n        while(cnt<=time){\\n\\n            int i=2;\\n            while(i<=n){\\n                ans.push_back(i++);\\n                cnt++;\\n            } \\n\\n            i=n-1;\\n            while(i>0){\\n                ans.push_back(i--);\\n                cnt++;\\n            }\\n        }\\n\\n        for(int it:ans){\\n            cout<<it<<\" \";\\n        }\\n        return ans[time];\\n    }\\n};\\n\\n// 4 => 1 2 3 4  3 2 1\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3259367,
                "title": "beginner-friendly-and-easy-to-understand-python-solution",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//TC - O(t)\\n//SC - O(1)\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if(time < n):\\n            return time+1\\n        d = \\'f\\'\\n        i = 1\\n        while(time > 0):\\n            if(d == \\'f\\'):\\n                i+=1\\n                if(i == n):\\n                    d = \\'r\\'\\n            else:\\n                i-=1\\n                if(i == 1):\\n                    d = \\'f\\'\\n            time-=1\\n        return i \\n```\\n```\\n//TC - O(1)\\n//SC - O(1)\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        r = time//(n-1)\\n        i = time%(n-1)\\n        if(r%2 == 0):\\n            return i+1\\n        return n-i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n//TC - O(t)\\n//SC - O(1)\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if(time < n):\\n            return time+1\\n        d = \\'f\\'\\n        i = 1\\n        while(time > 0):\\n            if(d == \\'f\\'):\\n                i+=1\\n                if(i == n):\\n                    d = \\'r\\'\\n            else:\\n                i-=1\\n                if(i == 1):\\n                    d = \\'f\\'\\n            time-=1\\n        return i \\n```\n```\\n//TC - O(1)\\n//SC - O(1)\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        r = time//(n-1)\\n        i = time%(n-1)\\n        if(r%2 == 0):\\n            return i+1\\n        return n-i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259104,
                "title": "0ms-java-solution-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int i =1;\\n        boolean flag = false;\\n        while(time-- != 0){\\n            if(!flag) i++;\\n            if(flag) i--;\\n            if(i == n) flag = true;\\n            if(i == 1) flag = false; \\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int i =1;\\n        boolean flag = false;\\n        while(time-- != 0){\\n            if(!flag) i++;\\n            if(flag) i--;\\n            if(i == n) flag = true;\\n            if(i == 1) flag = false; \\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259078,
                "title": "o-1-time-100-faster-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n       if(n>time) return time+1;\\n        int ans=time%(n-1);\\n        int t=time/(n-1);\\n        \\n        if(t%2==0) return ans+1;\\n     \\n      \\n        ans=n-ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n       if(n>time) return time+1;\\n        int ans=time%(n-1);\\n        int t=time/(n-1);\\n        \\n        if(t%2==0) return ans+1;\\n     \\n      \\n        ans=n-ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258772,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n         if(n > time){\\n            return time+1;\\n        }\\n        \\n        int res = 1, i = 1;\\n        bool flag = true;\\n        while(i<=time){\\n            if(res == 1)\\n                flag = true;\\n            \\n            if(res==n)\\n                flag = false;\\n            \\n            flag ? res++ : res--;\\n            i++;\\n        }\\n        return res;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n         if(n > time){\\n            return time+1;\\n        }\\n        \\n        int res = 1, i = 1;\\n        bool flag = true;\\n        while(i<=time){\\n            if(res == 1)\\n                flag = true;\\n            \\n            if(res==n)\\n                flag = false;\\n            \\n            flag ? res++ : res--;\\n            i++;\\n        }\\n        return res;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258609,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        \\n        if(n > time){\\n            return time+1;\\n        }\\n        \\n        int res = 1, i = 1;\\n        bool flag = true;\\n        while(i<=time){\\n            if(res == 1)\\n                flag = true;\\n            \\n            if(res==n)\\n                flag = false;\\n            \\n            flag ? res++ : res--;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        \\n        if(n > time){\\n            return time+1;\\n        }\\n        \\n        int res = 1, i = 1;\\n        bool flag = true;\\n        while(i<=time){\\n            if(res == 1)\\n                flag = true;\\n            \\n            if(res==n)\\n                flag = false;\\n            \\n            flag ? res++ : res--;\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258474,
                "title": "0ms-100-faster-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        boolean forward =true;\\n        int i=0;\\n        time+=1;\\n        while(time>0){\\n            if(forward){\\n                if(i==n){\\n                    i--;\\n                    forward=false;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            else{\\n                if(i==1){\\n                    i++;\\n                    forward=true;\\n                }\\n                else{\\n                    i--;\\n                }\\n            }\\n            time--;\\n        }\\n        \\n        return i;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        boolean forward =true;\\n        int i=0;\\n        time+=1;\\n        while(time>0){\\n            if(forward){\\n                if(i==n){\\n                    i--;\\n                    forward=false;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            else{\\n                if(i==1){\\n                    i++;\\n                    forward=true;\\n                }\\n                else{\\n                    i--;\\n                }\\n            }\\n            time--;\\n        }\\n        \\n        return i;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258396,
                "title": "o-1-easy-python-maths",
                "content": "# Intuition\\n`case 1: Given time < n => you can reach time + 1 position`\\n`case 2: given time >= n`\\nfind the amount of time you require to complete 1 loop i.e to reach end of n (i.e n- 1) so with given amount of time find the number of loops u can perform\\n`case 1: You get odd number of rounds so u will pass the pillow from last digit 8 -> 7 -> 6...`\\n`case 2: You get even number of rounds so u will pass the from first digit 1 -> 2 -> 3 -> ...`\\nNow how to find till where we can go? The remaining time with you after doing number of rounds.\\nIf rounds even => 1 + timeLeft (1 -> 2 -> 3 -> ...)\\nrounds odd => n - timeLeft ( 8 -> 7 -> 6...)\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if time < n:\\n            return time + 1\\n        else:\\n            timeRequired = n - 1\\n            rounds = time // timeRequired\\n            timeUsed = timeRequired * rounds\\n            timeLeft = time - timeUsed\\n            if rounds % 2 == 0: #even start from 1\\n                return 1 + timeLeft\\n            else:\\n                return n - timeLeft\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if time < n:\\n            return time + 1\\n        else:\\n            timeRequired = n - 1\\n            rounds = time // timeRequired\\n            timeUsed = timeRequired * rounds\\n            timeLeft = time - timeUsed\\n            if rounds % 2 == 0: #even start from 1\\n                return 1 + timeLeft\\n            else:\\n                return n - timeLeft\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258359,
                "title": "a-simple-c-solution-using-stack-4ms",
                "content": "# Intuition\\nA c++ simple stack approach\\n# Approach\\nusing stack \\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int count=0;\\n        stack<int> s;\\n        s.push(1);\\n        int flag=0;\\n        int i=2;\\n        while(count<time)\\n        {\\n          if(flag==0)\\n          {\\n              s.push(i);\\n              count++;\\n              i++;\\n          }\\n         else  if(flag==1)\\n          {\\n              s.pop();\\n              count++;\\n              \\n          }\\n          if(s.top()==1)\\n          {\\n              flag=0;\\n              i=2;\\n          }\\n           else if(s.top()==n)\\n               flag=1;    \\n           if(count==time) \\n               return s.top();\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int count=0;\\n        stack<int> s;\\n        s.push(1);\\n        int flag=0;\\n        int i=2;\\n        while(count<time)\\n        {\\n          if(flag==0)\\n          {\\n              s.push(i);\\n              count++;\\n              i++;\\n          }\\n         else  if(flag==1)\\n          {\\n              s.pop();\\n              count++;\\n              \\n          }\\n          if(s.top()==1)\\n          {\\n              flag=0;\\n              i=2;\\n          }\\n           else if(s.top()==n)\\n               flag=1;    \\n           if(count==time) \\n               return s.top();\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258274,
                "title": "most-basic-approach-c-fast-and-easy-code",
                "content": "# Intuition\\nwe will start from 1st person then when t is not zero but pillow reached last guy then need reverse the work, so need some boolean variable which will indicate whether going forward or backward.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nso i starts from 1, now until t will become 0 we will run a loop, if I am going forward means sach==false, then do i++ and  t--, which means decrement time and pillow will move backward, if i==n and sach==false means pillow is moving backward and has reached end of queue so need to reverse , so sach=true, now if sach is true then do t-- and i-- which means time is decrementing and pillow will move in forward direction.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int t) {\\n        bool sach=false;\\n        int i=1;\\n        while(t){\\n            if(!sach){\\n                t--;\\n                i++;\\n            }\\n            if(sach){\\n                t--;\\n                i--;\\n            }\\n            if(i==1 && t!=0 && sach){\\n                sach=false;\\n            }\\n            if(i==n && t!=0 && !sach){\\n                sach=true;\\n            }\\n            \\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int t) {\\n        bool sach=false;\\n        int i=1;\\n        while(t){\\n            if(!sach){\\n                t--;\\n                i++;\\n            }\\n            if(sach){\\n                t--;\\n                i--;\\n            }\\n            if(i==1 && t!=0 && sach){\\n                sach=false;\\n            }\\n            if(i==n && t!=0 && !sach){\\n                sach=true;\\n            }\\n            \\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258250,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int person=1;\\n        bool flag = true;\\n        for(int i=1;i<=time;i++){\\n            if(person==1){\\n                flag=true;\\n            }\\n            if(person == n){\\n                flag=false;\\n            }\\n            flag == true ? person++ : person--;\\n        }\\n        return person;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int person=1;\\n        bool flag = true;\\n        for(int i=1;i<=time;i++){\\n            if(person==1){\\n                flag=true;\\n            }\\n            if(person == n){\\n                flag=false;\\n            }\\n            flag == true ? person++ : person--;\\n        }\\n        return person;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258190,
                "title": "simple-solution-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        position = 0\\n        move = -1\\n        while time > 0:\\n            if position == n - 1 or position == 0:\\n                move *= -1\\n            position += move\\n            time -=1 \\n            \\n        return position + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        position = 0\\n        move = -1\\n        while time > 0:\\n            if position == n - 1 or position == 0:\\n                move *= -1\\n            position += move\\n            time -=1 \\n            \\n        return position + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258138,
                "title": "easy-c-code-15line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        bool flag=true;\\n        int temp=1;\\n        for(int i=0;i<time;i++)\\n        {\\n                 if(temp!=n && flag)\\n                 {\\n                     temp++;\\n                 }else if(temp==n && flag)\\n                 {\\n                     temp--;\\n                     flag=false;\\n                 } else if(temp!=1 && flag==false)\\n                     temp--;\\n            else{\\n                    temp++;\\n                flag=true;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        bool flag=true;\\n        int temp=1;\\n        for(int i=0;i<time;i++)\\n        {\\n                 if(temp!=n && flag)\\n                 {\\n                     temp++;\\n                 }else if(temp==n && flag)\\n                 {\\n                     temp--;\\n                     flag=false;\\n                 } else if(temp!=1 && flag==false)\\n                     temp--;\\n            else{\\n                    temp++;\\n                flag=true;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258129,
                "title": "beats-99-70-speed-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        a = [i for i in range(1, n+1)]\\n        b = [i for i in range(n-1, 1, -1)]\\n        c = (a + b)*(1 + time//n)\\n        return c[time]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        a = [i for i in range(1, n+1)]\\n        b = [i for i in range(n-1, 1, -1)]\\n        c = (a + b)*(1 + time//n)\\n        return c[time]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258123,
                "title": "easy-o-1",
                "content": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        time %= (2*n-2);\\n        if(time <= n-1) return time+1;\\n        else return 2*n-1-time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        time %= (2*n-2);\\n        if(time <= n-1) return time+1;\\n        else return 2*n-1-time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258095,
                "title": "simple-approach-in-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int index=1;\\n        int cnt=1;\\n        while(time--){\\n\\n          if(index==1)\\n              cnt=1;\\n            if(index==n)\\n                cnt=-1;\\n            \\n          index+=cnt;\\n\\n }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int index=1;\\n        int cnt=1;\\n        while(time--){\\n\\n          if(index==1)\\n              cnt=1;\\n            if(index==n)\\n                cnt=-1;\\n            \\n          index+=cnt;\\n\\n }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258090,
                "title": "o-1-time-o-1-space",
                "content": "# Intuition\\nMath.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int k = time % (n-1);\\n        \\n        if((time / (n-1)) % 2) return n - k;\\n        else return k + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int k = time % (n-1);\\n        \\n        if((time / (n-1)) % 2) return n - k;\\n        else return k + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258086,
                "title": "simple-simulation-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int idx = 0, dir = 0;\\n        while(time--){\\n            if(idx == 0){\\n                dir = 1;\\n            }else if(idx == n - 1){\\n                dir = -1;\\n            }\\n            if(dir == 1) idx++;\\n            else    idx--;\\n        }\\n        return idx + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int idx = 0, dir = 0;\\n        while(time--){\\n            if(idx == 0){\\n                dir = 1;\\n            }else if(idx == n - 1){\\n                dir = -1;\\n            }\\n            if(dir == 1) idx++;\\n            else    idx--;\\n        }\\n        return idx + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099449,
                "title": "two-lines-solution-using-divmod",
                "content": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        d, m = divmod(time, n-1)\\n        return n-m if d%2 else m+1   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        d, m = divmod(time, n-1)\\n        return n-m if d%2 else m+1   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096364,
                "title": "php",
                "content": "![Screen Shot 2023-09-27 at 8.38.16 AM.png](https://assets.leetcode.com/users/images/f80f0b96-ab51-49c4-95f1-02be932386e1_1695818363.4235418.png)\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n  /**\\n   * @param Integer $n\\n   * @param Integer $time\\n   * @return Integer\\n   */\\n  function passThePillow($n, $time)\\n  {\\n\\n    $pillow_cursor = 1;\\n    $direction = \"inc\";\\n    for ($i = 1; $i <= $time; $i++) {\\n      if ($pillow_cursor === $n) {\\n        $direction = \"dec\";\\n      } elseif ($pillow_cursor === 1) {\\n        $direction = \"inc\";\\n      }\\n      $pillow_cursor += ($direction === \"inc\") ? 1 : -1;\\n    }\\n\\n    return $pillow_cursor;\\n  }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n  /**\\n   * @param Integer $n\\n   * @param Integer $time\\n   * @return Integer\\n   */\\n  function passThePillow($n, $time)\\n  {\\n\\n    $pillow_cursor = 1;\\n    $direction = \"inc\";\\n    for ($i = 1; $i <= $time; $i++) {\\n      if ($pillow_cursor === $n) {\\n        $direction = \"dec\";\\n      } elseif ($pillow_cursor === 1) {\\n        $direction = \"inc\";\\n      }\\n      $pillow_cursor += ($direction === \"inc\") ? 1 : -1;\\n    }\\n\\n    return $pillow_cursor;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096018,
                "title": "c-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthinking in math to get the optimal value \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int PassThePillow(int n, int time) {\\n        int i = 0; \\n        while(time >= 0) {\\n            i++;  \\n            if(i == n){ \\n                i = n * -1;\\n            }else if(i == -1){ \\n                i *= -1; \\n            }\\n            if(time == 0){ \\n                return Math.Abs(i); \\n            }\\n            time --; \\n\\n        }\\n        return 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PassThePillow(int n, int time) {\\n        int i = 0; \\n        while(time >= 0) {\\n            i++;  \\n            if(i == n){ \\n                i = n * -1;\\n            }else if(i == -1){ \\n                i *= -1; \\n            }\\n            if(time == 0){ \\n                return Math.Abs(i); \\n            }\\n            time --; \\n\\n        }\\n        return 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090868,
                "title": "write-and-simulate-thenget-the-math-calculate-method",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let circle = Math.floor(time / (n - 1));\\n    let currPos = time % (n - 1);\\n\\n    return circle % 2 == 0 ? currPos + 1: n - currPos;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let circle = Math.floor(time / (n - 1));\\n    let currPos = time % (n - 1);\\n\\n    return circle % 2 == 0 ? currPos + 1: n - currPos;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089707,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int c=1;int f=1;\\n        while(time>0)\\n        {\\n            if(f>0)\\n            {\\n                c++;\\n                time--;\\n            }\\n            else if(f<0)\\n            {\\n                c--;\\n                time--;\\n            }\\n            if(c==n)\\n            {\\n                f=f*-1;\\n            }\\n            if(c==1)\\n            {\\n                f=f*-1;\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int c=1;int f=1;\\n        while(time>0)\\n        {\\n            if(f>0)\\n            {\\n                c++;\\n                time--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4079649,
                "title": "python-fast-solution-o-1",
                "content": "# Intuition:\\nThe game can be visualized as kids sitting in a circle, and the direction of the \\npillow-passing alternates every n-1 passes. This means that for every n-1 time \\nunits, the direction changes. The challenge is determining the final position \\nof the pillow after the given \\'time\\', especially considering the alternating directions.\\n\\n# Approach:\\n1. Calculate the number of full cycles (i.e., n-1 time units) and the remaining time after those cycles.\\n2. If the number of full cycles is even, the direction of passing remains the same as the beginning. \\n    Thus, the pillow\\'s position will be `remaining_time + 1` (since it\\'s 1-indexed).\\n3. If the number of full cycles is odd, the direction of passing is the opposite. \\n  This means we\\'d calculate the position from the end, i.e., `n - remaining_time`.\\n\\n# Complexity:\\n - Time complexity: O(1) \\n#   The operations are constant-time arithmetic operations.\\n - Space complexity: O(1)\\n\\n# Code:\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        full_cycles, remaining_time = divmod(time, n - 1)\\n        return remaining_time + 1 if full_cycles % 2 == 0 else n - remaining_time\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        full_cycles, remaining_time = divmod(time, n - 1)\\n        return remaining_time + 1 if full_cycles % 2 == 0 else n - remaining_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070397,
                "title": "java-100-faster-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int ans = 1;\\n        while(time > 0){\\n            ans+=1;\\n            time-=1;\\n            if(ans==n){\\n                while(ans > 1 && time > 0){\\n                    ans-=1;\\n                    time-=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int ans = 1;\\n        while(time > 0){\\n            ans+=1;\\n            time-=1;\\n            if(ans==n){\\n                while(ans > 1 && time > 0){\\n                    ans-=1;\\n                    time-=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069679,
                "title": "easy-solution-beats-100-c",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n      time %= (n-1)*2;\\n      if (time < n)\\n        return 1+time;\\n      return n-(time-(n-1)); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n      time %= (n-1)*2;\\n      if (time < n)\\n        return 1+time;\\n      return n-(time-(n-1)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055888,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        time -= 1\\n        while True:\\n            for i in range(2, n+1):\\n                time -= 1\\n                print(time, i)\\n                if time < 0:\\n                    return i\\n        \\n            for j in range(n-1, 0, -1):\\n                time -= 1\\n                print(time, j)\\n                if time < 0:\\n                    return j\\n        \\n        return 1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        time -= 1\\n        while True:\\n            for i in range(2, n+1):\\n                time -= 1\\n                print(time, i)\\n                if time < 0:\\n                    return i\\n        \\n            for j in range(n-1, 0, -1):\\n                time -= 1\\n                print(time, j)\\n                if time < 0:\\n                    return j\\n        \\n        return 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042960,
                "title": "python-simple-solution-math-loop",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n  def passThePillow(self, n: int, time: int) -> int:\\n    index = 1\\n    right_turn = 0\\n    while time > 0:\\n      if right_turn == 0:\\n        index += 1\\n        if index == n:\\n          right_turn = -1\\n      elif right_turn == -1:\\n        index -= 1\\n        if index == 1:\\n          right_turn = 0\\n      time -= 1\\n    return index\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n  def passThePillow(self, n: int, time: int) -> int:\\n    index = 1\\n    right_turn = 0\\n    while time > 0:\\n      if right_turn == 0:\\n        index += 1\\n        if index == n:\\n          right_turn = -1\\n      elif right_turn == -1:\\n        index -= 1\\n        if index == 1:\\n          right_turn = 0\\n      time -= 1\\n    return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041356,
                "title": "simple-python-solution-math-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every loop (1->n), it takes n-1. If loop value is even, then the direction is from right to left and vice versa. The remaining is the number of steps we need to take from most left or most right person. We can use these to determine which direction (loop) and how many steps should be taken (remaining). \\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if time > n:\\n            loop = (time // (n-1)) + 1\\n            remaining = time % (n-1) \\n            if loop % 2 == 0:\\n                return n-remaining\\n            elif loop % 2 != 0:\\n                return 1+remaining\\n        elif time < n:\\n            return 1+time\\n        else:\\n            return time-1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if time > n:\\n            loop = (time // (n-1)) + 1\\n            remaining = time % (n-1) \\n            if loop % 2 == 0:\\n                return n-remaining\\n            elif loop % 2 != 0:\\n                return 1+remaining\\n        elif time < n:\\n            return 1+time\\n        else:\\n            return time-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040633,
                "title": "python-2-line-solution",
                "content": "# Intuition\\nThis problem is essentially a maths problem. By considering the floor division and remainder of time when divided by n-1, we can easily find the answer.\\n\\n# Approach\\nDrawing the numbers from 1 to n on a number line reveals that there are n - 1 steps to reach n from 1 and vice versa. (This is left as an exercise for the reader!) Therefore a half round trip (i.e. leaving at 1 and ending at n or vice versa) is n - 1 steps, and a full round trip (i.e. leaving 1 and returning to 1) is 2*(n - 1) steps. Because of the periodicity of the problem, this extends to odd and even multiples of n - 1 respectively. In general, for time = k*(n-1) + r, if k is odd, the pillow is going L -> R when the time is up, if k is even, the pillow is going R -> L when the time is up.\\n\\nThe current direction of travel affects how the ending position of the pillow can be calculated from the remainder.\\n\\nIf time is an even multiple, the final position is the remainder + 1 (the +1 factor is there becasue the positions are not zero-indexed). If it\\'s an odd multiple, the position is n - remainder. This is because remainder is how many we have moved from the end point (1 or n-1) in this given half of the round trip.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        loop, rem = divmod(time, n - 1)\\n        return rem + 1 if (loop % 2 == 0) else (n - rem)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        loop, rem = divmod(time, n - 1)\\n        return rem + 1 if (loop % 2 == 0) else (n - rem)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032598,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        if(time<n)\\n            return time+1;\\n        return (time/(n-1))%2==0?time%(n-1)+1:n-time%(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        if(time<n)\\n            return time+1;\\n        return (time/(n-1))%2==0?time%(n-1)+1:n-time%(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022372,
                "title": "simple-c-solution-easy-to-understand-basic-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int rounds = time/(n-1); //find no. of round means how many total completed rounds from left to right and right to left\\n        //time%(n-1) indicates the remaining hops\\n        int ans = 0;\\n        if(rounds%2 == 0) {\\n            ans = (1 + time%(n-1)); //if no. of round are even hopping start from left\\n        }\\n        else {\\n            ans = (n - time%(n-1)); //if no. of rounds are odd hopping starts from right\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![leetupvote.png](https://assets.leetcode.com/users/images/6bcdddf6-00ec-4ffd-bb53-413c813e8d9e_1695018353.158166.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int rounds = time/(n-1); //find no. of round means how many total completed rounds from left to right and right to left\\n        //time%(n-1) indicates the remaining hops\\n        int ans = 0;\\n        if(rounds%2 == 0) {\\n            ans = (1 + time%(n-1)); //if no. of round are even hopping start from left\\n        }\\n        else {\\n            ans = (n - time%(n-1)); //if no. of rounds are odd hopping starts from right\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019340,
                "title": "c-easy-code-beats-100-on-time",
                "content": "# Complexity\\n- Time complexity: O(time)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1, flag = 0;\\n        while(time--)\\n        {\\n            if(i == n || i == 1)\\n            {\\n                flag = !flag;\\n            }\\n            flag == 1 ? i++ : i--;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1, flag = 0;\\n        while(time--)\\n        {\\n            if(i == n || i == 1)\\n            {\\n                flag = !flag;\\n            }\\n            flag == 1 ? i++ : i--;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015952,
                "title": "easy-to-understand-100-java-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int cycles = time / (n - 1);\\n        time = time % (n-1); \\n        int position;// 0 based position\\n        if(cycles % 2 == 0) return time + 1;\\n        return n - time; // n - 1 - time + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int cycles = time / (n - 1);\\n        time = time % (n-1); \\n        int position;// 0 based position\\n        if(cycles % 2 == 0) return time + 1;\\n        return n - time; // n - 1 - time + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001003,
                "title": "java-best-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        time = time % (2 * n-2);\\n        return (time < n) ? time + 1 :  2 * n - time - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        time = time % (2 * n-2);\\n        return (time < n) ? time + 1 :  2 * n - time - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977115,
                "title": "java-beats-100-simple-o-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        if(n>time){\\n           return time+1;\\n        }\\n        int c=1;\\n        int f=0;\\n        for(int i=1;i<=time;i++){\\n            if(f==0){\\n                c++;\\n                if(c==n){\\n                    f=1;\\n                }\\n            }\\n            else{\\n                c--;\\n                if(c==1){\\n                    f=0;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        if(n>time){\\n           return time+1;\\n        }\\n        int c=1;\\n        int f=0;\\n        for(int i=1;i<=time;i++){\\n            if(f==0){\\n                c++;\\n                if(c==n){\\n                    f=1;\\n                }\\n            }\\n            else{\\n                c--;\\n                if(c==1){\\n                    f=0;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971515,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  public int passThePillow(int n, int time) {\\n    int arr[] = new int[n];\\n    for (int i = 1; i <= n; i++) {\\n      arr[i - 1] = i;\\n    }\\n\\n    if (time < n) {\\n      return arr[time];\\n    }\\n    var counter = 0;\\n    var value = -1;\\n    var flag = true;\\n    var timeCounter = 0;\\n    while (timeCounter <= time) {\\n      value = arr[counter];\\n      if (flag) {\\n        counter++;\\n      } else {\\n        counter--;\\n      }\\n      if (counter + 1 == arr.length) {\\n        flag = false;\\n      } else if (counter - 1 < 0) {\\n        flag = true;\\n      }\\n\\n      timeCounter++;\\n    }\\n    return value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int passThePillow(int n, int time) {\\n    int arr[] = new int[n];\\n    for (int i = 1; i <= n; i++) {\\n      arr[i - 1] = i;\\n    }\\n\\n    if (time < n) {\\n      return arr[time];\\n    }\\n    var counter = 0;\\n    var value = -1;\\n    var flag = true;\\n    var timeCounter = 0;\\n    while (timeCounter <= time) {\\n      value = arr[counter];\\n      if (flag) {\\n        counter++;\\n      } else {\\n        counter--;\\n      }\\n      if (counter + 1 == arr.length) {\\n        flag = false;\\n      } else if (counter - 1 < 0) {\\n        flag = true;\\n      }\\n\\n      timeCounter++;\\n    }\\n    return value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971443,
                "title": "easy-understanding-solution-using-java-beats-100",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int balance = time % (n - 1);\\n        int rds = (int) time / (n - 1);\\n        return rds % 2 == 0 ? 1 + balance : n - balance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int balance = time % (n - 1);\\n        int rds = (int) time / (n - 1);\\n        return rds % 2 == 0 ? 1 + balance : n - balance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939658,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int start=1;\\n        bool dir=1;\\n        while(time)\\n        {\\n            if(dir==1)\\n            start++;\\n            else\\n            start--;\\n            if(start==1 or start==n)\\n            {\\n                dir=!dir;\\n            }\\n            time--;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int start=1;\\n        bool dir=1;\\n        while(time)\\n        {\\n            if(dir==1)\\n            start++;\\n            else\\n            start--;\\n            if(start==1 or start==n)\\n            {\\n                dir=!dir;\\n            }\\n            time--;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925029,
                "title": "java-o-1-count-roundtrip-steps-first",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int roundtrip = (n - 1) * 2;\\n        time  = time % roundtrip;\\n        if(time < n) return time + 1;\\n        return n - (time - n + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int roundtrip = (n - 1) * 2;\\n        time  = time % roundtrip;\\n        if(time < n) return time + 1;\\n        return n - (time - n + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924552,
                "title": "simple-typescript-solution-100-speed-one-liner",
                "content": "![image.png](https://assets.leetcode.com/users/images/99e68cee-e32e-4d64-b211-30a706551e28_1692313164.9939556.png)\\n\\n# Code (100% Speed)\\n```ts\\nfunction passThePillow(n: number, time: number): number {\\n    const isEven = Math.floor(time / (n - 1)) % 2 === 0\\n    const remainder = time % (n - 1)\\n    return isEven ? 1 + remainder : n - remainder\\n};\\n```\\n\\n# Code (One Liner)\\n```ts\\nfunction passThePillow(n: number, time: number): number {\\n    return Math.floor(time / (n - 1)) % 2 === 0\\n        ? 1 + (time % (n - 1)\\n        : n - (time % (n - 1))\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction passThePillow(n: number, time: number): number {\\n    const isEven = Math.floor(time / (n - 1)) % 2 === 0\\n    const remainder = time % (n - 1)\\n    return isEven ? 1 + remainder : n - remainder\\n};\\n```\n```ts\\nfunction passThePillow(n: number, time: number): number {\\n    return Math.floor(time / (n - 1)) % 2 === 0\\n        ? 1 + (time % (n - 1)\\n        : n - (time % (n - 1))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921334,
                "title": "to-avoid-long-loops",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def passThePillow(self, n, time):\\n        queue=[]\\n        for i in range(0,n):\\n            queue.append(i+1)\\n        for i in range(1,n):\\n            queue.append(n-i)\\n        #the gift gose back to 1st place after 2n-2 steps\\n        return queue[time%(2*n-2)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def passThePillow(self, n, time):\\n        queue=[]\\n        for i in range(0,n):\\n            queue.append(i+1)\\n        for i in range(1,n):\\n            queue.append(n-i)\\n        #the gift gose back to 1st place after 2n-2 steps\\n        return queue[time%(2*n-2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917206,
                "title": "well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        //Time taken to reach the last person.\\n        //Total no. of rounds pillow can make\\n        //The remaining no. of pillow passes.\\n        //when the round will be even that means pillow has reached\\n        // the first person\\n        //When the round will be odd that means the pillow has reached\\n        // the last person.\\n           int timeTakenForOnePass=n-1;\\n        int totalPasses=time/timeTakenForOnePass;\\n        int rem=time%timeTakenForOnePass;\\n        return totalPasses%2==0?rem+1:n-rem;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        //Time taken to reach the last person.\\n        //Total no. of rounds pillow can make\\n        //The remaining no. of pillow passes.\\n        //when the round will be even that means pillow has reached\\n        // the first person\\n        //When the round will be odd that means the pillow has reached\\n        // the last person.\\n           int timeTakenForOnePass=n-1;\\n        int totalPasses=time/timeTakenForOnePass;\\n        int rem=time%timeTakenForOnePass;\\n        return totalPasses%2==0?rem+1:n-rem;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914284,
                "title": "go-golang-1ms-73-1-88mb-100-simple",
                "content": "\\n\\n# Approach\\nThe approach was to track our direction and who is holding the pillow. We did this using `position` (the pillow holder) and `direction` (forwards: `1`, backwards: `-1`).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc passThePillow(n int, time int) int {\\n    var (\\n        position = 1\\n        direction = 1\\n    )\\n\\n    for i := 0; i < time; i++ {\\n        switch direction {\\n            case 1:\\n                // we are going forwards\\n                if position >= n {\\n                    // we\\'ve reached the last person, turn around\\n                    position--\\n                    direction = -1\\n                    continue\\n                }\\n\\n                // move to the next person going forwards\\n                position++\\n            case -1:\\n                if position <= 1 {\\n                    // we\\'ve reached the first person, turn around\\n                    position++\\n                    direction = 1\\n                    continue\\n                }\\n\\n                // move back a person\\n                position--\\n        }\\n    }\\n\\n    return position\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc passThePillow(n int, time int) int {\\n    var (\\n        position = 1\\n        direction = 1\\n    )\\n\\n    for i := 0; i < time; i++ {\\n        switch direction {\\n            case 1:\\n                // we are going forwards\\n                if position >= n {\\n                    // we\\'ve reached the last person, turn around\\n                    position--\\n                    direction = -1\\n                    continue\\n                }\\n\\n                // move to the next person going forwards\\n                position++\\n            case -1:\\n                if position <= 1 {\\n                    // we\\'ve reached the first person, turn around\\n                    position++\\n                    direction = 1\\n                    continue\\n                }\\n\\n                // move back a person\\n                position--\\n        }\\n    }\\n\\n    return position\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912107,
                "title": "c-solution-0-ms-5-90-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int completedIterations = time / (n - 1);\\n        int currentPerson = time % (n - 1);\\n\\n        if (completedIterations % 2 != 0) {\\n            currentPerson = n - currentPerson;\\n        } else {\\n            currentPerson += 1;\\n        }\\n\\n        return currentPerson;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int completedIterations = time / (n - 1);\\n        int currentPerson = time % (n - 1);\\n\\n        if (completedIterations % 2 != 0) {\\n            currentPerson = n - currentPerson;\\n        } else {\\n            currentPerson += 1;\\n        }\\n\\n        return currentPerson;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902417,
                "title": "beat-100-runtime-0ms-shortest-easiest-simplest-most-cleanest-c-solution",
                "content": "# Intuition\\n![Screenshot (42).png](https://assets.leetcode.com/users/images/9a8d49a5-e957-4bfb-8683-80c900265ce2_1691906991.8353322.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int t) {\\n        vector<int>p;\\n        for(int i=1;i<=n;i++)p.push_back(i);\\n        for(int i=0;i<p.size();i++){\\n            if(i==p.size()-1&&t!=0){reverse(p.begin(),p.end());i=0;}\\n            if(t==0)return p[i];\\n            t--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int t) {\\n        vector<int>p;\\n        for(int i=1;i<=n;i++)p.push_back(i);\\n        for(int i=0;i<p.size();i++){\\n            if(i==p.size()-1&&t!=0){reverse(p.begin(),p.end());i=0;}\\n            if(t==0)return p[i];\\n            t--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899665,
                "title": "best-way-with-explaination-beats-70-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\'\\'\\'\\n        direction = 1 -> Forward\\n        direction = -1 -> Backward\\n        \\'\\'\\'\\n        i = 0\\n        person = 1\\n        direction = 1\\n        while i < time:\\n            if person < n and direction == 1:\\n                person += 1\\n            elif person == 2:\\n                person = 1\\n                direction = 1\\n            else:\\n                person -= 1\\n                direction = -1            \\n            i+=1\\n        return person\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\'\\'\\'\\n        direction = 1 -> Forward\\n        direction = -1 -> Backward\\n        \\'\\'\\'\\n        i = 0\\n        person = 1\\n        direction = 1\\n        while i < time:\\n            if person < n and direction == 1:\\n                person += 1\\n            elif person == 2:\\n                person = 1\\n                direction = 1\\n            else:\\n                person -= 1\\n                direction = -1            \\n            i+=1\\n        return person\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890148,
                "title": "yaytse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int direction = time / (n - 1);\\n        int remainder = time % (n-1);\\n\\n        if(direction % 2 == 0) {\\n            return 1 + remainder;\\n        }\\n        return n - remainder;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int direction = time / (n - 1);\\n        int remainder = time % (n-1);\\n\\n        if(direction % 2 == 0) {\\n            return 1 + remainder;\\n        }\\n        return n - remainder;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890026,
                "title": "pass-the-pillow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        num=0\\n        if time>=n-1:\\n            num=time//(n-1)\\n            if num%2==0:\\n                return 1+time%(n-1)\\n            else:\\n                return n-time%(n-1)\\n        else:\\n            return 1+time\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        num=0\\n        if time>=n-1:\\n            num=time//(n-1)\\n            if num%2==0:\\n                return 1+time%(n-1)\\n            else:\\n                return n-time%(n-1)\\n        else:\\n            return 1+time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883758,
                "title": "python-simple",
                "content": "each round from head to end takes n-1 seconds;\\nwe have only even round trips or odd rounds, with a remainder r position.\\nif it is in odd rounds, position is n-r;\\nit it is in even rounds, position is r+1.\\n\\n```\\ndef passThePillow(self, n: int, time: int) -> int:\\n        rds=time//(n-1)\\n        r=time%(n-1)\\n        \\n        if rds%2:\\n            return n-r\\n        return r+1",
                "solutionTags": [],
                "code": "each round from head to end takes n-1 seconds;\\nwe have only even round trips or odd rounds, with a remainder r position.\\nif it is in odd rounds, position is n-r;\\nit it is in even rounds, position is r+1.\\n\\n```\\ndef passThePillow(self, n: int, time: int) -> int:\\n        rds=time//(n-1)\\n        r=time%(n-1)\\n        \\n        if rds%2:\\n            return n-r\\n        return r+1",
                "codeTag": "Python3"
            },
            {
                "id": 3861662,
                "title": "iterative-vs-divmod-as-direction-and-reminder",
                "content": "## Iterative solution\\n![image.png](https://assets.leetcode.com/users/images/30c4490e-9e12-4bbd-b4bb-17e46ceb4739_1691133782.911609.png)\\n\\n\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        pillow = 1\\n        direction = 1\\n        for _ in range(time):\\n            if pillow == n:\\n                direction = -1\\n            elif pillow == 1:\\n                direction = 1\\n            pillow += 1 * direction\\n        return pillow\\n```\\n\\n\\n## divmod() as direction and reminder\\n![image.png](https://assets.leetcode.com/users/images/90880122-1ef7-4cec-bd2d-52ca104dfe82_1691133831.6318934.png)\\n\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        direction, reminder = divmod(time, n - 1)\\n        if direction % 2 == 1:\\n            return n - reminder\\n        return 1 + reminder\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        pillow = 1\\n        direction = 1\\n        for _ in range(time):\\n            if pillow == n:\\n                direction = -1\\n            elif pillow == 1:\\n                direction = 1\\n            pillow += 1 * direction\\n        return pillow\\n```\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        direction, reminder = divmod(time, n - 1)\\n        if direction % 2 == 1:\\n            return n - reminder\\n        return 1 + reminder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854253,
                "title": "c-highly-optimized-o-1-beginner-easy-solution",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n// FIND DIR IN WHICH WE MOVE ONLY TWO DIR POSSIBLE\\n// O---> MEANS RIGHT DIRECTION MOVEMENT \\n// 1--->MEANS LEFT DIRECTION MOVEMENT\\n        bool dir=0;\\n        int  round=time/(n-1);\\n        dir=(round)%2;\\n        int ind=time%(n-1);\\n        if(dir==1)\\n        return n-ind;\\n        else\\n        return ind+1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n// FIND DIR IN WHICH WE MOVE ONLY TWO DIR POSSIBLE\\n// O---> MEANS RIGHT DIRECTION MOVEMENT \\n// 1--->MEANS LEFT DIRECTION MOVEMENT\\n        bool dir=0;\\n        int  round=time/(n-1);\\n        dir=(round)%2;\\n        int ind=time%(n-1);\\n        if(dir==1)\\n        return n-ind;\\n        else\\n        return ind+1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842584,
                "title": "java-simple-solution-time-complexity-o-time-single-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int index=1;\\n        int deacreasingOrIncreasing=0;\\n        for(int i=1; i<=time; i++){\\n          if(index==1){\\n            deacreasingOrIncreasing=1;\\n          }\\n          if(index==n){\\n            deacreasingOrIncreasing=-1;\\n          }\\n          index=index+deacreasingOrIncreasing;\\n          System.out.println(index);\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int index=1;\\n        int deacreasingOrIncreasing=0;\\n        for(int i=1; i<=time; i++){\\n          if(index==1){\\n            deacreasingOrIncreasing=1;\\n          }\\n          if(index==n){\\n            deacreasingOrIncreasing=-1;\\n          }\\n          index=index+deacreasingOrIncreasing;\\n          System.out.println(index);\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833943,
                "title": "o-n-98-runtime-98-space-counting-backwards",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Easy to understand. We count our people until we reach N, after that with the help of a variable we keep counting backwards and forwards again, until we reach the number of given time/seconds.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let pillowFlow = 1;\\n    let seconds = 0;\\n    let startPillowFlowBackwards = false;\\n    while (seconds !== time) {\\n        if (startPillowFlowBackwards === true) {\\n            if (pillowFlow === 1) {\\n                startPillowFlowBackwards = false;\\n            }\\n            else {\\n                pillowFlow--;\\n                seconds++;\\n            }\\n        }\\n        else if (pillowFlow === n) {\\n            startPillowFlowBackwards = true;\\n        }\\n        else {\\n            pillowFlow++;\\n            seconds++;\\n        }\\n    }\\n    return pillowFlow;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let pillowFlow = 1;\\n    let seconds = 0;\\n    let startPillowFlowBackwards = false;\\n    while (seconds !== time) {\\n        if (startPillowFlowBackwards === true) {\\n            if (pillowFlow === 1) {\\n                startPillowFlowBackwards = false;\\n            }\\n            else {\\n                pillowFlow--;\\n                seconds++;\\n            }\\n        }\\n        else if (pillowFlow === n) {\\n            startPillowFlowBackwards = true;\\n        }\\n        else {\\n            pillowFlow++;\\n            seconds++;\\n        }\\n    }\\n    return pillowFlow;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825970,
                "title": "python-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep a direction flag, True if we going to the right False if we going to the left. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdjust the direction flag once we reach the end point. Every step we check if we\\'re going to the right direction or left direction. Adjust our start variable accordingly.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(time)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        start = 1\\n        direction = True\\n        while time > 0:\\n            if direction == True:\\n                start += 1\\n            else:\\n                start -= 1\\n            if start == n:\\n                direction = False\\n            if start == 1:\\n                direction = True\\n            time -= 1\\n        return start\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        start = 1\\n        direction = True\\n        while time > 0:\\n            if direction == True:\\n                start += 1\\n            else:\\n                start -= 1\\n            if start == n:\\n                direction = False\\n            if start == 1:\\n                direction = True\\n            time -= 1\\n        return start\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800621,
                "title": "shortest-code-to-think",
                "content": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n , int t){\\n        int y = (n-1)*2;\\n        t%=y;\\n        int c=0;\\n        for(int i=1; i<n; i++){\\n            if(c==t){\\n                return i;\\n            }\\n            c++;\\n        }\\n        for(int i=n; i>=1; i--){\\n            if(c==t){\\n                return i;\\n            }\\n            c++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n , int t){\\n        int y = (n-1)*2;\\n        t%=y;\\n        int c=0;\\n        for(int i=1; i<n; i++){\\n            if(c==t){\\n                return i;\\n            }\\n            c++;\\n        }\\n        for(int i=n; i>=1; i--){\\n            if(c==t){\\n                return i;\\n            }\\n            c++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799756,
                "title": "resolved-in-one-line-c-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        return time / (n - 1) % 2 == 0 ? time % (n - 1) + 1: n - time % (n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        return time / (n - 1) % 2 == 0 ? time % (n - 1) + 1: n - time % (n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796256,
                "title": "easy-method-beat-100-java-code-simple-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int p=1;\\n        boolean pos=true;\\nwhile(time>0)\\n{\\n    if(pos)\\n    {\\n        p++;\\n    }\\n    else{\\n        p--;\\n    }\\n\\n    if(p==n)\\n    {\\n        pos=false;\\n    }\\n    else if(p==1)\\n    {\\n        pos=true;\\n    }\\n    \\n    time--;\\n    \\n}\\n\\nreturn p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int p=1;\\n        boolean pos=true;\\nwhile(time>0)\\n{\\n    if(pos)\\n    {\\n        p++;\\n    }\\n    else{\\n        p--;\\n    }\\n\\n    if(p==n)\\n    {\\n        pos=false;\\n    }\\n    else if(p==1)\\n    {\\n        pos=true;\\n    }\\n    \\n    time--;\\n    \\n}\\n\\nreturn p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793580,
                "title": "pass-the-pillow-analyzing-the-linear-time-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to be a simulation of a game where a pillow is passed between participants in a circle. The passThePillow function takes two parameters: n, which represents the number of participants, and time, which indicates the number of times the pillow is passed around the circle. The function needs to determine who will be holding the pillow after time passes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given code is to simulate the passing of the pillow. The holder variable is initialized to 1, indicating that the first participant is holding the pillow. The forward boolean variable is used to determine the direction of the pillow\\'s movement. The pillow moves forward (incrementing holder) until it reaches the last participant (n), at which point it changes direction and moves backward (decrementing holder) until it reaches the first participant again.\\n\\nThe loop runs for time iterations, and each time the current position of the pillow (holder) is updated based on the current direction (forward).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(time), where time is the number of times the pillow is passed around the circle. In each iteration, the code performs constant-time operations (condition checks and updates) to determine the new holder position.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1), as it uses a constant amount of extra space regardless of the input size. It only uses a few integer variables to keep track of the current holder and the direction of movement.\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int holder = 1;\\n        boolean forward = true;\\n        for (int t = 0; t < time; t++) {\\n            if (holder == 1) {\\n                forward = true;\\n            } else if (holder == n) {\\n                forward = false;\\n            }\\n\\n            if (forward) {\\n                holder++;\\n            } else {\\n                holder--;\\n            }\\n        }\\n        return holder;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int holder = 1;\\n        boolean forward = true;\\n        for (int t = 0; t < time; t++) {\\n            if (holder == 1) {\\n                forward = true;\\n            } else if (holder == n) {\\n                forward = false;\\n            }\\n\\n            if (forward) {\\n                holder++;\\n            } else {\\n                holder--;\\n            }\\n        }\\n        return holder;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785308,
                "title": "crazy-o-1-solution-python-beats-101-best",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(1) time\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if (time//(n-1))%2==0:\\n            return ((time%(n-1))+1)\\n        else:\\n            return ((n-(time%(n-1))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if (time//(n-1))%2==0:\\n            return ((time%(n-1))+1)\\n        else:\\n            return ((n-(time%(n-1))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782976,
                "title": "easy-python-solution-using-basic-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        direction = time // (n-1)\\n        curr = time % (n-1)\\n   \\n        if direction % 2 == 0:\\n            return 1 + curr\\n        return  n - curr \\n            \\n\\n\\n       \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        direction = time // (n-1)\\n        curr = time % (n-1)\\n   \\n        if direction % 2 == 0:\\n            return 1 + curr\\n        return  n - curr \\n            \\n\\n\\n       \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782975,
                "title": "easy-python-solution-using-basic-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        direction = time // (n-1)\\n        curr = time % (n-1)\\n   \\n        if direction % 2 == 0:\\n            return 1 + curr\\n        return  n - curr \\n            \\n\\n\\n       \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        \\n        direction = time // (n-1)\\n        curr = time % (n-1)\\n   \\n        if direction % 2 == 0:\\n            return 1 + curr\\n        return  n - curr \\n            \\n\\n\\n       \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781214,
                "title": "easy-to-understand-c-o-1-space-and-time",
                "content": "# Intuition\\nThe cycle repeats after 2n-2. \\nThus, we just need to take care of the cases when time< n-1 and time> n-1 and time = n-1\\n\\n# Approach\\n1. First get the time between 0 and 2n-2 using mod.\\n2. When time< n-1, return 1+time *COZ* time has not crossed the middle of the cycle.\\n3. When time> n-1, return the distance between 2n-1 and time *COZ* now the cycle reverses, ie it\\'s going down from n to 1 \\n4. When time== n-1, just return n *COZ* n-1 is the pivot/ center of the cycle\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) \\n    {\\n        if(time==1) return 2;\\n\\n        time= time%(2*n-2);\\n\\n        if(time<n-1) return 1+time;\\n\\n        if(time>n-1) return 2*n-1-time;\\n        else return n;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) \\n    {\\n        if(time==1) return 2;\\n\\n        time= time%(2*n-2);\\n\\n        if(time<n-1) return 1+time;\\n\\n        if(time>n-1) return 2*n-1-time;\\n        else return n;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761152,
                "title": "java",
                "content": "I tired to keep simple\\n\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n       \\n      int[] peopleInLine = new int[n];\\n       for(int i = 0; i<n;i++){\\n           peopleInLine[i]= i+1;\\n       }\\n       int passes= time / (n-1);    \\n       int counter = time % (n-1);\\n       int index=0; \\n        if(passes%2==0){\\n          index= counter ;\\n        }else{\\n                   \\n        index = (n -counter-1); \\n        }\\n       return peopleInLine[index];\\n      \\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n       \\n      int[] peopleInLine = new int[n];\\n       for(int i = 0; i<n;i++){\\n           peopleInLine[i]= i+1;\\n       }\\n       int passes= time / (n-1);    \\n       int counter = time % (n-1);\\n       int index=0; \\n        if(passes%2==0){\\n          index= counter ;\\n        }else{\\n                   \\n        index = (n -counter-1); \\n        }\\n       return peopleInLine[index];\\n      \\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758682,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int a=1,f=0;\\n        while(time--!=0){\\n            if(a==n){\\n                f=1;\\n            }\\n            else if(f==1 && a==1){\\n                f=0;\\n            }\\n            a=f==1?a-1:a+1;\\n        }\\n        return a;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/6c4177ae-c4df-458e-bf92-9de9c811f253_1689240835.1276777.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int a=1,f=0;\\n        while(time--!=0){\\n            if(a==n){\\n                f=1;\\n            }\\n            else if(f==1 && a==1){\\n                f=0;\\n            }\\n            a=f==1?a-1:a+1;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754449,
                "title": "a-simple-solution",
                "content": "# Complexity\\n$$O(time)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func passThePillow(_ n: Int, _ time: Int) -> Int {\\n        var personIndex = 0, direction = true\\n        for sec in 0...time {\\n            if personIndex == n && direction {\\n                direction = false\\n            } else if personIndex == 1 && !direction {\\n                direction = true\\n            }\\n            if direction {\\n                personIndex += 1\\n            } else {\\n                personIndex -= 1\\n            }\\n        }\\n        return personIndex\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func passThePillow(_ n: Int, _ time: Int) -> Int {\\n        var personIndex = 0, direction = true\\n        for sec in 0...time {\\n            if personIndex == n && direction {\\n                direction = false\\n            } else if personIndex == 1 && !direction {\\n                direction = true\\n            }\\n            if direction {\\n                personIndex += 1\\n            } else {\\n                personIndex -= 1\\n            }\\n        }\\n        return personIndex\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747704,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let count = Math.floor(time / (n-1));\\n    let mod = time % (n-1);\\n    if(count % 2 == 0) {\\n        return 1 + mod\\n    }\\n    return n - mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function(n, time) {\\n    let count = Math.floor(time / (n-1));\\n    let mod = time % (n-1);\\n    if(count % 2 == 0) {\\n        return 1 + mod\\n    }\\n    return n - mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742100,
                "title": "c-simple-and-easy-approach",
                "content": "# Intuition\\nWe have to find pillow lasts with which person when we play pass the pillow game with n persons for given time\\n\\n# Approach\\nFirst the pillow rests with person 1, and the sequence we follow is that we pass the pillow to next person, so its an incremental sequence, then we begin our for loop which we run till our time, in this loop we increment value of person if it is in sequence 1, when we reach person n then we have to decrement, becuase then we pass to n-1 person, so we decrement and set sequence to -1 till the pillow reaches to person 1 where we will again reverse the sequence, we do this in our for loop and finally we return the person who has the pillow.\\n\\n# Complexity\\n- Time complexity:\\nO(t) {where t = time}\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int person = 1;\\n        int sequence = 1;\\n        for(int i = 1; i <= time; i++)\\n        {\\n            if(sequence==1)\\n            {\\n                if(person<n)\\n                {\\n                    person++;\\n                }\\n                else\\n                {\\n                    person--;\\n                    sequence = -1;\\n                }\\n            }\\n            else\\n            {\\n                if(person>1)\\n                {\\n                    person--;\\n                }\\n                else\\n                {\\n                    person++;\\n                    sequence = 1;\\n                }\\n            }\\n        }\\n        return person;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int person = 1;\\n        int sequence = 1;\\n        for(int i = 1; i <= time; i++)\\n        {\\n            if(sequence==1)\\n            {\\n                if(person<n)\\n                {\\n                    person++;\\n                }\\n                else\\n                {\\n                    person--;\\n                    sequence = -1;\\n                }\\n            }\\n            else\\n            {\\n                if(person>1)\\n                {\\n                    person--;\\n                }\\n                else\\n                {\\n                    person++;\\n                    sequence = 1;\\n                }\\n            }\\n        }\\n        return person;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732967,
                "title": "solution-without-overcomplicated-loop-just-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n       int count=0;\\n        if(n>time){\\n            return time+1;\\n        }\\n        else if(n<time){\\n            while(n<=time){\\n                time-=n-1;\\n                count++;\\n            }\\n            return count%2==0?time+1:n-time;\\n        }\\n        else return n-1;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n       int count=0;\\n        if(n>time){\\n            return time+1;\\n        }\\n        else if(n<time){\\n            while(n<=time){\\n                time-=n-1;\\n                count++;\\n            }\\n            return count%2==0?time+1:n-time;\\n        }\\n        else return n-1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728681,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Understanding the direction \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(time)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        int c=1;//positive cycle\\n        while(time>0){\\n            if(c==1){\\n                i++;\\n                time--;\\n                if(i==n){\\n                    c=0;\\n                }\\n            }\\n            else if(c==0){\\n                i--;\\n                time--;\\n                if(i==1){\\n                    c=1;\\n                }\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        int c=1;//positive cycle\\n        while(time>0){\\n            if(c==1){\\n                i++;\\n                time--;\\n                if(i==n){\\n                    c=0;\\n                }\\n            }\\n            else if(c==0){\\n                i--;\\n                time--;\\n                if(i==1){\\n                    c=1;\\n                }\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714799,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* Do end to end traversals (T) = time / (n - 1)\\n* Remaining time will be R = time % (n - 1)\\n* If T is even, then direction is forward else backward\\n* Index of the person will pillow will be R + 1 if T is even else T - R + 1 (going backwards)\\n* 1 is added for 1 based indexing of people\\n>**T/S:** O(1)/O(1)\\n```\\npublic int passThePillow(int n, int time) {\\n\\tvar timeForFullTraversal = n - 1;\\n\\tvar traversalCount = time / timeForFullTraversal;\\n\\tvar remainingTime = time % timeForFullTraversal;\\n\\tvar isDirectionForward = (traversalCount & 1) == 0;\\n\\treturn isDirectionForward\\n\\t\\t ? 1 + remainingTime;\\n\\t\\t : 1 + timeForFullTraversal - remainingTime;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int passThePillow(int n, int time) {\\n\\tvar timeForFullTraversal = n - 1;\\n\\tvar traversalCount = time / timeForFullTraversal;\\n\\tvar remainingTime = time % timeForFullTraversal;\\n\\tvar isDirectionForward = (traversalCount & 1) == 0;\\n\\treturn isDirectionForward\\n\\t\\t ? 1 + remainingTime;\\n\\t\\t : 1 + timeForFullTraversal - remainingTime;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3697225,
                "title": "qtsol-solution-easy-with-beat-100-and-memory-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int d = 1;\\n        int t = time;\\n        int direc = 1;\\n        while(time > 0){\\n            d += direc;\\n            time--;\\n            if(d == n || d == 1) direc = direc *(-1);\\n        }\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int d = 1;\\n        int t = time;\\n        int direc = 1;\\n        while(time > 0){\\n            d += direc;\\n            time--;\\n            if(d == n || d == 1) direc = direc *(-1);\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691925,
                "title": "one-liner",
                "content": "\\n```\\nfunc passThePillow(_ n: Int, _ time: Int) -> Int {\\n    n - time%(n-1) - (1 + time/(n-1))%2 * (n-1-2*(time%(n-1)))\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nfunc passThePillow(_ n: Int, _ time: Int) -> Int {\\n    n - time%(n-1) - (1 + time/(n-1))%2 * (n-1-2*(time%(n-1)))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691719,
                "title": "easy-solution-dart",
                "content": "# Code\\n```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n      bool direction = false;\\n      int i = 1;\\n\\n      while(time > 0){\\n          if(i == 1 || i == n) direction = !direction;\\n          direction ? i++ : i--;\\n          time--;\\n      }\\n\\n      return i;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n      bool direction = false;\\n      int i = 1;\\n\\n      while(time > 0){\\n          if(i == 1 || i == n) direction = !direction;\\n          direction ? i++ : i--;\\n          time--;\\n      }\\n\\n      return i;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687434,
                "title": "0-ms-mermory-99-4-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int pil = 1;\\n        while(time>0){\\n            while(time>0 && pil<n){\\n                pil++;\\n                time--;\\n            }\\n            while(time>0 && pil>1){\\n                pil--;\\n                time--;\\n            }\\n        }\\n        return pil;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int pil = 1;\\n        while(time>0){\\n            while(time>0 && pil<n){\\n                pil++;\\n                time--;\\n            }\\n            while(time>0 && pil>1){\\n                pil--;\\n                time--;\\n            }\\n        }\\n        return pil;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687121,
                "title": "c-math-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int t) {\\n        --n;\\n        return((t/n)%2)? n-(t%n)+1:(t%n)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int t) {\\n        --n;\\n        return((t/n)%2)? n-(t%n)+1:(t%n)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678982,
                "title": "0ms-100-easy-understandable-solution-in-1-loop",
                "content": "# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n     int person =1;\\n     boolean dir=true;//true means going forward and false the opposite\\n     while(time>0){\\n       if(dir && person == n) {\\n             dir = false;person--;\\n         }\\n         else if(!dir && person ==1 ){\\n             dir = true;person++;\\n         }\\n         else if(dir){\\n             person++;\\n         }\\n         else if(!dir){\\n             person--;\\n         }\\n\\n         time--;\\n     }\\n     return person;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n     int person =1;\\n     boolean dir=true;//true means going forward and false the opposite\\n     while(time>0){\\n       if(dir && person == n) {\\n             dir = false;person--;\\n         }\\n         else if(!dir && person ==1 ){\\n             dir = true;person++;\\n         }\\n         else if(dir){\\n             person++;\\n         }\\n         else if(!dir){\\n             person--;\\n         }\\n\\n         time--;\\n     }\\n     return person;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674846,
                "title": "python-beats-93-12-easy-solution-4-lines",
                "content": "![Screenshot 2023-06-24 at 01.07.36.png](https://assets.leetcode.com/users/images/7adcecbf-3e2a-4151-a506-8c341a10f1a4_1687547315.204457.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if (time // (n - 1)) % 2 == 0:\\n            return 1 + (time % (n - 1))\\n        else:\\n            return n - (time % (n - 1))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        if (time // (n - 1)) % 2 == 0:\\n            return 1 + (time % (n - 1))\\n        else:\\n            return n - (time % (n - 1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674472,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere `n = time`\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function (n, time) {\\n    let t = time;\\n    let i = 1;\\n    let dir = 1 // left to right;\\n    while (t > 0) {\\n        if (dir == 1) {\\n            i++;\\n        } else {\\n            i--;\\n        }\\n        if (i == 1) {\\n            dir = 1;\\n        } else if (i == n) {\\n            dir = -1\\n        }\\n        t--;\\n    }\\n\\n    return i;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} time\\n * @return {number}\\n */\\nvar passThePillow = function (n, time) {\\n    let t = time;\\n    let i = 1;\\n    let dir = 1 // left to right;\\n    while (t > 0) {\\n        if (dir == 1) {\\n            i++;\\n        } else {\\n            i--;\\n        }\\n        if (i == 1) {\\n            dir = 1;\\n        } else if (i == n) {\\n            dir = -1\\n        }\\n        t--;\\n    }\\n\\n    return i;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653633,
                "title": "easy-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPLEASE UPVOTE!!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1,k=0;\\n        while(time)\\n        {\\n            if(i==n)\\n            {\\n                k++;\\n                i=1;\\n            }\\n            i++;\\n            time--;\\n        }\\n        if(k%2!=0)\\n        {\\n           return n-i+1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1,k=0;\\n        while(time)\\n        {\\n            if(i==n)\\n            {\\n                k++;\\n                i=1;\\n            }\\n            i++;\\n            time--;\\n        }\\n        if(k%2!=0)\\n        {\\n           return n-i+1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630815,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        const auto index = time % (2 * (n - 1));\\n        return (index / (n - 1) > 0 ? n - 1 - index % (n - 1) : index % (n - 1)) + 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        const auto index = time % (2 * (n - 1));\\n        return (index / (n - 1) > 0 ? n - 1 - index % (n - 1) : index % (n - 1)) + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620506,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(time < n){\\n            return time+1;\\n        }\\n        int count = 1;\\n        bool reverse = false;\\n\\n        for(int i=1; i<=time; i++){\\n            if(!reverse){\\n                count++;\\n            }else{\\n                count--;\\n            }\\n            \\n            if(count == n){\\n                reverse = true;\\n            }\\n            if(count == 1){\\n                reverse = false;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        if(time < n){\\n            return time+1;\\n        }\\n        int count = 1;\\n        bool reverse = false;\\n\\n        for(int i=1; i<=time; i++){\\n            if(!reverse){\\n                count++;\\n            }else{\\n                count--;\\n            }\\n            \\n            if(count == n){\\n                reverse = true;\\n            }\\n            if(count == 1){\\n                reverse = false;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618481,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        while(time)\\n        {\\n            while(i<n)\\n            {\\n                i++;\\n                time--;\\n                if(time==0)\\n                {\\n                    return i;\\n                }\\n            }\\n            while(i>1)\\n            {\\n                i--;\\n                time--;\\n                if(time==0)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n        int i=1;\\n        while(time)\\n        {\\n            while(i<n)\\n            {\\n                i++;\\n                time--;\\n                if(time==0)\\n                {\\n                    return i;\\n                }\\n            }\\n            while(i>1)\\n            {\\n                i--;\\n                time--;\\n                if(time==0)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608206,
                "title": "java-no-loops-simple-and-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        time = time % ((n-1)*2); // Cuts unnecessary repetitive loops.\\n        return n - Math.abs(n-1-time);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        time = time % ((n-1)*2); // Cuts unnecessary repetitive loops.\\n        return n - Math.abs(n-1-time);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604828,
                "title": "easy-and-simple-c-program-with-tc-of-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Too easy    \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> I did this using my own approach which you can see below\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n\\n        if(time == 0)   return 1;\\n        \\n        int person = 1;\\n\\n        wapas:\\n\\n        for(int i = 1; i < n; i++){\\n            person++; time--;\\n            if(time == 0)   return person;\\n        }\\n\\n        for(int i = n - 1; i > 0; i--){\\n            person--; time--;\\n            if(time == 0)   return person;\\n        }\\n\\n        if(time == 0)   return person;\\n        else    goto wapas;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int passThePillow(int n, int time) {\\n\\n        if(time == 0)   return 1;\\n        \\n        int person = 1;\\n\\n        wapas:\\n\\n        for(int i = 1; i < n; i++){\\n            person++; time--;\\n            if(time == 0)   return person;\\n        }\\n\\n        for(int i = n - 1; i > 0; i--){\\n            person--; time--;\\n            if(time == 0)   return person;\\n        }\\n\\n        if(time == 0)   return person;\\n        else    goto wapas;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588431,
                "title": "easy-peeesy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def passThePillow(self, n, time):\\n        x=time//(n-1)\\n        y=time%(n-1)\\n        if x%2==0:\\n            return y+1\\n        else:\\n            return n-y\\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def passThePillow(self, n, time):\\n        x=time//(n-1)\\n        y=time%(n-1)\\n        if x%2==0:\\n            return y+1\\n        else:\\n            return n-y\\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588025,
                "title": "go-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc passThePillow(n int, time int) int {\\n    count :=1\\n    j:=1\\n    again:\\n   \\n    for ;j<=time;j++{\\n        if count<n{\\n            count++          \\n             \\n        } else {\\n            goto reverse\\n        }\\n    }\\n    reverse:\\n    for ;j<=time;j++{\\n        if count>1{\\n            count--            \\n             \\n        } else {\\n            goto again\\n        }\\n    }\\n    return count   \\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc passThePillow(n int, time int) int {\\n    count :=1\\n    j:=1\\n    again:\\n   \\n    for ;j<=time;j++{\\n        if count<n{\\n            count++          \\n             \\n        } else {\\n            goto reverse\\n        }\\n    }\\n    reverse:\\n    for ;j<=time;j++{\\n        if count>1{\\n            count--            \\n             \\n        } else {\\n            goto again\\n        }\\n    }\\n    return count   \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588016,
                "title": "brute-force-solution-using-one-loop",
                "content": "# Intuition\\nThe problem can be solved by simulating the passing of the pillow among the people in the line. We need to keep track of the current position and the direction of the pillow. By iterating through the time and updating the position and direction accordingly, we can determine the index of the person holding the pillow after the given time.\\n\\n# Approach\\n1. Initialize the time taken to 1, the position to 2 (as the pillow starts with the first person), and the mode (direction) to \"forward\".\\n2. Use a while loop to iterate while the time taken is less than or equal to the given time.\\n3. Inside the loop, check the current mode:\\n   - If the mode is \"forward\", increment the position by 1.\\n   - If the mode is \"reverse\", decrement the position by 1.\\n4. Increment the time taken by 1 at the end of each iteration.\\n5. Check if the position reaches the last person (n). If so, change the mode to \"reverse\".\\n6. Check if the position reaches the first person (1). If so, change the mode to \"forward\".\\n7. After the loop finishes, return the final position as the index of the person holding the pillow after the given time.\\n\\n# Complexity\\n- Time complexity: O(time)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int timeTaken = 1, pos = 1;\\n        String mode = \"forward\";\\n\\n        while(timeTaken <= time){\\n            if(mode == \"forward\"){\\n                pos++;\\n            }else{\\n                pos--;\\n            }\\n            timeTaken++;\\n            if(pos == n){\\n                mode = \"reverse\";\\n            }\\n            if(pos == 1){\\n                mode = \"forward\";\\n            }\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int timeTaken = 1, pos = 1;\\n        String mode = \"forward\";\\n\\n        while(timeTaken <= time){\\n            if(mode == \"forward\"){\\n                pos++;\\n            }else{\\n                pos--;\\n            }\\n            timeTaken++;\\n            if(pos == n){\\n                mode = \"reverse\";\\n            }\\n            if(pos == 1){\\n                mode = \"forward\";\\n            }\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588006,
                "title": "easy-solution-with-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n    bool dir=false;\\n    int pillo=1;\\n    for(int i=1;i<=time;i++){\\n      if(pillo==n || pillo==1){\\n        dir=dir?false:true;\\n      } \\n      if(dir){\\n        pillo++;\\n      }else{\\n        pillo--;\\n      }\\n    }\\n    return pillo;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n    bool dir=false;\\n    int pillo=1;\\n    for(int i=1;i<=time;i++){\\n      if(pillo==n || pillo==1){\\n        dir=dir?false:true;\\n      } \\n      if(dir){\\n        pillo++;\\n      }else{\\n        pillo--;\\n      }\\n    }\\n    return pillo;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588000,
                "title": "simple-and-less-code-easy-to-understand",
                "content": "# Intuition\\nSimple and less code\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n  \\nint current=1;\\nint moment =1;\\nint pre = 0;\\n\\nwhile(pre<time){\\n    current+=moment;\\n    if(current == n || current ==1){\\n        moment=-moment;\\n    }\\n    pre++;\\n}\\n      return current;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n  \\nint current=1;\\nint moment =1;\\nint pre = 0;\\n\\nwhile(pre<time){\\n    current+=moment;\\n    if(current == n || current ==1){\\n        moment=-moment;\\n    }\\n    pre++;\\n}\\n      return current;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587980,
                "title": "dart-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n\\nint count =(time/(n-1)).floor();\\nint mod = time%(n-1);\\nif(count%2==0){\\n    return 1+ mod;\\n}\\nreturn n-mod;\\n}\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n\\nint count =(time/(n-1)).floor();\\nint mod = time%(n-1);\\nif(count%2==0){\\n    return 1+ mod;\\n}\\nreturn n-mod;\\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587973,
                "title": "easy-solution-for-python-using-if-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        time = time%(2*n-2)\\n        if time < n-1:\\n            result = time+1\\n        elif time == n:\\n            result = n-1\\n        else:\\n            result = n-(time-(n-1))\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def passThePillow(self, n: int, time: int) -> int:\\n        time = time%(2*n-2)\\n        if time < n-1:\\n            result = time+1\\n        elif time == n:\\n            result = n-1\\n        else:\\n            result = n-(time-(n-1))\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587776,
                "title": "dart-solution-with-logic-only",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n\\n     bool forward=true;\\n        time=time+1;\\n        int hold=0;\\n        while(time>0){\\n            if(forward==true){\\n                if(hold==n)\\n                {\\n                    hold--;\\n\\n                    forward=false;\\n\\n                }\\n                else{\\n                    hold++;\\n                }\\n            }\\n\\n            else{\\n                if(hold==1){\\n                    hold++;\\n                    forward=true;\\n                }\\n                else{\\n                    hold--;\\n                }\\n            }\\n            time--;\\n        }\\n        return hold;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int passThePillow(int n, int time) {\\n\\n     bool forward=true;\\n        time=time+1;\\n        int hold=0;\\n        while(time>0){\\n            if(forward==true){\\n                if(hold==n)\\n                {\\n                    hold--;\\n\\n                    forward=false;\\n\\n                }\\n                else{\\n                    hold++;\\n                }\\n            }\\n\\n            else{\\n                if(hold==1){\\n                    hold++;\\n                    forward=true;\\n                }\\n                else{\\n                    hold--;\\n                }\\n            }\\n            time--;\\n        }\\n        return hold;\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1823893,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "Tip: Think of a better approach without the use of any loops. Spot the pattern that after how many passes, the pillow returns to initial state. And what condition you need to check with respect to the direction to calculate the pillow landing place."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Pillow fight > Passing the pillow"
                    },
                    {
                        "username": "kd_5304",
                        "content": "I have to admit, this easy question was medium for me."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Oh, come on, people, you're not really going to simulate the process one by one in a loop, are you? And if the `time` constraint was $10^9$, would you run a billion iterations? I mean, think, it's a math riddle that's solved in $O(1)$."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\nWe start with direction 1 (forward) and i = 1 (person 1 holding the pillow). We then loop over each second up to the given time, updating the direction and i variables as necessary. When we reach the end of the line (i = n), we change the direction to -1 (backward), and when we reach the beginning of the line (i = 1), we change the direction to 1 (forward). Finally, we return the value of i after the loop, which gives us the index of the person holding the pillow at the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code link For Reference:-\\nhttps://leetcode.com/problems/pass-the-pillow/solutions/3258466/best-solution-very-easy-to-understand/"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "It is interesting question to passing the one pillow to standing the row>>"
                    }
                ]
            },
            {
                "id": 1822260,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "Tip: Think of a better approach without the use of any loops. Spot the pattern that after how many passes, the pillow returns to initial state. And what condition you need to check with respect to the direction to calculate the pillow landing place."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Pillow fight > Passing the pillow"
                    },
                    {
                        "username": "kd_5304",
                        "content": "I have to admit, this easy question was medium for me."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Oh, come on, people, you're not really going to simulate the process one by one in a loop, are you? And if the `time` constraint was $10^9$, would you run a billion iterations? I mean, think, it's a math riddle that's solved in $O(1)$."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\nWe start with direction 1 (forward) and i = 1 (person 1 holding the pillow). We then loop over each second up to the given time, updating the direction and i variables as necessary. When we reach the end of the line (i = n), we change the direction to -1 (backward), and when we reach the beginning of the line (i = 1), we change the direction to 1 (forward). Finally, we return the value of i after the loop, which gives us the index of the person holding the pillow at the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code link For Reference:-\\nhttps://leetcode.com/problems/pass-the-pillow/solutions/3258466/best-solution-very-easy-to-understand/"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "It is interesting question to passing the one pillow to standing the row>>"
                    }
                ]
            },
            {
                "id": 1830074,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "Tip: Think of a better approach without the use of any loops. Spot the pattern that after how many passes, the pillow returns to initial state. And what condition you need to check with respect to the direction to calculate the pillow landing place."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Pillow fight > Passing the pillow"
                    },
                    {
                        "username": "kd_5304",
                        "content": "I have to admit, this easy question was medium for me."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Oh, come on, people, you're not really going to simulate the process one by one in a loop, are you? And if the `time` constraint was $10^9$, would you run a billion iterations? I mean, think, it's a math riddle that's solved in $O(1)$."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\nWe start with direction 1 (forward) and i = 1 (person 1 holding the pillow). We then loop over each second up to the given time, updating the direction and i variables as necessary. When we reach the end of the line (i = n), we change the direction to -1 (backward), and when we reach the beginning of the line (i = 1), we change the direction to 1 (forward). Finally, we return the value of i after the loop, which gives us the index of the person holding the pillow at the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code link For Reference:-\\nhttps://leetcode.com/problems/pass-the-pillow/solutions/3258466/best-solution-very-easy-to-understand/"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "It is interesting question to passing the one pillow to standing the row>>"
                    }
                ]
            },
            {
                "id": 1947227,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "Tip: Think of a better approach without the use of any loops. Spot the pattern that after how many passes, the pillow returns to initial state. And what condition you need to check with respect to the direction to calculate the pillow landing place."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Pillow fight > Passing the pillow"
                    },
                    {
                        "username": "kd_5304",
                        "content": "I have to admit, this easy question was medium for me."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Oh, come on, people, you're not really going to simulate the process one by one in a loop, are you? And if the `time` constraint was $10^9$, would you run a billion iterations? I mean, think, it's a math riddle that's solved in $O(1)$."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\nWe start with direction 1 (forward) and i = 1 (person 1 holding the pillow). We then loop over each second up to the given time, updating the direction and i variables as necessary. When we reach the end of the line (i = n), we change the direction to -1 (backward), and when we reach the beginning of the line (i = 1), we change the direction to 1 (forward). Finally, we return the value of i after the loop, which gives us the index of the person holding the pillow at the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code link For Reference:-\\nhttps://leetcode.com/problems/pass-the-pillow/solutions/3258466/best-solution-very-easy-to-understand/"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "It is interesting question to passing the one pillow to standing the row>>"
                    }
                ]
            },
            {
                "id": 1822448,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "Tip: Think of a better approach without the use of any loops. Spot the pattern that after how many passes, the pillow returns to initial state. And what condition you need to check with respect to the direction to calculate the pillow landing place."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Pillow fight > Passing the pillow"
                    },
                    {
                        "username": "kd_5304",
                        "content": "I have to admit, this easy question was medium for me."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Oh, come on, people, you're not really going to simulate the process one by one in a loop, are you? And if the `time` constraint was $10^9$, would you run a billion iterations? I mean, think, it's a math riddle that's solved in $O(1)$."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\nWe start with direction 1 (forward) and i = 1 (person 1 holding the pillow). We then loop over each second up to the given time, updating the direction and i variables as necessary. When we reach the end of the line (i = n), we change the direction to -1 (backward), and when we reach the beginning of the line (i = 1), we change the direction to 1 (forward). Finally, we return the value of i after the loop, which gives us the index of the person holding the pillow at the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code link For Reference:-\\nhttps://leetcode.com/problems/pass-the-pillow/solutions/3258466/best-solution-very-easy-to-understand/"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "It is interesting question to passing the one pillow to standing the row>>"
                    }
                ]
            },
            {
                "id": 1822281,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "Tip: Think of a better approach without the use of any loops. Spot the pattern that after how many passes, the pillow returns to initial state. And what condition you need to check with respect to the direction to calculate the pillow landing place."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Pillow fight > Passing the pillow"
                    },
                    {
                        "username": "kd_5304",
                        "content": "I have to admit, this easy question was medium for me."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Oh, come on, people, you're not really going to simulate the process one by one in a loop, are you? And if the `time` constraint was $10^9$, would you run a billion iterations? I mean, think, it's a math riddle that's solved in $O(1)$."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\nWe start with direction 1 (forward) and i = 1 (person 1 holding the pillow). We then loop over each second up to the given time, updating the direction and i variables as necessary. When we reach the end of the line (i = n), we change the direction to -1 (backward), and when we reach the beginning of the line (i = 1), we change the direction to 1 (forward). Finally, we return the value of i after the loop, which gives us the index of the person holding the pillow at the given time."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code link For Reference:-\\nhttps://leetcode.com/problems/pass-the-pillow/solutions/3258466/best-solution-very-easy-to-understand/"
                    },
                    {
                        "username": "kumarnitesh88441",
                        "content": "It is interesting question to passing the one pillow to standing the row>>"
                    }
                ]
            }
        ]
    }
]