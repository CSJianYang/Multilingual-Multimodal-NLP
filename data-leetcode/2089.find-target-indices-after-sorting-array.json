[
    {
        "title": "Find Target Indices After Sorting Array",
        "question_content": "You are given a 0-indexed integer array nums and a target element target.\nA target index is an index i such that nums[i] == target.\nReturn a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,5,2,3], target = 2\nOutput: [1,2]\nExplanation: After sorting, nums is [1,2,2,3,5].\nThe indices where nums[i] == 2 are 1 and 2.\n\nExample 2:\n\nInput: nums = [1,2,5,2,3], target = 3\nOutput: [3]\nExplanation: After sorting, nums is [1,2,2,3,5].\nThe index where nums[i] == 3 is 3.\n\nExample 3:\n\nInput: nums = [1,2,5,2,3], target = 5\nOutput: [4]\nExplanation: After sorting, nums is [1,2,2,3,5].\nThe index where nums[i] == 5 is 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i], target <= 100",
        "solutions": [
            {
                "id": 1599963,
                "title": "java-o-n-single-loop-count",
                "content": "One iteration to count less than `target`, and equal `target`. Build output based on the first index at `lessthan`.\\n\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int count = 0, lessthan = 0;\\n        for (int n : nums) {\\n            if (n == target) count++;\\n            if (n < target) lessthan++;\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < count; i++) {\\n            result.add(lessthan++);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int count = 0, lessthan = 0;\\n        for (int n : nums) {\\n            if (n == target) count++;\\n            if (n < target) lessthan++;\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < count; i++) {\\n            result.add(lessthan++);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603203,
                "title": "python-o-n-easy-and-fast",
                "content": "Just count the number of elements that are less than and equal to target and create a list out of those.\\n\\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        lt_count = eq_count = 0\\n        for n in nums:\\n            if n < target:\\n                lt_count += 1\\n            elif n == target:\\n                eq_count += 1\\n            \\n        return list(range(lt_count, lt_count+eq_count))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        lt_count = eq_count = 0\\n        for n in nums:\\n            if n < target:\\n                lt_count += 1\\n            elif n == target:\\n                eq_count += 1\\n            \\n        return list(range(lt_count, lt_count+eq_count))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599800,
                "title": "c-o-n-time-counting-sort",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Sorting\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& A, int target) {\\n        sort(begin(A), end(A));\\n        vector<int> ans;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] == target) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Counting Sort\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& A, int target) {\\n        int cnt = 0, rank = 0; // `cnt` is the frequency of `target`, `rank` is the sum of frequencies of all numbers < target\\n        for (int n : A) {\\n            cnt += n == target;\\n            rank += n < target;\\n        }\\n        vector<int> ans;\\n        while (cnt--) ans.push_back(rank++);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& A, int target) {\\n        sort(begin(A), end(A));\\n        vector<int> ans;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (A[i] == target) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& A, int target) {\\n        int cnt = 0, rank = 0; // `cnt` is the frequency of `target`, `rank` is the sum of frequencies of all numbers < target\\n        for (int n : A) {\\n            cnt += n == target;\\n            rank += n < target;\\n        }\\n        vector<int> ans;\\n        while (cnt--) ans.push_back(rank++);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600903,
                "title": "concise-simple-beats-100-explained-both-o-n-o-nlogn",
                "content": "# **1st Method [Sorting]:**\\n**Code:**\\n```\\npublic List<Integer> targetIndices(int[] nums, int target) {        \\n        Arrays.sort(nums);\\n\\t    ArrayList<Integer> ans = new ArrayList<Integer>();\\n\\t\\t \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == target) ans.add(i);\\n        }\\n        return ans;  \\n\\t\\t}\\n```\\n**Complexity Analysis:**\\nTime Complexity: O(nlogn)        *[As the array is being sorted]*\\nSpace Complexity: O(1)      *[No extra space used]*\\n\\n**Explanation:**\\n*  The array ```nums``` is sorted using ```Array.sort()``` method.\\n*  Then while traversing ```nums```, if any element equals the ```target``` its index is added in the ArrayList ```ans```.\\n* List  ```ans``` is then returned as answer.\\n\\n# **2nd Method [Without Sorting/Optimal]:**\\n**Code:**\\n```\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n         int belowTCount=0, tCount=0;    \\n        for(int n : nums){\\n            if(n<target)\\n                belowTCount++;\\n            else if(n==target)\\n                tCount++;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n            for(int t=0;t<tCount;t++)\\n                ans.add(belowTCount++);\\n    \\n        return ans;\\n    }\\n```\\n**Complexity Analysis:**\\nTime Complexity: O(n)        *[As no sorting is done]*\\nSpace Complexity: O(1)      *[No extra space used]*\\n\\n**Explanation:**\\n* While traversing ```nums```, these variable are used:\\n     ``` belowTCount```: To maintain the count of elements having lesser value than ```target```.\\n\\t ```tCount```: To maintain the count of elements having value equal to ```target```.\\n\\t \\n* \\tNow, as you can see in the ```for-loop```, we are adding ```belowtCount```\\'s value(increased after every iteration) to our list, as it lets us ignore the indexes which have lesser value than the ```target``` and only add indexes of elements equal to ```target```.\\n* \\tThis is the same thing we would have done if the array was sorted.\\n* \\tList ```ans``` is then returned as answer.\\n\\n**The above process mimics answer given after sorting without actually sorting.**\\n\\n\\nDo Upvote,if it helps you \\uD83D\\uDE00\\nComment your doubts, if any \\u270C\\n\\n",
                "solutionTags": [
                    "Java",
                    "Counting Sort"
                ],
                "code": "```\\npublic List<Integer> targetIndices(int[] nums, int target) {        \\n        Arrays.sort(nums);\\n\\t    ArrayList<Integer> ans = new ArrayList<Integer>();\\n\\t\\t \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] == target) ans.add(i);\\n        }\\n        return ans;  \\n\\t\\t}\\n```\n```nums```\n```Array.sort()```\n```nums```\n```target```\n```ans```\n```ans```\n```\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n         int belowTCount=0, tCount=0;    \\n        for(int n : nums){\\n            if(n<target)\\n                belowTCount++;\\n            else if(n==target)\\n                tCount++;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n            for(int t=0;t<tCount;t++)\\n                ans.add(belowTCount++);\\n    \\n        return ans;\\n    }\\n```\n```nums```\n``` belowTCount```\n```target```\n```tCount```\n```target```\n```for-loop```\n```belowtCount```\n```target```\n```target```\n```ans```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606564,
                "title": "4-different-ways-binary-search-counting-sort-time-complexities-explained",
                "content": "**Approach 1**: This approach is naive as it\\'s the one that comes to mind at first. Sort the array. Traverse it and find the valid indexes,such that `nums[index] == target`. \\nTime Complexity: `O(Nlog N + N) ~ O(NLogN)`\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        print(nums);\\n        vector<int> res;\\n        int i =0;\\n        for(auto e: nums){\\n            if(e == target) res.push_back(i);\\n            ++i;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Next two approaches are based on Binary Search technique**\\n**Approach 2**: Sort the array. Find the minimum index (say `lb`) such that` nums[lb] == target`. Similarly find maximum index (say `ub`) such that `nums[ub] == target`. At last push indexes between `lb` and `ub` to result vector(automatically its going to be in sorted order).\\nTime Complexity : `O(NlogN)` for Sort + finding `lb` and `ub` will take` O(log N)` time each + `O(ub-lb)` for traversal\\nthat sums up to `O(NlogN + 2*LogN + N) ~ O(Nlog N)`\\n```\\nclass Solution {\\npublic:\\n    int LB(vector<int> nums, int x){\\n        int l = 0;\\n        int r = nums.size()-1;\\n        int lb = nums.size();\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n            if(nums[m] == x){\\n                lb = m;\\n                r = m - 1;   \\n            }\\n            else if(nums[m] < x){\\n                l = m + 1;\\n            }\\n            else r = m - 1;\\n        }\\n        return lb;\\n    }\\n    int UB(vector<int> nums, int x){\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        int ub = -1;\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n            if(nums[m] == x){\\n                ub = m;\\n                l = m + 1;\\n            }\\n            else if(nums[m] > x){\\n                r = m - 1;\\n            }\\n            else l = m + 1;\\n        }\\n        return ub;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int lb = LB(nums,target);\\n        int ub = UB(nums,target);\\n        //cout<<lb<<\" \"<<ub<<endl;\\n        vector<int> res;\\n        for(int i=lb;i<=ub;++i) res.push_back(i);\\n        return res;\\n    }\\n};\\n```\\n**Approach 3**: Similar to second one. Sort the array. Binary Search to find an index such that `nums[index] == target`. Traverse from `index-1 to 0` to find out left valid indexes and `index+1 to nums.size()-1` to find right valid indexes. In this context, valid specifies the index, where `nums[index] == target` Push those to the result array. And return sorted result array(`say res.size() comes out to be M(obviously M<=N`)).\\nTime Complexity: `O(NlogN + log N + N + MlogM) ~ O(Nlog N)`\\n```\\nclass Solution {\\npublic:\\n    int bsearch(vector<int> &a, int x){\\n        int l = 0;\\n        int r = a.size()-1;\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(a[m] == x) \\n                return m;\\n            else if(a[m] < x)\\n                l = m + 1;\\n            else r = m - 1;\\n        }\\n        return -1;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int index = bsearch(nums,target);\\n        vector<int> res;\\n        if(index == -1) return {};\\n        int i = index-1;\\n        while(i >= 0){\\n            if(nums[i] == target) res.push_back(i);\\n            else break;\\n            i--;\\n        }\\n        res.push_back(index);\\n        i = index + 1;\\n        while(i < nums.size()){\\n            if(nums[i] == target) res.push_back(i);\\n            else break;\\n            \\n            i++;\\n        }\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```\\n**Approach 4:**` Counting Sort Approach(Best approach for this problem)`. In this approach we keep a count of numbers that are smallest than our target(`say rank`) and second we keep a count how many times does this target appears in given array(`say cnt`). Now that we have a count for both the things, we can just loop `cnt `varialble. Keep on pushing rank into result array and incrementing rank for next iteration.\\nTime Complexity: `O(N)`\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int cnt = 0, rank = 0;\\n        for(auto e: nums){\\n            cnt += e == target;\\n            rank  += e < target;\\n        }\\n        vector<int> res;\\n        while(cnt--){\\n            res.push_back(rank++);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Hope it make sense!**",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        print(nums);\\n        vector<int> res;\\n        int i =0;\\n        for(auto e: nums){\\n            if(e == target) res.push_back(i);\\n            ++i;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int LB(vector<int> nums, int x){\\n        int l = 0;\\n        int r = nums.size()-1;\\n        int lb = nums.size();\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n            if(nums[m] == x){\\n                lb = m;\\n                r = m - 1;   \\n            }\\n            else if(nums[m] < x){\\n                l = m + 1;\\n            }\\n            else r = m - 1;\\n        }\\n        return lb;\\n    }\\n    int UB(vector<int> nums, int x){\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        int ub = -1;\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n            if(nums[m] == x){\\n                ub = m;\\n                l = m + 1;\\n            }\\n            else if(nums[m] > x){\\n                r = m - 1;\\n            }\\n            else l = m + 1;\\n        }\\n        return ub;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int lb = LB(nums,target);\\n        int ub = UB(nums,target);\\n        //cout<<lb<<\" \"<<ub<<endl;\\n        vector<int> res;\\n        for(int i=lb;i<=ub;++i) res.push_back(i);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bsearch(vector<int> &a, int x){\\n        int l = 0;\\n        int r = a.size()-1;\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(a[m] == x) \\n                return m;\\n            else if(a[m] < x)\\n                l = m + 1;\\n            else r = m - 1;\\n        }\\n        return -1;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int index = bsearch(nums,target);\\n        vector<int> res;\\n        if(index == -1) return {};\\n        int i = index-1;\\n        while(i >= 0){\\n            if(nums[i] == target) res.push_back(i);\\n            else break;\\n            i--;\\n        }\\n        res.push_back(index);\\n        i = index + 1;\\n        while(i < nums.size()){\\n            if(nums[i] == target) res.push_back(i);\\n            else break;\\n            \\n            i++;\\n        }\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int cnt = 0, rank = 0;\\n        for(auto e: nums){\\n            cnt += e == target;\\n            rank  += e < target;\\n        }\\n        vector<int> res;\\n        while(cnt--){\\n            res.push_back(rank++);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1601648,
                "title": "count-smaller-and-equal",
                "content": "We do not need to sort the array - we can just count elements `smaller` than the target.\\n\\nThe first index of the target (in the sorted array) will be `smaller`, then `smaller + 1`, and so on - depending on how many times the target appears in the array.\\n\\n**C++**\\n```cpp\\nvector<int> targetIndices(vector<int>& nums, int target) {\\n    int smaller = count_if(begin(nums), end(nums), [&](int n){ return n < target; });\\n    int equal = count(begin(nums), end(nums), target);\\n    vector<int> res(equal);\\n    iota(begin(res), end(res), smaller);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> targetIndices(vector<int>& nums, int target) {\\n    int smaller = count_if(begin(nums), end(nums), [&](int n){ return n < target; });\\n    int equal = count(begin(nums), end(nums), target);\\n    vector<int> res(equal);\\n    iota(begin(res), end(res), smaller);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745180,
                "title": "easy-c-solution-binary-search-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <int> ans;   //to store answers\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());     //sorting arrays initially\\n        int start=0, end=nums.size()-1;\\n        binary(nums, start, end, target);   //calling binary search on whole array \\n        return ans;\\n    }\\n    \\n    void binary(vector <int> nums, int start, int end, int target){\\n        if(start>end)       //if array can\\'t be divided into subarrays anymore\\n            return;\\n        \\n        int mid = start + (end-start)/2;        //declaring mid element\\n        if(nums[mid] == target){                //when target is found, push it into ans and call binary on each halved subarrays\\n            binary(nums, start, mid-1, target);\\n            ans.push_back(mid);\\n            binary(nums, mid+1, end, target);      \\n        }\\n        else if(nums[mid]>target)               //calling binary on lower half of array\\n            binary(nums, start, mid-1, target);\\n        else                                    //calling binary on upper half of array\\n            binary(nums, mid+1, end, target);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> ans;   //to store answers\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());     //sorting arrays initially\\n        int start=0, end=nums.size()-1;\\n        binary(nums, start, end, target);   //calling binary search on whole array \\n        return ans;\\n    }\\n    \\n    void binary(vector <int> nums, int start, int end, int target){\\n        if(start>end)       //if array can\\'t be divided into subarrays anymore\\n            return;\\n        \\n        int mid = start + (end-start)/2;        //declaring mid element\\n        if(nums[mid] == target){                //when target is found, push it into ans and call binary on each halved subarrays\\n            binary(nums, start, mid-1, target);\\n            ans.push_back(mid);\\n            binary(nums, mid+1, end, target);      \\n        }\\n        else if(nums[mid]>target)               //calling binary on lower half of array\\n            binary(nums, start, mid-1, target);\\n        else                                    //calling binary on upper half of array\\n            binary(nums, mid+1, end, target);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609499,
                "title": "c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand",
                "content": "**Two methods discussed with explanation.**\\n\\n**Method 1:**\\n\\t**1.** First sort the array.\\n\\t**2.** Find the index of the target\\n\\t**3.** Push it into the **\"result\"** vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> result;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(N log N)\\n\\n\\n**Method 2:**\\n\\t**1.** Count the occurences of elements lesser then the target and freq of target elements.\\n* \\t\\t\\t\"small\" contains the number of element lesser than the target.\\n* \\t\\t\\t\"count\" contains the number of occurences of the target element.\\n**2.** Now run a loop from **\"small\"** ( means **\"small\"** elements are lesser than our target value, so our target value will come after **\"small\"** elements in sorted array ), upto **\"count\"**.\\n**3.** Push the index into the **\"result\"** vector.\\n\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int small=0,count=0,k=0;\\n        for(auto n:nums) {\\n            if(n<target)    small++;                                        // calculates the frequency of elements lesser than the target\\n            if(n==target)   count++;                                        // calculate the number of occurences of the target element\\n        }\\n        vector<int> result(count);\\n        for(int i=small;i<small+count;i++)      \\n            result[k++]=i;\\n        return result;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(N)\\n\\nIf you liked the solution, then please upvote : )",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> result;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int small=0,count=0,k=0;\\n        for(auto n:nums) {\\n            if(n<target)    small++;                                        // calculates the frequency of elements lesser than the target\\n            if(n==target)   count++;                                        // calculate the number of occurences of the target element\\n        }\\n        vector<int> result(count);\\n        for(int i=small;i<small+count;i++)      \\n            result[k++]=i;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676438,
                "title": "python-o-n-simple-and-fast-solution-o-nlogn-sorting-solution",
                "content": "**Python :**\\nTime complexity: *O(n)*\\n```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\tindex = 0\\n\\tcount = 0\\n\\n\\tfor num in nums:\\n\\t\\tif num < target:\\n\\t\\t\\tindex += 1\\n\\n\\t\\tif num == target:\\n\\t\\t\\tcount += 1\\n\\n\\treturn list(range(index, index + count))\\n```\\n\\nTime complexity: *O(nlogn)*\\n\\n```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\tnums = sorted(nums)\\n\\treturn [i for i in range(len(nums)) if nums[i]== target]\\n```\\n\\n**Like it ? please upvote !**\\n\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\tindex = 0\\n\\tcount = 0\\n\\n\\tfor num in nums:\\n\\t\\tif num < target:\\n\\t\\t\\tindex += 1\\n\\n\\t\\tif num == target:\\n\\t\\t\\tcount += 1\\n\\n\\treturn list(range(index, index + count))\\n```\n```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\tnums = sorted(nums)\\n\\treturn [i for i in range(len(nums)) if nums[i]== target]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1603271,
                "title": "java-0ms-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm:\\n        - Parse the array once and count how many are lesser than target and how many are equal\\n        - DO NOT sort the array as we don\\'t need it sorted.\\n          Just to know how many are lesser and how many are equal. O(N) better than O(NlogN - sorting)\\n        - The response list will have a size = with the number of equal elements (as their positions)\\n        - Loop from smaller to smaller+equal and add the values into the list. Return the list\\n    */\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int smaller = 0;\\n        int equal = 0;\\n        for (int num : nums) {\\n            if (num < target) {\\n                smaller++;\\n            } else if (num == target) {\\n                equal++;\\n            }\\n        }\\n\\t\\tList<Integer> indices = new ArrayList<>(equal);\\n        for (int i = smaller; i < smaller + equal; i++) {\\n            indices.add(i);\\n        }\\n        return indices;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm:\\n        - Parse the array once and count how many are lesser than target and how many are equal\\n        - DO NOT sort the array as we don\\'t need it sorted.\\n          Just to know how many are lesser and how many are equal. O(N) better than O(NlogN - sorting)\\n        - The response list will have a size = with the number of equal elements (as their positions)\\n        - Loop from smaller to smaller+equal and add the values into the list. Return the list\\n    */\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int smaller = 0;\\n        int equal = 0;\\n        for (int num : nums) {\\n            if (num < target) {\\n                smaller++;\\n            } else if (num == target) {\\n                equal++;\\n            }\\n        }\\n\\t\\tList<Integer> indices = new ArrayList<>(equal);\\n        for (int i = smaller; i < smaller + equal; i++) {\\n            indices.add(i);\\n        }\\n        return indices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342250,
                "title": "c-easy-binary-search",
                "content": "\\uD83D\\uDE4FUpvote if u like the solution \\uD83D\\uDE4F\\n\\n```\\nclass Solution {\\npublic:\\n    int firstOccurence(vector<int>& nums, int target){\\n        int start = 0;\\n        int res = -1;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target==nums[mid]){\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else if(target<nums[mid])\\n                end = mid-1;\\n            else \\n                start = mid+1;\\n        }\\n        return res;\\n    }\\n    int lastOccurence(vector<int>& nums, int target){\\n        int start = 0;\\n        int res = -1;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target==nums[mid]){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else if(target<nums[mid])\\n                end = mid-1;\\n            else \\n                start = mid+1;\\n        }\\n        return res;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> result;\\n        sort(nums.begin(), nums.end());\\n        int first = firstOccurence(nums, target);\\n        int last = lastOccurence(nums, target);\\n        if(first!=-1 && last!=-1){\\n        for(int i=first; i<=last; i++)\\n            result.push_back(i);}\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstOccurence(vector<int>& nums, int target){\\n        int start = 0;\\n        int res = -1;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target==nums[mid]){\\n                res = mid;\\n                end = mid-1;\\n            }\\n            else if(target<nums[mid])\\n                end = mid-1;\\n            else \\n                start = mid+1;\\n        }\\n        return res;\\n    }\\n    int lastOccurence(vector<int>& nums, int target){\\n        int start = 0;\\n        int res = -1;\\n        int end = nums.size()-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target==nums[mid]){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else if(target<nums[mid])\\n                end = mid-1;\\n            else \\n                start = mid+1;\\n        }\\n        return res;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> result;\\n        sort(nums.begin(), nums.end());\\n        int first = firstOccurence(nums, target);\\n        int last = lastOccurence(nums, target);\\n        if(first!=-1 && last!=-1){\\n        for(int i=first; i<=last; i++)\\n            result.push_back(i);}\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024498,
                "title": "python-solution-one-line",
                "content": "**Solution - Time Complexity: O(n log(n))**:\\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        ans = []\\n        for i,num in enumerate(sorted(nums)):\\n            if num == target: ans.append(i)\\n        return ans\\n```\\n\\n**One-Line - Time Complexity: O(n log(n))**:\\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        return [i for i,num in enumerate(sorted(nums)) if num==target]\\n```\\n\\n**Solution - Time Complexity: O(n)**:\\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        idx = cnt = 0\\n        for num in nums:\\n            idx += num < target\\n            cnt += num == target\\n        return list(range(idx, idx+cnt))\\n```\\n\\n**Solution - Time Complexity: O(n) - Concise**:\\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        idx = sum(num < target  for num in nums)\\n        cnt = sum(num == target for num in nums)\\n        return list(range(idx, idx+cnt))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        ans = []\\n        for i,num in enumerate(sorted(nums)):\\n            if num == target: ans.append(i)\\n        return ans\\n```\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        return [i for i,num in enumerate(sorted(nums)) if num==target]\\n```\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        idx = cnt = 0\\n        for num in nums:\\n            idx += num < target\\n            cnt += num == target\\n        return list(range(idx, idx+cnt))\\n```\n```\\nclass Solution:\\n    def targetIndices(self, nums, target):\\n        idx = sum(num < target  for num in nums)\\n        cnt = sum(num == target for num in nums)\\n        return list(range(idx, idx+cnt))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733548,
                "title": "javascript-solution-using-binary-search",
                "content": "```\\nfunction binarySearch(lists, sorted, low, high, target){\\n    if(low > high) return;\\n    \\n    const mid = low + Math.floor((high - low) / 2);\\n    \\n    if(sorted[mid] === target){\\n    lists.push(mid);\\n    }\\n    \\n    binarySearch(lists, sorted, low, mid-1, target);\\n    binarySearch(lists, sorted, mid+1, high, target);\\n}\\n\\nvar targetIndices = function(nums, target) {\\n    let result = [];\\n    nums.sort((a,b)=>a-b);\\n    if(!nums.includes(target)) return [];\\n\\n    binarySearch(result, nums, 0 , nums.length-1, target);\\n    return result.sort((a,b) => a-b);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nfunction binarySearch(lists, sorted, low, high, target){\\n    if(low > high) return;\\n    \\n    const mid = low + Math.floor((high - low) / 2);\\n    \\n    if(sorted[mid] === target){\\n    lists.push(mid);\\n    }\\n    \\n    binarySearch(lists, sorted, low, mid-1, target);\\n    binarySearch(lists, sorted, mid+1, high, target);\\n}\\n\\nvar targetIndices = function(nums, target) {\\n    let result = [];\\n    nums.sort((a,b)=>a-b);\\n    if(!nums.includes(target)) return [];\\n\\n    binarySearch(result, nums, 0 , nums.length-1, target);\\n    return result.sort((a,b) => a-b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600003,
                "title": "just-count-and-get-index",
                "content": "# We can do it using simple sort , but that makes us learn a new way of finding the index of an element without sorting.\\n\\n**Steps:**\\nJust `count the number of elements smaller` than the target` as target element will have `it\\'s index after them.\\nIf `count of smaller element=n`, then the `index of target element will start from nth index because of 0-based indexing of array.`\\n\\n       vector<int> targetIndices(vector<int>& nums, int target) {\\n        int cnt=0 , small=0 , k=0;\\n\\t\\t\\n        for(auto i:nums){\\n            if(i<target) small++;\\n            if(i==target) cnt++;\\n        }\\n\\t\\t\\n        vector<int> ans;\\n\\t\\t//to make push_back work in O(1) TIME -> RESERVE SPACE\\n\\t\\tans.reserve(cnt);\\n        \\n        for(int i=small;i<cnt+small;i++)   v.push_back(i);    \\n\\t\\t\\n        return v;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "# We can do it using simple sort , but that makes us learn a new way of finding the index of an element without sorting.\\n\\n**Steps:**\\nJust `count the number of elements smaller` than the target` as target element will have `it\\'s index after them.\\nIf `count of smaller element=n`, then the `index of target element will start from nth index because of 0-based indexing of array.`\\n\\n       vector<int> targetIndices(vector<int>& nums, int target) {\\n        int cnt=0 , small=0 , k=0;\\n\\t\\t\\n        for(auto i:nums){\\n            if(i<target) small++;\\n            if(i==target) cnt++;\\n        }\\n\\t\\t\\n        vector<int> ans;\\n\\t\\t//to make push_back work in O(1) TIME -> RESERVE SPACE\\n\\t\\tans.reserve(cnt);\\n        \\n        for(int i=small;i<cnt+small;i++)   v.push_back(i);    \\n\\t\\t\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1699976,
                "title": "java-o-n-single-loop",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        for(int num: nums){\\n            if(num<target){\\n                low++;\\n            }else if(num>target){\\n                high--;\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        while(low<=high){\\n            list.add(low);\\n            low++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        for(int num: nums){\\n            if(num<target){\\n                low++;\\n            }else if(num>target){\\n                high--;\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        while(low<=high){\\n            list.add(low);\\n            low++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878302,
                "title": "python-98-02-faster-binary-search-sorting",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        l,h=0,len(nums)-1\\n        left=right=-1\\n        while l<=h: #For finding the leftmost index of the target element\\n            m=(l+h)>>1\\n            if nums[m]==target:\\n                left=m\\n                h=m-1\\n            elif nums[m]>target:\\n                h=m-1\\n            else:\\n                l=m+1\\n        l,h=left,len(nums)-1\\n        while l<=h: #For finding the rightmost index of the target element\\n            m=(l+h)>>1\\n            if nums[m]==target:\\n                right=m\\n                l=m+1\\n            elif nums[m]>target:\\n                h=m-1\\n            else:\\n                l=m+1\\n        if left==-1:\\n            return []\\n        ans=range(left,right+1)\\n        return ans         \\n```\\n\\n**An upovte will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        l,h=0,len(nums)-1\\n        left=right=-1\\n        while l<=h: #For finding the leftmost index of the target element\\n            m=(l+h)>>1\\n            if nums[m]==target:\\n                left=m\\n                h=m-1\\n            elif nums[m]>target:\\n                h=m-1\\n            else:\\n                l=m+1\\n        l,h=left,len(nums)-1\\n        while l<=h: #For finding the rightmost index of the target element\\n            m=(l+h)>>1\\n            if nums[m]==target:\\n                right=m\\n                l=m+1\\n            elif nums[m]>target:\\n                h=m-1\\n            else:\\n                l=m+1\\n        if left==-1:\\n            return []\\n        ans=range(left,right+1)\\n        return ans         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442824,
                "title": "easy-java-fast-for-beginners-explained",
                "content": "# Approach\\n- Quick sort the array\\n- Iterate through the list and add all the indexes for which target == nums[i].\\n- return the arraylist\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> a = new ArrayList<>();\\n        for(int i = 0;i<nums.length;i++){\\n            if (nums[i] == target){\\n                a.add(i);\\n            }else if(nums[i] > target){\\n                break;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/58351ff4-3008-4b0c-a91a-9eb320e99e9d_1682141128.9090092.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> a = new ArrayList<>();\\n        for(int i = 0;i<nums.length;i++){\\n            if (nums[i] == target){\\n                a.add(i);\\n            }else if(nums[i] > target){\\n                break;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353033,
                "title": "simple-c-solution-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : \\n- Simple Iteration Over sorted Array ! \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> result;\\n        for (int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                result.push_back(i);\\n            }\\n        }\\n        return result;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> result;\\n        for (int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                result.push_back(i);\\n            }\\n        }\\n        return result;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586361,
                "title": "java-array-sorting-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(i);\\n            if(nums[i]>target)\\n                break;\\n        }\\n        return list;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(i);\\n            if(nums[i]>target)\\n                break;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215861,
                "title": "go-o-n-one-pass",
                "content": "```\\nfunc targetIndices(nums []int, target int) []int {\\n    var res []int\\n    \\n    count, left := 0, 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] == target {\\n            count++\\n        }\\n        \\n        if nums[i] < target {\\n            left++\\n        }\\n    }\\n    \\n    for i := 0; i < count; i++ {\\n        res = append(res, left)\\n        left++\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc targetIndices(nums []int, target int) []int {\\n    var res []int\\n    \\n    count, left := 0, 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] == target {\\n            count++\\n        }\\n        \\n        if nums[i] < target {\\n            left++\\n        }\\n    }\\n    \\n    for i := 0; i < count; i++ {\\n        res = append(res, left)\\n        left++\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873968,
                "title": "python-binsearch",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        \\n        def bin_search(arr, t, lower=True):\\n            left, right = 0, len(arr) -1 \\n            \\n            while left <= right:\\n\\n                mid = (left + right) // 2\\n\\n                if arr[mid] == t:\\n                    if lower:\\n                        if mid == left or nums[mid] != arr[mid - 1]:\\n                            return mid\\n                        else:\\n                            right = mid - 1\\n                    else:\\n                        if mid == right or arr[mid] != arr[mid + 1]:\\n                            return mid\\n                        else:\\n                            left = mid + 1\\n                        \\n                elif arr[mid] > t:\\n                    right = mid - 1 \\n                elif nums[mid] < t:\\n                    left = mid + 1\\n            \\n            return -1\\n        \\n        start, end = bin_search(nums, target), bin_search(nums, target, False)\\n        \\n        if start < 0 and end < 0:\\n            return []\\n        \\n        return list(range(start, end + 1))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        \\n        def bin_search(arr, t, lower=True):\\n            left, right = 0, len(arr) -1 \\n            \\n            while left <= right:\\n\\n                mid = (left + right) // 2\\n\\n                if arr[mid] == t:\\n                    if lower:\\n                        if mid == left or nums[mid] != arr[mid - 1]:\\n                            return mid\\n                        else:\\n                            right = mid - 1\\n                    else:\\n                        if mid == right or arr[mid] != arr[mid + 1]:\\n                            return mid\\n                        else:\\n                            left = mid + 1\\n                        \\n                elif arr[mid] > t:\\n                    right = mid - 1 \\n                elif nums[mid] < t:\\n                    left = mid + 1\\n            \\n            return -1\\n        \\n        start, end = bin_search(nums, target), bin_search(nums, target, False)\\n        \\n        if start < 0 and end < 0:\\n            return []\\n        \\n        return list(range(start, end + 1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706705,
                "title": "python-3-40ms-o-nlogn-sorting-simple-solution",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        ans=[]\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        ans=[]\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612798,
                "title": "c-naive-and-linear-single-pass-solutions-compared-100-time-99-space",
                "content": "This problem is very trivial to be solved just following the requirement and, without even bothering to overthink, we might just do what we are told to do, given the very low constraints.\\n\\nWe will first of all declare a result variable `res`, then sort `nums`, proceed to iterate through them through an index `i` and record the position of any number `n` (`= nums[i]`) matching `target`, then finalle `return` `res`.\\n\\nThe naive code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        // support variables\\n        vector<int> res;\\n        // finding matches\\n        sort(begin(nums), end(nums));\\n        for (int i = 0, lmt = nums.size(), n; i < lmt; i++) {\\n            n = nums[i];\\n            if (n == target) res.push_back(i);\\n            else if (n > target) break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nDo we really need to sort the whole input vector? Probably not in a number of cases, so we might be instead first compute how many elements are before `target` and then `partial_sort` accordingly, bearing in mind that partial-sorting has an approssimate complexity which approximates to `(end - begin) * log(begin - mid)`, thus it might easily give us some improvements when the amount of elements to sort (`mid` in the above formula, `notOverTarget` in the code) is close to the start of the vector (`begin`), for the mere cost of an extra pass.\\n\\nThe code, which performs hardly any better with the short input we get, but still worth discussing in interviews - if you ask me:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        // support variables\\n        vector<int> res;\\n        int notOverTarget = accumulate(begin(nums), end(nums), 0, [target](int a, int b){return a + (b <= target);});\\n        // finding matches\\n        partial_sort(begin(nums), begin(nums) + notOverTarget, end(nums));\\n        for (int i = 0, lmt = nums.size(), n; i < lmt; i++) {\\n            n = nums[i];\\n            if (n == target) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut... Wait a moment! If we know how many elements are going to be not greater than `target`, we might not needt to sort at all!\\n\\nChanging our logic a bit, we might still iterate once through `nums`, figure out how many elements are strictly less than `target` (`lower`) and how many are equal to it (`matches`) and then just create `res` to be of the proper size (`matches`, again) and set its value to be starting from the amount of lesser elements onwards!\\n\\nIf that helps, think about implicitly having done a bucket-sorting of `nums`, but without actually rearranging the cell (and consuming space and time to do so), focusing only on the three buckets: lesser, equal and greater values, with no need to even bother counting the third ones.\\n\\nThe linear time code, which performs significantly better even on the small inputs we were provided:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        // counting lesser and equal elements than target in nums\\n        int less = 0, matches = 0;\\n        for_each(begin(nums), end(nums), [&](int n){\\n            if (n < target) less++;\\n            else if (n == target) matches++;\\n        });\\n        // setting and filling res accordingly\\n        vector<int> res(matches);\\n        iota(begin(res), end(res), less);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bucket Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        // support variables\\n        vector<int> res;\\n        // finding matches\\n        sort(begin(nums), end(nums));\\n        for (int i = 0, lmt = nums.size(), n; i < lmt; i++) {\\n            n = nums[i];\\n            if (n == target) res.push_back(i);\\n            else if (n > target) break;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        // support variables\\n        vector<int> res;\\n        int notOverTarget = accumulate(begin(nums), end(nums), 0, [target](int a, int b){return a + (b <= target);});\\n        // finding matches\\n        partial_sort(begin(nums), begin(nums) + notOverTarget, end(nums));\\n        for (int i = 0, lmt = nums.size(), n; i < lmt; i++) {\\n            n = nums[i];\\n            if (n == target) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        // counting lesser and equal elements than target in nums\\n        int less = 0, matches = 0;\\n        for_each(begin(nums), end(nums), [&](int n){\\n            if (n < target) less++;\\n            else if (n == target) matches++;\\n        });\\n        // setting and filling res accordingly\\n        vector<int> res(matches);\\n        iota(begin(res), end(res), less);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485696,
                "title": "easy-to-understand-c-code",
                "content": "# Why Linear search better than Binary search in this case\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this case using binary search is not an optimal solution because \\n\\n- The given array is not sorted so sorting it will take $$nlogn$$ time complexity itself.\\n- if after sorting the array contains the target element in both halves of the given array then we will need to traverse again one of the half after using binary search on the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasic Linear Search\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829312,
                "title": "java-easily-understandable-properly-explained",
                "content": "\\n# Approach\\n1st: sorting the array;\\n2nd: using a for loop, if any value matches with target then inserting that into the list.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] == target) {\\n                    list.add(i);\\n                }\\n            }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] == target) {\\n                    list.add(i);\\n                }\\n            }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570024,
                "title": "python-c-java-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2089. Find Target Indices After Sorting Array***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l,h=0,len(nums)\\n        for n in nums:\\n            if n>target:\\n                h-=1\\n            elif n<target:\\n                l+=1\\n        return (range(l,h))\\n```\\n**Runtime:**  55 ms\\t\\n**Memory Usage:**  13.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> ans=new ArrayList<>();\\n        Arrays.sort(nums);\\n        int l=0,h=nums.length-1;\\n        for(int num:nums)\\n        {\\n            if(num<target)\\n                l++;\\n            else if(num>target)\\n                h--;\\n        }\\n        while(l<=h)\\n            ans.add(l++);\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Runtime:**  3 ms\\t\\t\\n**Memory Usage:**  43..8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l=0,h=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        for(auto num:nums)\\n        {\\n            if (num>target)\\n                h--;\\n            else if(num<target)\\n                l++;\\n        }\\n        while(l<=h)\\n        {\\n            ans.push_back(l++);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Runtime:** 7 ms\\t\\n**Memory Usage:**  11.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l,h=0,len(nums)\\n        for n in nums:\\n            if n>target:\\n                h-=1\\n            elif n<target:\\n                l+=1\\n        return (range(l,h))\\n```\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> ans=new ArrayList<>();\\n        Arrays.sort(nums);\\n        int l=0,h=nums.length-1;\\n        for(int num:nums)\\n        {\\n            if(num<target)\\n                l++;\\n            else if(num>target)\\n                h--;\\n        }\\n        while(l<=h)\\n            ans.add(l++);\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l=0,h=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        for(auto num:nums)\\n        {\\n            if (num>target)\\n                h--;\\n            else if(num<target)\\n                l++;\\n        }\\n        while(l<=h)\\n        {\\n            ans.push_back(l++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199403,
                "title": "c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand",
                "content": "## **O(N) Solution**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> vec;\\n        int c1=0, c2=0;\\n        for(auto i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n                c2++;\\n            else if(nums[i]<target)\\n                c1++;\\n        }\\n        for(auto i=c1;i<c2+c1;i++)\\n            vec.emplace_back(i);\\n    return vec;\\n    }\\n};\\n```\\n\\n## **O(N logN) Solution**\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> vec;\\n        sort(nums.begin(),nums.end());\\n        for(auto i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n                vec.emplace_back(i);\\n        }\\n    return vec;\\n    }\\n};\\n```\\n\\n# **Please Upvote if it helps \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> vec;\\n        int c1=0, c2=0;\\n        for(auto i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n                c2++;\\n            else if(nums[i]<target)\\n                c1++;\\n        }\\n        for(auto i=c1;i<c2+c1;i++)\\n            vec.emplace_back(i);\\n    return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> vec;\\n        sort(nums.begin(),nums.end());\\n        for(auto i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n                vec.emplace_back(i);\\n        }\\n    return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756470,
                "title": "c-easy-fast-explained-binary-search",
                "content": "**Approach**\\n* Sort the nums vector\\n* Find the index where target is found using a binary search function\\n* in case no such index found return empty vector\\n* Otherwise, take a temp variable with value of srch-1 and iterate till temp reaches 0 and push all such temp index in ans vector\\n* Reverse the ans vector and tehn store srch index\\n* iterate from srch+1 till right end and store all such index havng target stored\\n````\\nclass Solution {\\npublic:\\n    int bs(vector<int>& nums, int target){\\n        int l=0,m;\\n        int r=nums.size()-1;\\n        while(l<=r)\\n        {\\n            m=l+(r-l)/2;\\n            if(nums[m]==target)return m;\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        return -1;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int srch=bs(nums,target);\\n        if(srch==-1)return {};\\n        int l=0,r=nums.size()-1;\\n        int temp=srch-1;\\n            while(temp>=0 && nums[temp]==target)\\n            {\\n             ans.push_back(temp);\\n             temp--;\\n            }\\n            reverse(ans.begin(),ans.end());\\n            ans.push_back(srch);\\n            temp=srch+1;\\n            while(temp<=r && nums[temp]==target)\\n            {\\n             ans.push_back(temp);\\n             temp++;\\n            }\\n        return ans;\\n    }\\n};\\n````\\n\\nTC: O(NlogN)+O(logN) +O(N) +O(N)\\nSC: O(N)\\n**Please Upvote if you like the solution! :)**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int bs(vector<int>& nums, int target){\\n        int l=0,m;\\n        int r=nums.size()-1;\\n        while(l<=r)\\n        {\\n            m=l+(r-l)/2;\\n            if(nums[m]==target)return m;\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        return -1;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        int srch=bs(nums,target);\\n        if(srch==-1)return {};\\n        int l=0,r=nums.size()-1;\\n        int temp=srch-1;\\n            while(temp>=0 && nums[temp]==target)\\n            {\\n             ans.push_back(temp);\\n             temp--;\\n            }\\n            reverse(ans.begin(),ans.end());\\n            ans.push_back(srch);\\n            temp=srch+1;\\n            while(temp<=r && nums[temp]==target)\\n            {\\n             ans.push_back(temp);\\n             temp++;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240038,
                "title": "python3-easy-beginner-solution",
                "content": "# Please upvote if you find the solution helpful\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l=[]\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                l.append(i)\\n        return l\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l=[]\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                l.append(i)\\n        return l\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878309,
                "title": "python-98-02-faster-o-n-solution-without-sorting",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l=c=0\\n        for i in nums:\\n            if i==target:\\n                c+=1\\n            elif i<target:\\n                l+=1\\n        ans=[]\\n        for i in range(c):\\n            ans.append(l)\\n            l+=1\\n        return ans\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l=c=0\\n        for i in nums:\\n            if i==target:\\n                c+=1\\n            elif i<target:\\n                l+=1\\n        ans=[]\\n        for i in range(c):\\n            ans.append(l)\\n            l+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274148,
                "title": "c-easy-solution-using-binary-search-well-explained-using-comments-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        \\n        sort (nums.begin(), nums.end());\\n        \\n        int low = 0;\\n        int high = nums.size() - 1;\\n        int mid;\\n        vector <int> ans;\\n        \\n        /*So the logic that we are going to use is:\\n        Binary Search is successful in finding only 1 instance of an element if there are multiple duplicates. So how do we find the rest instances. \\n        What I thought is that binary search randomly finds one instance of an element from the sorted array.\\n        So the other instances of that element will either be on its right or on its left and no where else.\\n        What if we store the index of the element found and use that index to find if the same element lies on it sright and left.\\n        NOTE: The boundary conditions, index must not go below 0 or higher than size of array which can give runtime error*/\\n        \\n        \\n        while (low <= high)\\n        {\\n            mid = (high+low)/2;\\n            \\n            if (nums[mid] == target)\\n            {\\n                ans.push_back (mid);\\n                break;\\n            }\\n            else if (nums[mid] < target)\\n            {\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        /*If no instance is found then we return the empty array as there cannot be any other duplicate*/\\n        if (ans.size() == 0)\\n            return ans;\\n        \\n        int tmid = mid;\\n        \\n        /*Checking the left side of the found element*/\\n        mid--;\\n        while (mid >= 0 && nums[mid] == target)\\n        {\\n            ans.push_back (mid);\\n            mid--;\\n        }\\n        \\n        mid = tmid;\\n        \\n        \\n        /*Checking the right side of the found element*/\\n        mid++;\\n        while (mid < nums.size() && nums[mid] == target)\\n        {\\n            ans.push_back (mid);\\n            mid++;\\n        }\\n        \\n        \\n        //Sorting the found element in ascending order\\n        sort (ans.begin(), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        \\n        sort (nums.begin(), nums.end());\\n        \\n        int low = 0;\\n        int high = nums.size() - 1;\\n        int mid;\\n        vector <int> ans;\\n        \\n        /*So the logic that we are going to use is:\\n        Binary Search is successful in finding only 1 instance of an element if there are multiple duplicates. So how do we find the rest instances. \\n        What I thought is that binary search randomly finds one instance of an element from the sorted array.\\n        So the other instances of that element will either be on its right or on its left and no where else.\\n        What if we store the index of the element found and use that index to find if the same element lies on it sright and left.\\n        NOTE: The boundary conditions, index must not go below 0 or higher than size of array which can give runtime error*/\\n        \\n        \\n        while (low <= high)\\n        {\\n            mid = (high+low)/2;\\n            \\n            if (nums[mid] == target)\\n            {\\n                ans.push_back (mid);\\n                break;\\n            }\\n            else if (nums[mid] < target)\\n            {\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        /*If no instance is found then we return the empty array as there cannot be any other duplicate*/\\n        if (ans.size() == 0)\\n            return ans;\\n        \\n        int tmid = mid;\\n        \\n        /*Checking the left side of the found element*/\\n        mid--;\\n        while (mid >= 0 && nums[mid] == target)\\n        {\\n            ans.push_back (mid);\\n            mid--;\\n        }\\n        \\n        mid = tmid;\\n        \\n        \\n        /*Checking the right side of the found element*/\\n        mid++;\\n        while (mid < nums.size() && nums[mid] == target)\\n        {\\n            ans.push_back (mid);\\n            mid++;\\n        }\\n        \\n        \\n        //Sorting the found element in ascending order\\n        sort (ans.begin(), ans.end());\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726393,
                "title": "simple-python-code-with-explanation",
                "content": "**Simple O(nlogn) Solution:**\\nIf we sort the array, simply we can search through array and see at which index target exists and we just update it in our result. \\n\\n```\\nclass Solution:\\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(i)\\n        return res\\n```\\n\\n**O(N) Solution**\\nWe can traverse through array and see how many elements exist which are less than target and how many target elements are present. Then we dont need to serach the array \\n\\nLets take an example:\\nnums = [1 3 4 2 2 5]\\n\\nIf we sort above array then output would look something like this\\nnums = [1 2 2 3 4 5]\\n\\nWhat information is useful if we sort array is how many numbers are present less than target. Once we know it and number of targets. We can get it without sorting too. We can just iterate through array and see get it. Once we have that we can simply push target index after no of elements which are less than target. \\n```\\nclass Solution:\\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        equal = 0\\n        less = 0\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                equal += 1\\n            elif nums[i] < target:\\n                less += 1\\n        \\n        for i in range(equal):\\n            res.append(less)\\n            less += 1\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(i)\\n        return res\\n```\n```\\nclass Solution:\\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        equal = 0\\n        less = 0\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                equal += 1\\n            elif nums[i] < target:\\n                less += 1\\n        \\n        for i in range(equal):\\n            res.append(less)\\n            less += 1\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672906,
                "title": "two-method-soln-in-python-without-sorting",
                "content": "Method  - 1 \\nWithout Sorting Simple logic\\nTC - O(N)\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        \\n        m=c=0 \\n        for i in nums:\\n            if i<target:\\n                m+=1\\n            if i==target:\\n                c+= 1\\n        if target not in nums:\\n            return []\\n        \\n        ans=[]\\n        while c > 0:\\n            ans.append(m)\\n            m+=1\\n            c-=1\\n        return ans\\n```\\n\\nMethod - 2\\nUsing Min Heap :-\\nTC - O(NlogN)\\n\\n```\\nclass Solution:\\n    \\n    import heapq\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        \\n        heapq.heapify(nums)\\n        i=0\\n        ans=[]\\n        while nums!=[]:\\n            x = heapq.heappop(nums)\\n            if x==target:\\n                ans.append(i)\\n            if x > target:\\n                break\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        \\n        m=c=0 \\n        for i in nums:\\n            if i<target:\\n                m+=1\\n            if i==target:\\n                c+= 1\\n        if target not in nums:\\n            return []\\n        \\n        ans=[]\\n        while c > 0:\\n            ans.append(m)\\n            m+=1\\n            c-=1\\n        return ans\\n```\n```\\nclass Solution:\\n    \\n    import heapq\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        \\n        heapq.heapify(nums)\\n        i=0\\n        ans=[]\\n        while nums!=[]:\\n            x = heapq.heappop(nums)\\n            if x==target:\\n                ans.append(i)\\n            if x > target:\\n                break\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624779,
                "title": "c-o-n-time-without-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int start=0,fre=0;\\n        for(auto i: nums)\\n        {   if(i<target)start++;//counted elements less than the target\\n            if(i==target)fre++;}//frequency of the target\\n            while(fre--)\\n                ans.push_back(start++);\\n            return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int start=0,fre=0;\\n        for(auto i: nums)\\n        {   if(i<target)start++;//counted elements less than the target\\n            if(i==target)fre++;}//frequency of the target\\n            while(fre--)\\n                ans.push_back(start++);\\n            return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612141,
                "title": "java-code-both-approach",
                "content": "**Brute Force - **\\nT.C => nlog(n) + O(n)\\n\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        \\n        //nlog(n)\\n        Arrays.sort(nums);\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = nums.length;\\n        \\n        //O(n)\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Optimized Approach - Count Sort**\\nCounting Sort\\nOne iteration to count less than target, and equal target. Build output based on the first index at lessthan.\\nT.C => O(N) \\n\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int count = 0, lessthan = 0;\\n        for (int n : nums) {\\n            if (n == target) count++;\\n            if (n < target) lessthan++;\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < count; i++) {\\n            result.add(lessthan++);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        \\n        //nlog(n)\\n        Arrays.sort(nums);\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = nums.length;\\n        \\n        //O(n)\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        int count = 0, lessthan = 0;\\n        for (int n : nums) {\\n            if (n == target) count++;\\n            if (n < target) lessthan++;\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < count; i++) {\\n            result.add(lessthan++);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983454,
                "title": "simple-binary-search-solution-100-91",
                "content": "bins\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    let result = [];\\n    if(!nums.includes(target)) return result;\\n    \\n    let sortedArr = nums;\\n    sortedArr.sort((a,b) => a-b);\\n    let left = 0;\\n    let right = sortedArr.length-1;\\n    let start = -1;\\n    let end = -1;\\n\\n    while(left <= right){\\n        let mid = Math.round((right + left) / 2);\\n        if(sortedArr[mid] === target){\\n            start = mid-1;\\n            end = mid+1;\\n\\n            result.push(mid)\\n            while(sortedArr[start] === target){\\n                result.push(start)\\n                start -= 1\\n            }\\n            while(sortedArr[end] === target){\\n                result.push(end)\\n                end += 1\\n            }\\n            break;\\n        }else if(sortedArr[mid] < target){\\n            left = mid+1;\\n        }else if(sortedArr[mid] > target){\\n            right = mid-1;\\n        }\\n    }\\n    return result.sort((a,b) => a-b)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    let result = [];\\n    if(!nums.includes(target)) return result;\\n    \\n    let sortedArr = nums;\\n    sortedArr.sort((a,b) => a-b);\\n    let left = 0;\\n    let right = sortedArr.length-1;\\n    let start = -1;\\n    let end = -1;\\n\\n    while(left <= right){\\n        let mid = Math.round((right + left) / 2);\\n        if(sortedArr[mid] === target){\\n            start = mid-1;\\n            end = mid+1;\\n\\n            result.push(mid)\\n            while(sortedArr[start] === target){\\n                result.push(start)\\n                start -= 1\\n            }\\n            while(sortedArr[end] === target){\\n                result.push(end)\\n                end += 1\\n            }\\n            break;\\n        }else if(sortedArr[mid] < target){\\n            left = mid+1;\\n        }else if(sortedArr[mid] > target){\\n            right = mid-1;\\n        }\\n    }\\n    return result.sort((a,b) => a-b)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983191,
                "title": "easiest-solution-100-87",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    let result = [];\\n\\n    nums.sort((a,b) => a-b).forEach((item, idx) => {\\n        if(item === target){\\n            result.push(idx);\\n        }\\n    })\\n    return result\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    let result = [];\\n\\n    nums.sort((a,b) => a-b).forEach((item, idx) => {\\n        if(item === target){\\n            result.push(idx);\\n        }\\n    })\\n    return result\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3817316,
                "title": "binary-search-solution-first-and-last-position-c",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    \\n    int left(vector<int>&nums,int k,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]==k){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<k){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int right(vector<int>&nums,int k,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]==k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<k){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int l=left(nums,target,n);\\n        int r=right(nums,target,n);\\n        if(l==-1)return {};\\n        vector<int>vect;\\n        for(int i=l;i<=r;i++){\\n            vect.push_back(i);\\n        }\\n        return vect;\\n      }\\n    };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n    \\n    int left(vector<int>&nums,int k,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]==k){\\n                ans=mid;\\n                high=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3452412,
                "title": "simple-o-n-solution-no-sorting",
                "content": "# Intuition\\nYou don\\'t need to sort the Array, you only need to find numbers bigger than target and smaller than target. Once you have that you can easily count the indices.\\n\\n# Approach\\nIterate over each number in the array and keep track of numbers lesser than target in the variable startSkip and numbers greater than target in the variable endSkip. \\n\\nRun a for look starting from the first index where the first occurance of target will occur in the sorted array and iteratively keep adding indices until you reach the last index of target number, which will be endSkip numbers away from the last index of the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) to store the elements.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> TargetIndices(int[] nums, int target) {\\n        List<int> nos = new List<int>();\\n        int startSkip = 0;\\n        int endSkip = 0;\\n        foreach(int num in nums){\\n            if (num > target){\\n                endSkip++;\\n            }\\n            if (num < target){\\n                startSkip++;\\n            }\\n        }\\n        \\n        for(int i = startSkip; i<nums.Length-endSkip; i++){\\n            nos.Add(i);\\n        }\\n\\n        return nos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> TargetIndices(int[] nums, int target) {\\n        List<int> nos = new List<int>();\\n        int startSkip = 0;\\n        int endSkip = 0;\\n        foreach(int num in nums){\\n            if (num > target){\\n                endSkip++;\\n            }\\n            if (num < target){\\n                startSkip++;\\n            }\\n        }\\n        \\n        for(int i = startSkip; i<nums.Length-endSkip; i++){\\n            nos.Add(i);\\n        }\\n\\n        return nos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367784,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int bs(vector<int>&v,int k,bool first=true)\\n    {\\n        int l = 0, h = size(v)-1, md,ans = -1;\\n        while(h >= l){\\n            md = l + (h-l)/2;\\n            if(v[md] == k){\\n                ans = md;\\n                first ? h = md-1 : l = md + 1;\\n            }\\n            else if(v[md] > k) h = md-1;\\n            else l = md+1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(begin(nums),end(nums));\\n        int first = bs(nums,target);\\n        if(first == -1) return {};\\n        int second = bs(nums,target,false);\\n        vector<int> ans(second-first+1);\\n        iota(begin(ans),end(ans),first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bs(vector<int>&v,int k,bool first=true)\\n    {\\n        int l = 0, h = size(v)-1, md,ans = -1;\\n        while(h >= l){\\n            md = l + (h-l)/2;\\n            if(v[md] == k){\\n                ans = md;\\n                first ? h = md-1 : l = md + 1;\\n            }\\n            else if(v[md] > k) h = md-1;\\n            else l = md+1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(begin(nums),end(nums));\\n        int first = bs(nums,target);\\n        if(first == -1) return {};\\n        int second = bs(nums,target,false);\\n        vector<int> ans(second-first+1);\\n        iota(begin(ans),end(ans),first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285557,
                "title": "2-lines-of-code-using-bst-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        n=sorted(nums)\\n        index1,index2=bisect.bisect_left(n,target),bisect.bisect_right(n,target)\\n        return list(range(index1,index2))\\n    #please upvote me it would encourage me alot\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        n=sorted(nums)\\n        index1,index2=bisect.bisect_left(n,target),bisect.bisect_right(n,target)\\n        return list(range(index1,index2))\\n    #please upvote me it would encourage me alot\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222383,
                "title": "how-binary-search-simple-time-efficient-approach-explained-in-detail-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The problem is labelled as \\'Binary Search\\' but since the array is not given in sorted form, we can\\'t use binary search directly and sorting it to apply binary search will give time complexity of $$O(n logn)$$ (due to sorting).\\n\\n2. And even after sorting, it the target element lies in both the sub-divisions of the array, then also we will have to traverse the entire array in order to count its total occurances.\\n\\n3. Hence, using binary search would not be an ideal approach for this problem. \\n\\n--> The most efficient time complexity which can be achieved in this problem is $$O(n)$$. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse the entire array in one go in $$O(n)$$ time and store the **count of occurances of target element** (*let say in variable count*) and **elements which are lesser than it** (*let say in variable lesser*).\\n\\n2. Create a vector (array) and enter the target indices which will hold the target element as per the values obtained from lesser and count variables in non-decreasing order.\\n\\n3. Finally return the output vector. \\n\\n# Complexity\\n- Time complexity = $$O(n)$$, due to linear traversal in array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, due to the output vector used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans ;\\n\\n        int n = nums.size() ;\\n\\n        int count = 0, lesser = 0 ;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < target) lesser++ ;\\n            else if(nums[i] == target) count++ ;\\n        }\\n\\n        int start = lesser, end = start + count - 1 ;\\n        for(int i=start; i<=end; i++){\\n            ans.push_back(i) ;\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans ;\\n\\n        int n = nums.size() ;\\n\\n        int count = 0, lesser = 0 ;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < target) lesser++ ;\\n            else if(nums[i] == target) count++ ;\\n        }\\n\\n        int start = lesser, end = start + count - 1 ;\\n        for(int i=start; i<=end; i++){\\n            ans.push_back(i) ;\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891516,
                "title": "o-n-solution-python",
                "content": "## Count Operation: \\n```\\n# Author: github.com/Ayon-SSP\\n# Time: O(N)\\n# Space: O(1)\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        lowVals = 0; repOfTg = 0\\n        for val in nums:\\n            if val < target:\\n                lowVals += 1\\n            elif val == target:\\n                repOfTg += 1\\n        ans = []\\n        for _ in range(repOfTg):\\n            ans.append(lowVals)\\n            lowVals += 1\\n        return ans\\n```\\nCheck Out SDE Prep full Road Map[`GitHub`](https://github.com/Ayon-SSP/The-SDE-Prep)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Author: github.com/Ayon-SSP\\n# Time: O(N)\\n# Space: O(1)\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        lowVals = 0; repOfTg = 0\\n        for val in nums:\\n            if val < target:\\n                lowVals += 1\\n            elif val == target:\\n                repOfTg += 1\\n        ans = []\\n        for _ in range(repOfTg):\\n            ans.append(lowVals)\\n            lowVals += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864266,
                "title": "beats-98-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        if len(nums) == 1:\\n            if target in nums:\\n                return [0]\\n            else:\\n                return []\\n        else:\\n            if target in nums:\\n                nums.sort()\\n                count = nums.count(target)\\n                reference = nums.index(target)\\n                values = [reference]\\n                for i in range(1, count):\\n                    reference += 1\\n                    values += [nums.index(target, reference)]\\n                return values\\n            else:\\n                return []\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        if len(nums) == 1:\\n            if target in nums:\\n                return [0]\\n            else:\\n                return []\\n        else:\\n            if target in nums:\\n                nums.sort()\\n                count = nums.count(target)\\n                reference = nums.index(target)\\n                values = [reference]\\n                for i in range(1, count):\\n                    reference += 1\\n                    values += [nums.index(target, reference)]\\n                return values\\n            else:\\n                return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677558,
                "title": "bruetforce-java-easy",
                "content": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> al=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                al.add(i);\\n                \\n        }\\n        return al;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> al=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                al.add(i);\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2659821,
                "title": "c-binary-search",
                "content": "class Solution {\\npublic:\\n    \\n    // first occurence\\n    int firstocc(vector<int>v,int k)\\n    {  int n=v.size();\\n        int s=0,e=n-1;\\n     int ans=-1;\\n     int mid=s+(e-s)/2;\\n     \\n     while(s<=e)\\n     {\\n         if(v[mid]==k)\\n         {\\n             ans=mid;\\n             e=mid-1;\\n         }\\n         else if(v[mid]>k)  e=mid-1;\\n         else s=mid+1;\\n         mid=s+(e-s)/2;\\n\\n     }\\n     return ans;\\n    }\\n    // last occurence \\n    \\n    int lastocc(vector<int>v,int k)\\n    {  int n=v.size();\\n        int s=0,e=n-1;\\n     int ans=-1;\\n     int mid=s+(e-s)/2;\\n     \\n     while(s<=e)\\n     {\\n         if(v[mid]==k)\\n         {\\n             ans=mid;\\n             s=mid+1;\\n         }\\n         else if(v[mid]>k)  e=mid-1;\\n         else s=mid+1;\\n         mid=s+(e-s)/2;\\n\\n     }\\n     return ans;\\n    }\\n    \\n    \\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int >Ans;\\n        int n1=firstocc(nums,target);\\n        int n2=lastocc(nums,target) ;\\n        if(n1!=-1 && n2!=-1)\\n        {\\n            for(int i=n1;i<=n2;i++)\\n            {\\n                Ans.push_back(i);\\n            }\\n        }\\n        return Ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // first occurence\\n    int firstocc(vector<int>v,int k)\\n    {  int n=v.size();\\n        int s=0,e=n-1;\\n     int ans=-1;\\n     int mid=s+(e-s)/2;\\n     \\n     while(s<=e)\\n     {\\n         if(v[mid]==k)\\n         {\\n             ans=mid;\\n             e=mid-1;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2540129,
                "title": "faster-no-sorting-easy-c-solution",
                "content": "**If you find it helpful, Please Up-Vote it.**\\n\\n\\n### **Intution :-**\\n* We can get the answer **without sorting the array**\\n* We need to **keep count the number of elements smaller than the target**, present in array, because the will definetitly come before the target when sorted.\\n* We also need tho **count the number of occurence of target element** in array, so that we can return the array having position of all ocurrence.\\n* We can get the position of target element by using simple formula :-\\n**Position** **=** **Number of elements smaller than target element** \\n* We can iterate a loop for all occurence of target, and just increase the position by 1;\\n\\n### **Approach :-**\\n* Keep two variables, `small` and `count`.\\n* `small` will keep count of all the elements which are lesser than the `target` element.\\n* `count` will keep count of number of occurence of the `target` element.\\n* Now, we can iterate a loop till we get the toal number of `target` element present in array (i.e., `count`).\\n* In each iteration, we will store the the position of `target` element in sorted array, which will be `small`+`iterator`.\\n\\n### **C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int count=0;\\n        int small = 0;\\n        \\n\\t\\t//------Iterating to get the count and small elements\\n        for(auto e : nums){\\n            if(e==target){\\n                count++;\\n            }\\n            else if(e<target){\\n                small++;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//-------generating the answer vector\\n        for(int i=0; i<count; i++){\\n            ans.push_back(small+i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**If you find it helpful, Please Up-Vote it.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int count=0;\\n        int small = 0;\\n        \\n\\t\\t//------Iterating to get the count and small elements\\n        for(auto e : nums){\\n            if(e==target){\\n                count++;\\n            }\\n            else if(e<target){\\n                small++;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//-------generating the answer vector\\n        for(int i=0; i<count; i++){\\n            ans.push_back(small+i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519861,
                "title": "2089-find-target-indices-after-sorting-array-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                arr.add(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                arr.add(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091493,
                "title": "java-using-binary-search-basic",
                "content": "```\\npublic void helper(int[] nums, int start, int end, int target, List<Integer> list){\\n        if(start > end) return;\\n        int mid = (start + end)/2;\\n        if(nums[mid] == target){\\n            list.add(mid);\\n        }\\n        helper(nums, start, mid-1, target, list);\\n        helper(nums, mid+1, end, target, list);\\n    }\\n    \\npublic List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        helper(nums, 0, nums.length-1, target, list);\\n        Collections.sort(list);\\n        return list;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic void helper(int[] nums, int start, int end, int target, List<Integer> list){\\n        if(start > end) return;\\n        int mid = (start + end)/2;\\n        if(nums[mid] == target){\\n            list.add(mid);\\n        }\\n        helper(nums, start, mid-1, target, list);\\n        helper(nums, mid+1, end, target, list);\\n    }\\n    \\npublic List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        helper(nums, 0, nums.length-1, target, list);\\n        Collections.sort(list);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826210,
                "title": "c-o-n-without-sorting",
                "content": "We do not need to sort the array - we can just count elements smaller (`ind`) than the target.\\n`cnt` is storing number of time target element is present.\\n\\n\\n**C++**\\n```\\nvector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int ind=0,cnt=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<target)ind++;\\n            else if(nums[i]==target)cnt++;\\n        }\\n        \\n        while(cnt--){\\n            ans.push_back(ind);\\n            ind++;\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nvector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int ind=0,cnt=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<target)ind++;\\n            else if(nums[i]==target)cnt++;\\n        }\\n        \\n        while(cnt--){\\n            ans.push_back(ind);\\n            ind++;\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1800686,
                "title": "c-explained-binary-search-approach",
                "content": "Kindly **upvote** if you find it helpful **: )**\\n```\\nclass Solution {\\npublic:\\n    //separate function to calculate first occurence of target using binary search\\n    int firstOccurence(vector<int>& nums, int k){\\n        int s = 0, e = nums.size()-1;\\n        int m = s + (e-s)/2;\\n        int ans = -1; // if target not found in the given array then function will return -1\\n        while(s<=e){\\n            if(nums[m]==k){\\n                ans = m;\\n                e = m-1;\\n            }\\n            else if(nums[m]<k){\\n                s = m+1;\\n            }\\n            else if(nums[m]>k){\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    //separate function to calculate last occurence of target using binary search\\n    int lastOccurence(vector<int>& nums, int k){\\n        int s = 0, e = nums.size()-1;\\n        int m = s + (e-s)/2;\\n        int ans = -1; // if target not found in the given array then function will return -1\\n        while(s<=e){\\n            if(nums[m]==k){\\n                ans = m;\\n                s = m+1;\\n            }\\n            else if(nums[m]<k){\\n                s = m+1;\\n            }\\n            else if(nums[m]>k){\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans; // creating ans vector for storing target indices\\n        sort(nums.begin(),nums.end()); // sorting given vector array\\n        \\n        int first = firstOccurence(nums,target); \\n        int last = lastOccurence(nums,target);\\n        \\n        if(first != -1 && last != -1){ // check if target is found \\n            for(int i=first; i<=last; i++){ // iterate from first to last and push all the indices in ans vector\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //separate function to calculate first occurence of target using binary search\\n    int firstOccurence(vector<int>& nums, int k){\\n        int s = 0, e = nums.size()-1;\\n        int m = s + (e-s)/2;\\n        int ans = -1; // if target not found in the given array then function will return -1\\n        while(s<=e){\\n            if(nums[m]==k){\\n                ans = m;\\n                e = m-1;\\n            }\\n            else if(nums[m]<k){\\n                s = m+1;\\n            }\\n            else if(nums[m]>k){\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    //separate function to calculate last occurence of target using binary search\\n    int lastOccurence(vector<int>& nums, int k){\\n        int s = 0, e = nums.size()-1;\\n        int m = s + (e-s)/2;\\n        int ans = -1; // if target not found in the given array then function will return -1\\n        while(s<=e){\\n            if(nums[m]==k){\\n                ans = m;\\n                s = m+1;\\n            }\\n            else if(nums[m]<k){\\n                s = m+1;\\n            }\\n            else if(nums[m]>k){\\n                e = m-1;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans; // creating ans vector for storing target indices\\n        sort(nums.begin(),nums.end()); // sorting given vector array\\n        \\n        int first = firstOccurence(nums,target); \\n        int last = lastOccurence(nums,target);\\n        \\n        if(first != -1 && last != -1){ // check if target is found \\n            for(int i=first; i<=last; i++){ // iterate from first to last and push all the indices in ans vector\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680898,
                "title": "simple-python-beats-100-spead-modified-binary-search",
                "content": "i used modified version of binary search to find both first and last occurence of the target\\nstarting from low, high equals start and end of the list, but then i noticed in the second trial we don\\'t need to scan the whole array to get the last occurence, and made l = start\\n\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l = 0\\n        r = len(nums) -1\\n        nums.sort()\\n        # print(nums)\\n        start,end=-1,-1\\n\\n        # first \\n        while (l <=r):\\n            m = (l+r)//2\\n            \\n            if (target== nums[m]):\\n                start=m\\n                r = m-1\\n                \\n            if target > nums[m]:\\n                l = m+1\\n            \\n            elif target < nums[m]:\\n                r = m-1\\n        \\n        # last\\n        l,r=start,len(nums)-1\\n        while (l <=r):\\n            m = (l+r)//2\\n            \\n            if (target== nums[m]):\\n                end=m\\n                l = m+1\\n                \\n            if target > nums[m]:\\n                l = m+1\\n            \\n            elif target < nums[m]:\\n                r = m-1\\n        \\n        \\n        # print(start,end)\\n        if start==end==-1:\\n            return []\\n        else:\\n            res = list(range(start,end+1))\\n            return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        l = 0\\n        r = len(nums) -1\\n        nums.sort()\\n        # print(nums)\\n        start,end=-1,-1\\n\\n        # first \\n        while (l <=r):\\n            m = (l+r)//2\\n            \\n            if (target== nums[m]):\\n                start=m\\n                r = m-1\\n                \\n            if target > nums[m]:\\n                l = m+1\\n            \\n            elif target < nums[m]:\\n                r = m-1\\n        \\n        # last\\n        l,r=start,len(nums)-1\\n        while (l <=r):\\n            m = (l+r)//2\\n            \\n            if (target== nums[m]):\\n                end=m\\n                l = m+1\\n                \\n            if target > nums[m]:\\n                l = m+1\\n            \\n            elif target < nums[m]:\\n                r = m-1\\n        \\n        \\n        # print(start,end)\\n        if start==end==-1:\\n            return []\\n        else:\\n            res = list(range(start,end+1))\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678973,
                "title": "javascript-o-n",
                "content": "```\\nvar targetIndices = function(nums, target) {\\n    let lownums=repeat=0;\\n    for(i=0;i<nums.length;i++){\\n        if(nums[i]<target){\\n            lownums++;\\n            }\\n        if(nums[i]==target){\\n            repeat++}\\n    }\\n    let arr=[];\\n\\t\\n     if(repeat<1){\\n         return arr;\\n     }\\n   else{\\n    for(i=0;i<repeat;i++){\\n       arr.push(lownums+i)\\n    }\\n    return arr;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar targetIndices = function(nums, target) {\\n    let lownums=repeat=0;\\n    for(i=0;i<nums.length;i++){\\n        if(nums[i]<target){\\n            lownums++;\\n            }\\n        if(nums[i]==target){\\n            repeat++}\\n    }\\n    let arr=[];\\n\\t\\n     if(repeat<1){\\n         return arr;\\n     }\\n   else{\\n    for(i=0;i<repeat;i++){\\n       arr.push(lownums+i)\\n    }\\n    return arr;\\n    }\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669338,
                "title": "java-two-approaches",
                "content": "*Approach 1*\\n\\n**Time Complexity** : O(nlogn)\\n**Space Complexity** :  [> O(1) ] [https://stackoverflow.com/questions/22571586/will-arrays-sort-increase-time-complexity-and-space-time-complexity](http://)\\n ```\\n class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0;i < nums.length;i++) {\\n            if(nums[i] == target) {\\n                result.add(i);\\n            }            \\n        }\\n        return result;\\n    }\\n}\\n ```\\n \\n *Approach 2*\\n \\n **Time Complexity** : O(n)\\n **Space Complexity**: O(1)\\n \\n ```\\n class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer>result = new ArrayList<>();\\n        int number_of_targets = 0;\\n        int less_than_target_values = 0;\\n        for(int i : nums) {\\n            if(i < target) {\\n                less_than_target_values++;\\n            }\\n            else if(i == target) {\\n                number_of_targets++;\\n            }\\n        }\\n        while(number_of_targets > 0) {\\n            result.add(less_than_target_values);\\n            less_than_target_values++;\\n            number_of_targets--;\\n        }\\n        return result;\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0;i < nums.length;i++) {\\n            if(nums[i] == target) {\\n                result.add(i);\\n            }            \\n        }\\n        return result;\\n    }\\n}\\n ```\n```\\n class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer>result = new ArrayList<>();\\n        int number_of_targets = 0;\\n        int less_than_target_values = 0;\\n        for(int i : nums) {\\n            if(i < target) {\\n                less_than_target_values++;\\n            }\\n            else if(i == target) {\\n                number_of_targets++;\\n            }\\n        }\\n        while(number_of_targets > 0) {\\n            result.add(less_than_target_values);\\n            less_than_target_values++;\\n            number_of_targets--;\\n        }\\n        return result;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1642010,
                "title": "java-0-ms-simple",
                "content": "\\n**T/S:** O(n)/O(1)\\n* Ignoring space for output\\n* Count frequency of target and number of numbers smaller than target\\n* Create a list of indices based on the above calculation\\n```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n\\tvar targetCount = 0;\\n\\tvar smallerCount = 0;\\n\\n\\tfor (var num : nums)\\n\\t\\tif (num == target)\\n\\t\\t\\ttargetCount++;\\n\\t\\telse if (num < target)\\n\\t\\t\\tsmallerCount++;\\n\\n\\tvar targets = new ArrayList<Integer>();\\n\\tfor (var i = smallerCount; i < targetCount + smallerCount; i++)\\n\\t\\ttargets.add(i);\\n\\treturn targets;\\n}\\n```\\n**Variation 2:** Same idea using Streams\\n```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n\\tvar targetCount = 0;\\n\\tvar smallerCount = 0;\\n\\t\\n\\tfor (var num : nums)\\n\\t\\tif (num == target)\\n\\t\\t\\ttargetCount++;\\n\\t\\telse if (num < target)\\n\\t\\t\\tsmallerCount++;\\n\\n\\treturn IntStream.range(smallerCount, targetCount + smallerCount)\\n\\t\\t\\t\\t\\t.boxed()\\n\\t\\t\\t\\t\\t.collect(Collectors.toCollection(ArrayList::new));\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n\\tvar targetCount = 0;\\n\\tvar smallerCount = 0;\\n\\n\\tfor (var num : nums)\\n\\t\\tif (num == target)\\n\\t\\t\\ttargetCount++;\\n\\t\\telse if (num < target)\\n\\t\\t\\tsmallerCount++;\\n\\n\\tvar targets = new ArrayList<Integer>();\\n\\tfor (var i = smallerCount; i < targetCount + smallerCount; i++)\\n\\t\\ttargets.add(i);\\n\\treturn targets;\\n}\\n```\n```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n\\tvar targetCount = 0;\\n\\tvar smallerCount = 0;\\n\\t\\n\\tfor (var num : nums)\\n\\t\\tif (num == target)\\n\\t\\t\\ttargetCount++;\\n\\t\\telse if (num < target)\\n\\t\\t\\tsmallerCount++;\\n\\n\\treturn IntStream.range(smallerCount, targetCount + smallerCount)\\n\\t\\t\\t\\t\\t.boxed()\\n\\t\\t\\t\\t\\t.collect(Collectors.toCollection(ArrayList::new));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621639,
                "title": "o-n-simple-python-solution",
                "content": "Some observations about the problem:\\n\\n1. We do not need to sort the array since we only have to find the index of target element if it were in a sorted array. This is nothing but the number of elements that are less than the target. Let number of such elements be ` lt_ct`. Then `lt_ct+1` would be the next element and `lt_ct+1-1= lt_ct` since its zero indexed\\n\\n2. if there more than 1 elements equal to target (say `ct` times), the resultant array will have consecutive elements with length equal to `ct` which cab be generated using `range` function\\n\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lt_ct, ct=0, 0\\n\\t\\t\\n        for i in nums:\\n            if i < target:  lt_ct+=1\\n            elif i == target: ct+=1\\n        \\n        res=list(range(lt_ct,lt_ct+ct))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lt_ct, ct=0, 0\\n\\t\\t\\n        for i in nums:\\n            if i < target:  lt_ct+=1\\n            elif i == target: ct+=1\\n        \\n        res=list(range(lt_ct,lt_ct+ct))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614538,
                "title": "python-one-liner",
                "content": "```return list(filter(lambda x: (x != -1),[[-1,i][sorted(nums)[i] == target] for i in range(len(nums))]))```",
                "solutionTags": [],
                "code": "```return list(filter(lambda x: (x != -1),[[-1,i][sorted(nums)[i] == target] for i in range(len(nums))]))```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599978,
                "title": "python3-short-o-n-solution-2-liners-numpy-1-liner",
                "content": "Just simply count how many elements are less than the target and you will get the lowest index for target element. Then rest of it should be straightforward.\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        cnt_smaller = 0\\n        cnt_equal = 0\\n        for x in nums:\\n            if x < target:\\n                cnt_smaller += 1\\n            elif x == target:\\n                cnt_equal += 1\\n        return range(cnt_smaller, cnt_smaller + cnt_equal)\\n```\\n\\n2-Liners version (by @stefan4trivia aka @StefanPochmann):\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        smaller = sum(map(target.__gt__, nums))\\n        return islice(count(smaller), nums.count(target))\\n```\\n\\nShorter 1-Liner O(N log N) version (also by @stefan4trivia aka @StefanPochmann):\\n```\\nimport numpy as np\\n\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        return np.where(np.sort(nums) == target)[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        cnt_smaller = 0\\n        cnt_equal = 0\\n        for x in nums:\\n            if x < target:\\n                cnt_smaller += 1\\n            elif x == target:\\n                cnt_equal += 1\\n        return range(cnt_smaller, cnt_smaller + cnt_equal)\\n```\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        smaller = sum(map(target.__gt__, nums))\\n        return islice(count(smaller), nums.count(target))\\n```\n```\\nimport numpy as np\\n\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        return np.where(np.sort(nums) == target)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849373,
                "title": "no-searching-no-sorting-beats-100",
                "content": "# Intuition\\nwe dont need actual indices, we dont care about sequence or order so we don\\'t need sort.\\nbinary search \\n# Approach\\nJust count number of elements which are less than or equal to given target. say lessThanOrEqualCount\\nThen count number of elements which are strictly less than given target onlyLessThanCount\\n\\nif lessThanOrEqualCount = onlyLessThanCount: return empty\\nor else all numbers between them\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity: O(1)\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanEqual = 0\\n        onlyLess = 0\\n        for i in nums:\\n            if i <= target:\\n                lessThanEqual += 1\\n            if i < target:\\n                onlyLess += 1\\n        return list(range(onlyLess, lessThanEqual))\\n```\\n\\nPlease upvote if you like the solution.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanEqual = 0\\n        onlyLess = 0\\n        for i in nums:\\n            if i <= target:\\n                lessThanEqual += 1\\n            if i < target:\\n                onlyLess += 1\\n        return list(range(onlyLess, lessThanEqual))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712356,
                "title": "find-target-indices-after-sorting-array-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList <Integer> arr = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == target){\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList <Integer> arr = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == target){\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528470,
                "title": "using-upper-bound-and-lower-bound-weird-way-xd",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(begin(nums), end(nums));\\n        int lb = lower_bound(begin(nums), end(nums), target) - begin(nums);\\n        int ub = upper_bound(begin(nums)+lb, end(nums), target) - begin(nums);\\n\\n        if (lb == ub) return {};\\n\\n        vector<int> ans;\\n        while (lb < ub) ans.push_back(lb++);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(begin(nums), end(nums));\\n        int lb = lower_bound(begin(nums), end(nums), target) - begin(nums);\\n        int ub = upper_bound(begin(nums)+lb, end(nums), target) - begin(nums);\\n\\n        if (lb == ub) return {};\\n\\n        vector<int> ans;\\n        while (lb < ub) ans.push_back(lb++);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469602,
                "title": "solution-in-java-using-binary-search",
                "content": "\\n\\n\\n# Approach. \\nPure binary search approch\\n<!-- Describe your approach to solving the problem. -->\\n1)sort the array.     O(n logn )  \\n2)find out left most occurance of target element.  O(logn)\\n3)fing out right most occurance of target element.  0(logn)\\n4)now from leftmost to rightindex traverse and add target element that number of times. 0(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\nList<Integer> out=new ArrayList<>();\\n\\nint low=0;\\nint high=nums.length-1;\\nint ansl=-1;\\nwhile(low<=high)\\n{\\nint mid=(low+high)/2;\\nif(nums[mid]==target)\\n{\\n    ansl=mid;\\n    high=mid-1;\\n}else if(nums[mid]>target)\\n{\\n    high=mid-1;\\n}else{\\n    low=mid+1;\\n}\\n\\n}\\n\\n low=0;\\n high=nums.length-1;\\nint ansr=-1;\\nwhile(low<=high)\\n{\\nint mid=(low+high)/2;\\nif(nums[mid]==target)\\n{\\n    ansr=mid;\\n    low=mid+1;\\n}else if(nums[mid]>target)\\n{\\n    high=mid-1;\\n}else{\\n    low=mid+1;\\n}\\n\\n}\\nif(ansl==-1)\\n{\\n    return out;\\n}\\nfor(int i=ansl;i<=ansr;i++)\\n{\\n    out.add(i);\\n}\\n\\n\\nreturn out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\nList<Integer> out=new ArrayList<>();\\n\\nint low=0;\\nint high=nums.length-1;\\nint ansl=-1;\\nwhile(low<=high)\\n{\\nint mid=(low+high)/2;\\nif(nums[mid]==target)\\n{\\n    ansl=mid;\\n    high=mid-1;\\n}else if(nums[mid]>target)\\n{\\n    high=mid-1;\\n}else{\\n    low=mid+1;\\n}\\n\\n}\\n\\n low=0;\\n high=nums.length-1;\\nint ansr=-1;\\nwhile(low<=high)\\n{\\nint mid=(low+high)/2;\\nif(nums[mid]==target)\\n{\\n    ansr=mid;\\n    low=mid+1;\\n}else if(nums[mid]>target)\\n{\\n    high=mid-1;\\n}else{\\n    low=mid+1;\\n}\\n\\n}\\nif(ansl==-1)\\n{\\n    return out;\\n}\\nfor(int i=ansl;i<=ansr;i++)\\n{\\n    out.add(i);\\n}\\n\\n\\nreturn out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467724,
                "title": "c-simple-solution-linear-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nYou can also use binary search but time complexity would be same because of sort function used above.\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\nvector<int> s;\\n    sort(nums.begin(),nums.end());\\n      for(int i=0;i<nums.size();i++){\\n if(nums[i]>target){\\n          break;\\n      }\\n      if(nums[i]==target){\\n          s.push_back(i);\\n      }\\n     \\n      }  \\n    \\n   return s; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\nvector<int> s;\\n    sort(nums.begin(),nums.end());\\n      for(int i=0;i<nums.size();i++){\\n if(nums[i]>target){\\n          break;\\n      }\\n      if(nums[i]==target){\\n          s.push_back(i);\\n      }\\n     \\n      }  \\n    \\n   return s; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411441,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        // int n = nums.size();\\n        // for(int i=0;i<n-1;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         if(nums[i]>nums[j]){\\n        //             int temp = nums[i];\\n        //             nums[i]=nums[j];\\n        //             nums[j]=temp;\\n        //         }\\n        //     }\\n        // }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        // int n = nums.size();\\n        // for(int i=0;i<n-1;i++){\\n        //     for(int j=i+1;j<n;j++){\\n        //         if(nums[i]>nums[j]){\\n        //             int temp = nums[i];\\n        //             nums[i]=nums[j];\\n        //             nums[j]=temp;\\n        //         }\\n        //     }\\n        // }\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285597,
                "title": "easiest-solution-in-python-u-will-ever-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        nums.sort()\\n        index1=bisect.bisect_left(nums,target)\\n        index2=bisect.bisect_right(nums,target)\\n        return list(range(index1,index2))\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        nums.sort()\\n        index1=bisect.bisect_left(nums,target)\\n        index2=bisect.bisect_right(nums,target)\\n        return list(range(index1,index2))\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285010,
                "title": "simple-5-lines-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)-->since sorting is used\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                res.append(i)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                res.append(i)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276036,
                "title": "javascript-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    \\n    let res = []\\n    let minus = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i]<target){\\n            minus++;\\n        }\\n        if(nums[i]===target){\\n            res.push(0)\\n        }\\n    }\\n    return res.map((e, i)=>minus+i)\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    \\n    let res = []\\n    let minus = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        if(nums[i]<target){\\n            minus++;\\n        }\\n        if(nums[i]===target){\\n            res.push(0)\\n        }\\n    }\\n    return res.map((e, i)=>minus+i)\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216683,
                "title": "best-5-lines-of-code-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135958,
                "title": "lower-and-upper-bound-o-1-space-complexity-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust sort and consider the lower and upper bound of the target and then clear the given vector and pushback the values from lowerbound of the target to the upper bound of the target to get the indices.\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int lb = lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ub = upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        nums.clear();\\n        for(int i=lb;i<ub;i++) nums.push_back(i);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int lb = lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ub = upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        nums.clear();\\n        for(int i=lb;i<ub;i++) nums.push_back(i);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127091,
                "title": "c-beats-94-beginner-friendly",
                "content": "# Brute Force Solution \\n```\\nclass Solution \\n{\\n    public:\\n        vector<int> targetIndices(vector<int>& nums, int target) \\n        {\\n            sort(nums.begin(), nums.end()); // first Sort the vector\\n            \\n            int N = nums.size();\\n            vector<int> v;\\n\\n            // find the target element by traversing the loop and push the index in the vector\\n            for(int i=0; i<N; i++)\\n            {\\n                if(nums[i] == target) \\n                {\\n                    v.push_back(i);\\n                }\\n            }\\n            return v;\\n        }\\n};\\n```\\n\\n# Using Binary Search \\n\\n```\\nclass Solution \\n{\\n    public:\\n        vector<int> targetIndices(vector<int>& nums, int target) \\n        {\\n            sort(nums.begin(), nums.end());\\n            \\n            vector<int> v;\\n            \\n            int first = occurance(nums, target, true); // find the first Occurrence of the element\\n            int last = occurance(nums, target, false); // find the last Occurrence of the element\\n            \\n            if(first == -1 && last == -1)\\n            {\\n                return {};\\n            }\\n            \\n            for(int i=first; i<=last; i++)\\n            {\\n                v.push_back(i);\\n            }\\n            return v;\\n        }\\n    \\n        int occurance(vector<int>& nums, int target, bool isTrue)\\n        {\\n            int low = 0;\\n            int high = nums.size()-1;\\n            int ans = -1;\\n            \\n            while(low <= high)\\n            {\\n                int mid = low + ((high-low)/2);\\n                \\n                if(nums[mid] == target)\\n                {\\n                    ans = mid;\\n                    if(isTrue)\\n                    {\\n                        high = mid - 1;\\n                    }\\n                    else\\n                    {\\n                        low = mid + 1;\\n                    }   \\n                }\\n                else if(nums[mid] > target)\\n                {\\n                    high = mid - 1;\\n                }\\n                else\\n                {\\n                    low = mid + 1;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n        vector<int> targetIndices(vector<int>& nums, int target) \\n        {\\n            sort(nums.begin(), nums.end()); // first Sort the vector\\n            \\n            int N = nums.size();\\n            vector<int> v;\\n\\n            // find the target element by traversing the loop and push the index in the vector\\n            for(int i=0; i<N; i++)\\n            {\\n                if(nums[i] == target) \\n                {\\n                    v.push_back(i);\\n                }\\n            }\\n            return v;\\n        }\\n};\\n```\n```\\nclass Solution \\n{\\n    public:\\n        vector<int> targetIndices(vector<int>& nums, int target) \\n        {\\n            sort(nums.begin(), nums.end());\\n            \\n            vector<int> v;\\n            \\n            int first = occurance(nums, target, true); // find the first Occurrence of the element\\n            int last = occurance(nums, target, false); // find the last Occurrence of the element\\n            \\n            if(first == -1 && last == -1)\\n            {\\n                return {};\\n            }\\n            \\n            for(int i=first; i<=last; i++)\\n            {\\n                v.push_back(i);\\n            }\\n            return v;\\n        }\\n    \\n        int occurance(vector<int>& nums, int target, bool isTrue)\\n        {\\n            int low = 0;\\n            int high = nums.size()-1;\\n            int ans = -1;\\n            \\n            while(low <= high)\\n            {\\n                int mid = low + ((high-low)/2);\\n                \\n                if(nums[mid] == target)\\n                {\\n                    ans = mid;\\n                    if(isTrue)\\n                    {\\n                        high = mid - 1;\\n                    }\\n                    else\\n                    {\\n                        low = mid + 1;\\n                    }   \\n                }\\n                else if(nums[mid] > target)\\n                {\\n                    high = mid - 1;\\n                }\\n                else\\n                {\\n                    low = mid + 1;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021330,
                "title": "without-sorting-o-n-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve it without sorting the list :\\n\\n**Fisrt :** count the number of elements that are less than target (`lessThanTarget`) .\\n**Second :** count the frequency of target (`equalsToTarget` ).\\n\\nFor Example : \\n`nums = [1,2,4,2,4,6], target = 4`\\nTherefore `lessThanTarget = 3`  and  `equalsToTarget = 2`.\\n\\nSo now, we know the starting index of the target elements. It will be `lessThanTarget` (Because `nums` starting with index `0`) and then we will **keep track of pushing `i` into vector** till `lessThanTarget + equalsToTarget`.\\n\\n\\n# Complexity\\n- **Time complexity:** o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> findIndexes(vector<int>& nums, int ind , int target)\\n    {\\n        int lessThanTarget = 0;\\n        int equalsToTarget = 0 ;\\n        vector<int> indexes;\\n\\n        for(int i = 0 ; i<nums.size() ; i++)\\n        {\\n            if (nums[i]<target)\\n            lessThanTarget++;\\n            else if (nums[i]==target)\\n            equalsToTarget++;\\n        }\\n\\n\\n        int size = equalsToTarget + lessThanTarget ;\\n\\n        for(int i = lessThanTarget ; i<size ; i++)\\n        indexes.push_back(i);\\n\\n        return indexes;\\n \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> findIndexes(vector<int>& nums, int ind , int target)\\n    {\\n        int lessThanTarget = 0;\\n        int equalsToTarget = 0 ;\\n        vector<int> indexes;\\n\\n        for(int i = 0 ; i<nums.size() ; i++)\\n        {\\n            if (nums[i]<target)\\n            lessThanTarget++;\\n            else if (nums[i]==target)\\n            equalsToTarget++;\\n        }\\n\\n\\n        int size = equalsToTarget + lessThanTarget ;\\n\\n        for(int i = lessThanTarget ; i<size ; i++)\\n        indexes.push_back(i);\\n\\n        return indexes;\\n \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018874,
                "title": "simple-solution-on-swift",
                "content": "# Code\\n```\\nclass Solution {\\n    func targetIndices(_ nums: [Int], _ target: Int) -> [Int] {\\n        var result = [Int]()\\n        for (index, item) in nums.sorted().enumerated() where item == target {\\n            result.append(index)\\n        }\\n        return result\\n    }\\n}\\n```\\n### Please upvote if you found the solution useful!",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func targetIndices(_ nums: [Int], _ target: Int) -> [Int] {\\n        var result = [Int]()\\n        for (index, item) in nums.sorted().enumerated() where item == target {\\n            result.append(index)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773394,
                "title": "simple-solution-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def targetIndices(self, N: List[int], T: int) -> List[int]:\\n        c = i = 0\\n        for n in N:\\n            if n < T: i += 1\\n            elif n == T: c += 1\\n        return range(i, i+c)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, N: List[int], T: int) -> List[int]:\\n        c = i = 0\\n        for n in N:\\n            if n < T: i += 1\\n            elif n == T: c += 1\\n        return range(i, i+c)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748570,
                "title": "binary-search-java",
                "content": "Runtime: 2 ms, faster than 85.29% of Java online submissions for Find Target Indices After Sorting Array.\\nMemory Usage: 42.5 MB, less than 87.82% of Java online submissions for Find Target Indices After Sorting Array.\\n\"\\'\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        int f = 0;\\n        int l = nums.length-1;\\n        int mid = 0;\\n        while(f <= l){\\n            mid = f+(l-f)/2;\\n            \\n            \\n            if(target > nums[mid]){\\n                f = mid + 1;\\n            }\\n            else if(target < nums[mid]){\\n                l = mid - 1;\\n            }\\n            else{\\n                int first = mid;\\n                int last = mid;\\n                while(first-1 >= 0 && nums[first-1]==target){\\n                    first--;\\n                }\\n                while(last+1 < nums.length  && nums[last+1]==target){\\n                    last++;\\n                }\\n                for(int i = first; i <= last; i++){\\n                    list.add(i);\\n                }\\n                 return list;\\n                \\n            }\\n            \\n            \\n        }\\n        return list;\\n       \\n        \\n    }\\n}\\n\"\"",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        int f = 0;\\n        int l = nums.length-1;\\n        int mid = 0;\\n        while(f <= l){\\n            mid = f+(l-f)/2;\\n            \\n            \\n            if(target > nums[mid]){\\n                f = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2642889,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n\\n// finding first occurrence of the target\\n\\n    int firstOccu(vector<int> nums,int target){\\n        int n=nums.size();\\n        int start=0,end=n-1;\\n        int res=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                res=mid;\\n                end=mid-1;\\n            }\\n            else if(nums[mid]>target) end=mid-1;\\n            else start=mid+1;\\n        }\\n        return res;\\n    }\\n    \\n// finding last occurrence of the target\\n\\t\\n    int LastOccu(vector<int> nums,int target){\\n        int n=nums.size();\\n        int start=0,end=n-1;\\n        int res=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                res=mid;\\n                start=mid+1;\\n            }\\n            else if(nums[mid]>target) end=mid-1;\\n            else start=mid+1;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> targetIndices(vector<int>& nums, int target){\\n\\t\\n        sort(nums.begin(),nums.end());\\n        int first=firstOccu(nums,target);\\n        int last=LastOccu(nums,target);\\n\\t\\t\\n        vector<int> ans;\\n\\t\\t\\n        if(first!=-1 && last!=-1){\\n            for(int i=first;i<=last;i++){   // storing all indexes between first and last occurence\\n                ans.push_back(i);\\n            }\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n// finding first occurrence of the target\\n\\n    int firstOccu(vector<int> nums,int target){\\n        int n=nums.size();\\n        int start=0,end=n-1;\\n        int res=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                res=mid;\\n                end=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2587715,
                "title": "c-o-n-logn-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    int firstOcc(vector<int>nums,int target){\\n        \\n        int ans=-1;\\n        int s=0,e=nums.size()-1;\\n        int mid=s+(e-s)/2;\\n        \\n        while(s<=e)\\n        {\\n            if(nums[mid]==target)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            \\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            \\n            else{\\n                s=mid+1;\\n            }\\n            \\n            mid=s+(e-s)/2;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int lastOcc(vector<int>nums,int target){\\n        \\n        int ans=-1;\\n        int s=0,e=nums.size()-1;\\n        int mid=s+(e-s)/2;\\n        \\n        while(s<=e)\\n        {\\n            if(nums[mid]==target)\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            \\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            \\n            else{\\n                s=mid+1;\\n            }\\n            \\n            mid=s+(e-s)/2;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n   \\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        if(nums.size() <= 0)\\n            return {};\\n        \\n        vector<int>Res;\\n        int start=firstOcc(nums,target);\\n        int end=lastOcc(nums,target);\\n        \\n        if(start == -1 && end == -1)\\n            return {};\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            Res.push_back(i);\\n        }\\n        \\n        return Res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int firstOcc(vector<int>nums,int target){\\n        \\n        int ans=-1;\\n        int s=0,e=nums.size()-1;\\n        int mid=s+(e-s)/2;\\n        \\n        while(s<=e)\\n        {\\n            if(nums[mid]==target)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2563037,
                "title": "count-smaller-and-equal-simple-java-code",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n       int less = 0;\\n        int equal = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<target){\\n                less++;\\n            }else if(nums[i]==target){\\n                equal++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<Integer>();\\n        for(int i=0; i<equal; i++){\\n            ans.add(less);\\n            less++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n       int less = 0;\\n        int equal = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<target){\\n                less++;\\n            }else if(nums[i]==target){\\n                equal++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<Integer>();\\n        for(int i=0; i<equal; i++){\\n            ans.add(less);\\n            less++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296188,
                "title": "c-faster-than-96-people",
                "content": "Runtime: 3 ms, faster than 95.55% of C++ online submissions for Find Target Indices After Sorting Array.\\nMemory Usage: 12 MB, less than 15.50% of C++ online submissions for Find Target Indices After Sorting Array.\\n```\\nclass Solution {\\nprivate:\\n    int leftOccurence(vector<int>nums, int target) {\\n    int s = 0;\\n    int e = nums.size()-1;\\n    int ansL = -1;\\n    int mid = s+(e-s)/2;\\n    while(s<=e) {\\n        if(nums[mid]==target) {\\n            ansL = mid;\\n            e = mid-1;\\n        }\\n        \\n        else if(nums[mid]<target) {\\n            s = mid+1;\\n        }\\n        \\n        else {\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    }\\n        return ansL;\\n}\\n    int rightOccurence(vector<int>nums, int target) {\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int ansR = -1;\\n        int mid = s+(e-s)/2;\\n        while(s<=e) {\\n            if(nums[mid]==target) {\\n                ansR = mid;\\n                s = mid+1;\\n            }\\n            \\n            else if(nums[mid]<target) {\\n                s = mid+1;\\n            }\\n            \\n            else {\\n                e = mid-1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return ansR;\\n    }\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<int>v;\\n        int ansL = leftOccurence(nums, target);\\n        int ansR = rightOccurence(nums, target);\\n        if(ansL==-1 and ansR==-1) {\\n            return {};\\n        }\\n        for(int i=ansL;i<=ansR;i++) {\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nIf you like please upvote and for any query, do like and comment",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int leftOccurence(vector<int>nums, int target) {\\n    int s = 0;\\n    int e = nums.size()-1;\\n    int ansL = -1;\\n    int mid = s+(e-s)/2;\\n    while(s<=e) {\\n        if(nums[mid]==target) {\\n            ansL = mid;\\n            e = mid-1;\\n        }\\n        \\n        else if(nums[mid]<target) {\\n            s = mid+1;\\n        }\\n        \\n        else {\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    }\\n        return ansL;\\n}\\n    int rightOccurence(vector<int>nums, int target) {\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int ansR = -1;\\n        int mid = s+(e-s)/2;\\n        while(s<=e) {\\n            if(nums[mid]==target) {\\n                ansR = mid;\\n                s = mid+1;\\n            }\\n            \\n            else if(nums[mid]<target) {\\n                s = mid+1;\\n            }\\n            \\n            else {\\n                e = mid-1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return ansR;\\n    }\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<int>v;\\n        int ansL = leftOccurence(nums, target);\\n        int ansR = rightOccurence(nums, target);\\n        if(ansL==-1 and ansR==-1) {\\n            return {};\\n        }\\n        for(int i=ansL;i<=ansR;i++) {\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287275,
                "title": "java-1ms-o-n-beats-99-59-without-sorting",
                "content": "[https://leetcode.com/submissions/detail/747986331/](https://leetcode.com/submissions/detail/747986331/)\\n\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> res = new LinkedList<>();\\n        int smaller = 0;\\n        int equal = 0;\\n        int val;\\n        for(int i = 0; i< nums.length; i++) {\\n            val = nums[i];\\n            if(target == val) {\\n                equal += 1;\\n            } else if(val < target) {\\n                smaller += 1;\\n            }\\n        }\\n        int i = 0;\\n        while (i < equal) {\\n            res.add(smaller++);\\n            i += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> res = new LinkedList<>();\\n        int smaller = 0;\\n        int equal = 0;\\n        int val;\\n        for(int i = 0; i< nums.length; i++) {\\n            val = nums[i];\\n            if(target == val) {\\n                equal += 1;\\n            } else if(val < target) {\\n                smaller += 1;\\n            }\\n        }\\n        int i = 0;\\n        while (i < equal) {\\n            res.add(smaller++);\\n            i += 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228021,
                "title": "java-most-efficient-self-explanatory-solution-upvote-to-reach-everyone",
                "content": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        \\n        int lc = 0;\\n        int cc = 0;\\n        \\n        for(int num : nums){\\n            if(num<target){\\n                lc++;\\n            }else if(num == target)\\n            {\\n                cc++;\\n            }        \\n        }\\n        \\n        \\n        List<Integer> pos = new ArrayList<>();\\n        while(cc-->0){\\n            pos.add(lc++);\\n        }\\n        \\n        return pos;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        \\n        int lc = 0;\\n        int cc = 0;\\n        \\n        for(int num : nums){\\n            if(num<target){\\n                lc++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2213166,
                "title": "find-target-indices-after-sorting-array-c-binary-search",
                "content": "This question is similar to last and first occurrence of given number in an array.\\nI sorted the array initially to make my task easier.\\nI created two functions one for getting the first occurence of the target and another for getting the last occurence of the target.\\nAfter getting first and last occurence, I traversed the sorted array from first occurence to lastoccurence(inclusive) and store all indices.\\n\\n**TC==>O(nlogn)+O(2logn)+O(lastoccurence-firstoccurence) = O(nlogn)\\n O(nlogn) => For sorting the array\\n O(2logn) => For applying Binary search two times\\n O(lastoccurence-firstoccurence) => For traversing indices of target\\nSC==>O(lastoccurence-firstoccurence)**\\n```\\nclass Solution {\\npublic:\\n    int BSF(vector<int>nums,int low,int high,int target)\\n    {\\n        int ans = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int BSL(vector<int>nums,int low,int high,int target)\\n    {\\n        int ans = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n            {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n-1;\\n        vector<int>res;\\n\\t\\t//Calling Binary search function for last occurence\\n        int lastoccur = BSL(nums,low,high,target);\\n\\t\\t//Calling Binary search function for first occurence\\n        int firstoccur = BSF(nums,low,high,target);\\n\\t\\t//If the target is not present then it means it\\'s first occurence is -1. So we have to return empty array.\\n        if(firstoccur<0)\\n            return res;\\n        for(int i=firstoccur;i<=lastoccur;i++)\\n        {\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you understand the approach and code, then please upvote this post!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BSF(vector<int>nums,int low,int high,int target)\\n    {\\n        int ans = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int BSL(vector<int>nums,int low,int high,int target)\\n    {\\n        int ans = -1;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]==target)\\n            {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int low = 0;\\n        int high = n-1;\\n        vector<int>res;\\n\\t\\t//Calling Binary search function for last occurence\\n        int lastoccur = BSL(nums,low,high,target);\\n\\t\\t//Calling Binary search function for first occurence\\n        int firstoccur = BSF(nums,low,high,target);\\n\\t\\t//If the target is not present then it means it\\'s first occurence is -1. So we have to return empty array.\\n        if(firstoccur<0)\\n            return res;\\n        for(int i=firstoccur;i<=lastoccur;i++)\\n        {\\n            res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207781,
                "title": "o-n-approach-java-solution-well-described",
                "content": "\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> res  = new ArrayList<>();\\n        int len = nums.length;\\n        int prev=0;\\n        \\n        // First we are counting how many numbers are there in arr which are less than target \\n        \\n        for(int i=0;i<len;i++){\\n            if(nums[i]<target){\\n                prev++;\\n            }\\n        }\\n        \\n        // After we\\'ll check how many targets are present in the arr than we\\'ll add the prev \\n        // Count and keep on adding one \\n        \\n        \\n        // If the worst case is 100 elements in the array \\n        // This code will take only 200 cpu cycles or you could say O(2n) which is O(n)\\n        \\n        // If we sort the array first than finding the target it would cost us 100*log2(100) \\n        // Which is somewhere around 600 or more cpu cylces plus searching the element\\n        \\n        for(int i=0;i<len;i++){\\n            if(nums[i]==target){\\n                res.add(prev);\\n                prev++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> res  = new ArrayList<>();\\n        int len = nums.length;\\n        int prev=0;\\n        \\n        // First we are counting how many numbers are there in arr which are less than target \\n        \\n        for(int i=0;i<len;i++){\\n            if(nums[i]<target){\\n                prev++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2120009,
                "title": "java-o-n-one-loop",
                "content": "```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n        int count = 0;\\n        int smallernumbers = 0;\\n        for (int i : nums) {\\n            if (i < target)\\n                smallernumbers++;\\n            else if (i == target)\\n                count++;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 1, j = smallernumbers; i <= count; i++, j++) {\\n            list.add(j);\\n        }\\n        return list;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n        int count = 0;\\n        int smallernumbers = 0;\\n        for (int i : nums) {\\n            if (i < target)\\n                smallernumbers++;\\n            else if (i == target)\\n                count++;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 1, j = smallernumbers; i <= count; i++, j++) {\\n            list.add(j);\\n        }\\n        return list;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103892,
                "title": "python-o-n-no-sorting",
                "content": "(If we sort nums first: nums.sort() = [1,2,3,4,6,6,8] --> O(nlogn) )\\n\\nMy solution:\\n- less_target: num of values that are less than the target (same as the number of values before the target after sorting)\\n- n_target: num of values that are equal to the target\\nex: nums = [1,3,2,4,6,8,6], target = 6       \\n\\nless_target = 4, n_target = 2 (traverse the list --> O(n))\\n=> indices = [less_target + 0, less_target + 1] = [4, 5] (create the result list --> O(n))\\n\\nclass Solution:\\n\\n\\tdef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        less_target = 0\\n        n_target = 0\\n        for value in nums:\\n            if value < target: \\n                less_target += 1\\n            if value == target:\\n                n_target += 1\\n\\t\\t\\t\\t\\n        result = [less_target+i for i in range(n_target)]\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "(If we sort nums first: nums.sort() = [1,2,3,4,6,6,8] --> O(nlogn) )\\n\\nMy solution:\\n- less_target: num of values that are less than the target (same as the number of values before the target after sorting)\\n- n_target: num of values that are equal to the target\\nex: nums = [1,3,2,4,6,8,6], target = 6       \\n\\nless_target = 4, n_target = 2 (traverse the list --> O(n))\\n=> indices = [less_target + 0, less_target + 1] = [4, 5] (create the result list --> O(n))\\n\\nclass Solution:\\n\\n\\tdef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        less_target = 0\\n        n_target = 0\\n        for value in nums:\\n            if value < target: \\n                less_target += 1\\n            if value == target:\\n                n_target += 1\\n\\t\\t\\t\\t\\n        result = [less_target+i for i in range(n_target)]\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2063460,
                "title": "python-solution-using-sort-and-list-comprehension",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        return [i for i in range(len(nums)) if nums[i] == target ]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        return [i for i in range(len(nums)) if nums[i] == target ]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2016083,
                "title": "1ms-97-faster-simple-o-n-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n         int count=0,small=0;\\n        for(int num : nums){\\n            if(num==target)count++;\\n            else if(num<target)small++;\\n        }\\n        \\n        List<Integer>list=new ArrayList<>();\\n        while(count-- >0)list.add(small++);\\n        return list;\\n    }\\n}\\n```\\nTime : O(n) linear time\\nSpace : O(n) to store the result list\\n\\nPlease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n         int count=0,small=0;\\n        for(int num : nums){\\n            if(num==target)count++;\\n            else if(num<target)small++;\\n        }\\n        \\n        List<Integer>list=new ArrayList<>();\\n        while(count-- >0)list.add(small++);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903186,
                "title": "faster-than-99-34",
                "content": "```\\nclass Solution:\\n    def findMe(self, nums, target, Left):\\n        s = 0 \\n        e = len(nums) - 1 \\n        index = -1\\n        while s <=e:\\n            mid = (s + e)//2 \\n            if nums[mid] == target:\\n                index = mid \\n                if Left:\\n                    e = mid - 1 \\n                else:\\n                    s = mid + 1\\n            elif nums[mid] > target:\\n                e = mid - 1 \\n            else:\\n                s = mid + 1 \\n        return index\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        if len(nums) == 1 and nums[0] == target:\\n            return [0]\\n        elif len(nums) == 1 and nums[0] != target:\\n            return []\\n        nums.sort()\\n        left_index = self.findMe(nums, target, True)\\n        right_index = self.findMe(nums, target, False)\\n        if left_index == -1 and right_index == -1:\\n            return []\\n        else:\\n            return [ x for x in range(left_index, right_index+1)]\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMe(self, nums, target, Left):\\n        s = 0 \\n        e = len(nums) - 1 \\n        index = -1\\n        while s <=e:\\n            mid = (s + e)//2 \\n            if nums[mid] == target:\\n                index = mid \\n                if Left:\\n                    e = mid - 1 \\n                else:\\n                    s = mid + 1\\n            elif nums[mid] > target:\\n                e = mid - 1 \\n            else:\\n                s = mid + 1 \\n        return index\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        if len(nums) == 1 and nums[0] == target:\\n            return [0]\\n        elif len(nums) == 1 and nums[0] != target:\\n            return []\\n        nums.sort()\\n        left_index = self.findMe(nums, target, True)\\n        right_index = self.findMe(nums, target, False)\\n        if left_index == -1 and right_index == -1:\\n            return []\\n        else:\\n            return [ x for x in range(left_index, right_index+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881635,
                "title": "best-simple-code-c-0ms-100-faster-solution",
                "content": "\\n\\tclass Solution {\\n\\t public:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector <int> res;\\n        sort(nums.begin(),nums.end());\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]==target)\\n                {\\n                    res.push_back(i);\\n                }\\n            }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t public:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector <int> res;\\n        sort(nums.begin(),nums.end());\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]==target)\\n                {\\n                    res.push_back(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1828764,
                "title": "easy-c-68-faster-85-space",
                "content": "**Linear Search** \\n```\\nvector<int> targetIndices(vector<int>& nums, int target) {\\n    sort(nums.begin(),nums.end());\\n    vector<int> ans;\\n    for(int i=0;i<nums.size();++i){\\n        if(nums[i]==target) ans.push_back(i);\\n        else if(nums[i]>target) break;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> targetIndices(vector<int>& nums, int target) {\\n    sort(nums.begin(),nums.end());\\n    vector<int> ans;\\n    for(int i=0;i<nums.size();++i){\\n        if(nums[i]==target) ans.push_back(i);\\n        else if(nums[i]>target) break;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827433,
                "title": "simple-java-solution-using-binary-search",
                "content": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> res=new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        int firstIndex=BinarySearch(nums, target, true);\\n        int lastIndex=BinarySearch(nums, target, false);\\n        // res.add(firstIndex);\\n        // res.add(lastIndex);\\n        if(firstIndex==-1){\\n            return res;\\n        }\\n        for(int i=firstIndex;i<=lastIndex;i++){\\n            res.add(i);\\n        }\\n     return res;\\n    }\\n    public int  BinarySearch(int[] arr, int target, boolean firstIndex){\\n        int ans=-1;\\n        int start=0; int end=arr.length-1;\\n        while (start <= end){\\n            int mid=start+(end-start)/2;\\n            if(target < arr[mid]){\\n                end=mid-1;\\n            } else if(target > arr[mid]){\\n                start=mid+1;\\n            } else{\\n                ans= mid;\\n                if(firstIndex){\\n                    end=mid-1;\\n                } else{\\n                    start=mid+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> res=new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        int firstIndex=BinarySearch(nums, target, true);\\n        int lastIndex=BinarySearch(nums, target, false);\\n        // res.add(firstIndex);\\n        // res.add(lastIndex);\\n        if(firstIndex==-1){\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1819677,
                "title": "optimal-solution-count-smaller-and-equal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) \\n    {\\n        vector<int> res;\\n        int count=0;   //Stores nums[i]==target\\n        int pos=0;   //Stores nums[i]<target\\n        for(int i:nums)\\n        {\\n            count+=(i==target);\\n            pos+=(i<target);\\n        }\\n        while(count--)\\n            res.push_back(pos++);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Counting Sort"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) \\n    {\\n        vector<int> res;\\n        int count=0;   //Stores nums[i]==target\\n        int pos=0;   //Stores nums[i]<target\\n        for(int i:nums)\\n        {\\n            count+=(i==target);\\n            pos+=(i<target);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1800093,
                "title": "2-approaches-o-nlogn-o-n-binary-search-counting-c",
                "content": "**Method 1:**\\n**1. First sort the array.\\n2. Find the index of the target\\n3. Push it into the \"result\" vector.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> result;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Time Complexity : O(N log N)**\\n\\n**Method 2:**\\n1. Count the occurences of elements lesser then the target and freq of target elements.\\n  \\t\"small\" contains the number of element lesser than the target.\\n  \\t\"count\" contains the number of occurences of the target element.\\n2. Now run a loop from \"small\" ( means \"small\" elements are lesser than our target value, so our target value will come after \"small\" elements in sorted array ), upto \"count\".\\n3. Push the index into the \"result\" vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int small=0,count=0,k=0;\\n        for(auto n:nums) {\\n            if(n<target)    small++;                                        // calculates the frequency of elements lesser than the target\\n            if(n==target)   count++;                                        // calculate the number of occurences of the target element\\n        }\\n        vector<int> result(count);\\n        for(int i=small;i<small+count;i++)      \\n            result[k++]=i;\\n        return result;\\n    }\\n};\\n```\\n**Time Complexity : O(N)**\\n\\nPlease upvote \\uD83D\\uDC4D\\uD83C\\uDFFB : )",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> result;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int small=0,count=0,k=0;\\n        for(auto n:nums) {\\n            if(n<target)    small++;                                        // calculates the frequency of elements lesser than the target\\n            if(n==target)   count++;                                        // calculate the number of occurences of the target element\\n        }\\n        vector<int> result(count);\\n        for(int i=small;i<small+count;i++)      \\n            result[k++]=i;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744067,
                "title": "simple-loop-no-sorting",
                "content": "As sorting will be too easy we needed something faster than O(NlogN). So, we use counting sort.\\n\\nSimply count appearence of target value. And in parallel count values that will be on the left (less than target) of target values.\\n\\n```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        cnt_less = 0\\n        cnt = 0\\n        for val in nums:\\n            if val == target:\\n                cnt += 1\\n            elif val < target:\\n                cnt_less += 1\\n        return [i+cnt_less for i in range(cnt)]\\n```",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        cnt_less = 0\\n        cnt = 0\\n        for val in nums:\\n            if val == target:\\n                cnt += 1\\n            elif val < target:\\n                cnt_less += 1\\n        return [i+cnt_less for i in range(cnt)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1733182,
                "title": "python3-easiest-one-liner",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        return [i for i, v in enumerate(nums) if v == target]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        return [i for i, v in enumerate(nums) if v == target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706808,
                "title": "java-easy-understanding",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> arrList = new ArrayList<Integer>();\\n        for(int i=0; i<nums.length; i++){}\\n            if(nums[i] == target)\\n                arrList.add(i);\\n            if(nums[i] > target)\\n                break;\\n        }\\n        return arrList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> arrList = new ArrayList<Integer>();\\n        for(int i=0; i<nums.length; i++){}\\n            if(nums[i] == target)\\n                arrList.add(i);\\n            if(nums[i] > target)\\n                break;\\n        }\\n        return arrList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678761,
                "title": "c-solution-using-binary-search",
                "content": "class Solution {\\npublic:\\n    int upper(vector<int>&arr,int x){\\n        int ans=-1;\\n        int s=0,e=arr.size()-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==x){\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else if(arr[mid]<x)\\n                s=mid+1;\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n    int lower(vector<int>&arr,int x){\\n        int ans=-1;\\n        int s=0,e=arr.size()-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==x){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else if(arr[mid]<x)\\n                s=mid+1;\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int l=lower(nums,target);\\n        int u=upper(nums,target);\\n        vector<int>ans;\\n        if(l!=-1&&u!=-1)\\n        for(int i=l;i<=u;i++)\\n            ans.push_back(i);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int upper(vector<int>&arr,int x){\\n        int ans=-1;\\n        int s=0,e=arr.size()-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]==x){\\n                ans=mid;\\n                s=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1653153,
                "title": "c-easy-five-line-code",
                "content": "```\\n\\n```\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target ) {\\n       sort(begin(nums) , end(nums));\\n        int n = nums.size();\\n        vector <int>ans;\\n        for(int i =0; i<n;i++){\\n            if(target==nums[i])\\n                ans.push_back(i); \\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644062,
                "title": "python-3-o-n-time-o-1-space",
                "content": "There are several similar solutions posted but this is the most concise:\\n\\n```\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        less = equal = 0\\n        for n in nums:\\n            less += n < target\\n            equal += n == target\\n        return range(less, less+equal)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting Sort"
                ],
                "code": "```\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        less = equal = 0\\n        for n in nums:\\n            less += n < target\\n            equal += n == target\\n        return range(less, less+equal)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1643646,
                "title": "ruby-solution",
                "content": "![image](https://assets.leetcode.com/users/images/d400a97f-0b81-4207-a28a-31f4fb01be30_1640288856.5651648.png)\\n\\n```\\ndef target_indices(nums, target)\\n    less_than_count = 0\\n    target_count = 0\\n    nums.each do |n|\\n        less_than_count += n < target ? 1 : 0\\n        target_count += n == target ? 1 : 0\\n    end\\n    (less_than_count...less_than_count + target_count).to_a\\nend\\n```\\n\\nWe don\\'t have to sort the array. We can just do a single pass over the elements keeping track of how many are less than the target and how many times we encounter the target. Then, we can just create a range with `target_count` elements that starts at `less_than_count`.",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef target_indices(nums, target)\\n    less_than_count = 0\\n    target_count = 0\\n    nums.each do |n|\\n        less_than_count += n < target ? 1 : 0\\n        target_count += n == target ? 1 : 0\\n    end\\n    (less_than_count...less_than_count + target_count).to_a\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1633522,
                "title": "all-approaches-explained-c",
                "content": "1. **Complexity : O(nlogn +logn )**\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int first=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n       \\n        if(first==n||nums[first]!=target)\\n            return {};\\n        vector<int>ans;\\n        for(int i=first;i<n;i++)\\n        {\\n            if(nums[i]==target)\\n                ans.push_back(i);\\n            else\\n                break;\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nThe above  would be the best solution if the input given to us would be sorted, but since sorting increase the complexity by nlogn counting sort is the best solution for unsorted input.\\n2. **Complexity: O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n       \\n        int freq_smaller=0;\\n        int fre_target=0;\\n        for(auto i:nums)\\n        {\\n           \\n            if(i<target)\\n                freq_smaller++;\\n            else if(i==target)\\n                fre_target++;\\n            \\n        }\\n        \\n        vector<int>ans;\\n        int i=freq_smaller;\\n        while(fre_target--)\\n        {\\n            ans.push_back(freq_smaller++);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int first=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n       \\n        if(first==n||nums[first]!=target)\\n            return {};\\n        vector<int>ans;\\n        for(int i=first;i<n;i++)\\n        {\\n            if(nums[i]==target)\\n                ans.push_back(i);\\n            else\\n                break;\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n       \\n        int freq_smaller=0;\\n        int fre_target=0;\\n        for(auto i:nums)\\n        {\\n           \\n            if(i<target)\\n                freq_smaller++;\\n            else if(i==target)\\n                fre_target++;\\n            \\n        }\\n        \\n        vector<int>ans;\\n        int i=freq_smaller;\\n        while(fre_target--)\\n        {\\n            ans.push_back(freq_smaller++);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622944,
                "title": "easy-to-understand-for-beginners-do-try-it",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n                list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n                list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614427,
                "title": "php-simple-two-liner",
                "content": "class Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $target\\n     * @return Integer[]\\n     */\\n    function targetIndices($nums, $target) {\\n        sort($nums);\\n\\t\\t\\n        return array_keys($nums, $target);\\n    }\\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "class Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $target\\n     * @return Integer[]\\n     */\\n    function targetIndices($nums, $target) {\\n        sort($nums);\\n\\t\\t\\n        return array_keys($nums, $target);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1611382,
                "title": "golang-solutions-both-o-n-and-o-n-logn",
                "content": "Linear solution without sorting the input array **O(N).**\\n```\\nfunc targetIndices(nums []int, target int) []int {\\n  var ans []int\\n  \\n  a, i := 0, 0\\n  for _, num := range nums {\\n    if num < target {\\n      i++\\n    }\\n    \\n    if num == target {\\n      a++\\n    }\\n  }\\n  \\n  for l := 0; l < a; l++ {\\n    ans = append(ans, i)\\n    i++\\n  }\\n  \\n  return ans\\n}\\n```\\n\\nSorting the input array and then performing binary search on the target value **O(N logn).**\\n```\\nfunc targetIndices(nums []int, target int) []int {\\n  qs(nums, 0, len(nums)-1)\\n  \\n  firstIdx := binarySearch(nums, target,  true)\\n  lastIdx := binarySearch(nums, target, false)\\n  var ans []int\\n  \\n  if firstIdx == -1 || lastIdx == -1 {\\n    return ans\\n  }\\n\\n  for i := firstIdx; i <= lastIdx; i++ {\\n    ans = append(ans, i)\\n  }\\n\\n  return  ans\\n}\\n\\nfunc binarySearch(nums []int, target int, firstIdx bool) int {\\n  l := 0\\n  r := len(nums)-1\\n\\n  for l <= r {\\n    mid := l + (r - l) / 2\\n\\n    if (nums[mid] == target && firstIdx && ((mid > 0 && nums[mid] > nums[mid-1]) || (mid == 0))) {\\n      return mid\\n    }\\n\\n    if (nums[mid] == target && !firstIdx && ((mid < len(nums)-1 && nums[mid] < nums[mid+1]) || (mid == len(nums)-1))) {\\n      return mid\\n    }\\n\\n    if (nums[mid] == target && firstIdx && mid > 0 && nums[mid] == nums[mid-1]) {\\n      r = mid - 1\\n    }\\n\\n    if (nums[mid] == target && !firstIdx && mid < len(nums)-1 && nums[mid] == nums[mid+1]) {\\n      l = mid + 1\\n    }\\n\\n    if nums[mid] > target {\\n      r = mid -1\\n    }\\n\\n    if nums[mid] < target {\\n      l = mid + 1\\n    }\\n  }\\n  \\n  return -1\\n}\\n\\nfunc qs(nums []int, l, r int) {\\n  if l >= r {\\n    return\\n  }\\n\\n  pivotIdx := partition(nums, l, r)\\n  qs(nums, l, pivotIdx-1)\\n  qs(nums, pivotIdx+1, r)\\n}\\n\\nfunc partition(nums []int, l, r int) int {\\n  pivot := nums[r]\\n\\n  for i := l; i < r; i++ {\\n    if nums[i] < pivot {\\n      nums[l], nums[i] = nums[i], nums[l]\\n      l++\\n    }\\n  }\\n\\n  nums[r], nums[l] = nums[l], nums[r]\\n  return l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nfunc targetIndices(nums []int, target int) []int {\\n  var ans []int\\n  \\n  a, i := 0, 0\\n  for _, num := range nums {\\n    if num < target {\\n      i++\\n    }\\n    \\n    if num == target {\\n      a++\\n    }\\n  }\\n  \\n  for l := 0; l < a; l++ {\\n    ans = append(ans, i)\\n    i++\\n  }\\n  \\n  return ans\\n}\\n```\n```\\nfunc targetIndices(nums []int, target int) []int {\\n  qs(nums, 0, len(nums)-1)\\n  \\n  firstIdx := binarySearch(nums, target,  true)\\n  lastIdx := binarySearch(nums, target, false)\\n  var ans []int\\n  \\n  if firstIdx == -1 || lastIdx == -1 {\\n    return ans\\n  }\\n\\n  for i := firstIdx; i <= lastIdx; i++ {\\n    ans = append(ans, i)\\n  }\\n\\n  return  ans\\n}\\n\\nfunc binarySearch(nums []int, target int, firstIdx bool) int {\\n  l := 0\\n  r := len(nums)-1\\n\\n  for l <= r {\\n    mid := l + (r - l) / 2\\n\\n    if (nums[mid] == target && firstIdx && ((mid > 0 && nums[mid] > nums[mid-1]) || (mid == 0))) {\\n      return mid\\n    }\\n\\n    if (nums[mid] == target && !firstIdx && ((mid < len(nums)-1 && nums[mid] < nums[mid+1]) || (mid == len(nums)-1))) {\\n      return mid\\n    }\\n\\n    if (nums[mid] == target && firstIdx && mid > 0 && nums[mid] == nums[mid-1]) {\\n      r = mid - 1\\n    }\\n\\n    if (nums[mid] == target && !firstIdx && mid < len(nums)-1 && nums[mid] == nums[mid+1]) {\\n      l = mid + 1\\n    }\\n\\n    if nums[mid] > target {\\n      r = mid -1\\n    }\\n\\n    if nums[mid] < target {\\n      l = mid + 1\\n    }\\n  }\\n  \\n  return -1\\n}\\n\\nfunc qs(nums []int, l, r int) {\\n  if l >= r {\\n    return\\n  }\\n\\n  pivotIdx := partition(nums, l, r)\\n  qs(nums, l, pivotIdx-1)\\n  qs(nums, pivotIdx+1, r)\\n}\\n\\nfunc partition(nums []int, l, r int) int {\\n  pivot := nums[r]\\n\\n  for i := l; i < r; i++ {\\n    if nums[i] < pivot {\\n      nums[l], nums[i] = nums[i], nums[l]\\n      l++\\n    }\\n  }\\n\\n  nums[r], nums[l] = nums[l], nums[r]\\n  return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607754,
                "title": "rust-simple-solution-without-sort",
                "content": "```rust\\nimpl Solution {\\n    pub fn target_indices(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut target_count = 0;\\n        let mut smaller_count = 0;\\n\\n        for n in nums {\\n            if target == n {\\n                target_count += 1;\\n            } else if target > n {\\n                smaller_count += 1;\\n            }\\n        }\\n\\n        (smaller_count..smaller_count + target_count).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn target_indices(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut target_count = 0;\\n        let mut smaller_count = 0;\\n\\n        for n in nums {\\n            if target == n {\\n                target_count += 1;\\n            } else if target > n {\\n                smaller_count += 1;\\n            }\\n        }\\n\\n        (smaller_count..smaller_count + target_count).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604566,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public List<Integer> targetIndices(int[] n, int t) {\\n        int k=n.length;\\n        Arrays.sort(n);\\n        List<Integer> nm=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]>t)\\n                break;\\n            else if(n[i]==t)\\n                nm.add(i);\\n        }\\n        return nm;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> targetIndices(int[] n, int t) {\\n        int k=n.length;\\n        Arrays.sort(n);\\n        List<Integer> nm=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]>t)\\n                break;\\n            else if(n[i]==t)\\n                nm.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1604292,
                "title": "o-n-counting-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        int less = 0;\\n        int tar_cnt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            less += (nums[i]<target);\\n            tar_cnt += (nums[i]==target);\\n        }\\n        if(tar_cnt == 0) return ans;\\n        int startIdx = less;\\n        for(int i=0;i<tar_cnt;i++){\\n            ans.push_back(startIdx+i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        int less = 0;\\n        int tar_cnt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            less += (nums[i]<target);\\n            tar_cnt += (nums[i]==target);\\n        }\\n        if(tar_cnt == 0) return ans;\\n        int startIdx = less;\\n        for(int i=0;i<tar_cnt;i++){\\n            ans.push_back(startIdx+i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601081,
                "title": "python-o-n-by-counting-w-hint",
                "content": "Hint:\\n\\nThink of the sorting result and **observe the pattern of target index** after sorting.\\n\\n\\n---\\n\\n```\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        \\n        \\n        # Imagine nums get sorting in non-decreasing order\\n        # What we want is [n, n+1, ..., n + k - 1 ]\\n        #\\n        #               = range(counter_of_smaller : counter_of_smaller + counter_of_equal ) in python syntax\\n        \\n        \\'\\'\\'\\n        \\nNumber     A   B ...  C   target target  ... target     E       F         G   ...\\n        \\nIndex      0   1 ... n-1    n    n + 1   ... n + k-1    n+k   n+k+1     n+k+2 ...\\n        \\n        \\'\\'\\'\\n                \\n        # total count of number smaller than target, and total count of number equal to target.   \\n        count_of_smaller, count_of_equal = 0, 0\\n        \\n        for number in nums:\\n            \\n            if number < target:\\n                count_of_smaller += 1\\n                \\n            elif number == target:\\n                count_of_equal += 1\\n        \\n        return [ i for i in range(count_of_smaller, count_of_smaller + count_of_equal)]\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Counting"
                ],
                "code": "```\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        \\n        \\n        # Imagine nums get sorting in non-decreasing order\\n        # What we want is [n, n+1, ..., n + k - 1 ]\\n        #\\n        #               = range(counter_of_smaller : counter_of_smaller + counter_of_equal ) in python syntax\\n        \\n        \\'\\'\\'\\n        \\nNumber     A   B ...  C   target target  ... target     E       F         G   ...\\n        \\nIndex      0   1 ... n-1    n    n + 1   ... n + k-1    n+k   n+k+1     n+k+2 ...\\n        \\n        \\'\\'\\'\\n                \\n        # total count of number smaller than target, and total count of number equal to target.   \\n        count_of_smaller, count_of_equal = 0, 0\\n        \\n        for number in nums:\\n            \\n            if number < target:\\n                count_of_smaller += 1\\n                \\n            elif number == target:\\n                count_of_equal += 1\\n        \\n        return [ i for i in range(count_of_smaller, count_of_smaller + count_of_equal)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600575,
                "title": "find-target-indices-after-sorting-array",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector< int >& nums, int target) {\\n        int n= nums.size();\\n        vector< int > val;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i < n ;i++){\\n            if(nums[i]==target)\\n                val.insert(val.end(),i);\\n        }\\n        return val;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> targetIndices(vector< int >& nums, int target) {\\n        int n= nums.size();\\n        vector< int > val;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i < n ;i++){\\n            if(nums[i]==target)\\n                val.insert(val.end(),i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1599868,
                "title": "python-lower-bound-upper-bound",
                "content": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()  # sorting array\\n        return list(range(bisect_left(nums, target),bisect_right(nums, target)))  #return range from left most occurrence to rightmost occurrence\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()  # sorting array\\n        return list(range(bisect_left(nums, target),bisect_right(nums, target)))  #return range from left most occurrence to rightmost occurrence\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599851,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> result;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n                result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> result;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n                result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031110,
                "title": "best-optimized-solution-with-basic-approach-of-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n\\n        int start = 0;\\n        int end =nums.size()-1;\\n        int startIndex = -1;\\n      \\n        while(start<=end){\\n             int mid = (start+end)/2;\\n\\n             if(nums[mid]==target){\\n              startIndex =mid;\\n                end = mid-1;\\n             }\\n             else if(nums[mid]>target){\\n                 end = mid-1;\\n             }\\n             else {\\n                 start = mid+1;\\n             }\\n        }\\n\\n        start = 0;\\n        end =nums.size()-1;\\n        int endIndex =  -1;\\n        while(start<=end){\\n             int mid = (start+end)/2;\\n\\n             if(nums[mid]==target){\\n              endIndex =mid;\\n                start = mid+1;\\n             }\\n             else if(nums[mid]>target){\\n                 end = mid-1;\\n             }\\n             else {\\n                 start = mid+1;\\n             }\\n        }\\n\\n\\n\\n        vector<int>ans;\\n\\n        if(endIndex ==-1 && startIndex ==-1){\\n            return ans;\\n        }\\n        while(startIndex<=endIndex){\\n            ans.push_back(startIndex);\\n            startIndex++;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n\\n        int start = 0;\\n        int end =nums.size()-1;\\n        int startIndex = -1;\\n      \\n        while(start<=end){\\n             int mid = (start+end)/2;\\n\\n             if(nums[mid]==target){\\n              startIndex =mid;\\n                end = mid-1;\\n             }\\n             else if(nums[mid]>target){\\n                 end = mid-1;\\n             }\\n             else {\\n                 start = mid+1;\\n             }\\n        }\\n\\n        start = 0;\\n        end =nums.size()-1;\\n        int endIndex =  -1;\\n        while(start<=end){\\n             int mid = (start+end)/2;\\n\\n             if(nums[mid]==target){\\n              endIndex =mid;\\n                start = mid+1;\\n             }\\n             else if(nums[mid]>target){\\n                 end = mid-1;\\n             }\\n             else {\\n                 start = mid+1;\\n             }\\n        }\\n\\n\\n\\n        vector<int>ans;\\n\\n        if(endIndex ==-1 && startIndex ==-1){\\n            return ans;\\n        }\\n        while(startIndex<=endIndex){\\n            ans.push_back(startIndex);\\n            startIndex++;\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022412,
                "title": "find-target-indices-after-sorting-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList<Integer> lst=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n            lst.add(i);\\n        }\\n        return lst;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList<Integer> lst=new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n            lst.add(i);\\n        }\\n        return lst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981196,
                "title": "optimized-solution-with-explanation-c-c-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n This approach is based on the observation of a sorted array. In an array which is sorted in increasing order all the elements before val are less than val. So, to get the indices of val in a sorted array, instead of performing sort operation, we can simply count the elements less than val. If the count is x then val will start from x-th index (because of 0-based indexing). Follow the steps mentioned below: \\n\\nTraverse the array. Use variables to store the count of elements less than val (smallCount) and elements having a value same as val (sameCount).\\nIf the value of an element is less than val increment smallCount by one.\\nIf the value is same as val increment sameCount by one.\\nAfter traversal is complete, the indices will start from smallCount and end at (smallCount+sameCount-1)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }\\n    *returnSize=same;\\n    int*ans=(int*)malloc(sizeof(int)*same);\\n    int i=0;\\n    while(same--){\\n        ans[i++]=small++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* targetIndices(int* nums, int numsSize, int target, int* returnSize){\\n    int small=0,same=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i] < target) small++;\\n        if(nums[i] == target) same++;\\n    }\\n    *returnSize=same;\\n    int*ans=(int*)malloc(sizeof(int)*same);\\n    int i=0;\\n    while(same--){\\n        ans[i++]=small++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976455,
                "title": "aniruddha-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end() );\\n        int sz = nums.size();\\n        vector<int> v;\\n        for(int i = 0 ; i < sz ; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                v.push_back(i);\\n            }\\n\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end() );\\n        int sz = nums.size();\\n        vector<int> v;\\n        for(int i = 0 ; i < sz ; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                v.push_back(i);\\n            }\\n\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873025,
                "title": "beats-90-java-beginner-friendly-solution-easy-to-understand-code-writing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859185,
                "title": "c-easy-5-lines-killer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849381,
                "title": "no-searching-no-sorting-beats-100",
                "content": "# Intuition\\nwe dont need actual indices, we dont care about sequence or order so we don\\'t need sort.\\nbinary search \\n# Approach\\nJust count number of elements which are less than or equal to given target. say lessThanOrEqualCount\\nThen count number of elements which are strictly less than given target onlyLessThanCount\\n\\nif lessThanOrEqualCount = onlyLessThanCount: return empty\\nor else all numbers between them\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity: O(1)\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanEqual = 0\\n        onlyLess = 0\\n        for i in nums:\\n            if i <= target:\\n                lessThanEqual += 1\\n            if i < target:\\n                onlyLess += 1\\n        return list(range(onlyLess, lessThanEqual))\\n```\\n\\nPlease upvote if you like the solution.\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanEqual = 0\\n        onlyLess = 0\\n        for i in nums:\\n            if i <= target:\\n                lessThanEqual += 1\\n            if i < target:\\n                onlyLess += 1\\n        return list(range(onlyLess, lessThanEqual))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716800,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                res.append(i)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                res.append(i)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541391,
                "title": "simple-java-solution-for-beginners-2ms-beats-83-31",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> AL = new ArrayList();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) {\\n                AL.add(i);\\n            }\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> AL = new ArrayList();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) {\\n                AL.add(i);\\n            }\\n        }\\n        return AL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439317,
                "title": "binary-search-and-iteration-based-solution-for-finding-target-indices-in-sorted-array",
                "content": "\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code uses binary search to find the first and last occurrences of the target value in the sorted input array. It then iterates over the indices between these two occurrences and adds the ones that contain the target value to a list, which is then returned.\\n\\nThe algorithm first sorts the input array in non-decreasing order using the Arrays.sort method. Then, it uses two helper functions findFirst and findLast to find the first and last occurrences of the target value in the sorted array, respectively. Both functions use binary search to find the index of the target value in the array. The findFirst function returns the index of the first occurrence of the target value, or -1 if it is not found. The findLast function returns the index of the last occurrence of the target value, or -1 if it is not found.\\n\\nIf either the findFirst or findLast function returns -1, indicating that the target value does not exist in the array, the algorithm returns an empty list.\\n\\nIf the target value exists in the array, the algorithm initializes an empty list called targetIndices to store the indices where the target value occurs. It then iterates from the index of the first occurrence of the target value to the index of the last occurrence of the target value and adds the indices where the target value occurs to the targetIndices list.\\n\\nFinally, the algorithm returns the targetIndices list, which contains the indices of the target value in the sorted array in increasing order.\\n\\n# Complexity\\n- Time complexity: O((log n) * n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);  // sort the array in non-decreasing order\\n        \\n        // find the first and last occurrences of the target value using binary search\\n        int left = findFirst(nums, target);\\n        int right = findLast(nums, target);\\n        \\n        // if target value does not exist in the array, return an empty list\\n        if (left == -1 || right == -1) {\\n            return new ArrayList<Integer>();\\n        }\\n        \\n        List<Integer> targetIndices = new ArrayList<Integer>();  // initialize an empty list\\n        \\n        // iterate from left to right and append indices where the target value occurs\\n        for (int i = left; i <= right; i++) {\\n            if (nums[i] == target) {\\n                targetIndices.add(i);\\n            }\\n        }\\n        \\n        return targetIndices;  // return the list of target indices\\n    }\\n    \\n    // helper function to find the first occurrence of the target value using binary search\\n    private int findFirst(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return (left < nums.length && nums[left] == target) ? left : -1;\\n    }\\n    \\n    // helper function to find the last occurrence of the target value using binary search\\n    private int findLast(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return (right >= 0 && nums[right] == target) ? right : -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        Arrays.sort(nums);  // sort the array in non-decreasing order\\n        \\n        // find the first and last occurrences of the target value using binary search\\n        int left = findFirst(nums, target);\\n        int right = findLast(nums, target);\\n        \\n        // if target value does not exist in the array, return an empty list\\n        if (left == -1 || right == -1) {\\n            return new ArrayList<Integer>();\\n        }\\n        \\n        List<Integer> targetIndices = new ArrayList<Integer>();  // initialize an empty list\\n        \\n        // iterate from left to right and append indices where the target value occurs\\n        for (int i = left; i <= right; i++) {\\n            if (nums[i] == target) {\\n                targetIndices.add(i);\\n            }\\n        }\\n        \\n        return targetIndices;  // return the list of target indices\\n    }\\n    \\n    // helper function to find the first occurrence of the target value using binary search\\n    private int findFirst(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return (left < nums.length && nums[left] == target) ? left : -1;\\n    }\\n    \\n    // helper function to find the last occurrence of the target value using binary search\\n    private int findLast(int[] nums, int target) {\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return (right >= 0 && nums[right] == target) ? right : -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258059,
                "title": "find-target-indices-after-sorting-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int i;\\n        vector<int> ans;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        int i;\\n        vector<int> ans;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236405,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for( int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans.push_back(i);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for( int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans.push_back(i);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207691,
                "title": "java-javascript-solution-jw",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nJava:\\n```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n    Arrays.sort(nums);\\n    ArrayList<Integer> ans = new ArrayList<Integer>();\\n        \\n    for (int i=0;i < nums.length;i++) {\\n        if (nums[i] == target) {\\n            ans.add(i);\\n        }\\n    }\\n    return ans;   \\n}\\n```\\nJavascript:\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let ans = [];\\n        \\n    for (let i=0;i < nums.length;i++) {\\n        if (nums[i] === target) {\\n            ans.push(i);\\n        }\\n    }\\n    return ans;  \\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\npublic List<Integer> targetIndices(int[] nums, int target) {\\n    Arrays.sort(nums);\\n    ArrayList<Integer> ans = new ArrayList<Integer>();\\n        \\n    for (int i=0;i < nums.length;i++) {\\n        if (nums[i] == target) {\\n            ans.add(i);\\n        }\\n    }\\n    return ans;   \\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar targetIndices = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let ans = [];\\n        \\n    for (let i=0;i < nums.length;i++) {\\n        if (nums[i] === target) {\\n            ans.push(i);\\n        }\\n    }\\n    return ans;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163552,
                "title": "c-solution-using-selection-sort-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n\\n    vector<int> ans;\\n    int n=nums.size();    \\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            if (nums[j] < nums[i])\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (nums[i] == target)\\n        {\\n            ans.push_back(i);\\n        }\\n    }\\n    return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n\\n    vector<int> ans;\\n    int n=nums.size();    \\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            if (nums[j] < nums[i])\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (nums[i] == target)\\n        {\\n            ans.push_back(i);\\n        }\\n    }\\n    return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135428,
                "title": "easy-c-vector-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//sorting first\\n        vector<int>k;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)//comparing target values\\n            k.push_back(i);//pushing equal values in vector\\n        }\\n        return k;//returning vector output\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//sorting first\\n        vector<int>k;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)//comparing target values\\n            k.push_back(i);//pushing equal values in vector\\n        }\\n        return k;//returning vector output\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130957,
                "title": "4ms-easy-solution-with-simple-trick",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        \\n        int n = nums.size();\\n        int smaller = 0;\\n        int bigger = 0;\\n        \\n        for(int i: nums){\\n            if(i< target){\\n                smaller++;\\n            }else if(i> target){\\n                bigger++;\\n            }\\n        }\\n        \\n        for(int i= smaller ; i<= n- bigger-1 ;i++){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans ;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        \\n        int n = nums.size();\\n        int smaller = 0;\\n        int bigger = 0;\\n        \\n        for(int i: nums){\\n            if(i< target){\\n                smaller++;\\n            }else if(i> target){\\n                bigger++;\\n            }\\n        }\\n        \\n        for(int i= smaller ; i<= n- bigger-1 ;i++){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans ;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123390,
                "title": "find-target-indices-after-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        result=[]\\n        nums=sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                result.append(i)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        result=[]\\n        nums=sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                result.append(i)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025196,
                "title": "easy-linear-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> arr = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) {\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> arr = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) {\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726971,
                "title": "typescript-javascript-100-faster",
                "content": "```\\nfunction targetIndices(nums: number[], target: number): number[] {\\n    nums.sort((n1, n2) => n1 - n2);\\n    \\n    const res = [];\\n    for (let i = 0; i < nums.length && nums[i] <= target; i++) {\\n        if (nums[i] === target) {\\n            res.push(i);\\n        }\\n    }\\n    \\n    return res;\\n}\\n```\\n\\n<img alt=\"submission\" src=\"https://assets.leetcode.com/users/images/f144503f-d22f-4238-9522-a4ce3846b9c1_1666298415.6383977.png\" width=\"600px\"/>\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction targetIndices(nums: number[], target: number): number[] {\\n    nums.sort((n1, n2) => n1 - n2);\\n    \\n    const res = [];\\n    for (let i = 0; i < nums.length && nums[i] <= target; i++) {\\n        if (nums[i] === target) {\\n            res.push(i);\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703186,
                "title": "swift-binary-search-recursion",
                "content": "```\\n    class Solution {\\n        func targetIndices(_ nums: [Int], _ target: Int) -> [Int] {\\n            let nums = nums.sorted()\\n            return binarySearch(0, nums.count-1, nums, target)?.sorted() ?? []\\n        }\\n        \\n        func binarySearch(_ left: Int, _ right: Int, _ array: [Int], _ target: Int) -> [Int]? {\\n            if array.isEmpty { return nil }\\n            \\n            var result = [Int]()\\n            var left = left\\n            var right = right\\n            \\n            while left <= right {\\n                let middle = (left + right) / 2\\n                let item = array[middle]\\n                \\n                if item == target {\\n                    result.append(middle)\\n                    result += binarySearch(left, middle-1, array, target) ?? []\\n                    result += binarySearch(middle+1, right, array, target) ?? []\\n                    return result\\n                } else if item > target {\\n                    right = middle - 1\\n                } else {\\n                    left = middle + 1\\n                }\\n            }\\n            return result\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n    class Solution {\\n        func targetIndices(_ nums: [Int], _ target: Int) -> [Int] {\\n            let nums = nums.sorted()\\n            return binarySearch(0, nums.count-1, nums, target)?.sorted() ?? []\\n        }\\n        \\n        func binarySearch(_ left: Int, _ right: Int, _ array: [Int], _ target: Int) -> [Int]? {\\n            if array.isEmpty { return nil }\\n            \\n            var result = [Int]()\\n            var left = left\\n            var right = right\\n            \\n            while left <= right {\\n                let middle = (left + right) / 2\\n                let item = array[middle]\\n                \\n                if item == target {\\n                    result.append(middle)\\n                    result += binarySearch(left, middle-1, array, target) ?? []\\n                    result += binarySearch(middle+1, right, array, target) ?? []\\n                    return result\\n                } else if item > target {\\n                    right = middle - 1\\n                } else {\\n                    left = middle + 1\\n                }\\n            }\\n            return result\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688589,
                "title": "find-target-indices-after-sorting-array-java",
                "content": "```\\n\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> list = new ArrayList<>();\\n        boolean sort = false;\\n        while (!sort) { //sort with bubble sort\\n            sort = true;\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i-1] > nums[i]) {\\n                    int temp = nums[i];\\n                    nums[i] = nums[i-1];\\n                    nums[i-1] = temp;\\n                    sort = false;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) if (nums[i] == target) list.add(i);//add index of target\\n        return list;\\n    }\\n\\t\\n\\t```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> list = new ArrayList<>();\\n        boolean sort = false;\\n        while (!sort) { //sort with bubble sort\\n            sort = true;\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i-1] > nums[i]) {\\n                    int temp = nums[i];\\n                    nums[i] = nums[i-1];\\n                    nums[i-1] = temp;\\n                    sort = false;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) if (nums[i] == target) list.add(i);//add index of target\\n        return list;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2684487,
                "title": "c",
                "content": "int i,j,c,*p,k,s=0;\\n     for(i=0;i<numsSize;i++)\\n            if(nums[i]==target)\\n                s++;\\n    p=(int *)malloc(s*sizeof(int));\\n    for(i=0;i<numsSize-1;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n            if(nums[i]>nums[j])\\n            {\\n                c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            }\\n    }\\n    k=0;\\n    for(i=0;i<numsSize;i++)\\n            if(nums[i]==target)\\n            {\\n                p[k++]=i;\\n            }\\n    *returnSize=s;\\n    return p;",
                "solutionTags": [],
                "code": "int i,j,c,*p,k,s=0;\\n     for(i=0;i<numsSize;i++)\\n            if(nums[i]==target)\\n                s++;\\n    p=(int *)malloc(s*sizeof(int));\\n    for(i=0;i<numsSize-1;i++)\\n    {\\n        for(j=i+1;j<numsSize;j++)\\n            if(nums[i]>nums[j])\\n            {\\n                c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            }\\n    }\\n    k=0;\\n    for(i=0;i<numsSize;i++)\\n            if(nums[i]==target)\\n            {\\n                p[k++]=i;\\n            }\\n    *returnSize=s;\\n    return p;",
                "codeTag": "Unknown"
            },
            {
                "id": 2641845,
                "title": "python-binary-search",
                "content": "Perform binary search to find the leftmost and rightmost index range to the target. And for loop on the obtained range.\\n\\n**Time Complexity**\\n- $$O(nlogn)$$ Due to sorting\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n\\n        def binarySearchLeft(nums, target):\\n            l, r = 0, len(nums) - 1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] < target:\\n                    l = mid + 1\\n                \\n                else:\\n                    r = mid - 1\\n\\n            return l\\n\\n        def binarySearchRight(nums, target):\\n            l, r = 0, len(nums) - 1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] <= target:\\n                    l = mid + 1\\n                \\n                else:\\n                    r = mid - 1\\n\\n            return r\\n\\n        left = binarySearchLeft(nums, target)\\n        right = binarySearchRight(nums, target)\\n        if left < right:\\n            return [i for i in range(left, right + 1)]\\n\\n        if left == right:\\n            return [left]\\n        \\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n\\n        def binarySearchLeft(nums, target):\\n            l, r = 0, len(nums) - 1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] < target:\\n                    l = mid + 1\\n                \\n                else:\\n                    r = mid - 1\\n\\n            return l\\n\\n        def binarySearchRight(nums, target):\\n            l, r = 0, len(nums) - 1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] <= target:\\n                    l = mid + 1\\n                \\n                else:\\n                    r = mid - 1\\n\\n            return r\\n\\n        left = binarySearchLeft(nums, target)\\n        right = binarySearchRight(nums, target)\\n        if left < right:\\n            return [i for i in range(left, right + 1)]\\n\\n        if left == right:\\n            return [left]\\n        \\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635861,
                "title": "easy-c-solution",
                "content": "**Please upvote if this helps :)**\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int>v;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int>v;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                v.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2631416,
                "title": "python-multiple-solutions-sorting-binary-search-and-without-sorting",
                "content": "## **1. SORT THEN SEARCH**\\n\\n```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n\\t\\t# Sort the array\\n        nums.sort()\\n        \\n        output = []\\n        \\n\\t\\t# Now store all the indices where we get target element\\n        for i, num in enumerate(nums): \\n            if num == target: output.append(i)\\n            \\n        return output\\n```\\n\\n\\n## **2. FIND THE FIRST OCCURANCE AND THEN STORE THE INDICES**\\n```\\nclass Solution:\\n\\n    # First Occurance of an element in the sorted array\\n    def firstOccurance(self, arr, target):\\n        start = 0\\n        end = len(arr) - 1\\n        result = -1\\n        \\n        while start <= end:\\n            mid = (start + (end  - start) // 2)\\n            if arr[mid] == target:\\n                result = mid\\n                end = mid - 1\\n            elif arr[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return result\\n        \\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        \\n        # Get the first occurance of the target in the given array\\n        start = self.firstOccurance(nums, target)\\n        \\n        output = []\\n        \\n        # If target isn\\'t present in the array\\n        if start == -1: return output\\n        \\n        # Otherwise, start loop from the first index where target appeared \\n        # Then keep adding the valid indices to output\\n        while(start < len(nums) and nums[start] == target):\\n            output.append(start)\\n            start += 1\\n            \\n        return output\\n        \\n```\\n\\n## **3. FIND THE FIRST AND LAST OCCURANCE AND THEN STORE INDICES**\\n\\n```\\n# First Occurance of an element in the sorted array\\n    def firstOccurance(self, arr, target):\\n        start = 0\\n        end = len(arr) - 1\\n        result = -1\\n        \\n        while start <= end:\\n            mid = (start + (end  - start) // 2)\\n            if arr[mid] == target:\\n                result = mid\\n                end = mid - 1\\n            elif arr[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return result\\n    \\n    # Last Occurance of an element in the sorted array\\n    def lastOccurance(self, arr, target):\\n        start = 0\\n        end = len(arr) - 1\\n        result = -1\\n        \\n        while start <= end:\\n            mid = (start + (end  - start) // 2)\\n            if arr[mid] == target:\\n                result = mid\\n                start = mid + 1\\n            elif arr[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return result\\n        \\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        first, last = self.firstOccurance(nums, target), self.lastOccurance(nums, target)\\n        \\n        output = []\\n        if first == -1: return output\\n        \\n\\t\\t# Store all the indices between first and last index in the output array\\n        for i in range(first, last+1): output.append(i)\\n            \\n        return output\\n```\\n\\n\\n## **4. WITHOUT SORTING**\\n\\n```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        # Elements smaller than target\\n        # Number of times target appears\\n        smaller = 0\\n        freq = 0\\n        \\n        for num in nums:\\n            if num < target: smaller += 1\\n            if num == target: freq += 1\\n                \\n        # Output to return\\n        output = []\\n        \\n        # Starting index of target in sorted list = smaller\\n        # And since it appears \\'freq\\' times, just run a loop from 0 to freq \\n        # And in each iteration, put smaller++ in output\\n        for i in range(freq): \\n            output.append(smaller)\\n            smaller += 1\\n        \\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n\\t\\t# Sort the array\\n        nums.sort()\\n        \\n        output = []\\n        \\n\\t\\t# Now store all the indices where we get target element\\n        for i, num in enumerate(nums): \\n            if num == target: output.append(i)\\n            \\n        return output\\n```\n```\\nclass Solution:\\n\\n    # First Occurance of an element in the sorted array\\n    def firstOccurance(self, arr, target):\\n        start = 0\\n        end = len(arr) - 1\\n        result = -1\\n        \\n        while start <= end:\\n            mid = (start + (end  - start) // 2)\\n            if arr[mid] == target:\\n                result = mid\\n                end = mid - 1\\n            elif arr[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return result\\n        \\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        \\n        # Get the first occurance of the target in the given array\\n        start = self.firstOccurance(nums, target)\\n        \\n        output = []\\n        \\n        # If target isn\\'t present in the array\\n        if start == -1: return output\\n        \\n        # Otherwise, start loop from the first index where target appeared \\n        # Then keep adding the valid indices to output\\n        while(start < len(nums) and nums[start] == target):\\n            output.append(start)\\n            start += 1\\n            \\n        return output\\n        \\n```\n```\\n# First Occurance of an element in the sorted array\\n    def firstOccurance(self, arr, target):\\n        start = 0\\n        end = len(arr) - 1\\n        result = -1\\n        \\n        while start <= end:\\n            mid = (start + (end  - start) // 2)\\n            if arr[mid] == target:\\n                result = mid\\n                end = mid - 1\\n            elif arr[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return result\\n    \\n    # Last Occurance of an element in the sorted array\\n    def lastOccurance(self, arr, target):\\n        start = 0\\n        end = len(arr) - 1\\n        result = -1\\n        \\n        while start <= end:\\n            mid = (start + (end  - start) // 2)\\n            if arr[mid] == target:\\n                result = mid\\n                start = mid + 1\\n            elif arr[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return result\\n        \\n        \\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n        first, last = self.firstOccurance(nums, target), self.lastOccurance(nums, target)\\n        \\n        output = []\\n        if first == -1: return output\\n        \\n\\t\\t# Store all the indices between first and last index in the output array\\n        for i in range(first, last+1): output.append(i)\\n            \\n        return output\\n```\n```\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        # Elements smaller than target\\n        # Number of times target appears\\n        smaller = 0\\n        freq = 0\\n        \\n        for num in nums:\\n            if num < target: smaller += 1\\n            if num == target: freq += 1\\n                \\n        # Output to return\\n        output = []\\n        \\n        # Starting index of target in sorted list = smaller\\n        # And since it appears \\'freq\\' times, just run a loop from 0 to freq \\n        # And in each iteration, put smaller++ in output\\n        for i in range(freq): \\n            output.append(smaller)\\n            smaller += 1\\n        \\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615848,
                "title": "swift-solution-95-faster",
                "content": "```\\nclass Solution {\\n    func targetIndices(_ nums: [Int], _ target: Int) -> [Int] {\\n        var nums = nums.filter { $0 <= target }.sorted()\\n        var result: [Int] = []\\n        for i in stride(from: 0, to: nums.count, by: 1) {\\n            if nums[i] == target { result.append(i) }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func targetIndices(_ nums: [Int], _ target: Int) -> [Int] {\\n        var nums = nums.filter { $0 <= target }.sorted()\\n        var result: [Int] = []\\n        for i in stride(from: 0, to: nums.count, by: 1) {\\n            if nums[i] == target { result.append(i) }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591208,
                "title": "python-o-n-solution-no-sorting-needed",
                "content": "We can simply count the nubmer of elements equalto the target and the number of elements less than the target to calculate our results.\\n\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanCount = 0\\n        equalCount = 0\\n        \\n        for x in nums:\\n            if x == target:\\n                equalCount += 1\\n            elif x < target:\\n                lessThanCount += 1\\n                \\n        results = []\\n        \\n        l = lessThanCount\\n        r = l + equalCount\\n        for i in range(l, r):\\n            results.append(i)\\n            \\n        return results\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanCount = 0\\n        equalCount = 0\\n        \\n        for x in nums:\\n            if x == target:\\n                equalCount += 1\\n            elif x < target:\\n                lessThanCount += 1\\n                \\n        results = []\\n        \\n        l = lessThanCount\\n        r = l + equalCount\\n        for i in range(l, r):\\n            results.append(i)\\n            \\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586556,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n           \\n       int smaller = 0;\\n        int equal = 0;\\n        for (int num : nums) \\n        {\\n            if (num < target) \\n                smaller++;\\n            else \\n                if (num == target) \\n                equal++;\\n            \\n        }\\n\\t\\tList<Integer> indices = new ArrayList<>(equal);\\n        for (int i = smaller; i < smaller+equal; i++) {\\n            indices.add(i);\\n        }\\n        return indices;\\n    \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n           \\n       int smaller = 0;\\n        int equal = 0;\\n        for (int num : nums) \\n        {\\n            if (num < target) \\n                smaller++;\\n            else \\n                if (num == target) \\n                equal++;\\n            \\n        }\\n\\t\\tList<Integer> indices = new ArrayList<>(equal);\\n        for (int i = smaller; i < smaller+equal; i++) {\\n            indices.add(i);\\n        }\\n        return indices;\\n    \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584719,
                "title": "java-best-solution-time-o-n-with-one-loop",
                "content": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        // Count of elements that equal target\\n        int counter = 0;\\n        // Count of elements that lesser than target\\n        int lessCounter = 0;\\n        for(int num : nums)\\n            if(num == target)\\n                counter++;\\n            else if(num < target)\\n                lessCounter++;\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < counter; i++)\\n            result.add(lessCounter++);\\n            \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        // Count of elements that equal target\\n        int counter = 0;\\n        // Count of elements that lesser than target\\n        int lessCounter = 0;\\n        for(int num : nums)\\n            if(num == target)\\n                counter++;\\n            else if(num < target)\\n                lessCounter++;\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < counter; i++)\\n            result.add(lessCounter++);\\n            \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563445,
                "title": "c-solution-easiest-approach-binary-search-sort-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& v, int x) {\\n        sort(v.begin(), v.end());\\n        \\n        int min=binarySearch(v, x, true);\\n        int max;\\n        if(min!=-1)\\n        {\\n            max=binarySearch(v, x, false);\\n        }\\n        else\\n        {\\n            return {};\\n        }\\n\\n        vector <int> res;\\n        for(int i=min; i<=max; i++)\\n        {\\n            res.push_back(i);\\n        }\\n        \\n        return res;  \\n    }\\n    \\n    int binarySearch(vector<int>& v, int x, bool isMin)\\n    {\\n        int lb=0;\\n        int ub=v.size()-1;\\n        int ans=-1;\\n        while(lb<=ub)\\n        {\\n            int mid=lb+(ub-lb)/2;\\n            \\n            if(v[mid]==x)\\n            {\\n                ans=mid;\\n                if(isMin)\\n                    ub=mid-1;\\n                else\\n                    lb=mid+1;\\n            }\\n            \\n            else if(v[mid]>x)\\n                ub=mid-1;\\n            else\\n                lb=mid+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& v, int x) {\\n        sort(v.begin(), v.end());\\n        \\n        int min=binarySearch(v, x, true);\\n        int max;\\n        if(min!=-1)\\n        {\\n            max=binarySearch(v, x, false);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2559370,
                "title": "c-solution-simple",
                "content": "class Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        \\n        vector<int>v;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i<nums.size(); i++){\\n            if(target == nums[i])\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        \\n        vector<int>v;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i<nums.size(); i++){\\n            if(target == nums[i])\\n                v.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2543556,
                "title": "c-easy-and-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                ans.push_back(i);\\n            if(nums[i] > target)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if(nums[i] == target)\\n                ans.push_back(i);\\n            if(nums[i] > target)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511903,
                "title": "pyhton-simple-solution",
                "content": "```\\n\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n    \\n        l, r= 0, len(nums) - 1\\n        myArray=[]\\n    \\n        while l<=r:\\n            mid = (l+r)//2\\n            if nums[mid]<target:\\n                l = mid + 1\\n            if nums[mid]>target:\\n                r = mid-1\\n            if nums[mid]==target:\\n                \\n                if nums[l]<target:\\n                    l = l + 1\\n                if nums[r]>target:\\n                    r = r -1 \\n                if nums[l]==target and nums[r]==target:\\n                    myArray.append(l)\\n                    l+=1\\n        return myArray\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n\\ndef targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        nums.sort()\\n    \\n        l, r= 0, len(nums) - 1\\n        myArray=[]\\n    \\n        while l<=r:\\n            mid = (l+r)//2\\n            if nums[mid]<target:\\n                l = mid + 1\\n            if nums[mid]>target:\\n                r = mid-1\\n            if nums[mid]==target:\\n                \\n                if nums[l]<target:\\n                    l = l + 1\\n                if nums[r]>target:\\n                    r = r -1 \\n                if nums[l]==target and nums[r]==target:\\n                    myArray.append(l)\\n                    l+=1\\n        return myArray\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2510826,
                "title": "c-simple-runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n    \\n        vector<int> v1;\\n        sort(nums.begin(),nums.end());        //sorting of nums\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==target)   v1.push_back(i);         // if target is found at any location of nums then save that location to v1 vector\\n        return v1;\\n    }\\n};\\n```\\nIf you find my solution helpful, please upvote!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n    \\n        vector<int> v1;\\n        sort(nums.begin(),nums.end());        //sorting of nums\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==target)   v1.push_back(i);         // if target is found at any location of nums then save that location to v1 vector\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463523,
                "title": "python-solution-with-sorting-and-without-sorting",
                "content": "Two Solutions With Sorting and without sorting \\n***Without Sorting Solution***\\n```\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # without sorting\\n        smaller = 0\\n        larger = 0\\n        n = len(nums)\\n        index = []\\n        for i in range(0,n):\\n            if(nums[i]<target):\\n                smaller+=1\\n            elif(nums[i]>target):\\n                larger+=1\\n        for i in range(smaller,n-larger):\\n            index.append(i)    \\n        \\n        return index\\n```\\n***With Sorting Solution***\\n\\n```\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # with sorting\\n        smaller = 0\\n        larger = 0\\n        n = len(nums)\\n\\t\\tnums = sorted(nums)\\n        index = []\\n        for i in range(0,n):\\n            if(nums[i] == target):\\n\\t\\t\\t\\tindex.append(i)\\n        return index\\n```\\n\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # without sorting\\n        smaller = 0\\n        larger = 0\\n        n = len(nums)\\n        index = []\\n        for i in range(0,n):\\n            if(nums[i]<target):\\n                smaller+=1\\n            elif(nums[i]>target):\\n                larger+=1\\n        for i in range(smaller,n-larger):\\n            index.append(i)    \\n        \\n        return index\\n```\n```\\nclass Solution(object):\\n    def targetIndices(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # with sorting\\n        smaller = 0\\n        larger = 0\\n        n = len(nums)\\n\\t\\tnums = sorted(nums)\\n        index = []\\n        for i in range(0,n):\\n            if(nums[i] == target):\\n\\t\\t\\t\\tindex.append(i)\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435248,
                "title": "3ms-96-beats-binary-search-sortinf",
                "content": "class Solution {\\npublic:\\n    int mid,ans = -1;\\n    void fi(vector<int> &arr,int &tgt,int &s,int &e){\\n        while(s<=e){\\n            mid = (e-s)/2+s;\\n            // cout<<mid;\\n            if(arr[mid]>=tgt){\\n                if(arr[mid]==tgt)\\n                ans = mid;\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }\\n    }\\n    void li(vector<int> &arr,int &tgt,int &s,int &e){\\n        while(s<=e){\\n            mid = (e-s)/2+s;\\n            // cout<<mid;\\n            if(arr[mid]<=tgt){\\n                if(arr[mid]==tgt)\\n                ans = mid;\\n                s = mid+1;\\n            }else{\\n                e = mid-1;\\n            }\\n        }\\n    }\\n    vector<int> targetIndices(vector<int>& arr, int &tgt) {\\n        sort(arr.begin(),arr.end());\\n        int s = 0, e = arr.size()-1;\\n        fi(arr,tgt,s,e);\\n        int first = ans;\\n        ans = -1;\\n        s = 0, e = arr.size()-1;\\n        // cout<<endl;\\n        li(arr,tgt,s,e);\\n        int last = ans;\\n        // cout<<endl;\\n        // cout<<first<<\" \"<<last;\\n        if(first==-1&&last == -1)return {};\\n        arr.clear();\\n        for(int s = first; s <= last; s++){\\n            arr.push_back(s);\\n        }\\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int mid,ans = -1;\\n    void fi(vector<int> &arr,int &tgt,int &s,int &e){\\n        while(s<=e){\\n            mid = (e-s)/2+s;\\n            // cout<<mid;\\n            if(arr[mid]>=tgt){\\n                if(arr[mid]==tgt)\\n                ans = mid;\\n                e = mid-1;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2421137,
                "title": "java-solution-two-approaches",
                "content": "##### 1. By sorting first\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// TC: O(nlogn) + O(n); SC: O(n) in worst case\\n```\\n\\n##### 2. Without sorting\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> ans = new ArrayList<>();\\n        int targetCount = 0, smallerElements = 0;\\n        \\n        \\n        // we count the number of times the target occurs\\n        // and the number of elements lesser than target\\n        for (int num : nums) {\\n            if (num == target) targetCount++;\\n            if (num < target) smallerElements++;\\n        }\\n        \\n        \\n        // If the array were sorted, the target would strart occupying indices from \\n        // the number equal to smallerElements (coz 0-indexed) \\n        // till (smallerElements + targetCount)\\n        // That would literally give us all the target indices serially\\n        \\n        for (int i = smallerElements; i < smallerElements + targetCount; i++) {\\n            ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n) in worst case\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// TC: O(nlogn) + O(n); SC: O(n) in worst case\\n```\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        List<Integer> ans = new ArrayList<>();\\n        int targetCount = 0, smallerElements = 0;\\n        \\n        \\n        // we count the number of times the target occurs\\n        // and the number of elements lesser than target\\n        for (int num : nums) {\\n            if (num == target) targetCount++;\\n            if (num < target) smallerElements++;\\n        }\\n        \\n        \\n        // If the array were sorted, the target would strart occupying indices from \\n        // the number equal to smallerElements (coz 0-indexed) \\n        // till (smallerElements + targetCount)\\n        // That would literally give us all the target indices serially\\n        \\n        for (int i = smallerElements; i < smallerElements + targetCount; i++) {\\n            ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n) in worst case\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415547,
                "title": "simple-solution-without-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& v, int t) {\\n        \\n        vector<int>ans;\\n        \\n      //  sort(v.begin(),v.end());\\n    \\n                \\n        int a=v.size();\\n        \\n        int x=0;\\n        int y=0;\\n        \\n        for(int i=0;i<a;i++){\\n            \\n          if(v[i]>t)x++;\\n          \\n          if(v[i]<t)y++;  \\n           \\n            \\n        }\\n        \\n        //cout<<x<<\" \"<<y<<endl;\\n        \\n        for(int i=y;i<a-x;i++){\\n            ans.push_back(i);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& v, int t) {\\n        \\n        vector<int>ans;\\n        \\n      //  sort(v.begin(),v.end());\\n    \\n                \\n        int a=v.size();\\n        \\n        int x=0;\\n        int y=0;\\n        \\n        for(int i=0;i<a;i++){\\n            \\n          if(v[i]>t)x++;\\n          \\n          if(v[i]<t)y++;  \\n           \\n            \\n        }\\n        \\n        //cout<<x<<\" \"<<y<<endl;\\n        \\n        for(int i=y;i<a-x;i++){\\n            ans.push_back(i);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2415546,
                "title": "simple-c-solution-without-sorting",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int less=0, more=0;\\n        \\n        for(int i: nums){\\n            if(i<target){\\n                less++;\\n            }\\n            else if(i>target){\\n                more++;\\n            }\\n        }\\n        \\n        int cTarget=nums.size()-less-more;\\n        \\n        if(cTarget==0){\\n            return ans;\\n        }\\n        \\n        for(int i=less;i<cTarget+less;i++){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int less=0, more=0;\\n        \\n        for(int i: nums){\\n            if(i<target){\\n                less++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2409862,
                "title": "easy-short-neat-clean-idea-explained",
                "content": "step 1: take one vector int type;\\nstep 2:sort the given vector;\\nstep 3: run a for loop till less than given vector\\'s size;\\nstep4: if```(nums[i]==target)``` then pushback the INDEX no in the taken vector;\\nstep 5: last step return the taken vector.\\n       \\u203C\\uFE0F HOPE YOU WILL LIKE IT \\u203C\\uFE0F\\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> index;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]==target){\\n                    index.push_back(i);   \\n                }\\n        }\\n        return index;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```(nums[i]==target)```\n```\\nclass Solution {\\npublic:\\n    vector<int> targetIndices(vector<int>& nums, int target) {\\n        vector<int> index;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]==target){\\n                    index.push_back(i);   \\n                }\\n        }\\n        return index;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1660460,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1576301,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1839346,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1736285,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 2057311,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1976046,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1966902,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1963556,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1940249,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1927602,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1660460,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1576301,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1839346,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1736285,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 2057311,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1976046,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1966902,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1963556,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1940249,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            },
            {
                "id": 1927602,
                "content": [
                    {
                        "username": "vivekrajyaguru",
                        "content": "After Reviewing the given problem, It is clearly not a binary search problem. you can easily solved it by using Loops with Condition. \\n\\nFor python 3, It can be easily solved using enumerate function. :) "
                    },
                    {
                        "username": "Buran007",
                        "content": "[@mukulojha](/mukulojha) \\u043D\\u0443 \\u0441\\u043B\\u0443\\u0448\\u0430\\u0439\\u0442\\u0435 \\u0440\\u0435\\u0448\\u0438\\u0442\\u044C \\u0437\\u0430 \\u041E(nlogn) \\u0438\\u043B\\u0438 \\u0437\\u0430 \\u041E(nlogn) provided that the solution voiced above is easier to implement\\n"
                    },
                    {
                        "username": "mukulojha",
                        "content": "Yeah true man. Why complicate it when it can be done in O(N) time.\\n"
                    },
                    {
                        "username": "friendfunction22",
                        "content": "analyzing the complexity, one can understand that there is surely no requirement of binary search here!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/find-target-indices-after-sorting-array/solutions/2199403/c-two-methods-with-explanation-o-n-and-o-n-log-n-approach-easy-to-understand/"
                    },
                    {
                        "username": "sjaskirat461",
                        "content": "One might think of applying binary search on sorted array to achieve O(log n) complexity, but don\\'t forget that sorting itself will make the complexity O(n*log n). \\n\\nIn the sorted array, all the elements smaller than the target will appear before it, so just count the no. of elements strictly smaller than the target, and also count the no. of occurrences of target.\\n\\nThen think where will you find the first occurrence of target  and the last occurrence."
                    },
                    {
                        "username": "rakeshsharmanv",
                        "content": "In this question we don\\'t need to implement binary search and we can implement linear search . "
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "So, I was just wondering of the alternative version of the same problem where in the aim would be to return the indices of the elements where the values matches the target but not necessarily in non- descending ordering and the array should be in ascending order                                                        So, if the question is  nums = [7,2,9,1,4,3,2]. The return values should be [1,6] or [6,1] anyhow ie: the position of the indices matching the target doesn\\'t matter and the nums given array should be sorted nums = [1,2,2,3,4,7,9]. If this were the case what is the best approach to solve the above problem.                                                                                                                               My thought process was to use randomized quick sort and check the values of the pivot in the same loop.                                                                                                                                      `class Solution:\\n    def swap(self,nums,i,j):\\n        temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        return nums\\n\\n    def solution(self,nums,low,high,indices,target):\\n        print(\"entering the solution func with low:\",low,\"high:\",high)\\n        if(low == high):\\n            # print(\"single element: low:\",low,\"high:\",high)\\n            if nums[low] == target:\\n                indices.append(low)\\n                # print(\"after adding element to the solution:\",indices)\\n        \\n        if(low<high):\\n            i = low\\n            j = low+1\\n            pivotidx = random.randint(low,high)\\n            pivot = nums[pivotidx]\\n            nums = self.swap(nums,i,pivotidx)\\n\\n            # print(\"pivot picked is \",pivot,\"at index : \",pivotidx)\\n            # print(\"array after swapping : \",nums)\\n\\n            while(j<=high):\\n\\n                while(j<=high and nums[j]>pivot):\\n                    j = j+1\\n                \\n                if(j<=high):\\n                    i = i+1\\n                    # print(\"swapping indices\",i,\"and\",j)\\n                    nums = self.swap(nums,i,j)\\n                    j = j+1\\n                # print(\"after swap : \",nums)\\n\\n            # print(\"current array after comparisson \",nums,i)\\n            \\n            self.swap(nums,i,low)\\n\\n            # print(\"current array after  swaping low :\",low,\"and i:\",i,\"is : \",nums)\\n            \\n            if(nums[i] == target):\\n                indices.append(i)\\n                # print(\"after adding element to the solution:\",indices)\\n\\n            \\n            self.solution(nums,low,i-1,indices,target)\\n            self.solution(nums,i+1,high,indices,target)\\n\\n        # print(\"exited the solution function,\",low,\"high\",high)\\n\\n\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        indices = []\\n        low = 0\\n        high = len(nums)-1\\n        self.solution(nums,low,high,indices,target)\\n        print(nums,indices)\\n        return sorted(indices)\\n        `"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 can we do it with just linear search"
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "I am not sure if we can do it in linear time. As the solution requires sorting and sorting will take nlogn time. And even if we try to do it using some extra spaces, then also we need have the element x at position x, which without sorting would not be possible.\\n\\nBut still if some other solution exists, I would also like to explore them."
                    },
                    {
                        "username": "amanjaiswal159",
                        "content": "Even if it is marked as easy question for Binary search, a normal for loop would be easy."
                    },
                    {
                        "username": "Shivanshu1009",
                        "content": "Is there any approach which use binary search in this problem?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Hello ,I did this  question in easy way\\n\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n\\n        ans = []\\n\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                ans.append(i)\\n        return ans"
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "What\\'s the time complexity   O(nlog(n)) + O(n) \\n\\n"
                    },
                    {
                        "username": "ankush20386",
                        "content": "I am using binary search here but compiler is showing time limit exceeded  can anyone please explain why is it so?\n\nclass Solution {\n \npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        vector<int>ans;\n        sort(nums.begin(),nums.end());\n        if(nums.size()==0)\n        {\n            return ans;\n        }\n        int h=nums.size();\n        int l=0;\n        int mid=0;\n        while(l<h)\n        {\n            mid=(l+h)/2;\n            if(nums[mid]==target)\n            {\n                ans.push_back(mid);\n            }\n            if(nums[mid]>target)\n            {\n                h=mid-1;\n                mid=(l+h)/2;\n            }\n            if(nums[mid]<target)\n            {\n                l=mid+1;\n                mid=(l+h)/2;\n            }\n        }\n        if(ans.size()>1)\n        {\n            sort(ans.begin(),ans.end());\n        }\n        return ans;\n        \n    }\n};"
                    }
                ]
            }
        ]
    }
]